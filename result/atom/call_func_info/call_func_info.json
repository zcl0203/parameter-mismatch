[{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js","name":"stop","line":85,"func_location":"NativeWatcher.onDidChange.(unnamed_function_1)","func_start_line":82,"func_end_line":87,"args":[],"code":"    return new Disposable(() => {\r\n      sub.dispose()\r\n      if (this.emitter.listenerCountForEventName('did-change') === 0) {\r\n        this.stop()\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js","name":"NativeWatcher.stop","start_line":130,"end_line":142,"comment":[" Private: Stop the native watcher and release any operating system resources associated with it.",""," Has no effect if the watcher is not running."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"setState","line":38,"func_location":"AutoUpdateManager.initialize.(unnamed_function_1)","func_start_line":37,"func_end_line":41,"args":["ErrorState","message"],"code":"    autoUpdater.on('error', (event, message) => {\r\n      this.setState(ErrorState, message)\r\n      this.emitWindowEvent('update-error')\r\n      console.error(`Error Downloading Update: ${message}`)\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"AutoUpdateManager.setState","start_line":103,"end_line":108,"comment":[],"params":["state","errorMessage"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"emitWindowEvent","line":39,"func_location":"AutoUpdateManager.initialize.(unnamed_function_1)","func_start_line":37,"func_end_line":41,"args":[{"type":"string"}],"code":"    autoUpdater.on('error', (event, message) => {\r\n      this.setState(ErrorState, message)\r\n      this.emitWindowEvent('update-error')\r\n      console.error(`Error Downloading Update: ${message}`)\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"AutoUpdateManager.emitWindowEvent","start_line":97,"end_line":101,"comment":[],"params":["eventName","payload"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/title-bar.js","name":"updateTitle","line":17,"func_location":"TitleBar.constructor.(unnamed_function_1)","func_start_line":17,"func_end_line":17,"args":[null],"code":"    this.workspace.onDidChangeWindowTitle(() => this.updateTitle())\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/title-bar.js","name":"TitleBar.updateTitle","start_line":40,"end_line":42,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"save","line":437,"func_location":"Config.clear.(unnamed_function_1)","func_start_line":437,"func_end_line":437,"args":[null,{"type":"number"}],"code":"    this.requestSave = _.debounce(() => this.save(), 1)\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.save","start_line":923,"end_line":930,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js","name":"update","line":17,"func_location":"ReopenProjectMenuManager.constructor.(unnamed_function_1)","func_start_line":16,"func_end_line":18,"args":[],"code":"      config.onDidChange('core.reopenProjectMenuCount', ({oldValue, newValue}) => {\r\n        this.update()\r\n      }),\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js","name":"ReopenProjectMenuManager.update","start_line":45,"end_line":51,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js","name":"removeStyleElement","line":156,"func_location":"StyleManager.addStyleSheet.(unnamed_function_1)","func_start_line":156,"func_end_line":156,"args":["styleElement"],"code":"    return new Disposable(() => { this.removeStyleElement(styleElement) })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js","name":"StyleManager.removeStyleElement","start_line":178,"end_line":187,"comment":[],"params":["styleElement"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"retokenizeLines","line":36,"func_location":"TextMateLanguageMode.constructor.(unnamed_function_1)","func_start_line":36,"func_end_line":36,"args":[null],"code":"    this.disposables.add(this.grammar.onDidUpdate(() => this.retokenizeLines()))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.retokenizeLines","start_line":253,"end_line":263,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"refreshIndex","line":96,"func_location":"GitRepository.constructor.onWindowFocus.(unnamed_function_1)","func_start_line":95,"func_end_line":98,"args":[],"code":"      const onWindowFocus = () => {\r\n        this.refreshIndex()\r\n        this.refreshStatus()\r\n      }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.refreshIndex","start_line":534,"end_line":536,"comment":[" Reread the index to update any values that have changed since the"," last time the index was read."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"refreshStatus","line":97,"func_location":"GitRepository.constructor.onWindowFocus.(unnamed_function_1)","func_start_line":95,"func_end_line":98,"args":[],"code":"      const onWindowFocus = () => {\r\n        this.refreshIndex()\r\n        this.refreshStatus()\r\n      }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.refreshStatus","start_line":540,"end_line":594,"comment":[" Refreshes the current git status in an outside process and asynchronously"," updates the relevant properties."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/context-menu.js","name":"createClickHandlers","line":29,"func_location":"ContextMenu.createClickHandlers.(unnamed_function_1)","func_start_line":16,"func_end_line":31,"args":["item.submenu"],"code":"    template.forEach(item => {\r\n      if (item.command) {\r\n        if (!item.commandDetail) item.commandDetail = {}\r\n        item.commandDetail.contextCommand = true\r\n        item.commandDetail.atomWindow = this.atomWindow\r\n        item.click = () => {\r\n          global.atomApplication.sendCommandToWindow(\r\n            item.command,\r\n            this.atomWindow,\r\n            item.commandDetail\r\n          )\r\n        }\r\n      } else if (item.submenu) {\r\n        this.createClickHandlers(item.submenu)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/context-menu.js","name":"ContextMenu.createClickHandlers","start_line":15,"end_line":32,"comment":[" It's necessary to build the event handlers in this process, otherwise"," closures are dragged across processes and failed to be garbage collected"," appropriately."],"params":["template"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/storage-folder.js","name":"pathForKey","line":15,"func_location":"StorageFolder.store.(unnamed_function_1)","func_start_line":13,"func_end_line":18,"args":["name"],"code":"    return new Promise((resolve, reject) => {\r\n      if (!this.path) return resolve()\r\n      fs.writeFile(this.pathForKey(name), JSON.stringify(object), 'utf8', error =>\r\n        error ? reject(error) : resolve()\r\n      )\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/storage-folder.js","name":"StorageFolder.pathForKey","start_line":42,"end_line":44,"comment":[],"params":["name"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js","name":"getActiveView","line":44,"func_location":"PaneElement.subscribeToDOMEvents.handleFocus.(unnamed_function_1)","func_start_line":33,"func_end_line":49,"args":[],"code":"    const handleFocus = event => {\r\n      if (\r\n        !(\r\n          this.isActivating ||\r\n          this.model.isDestroyed() ||\r\n          this.contains(event.relatedTarget)\r\n        )\r\n      ) {\r\n        this.model.focus()\r\n      }\r\n      if (event.target !== this) return\r\n      const view = this.getActiveView()\r\n      if (view) {\r\n        view.focus()\r\n        event.stopPropagation()\r\n      }\r\n    }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js","name":"PaneElement.getActiveView","start_line":205,"end_line":207,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js","name":"cloneMenuItem","line":93,"func_location":"cloneMenuItem.(unnamed_function_1)","func_start_line":93,"func_end_line":93,"args":[null],"code":"    item.submenu = item.submenu.map(submenuItem => cloneMenuItem(submenuItem))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js","name":"cloneMenuItem","start_line":75,"end_line":96,"comment":[],"params":["item"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"addProject","line":15,"func_location":"HistoryManager.constructor.(unnamed_function_1)","func_start_line":15,"func_end_line":15,"args":[null],"code":"    this.disposables.add(project.onDidChangePaths((projectPaths) => this.addProject(projectPaths)))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"HistoryManager.addProject","start_line":55,"end_line":68,"comment":[],"params":["paths","lastOpened"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":36,"func_location":"TextEditorElement.createdCallback.(unnamed_function_1)","func_start_line":36,"func_end_line":36,"args":[{"type":"string"},null],"code":"    this.addEventListener('focus', (event) => this.getComponent().didFocus(event))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"loadStylesheets","line":115,"func_location":"Package.finishLoading.(unnamed_function_1)","func_start_line":111,"func_end_line":119,"args":[],"code":"    this.measure('loadTime', () => {\r\n      this.path = path.join(this.packageManager.resourcePath, this.path)\r\n      ModuleCache.add(this.path, this.metadata)\r\n\r\n      this.loadStylesheets()\r\n      // Unfortunately some packages are accessing `@mainModulePath`, so we need\r\n      // to compute that variable eagerly also for preloaded packages.\r\n      this.getMainModulePath()\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.loadStylesheets","start_line":486,"end_line":490,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"getMainModulePath","line":118,"func_location":"Package.finishLoading.(unnamed_function_1)","func_start_line":111,"func_end_line":119,"args":[],"code":"    this.measure('loadTime', () => {\r\n      this.path = path.join(this.packageManager.resourcePath, this.path)\r\n      ModuleCache.add(this.path, this.metadata)\r\n\r\n      this.loadStylesheets()\r\n      // Unfortunately some packages are accessing `@mainModulePath`, so we need\r\n      // to compute that variable eagerly also for preloaded packages.\r\n      this.getMainModulePath()\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.getMainModulePath","start_line":786,"end_line":803,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js","name":"rejectSelector","line":70,"func_location":"SyntaxScopeMap.addSelector.(unnamed_function_1)","func_start_line":16,"func_end_line":96,"args":["selector"],"code":"    parser((parseResult) => {\r\n      for (let selectorNode of parseResult.nodes) {\r\n        let currentTable = null\r\n        let currentIndexValue = null\r\n\r\n        for (let i = selectorNode.nodes.length - 1; i >= 0; i--) {\r\n          const termNode = selectorNode.nodes[i]\r\n\r\n          switch (termNode.type) {\r\n            case 'tag':\r\n              if (!currentTable) currentTable = this.namedScopeTable\r\n              if (!currentTable[termNode.value]) currentTable[termNode.value] = {}\r\n              currentTable = currentTable[termNode.value]\r\n              if (currentIndexValue != null) {\r\n                if (!currentTable.indices) currentTable.indices = {}\r\n                if (!currentTable.indices[currentIndexValue]) currentTable.indices[currentIndexValue] = {}\r\n                currentTable = currentTable.indices[currentIndexValue]\r\n                currentIndexValue = null\r\n              }\r\n              break\r\n\r\n            case 'string':\r\n              if (!currentTable) currentTable = this.anonymousScopeTable\r\n              const value = termNode.value.slice(1, -1)\r\n              if (!currentTable[value]) currentTable[value] = {}\r\n              currentTable = currentTable[value]\r\n              if (currentIndexValue != null) {\r\n                if (!currentTable.indices) currentTable.indices = {}\r\n                if (!currentTable.indices[currentIndexValue]) currentTable.indices[currentIndexValue] = {}\r\n                currentTable = currentTable.indices[currentIndexValue]\r\n                currentIndexValue = null\r\n              }\r\n              break\r\n\r\n            case 'universal':\r\n              if (currentTable) {\r\n                if (!currentTable['*']) currentTable['*'] = {}\r\n                currentTable = currentTable['*']\r\n              } else {\r\n                if (!this.namedScopeTable['*']) {\r\n                  this.namedScopeTable['*'] = this.anonymousScopeTable['*'] = {}\r\n                }\r\n                currentTable = this.namedScopeTable['*']\r\n              }\r\n              if (currentIndexValue != null) {\r\n                if (!currentTable.indices) currentTable.indices = {}\r\n                if (!currentTable.indices[currentIndexValue]) currentTable.indices[currentIndexValue] = {}\r\n                currentTable = currentTable.indices[currentIndexValue]\r\n                currentIndexValue = null\r\n              }\r\n              break\r\n\r\n            case 'combinator':\r\n              if (currentIndexValue != null) {\r\n                rejectSelector(selector)\r\n              }\r\n\r\n              if (termNode.value === '>') {\r\n                if (!currentTable.parents) currentTable.parents = {}\r\n                currentTable = currentTable.parents\r\n              } else {\r\n                rejectSelector(selector)\r\n              }\r\n              break\r\n\r\n            case 'pseudo':\r\n              if (termNode.value === ':nth-child') {\r\n                currentIndexValue = termNode.nodes[0].nodes[0].value\r\n              } else {\r\n                rejectSelector(selector)\r\n              }\r\n              break\r\n\r\n            default:\r\n              rejectSelector(selector)\r\n          }\r\n        }\r\n\r\n        currentTable.result = result\r\n      }\r\n    }).process(selector)\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js","name":"rejectSelector","start_line":176,"end_line":178,"comment":[],"params":["selector"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js","name":"rejectSelector","line":77,"func_location":"SyntaxScopeMap.addSelector.(unnamed_function_1)","func_start_line":16,"func_end_line":96,"args":["selector"],"code":"    parser((parseResult) => {\r\n      for (let selectorNode of parseResult.nodes) {\r\n        let currentTable = null\r\n        let currentIndexValue = null\r\n\r\n        for (let i = selectorNode.nodes.length - 1; i >= 0; i--) {\r\n          const termNode = selectorNode.nodes[i]\r\n\r\n          switch (termNode.type) {\r\n            case 'tag':\r\n              if (!currentTable) currentTable = this.namedScopeTable\r\n              if (!currentTable[termNode.value]) currentTable[termNode.value] = {}\r\n              currentTable = currentTable[termNode.value]\r\n              if (currentIndexValue != null) {\r\n                if (!currentTable.indices) currentTable.indices = {}\r\n                if (!currentTable.indices[currentIndexValue]) currentTable.indices[currentIndexValue] = {}\r\n                currentTable = currentTable.indices[currentIndexValue]\r\n                currentIndexValue = null\r\n              }\r\n              break\r\n\r\n            case 'string':\r\n              if (!currentTable) currentTable = this.anonymousScopeTable\r\n              const value = termNode.value.slice(1, -1)\r\n              if (!currentTable[value]) currentTable[value] = {}\r\n              currentTable = currentTable[value]\r\n              if (currentIndexValue != null) {\r\n                if (!currentTable.indices) currentTable.indices = {}\r\n                if (!currentTable.indices[currentIndexValue]) currentTable.indices[currentIndexValue] = {}\r\n                currentTable = currentTable.indices[currentIndexValue]\r\n                currentIndexValue = null\r\n              }\r\n              break\r\n\r\n            case 'universal':\r\n              if (currentTable) {\r\n                if (!currentTable['*']) currentTable['*'] = {}\r\n                currentTable = currentTable['*']\r\n              } else {\r\n                if (!this.namedScopeTable['*']) {\r\n                  this.namedScopeTable['*'] = this.anonymousScopeTable['*'] = {}\r\n                }\r\n                currentTable = this.namedScopeTable['*']\r\n              }\r\n              if (currentIndexValue != null) {\r\n                if (!currentTable.indices) currentTable.indices = {}\r\n                if (!currentTable.indices[currentIndexValue]) currentTable.indices[currentIndexValue] = {}\r\n                currentTable = currentTable.indices[currentIndexValue]\r\n                currentIndexValue = null\r\n              }\r\n              break\r\n\r\n            case 'combinator':\r\n              if (currentIndexValue != null) {\r\n                rejectSelector(selector)\r\n              }\r\n\r\n              if (termNode.value === '>') {\r\n                if (!currentTable.parents) currentTable.parents = {}\r\n                currentTable = currentTable.parents\r\n              } else {\r\n                rejectSelector(selector)\r\n              }\r\n              break\r\n\r\n            case 'pseudo':\r\n              if (termNode.value === ':nth-child') {\r\n                currentIndexValue = termNode.nodes[0].nodes[0].value\r\n              } else {\r\n                rejectSelector(selector)\r\n              }\r\n              break\r\n\r\n            default:\r\n              rejectSelector(selector)\r\n          }\r\n        }\r\n\r\n        currentTable.result = result\r\n      }\r\n    }).process(selector)\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js","name":"rejectSelector","start_line":176,"end_line":178,"comment":[],"params":["selector"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js","name":"rejectSelector","line":85,"func_location":"SyntaxScopeMap.addSelector.(unnamed_function_1)","func_start_line":16,"func_end_line":96,"args":["selector"],"code":"    parser((parseResult) => {\r\n      for (let selectorNode of parseResult.nodes) {\r\n        let currentTable = null\r\n        let currentIndexValue = null\r\n\r\n        for (let i = selectorNode.nodes.length - 1; i >= 0; i--) {\r\n          const termNode = selectorNode.nodes[i]\r\n\r\n          switch (termNode.type) {\r\n            case 'tag':\r\n              if (!currentTable) currentTable = this.namedScopeTable\r\n              if (!currentTable[termNode.value]) currentTable[termNode.value] = {}\r\n              currentTable = currentTable[termNode.value]\r\n              if (currentIndexValue != null) {\r\n                if (!currentTable.indices) currentTable.indices = {}\r\n                if (!currentTable.indices[currentIndexValue]) currentTable.indices[currentIndexValue] = {}\r\n                currentTable = currentTable.indices[currentIndexValue]\r\n                currentIndexValue = null\r\n              }\r\n              break\r\n\r\n            case 'string':\r\n              if (!currentTable) currentTable = this.anonymousScopeTable\r\n              const value = termNode.value.slice(1, -1)\r\n              if (!currentTable[value]) currentTable[value] = {}\r\n              currentTable = currentTable[value]\r\n              if (currentIndexValue != null) {\r\n                if (!currentTable.indices) currentTable.indices = {}\r\n                if (!currentTable.indices[currentIndexValue]) currentTable.indices[currentIndexValue] = {}\r\n                currentTable = currentTable.indices[currentIndexValue]\r\n                currentIndexValue = null\r\n              }\r\n              break\r\n\r\n            case 'universal':\r\n              if (currentTable) {\r\n                if (!currentTable['*']) currentTable['*'] = {}\r\n                currentTable = currentTable['*']\r\n              } else {\r\n                if (!this.namedScopeTable['*']) {\r\n                  this.namedScopeTable['*'] = this.anonymousScopeTable['*'] = {}\r\n                }\r\n                currentTable = this.namedScopeTable['*']\r\n              }\r\n              if (currentIndexValue != null) {\r\n                if (!currentTable.indices) currentTable.indices = {}\r\n                if (!currentTable.indices[currentIndexValue]) currentTable.indices[currentIndexValue] = {}\r\n                currentTable = currentTable.indices[currentIndexValue]\r\n                currentIndexValue = null\r\n              }\r\n              break\r\n\r\n            case 'combinator':\r\n              if (currentIndexValue != null) {\r\n                rejectSelector(selector)\r\n              }\r\n\r\n              if (termNode.value === '>') {\r\n                if (!currentTable.parents) currentTable.parents = {}\r\n                currentTable = currentTable.parents\r\n              } else {\r\n                rejectSelector(selector)\r\n              }\r\n              break\r\n\r\n            case 'pseudo':\r\n              if (termNode.value === ':nth-child') {\r\n                currentIndexValue = termNode.nodes[0].nodes[0].value\r\n              } else {\r\n                rejectSelector(selector)\r\n              }\r\n              break\r\n\r\n            default:\r\n              rejectSelector(selector)\r\n          }\r\n        }\r\n\r\n        currentTable.result = result\r\n      }\r\n    }).process(selector)\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js","name":"rejectSelector","start_line":176,"end_line":178,"comment":[],"params":["selector"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js","name":"rejectSelector","line":90,"func_location":"SyntaxScopeMap.addSelector.(unnamed_function_1)","func_start_line":16,"func_end_line":96,"args":["selector"],"code":"    parser((parseResult) => {\r\n      for (let selectorNode of parseResult.nodes) {\r\n        let currentTable = null\r\n        let currentIndexValue = null\r\n\r\n        for (let i = selectorNode.nodes.length - 1; i >= 0; i--) {\r\n          const termNode = selectorNode.nodes[i]\r\n\r\n          switch (termNode.type) {\r\n            case 'tag':\r\n              if (!currentTable) currentTable = this.namedScopeTable\r\n              if (!currentTable[termNode.value]) currentTable[termNode.value] = {}\r\n              currentTable = currentTable[termNode.value]\r\n              if (currentIndexValue != null) {\r\n                if (!currentTable.indices) currentTable.indices = {}\r\n                if (!currentTable.indices[currentIndexValue]) currentTable.indices[currentIndexValue] = {}\r\n                currentTable = currentTable.indices[currentIndexValue]\r\n                currentIndexValue = null\r\n              }\r\n              break\r\n\r\n            case 'string':\r\n              if (!currentTable) currentTable = this.anonymousScopeTable\r\n              const value = termNode.value.slice(1, -1)\r\n              if (!currentTable[value]) currentTable[value] = {}\r\n              currentTable = currentTable[value]\r\n              if (currentIndexValue != null) {\r\n                if (!currentTable.indices) currentTable.indices = {}\r\n                if (!currentTable.indices[currentIndexValue]) currentTable.indices[currentIndexValue] = {}\r\n                currentTable = currentTable.indices[currentIndexValue]\r\n                currentIndexValue = null\r\n              }\r\n              break\r\n\r\n            case 'universal':\r\n              if (currentTable) {\r\n                if (!currentTable['*']) currentTable['*'] = {}\r\n                currentTable = currentTable['*']\r\n              } else {\r\n                if (!this.namedScopeTable['*']) {\r\n                  this.namedScopeTable['*'] = this.anonymousScopeTable['*'] = {}\r\n                }\r\n                currentTable = this.namedScopeTable['*']\r\n              }\r\n              if (currentIndexValue != null) {\r\n                if (!currentTable.indices) currentTable.indices = {}\r\n                if (!currentTable.indices[currentIndexValue]) currentTable.indices[currentIndexValue] = {}\r\n                currentTable = currentTable.indices[currentIndexValue]\r\n                currentIndexValue = null\r\n              }\r\n              break\r\n\r\n            case 'combinator':\r\n              if (currentIndexValue != null) {\r\n                rejectSelector(selector)\r\n              }\r\n\r\n              if (termNode.value === '>') {\r\n                if (!currentTable.parents) currentTable.parents = {}\r\n                currentTable = currentTable.parents\r\n              } else {\r\n                rejectSelector(selector)\r\n              }\r\n              break\r\n\r\n            case 'pseudo':\r\n              if (termNode.value === ':nth-child') {\r\n                currentIndexValue = termNode.nodes[0].nodes[0].value\r\n              } else {\r\n                rejectSelector(selector)\r\n              }\r\n              break\r\n\r\n            default:\r\n              rejectSelector(selector)\r\n          }\r\n        }\r\n\r\n        currentTable.result = result\r\n      }\r\n    }).process(selector)\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js","name":"rejectSelector","start_line":176,"end_line":178,"comment":[],"params":["selector"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"showUpdateMenuItem","line":16,"func_location":"ApplicationMenu.constructor.(unnamed_function_1)","func_start_line":16,"func_end_line":16,"args":[{"type":"string"},null],"code":"    this.autoUpdateManager.on('state-changed', state => this.showUpdateMenuItem(state))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"ApplicationMenu.showUpdateMenuItem","start_line":109,"end_line":140,"comment":[" Sets the proper visible state the update menu items"],"params":["state"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip-manager.js","name":"hideTooltip","line":161,"func_location":"TooltipManager.add.disposable.(unnamed_function_1)","func_start_line":158,"func_end_line":174,"args":[],"code":"    const disposable = new Disposable(() => {\r\n      window.removeEventListener('resize', hideTooltip)\r\n\r\n      hideTooltip()\r\n      tooltip.destroy()\r\n\r\n      if (this.tooltips.has(target)) {\r\n        const tooltipsForTarget = this.tooltips.get(target)\r\n        const index = tooltipsForTarget.indexOf(tooltip)\r\n        if (index !== -1) {\r\n          tooltipsForTarget.splice(index, 1)\r\n        }\r\n        if (tooltipsForTarget.length === 0) {\r\n          this.tooltips.delete(target)\r\n        }\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip-manager.js","name":"TooltipManager.add.hideTooltip","start_line":150,"end_line":153,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/panel-container-element.js","name":"hideAllPanelsExcept","line":54,"func_location":"PanelContainerElement.panelAdded.(unnamed_function_1)","func_start_line":53,"func_end_line":55,"args":["panel"],"code":"      this.subscriptions.add(panel.onDidChangeVisible(visible => {\r\n        if (visible) { this.hideAllPanelsExcept(panel) }\r\n      }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/panel-container-element.js","name":"PanelContainerElement.hideAllPanelsExcept","start_line":86,"end_line":90,"comment":[],"params":["excludedPanel"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/win-powershell.js","name":"spawnPowershell","line":37,"func_location":"(unnamed_function_1)","func_start_line":36,"func_end_line":45},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/win-powershell.js","name":"spawnPowershell","start_line":13,"end_line":28,"comment":[" Spawn powershell.exe and callback when it completes"],"params":["args","callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"show","line":61,"func_location":"Dock.constructor.(unnamed_function_1)","func_start_line":60,"func_end_line":63,"args":[],"code":"      this.paneContainer.onDidActivatePane(() => {\r\n        this.show()\r\n        this.didActivate(this)\r\n      }),\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.show","start_line":119,"end_line":121,"comment":[" Extended: Show the dock without focusing it."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"onDidChangeActiveThemes","line":27,"func_location":"ThemeManager.constructor.(unnamed_function_1)","func_start_line":26,"func_end_line":28,"args":[null],"code":"    this.packageManager.onDidActivateInitialPackages(() => {\r\n      this.onDidChangeActiveThemes(() => this.packageManager.reloadActivePackageStyleSheets())\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.onDidChangeActiveThemes","start_line":55,"end_line":57,"comment":["\r\n  Section: Event Subscription\r\n  "," Essential: Invoke `callback` when style sheet changes associated with"," updating the list of active themes have completed.",""," * `callback` {Function}",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"removeGrammar","line":466,"func_location":"GrammarRegistry.addGrammar.(unnamed_function_10)","func_start_line":466,"func_end_line":466,"args":["grammar"],"code":"      return new Disposable(() => this.removeGrammar(grammar))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.removeGrammar","start_line":472,"end_line":478,"comment":[],"params":["grammar"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"get","line":1049,"func_location":"Config.onDidChangeKeyPath.(unnamed_function_10)","func_start_line":1048,"func_end_line":1055,"args":["keyPath"],"code":"    return this.emitter.on('did-change', () => {\r\n      const newValue = this.get(keyPath)\r\n      if (!_.isEqual(oldValue, newValue)) {\r\n        const event = {oldValue, newValue}\r\n        oldValue = newValue\r\n        return callback(event)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.get","start_line":585,"end_line":602,"comment":["\r\n  Section: Managing Settings\r\n  "," Essential: Retrieves the setting for the given key.",""," ### Examples",""," You might want to know what themes are enabled, so check `core.themes`",""," ```coffee"," atom.config.get('core.themes')"," ```",""," With scope descriptors you can get settings within a specific editor"," scope. For example, you might want to know `editor.tabLength` for ruby"," files.",""," ```coffee"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," ```",""," This setting in ruby files might be different than the global tabLength setting",""," ```coffee"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," ```",""," You can get the language scope descriptor via"," {TextEditor::getRootScopeDescriptor}. This will get the setting specifically"," for the editor's language.",""," ```coffee"," atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2"," ```",""," Additionally, you can get the setting at the specific cursor position.",""," ```coffee"," scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()"," atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2"," ```",""," * `keyPath` The {String} name of the key to retrieve."," * `options` (optional) {Object}","   * `sources` (optional) {Array} of {String} source names. If provided, only","     values that were associated with these sources during {::set} will be used.","   * `excludeSources` (optional) {Array} of {String} source names. If provided,","     values that  were associated with these sources during {::set} will not","     be used.","   * `scope` (optional) {ScopeDescriptor} describing a path from","     the root of the syntax tree to a token. Get one by calling","     {editor.getLastCursor().getScopeDescriptor()}","     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)","     for more information.",""," Returns the value from Atom's default settings, the user's configuration"," file in the type specified by the configuration schema."],"params":["args"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"nodeContainsIndices","line":397,"func_location":"TreeSitterLanguageMode.getSyntaxNodeAndGrammarContainingRange.(unnamed_function_10)","func_start_line":394,"func_end_line":406,"args":["node","startIndex","endIndex"],"code":"    this._forEachTreeWithRange(range, (tree, grammar) => {\r\n      let node = tree.rootNode.descendantForIndex(startIndex, searchEndIndex)\r\n      while (node) {\r\n        if (nodeContainsIndices(node, startIndex, endIndex) && where(node, grammar)) {\r\n          if (nodeIsSmaller(node, smallestNode)) {\r\n            smallestNode = node\r\n            smallestNodeGrammar = grammar\r\n          }\r\n          break\r\n        }\r\n        node = node.parent\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"nodeContainsIndices","start_line":1194,"end_line":1198,"comment":[],"params":["node","start","end"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"nodeIsSmaller","line":398,"func_location":"TreeSitterLanguageMode.getSyntaxNodeAndGrammarContainingRange.(unnamed_function_10)","func_start_line":394,"func_end_line":406,"args":["node","smallestNode"],"code":"    this._forEachTreeWithRange(range, (tree, grammar) => {\r\n      let node = tree.rootNode.descendantForIndex(startIndex, searchEndIndex)\r\n      while (node) {\r\n        if (nodeContainsIndices(node, startIndex, endIndex) && where(node, grammar)) {\r\n          if (nodeIsSmaller(node, smallestNode)) {\r\n            smallestNode = node\r\n            smallestNodeGrammar = grammar\r\n          }\r\n          break\r\n        }\r\n        node = node.parent\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"nodeIsSmaller","start_line":1200,"end_line":1204,"comment":[],"params":["left","right"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"focusedWindow","line":165,"func_location":"submenu.click.(unnamed_function_10)","func_start_line":164,"func_end_line":167,"args":[],"code":"          click: () => {\r\n            const window = this.focusedWindow()\r\n            if (window) window.close()\r\n          }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"ApplicationMenu.focusedWindow","start_line":186,"end_line":188,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"deactivateThemes","line":323,"func_location":"ThemeManager.activateThemes.(unnamed_function_9).(unnamed_function_10)","func_start_line":322,"func_end_line":346,"args":[],"comment":[" @config.observe runs the callback once, then on subsequent changes."],"code":"      this.config.observe('core.themes', () => {\r\n        this.deactivateThemes().then(() => {\r\n          this.warnForNonExistentThemes()\r\n          this.refreshLessCache() // Update cache for packages in core.themes config\r\n\r\n          const promises = []\r\n          for (const themeName of this.getEnabledThemeNames()) {\r\n            if (this.packageManager.resolvePackagePath(themeName)) {\r\n              promises.push(this.packageManager.activatePackage(themeName))\r\n            } else {\r\n              console.warn(`Failed to activate theme '${themeName}' because it isn't installed.`)\r\n            }\r\n          }\r\n\r\n          return Promise.all(promises).then(() => {\r\n            this.addActiveThemeClasses()\r\n            this.refreshLessCache() // Update cache again now that @getActiveThemes() is populated\r\n            this.loadUserStylesheet()\r\n            this.reloadBaseStylesheets()\r\n            this.initialLoadComplete = true\r\n            this.emitter.emit('did-change-active-themes')\r\n            resolve()\r\n          })\r\n        })\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.deactivateThemes","start_line":350,"end_line":355,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"restart","line":1355,"func_location":"AtomApplication.promptForRestart.(unnamed_function_100)","func_start_line":1355,"func_end_line":1355,"args":[],"code":"    }, response => { if (response === 0) this.restart() })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.restart","start_line":1358,"end_line":1370,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"getAllWindows","line":1374,"func_location":"AtomApplication.disableZoomOnDisplayChange.callback.(unnamed_function_101)","func_start_line":1373,"func_end_line":1375,"args":[null],"code":"    const callback = () => {\r\n      this.getAllWindows().map(window => window.disableZoom())\r\n    }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.getAllWindows","start_line":321,"end_line":323,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"addGrammar","line":493,"func_location":"GrammarRegistry.loadGrammar.(unnamed_function_11)","func_start_line":491,"func_end_line":495,"args":["grammar"],"code":"    this.readGrammar(grammarPath, (error, grammar) => {\r\n      if (error) return callback(error)\r\n      this.addGrammar(grammar)\r\n      callback(null, grammar)\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.addGrammar","start_line":456,"end_line":470,"comment":[],"params":["grammar"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateOverlayToRender","line":818,"func_location":"didResize.(unnamed_function_11)","func_start_line":817,"func_end_line":820,"args":["overlayProps"],"code":"          didResize: (overlayComponent) => {\r\n            this.updateOverlayToRender(overlayProps)\r\n            overlayComponent.update(overlayProps)\r\n          }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateOverlayToRender","start_line":1362,"end_line":1393,"comment":[],"params":["decoration"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"setDefaults","line":1078,"func_location":"Config.setDefaults.(unnamed_function_11)","func_start_line":1073,"func_end_line":1081,"args":[null],"code":"      this.transact(() => {\r\n        const result = []\r\n        for (let key in defaults) {\r\n          const childValue = defaults[key]\r\n          if (!defaults.hasOwnProperty(key)) { continue }\r\n          result.push(this.setDefaults(keys.concat([key]).join('.'), childValue))\r\n        }\r\n        return result\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.setDefaults","start_line":1070,"end_line":1090,"comment":[],"params":["keyPath","defaults"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"prepareToUnload","line":173,"func_location":"AtomWindow.handleEvents.(unnamed_function_11)","func_start_line":168,"func_end_line":175,"args":[],"code":"    this.browserWindow.on('close', async event => {\r\n      if (!this.atomApplication.quitting && !this.unloading) {\r\n        event.preventDefault()\r\n        this.unloading = true\r\n        this.atomApplication.saveCurrentWindowOptions(false)\r\n        if (await this.prepareToUnload()) this.close()\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"AtomWindow.prepareToUnload","start_line":227,"end_line":246,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"close","line":173,"func_location":"AtomWindow.handleEvents.(unnamed_function_11)","func_start_line":168,"func_end_line":175,"args":[],"code":"    this.browserWindow.on('close', async event => {\r\n      if (!this.atomApplication.quitting && !this.unloading) {\r\n        event.preventDefault()\r\n        this.unloading = true\r\n        this.atomApplication.saveCurrentWindowOptions(false)\r\n        if (await this.prepareToUnload()) this.close()\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"AtomWindow.close","start_line":330,"end_line":332,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getCenter","line":528,"func_location":"Workspace.subscribeToDockToggling.(unnamed_function_10).(unnamed_function_11)","func_start_line":523,"func_end_line":530,"args":[],"code":"      dock.onDidChangeVisible(visible => {\r\n        if (visible) return\r\n        const {activeElement} = document\r\n        const dockElement = dock.getElement()\r\n        if (dockElement === activeElement || dockElement.contains(activeElement)) {\r\n          this.getCenter().activate()\r\n        }\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getCenter","start_line":1599,"end_line":1601,"comment":["\r\n  Section: Pane Locations\r\n  "," Essential: Get the {WorkspaceCenter} at the center of the editor window."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"focusedWindow","line":173,"func_location":"submenu.click.(unnamed_function_11)","func_start_line":172,"func_end_line":175,"args":[],"code":"          click: () => {\r\n            const window = this.focusedWindow()\r\n            if (window) window.toggleDevTools()\r\n          }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"ApplicationMenu.focusedWindow","start_line":186,"end_line":188,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"destroyItem","line":787,"func_location":"Pane.destroyItems.(unnamed_function_11)","func_start_line":787,"func_end_line":787,"args":[null],"code":"      this.getItems().map(item => this.destroyItem(item))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.destroyItem","start_line":757,"end_line":782,"comment":[" Public: Destroy the given item.",""," If the item is active, the next item will be activated. If the item is the"," last item, the pane will be destroyed if the `core.destroyEmptyPanes` config"," setting is `true`.",""," * `item` Item to destroy"," * `force` (optional) {Boolean} Destroy the item without prompting to save","    it, even if the item's `isPermanentDockItem` method returns true.",""," Returns a {Promise} that resolves with a {Boolean} indicating whether or not"," the item was destroyed."],"params":["item","force"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"warnForNonExistentThemes","line":324,"func_location":"ThemeManager.activateThemes.(unnamed_function_9).(unnamed_function_10).(unnamed_function_11)","func_start_line":323,"func_end_line":345,"args":[],"code":"        this.deactivateThemes().then(() => {\r\n          this.warnForNonExistentThemes()\r\n          this.refreshLessCache() // Update cache for packages in core.themes config\r\n\r\n          const promises = []\r\n          for (const themeName of this.getEnabledThemeNames()) {\r\n            if (this.packageManager.resolvePackagePath(themeName)) {\r\n              promises.push(this.packageManager.activatePackage(themeName))\r\n            } else {\r\n              console.warn(`Failed to activate theme '${themeName}' because it isn't installed.`)\r\n            }\r\n          }\r\n\r\n          return Promise.all(promises).then(() => {\r\n            this.addActiveThemeClasses()\r\n            this.refreshLessCache() // Update cache again now that @getActiveThemes() is populated\r\n            this.loadUserStylesheet()\r\n            this.reloadBaseStylesheets()\r\n            this.initialLoadComplete = true\r\n            this.emitter.emit('did-change-active-themes')\r\n            resolve()\r\n          })\r\n        })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.warnForNonExistentThemes","start_line":104,"end_line":112,"comment":["\r\n  Section: Managing Enabled Themes\r\n  "],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"refreshLessCache","line":325,"func_location":"ThemeManager.activateThemes.(unnamed_function_9).(unnamed_function_10).(unnamed_function_11)","func_start_line":323,"func_end_line":345,"args":[],"code":"        this.deactivateThemes().then(() => {\r\n          this.warnForNonExistentThemes()\r\n          this.refreshLessCache() // Update cache for packages in core.themes config\r\n\r\n          const promises = []\r\n          for (const themeName of this.getEnabledThemeNames()) {\r\n            if (this.packageManager.resolvePackagePath(themeName)) {\r\n              promises.push(this.packageManager.activatePackage(themeName))\r\n            } else {\r\n              console.warn(`Failed to activate theme '${themeName}' because it isn't installed.`)\r\n            }\r\n          }\r\n\r\n          return Promise.all(promises).then(() => {\r\n            this.addActiveThemeClasses()\r\n            this.refreshLessCache() // Update cache again now that @getActiveThemes() is populated\r\n            this.loadUserStylesheet()\r\n            this.reloadBaseStylesheets()\r\n            this.initialLoadComplete = true\r\n            this.emitter.emit('did-change-active-themes')\r\n            resolve()\r\n          })\r\n        })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.refreshLessCache","start_line":377,"end_line":379,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"getEnabledThemeNames","line":328,"func_location":"ThemeManager.activateThemes.(unnamed_function_9).(unnamed_function_10).(unnamed_function_11)","func_start_line":323,"func_end_line":345,"args":[],"code":"        this.deactivateThemes().then(() => {\r\n          this.warnForNonExistentThemes()\r\n          this.refreshLessCache() // Update cache for packages in core.themes config\r\n\r\n          const promises = []\r\n          for (const themeName of this.getEnabledThemeNames()) {\r\n            if (this.packageManager.resolvePackagePath(themeName)) {\r\n              promises.push(this.packageManager.activatePackage(themeName))\r\n            } else {\r\n              console.warn(`Failed to activate theme '${themeName}' because it isn't installed.`)\r\n            }\r\n          }\r\n\r\n          return Promise.all(promises).then(() => {\r\n            this.addActiveThemeClasses()\r\n            this.refreshLessCache() // Update cache again now that @getActiveThemes() is populated\r\n            this.loadUserStylesheet()\r\n            this.reloadBaseStylesheets()\r\n            this.initialLoadComplete = true\r\n            this.emitter.emit('did-change-active-themes')\r\n            resolve()\r\n          })\r\n        })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.getEnabledThemeNames","start_line":117,"end_line":152,"comment":[" Public: Get the enabled theme names from the config.",""," Returns an array of theme names in the order that they should be activated."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedStartRow","line":883,"func_location":"TextEditorComponent.queryExtraScreenLinesToRender.(unnamed_function_12)","func_start_line":882,"func_end_line":886,"args":[],"code":"    this.linesToMeasure.forEach((screenLine, row) => {\r\n      if (row < this.getRenderedStartRow() || row >= this.getRenderedEndRow()) {\r\n        this.extraRenderedScreenLines.set(row, screenLine)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedStartRow","start_line":2720,"end_line":2726,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedEndRow","line":883,"func_location":"TextEditorComponent.queryExtraScreenLinesToRender.(unnamed_function_12)","func_start_line":882,"func_end_line":886,"args":[],"code":"    this.linesToMeasure.forEach((screenLine, row) => {\r\n      if (row < this.getRenderedStartRow() || row >= this.getRenderedEndRow()) {\r\n        this.extraRenderedScreenLines.set(row, screenLine)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedEndRow","start_line":2728,"end_line":2737,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"deepClone","line":1096,"func_location":"Config.deepClone.(unnamed_function_12)","func_start_line":1096,"func_end_line":1096,"args":[null],"code":"      return object.map(value => this.deepClone(value))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.deepClone","start_line":1092,"end_line":1102,"comment":[],"params":["object"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"getAvailablePackages","line":543,"func_location":"PackageManager.loadPackages.(unnamed_function_12)","func_start_line":542,"func_end_line":546,"args":[],"code":"    this.config.transact(() => {\r\n      for (const pack of this.getAvailablePackages()) {\r\n        this.loadAvailablePackage(pack, disabledPackageNames)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.getAvailablePackages","start_line":382,"end_line":414,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"loadAvailablePackage","line":544,"func_location":"PackageManager.loadPackages.(unnamed_function_12)","func_start_line":542,"func_end_line":546,"args":["pack","disabledPackageNames"],"code":"    this.config.transact(() => {\r\n      for (const pack of this.getAvailablePackages()) {\r\n        this.loadAvailablePackage(pack, disabledPackageNames)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.loadAvailablePackage","start_line":571,"end_line":635,"comment":[],"params":["availablePackage","disabledPackageNames"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"saveCurrentWindowOptions","line":309,"func_location":"AtomApplication.addWindow.blurHandler.(unnamed_function_12)","func_start_line":309,"func_end_line":310},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.saveCurrentWindowOptions","start_line":968,"end_line":981,"comment":[],"params":["allowEmpty"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"addActiveThemeClasses","line":337,"func_location":"ThemeManager.activateThemes.(unnamed_function_9).(unnamed_function_10).(unnamed_function_11).(unnamed_function_12)","func_start_line":336,"func_end_line":344,"args":[],"code":"          return Promise.all(promises).then(() => {\r\n            this.addActiveThemeClasses()\r\n            this.refreshLessCache() // Update cache again now that @getActiveThemes() is populated\r\n            this.loadUserStylesheet()\r\n            this.reloadBaseStylesheets()\r\n            this.initialLoadComplete = true\r\n            this.emitter.emit('did-change-active-themes')\r\n            resolve()\r\n          })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.addActiveThemeClasses","start_line":361,"end_line":368,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"refreshLessCache","line":338,"func_location":"ThemeManager.activateThemes.(unnamed_function_9).(unnamed_function_10).(unnamed_function_11).(unnamed_function_12)","func_start_line":336,"func_end_line":344,"args":[],"code":"          return Promise.all(promises).then(() => {\r\n            this.addActiveThemeClasses()\r\n            this.refreshLessCache() // Update cache again now that @getActiveThemes() is populated\r\n            this.loadUserStylesheet()\r\n            this.reloadBaseStylesheets()\r\n            this.initialLoadComplete = true\r\n            this.emitter.emit('did-change-active-themes')\r\n            resolve()\r\n          })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.refreshLessCache","start_line":377,"end_line":379,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"loadUserStylesheet","line":339,"func_location":"ThemeManager.activateThemes.(unnamed_function_9).(unnamed_function_10).(unnamed_function_11).(unnamed_function_12)","func_start_line":336,"func_end_line":344,"args":[],"code":"          return Promise.all(promises).then(() => {\r\n            this.addActiveThemeClasses()\r\n            this.refreshLessCache() // Update cache again now that @getActiveThemes() is populated\r\n            this.loadUserStylesheet()\r\n            this.reloadBaseStylesheets()\r\n            this.initialLoadComplete = true\r\n            this.emitter.emit('did-change-active-themes')\r\n            resolve()\r\n          })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.loadUserStylesheet","start_line":185,"end_line":218,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"reloadBaseStylesheets","line":340,"func_location":"ThemeManager.activateThemes.(unnamed_function_9).(unnamed_function_10).(unnamed_function_11).(unnamed_function_12)","func_start_line":336,"func_end_line":344,"args":[],"code":"          return Promise.all(promises).then(() => {\r\n            this.addActiveThemeClasses()\r\n            this.refreshLessCache() // Update cache again now that @getActiveThemes() is populated\r\n            this.loadUserStylesheet()\r\n            this.reloadBaseStylesheets()\r\n            this.initialLoadComplete = true\r\n            this.emitter.emit('did-change-active-themes')\r\n            resolve()\r\n          })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.reloadBaseStylesheets","start_line":224,"end_line":226,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"createGrammar","line":522,"func_location":"GrammarRegistry.readGrammar.(unnamed_function_13)","func_start_line":519,"func_end_line":526,"args":[{"type":"object"},null],"code":"    CSON.readFile(grammarPath, (error, params = {}) => {\r\n      if (error) return callback(error)\r\n      try {\r\n        callback(null, this.createGrammar(grammarPath, params))\r\n      } catch (error) {\r\n        callback(error)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.createGrammar","start_line":538,"end_line":547,"comment":[],"params":["grammarPath","params"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"deepClone","line":1098,"func_location":"Config.deepClone.(unnamed_function_13)","func_start_line":1098,"func_end_line":1098,"args":["object",null],"code":"      return _.mapObject(object, (key, value) => [key, this.deepClone(value)])\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.deepClone","start_line":1092,"end_line":1102,"comment":[],"params":["object"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"handleError","line":293,"func_location":"BufferedProcess.handleEvents.(unnamed_function_13)","func_start_line":292,"func_end_line":294,"args":["error"],"code":"    this.process.on('error', (error) => {\r\n      this.handleError(error)\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"BufferedProcess.handleError","start_line":297,"end_line":312,"comment":[],"params":["error"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"unloadPackage","line":638,"func_location":"PackageManager.unloadPackages.(unnamed_function_13)","func_start_line":638,"func_end_line":638,"args":[null],"code":"    _.keys(this.loadedPackages).forEach(name => this.unloadPackage(name))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.unloadPackage","start_line":641,"end_line":653,"comment":[],"params":["name"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"destroyItem","line":796,"func_location":"Pane.destroyInactiveItems.(unnamed_function_13)","func_start_line":796,"func_end_line":796},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.destroyItem","start_line":757,"end_line":782,"comment":[" Public: Destroy the given item.",""," If the item is active, the next item will be activated. If the item is the"," last item, the pane will be destroyed if the `core.destroyEmptyPanes` config"," setting is `true`.",""," * `item` Item to destroy"," * `force` (optional) {Boolean} Destroy the item without prompting to save","    it, even if the item's `isPermanentDockItem` method returns true.",""," Returns a {Promise} that resolves with a {Boolean} indicating whether or not"," the item was destroyed."],"params":["item","force"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js","name":"onEvents","line":241,"func_location":"AtomNativeWatcher.doStart.(unnamed_function_14)","func_start_line":237,"func_end_line":242,"args":[null],"code":"    this.subs.add(treeView.onFileCreated(async event => {\r\n      const realPath = await getRealPath(event.path)\r\n      if (!realPath) return\r\n\r\n      this.onEvents([{action: 'added', path: realPath}])\r\n    }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js","name":"NativeWatcher.onEvents","start_line":157,"end_line":159,"comment":[" Private: Callback function invoked by the native watcher when a debounced group of filesystem events arrive."," Normalize and re-broadcast them to any subscribers.",""," * `events` An Array of filesystem events."],"params":["events"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"addDecorationToRender","line":1004,"func_location":"TextEditorComponent.queryDecorationsToRender.(unnamed_function_14)","func_start_line":999,"func_end_line":1006,"args":["decoration.type","decoration","marker","screenRange","reversed"],"code":"    decorationsByMarker.forEach((decorations, marker) => {\r\n      const screenRange = marker.getScreenRange()\r\n      const reversed = marker.isReversed()\r\n      for (let i = 0; i < decorations.length; i++) {\r\n        const decoration = decorations[i]\r\n        this.addDecorationToRender(decoration.type, decoration, marker, screenRange, reversed)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.addDecorationToRender","start_line":1011,"end_line":1042,"comment":[],"params":["type","decoration","marker","screenRange","reversed"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"makeValueConformToSchema","line":1185,"func_location":"Config.resetSettingsForSchemaChange.(unnamed_function_14)","func_start_line":1184,"func_end_line":1193,"args":[{"type":"object"},".settings",null],"code":"    return this.transact(() => {\r\n      this.settings = this.makeValueConformToSchema(null, this.settings, {suppressException: true})\r\n      const selectorsAndSettings = this.scopedSettingsStore.propertiesForSource(source)\r\n      this.scopedSettingsStore.removePropertiesForSource(source)\r\n      for (let scopeSelector in selectorsAndSettings) {\r\n        let settings = selectorsAndSettings[scopeSelector]\r\n        settings = this.makeValueConformToSchema(null, settings, {suppressException: true})\r\n        this.setRawScopedValue(null, settings, source, scopeSelector)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.makeValueConformToSchema","start_line":1164,"end_line":1178,"comment":[],"params":["keyPath","value","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"makeValueConformToSchema","line":1190,"func_location":"Config.resetSettingsForSchemaChange.(unnamed_function_14)","func_start_line":1184,"func_end_line":1193,"args":[{"type":"object"},"settings",null],"code":"    return this.transact(() => {\r\n      this.settings = this.makeValueConformToSchema(null, this.settings, {suppressException: true})\r\n      const selectorsAndSettings = this.scopedSettingsStore.propertiesForSource(source)\r\n      this.scopedSettingsStore.removePropertiesForSource(source)\r\n      for (let scopeSelector in selectorsAndSettings) {\r\n        let settings = selectorsAndSettings[scopeSelector]\r\n        settings = this.makeValueConformToSchema(null, settings, {suppressException: true})\r\n        this.setRawScopedValue(null, settings, source, scopeSelector)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.makeValueConformToSchema","start_line":1164,"end_line":1178,"comment":[],"params":["keyPath","value","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"setRawScopedValue","line":1191,"func_location":"Config.resetSettingsForSchemaChange.(unnamed_function_14)","func_start_line":1184,"func_end_line":1193,"args":[{"type":"object"},"settings","source","scopeSelector"],"code":"    return this.transact(() => {\r\n      this.settings = this.makeValueConformToSchema(null, this.settings, {suppressException: true})\r\n      const selectorsAndSettings = this.scopedSettingsStore.propertiesForSource(source)\r\n      this.scopedSettingsStore.removePropertiesForSource(source)\r\n      for (let scopeSelector in selectorsAndSettings) {\r\n        let settings = selectorsAndSettings[scopeSelector]\r\n        settings = this.makeValueConformToSchema(null, settings, {suppressException: true})\r\n        this.setRawScopedValue(null, settings, source, scopeSelector)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.setRawScopedValue","start_line":1231,"end_line":1242,"comment":[],"params":["keyPath","value","source","selector","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"registerViewProviders","line":499,"func_location":"deserialize.(unnamed_function_14)","func_start_line":498,"func_end_line":503,"args":[],"code":"          deserialize: (state, atomEnvironment) => {\r\n            this.registerViewProviders()\r\n            this.requireMainModule()\r\n            this.initializeIfNeeded()\r\n            return this.mainModule[methodName](state, atomEnvironment)\r\n          }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.registerViewProviders","start_line":526,"end_line":537,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"requireMainModule","line":500,"func_location":"deserialize.(unnamed_function_14)","func_start_line":498,"func_end_line":503,"args":[],"code":"          deserialize: (state, atomEnvironment) => {\r\n            this.registerViewProviders()\r\n            this.requireMainModule()\r\n            this.initializeIfNeeded()\r\n            return this.mainModule[methodName](state, atomEnvironment)\r\n          }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.requireMainModule","start_line":755,"end_line":784,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"initializeIfNeeded","line":501,"func_location":"deserialize.(unnamed_function_14)","func_start_line":498,"func_end_line":503,"args":[],"code":"          deserialize: (state, atomEnvironment) => {\r\n            this.registerViewProviders()\r\n            this.requireMainModule()\r\n            this.initializeIfNeeded()\r\n            return this.mainModule[methodName](state, atomEnvironment)\r\n          }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.initializeIfNeeded","start_line":170,"end_line":187,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"triggerDeferredActivationHooks","line":663,"func_location":"PackageManager.activate.(unnamed_function_14)","func_start_line":662,"func_end_line":666,"args":[],"code":"    return Promise.all(promises).then(() => {\r\n      this.triggerDeferredActivationHooks()\r\n      this.initialPackagesActivated = true\r\n      this.emitter.emit('did-activate-initial-packages')\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.triggerDeferredActivationHooks","start_line":724,"end_line":734,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"acceleratorForCommand","line":202,"func_location":"ApplicationMenu.translateTemplate.(unnamed_function_14)","func_start_line":199,"func_end_line":209,"args":["item.command","keystrokesByCommand"],"code":"    template.forEach(item => {\r\n      if (item.metadata == null) item.metadata = {}\r\n      if (item.command) {\r\n        item.accelerator = this.acceleratorForCommand(item.command, keystrokesByCommand)\r\n        item.click = () => global.atomApplication.sendCommand(item.command, item.commandDetail)\r\n        if (!/^application:/.test(item.command)) {\r\n          item.metadata.windowSpecific = true\r\n        }\r\n      }\r\n      if (item.submenu) this.translateTemplate(item.submenu, keystrokesByCommand)\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"ApplicationMenu.acceleratorForCommand","start_line":221,"end_line":224,"comment":[" Determine the accelerator for a given command.",""," command - The name of the command."," keystrokesByCommand - An Object where the keys are commands and the values","                       are Arrays containing the keystroke.",""," Returns a String containing the keystroke in a format that can be interpreted","   by Electron to provide nice icons where available."],"params":["command","keystrokesByCommand"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"translateTemplate","line":208,"func_location":"ApplicationMenu.translateTemplate.(unnamed_function_14)","func_start_line":199,"func_end_line":209,"args":["item.submenu","keystrokesByCommand"],"code":"    template.forEach(item => {\r\n      if (item.metadata == null) item.metadata = {}\r\n      if (item.command) {\r\n        item.accelerator = this.acceleratorForCommand(item.command, keystrokesByCommand)\r\n        item.click = () => global.atomApplication.sendCommand(item.command, item.commandDetail)\r\n        if (!/^application:/.test(item.command)) {\r\n          item.metadata.windowSpecific = true\r\n        }\r\n      }\r\n      if (item.submenu) this.translateTemplate(item.submenu, keystrokesByCommand)\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"ApplicationMenu.translateTemplate","start_line":198,"end_line":211,"comment":[" Combines a menu template with the appropriate keystroke.",""," template - An Object conforming to atom-shell's menu api but lacking","            accelerator and click properties."," keystrokesByCommand - An Object where the keys are commands and the values","                       are Arrays containing the keystroke.",""," Returns a complete menu configuration object for atom-shell's menu API."],"params":["template","keystrokesByCommand"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js","name":"onEvents","line":248,"func_location":"AtomNativeWatcher.doStart.(unnamed_function_15)","func_start_line":244,"func_end_line":249,"args":[null],"code":"    this.subs.add(treeView.onEntryDeleted(async event => {\r\n      const realPath = await getRealPath(event.path)\r\n      if (!realPath || await isOpenInEditor(realPath)) return\r\n\r\n      this.onEvents([{action: 'deleted', path: realPath}])\r\n    }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js","name":"NativeWatcher.onEvents","start_line":157,"end_line":159,"comment":[" Private: Callback function invoked by the native watcher when a debounced group of filesystem events arrive."," Normalize and re-broadcast them to any subscribers.",""," * `events` An Array of filesystem events."],"params":["events"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"_populateInjections","line":617,"func_location":"LanguageLayer.updateInjections.(unnamed_function_15)","func_start_line":616,"func_end_line":619,"args":["MAX_RANGE",{"type":"object"}],"code":"      this.currentParsePromise = this.currentParsePromise.then(async () => {\r\n        await this._populateInjections(MAX_RANGE, null)\r\n        this.currentParsePromise = null\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"LanguageLayer._populateInjections","start_line":701,"end_line":781,"comment":[],"params":["range","nodeRangeSet"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"activatePackage","line":683,"func_location":"PackageManager.activatePackages.(unnamed_function_15)","func_start_line":681,"func_end_line":689,"args":["pack.name"],"code":"    this.config.transactAsync(() => {\r\n      for (const pack of packages) {\r\n        const promise = this.activatePackage(pack.name)\r\n        if (!pack.activationShouldBeDeferred()) {\r\n          promises.push(promise)\r\n        }\r\n      }\r\n      return Promise.all(promises)\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.activatePackage","start_line":696,"end_line":722,"comment":[" Activate a single package by name"],"params":["name"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js","name":"onEvents","line":258,"func_location":"AtomNativeWatcher.doStart.(unnamed_function_16)","func_start_line":251,"func_end_line":259,"args":[null],"code":"    this.subs.add(treeView.onEntryMoved(async event => {\r\n      const [realNewPath, realOldPath] = await Promise.all([\r\n        getRealPath(event.newPath),\r\n        getRealPath(event.initialPath)\r\n      ])\r\n      if (!realNewPath || !realOldPath || await isOpenInEditor(realNewPath) || await isOpenInEditor(realOldPath)) return\r\n\r\n      this.onEvents([{action: 'renamed', path: realNewPath, oldPath: realOldPath}])\r\n    }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js","name":"NativeWatcher.onEvents","start_line":157,"end_line":159,"comment":[" Private: Callback function invoked by the native watcher when a debounced group of filesystem events arrive."," Normalize and re-broadcast them to any subscribers.",""," * `events` An Array of filesystem events."],"params":["events"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"get","line":1272,"func_location":"Config.onDidChangeScopedKeyPath.(unnamed_function_16)","func_start_line":1271,"func_end_line":1278,"args":["keyPath",null],"code":"    return this.emitter.on('did-change', () => {\r\n      const newValue = this.get(keyPath, {scope})\r\n      if (!_.isEqual(oldValue, newValue)) {\r\n        const event = {oldValue, newValue}\r\n        oldValue = newValue\r\n        callback(event)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.get","start_line":585,"end_line":602,"comment":["\r\n  Section: Managing Settings\r\n  "," Essential: Retrieves the setting for the given key.",""," ### Examples",""," You might want to know what themes are enabled, so check `core.themes`",""," ```coffee"," atom.config.get('core.themes')"," ```",""," With scope descriptors you can get settings within a specific editor"," scope. For example, you might want to know `editor.tabLength` for ruby"," files.",""," ```coffee"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," ```",""," This setting in ruby files might be different than the global tabLength setting",""," ```coffee"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," ```",""," You can get the language scope descriptor via"," {TextEditor::getRootScopeDescriptor}. This will get the setting specifically"," for the editor's language.",""," ```coffee"," atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2"," ```",""," Additionally, you can get the setting at the specific cursor position.",""," ```coffee"," scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()"," atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2"," ```",""," * `keyPath` The {String} name of the key to retrieve."," * `options` (optional) {Object}","   * `sources` (optional) {Array} of {String} source names. If provided, only","     values that were associated with these sources during {::set} will be used.","   * `excludeSources` (optional) {Array} of {String} source names. If provided,","     values that  were associated with these sources during {::set} will not","     be used.","   * `scope` (optional) {ScopeDescriptor} describing a path from","     the root of the syntax tree to a token. Get one by calling","     {editor.getLastCursor().getScopeDescriptor()}","     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)","     for more information.",""," Returns the value from Atom's default settings, the user's configuration"," file in the type specified by the configuration schema."],"params":["args"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"initializeIfNeeded","line":531,"func_location":"Package.registerViewProviders.(unnamed_function_15).(unnamed_function_16)","func_start_line":530,"func_end_line":533,"args":[],"code":"        this.viewRegistry.addViewProvider(model => {\r\n          this.initializeIfNeeded()\r\n          return this.mainModule[methodName](model)\r\n        })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.initializeIfNeeded","start_line":170,"end_line":187,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"openWithOptions","line":341,"func_location":"AtomApplication.listenForArgumentsFromNewProcess.server.(unnamed_function_14).(unnamed_function_16)","func_start_line":341,"func_end_line":341,"args":[{"type":"string"},null],"code":"      connection.on('end', () => this.openWithOptions(JSON.parse(data)))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.openWithOptions","start_line":207,"end_line":281,"comment":[],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js","name":"onEvents","line":267,"func_location":"NSFWNativeWatcher.doStart.handler.(unnamed_function_17)","func_start_line":266,"func_end_line":280},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js","name":"NativeWatcher.onEvents","start_line":157,"end_line":159,"comment":[" Private: Callback function invoked by the native watcher when a debounced group of filesystem events arrive."," Normalize and re-broadcast them to any subscribers.",""," * `events` An Array of filesystem events."],"params":["events"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"open","line":862,"func_location":"open.(unnamed_function_17)","func_start_line":862,"func_end_line":863},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.open","start_line":547,"end_line":549,"comment":["\r\n  Section: Managing The Atom Window\r\n  "," Essential: Open a new Atom window using the given options.",""," Calling this method without an options parameter will open a prompt to pick"," a file/folder to open in the new window.",""," * `params` An {Object} with the following keys:","   * `pathsToOpen`  An {Array} of {String} paths to open.","   * `newWindow` A {Boolean}, true to always open a new window instead of","     reusing existing windows depending on the paths to open.","   * `devMode` A {Boolean}, true to open the window in development mode.","     Development mode loads the Atom source from the locally cloned","     repository and also loads all the packages in ~/.atom/dev/packages","   * `safeMode` A {Boolean}, true to open the window in safe mode. Safe","     mode prevents all packages installed to ~/.atom/packages from loading."],"params":["params"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getMessageForErrorCode","line":832,"func_location":"Pane.promptToSaveItem.(unnamed_function_14).saveDialog.(unnamed_function_15).(unnamed_function_16).(unnamed_function_17)","func_start_line":825,"func_end_line":837,"args":["error.code"],"code":"              return saveFn(item, error => {\r\n                if (error instanceof SaveCancelledError) {\r\n                  resolve(false)\r\n                } else if (error) {\r\n                  saveDialog(\r\n                    'Save as',\r\n                    this.saveItemAs,\r\n                    `'${title}' could not be saved.\\nError: ${this.getMessageForErrorCode(error.code)}`\r\n                  )\r\n                } else {\r\n                  resolve(true)\r\n                }\r\n              })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getMessageForErrorCode","start_line":1246,"end_line":1259,"comment":[],"params":["errorCode"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelPositionAfterBlocksForRow","line":1347,"func_location":"TextEditorComponent.updateCursorsToRender.(unnamed_function_18)","func_start_line":1343,"func_end_line":1359,"args":["row"],"code":"    this.decorationsToMeasure.cursors.forEach((cursor) => {\r\n      const {screenPosition, className, style} = cursor\r\n      const {row, column} = screenPosition\r\n\r\n      const pixelTop = this.pixelPositionAfterBlocksForRow(row)\r\n      const pixelLeft = this.pixelLeftForRowAndColumn(row, column)\r\n      let pixelWidth\r\n      if (cursor.columnWidth === 0) {\r\n        pixelWidth = this.getBaseCharacterWidth()\r\n      } else {\r\n        pixelWidth = this.pixelLeftForRowAndColumn(row, column + 1) - pixelLeft\r\n      }\r\n\r\n      const cursorPosition = {pixelTop, pixelLeft, pixelWidth, className, style}\r\n      this.decorationsToRender.cursors.push(cursorPosition)\r\n      if (cursor.isLastCursor) this.hiddenInputPosition = cursorPosition\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelPositionAfterBlocksForRow","start_line":2364,"end_line":2366,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelLeftForRowAndColumn","line":1348,"func_location":"TextEditorComponent.updateCursorsToRender.(unnamed_function_18)","func_start_line":1343,"func_end_line":1359,"args":["row","column"],"code":"    this.decorationsToMeasure.cursors.forEach((cursor) => {\r\n      const {screenPosition, className, style} = cursor\r\n      const {row, column} = screenPosition\r\n\r\n      const pixelTop = this.pixelPositionAfterBlocksForRow(row)\r\n      const pixelLeft = this.pixelLeftForRowAndColumn(row, column)\r\n      let pixelWidth\r\n      if (cursor.columnWidth === 0) {\r\n        pixelWidth = this.getBaseCharacterWidth()\r\n      } else {\r\n        pixelWidth = this.pixelLeftForRowAndColumn(row, column + 1) - pixelLeft\r\n      }\r\n\r\n      const cursorPosition = {pixelTop, pixelLeft, pixelWidth, className, style}\r\n      this.decorationsToRender.cursors.push(cursorPosition)\r\n      if (cursor.isLastCursor) this.hiddenInputPosition = cursorPosition\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelLeftForRowAndColumn","start_line":2368,"end_line":2377,"comment":[],"params":["row","column"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getBaseCharacterWidth","line":1351,"func_location":"TextEditorComponent.updateCursorsToRender.(unnamed_function_18)","func_start_line":1343,"func_end_line":1359,"args":[],"code":"    this.decorationsToMeasure.cursors.forEach((cursor) => {\r\n      const {screenPosition, className, style} = cursor\r\n      const {row, column} = screenPosition\r\n\r\n      const pixelTop = this.pixelPositionAfterBlocksForRow(row)\r\n      const pixelLeft = this.pixelLeftForRowAndColumn(row, column)\r\n      let pixelWidth\r\n      if (cursor.columnWidth === 0) {\r\n        pixelWidth = this.getBaseCharacterWidth()\r\n      } else {\r\n        pixelWidth = this.pixelLeftForRowAndColumn(row, column + 1) - pixelLeft\r\n      }\r\n\r\n      const cursorPosition = {pixelTop, pixelLeft, pixelWidth, className, style}\r\n      this.decorationsToRender.cursors.push(cursorPosition)\r\n      if (cursor.isLastCursor) this.hiddenInputPosition = cursorPosition\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getBaseCharacterWidth","start_line":2604,"end_line":2606,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelLeftForRowAndColumn","line":1353,"func_location":"TextEditorComponent.updateCursorsToRender.(unnamed_function_18)","func_start_line":1343,"func_end_line":1359,"args":["row",null],"code":"    this.decorationsToMeasure.cursors.forEach((cursor) => {\r\n      const {screenPosition, className, style} = cursor\r\n      const {row, column} = screenPosition\r\n\r\n      const pixelTop = this.pixelPositionAfterBlocksForRow(row)\r\n      const pixelLeft = this.pixelLeftForRowAndColumn(row, column)\r\n      let pixelWidth\r\n      if (cursor.columnWidth === 0) {\r\n        pixelWidth = this.getBaseCharacterWidth()\r\n      } else {\r\n        pixelWidth = this.pixelLeftForRowAndColumn(row, column + 1) - pixelLeft\r\n      }\r\n\r\n      const cursorPosition = {pixelTop, pixelLeft, pixelWidth, className, style}\r\n      this.decorationsToRender.cursors.push(cursorPosition)\r\n      if (cursor.isLastCursor) this.hiddenInputPosition = cursorPosition\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelLeftForRowAndColumn","start_line":2368,"end_line":2377,"comment":[],"params":["row","column"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"openDevTools","line":938,"func_location":"AtomEnvironment.installUncaughtErrorHandler.(unnamed_function_18)","func_start_line":924,"func_end_line":944,"args":[],"code":"    this.window.onerror = (message, url, line, column, originalError) => {\r\n      const mapping = mapSourcePosition({source: url, line, column})\r\n      line = mapping.line\r\n      column = mapping.column\r\n      if (url === '<embedded>') url = mapping.source\r\n\r\n      const eventObject = {message, url, line, column, originalError}\r\n\r\n      let openDevTools = true\r\n      eventObject.preventDefault = () => { openDevTools = false }\r\n\r\n      this.emitter.emit('will-throw-error', eventObject)\r\n\r\n      if (openDevTools) {\r\n        this.openDevTools().then(() =>\r\n          this.executeJavaScriptInDevTools('DevToolsAPI.showPanel(\"console\")')\r\n        )\r\n      }\r\n\r\n      this.emitter.emit('did-throw-error', {message, url, line, column, originalError})\r\n    }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.openDevTools","start_line":1055,"end_line":1057,"comment":["\r\n  Section: Managing the Dev Tools\r\n  "," Extended: Open the dev tools for the current window.",""," Returns a {Promise} that resolves when the DevTools have been opened."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"getLoadedPackages","line":772,"func_location":"PackageManager.deactivatePackages.(unnamed_function_18)","func_start_line":771,"func_end_line":773,"args":[null],"code":"    await this.config.transactAsync(() =>\r\n      Promise.all(this.getLoadedPackages().map(pack => this.deactivatePackage(pack.name, true)))\r\n    )\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.getLoadedPackages","start_line":323,"end_line":325,"comment":["\r\n  Section: Accessing loaded packages\r\n  "," Public: Get an {Array} of all the loaded {Package}s"],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"focusedWindow","line":366,"func_location":"AtomApplication.handleEvents.getLoadSettings.(unnamed_function_18)","func_start_line":365,"func_end_line":368,"args":[],"code":"    const getLoadSettings = () => {\r\n      const window = this.focusedWindow()\r\n      return {devMode: window && window.devMode, safeMode: window && window.safeMode}\r\n    }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.focusedWindow","start_line":748,"end_line":750,"comment":[" Public: Returns the currently focused {AtomWindow} or undefined if none."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"didShow","line":1411,"func_location":"TextEditorComponent.didAttach.(unnamed_function_19)","func_start_line":1408,"func_end_line":1415,"args":[],"code":"      this.intersectionObserver = new IntersectionObserver((entries) => {\r\n        const {intersectionRect} = entries[entries.length - 1]\r\n        if (intersectionRect.width > 0 || intersectionRect.height > 0) {\r\n          this.didShow()\r\n        } else {\r\n          this.didHide()\r\n        }\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.didShow","start_line":1456,"end_line":1465,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"didHide","line":1413,"func_location":"TextEditorComponent.didAttach.(unnamed_function_19)","func_start_line":1408,"func_end_line":1415,"args":[],"code":"      this.intersectionObserver = new IntersectionObserver((entries) => {\r\n        const {intersectionRect} = entries[entries.length - 1]\r\n        if (intersectionRect.width > 0 || intersectionRect.height > 0) {\r\n          this.didShow()\r\n        } else {\r\n          this.didHide()\r\n        }\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.didHide","start_line":1467,"end_line":1472,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"deactivatePackage","line":772,"func_location":"PackageManager.deactivatePackages.(unnamed_function_18).(unnamed_function_19)","func_start_line":772,"func_end_line":772,"args":[null],"code":"      Promise.all(this.getLoadedPackages().map(pack => this.deactivatePackage(pack.name, true)))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.deactivatePackage","start_line":779,"end_line":797,"comment":[" Deactivate the package with the given name"],"params":["name","suppressSerialization"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"autoAssignLanguageMode","line":45,"func_location":"GrammarRegistry.clear.(unnamed_function_1).(unnamed_function_2)","func_start_line":43,"func_end_line":47,"args":["buffer"],"code":"      this.grammarScoresByBuffer.forEach((score, buffer) => {\r\n        if (!this.languageOverridesByBufferId.has(buffer.id)) {\r\n          this.autoAssignLanguageMode(buffer)\r\n        }\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.autoAssignLanguageMode","start_line":158,"end_line":168,"comment":[" Extended: Remove any language mode override that has been set for the"," given {TextBuffer}. This will assign to the buffer the best language"," mode available.",""," * `buffer` The {TextBuffer}."],"params":["buffer"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"setState","line":46,"func_location":"AutoUpdateManager.initialize.(unnamed_function_2)","func_start_line":45,"func_end_line":48,"args":["CheckingState"],"code":"    autoUpdater.on('checking-for-update', () => {\r\n      this.setState(CheckingState)\r\n      this.emitWindowEvent('checking-for-update')\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"AutoUpdateManager.setState","start_line":103,"end_line":108,"comment":[],"params":["state","errorMessage"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"emitWindowEvent","line":47,"func_location":"AutoUpdateManager.initialize.(unnamed_function_2)","func_start_line":45,"func_end_line":48,"args":[{"type":"string"}],"code":"    autoUpdater.on('checking-for-update', () => {\r\n      this.setState(CheckingState)\r\n      this.emitWindowEvent('checking-for-update')\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"AutoUpdateManager.emitWindowEvent","start_line":97,"end_line":101,"comment":[],"params":["eventName","payload"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/title-bar.js","name":"updateWindowSheetOffset","line":18,"func_location":"TitleBar.constructor.(unnamed_function_2)","func_start_line":18,"func_end_line":18,"args":[null],"code":"    this.themes.onDidChangeActiveThemes(() => this.updateWindowSheetOffset())\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/title-bar.js","name":"TitleBar.updateWindowSheetOffset","start_line":44,"end_line":46,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"set","line":691,"func_location":"Config.set.(unnamed_function_2)","func_start_line":691,"func_end_line":691,"args":[null],"code":"      this.pendingOperations.push(() => this.set(keyPath, value, options))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.set","start_line":687,"end_line":722,"comment":[" Essential: Sets the value for a configuration setting.",""," This value is stored in Atom's internal configuration file.",""," ### Examples",""," You might want to change the themes programmatically:",""," ```coffee"," atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])"," ```",""," You can also set scoped settings. For example, you might want change the"," `editor.tabLength` only for ruby files.",""," ```coffee"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4"," atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",""," # Set ruby to 2"," atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true",""," # Notice it's only set to 2 in the case of ruby"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," atom.config.get('editor.tabLength', scope: ['source.js']) # => 4"," ```",""," * `keyPath` The {String} name of the key."," * `value` The value of the setting. Passing `undefined` will revert the","   setting to the default value."," * `options` (optional) {Object}","   * `scopeSelector` (optional) {String}. eg. '.source.ruby'","     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)","     for more information.","   * `source` (optional) {String} The name of a file with which the setting","     is associated. Defaults to the user's config file.",""," Returns a {Boolean}"," * `true` if the value was set."," * `false` if the value was not able to be coerced to the type specified in the setting's schema."],"params":["args"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"isExplorerCommand","line":85,"func_location":"BufferedProcess.spawnWithEscapedWindowsArgs.(unnamed_function_2)","func_start_line":84,"func_end_line":93,"args":["command"],"code":"        .map((arg) => {\r\n          if (this.isExplorerCommand(command) && /^\\/[a-zA-Z]+,.*$/.test(arg)) {\r\n            // Don't wrap /root,C:\\folder style arguments to explorer calls in\r\n            // quotes since they will not be interpreted correctly if they are\r\n            return arg\r\n          } else {\r\n            // Escape double quotes by putting a backslash in front of them\r\n            return `\\\"${arg.toString().replace(/\"/g, '\\\\\"')}\\\"`\r\n          }\r\n        })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"BufferedProcess.isExplorerCommand","start_line":212,"end_line":220,"comment":[],"params":["command"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"constructor","line":26,"func_location":"HistoryManager.getProjects.(unnamed_function_2)","func_start_line":26,"func_end_line":26,"args":[null],"code":"    return this.projects.map(p => new HistoryProject(p.paths, p.lastOpened))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"HistoryProject.constructor","start_line":118,"end_line":121,"comment":[],"params":["paths","lastOpened"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":37,"func_location":"TextEditorElement.createdCallback.(unnamed_function_2)","func_start_line":37,"func_end_line":37,"args":[{"type":"string"},null],"code":"    this.addEventListener('blur', (event) => this.getComponent().didBlur(event))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"loadKeymaps","line":127,"func_location":"Package.load.(unnamed_function_2)","func_start_line":123,"func_end_line":142,"args":[],"code":"    this.measure('loadTime', () => {\r\n      try {\r\n        ModuleCache.add(this.path, this.metadata)\r\n\r\n        this.loadKeymaps()\r\n        this.loadMenus()\r\n        this.loadStylesheets()\r\n        this.registerDeserializerMethods()\r\n        this.activateCoreStartupServices()\r\n        this.registerURIHandler()\r\n        this.registerTranspilerConfig()\r\n        this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n        this.settingsPromise = this.loadSettings()\r\n        if (this.shouldRequireMainModuleOnLoad() && (this.mainModule == null)) {\r\n          this.requireMainModule()\r\n        }\r\n      } catch (error) {\r\n        this.handleError(`Failed to load the ${this.name} package`, error)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.loadKeymaps","start_line":438,"end_line":451,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"loadMenus","line":128,"func_location":"Package.load.(unnamed_function_2)","func_start_line":123,"func_end_line":142,"args":[],"code":"    this.measure('loadTime', () => {\r\n      try {\r\n        ModuleCache.add(this.path, this.metadata)\r\n\r\n        this.loadKeymaps()\r\n        this.loadMenus()\r\n        this.loadStylesheets()\r\n        this.registerDeserializerMethods()\r\n        this.activateCoreStartupServices()\r\n        this.registerURIHandler()\r\n        this.registerTranspilerConfig()\r\n        this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n        this.settingsPromise = this.loadSettings()\r\n        if (this.shouldRequireMainModuleOnLoad() && (this.mainModule == null)) {\r\n          this.requireMainModule()\r\n        }\r\n      } catch (error) {\r\n        this.handleError(`Failed to load the ${this.name} package`, error)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.loadMenus","start_line":453,"end_line":466,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"loadStylesheets","line":129,"func_location":"Package.load.(unnamed_function_2)","func_start_line":123,"func_end_line":142,"args":[],"code":"    this.measure('loadTime', () => {\r\n      try {\r\n        ModuleCache.add(this.path, this.metadata)\r\n\r\n        this.loadKeymaps()\r\n        this.loadMenus()\r\n        this.loadStylesheets()\r\n        this.registerDeserializerMethods()\r\n        this.activateCoreStartupServices()\r\n        this.registerURIHandler()\r\n        this.registerTranspilerConfig()\r\n        this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n        this.settingsPromise = this.loadSettings()\r\n        if (this.shouldRequireMainModuleOnLoad() && (this.mainModule == null)) {\r\n          this.requireMainModule()\r\n        }\r\n      } catch (error) {\r\n        this.handleError(`Failed to load the ${this.name} package`, error)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.loadStylesheets","start_line":486,"end_line":490,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"registerDeserializerMethods","line":130,"func_location":"Package.load.(unnamed_function_2)","func_start_line":123,"func_end_line":142,"args":[],"code":"    this.measure('loadTime', () => {\r\n      try {\r\n        ModuleCache.add(this.path, this.metadata)\r\n\r\n        this.loadKeymaps()\r\n        this.loadMenus()\r\n        this.loadStylesheets()\r\n        this.registerDeserializerMethods()\r\n        this.activateCoreStartupServices()\r\n        this.registerURIHandler()\r\n        this.registerTranspilerConfig()\r\n        this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n        this.settingsPromise = this.loadSettings()\r\n        if (this.shouldRequireMainModuleOnLoad() && (this.mainModule == null)) {\r\n          this.requireMainModule()\r\n        }\r\n      } catch (error) {\r\n        this.handleError(`Failed to load the ${this.name} package`, error)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.registerDeserializerMethods","start_line":492,"end_line":507,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"activateCoreStartupServices","line":131,"func_location":"Package.load.(unnamed_function_2)","func_start_line":123,"func_end_line":142,"args":[],"code":"    this.measure('loadTime', () => {\r\n      try {\r\n        ModuleCache.add(this.path, this.metadata)\r\n\r\n        this.loadKeymaps()\r\n        this.loadMenus()\r\n        this.loadStylesheets()\r\n        this.registerDeserializerMethods()\r\n        this.activateCoreStartupServices()\r\n        this.registerURIHandler()\r\n        this.registerTranspilerConfig()\r\n        this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n        this.settingsPromise = this.loadSettings()\r\n        if (this.shouldRequireMainModuleOnLoad() && (this.mainModule == null)) {\r\n          this.requireMainModule()\r\n        }\r\n      } catch (error) {\r\n        this.handleError(`Failed to load the ${this.name} package`, error)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.activateCoreStartupServices","start_line":509,"end_line":524,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"registerURIHandler","line":132,"func_location":"Package.load.(unnamed_function_2)","func_start_line":123,"func_end_line":142,"args":[],"code":"    this.measure('loadTime', () => {\r\n      try {\r\n        ModuleCache.add(this.path, this.metadata)\r\n\r\n        this.loadKeymaps()\r\n        this.loadMenus()\r\n        this.loadStylesheets()\r\n        this.registerDeserializerMethods()\r\n        this.activateCoreStartupServices()\r\n        this.registerURIHandler()\r\n        this.registerTranspilerConfig()\r\n        this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n        this.settingsPromise = this.loadSettings()\r\n        if (this.shouldRequireMainModuleOnLoad() && (this.mainModule == null)) {\r\n          this.requireMainModule()\r\n        }\r\n      } catch (error) {\r\n        this.handleError(`Failed to load the ${this.name} package`, error)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.registerURIHandler","start_line":405,"end_line":413,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"registerTranspilerConfig","line":133,"func_location":"Package.load.(unnamed_function_2)","func_start_line":123,"func_end_line":142,"args":[],"code":"    this.measure('loadTime', () => {\r\n      try {\r\n        ModuleCache.add(this.path, this.metadata)\r\n\r\n        this.loadKeymaps()\r\n        this.loadMenus()\r\n        this.loadStylesheets()\r\n        this.registerDeserializerMethods()\r\n        this.activateCoreStartupServices()\r\n        this.registerURIHandler()\r\n        this.registerTranspilerConfig()\r\n        this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n        this.settingsPromise = this.loadSettings()\r\n        if (this.shouldRequireMainModuleOnLoad() && (this.mainModule == null)) {\r\n          this.requireMainModule()\r\n        }\r\n      } catch (error) {\r\n        this.handleError(`Failed to load the ${this.name} package`, error)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.registerTranspilerConfig","start_line":426,"end_line":430,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"registerConfigSchemaFromMetadata","line":134,"func_location":"Package.load.(unnamed_function_2)","func_start_line":123,"func_end_line":142,"args":[],"code":"    this.measure('loadTime', () => {\r\n      try {\r\n        ModuleCache.add(this.path, this.metadata)\r\n\r\n        this.loadKeymaps()\r\n        this.loadMenus()\r\n        this.loadStylesheets()\r\n        this.registerDeserializerMethods()\r\n        this.activateCoreStartupServices()\r\n        this.registerURIHandler()\r\n        this.registerTranspilerConfig()\r\n        this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n        this.settingsPromise = this.loadSettings()\r\n        if (this.shouldRequireMainModuleOnLoad() && (this.mainModule == null)) {\r\n          this.requireMainModule()\r\n        }\r\n      } catch (error) {\r\n        this.handleError(`Failed to load the ${this.name} package`, error)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.registerConfigSchemaFromMetadata","start_line":238,"end_line":246,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"loadSettings","line":135,"func_location":"Package.load.(unnamed_function_2)","func_start_line":123,"func_end_line":142,"args":[],"code":"    this.measure('loadTime', () => {\r\n      try {\r\n        ModuleCache.add(this.path, this.metadata)\r\n\r\n        this.loadKeymaps()\r\n        this.loadMenus()\r\n        this.loadStylesheets()\r\n        this.registerDeserializerMethods()\r\n        this.activateCoreStartupServices()\r\n        this.registerURIHandler()\r\n        this.registerTranspilerConfig()\r\n        this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n        this.settingsPromise = this.loadSettings()\r\n        if (this.shouldRequireMainModuleOnLoad() && (this.mainModule == null)) {\r\n          this.requireMainModule()\r\n        }\r\n      } catch (error) {\r\n        this.handleError(`Failed to load the ${this.name} package`, error)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.loadSettings","start_line":634,"end_line":671,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"shouldRequireMainModuleOnLoad","line":136,"func_location":"Package.load.(unnamed_function_2)","func_start_line":123,"func_end_line":142,"args":[],"code":"    this.measure('loadTime', () => {\r\n      try {\r\n        ModuleCache.add(this.path, this.metadata)\r\n\r\n        this.loadKeymaps()\r\n        this.loadMenus()\r\n        this.loadStylesheets()\r\n        this.registerDeserializerMethods()\r\n        this.activateCoreStartupServices()\r\n        this.registerURIHandler()\r\n        this.registerTranspilerConfig()\r\n        this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n        this.settingsPromise = this.loadSettings()\r\n        if (this.shouldRequireMainModuleOnLoad() && (this.mainModule == null)) {\r\n          this.requireMainModule()\r\n        }\r\n      } catch (error) {\r\n        this.handleError(`Failed to load the ${this.name} package`, error)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.shouldRequireMainModuleOnLoad","start_line":150,"end_line":158,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"requireMainModule","line":137,"func_location":"Package.load.(unnamed_function_2)","func_start_line":123,"func_end_line":142,"args":[],"code":"    this.measure('loadTime', () => {\r\n      try {\r\n        ModuleCache.add(this.path, this.metadata)\r\n\r\n        this.loadKeymaps()\r\n        this.loadMenus()\r\n        this.loadStylesheets()\r\n        this.registerDeserializerMethods()\r\n        this.activateCoreStartupServices()\r\n        this.registerURIHandler()\r\n        this.registerTranspilerConfig()\r\n        this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n        this.settingsPromise = this.loadSettings()\r\n        if (this.shouldRequireMainModuleOnLoad() && (this.mainModule == null)) {\r\n          this.requireMainModule()\r\n        }\r\n      } catch (error) {\r\n        this.handleError(`Failed to load the ${this.name} package`, error)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.requireMainModule","start_line":755,"end_line":784,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"handleError","line":140,"func_location":"Package.load.(unnamed_function_2)","func_start_line":123,"func_end_line":142,"args":[null,"error"],"code":"    this.measure('loadTime', () => {\r\n      try {\r\n        ModuleCache.add(this.path, this.metadata)\r\n\r\n        this.loadKeymaps()\r\n        this.loadMenus()\r\n        this.loadStylesheets()\r\n        this.registerDeserializerMethods()\r\n        this.activateCoreStartupServices()\r\n        this.registerURIHandler()\r\n        this.registerTranspilerConfig()\r\n        this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n        this.settingsPromise = this.loadSettings()\r\n        if (this.shouldRequireMainModuleOnLoad() && (this.mainModule == null)) {\r\n          this.requireMainModule()\r\n        }\r\n      } catch (error) {\r\n        this.handleError(`Failed to load the ${this.name} package`, error)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.handleError","start_line":1085,"end_line":1105,"comment":[],"params":["message","error"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selectors.js","name":"parse","line":27,"func_location":"matcherForSelector.(unnamed_function_2)","func_start_line":27,"func_end_line":28},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selectors.js","name":"parse","start_line":10,"end_line":14,"comment":[" Private: Parse a selector into parts.","          If already parsed, returns the selector unmodified.",""," * `selector` a {String|Array<String>} specifying what to match"," Returns selector parts, an {Array<String>}."],"params":["selector"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-updater-win32.js","name":"installUpdate","line":68,"func_location":"AutoUpdater.checkForUpdates.(unnamed_function_2)","func_start_line":55,"func_end_line":84},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-updater-win32.js","name":"AutoUpdater.installUpdate","start_line":37,"end_line":39,"comment":[],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js","name":"remove","line":98,"func_location":"TextEditorRegistry.add.(unnamed_function_2)","func_start_line":98,"func_end_line":98,"args":["editor"],"code":"    return new Disposable(() => this.remove(editor))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js","name":"TextEditorRegistry.remove","start_line":122,"end_line":126,"comment":[" Remove a `TextEditor`.",""," * `editor` The editor to remove.",""," Returns a {Boolean} indicating whether the editor was successfully removed."],"params":["editor"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration.js","name":"destroy","line":81,"func_location":"Decoration.constructor.(unnamed_function_2)","func_start_line":81,"func_end_line":81,"args":[null],"code":"    this.markerDestroyDisposable = this.marker.onDidDestroy(() => this.destroy())\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration.js","name":"Decoration.destroy","start_line":88,"end_line":96,"comment":[" Essential: Destroy this marker decoration.",""," You can also destroy the marker if you own it, which will destroy this"," decoration."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"setActiveTemplate","line":49,"func_location":"ApplicationMenu.addWindow.focusHandler.(unnamed_function_2)","func_start_line":46,"func_end_line":50,"args":["template"],"code":"    const focusHandler = () => {\r\n      this.lastFocusedWindow = window\r\n      const template = this.windowTemplates.get(window)\r\n      if (template) this.setActiveTemplate(template)\r\n    }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"ApplicationMenu.setActiveTemplate","start_line":32,"end_line":40,"comment":[],"params":["template"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"setPaths","line":610,"func_location":"Project.consumeServices.(unnamed_function_20)","func_start_line":608,"func_end_line":614,"args":[{"type":"object"}],"code":"      provider => {\r\n        this.repositoryProviders.unshift(provider)\r\n        if (this.repositories.includes(null)) { this.setPaths(this.getPaths()) }\r\n        return new Disposable(() => {\r\n          return this.repositoryProviders.splice(this.repositoryProviders.indexOf(provider), 1)\r\n        })\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.setPaths","start_line":339,"end_line":371,"comment":[" Public: Set the paths of the project's directories.",""," * `projectPaths` {Array} of {String} paths."," * `options` An optional {Object} that may contain the following keys:","   * `mustExist` If `true`, throw an Error if any `projectPaths` do not exist. Any remaining `projectPaths` that","     do exist will still be added to the project. Default: `false`.","   * `exact` If `true`, only add a `projectPath` if it names an existing directory. If `false` and any `projectPath`","     is a file or does not exist, its parent directory will be added instead. Default: `false`."],"params":["projectPaths","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"getPaths","line":610,"func_location":"Project.consumeServices.(unnamed_function_20)","func_start_line":608,"func_end_line":614,"args":[{"type":"object"}],"code":"      provider => {\r\n        this.repositoryProviders.unshift(provider)\r\n        if (this.repositories.includes(null)) { this.setPaths(this.getPaths()) }\r\n        return new Disposable(() => {\r\n          return this.repositoryProviders.splice(this.repositoryProviders.indexOf(provider), 1)\r\n        })\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.getPaths","start_line":327,"end_line":329,"comment":["\r\n  Section: Managing Paths\r\n  "," Public: Get an {Array} of {String}s containing the paths of the project's"," directories."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"executeJavaScriptInDevTools","line":939,"func_location":"AtomEnvironment.installUncaughtErrorHandler.(unnamed_function_18).(unnamed_function_20)","func_start_line":938,"func_end_line":940,"args":[{"type":"string"}],"code":"        this.openDevTools().then(() =>\r\n          this.executeJavaScriptInDevTools('DevToolsAPI.showPanel(\"console\")')\r\n        )\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.executeJavaScriptInDevTools","start_line":1068,"end_line":1070,"comment":[" Extended: Execute code in dev tools."],"params":["code"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"openPath","line":371,"func_location":"AtomApplication.handleEvents.(unnamed_function_20)","func_start_line":371,"func_end_line":371,"args":[{"type":"string"},null],"code":"    this.on('application:new-window', () => this.openPath(getLoadSettings()))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.openPath","start_line":786,"end_line":812,"comment":[" Public: Opens a single path, in an existing window if possible.",""," options -","   :pathToOpen - The file path to open","   :pidToKillWhenClosed - The integer of the pid to kill","   :newWindow - Boolean of whether this should be opened in a new window.","   :devMode - Boolean to control the opened window's dev mode.","   :safeMode - Boolean to control the opened window's safe mode.","   :profileStartup - Boolean to control creating a profile of the startup time.","   :window - {AtomWindow} to open file paths in.","   :addToLastWindow - Boolean of whether this should be opened in last focused window."],"params":[["initialPaths","pathToOpen","pidToKillWhenClosed","newWindow","devMode","safeMode","profileStartup","window","clearWindowState","addToLastWindow","env"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"handleSaveError","line":895,"func_location":"Pane.saveItem.(unnamed_function_20)","func_start_line":891,"func_end_line":897,"args":["error","item"],"code":"          .catch(error => {\r\n            if (nextAction) {\r\n              nextAction(error)\r\n            } else {\r\n              this.handleSaveError(error, item)\r\n            }\r\n          })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.handleSaveError","start_line":1221,"end_line":1244,"comment":[],"params":["error","item"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"pickFolder","line":1114,"func_location":"AtomEnvironment.addProjectFolder.(unnamed_function_21)","func_start_line":1113,"func_end_line":1117},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.pickFolder","start_line":556,"end_line":558,"comment":[" Extended: Prompt the user to select one or more folders.",""," * `callback` A {Function} to call once the user has confirmed the selection.","   * `paths` An {Array} of {String} paths that the user selected, or `null`","     if the user dismissed the dialog."],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"focusedWindow","line":372,"func_location":"AtomApplication.handleEvents.(unnamed_function_21)","func_start_line":372,"func_end_line":372,"args":[{"type":"string"},null],"code":"    this.on('application:new-file', () => (this.focusedWindow() || this).openPath())\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.focusedWindow","start_line":748,"end_line":750,"comment":[" Public: Returns the currently focused {AtomWindow} or undefined if none."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"addToProject","line":1115,"func_location":"AtomEnvironment.addProjectFolder.(unnamed_function_21).(unnamed_function_22)","func_start_line":1114,"func_end_line":1116,"args":["resolve"],"code":"      this.pickFolder((selectedPaths) => {\r\n        this.addToProject(selectedPaths || []).then(resolve)\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.addToProject","start_line":1120,"end_line":1127,"comment":[],"params":["projectPaths"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"promptForPathToOpen","line":373,"func_location":"AtomApplication.handleEvents.(unnamed_function_22)","func_start_line":373,"func_end_line":373,"args":[{"type":"string"},null],"code":"    this.on('application:open-dev', () => this.promptForPathToOpen('all', {devMode: true}))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.promptForPathToOpen","start_line":1309,"end_line":1317,"comment":[" Opens a native dialog to prompt the user for a path.",""," Once paths are selected, they're opened in a new or existing {AtomWindow}s.",""," options -","   :type - A String which specifies the type of the dialog, could be 'file',","           'folder' or 'all'. The 'all' is only available on macOS.","   :devMode - A Boolean which controls whether any newly opened windows","              should be in dev mode or not.","   :safeMode - A Boolean which controls whether any newly opened windows","               should be in safe mode or not.","   :window - An {AtomWindow} to use for opening a selected file path.","   :path - An optional String which controls the default path to which the","           file dialog opens."],"params":["type",["devMode","safeMode","window"],"path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"promisify","line":930,"func_location":"Pane.saveItemAs.(unnamed_function_22)","func_start_line":928,"func_end_line":951,"args":[null],"code":"    this.applicationDelegate.showSaveDialog(saveOptions, newItemPath => {\r\n      if (newItemPath) {\r\n        promisify(() => item.saveAs(newItemPath))\r\n          .then(() => {\r\n            if (nextAction) {\r\n              resolveSaveDialogPromise(nextAction())\r\n            } else {\r\n              resolveSaveDialogPromise()\r\n            }\r\n          })\r\n          .catch(error => {\r\n            if (nextAction) {\r\n              resolveSaveDialogPromise(nextAction(error))\r\n            } else {\r\n              this.handleSaveError(error, item)\r\n              resolveSaveDialogPromise()\r\n            }\r\n          })\r\n      } else if (nextAction) {\r\n        resolveSaveDialogPromise(nextAction(new SaveCancelledError('Save Cancelled')))\r\n      } else {\r\n        resolveSaveDialogPromise()\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"promisify","start_line":1262,"end_line":1268,"comment":[],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"promptForPathToOpen","line":374,"func_location":"AtomApplication.handleEvents.(unnamed_function_23)","func_start_line":374,"func_end_line":374,"args":[{"type":"string"},null],"code":"    this.on('application:open-safe', () => this.promptForPathToOpen('all', {safeMode: true}))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.promptForPathToOpen","start_line":1309,"end_line":1317,"comment":[" Opens a native dialog to prompt the user for a path.",""," Once paths are selected, they're opened in a new or existing {AtomWindow}s.",""," options -","   :type - A String which specifies the type of the dialog, could be 'file',","           'folder' or 'all'. The 'all' is only available on macOS.","   :devMode - A Boolean which controls whether any newly opened windows","              should be in dev mode or not.","   :safeMode - A Boolean which controls whether any newly opened windows","               should be in safe mode or not.","   :window - An {AtomWindow} to use for opening a selected file path.","   :path - An optional String which controls the default path to which the","           file dialog opens."],"params":["type",["devMode","safeMode","window"],"path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"focusedWindow","line":376,"func_location":"AtomApplication.handleEvents.(unnamed_function_24)","func_start_line":375,"func_end_line":378,"args":[],"code":"    this.on('application:inspect', ({x, y, atomWindow}) => {\r\n      if (!atomWindow) atomWindow = this.focusedWindow()\r\n      if (atomWindow) atomWindow.browserWindow.inspectElement(x, y)\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.focusedWindow","start_line":748,"end_line":750,"comment":[" Public: Returns the currently focused {AtomWindow} or undefined if none."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js","name":"onDidChange","line":434,"func_location":"PathWatcher.onDidChange.(unnamed_function_25)","func_start_line":433,"func_end_line":435,"args":["callback"],"comment":[" Attach to a new native listener and retry"],"code":"      this.nativeWatcherRegistry.attach(this).then(() => {\r\n        this.onDidChange(callback)\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js","name":"PathWatcher.onDidChange","start_line":425,"end_line":443,"comment":[" Private: Attach another {Function} to be called with each batch of filesystem events. See {watchPath} for the"," spec of the callback's argument.",""," * `callback` {Function} to be called with each batch of filesystem events.",""," Returns a {Disposable} that will stop the underlying watcher when all callbacks mapped to it have been disposed."],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getHiddenInput","line":1724,"func_location":"TextEditorComponent.didCompositionStart.(unnamed_function_25)","func_start_line":1721,"func_end_line":1726,"args":[],"code":"      process.nextTick(() => {\r\n        // Disabling the hidden input makes it lose focus as well, so we have to\r\n        // re-enable and re-focus it.\r\n        this.getHiddenInput().disabled = false\r\n        this.getHiddenInput().focus()\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getHiddenInput","start_line":2960,"end_line":2962,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getHiddenInput","line":1725,"func_location":"TextEditorComponent.didCompositionStart.(unnamed_function_25)","func_start_line":1721,"func_end_line":1726,"args":[],"code":"      process.nextTick(() => {\r\n        // Disabling the hidden input makes it lose focus as well, so we have to\r\n        // re-enable and re-focus it.\r\n        this.getHiddenInput().disabled = false\r\n        this.getHiddenInput().focus()\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getHiddenInput","start_line":2960,"end_line":2962,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"handleSaveError","line":942,"func_location":"Pane.saveItemAs.(unnamed_function_22).(unnamed_function_25)","func_start_line":938,"func_end_line":945,"args":["error","item"],"code":"          .catch(error => {\r\n            if (nextAction) {\r\n              resolveSaveDialogPromise(nextAction(error))\r\n            } else {\r\n              this.handleSaveError(error, item)\r\n              resolveSaveDialogPromise()\r\n            }\r\n          })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.handleSaveError","start_line":1221,"end_line":1244,"comment":[],"params":["error","item"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"autoscrollOnMouseDrag","line":1815,"func_location":"didDrag.(unnamed_function_26)","func_start_line":1814,"func_end_line":1819,"args":["event"],"code":"      didDrag: (event) => {\r\n        this.autoscrollOnMouseDrag(event)\r\n        const screenPosition = this.screenPositionForMouseEvent(event)\r\n        model.selectToScreenPosition(screenPosition, {suppressSelectionMerge: true, autoscroll: false})\r\n        this.updateSync()\r\n      },\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.autoscrollOnMouseDrag","start_line":1922,"end_line":1959,"comment":[],"params":[["clientX","clientY"],"verticalOnly"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"screenPositionForMouseEvent","line":1816,"func_location":"didDrag.(unnamed_function_26)","func_start_line":1814,"func_end_line":1819,"args":["event"],"code":"      didDrag: (event) => {\r\n        this.autoscrollOnMouseDrag(event)\r\n        const screenPosition = this.screenPositionForMouseEvent(event)\r\n        model.selectToScreenPosition(screenPosition, {suppressSelectionMerge: true, autoscroll: false})\r\n        this.updateSync()\r\n      },\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.screenPositionForMouseEvent","start_line":1961,"end_line":1963,"comment":[],"params":["event"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateSync","line":1818,"func_location":"didDrag.(unnamed_function_26)","func_start_line":1814,"func_end_line":1819,"args":[],"code":"      didDrag: (event) => {\r\n        this.autoscrollOnMouseDrag(event)\r\n        const screenPosition = this.screenPositionForMouseEvent(event)\r\n        model.selectToScreenPosition(screenPosition, {suppressSelectionMerge: true, autoscroll: false})\r\n        this.updateSync()\r\n      },\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateSync","start_line":221,"end_line":289,"comment":[],"params":["useScheduler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"load","line":638,"func_location":"Package.loadSettings.loadSettingsFile.(unnamed_function_26)","func_start_line":637,"func_end_line":649},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"SettingsFile.load","start_line":1109,"end_line":1117,"comment":[],"params":["path","callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateSync","line":1823,"func_location":"didStopDragging.(unnamed_function_27)","func_start_line":1820,"func_end_line":1824,"args":[],"code":"      didStopDragging: () => {\r\n        model.finalizeSelections()\r\n        model.mergeIntersectingSelections()\r\n        this.updateSync()\r\n      }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateSync","start_line":221,"end_line":289,"comment":[],"params":["useScheduler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"open","line":1164,"func_location":"AtomEnvironment.attemptRestoreProjectStateForPaths.(unnamed_function_27)","func_start_line":1162,"func_end_line":1177},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.open","start_line":547,"end_line":549,"comment":["\r\n  Section: Managing The Atom Window\r\n  "," Essential: Open a new Atom window using the given options.",""," Calling this method without an options parameter will open a prompt to pick"," a file/folder to open in the new window.",""," * `params` An {Object} with the following keys:","   * `pathsToOpen`  An {Array} of {String} paths to open.","   * `newWindow` A {Boolean}, true to always open a new window instead of","     reusing existing windows depending on the paths to open.","   * `devMode` A {Boolean}, true to open the window in development mode.","     Development mode loads the Atom source from the locally cloned","     repository and also loads all the packages in ~/.atom/dev/packages","   * `safeMode` A {Boolean}, true to open the window in safe mode. Safe","     mode prevents all packages installed to ~/.atom/packages from loading."],"params":["params"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"inDevMode","line":1167,"func_location":"AtomEnvironment.attemptRestoreProjectStateForPaths.(unnamed_function_27)","func_start_line":1162,"func_end_line":1177,"args":[],"code":"      }, response => {\r\n        if (response === 0) {\r\n          this.open({\r\n            pathsToOpen: projectPaths.concat(filesToOpen),\r\n            newWindow: true,\r\n            devMode: this.inDevMode(),\r\n            safeMode: this.inSafeMode()\r\n          })\r\n          resolveDiscardStatePromise(Promise.resolve(null))\r\n        } else if (response === 1) {\r\n          for (let selectedPath of projectPaths) {\r\n            this.project.addPath(selectedPath)\r\n          }\r\n          resolveDiscardStatePromise(Promise.all(filesToOpen.map(file => this.workspace.open(file))))\r\n        }\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.inDevMode","start_line":456,"end_line":459,"comment":["\r\n  Section: Atom Details\r\n  "," Public: Returns a {Boolean} that is `true` if the current window is in development mode."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"inSafeMode","line":1168,"func_location":"AtomEnvironment.attemptRestoreProjectStateForPaths.(unnamed_function_27)","func_start_line":1162,"func_end_line":1177,"args":[],"code":"      }, response => {\r\n        if (response === 0) {\r\n          this.open({\r\n            pathsToOpen: projectPaths.concat(filesToOpen),\r\n            newWindow: true,\r\n            devMode: this.inDevMode(),\r\n            safeMode: this.inSafeMode()\r\n          })\r\n          resolveDiscardStatePromise(Promise.resolve(null))\r\n        } else if (response === 1) {\r\n          for (let selectedPath of projectPaths) {\r\n            this.project.addPath(selectedPath)\r\n          }\r\n          resolveDiscardStatePromise(Promise.all(filesToOpen.map(file => this.workspace.open(file))))\r\n        }\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.inSafeMode","start_line":462,"end_line":465,"comment":[" Public: Returns a {Boolean} that is `true` if the current window is in safe mode."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"promptToSaveItem","line":1215,"func_location":"Pane.close.(unnamed_function_27)","func_start_line":1215,"func_end_line":1215,"args":[null],"code":"    return Promise.all(this.getItems().map(item => this.promptToSaveItem(item)))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.promptToSaveItem","start_line":800,"end_line":848,"comment":[],"params":["item","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"autoscrollOnMouseDrag","line":1869,"func_location":"didDrag.(unnamed_function_28)","func_start_line":1868,"func_end_line":1878,"args":["event",{"type":"boolean"}],"code":"      didDrag: (event) => {\r\n        this.autoscrollOnMouseDrag(event, true)\r\n        const dragRow = this.screenPositionForMouseEvent(event).row\r\n        const draggedLineScreenRange = Range(Point(dragRow, 0), Point(dragRow + 1, 0))\r\n        model.getLastSelection().setScreenRange(draggedLineScreenRange.union(initialScreenRange), {\r\n          reversed: dragRow < initialScreenRange.start.row,\r\n          autoscroll: false,\r\n          preserveFolds: true\r\n        })\r\n        this.updateSync()\r\n      },\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.autoscrollOnMouseDrag","start_line":1922,"end_line":1959,"comment":[],"params":[["clientX","clientY"],"verticalOnly"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"screenPositionForMouseEvent","line":1870,"func_location":"didDrag.(unnamed_function_28)","func_start_line":1868,"func_end_line":1878,"args":["event"],"code":"      didDrag: (event) => {\r\n        this.autoscrollOnMouseDrag(event, true)\r\n        const dragRow = this.screenPositionForMouseEvent(event).row\r\n        const draggedLineScreenRange = Range(Point(dragRow, 0), Point(dragRow + 1, 0))\r\n        model.getLastSelection().setScreenRange(draggedLineScreenRange.union(initialScreenRange), {\r\n          reversed: dragRow < initialScreenRange.start.row,\r\n          autoscroll: false,\r\n          preserveFolds: true\r\n        })\r\n        this.updateSync()\r\n      },\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.screenPositionForMouseEvent","start_line":1961,"end_line":1963,"comment":[],"params":["event"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateSync","line":1877,"func_location":"didDrag.(unnamed_function_28)","func_start_line":1868,"func_end_line":1878,"args":[],"code":"      didDrag: (event) => {\r\n        this.autoscrollOnMouseDrag(event, true)\r\n        const dragRow = this.screenPositionForMouseEvent(event).row\r\n        const draggedLineScreenRange = Range(Point(dragRow, 0), Point(dragRow + 1, 0))\r\n        model.getLastSelection().setScreenRange(draggedLineScreenRange.union(initialScreenRange), {\r\n          reversed: dragRow < initialScreenRange.start.row,\r\n          autoscroll: false,\r\n          preserveFolds: true\r\n        })\r\n        this.updateSync()\r\n      },\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateSync","start_line":221,"end_line":289,"comment":[],"params":["useScheduler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"destroy","line":1217,"func_location":"Pane.close.(unnamed_function_28)","func_start_line":1216,"func_end_line":1218,"args":[{"type":"boolean"}],"code":"      .then(results => {\r\n        if (!results.includes(false)) return this.destroy()\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.destroy","start_line":1022,"end_line":1039,"comment":[" Public: Close the pane and destroy all its items.",""," If this is the last pane, all the items will be destroyed but the pane"," itself will not be destroyed."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateSync","line":1881,"func_location":"didStopDragging.(unnamed_function_29)","func_start_line":1879,"func_end_line":1882,"args":[],"code":"      didStopDragging: () => {\r\n        model.mergeIntersectingSelections()\r\n        this.updateSync()\r\n      }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateSync","start_line":221,"end_line":289,"comment":[],"params":["useScheduler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"setState","line":51,"func_location":"AutoUpdateManager.initialize.(unnamed_function_3)","func_start_line":50,"func_end_line":53,"args":["NoUpdateAvailableState"],"code":"    autoUpdater.on('update-not-available', () => {\r\n      this.setState(NoUpdateAvailableState)\r\n      this.emitWindowEvent('update-not-available')\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"AutoUpdateManager.setState","start_line":103,"end_line":108,"comment":[],"params":["state","errorMessage"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"emitWindowEvent","line":52,"func_location":"AutoUpdateManager.initialize.(unnamed_function_3)","func_start_line":50,"func_end_line":53,"args":[{"type":"string"}],"code":"    autoUpdater.on('update-not-available', () => {\r\n      this.setState(NoUpdateAvailableState)\r\n      this.emitWindowEvent('update-not-available')\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"AutoUpdateManager.emitWindowEvent","start_line":97,"end_line":101,"comment":[],"params":["eventName","payload"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateSync","line":216,"func_location":"TextEditorComponent.scheduleUpdate.(unnamed_function_3)","func_start_line":215,"func_end_line":217,"args":[{"type":"boolean"}],"code":"      etch.getScheduler().updateDocument(() => {\r\n        if (this.updateScheduled) this.updateSync(true)\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateSync","start_line":221,"end_line":289,"comment":[],"params":["useScheduler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"isLastSelection","line":100,"func_location":"Selection.setBufferRange.(unnamed_function_3)","func_start_line":96,"func_end_line":103,"args":[],"code":"    this.modifySelection(() => {\r\n      const needsFlash = options.flash\r\n      options.flash = null\r\n      this.marker.setBufferRange(bufferRange, options)\r\n      const autoscroll = options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n      if (autoscroll) this.autoscroll()\r\n      if (needsFlash) this.decoration.flash('flash', this.editor.selectionFlashDuration)\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.isLastSelection","start_line":29,"end_line":31,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"unset","line":732,"func_location":"Config.unset.(unnamed_function_3)","func_start_line":732,"func_end_line":732,"args":[null],"code":"      this.pendingOperations.push(() => this.unset(keyPath, options))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.unset","start_line":730,"end_line":766,"comment":[" Essential: Restore the setting at `keyPath` to its default value.",""," * `keyPath` The {String} name of the key."," * `options` (optional) {Object}","   * `scopeSelector` (optional) {String}. See {::set}","   * `source` (optional) {String}. See {::set}"],"params":["keyPath","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js","name":"betterBaseName","line":54,"func_location":"ReopenProjectMenuManager.taskDescription.(unnamed_function_3)","func_start_line":54,"func_end_line":54,"args":[{"type":"string"}],"code":"    return paths.map(path => `${ReopenProjectMenuManager.betterBaseName(path)} (${path})`).join(' ')\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js","name":"ReopenProjectMenuManager.betterBaseName","start_line":141,"end_line":145,"comment":[],"params":["directory"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js","name":"cancel","line":21,"func_location":"didConfirmSelection.(unnamed_function_3)","func_start_line":20,"func_end_line":23,"args":[],"code":"      didConfirmSelection: (project) => {\r\n        this.cancel()\r\n        this.callback(project.value)\r\n      },\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js","name":"ReopenProjectListView.cancel","start_line":40,"end_line":50,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"isAlive","line":278,"func_location":"TextMateLanguageMode.tokenizeInBackground.(unnamed_function_3)","func_start_line":276,"func_end_line":279,"args":[],"code":"    _.defer(() => {\r\n      this.pendingChunk = false\r\n      if (this.isAlive() && this.buffer.isAlive()) this.tokenizeNextChunk()\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.isAlive","start_line":47,"end_line":49,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"tokenizeNextChunk","line":278,"func_location":"TextMateLanguageMode.tokenizeInBackground.(unnamed_function_3)","func_start_line":276,"func_end_line":279,"args":[],"code":"    _.defer(() => {\r\n      this.pendingChunk = false\r\n      if (this.isAlive() && this.buffer.isAlive()) this.tokenizeNextChunk()\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.tokenizeNextChunk","start_line":282,"end_line":319,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"subscribeToBuffer","line":105,"func_location":"GitRepository.constructor.(unnamed_function_3)","func_start_line":105,"func_end_line":105,"args":[null],"code":"      this.project.getBuffers().forEach(buffer => this.subscribeToBuffer(buffer))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.subscribeToBuffer","start_line":495,"end_line":511,"comment":["\r\n  Section: Private\r\n  "," Subscribes to buffer events."],"params":["buffer"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js","name":"getPackageTranspilerSpecForFilePath","line":47,"func_location":"getCachePath.(unnamed_function_3)","func_start_line":46,"func_end_line":53,"args":["filePath"],"code":"      getCachePath: (sourceCode, filePath) => {\r\n        const spec = this.getPackageTranspilerSpecForFilePath(filePath)\r\n        if (spec) {\r\n          return this.getCachePath(sourceCode, filePath, spec)\r\n        }\r\n\r\n        return transpiler.getCachePath(sourceCode, filePath)\r\n      },\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js","name":"PackageTranspilationRegistry.getPackageTranspilerSpecForFilePath","start_line":78,"end_line":110,"comment":[],"params":["filePath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js","name":"getCachePath","line":49,"func_location":"getCachePath.(unnamed_function_3)","func_start_line":46,"func_end_line":53,"args":["sourceCode","filePath","spec"],"code":"      getCachePath: (sourceCode, filePath) => {\r\n        const spec = this.getPackageTranspilerSpecForFilePath(filePath)\r\n        if (spec) {\r\n          return this.getCachePath(sourceCode, filePath, spec)\r\n        }\r\n\r\n        return transpiler.getCachePath(sourceCode, filePath)\r\n      },\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js","name":"PackageTranspilationRegistry.getCachePath","start_line":112,"end_line":131,"comment":[],"params":["sourceCode","filePath","spec"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/storage-folder.js","name":"pathForKey","line":24,"func_location":"StorageFolder.load.(unnamed_function_3)","func_start_line":22,"func_end_line":39,"args":["name"],"code":"    return new Promise(resolve => {\r\n      if (!this.path) return resolve(null)\r\n      const statePath = this.pathForKey(name)\r\n      fs.readFile(statePath, 'utf8', (error, stateString) => {\r\n        if (error && error.code !== 'ENOENT') {\r\n          console.warn(`Error reading state file: ${statePath}`, error.stack, error)\r\n        }\r\n\r\n        if (!stateString) return resolve(null)\r\n\r\n        try {\r\n          resolve(JSON.parse(stateString))\r\n        } catch (error) {\r\n          console.warn(`Error parsing state file: ${statePath}`, error.stack, error)\r\n          resolve(null)\r\n        }\r\n      })\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/storage-folder.js","name":"StorageFolder.pathForKey","start_line":42,"end_line":44,"comment":[],"params":["name"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"requireMainModule","line":178,"func_location":"Package.initializeIfNeeded.(unnamed_function_3)","func_start_line":172,"func_end_line":186,"args":[],"code":"    this.measure('initializeTime', () => {\r\n      try {\r\n        // The main module's `initialize()` method is guaranteed to be called\r\n        // before its `activate()`. This gives you a chance to handle the\r\n        // serialized package state before the package's derserializers and view\r\n        // providers are used.\r\n        if (!this.mainModule) this.requireMainModule()\r\n        if (typeof this.mainModule.initialize === 'function') {\r\n          this.mainModule.initialize(this.packageManager.getPackageState(this.name) || {})\r\n        }\r\n        this.mainInitialized = true\r\n      } catch (error) {\r\n        this.handleError(`Failed to initialize the ${this.name} package`, error)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.requireMainModule","start_line":755,"end_line":784,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"handleError","line":184,"func_location":"Package.initializeIfNeeded.(unnamed_function_3)","func_start_line":172,"func_end_line":186,"args":[null,"error"],"code":"    this.measure('initializeTime', () => {\r\n      try {\r\n        // The main module's `initialize()` method is guaranteed to be called\r\n        // before its `activate()`. This gives you a chance to handle the\r\n        // serialized package state before the package's derserializers and view\r\n        // providers are used.\r\n        if (!this.mainModule) this.requireMainModule()\r\n        if (typeof this.mainModule.initialize === 'function') {\r\n          this.mainModule.initialize(this.packageManager.getPackageState(this.name) || {})\r\n        }\r\n        this.mainInitialized = true\r\n      } catch (error) {\r\n        this.handleError(`Failed to initialize the ${this.name} package`, error)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.handleError","start_line":1085,"end_line":1105,"comment":[],"params":["message","error"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"constructor","line":84,"func_location":"AtomApplication.open.(unnamed_function_3)","func_start_line":84,"func_end_line":84,"args":[{"type":"string"},null],"code":"    client.on('error', () => new AtomApplication(options).initialize(options))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.constructor","start_line":91,"end_line":136,"comment":[],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"initialize","line":84,"func_location":"AtomApplication.open.(unnamed_function_3)","func_start_line":84,"func_end_line":84,"args":[{"type":"string"},null],"code":"    client.on('error', () => new AtomApplication(options).initialize(options))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.initialize","start_line":142,"end_line":161,"comment":[" This stuff was previously done in the constructor, but we want to be able to construct this object"," for testing purposes without booting up the world. As you add tests, feel free to move instantiation"," of these various sub-objects into the constructor, but you'll need to remove the side-effects they"," perform during their construction, adding an initialize method that you call here."],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js","name":"updateAndMonitorEditorSettings","line":153,"func_location":"TextEditorRegistry.maintainConfig.languageChangeSubscription.(unnamed_function_3)","func_start_line":152,"func_end_line":154,"args":["editor","oldLanguageMode"],"code":"    const languageChangeSubscription = editor.buffer.onDidChangeLanguageMode((newLanguageMode, oldLanguageMode) => {\r\n      this.updateAndMonitorEditorSettings(editor, oldLanguageMode)\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js","name":"TextEditorRegistry.updateAndMonitorEditorSettings","start_line":218,"end_line":222,"comment":[],"params":["editor","oldLanguageMode"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js","name":"installApmCommand","line":32,"func_location":"CommandInstaller.installShellCommandsInteractively.(unnamed_function_3)","func_start_line":30,"func_end_line":39},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js","name":"CommandInstaller.installApmCommand","start_line":65,"end_line":72,"comment":[],"params":["askForPrivilege","callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config-file.js","name":"reload","line":53,"func_location":"ConfigFile.constructor.(unnamed_function_3)","func_start_line":53,"func_end_line":53,"args":[null,{"type":"number"}],"code":"    this.requestLoad = _.debounce(() => this.reload(), 200)\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config-file.js","name":"ConfigFile.reload","start_line":102,"end_line":117,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"removeBuffer","line":765,"func_location":"Project.subscribeToBuffer.(unnamed_function_30)","func_start_line":765,"func_end_line":765,"args":[null],"code":"    buffer.onDidDestroy(() => this.removeBuffer(buffer))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.removeBuffer","start_line":739,"end_line":742,"comment":[" Removes a {TextBuffer} association from the project.",""," Returns the removed {TextBuffer}."],"params":["buffer"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"getPaths","line":767,"func_location":"Project.subscribeToBuffer.(unnamed_function_31)","func_start_line":766,"func_end_line":770,"args":[],"code":"    buffer.onDidChangePath(() => {\r\n      if (!(this.getPaths().length > 0)) {\r\n        this.setPaths([path.dirname(buffer.getPath())])\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.getPaths","start_line":327,"end_line":329,"comment":["\r\n  Section: Managing Paths\r\n  "," Public: Get an {Array} of {String}s containing the paths of the project's"," directories."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"setPaths","line":768,"func_location":"Project.subscribeToBuffer.(unnamed_function_31)","func_start_line":766,"func_end_line":770,"args":[null],"code":"    buffer.onDidChangePath(() => {\r\n      if (!(this.getPaths().length > 0)) {\r\n        this.setPaths([path.dirname(buffer.getPath())])\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.setPaths","start_line":339,"end_line":371,"comment":[" Public: Set the paths of the project's directories.",""," * `projectPaths` {Array} of {String} paths."," * `options` An optional {Object} that may contain the following keys:","   * `mustExist` If `true`, throw an Error if any `projectPaths` do not exist. Any remaining `projectPaths` that","     do exist will still be added to the project. Default: `false`.","   * `exact` If `true`, only add a `projectPath` if it names an existing directory. If `false` and any `projectPath`","     is a file or does not exist, its parent directory will be added instead. Default: `false`."],"params":["projectPaths","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"scheduleUpdate","line":2005,"func_location":"TextEditorComponent.startCursorBlinking.(unnamed_function_32)","func_start_line":2003,"func_end_line":2006,"args":[{"type":"boolean"}],"code":"      this.cursorBlinkIntervalHandle = window.setInterval(() => {\r\n        this.cursorsBlinkedOff = !this.cursorsBlinkedOff\r\n        this.scheduleUpdate(true)\r\n      }, (this.props.cursorBlinkPeriod || CURSOR_BLINK_PERIOD) / 2)\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.scheduleUpdate","start_line":204,"end_line":219,"comment":[],"params":["nextUpdateOnlyBlinksCursors"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"renderedScreenLineForRow","line":2263,"func_location":"TextEditorComponent.measureHorizontalPositions.(unnamed_function_33)","func_start_line":2260,"func_end_line":2290,"args":["row"],"code":"    this.horizontalPositionsToMeasure.forEach((columnsToMeasure, row) => {\r\n      columnsToMeasure.sort((a, b) => a - b)\r\n\r\n      const screenLine = this.renderedScreenLineForRow(row)\r\n      const lineComponent = this.lineComponentsByScreenLineId.get(screenLine.id)\r\n\r\n      if (!lineComponent) {\r\n        const error = new Error('Requested measurement of a line component that is not currently rendered')\r\n        error.metadata = {\r\n          row,\r\n          columnsToMeasure,\r\n          renderedScreenLineIds: this.renderedScreenLines.map((line) => line.id),\r\n          extraRenderedScreenLineIds: Array.from(this.extraRenderedScreenLines.keys()),\r\n          lineComponentScreenLineIds: Array.from(this.lineComponentsByScreenLineId.keys()),\r\n          renderedStartRow: this.getRenderedStartRow(),\r\n          renderedEndRow: this.getRenderedEndRow(),\r\n          requestedScreenLineId: screenLine.id\r\n        }\r\n        throw error\r\n      }\r\n\r\n      const lineNode = lineComponent.element\r\n      const textNodes = lineComponent.textNodes\r\n      let positionsForLine = this.horizontalPixelPositionsByScreenLineId.get(screenLine.id)\r\n      if (positionsForLine == null) {\r\n        positionsForLine = new Map()\r\n        this.horizontalPixelPositionsByScreenLineId.set(screenLine.id, positionsForLine)\r\n      }\r\n\r\n      this.measureHorizontalPositionsOnLine(lineNode, textNodes, columnsToMeasure, positionsForLine)\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.renderedScreenLineForRow","start_line":956,"end_line":961,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedStartRow","line":2274,"func_location":"TextEditorComponent.measureHorizontalPositions.(unnamed_function_33)","func_start_line":2260,"func_end_line":2290,"args":[],"code":"    this.horizontalPositionsToMeasure.forEach((columnsToMeasure, row) => {\r\n      columnsToMeasure.sort((a, b) => a - b)\r\n\r\n      const screenLine = this.renderedScreenLineForRow(row)\r\n      const lineComponent = this.lineComponentsByScreenLineId.get(screenLine.id)\r\n\r\n      if (!lineComponent) {\r\n        const error = new Error('Requested measurement of a line component that is not currently rendered')\r\n        error.metadata = {\r\n          row,\r\n          columnsToMeasure,\r\n          renderedScreenLineIds: this.renderedScreenLines.map((line) => line.id),\r\n          extraRenderedScreenLineIds: Array.from(this.extraRenderedScreenLines.keys()),\r\n          lineComponentScreenLineIds: Array.from(this.lineComponentsByScreenLineId.keys()),\r\n          renderedStartRow: this.getRenderedStartRow(),\r\n          renderedEndRow: this.getRenderedEndRow(),\r\n          requestedScreenLineId: screenLine.id\r\n        }\r\n        throw error\r\n      }\r\n\r\n      const lineNode = lineComponent.element\r\n      const textNodes = lineComponent.textNodes\r\n      let positionsForLine = this.horizontalPixelPositionsByScreenLineId.get(screenLine.id)\r\n      if (positionsForLine == null) {\r\n        positionsForLine = new Map()\r\n        this.horizontalPixelPositionsByScreenLineId.set(screenLine.id, positionsForLine)\r\n      }\r\n\r\n      this.measureHorizontalPositionsOnLine(lineNode, textNodes, columnsToMeasure, positionsForLine)\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedStartRow","start_line":2720,"end_line":2726,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedEndRow","line":2275,"func_location":"TextEditorComponent.measureHorizontalPositions.(unnamed_function_33)","func_start_line":2260,"func_end_line":2290,"args":[],"code":"    this.horizontalPositionsToMeasure.forEach((columnsToMeasure, row) => {\r\n      columnsToMeasure.sort((a, b) => a - b)\r\n\r\n      const screenLine = this.renderedScreenLineForRow(row)\r\n      const lineComponent = this.lineComponentsByScreenLineId.get(screenLine.id)\r\n\r\n      if (!lineComponent) {\r\n        const error = new Error('Requested measurement of a line component that is not currently rendered')\r\n        error.metadata = {\r\n          row,\r\n          columnsToMeasure,\r\n          renderedScreenLineIds: this.renderedScreenLines.map((line) => line.id),\r\n          extraRenderedScreenLineIds: Array.from(this.extraRenderedScreenLines.keys()),\r\n          lineComponentScreenLineIds: Array.from(this.lineComponentsByScreenLineId.keys()),\r\n          renderedStartRow: this.getRenderedStartRow(),\r\n          renderedEndRow: this.getRenderedEndRow(),\r\n          requestedScreenLineId: screenLine.id\r\n        }\r\n        throw error\r\n      }\r\n\r\n      const lineNode = lineComponent.element\r\n      const textNodes = lineComponent.textNodes\r\n      let positionsForLine = this.horizontalPixelPositionsByScreenLineId.get(screenLine.id)\r\n      if (positionsForLine == null) {\r\n        positionsForLine = new Map()\r\n        this.horizontalPixelPositionsByScreenLineId.set(screenLine.id, positionsForLine)\r\n      }\r\n\r\n      this.measureHorizontalPositionsOnLine(lineNode, textNodes, columnsToMeasure, positionsForLine)\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedEndRow","start_line":2728,"end_line":2737,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"measureHorizontalPositionsOnLine","line":2289,"func_location":"TextEditorComponent.measureHorizontalPositions.(unnamed_function_33)","func_start_line":2260,"func_end_line":2290,"args":["lineNode","textNodes","columnsToMeasure","positionsForLine"],"code":"    this.horizontalPositionsToMeasure.forEach((columnsToMeasure, row) => {\r\n      columnsToMeasure.sort((a, b) => a - b)\r\n\r\n      const screenLine = this.renderedScreenLineForRow(row)\r\n      const lineComponent = this.lineComponentsByScreenLineId.get(screenLine.id)\r\n\r\n      if (!lineComponent) {\r\n        const error = new Error('Requested measurement of a line component that is not currently rendered')\r\n        error.metadata = {\r\n          row,\r\n          columnsToMeasure,\r\n          renderedScreenLineIds: this.renderedScreenLines.map((line) => line.id),\r\n          extraRenderedScreenLineIds: Array.from(this.extraRenderedScreenLines.keys()),\r\n          lineComponentScreenLineIds: Array.from(this.lineComponentsByScreenLineId.keys()),\r\n          renderedStartRow: this.getRenderedStartRow(),\r\n          renderedEndRow: this.getRenderedEndRow(),\r\n          requestedScreenLineId: screenLine.id\r\n        }\r\n        throw error\r\n      }\r\n\r\n      const lineNode = lineComponent.element\r\n      const textNodes = lineComponent.textNodes\r\n      let positionsForLine = this.horizontalPixelPositionsByScreenLineId.get(screenLine.id)\r\n      if (positionsForLine == null) {\r\n        positionsForLine = new Map()\r\n        this.horizontalPixelPositionsByScreenLineId.set(screenLine.id, positionsForLine)\r\n      }\r\n\r\n      this.measureHorizontalPositionsOnLine(lineNode, textNodes, columnsToMeasure, positionsForLine)\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.measureHorizontalPositionsOnLine","start_line":2294,"end_line":2344,"comment":[],"params":["lineNode","textNodes","columnsToMeasure","positions"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"activateNow","line":859,"func_location":"Package.subscribeToActivationCommands.(unnamed_function_33).(unnamed_function_35)","func_start_line":853,"func_end_line":864,"args":[],"code":"          this.activationCommandSubscriptions.add(this.commandRegistry.onWillDispatch(event => {\r\n            if (event.type !== command) return\r\n            let currentTarget = event.target\r\n            while (currentTarget) {\r\n              if (currentTarget.webkitMatchesSelector(selector)) {\r\n                this.activationCommandSubscriptions.dispose()\r\n                this.activateNow()\r\n                break\r\n              }\r\n              currentTarget = currentTarget.parentElement\r\n            }\r\n          }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.activateNow","start_line":212,"end_line":236,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"activateNow","line":895,"func_location":"Package.subscribeToActivationHooks.(unnamed_function_36)","func_start_line":895,"func_end_line":895,"args":["hook",null],"code":"          this.packageManager.onDidTriggerActivationHook(hook, () => this.activateNow())\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.activateNow","start_line":212,"end_line":236,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"scheduleUpdate","line":2535,"func_location":"TextEditorComponent.addBlockDecoration.didUpdateDisposable.(unnamed_function_37)","func_start_line":2526,"func_end_line":2543,"args":[],"code":"      const didUpdateDisposable = marker.bufferMarker.onDidChange(({textChanged}) => {\r\n        const isValid = marker.isValid()\r\n        if (wasValid && !isValid) {\r\n          wasValid = false\r\n          this.blockDecorationsToMeasure.delete(decoration)\r\n          this.heightsByBlockDecoration.delete(decoration)\r\n          this.blockDecorationsByElement.delete(element)\r\n          this.blockDecorationResizeObserver.unobserve(element)\r\n          this.lineTopIndex.removeBlock(decoration)\r\n          this.scheduleUpdate()\r\n        } else if (!wasValid && isValid) {\r\n          wasValid = true\r\n          this.addBlockDecoration(decoration, false)\r\n        } else if (isValid && !textChanged) {\r\n          this.lineTopIndex.moveBlock(decoration, marker.getHeadScreenPosition().row)\r\n          this.scheduleUpdate()\r\n        }\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.scheduleUpdate","start_line":204,"end_line":219,"comment":[],"params":["nextUpdateOnlyBlinksCursors"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"addBlockDecoration","line":2538,"func_location":"TextEditorComponent.addBlockDecoration.didUpdateDisposable.(unnamed_function_37)","func_start_line":2526,"func_end_line":2543,"args":["decoration",{"type":"boolean"}],"code":"      const didUpdateDisposable = marker.bufferMarker.onDidChange(({textChanged}) => {\r\n        const isValid = marker.isValid()\r\n        if (wasValid && !isValid) {\r\n          wasValid = false\r\n          this.blockDecorationsToMeasure.delete(decoration)\r\n          this.heightsByBlockDecoration.delete(decoration)\r\n          this.blockDecorationsByElement.delete(element)\r\n          this.blockDecorationResizeObserver.unobserve(element)\r\n          this.lineTopIndex.removeBlock(decoration)\r\n          this.scheduleUpdate()\r\n        } else if (!wasValid && isValid) {\r\n          wasValid = true\r\n          this.addBlockDecoration(decoration, false)\r\n        } else if (isValid && !textChanged) {\r\n          this.lineTopIndex.moveBlock(decoration, marker.getHeadScreenPosition().row)\r\n          this.scheduleUpdate()\r\n        }\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.addBlockDecoration","start_line":2508,"end_line":2560,"comment":[],"params":["decoration","subscribeToChanges"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"scheduleUpdate","line":2541,"func_location":"TextEditorComponent.addBlockDecoration.didUpdateDisposable.(unnamed_function_37)","func_start_line":2526,"func_end_line":2543,"args":[],"code":"      const didUpdateDisposable = marker.bufferMarker.onDidChange(({textChanged}) => {\r\n        const isValid = marker.isValid()\r\n        if (wasValid && !isValid) {\r\n          wasValid = false\r\n          this.blockDecorationsToMeasure.delete(decoration)\r\n          this.heightsByBlockDecoration.delete(decoration)\r\n          this.blockDecorationsByElement.delete(element)\r\n          this.blockDecorationResizeObserver.unobserve(element)\r\n          this.lineTopIndex.removeBlock(decoration)\r\n          this.scheduleUpdate()\r\n        } else if (!wasValid && isValid) {\r\n          wasValid = true\r\n          this.addBlockDecoration(decoration, false)\r\n        } else if (isValid && !textChanged) {\r\n          this.lineTopIndex.moveBlock(decoration, marker.getHeadScreenPosition().row)\r\n          this.scheduleUpdate()\r\n        }\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.scheduleUpdate","start_line":204,"end_line":219,"comment":[],"params":["nextUpdateOnlyBlinksCursors"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"isNativeModule","line":954,"func_location":"Package.getNativeModuleDependencyPaths.traversePath.(unnamed_function_37)","func_start_line":951,"func_end_line":958,"args":["modulePath"],"code":"    var traversePath = nodeModulesPath => {\r\n      try {\r\n        for (let modulePath of fs.listSync(nodeModulesPath)) {\r\n          if (this.isNativeModule(modulePath)) nativeModulePaths.push(modulePath)\r\n          traversePath(path.join(modulePath, 'node_modules'))\r\n        }\r\n      } catch (error) {}\r\n    }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.isNativeModule","start_line":924,"end_line":930,"comment":[" Does the given module path contain native code?"],"params":["modulePath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"scheduleUpdate","line":2556,"func_location":"TextEditorComponent.addBlockDecoration.didDestroyDisposable.(unnamed_function_38)","func_start_line":2545,"func_end_line":2558,"args":[],"code":"      const didDestroyDisposable = decoration.onDidDestroy(() => {\r\n        didUpdateDisposable.dispose()\r\n        didDestroyDisposable.dispose()\r\n\r\n        if (wasValid) {\r\n          wasValid = false\r\n          this.blockDecorationsToMeasure.delete(decoration)\r\n          this.heightsByBlockDecoration.delete(decoration)\r\n          this.blockDecorationsByElement.delete(element)\r\n          this.blockDecorationResizeObserver.unobserve(element)\r\n          this.lineTopIndex.removeBlock(decoration)\r\n          this.scheduleUpdate()\r\n        }\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.scheduleUpdate","start_line":204,"end_line":219,"comment":[],"params":["nextUpdateOnlyBlinksCursors"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"runRebuildProcess","line":999,"func_location":"Package.rebuild.(unnamed_function_38)","func_start_line":998,"func_end_line":1009},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.runRebuildProcess","start_line":1019,"end_line":1030,"comment":[],"params":["done"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"getBuildFailureOutputStorageKey","line":1001,"func_location":"Package.rebuild.(unnamed_function_38).(unnamed_function_39)","func_start_line":999,"func_end_line":1008,"args":[null],"code":"      this.runRebuildProcess(result => {\r\n        if (result.code === 0) {\r\n          global.localStorage.removeItem(this.getBuildFailureOutputStorageKey())\r\n        } else {\r\n          this.compatible = false\r\n          global.localStorage.setItem(this.getBuildFailureOutputStorageKey(), result.stderr)\r\n        }\r\n        global.localStorage.setItem(this.getIncompatibleNativeModulesStorageKey(), '[]')\r\n        resolve(result)\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.getBuildFailureOutputStorageKey","start_line":1032,"end_line":1034,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"getBuildFailureOutputStorageKey","line":1004,"func_location":"Package.rebuild.(unnamed_function_38).(unnamed_function_39)","func_start_line":999,"func_end_line":1008,"args":[null,"result.stderr"],"code":"      this.runRebuildProcess(result => {\r\n        if (result.code === 0) {\r\n          global.localStorage.removeItem(this.getBuildFailureOutputStorageKey())\r\n        } else {\r\n          this.compatible = false\r\n          global.localStorage.setItem(this.getBuildFailureOutputStorageKey(), result.stderr)\r\n        }\r\n        global.localStorage.setItem(this.getIncompatibleNativeModulesStorageKey(), '[]')\r\n        resolve(result)\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.getBuildFailureOutputStorageKey","start_line":1032,"end_line":1034,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"getIncompatibleNativeModulesStorageKey","line":1006,"func_location":"Package.rebuild.(unnamed_function_38).(unnamed_function_39)","func_start_line":999,"func_end_line":1008,"args":[null,{"type":"string"}],"code":"      this.runRebuildProcess(result => {\r\n        if (result.code === 0) {\r\n          global.localStorage.removeItem(this.getBuildFailureOutputStorageKey())\r\n        } else {\r\n          this.compatible = false\r\n          global.localStorage.setItem(this.getBuildFailureOutputStorageKey(), result.stderr)\r\n        }\r\n        global.localStorage.setItem(this.getIncompatibleNativeModulesStorageKey(), '[]')\r\n        resolve(result)\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.getIncompatibleNativeModulesStorageKey","start_line":1036,"end_line":1039,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"focusedWindow","line":403,"func_location":"AtomApplication.handleEvents.(unnamed_function_39)","func_start_line":402,"func_end_line":405,"args":[],"code":"      this.on('application:minimize', () => {\r\n        const window = this.focusedWindow()\r\n        if (window) window.minimize()\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.focusedWindow","start_line":748,"end_line":750,"comment":[" Public: Returns the currently focused {AtomWindow} or undefined if none."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"autoAssignLanguageMode","line":93,"func_location":"GrammarRegistry.maintainLanguageMode.pathChangeSubscription.(unnamed_function_4)","func_start_line":90,"func_end_line":95,"args":["buffer"],"code":"    const pathChangeSubscription = buffer.onDidChangePath(() => {\r\n      this.grammarScoresByBuffer.delete(buffer)\r\n      if (!this.languageOverridesByBufferId.has(buffer.id)) {\r\n        this.autoAssignLanguageMode(buffer)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.autoAssignLanguageMode","start_line":158,"end_line":168,"comment":[" Extended: Remove any language mode override that has been set for the"," given {TextBuffer}. This will assign to the buffer the best language"," mode available.",""," * `buffer` The {TextBuffer}."],"params":["buffer"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"setState","line":56,"func_location":"AutoUpdateManager.initialize.(unnamed_function_4)","func_start_line":55,"func_end_line":63,"args":["DownloadingState"],"code":"    autoUpdater.on('update-available', () => {\r\n      this.setState(DownloadingState)\r\n      // We use sendMessage to send an event called 'update-available' in 'update-downloaded'\r\n      // once the update download is complete. This mismatch between the electron\r\n      // autoUpdater events is unfortunate but in the interest of not changing the\r\n      // one existing event handled by applicationDelegate\r\n      this.emitWindowEvent('did-begin-downloading-update')\r\n      this.emit('did-begin-download')\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"AutoUpdateManager.setState","start_line":103,"end_line":108,"comment":[],"params":["state","errorMessage"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"emitWindowEvent","line":61,"func_location":"AutoUpdateManager.initialize.(unnamed_function_4)","func_start_line":55,"func_end_line":63,"args":[{"type":"string"}],"code":"    autoUpdater.on('update-available', () => {\r\n      this.setState(DownloadingState)\r\n      // We use sendMessage to send an event called 'update-available' in 'update-downloaded'\r\n      // once the update download is complete. This mismatch between the electron\r\n      // autoUpdater events is unfortunate but in the interest of not changing the\r\n      // one existing event handled by applicationDelegate\r\n      this.emitWindowEvent('did-begin-downloading-update')\r\n      this.emit('did-begin-download')\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"AutoUpdateManager.emitWindowEvent","start_line":97,"end_line":101,"comment":[],"params":["eventName","payload"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"checkCleanupDockHoverEvents","line":100,"func_location":"WorkspaceElement.initialize.(unnamed_function_3).(unnamed_function_4)","func_start_line":97,"func_end_line":101,"args":[],"code":"        .map(dock => dock.onDidChangeHovered(hovered => {\r\n          if (hovered) this.hoveredDock = dock\r\n          else if (dock === this.hoveredDock) this.hoveredDock = null\r\n          this.checkCleanupDockHoverEvents()\r\n        }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.checkCleanupDockHoverEvents","start_line":204,"end_line":208,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"measureContentDuringUpdateSync","line":270,"func_location":"TextEditorComponent.updateSync.(unnamed_function_4)","func_start_line":269,"func_end_line":278,"args":[],"code":"      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.measureContentDuringUpdateSync","start_line":389,"end_line":424,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"expandOverLine","line":226,"func_location":"Selection.selectToScreenPosition.(unnamed_function_4)","func_start_line":214,"func_end_line":230,"args":["options"],"code":"    this.modifySelection(() => {\r\n      if (this.initialScreenRange) {\r\n        if (position.isLessThan(this.initialScreenRange.start)) {\r\n          this.marker.setScreenRange([position, this.initialScreenRange.end], {reversed: true})\r\n        } else {\r\n          this.marker.setScreenRange([this.initialScreenRange.start, position], {reversed: false})\r\n        }\r\n      } else {\r\n        this.cursor.setScreenPosition(position, options)\r\n      }\r\n\r\n      if (this.linewise) {\r\n        this.expandOverLine(options)\r\n      } else if (this.wordwise) {\r\n        this.expandOverWord(options)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.expandOverLine","start_line":403,"end_line":408,"comment":[" Public: Expands the newest selection to include the entire line on which"," the cursor currently rests.",""," It also includes the newline character."],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"expandOverWord","line":228,"func_location":"Selection.selectToScreenPosition.(unnamed_function_4)","func_start_line":214,"func_end_line":230,"args":["options"],"code":"    this.modifySelection(() => {\r\n      if (this.initialScreenRange) {\r\n        if (position.isLessThan(this.initialScreenRange.start)) {\r\n          this.marker.setScreenRange([position, this.initialScreenRange.end], {reversed: true})\r\n        } else {\r\n          this.marker.setScreenRange([this.initialScreenRange.start, position], {reversed: false})\r\n        }\r\n      } else {\r\n        this.cursor.setScreenPosition(position, options)\r\n      }\r\n\r\n      if (this.linewise) {\r\n        this.expandOverLine(options)\r\n      } else if (this.wordwise) {\r\n        this.expandOverWord(options)\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.expandOverWord","start_line":376,"end_line":380,"comment":[" Public: Expands the newest selection to include the entire word on which"," the cursors rests."],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"disableZoom","line":107,"func_location":"AtomWindow.constructor.(unnamed_function_4)","func_start_line":106,"func_end_line":110,"args":[],"code":"    this.browserWindow.on('window:loaded', () => {\r\n      this.disableZoom()\r\n      this.emit('window:loaded')\r\n      this.resolveLoadedPromise()\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"AtomWindow.disableZoom","start_line":444,"end_line":446,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js","name":"cancel","line":25,"func_location":"didCancelSelection.(unnamed_function_4)","func_start_line":24,"func_end_line":26,"args":[],"code":"      didCancelSelection: () => {\r\n        this.cancel()\r\n      }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js","name":"ReopenProjectListView.cancel","start_line":40,"end_line":50,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"subscribeToBuffer","line":106,"func_location":"GitRepository.constructor.(unnamed_function_4)","func_start_line":106,"func_end_line":106,"args":[null],"code":"      this.subscriptions.add(this.project.onDidAddBuffer(buffer => this.subscribeToBuffer(buffer)))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.subscribeToBuffer","start_line":495,"end_line":511,"comment":["\r\n  Section: Private\r\n  "," Subscribes to buffer events."],"params":["buffer"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js","name":"getPackageTranspilerSpecForFilePath","line":56,"func_location":"compile.(unnamed_function_4)","func_start_line":55,"func_end_line":62,"args":["filePath"],"code":"      compile: (sourceCode, filePath) => {\r\n        const spec = this.getPackageTranspilerSpecForFilePath(filePath)\r\n        if (spec) {\r\n          return this.transpileWithPackageTranspiler(sourceCode, filePath, spec)\r\n        }\r\n\r\n        return transpiler.compile(sourceCode, filePath)\r\n      },\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js","name":"PackageTranspilationRegistry.getPackageTranspilerSpecForFilePath","start_line":78,"end_line":110,"comment":[],"params":["filePath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js","name":"transpileWithPackageTranspiler","line":58,"func_location":"compile.(unnamed_function_4)","func_start_line":55,"func_end_line":62,"args":["sourceCode","filePath","spec"],"code":"      compile: (sourceCode, filePath) => {\r\n        const spec = this.getPackageTranspilerSpecForFilePath(filePath)\r\n        if (spec) {\r\n          return this.transpileWithPackageTranspiler(sourceCode, filePath, spec)\r\n        }\r\n\r\n        return transpiler.compile(sourceCode, filePath)\r\n      },\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js","name":"PackageTranspilationRegistry.transpileWithPackageTranspiler","start_line":133,"end_line":150,"comment":[],"params":["sourceCode","filePath","spec"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js","name":"getModel","line":62,"func_location":"PaneElement.subscribeToDOMEvents.handleDrop.(unnamed_function_4)","func_start_line":59,"func_end_line":67,"args":[],"code":"    const handleDrop = event => {\r\n      event.preventDefault()\r\n      event.stopPropagation()\r\n      this.getModel().activate()\r\n      const pathsToOpen = [...event.dataTransfer.files].map(file => file.path)\r\n      if (pathsToOpen.length > 0) {\r\n        this.applicationDelegate.open({pathsToOpen})\r\n      }\r\n    }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js","name":"PaneElement.getModel","start_line":107,"end_line":109,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js","name":"setAsDefaultProtocolClient","line":66,"func_location":"ProtocolHandlerInstaller.promptToBecomeProtocolClient.accept.(unnamed_function_4)","func_start_line":64,"func_end_line":67,"args":[],"code":"    const accept = () => {\r\n      notification.dismiss()\r\n      this.setAsDefaultProtocolClient()\r\n    }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js","name":"ProtocolHandlerInstaller.setAsDefaultProtocolClient","start_line":18,"end_line":22,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"measure","line":194,"func_location":"Package.activate.(unnamed_function_4)","func_start_line":192,"func_end_line":206},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.measure","start_line":80,"end_line":85,"comment":[],"params":["key","fn"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-updater-win32.js","name":"quitAndInstall","line":81,"func_location":"AutoUpdater.checkForUpdates.(unnamed_function_2).(unnamed_function_3).(unnamed_function_4)","func_start_line":81,"func_end_line":82},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-updater-win32.js","name":"AutoUpdater.quitAndInstall","start_line":9,"end_line":15,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js","name":"shouldEditorUseSoftTabs","line":159,"func_location":"TextEditorRegistry.maintainConfig.updateTabTypes.(unnamed_function_4)","func_start_line":157,"func_end_line":164},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js","name":"shouldEditorUseSoftTabs","start_line":298,"end_line":314,"comment":[],"params":["editor","tabType","softTabs"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"constructor","line":1114,"func_location":"SettingsFile.load.(unnamed_function_40)","func_start_line":1110,"func_end_line":1116,"args":[{"type":"object"},null],"code":"    CSON.readFile(path, (error, properties = {}) => {\r\n      if (error) {\r\n        callback(error)\r\n      } else {\r\n        callback(null, new SettingsFile(path, properties))\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"SettingsFile.constructor","start_line":1119,"end_line":1122,"comment":[],"params":["path","properties"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"getAllWindows","line":422,"func_location":"AtomApplication.handleEvents.(unnamed_function_41)","func_start_line":421,"func_end_line":426,"args":[],"code":"    this.configFile.onDidChange(settings => {\r\n      for (let window of this.getAllWindows()) {\r\n        window.didChangeUserSettings(settings)\r\n      }\r\n      this.config.resetUserSettings(settings)\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.getAllWindows","start_line":321,"end_line":323,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"focusedWindow","line":429,"func_location":"AtomApplication.handleEvents.(unnamed_function_42)","func_start_line":428,"func_end_line":431,"args":[],"code":"    this.configFile.onDidError(message => {\r\n      const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n      if (window) window.didFailToReadUserSettings(message)\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.focusedWindow","start_line":748,"end_line":750,"comment":[" Public: Returns the currently focused {AtomWindow} or undefined if none."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"getLastFocusedWindow","line":429,"func_location":"AtomApplication.handleEvents.(unnamed_function_42)","func_start_line":428,"func_end_line":431,"args":[],"code":"    this.configFile.onDidError(message => {\r\n      const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n      if (window) window.didFailToReadUserSettings(message)\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.getLastFocusedWindow","start_line":325,"end_line":327,"comment":[],"params":["predicate"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"renderLineNumberGutter","line":3115,"func_location":"GutterContainerComponent.render.(unnamed_function_43)","func_start_line":3113,"func_end_line":3126,"args":["gutter"],"code":"        guttersToRender.map((gutter) => {\r\n          if (gutter.type === 'line-number') {\r\n            return this.renderLineNumberGutter(gutter)\r\n          } else {\r\n            return $(CustomGutterComponent, {\r\n              key: gutter,\r\n              element: gutter.getElement(),\r\n              name: gutter.name,\r\n              visible: gutter.isVisible(),\r\n              height: scrollHeight,\r\n              decorations: decorationsToRender.customGutter.get(gutter.name)\r\n            })\r\n          }\r\n        })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"GutterContainerComponent.renderLineNumberGutter","start_line":3131,"end_line":3186,"comment":[],"params":["gutter"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"getAllWindows","line":440,"func_location":"AtomApplication.handleEvents.(unnamed_function_43)","func_start_line":433,"func_end_line":457,"args":[],"code":"    this.disposable.add(ipcHelpers.on(app, 'before-quit', async event => {\r\n      let resolveBeforeQuitPromise\r\n      this.lastBeforeQuitPromise = new Promise(resolve => { resolveBeforeQuitPromise = resolve })\r\n\r\n      if (!this.quitting) {\r\n        this.quitting = true\r\n        event.preventDefault()\r\n        const windowUnloadPromises = this.getAllWindows().map(async window => {\r\n          const unloaded = await window.prepareToUnload()\r\n          if (unloaded) {\r\n            window.close()\r\n            await window.closedPromise\r\n          }\r\n          return unloaded\r\n        })\r\n        const windowUnloadedResults = await Promise.all(windowUnloadPromises)\r\n        if (windowUnloadedResults.every(Boolean)) {\r\n          app.quit()\r\n        } else {\r\n          this.quitting = false\r\n        }\r\n      }\r\n\r\n      resolveBeforeQuitPromise()\r\n    }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.getAllWindows","start_line":321,"end_line":323,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"arraysEqual","line":3342,"func_location":"LineNumberGutterComponent.shouldUpdate.(unnamed_function_44)","func_start_line":3339,"func_end_line":3344,"args":["oldDecorations","newDecorations"],"code":"        oldTileBlockDecorations.forEach((oldDecorations, screenLineId) => {\r\n          if (!blockDecorationsChanged) {\r\n            const newDecorations = newTileBlockDecorations.get(screenLineId)\r\n            blockDecorationsChanged = (newDecorations == null || !arraysEqual(oldDecorations, newDecorations))\r\n          }\r\n        })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"arraysEqual","start_line":4356,"end_line":4362,"comment":[],"params":["a","b"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"killAllProcesses","line":460,"func_location":"AtomApplication.handleEvents.(unnamed_function_46)","func_start_line":459,"func_end_line":462,"args":[],"code":"    this.disposable.add(ipcHelpers.on(app, 'will-quit', () => {\r\n      this.killAllProcesses()\r\n      this.deleteSocketFile()\r\n    }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.killAllProcesses","start_line":928,"end_line":932,"comment":[" Kill all processes associated with opened windows."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"deleteSocketFile","line":461,"func_location":"AtomApplication.handleEvents.(unnamed_function_46)","func_start_line":459,"func_end_line":462,"args":[],"code":"    this.disposable.add(ipcHelpers.on(app, 'will-quit', () => {\r\n      this.killAllProcesses()\r\n      this.deleteSocketFile()\r\n    }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.deleteSocketFile","start_line":348,"end_line":361,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"openPath","line":466,"func_location":"AtomApplication.handleEvents.(unnamed_function_47)","func_start_line":464,"func_end_line":467,"args":[null],"code":"    this.disposable.add(ipcHelpers.on(app, 'open-file', (event, pathToOpen) => {\r\n      event.preventDefault()\r\n      this.openPath({pathToOpen})\r\n    }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.openPath","start_line":786,"end_line":812,"comment":[" Public: Opens a single path, in an existing window if possible.",""," options -","   :pathToOpen - The file path to open","   :pidToKillWhenClosed - The integer of the pid to kill","   :newWindow - Boolean of whether this should be opened in a new window.","   :devMode - Boolean to control the opened window's dev mode.","   :safeMode - Boolean to control the opened window's safe mode.","   :profileStartup - Boolean to control creating a profile of the startup time.","   :window - {AtomWindow} to open file paths in.","   :addToLastWindow - Boolean of whether this should be opened in last focused window."],"params":[["initialPaths","pathToOpen","pidToKillWhenClosed","newWindow","devMode","safeMode","profileStartup","window","clearWindowState","addToLastWindow","env"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"openUrl","line":471,"func_location":"AtomApplication.handleEvents.(unnamed_function_48)","func_start_line":469,"func_end_line":472,"args":[null],"code":"    this.disposable.add(ipcHelpers.on(app, 'open-url', (event, urlToOpen) => {\r\n      event.preventDefault()\r\n      this.openUrl({urlToOpen, devMode: this.devMode, safeMode: this.safeMode})\r\n    }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.openUrl","start_line":1008,"end_line":1025,"comment":[" Open an atom:// url.",""," The host of the URL being opened is assumed to be the package name"," responsible for opening the URL.  A new window will be created with"," that package's `urlMain` as the bootstrap script.",""," options -","   :urlToOpen - The atom:// url to open.","   :devMode - Boolean to control the opened window's dev mode.","   :safeMode - Boolean to control the opened window's safe mode."],"params":[["urlToOpen","devMode","safeMode","env"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"arraysEqual","line":3901,"func_location":"LinesTileComponent.shouldUpdate.(unnamed_function_49)","func_start_line":3898,"func_end_line":3903,"args":["oldDecorations","newDecorations"],"code":"      oldProps.blockDecorations.forEach((oldDecorations, screenLineId) => {\r\n        if (!blockDecorationsChanged) {\r\n          const newDecorations = newProps.blockDecorations.get(screenLineId)\r\n          blockDecorationsChanged = (newDecorations == null || !arraysEqual(oldDecorations, newDecorations))\r\n        }\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"arraysEqual","start_line":4356,"end_line":4362,"comment":[],"params":["a","b"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"setState","line":67,"func_location":"AutoUpdateManager.initialize.(unnamed_function_5)","func_start_line":65,"func_end_line":69,"args":["UpdateAvailableState"],"code":"    autoUpdater.on('update-downloaded', (event, releaseNotes, releaseVersion) => {\r\n      this.releaseVersion = releaseVersion\r\n      this.setState(UpdateAvailableState)\r\n      this.emitUpdateAvailableEvent()\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"AutoUpdateManager.setState","start_line":103,"end_line":108,"comment":[],"params":["state","errorMessage"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"emitUpdateAvailableEvent","line":68,"func_location":"AutoUpdateManager.initialize.(unnamed_function_5)","func_start_line":65,"func_end_line":69,"args":[],"code":"    autoUpdater.on('update-downloaded', (event, releaseNotes, releaseVersion) => {\r\n      this.releaseVersion = releaseVersion\r\n      this.setState(UpdateAvailableState)\r\n      this.emitUpdateAvailableEvent()\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"AutoUpdateManager.emitUpdateAvailableEvent","start_line":92,"end_line":95,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"getTitle","line":585,"func_location":"TextEditor.subscribeToBuffer.(unnamed_function_5)","func_start_line":584,"func_end_line":587,"args":[{"type":"string"},null],"code":"    this.disposables.add(this.buffer.onDidChangePath(() => {\r\n      this.emitter.emit('did-change-title', this.getTitle())\r\n      this.emitter.emit('did-change-path', this.getPath())\r\n    }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.getTitle","start_line":1090,"end_line":1092,"comment":["\r\n  Section: File Details\r\n  "," Essential: Get the editor's title for display in other parts of the"," UI such as the tabs.",""," If the editor's buffer is saved, its title is the file name. If it is"," unsaved, its title is \"untitled\".",""," Returns a {String}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"getPath","line":586,"func_location":"TextEditor.subscribeToBuffer.(unnamed_function_5)","func_start_line":584,"func_end_line":587,"args":[{"type":"string"},null],"code":"    this.disposables.add(this.buffer.onDidChangePath(() => {\r\n      this.emitter.emit('did-change-title', this.getTitle())\r\n      this.emitter.emit('did-change-path', this.getPath())\r\n    }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.getPath","start_line":1136,"end_line":1138,"comment":[" Essential: Returns the {String} path of this editor's text buffer."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateSync","line":273,"func_location":"TextEditorComponent.updateSync.(unnamed_function_4).(unnamed_function_5)","func_start_line":271,"func_end_line":277,"args":[{"type":"boolean"}],"code":"        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateSync","start_line":221,"end_line":289,"comment":[],"params":["useScheduler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateSyncAfterMeasuringContent","line":275,"func_location":"TextEditorComponent.updateSync.(unnamed_function_4).(unnamed_function_5)","func_start_line":271,"func_end_line":277,"args":[],"code":"        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateSyncAfterMeasuringContent","start_line":426,"end_line":449,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"endTransaction","line":849,"func_location":"Config.transactAsync.(unnamed_function_4).(unnamed_function_5)","func_start_line":848,"func_end_line":851,"args":[],"code":"      endTransaction = fn => (...args) => {\r\n        this.endTransaction()\r\n        return fn(...args)\r\n      }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.endTransaction","start_line":866,"end_line":869,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js","name":"taskDescription","line":89,"func_location":"items.(unnamed_function_5)","func_start_line":85,"func_end_line":95,"args":["project.paths"],"code":"        items: this.projects.map(project =>\r\n          ({\r\n            type: 'task',\r\n            title: project.paths.map(ReopenProjectMenuManager.betterBaseName).join(', '),\r\n            description: ReopenProjectMenuManager.taskDescription(project.paths),\r\n            program: process.execPath,\r\n            args: project.paths.map(path => `\"${path}\"`).join(' '),\r\n            iconPath: path.join(path.dirname(process.execPath), 'resources', 'cli', 'folder.ico'),\r\n            iconIndex: 0\r\n          })\r\n        )\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js","name":"ReopenProjectMenuManager.taskDescription","start_line":53,"end_line":55,"comment":[],"params":["paths"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js","name":"makeName","line":66,"func_location":"ReopenProjectListView.toggle.projects.(unnamed_function_5)","func_start_line":66,"func_end_line":66,"args":[null],"code":"      const projects = atom.history.getProjects().map(p => ({ name: this.makeName(p.paths), value: p.paths }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js","name":"ReopenProjectListView.makeName","start_line":72,"end_line":74,"comment":[],"params":["paths"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getPathStatus","line":498,"func_location":"GitRepository.subscribeToBuffer.getBufferPathStatus.(unnamed_function_5)","func_start_line":496,"func_end_line":499,"args":["bufferPath"],"code":"    const getBufferPathStatus = () => {\r\n      const bufferPath = buffer.getPath()\r\n      if (bufferPath) this.getPathStatus(bufferPath)\r\n    }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getPathStatus","start_line":374,"end_line":390,"comment":[" Public: Get the status of a single path in the repository.",""," * `path` A {String} repository-relative path.",""," Returns a {Number} representing the status. This value can be passed to"," {::isStatusModified} or {::isStatusNew} to get more information."],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js","name":"getPackageTranspilerSpecForFilePath","line":68,"func_location":"shouldCompile.(unnamed_function_5)","func_start_line":64,"func_end_line":74,"args":["filePath"],"code":"      shouldCompile: (sourceCode, filePath) => {\r\n        if (this.transpilerPaths[filePath]) {\r\n          return false\r\n        }\r\n        const spec = this.getPackageTranspilerSpecForFilePath(filePath)\r\n        if (spec) {\r\n          return true\r\n        }\r\n\r\n        return transpiler.shouldCompile(sourceCode, filePath)\r\n      }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js","name":"PackageTranspilationRegistry.getPackageTranspilerSpecForFilePath","start_line":78,"end_line":110,"comment":[],"params":["filePath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"constructor","line":96,"func_location":"HistoryManager.loadState.(unnamed_function_5)","func_start_line":96,"func_end_line":96,"args":[null],"code":"      this.projects = history.projects.filter(p => Array.isArray(p.paths) && p.paths.length > 0).map(p => new HistoryProject(p.paths, new Date(p.lastOpened)))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"HistoryProject.constructor","start_line":118,"end_line":121,"comment":[],"params":["paths","lastOpened"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"subscribeToBuffer","line":139,"func_location":"Project.deserialize.(unnamed_function_5)","func_start_line":135,"func_end_line":142,"args":["buffer"],"code":"    return Promise.all(bufferPromises).then(buffers => {\r\n      this.buffers = buffers.filter(Boolean)\r\n      for (let buffer of this.buffers) {\r\n        this.grammarRegistry.maintainLanguageMode(buffer)\r\n        this.subscribeToBuffer(buffer)\r\n      }\r\n      this.setPaths(state.paths || [], {mustExist: true, exact: true})\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.subscribeToBuffer","start_line":762,"end_line":781,"comment":[],"params":["buffer"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"setPaths","line":141,"func_location":"Project.deserialize.(unnamed_function_5)","func_start_line":135,"func_end_line":142,"args":[null,null],"code":"    return Promise.all(bufferPromises).then(buffers => {\r\n      this.buffers = buffers.filter(Boolean)\r\n      for (let buffer of this.buffers) {\r\n        this.grammarRegistry.maintainLanguageMode(buffer)\r\n        this.subscribeToBuffer(buffer)\r\n      }\r\n      this.setPaths(state.paths || [], {mustExist: true, exact: true})\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.setPaths","start_line":339,"end_line":371,"comment":[" Public: Set the paths of the project's directories.",""," * `projectPaths` {Array} of {String} paths."," * `options` An optional {Object} that may contain the following keys:","   * `mustExist` If `true`, throw an Error if any `projectPaths` do not exist. Any remaining `projectPaths` that","     do exist will still be added to the project. Default: `false`.","   * `exact` If `true`, only add a `projectPath` if it names an existing directory. If `false` and any `projectPath`","     is a file or does not exist, its parent directory will be added instead. Default: `false`."],"params":["projectPaths","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"getFoldableRangeForNode","line":288,"func_location":"TreeSitterLanguageMode.getFoldableRangeContainingPoint.(unnamed_function_5)","func_start_line":283,"func_end_line":296,"args":["node","grammar"],"code":"    this._forEachTreeWithRange(new Range(point, point), (tree, grammar) => {\r\n      let node = tree.rootNode.descendantForPosition(this.buffer.clipPosition(point))\r\n      while (node) {\r\n        if (existenceOnly && node.startPosition.row < point.row) return\r\n        if (node.endPosition.row > point.row) {\r\n          const range = this.getFoldableRangeForNode(node, grammar)\r\n          if (range && rangeIsSmaller(range, smallestRange)) {\r\n            smallestRange = range\r\n            return\r\n          }\r\n        }\r\n        node = node.parent\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"TreeSitterLanguageMode.getFoldableRangeForNode","start_line":318,"end_line":377,"comment":[],"params":["node","grammar","existenceOnly"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"rangeIsSmaller","line":289,"func_location":"TreeSitterLanguageMode.getFoldableRangeContainingPoint.(unnamed_function_5)","func_start_line":283,"func_end_line":296,"args":["range","smallestRange"],"code":"    this._forEachTreeWithRange(new Range(point, point), (tree, grammar) => {\r\n      let node = tree.rootNode.descendantForPosition(this.buffer.clipPosition(point))\r\n      while (node) {\r\n        if (existenceOnly && node.startPosition.row < point.row) return\r\n        if (node.endPosition.row > point.row) {\r\n          const range = this.getFoldableRangeForNode(node, grammar)\r\n          if (range && rangeIsSmaller(range, smallestRange)) {\r\n            smallestRange = range\r\n            return\r\n          }\r\n        }\r\n        node = node.parent\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"rangeIsSmaller","start_line":1179,"end_line":1184,"comment":[" Return true iff `mouse` is smaller than `house`. Only correct if"," mouse and house overlap.",""," * `mouse` {Range}"," * `house` {Range}"],"params":["mouse","house"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"saveState","line":283,"func_location":"AtomEnvironment.attachSaveStateListeners.saveState.(unnamed_function_4).(unnamed_function_5)","func_start_line":282,"func_end_line":284,"args":[null],"code":"      this.window.requestIdleCallback(() => {\r\n        if (!this.unloading) this.saveState({isUnloading: false})\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.saveState","start_line":1198,"end_line":1208,"comment":[],"params":["options","storageKey"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"activateResources","line":196,"func_location":"Package.activate.(unnamed_function_4).(unnamed_function_5)","func_start_line":194,"func_end_line":205,"args":[],"code":"        this.measure('activateTime', () => {\r\n          try {\r\n            this.activateResources()\r\n            if (this.activationShouldBeDeferred()) {\r\n              return this.subscribeToDeferredActivation()\r\n            } else {\r\n              return this.activateNow()\r\n            }\r\n          } catch (error) {\r\n            return this.handleError(`Failed to activate the ${this.name} package`, error)\r\n          }\r\n        })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.activateResources","start_line":297,"end_line":324,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"activationShouldBeDeferred","line":197,"func_location":"Package.activate.(unnamed_function_4).(unnamed_function_5)","func_start_line":194,"func_end_line":205,"args":[],"code":"        this.measure('activateTime', () => {\r\n          try {\r\n            this.activateResources()\r\n            if (this.activationShouldBeDeferred()) {\r\n              return this.subscribeToDeferredActivation()\r\n            } else {\r\n              return this.activateNow()\r\n            }\r\n          } catch (error) {\r\n            return this.handleError(`Failed to activate the ${this.name} package`, error)\r\n          }\r\n        })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.activationShouldBeDeferred","start_line":805,"end_line":807,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"subscribeToDeferredActivation","line":198,"func_location":"Package.activate.(unnamed_function_4).(unnamed_function_5)","func_start_line":194,"func_end_line":205,"args":[],"code":"        this.measure('activateTime', () => {\r\n          try {\r\n            this.activateResources()\r\n            if (this.activationShouldBeDeferred()) {\r\n              return this.subscribeToDeferredActivation()\r\n            } else {\r\n              return this.activateNow()\r\n            }\r\n          } catch (error) {\r\n            return this.handleError(`Failed to activate the ${this.name} package`, error)\r\n          }\r\n        })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.subscribeToDeferredActivation","start_line":828,"end_line":831,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"activateNow","line":200,"func_location":"Package.activate.(unnamed_function_4).(unnamed_function_5)","func_start_line":194,"func_end_line":205,"args":[],"code":"        this.measure('activateTime', () => {\r\n          try {\r\n            this.activateResources()\r\n            if (this.activationShouldBeDeferred()) {\r\n              return this.subscribeToDeferredActivation()\r\n            } else {\r\n              return this.activateNow()\r\n            }\r\n          } catch (error) {\r\n            return this.handleError(`Failed to activate the ${this.name} package`, error)\r\n          }\r\n        })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.activateNow","start_line":212,"end_line":236,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"handleError","line":203,"func_location":"Package.activate.(unnamed_function_4).(unnamed_function_5)","func_start_line":194,"func_end_line":205,"args":[null,"error"],"code":"        this.measure('activateTime', () => {\r\n          try {\r\n            this.activateResources()\r\n            if (this.activationShouldBeDeferred()) {\r\n              return this.subscribeToDeferredActivation()\r\n            } else {\r\n              return this.activateNow()\r\n            }\r\n          } catch (error) {\r\n            return this.handleError(`Failed to activate the ${this.name} package`, error)\r\n          }\r\n        })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.handleError","start_line":1085,"end_line":1105,"comment":[],"params":["message","error"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"restart","line":481,"func_location":"AtomApplication.handleEvents.(unnamed_function_50)","func_start_line":480,"func_end_line":482,"args":[],"code":"    this.disposable.add(ipcHelpers.on(ipcMain, 'restart-application', () => {\r\n      this.restart()\r\n    }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.restart","start_line":1358,"end_line":1370,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"getAllWindows","line":491,"func_location":"AtomApplication.handleEvents.(unnamed_function_53)","func_start_line":490,"func_end_line":495,"args":[],"code":"    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-history-manager', event => {\r\n      for (let atomWindow of this.getAllWindows()) {\r\n        const {webContents} = atomWindow.browserWindow\r\n        if (webContents !== event.sender) webContents.send('did-change-history-manager')\r\n      }\r\n    }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.getAllWindows","start_line":321,"end_line":323,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"performFlash","line":4183,"func_location":"HighlightComponent.performFlash.(unnamed_function_54)","func_start_line":4183,"func_end_line":4183,"args":[null],"code":"      requestAnimationFrame(() => this.performFlash())\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"HighlightComponent.performFlash","start_line":4172,"end_line":4190,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"atomWindowForEvent","line":499,"func_location":"AtomApplication.handleEvents.(unnamed_function_54)","func_start_line":498,"func_end_line":514,"args":["event"],"comment":[" A request from the associated render process to open a new render process."],"code":"    this.disposable.add(ipcHelpers.on(ipcMain, 'open', (event, options) => {\r\n      const window = this.atomWindowForEvent(event)\r\n      if (options) {\r\n        if (typeof options.pathsToOpen === 'string') {\r\n          options.pathsToOpen = [options.pathsToOpen]\r\n        }\r\n\r\n        if (options.pathsToOpen && options.pathsToOpen.length > 0) {\r\n          options.window = window\r\n          this.openPaths(options)\r\n        } else {\r\n          this.addWindow(new AtomWindow(this, this.fileRecoveryService, options))\r\n        }\r\n      } else {\r\n        this.promptForPathToOpen('all', {window})\r\n      }\r\n    }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.atomWindowForEvent","start_line":739,"end_line":741,"comment":[" Returns the {AtomWindow} for the given ipcMain event."],"params":[["sender"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"openPaths","line":507,"func_location":"AtomApplication.handleEvents.(unnamed_function_54)","func_start_line":498,"func_end_line":514,"args":["options"],"comment":[" A request from the associated render process to open a new render process."],"code":"    this.disposable.add(ipcHelpers.on(ipcMain, 'open', (event, options) => {\r\n      const window = this.atomWindowForEvent(event)\r\n      if (options) {\r\n        if (typeof options.pathsToOpen === 'string') {\r\n          options.pathsToOpen = [options.pathsToOpen]\r\n        }\r\n\r\n        if (options.pathsToOpen && options.pathsToOpen.length > 0) {\r\n          options.window = window\r\n          this.openPaths(options)\r\n        } else {\r\n          this.addWindow(new AtomWindow(this, this.fileRecoveryService, options))\r\n        }\r\n      } else {\r\n        this.promptForPathToOpen('all', {window})\r\n      }\r\n    }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.openPaths","start_line":825,"end_line":925,"comment":[" Public: Opens multiple paths, in existing windows if possible.",""," options -","   :pathsToOpen - The array of file paths to open","   :pidToKillWhenClosed - The integer of the pid to kill","   :newWindow - Boolean of whether this should be opened in a new window.","   :devMode - Boolean to control the opened window's dev mode.","   :safeMode - Boolean to control the opened window's safe mode.","   :windowDimensions - Object with height and width keys.","   :window - {AtomWindow} to open file paths in.","   :addToLastWindow - Boolean of whether this should be opened in last focused window."],"params":[["initialPaths","pathsToOpen","executedFrom","pidToKillWhenClosed","newWindow","devMode","safeMode","windowDimensions","profileStartup","window","clearWindowState","addToLastWindow","env"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"addWindow","line":509,"func_location":"AtomApplication.handleEvents.(unnamed_function_54)","func_start_line":498,"func_end_line":514,"args":[null],"comment":[" A request from the associated render process to open a new render process."],"code":"    this.disposable.add(ipcHelpers.on(ipcMain, 'open', (event, options) => {\r\n      const window = this.atomWindowForEvent(event)\r\n      if (options) {\r\n        if (typeof options.pathsToOpen === 'string') {\r\n          options.pathsToOpen = [options.pathsToOpen]\r\n        }\r\n\r\n        if (options.pathsToOpen && options.pathsToOpen.length > 0) {\r\n          options.window = window\r\n          this.openPaths(options)\r\n        } else {\r\n          this.addWindow(new AtomWindow(this, this.fileRecoveryService, options))\r\n        }\r\n      } else {\r\n        this.promptForPathToOpen('all', {window})\r\n      }\r\n    }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.addWindow","start_line":299,"end_line":319,"comment":[" Public: Adds the {AtomWindow} to the global window list."],"params":["window"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"promptForPathToOpen","line":512,"func_location":"AtomApplication.handleEvents.(unnamed_function_54)","func_start_line":498,"func_end_line":514,"args":[{"type":"string"},null],"comment":[" A request from the associated render process to open a new render process."],"code":"    this.disposable.add(ipcHelpers.on(ipcMain, 'open', (event, options) => {\r\n      const window = this.atomWindowForEvent(event)\r\n      if (options) {\r\n        if (typeof options.pathsToOpen === 'string') {\r\n          options.pathsToOpen = [options.pathsToOpen]\r\n        }\r\n\r\n        if (options.pathsToOpen && options.pathsToOpen.length > 0) {\r\n          options.window = window\r\n          this.openPaths(options)\r\n        } else {\r\n          this.addWindow(new AtomWindow(this, this.fileRecoveryService, options))\r\n        }\r\n      } else {\r\n        this.promptForPathToOpen('all', {window})\r\n      }\r\n    }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.promptForPathToOpen","start_line":1309,"end_line":1317,"comment":[" Opens a native dialog to prompt the user for a path.",""," Once paths are selected, they're opened in a new or existing {AtomWindow}s.",""," options -","   :type - A String which specifies the type of the dialog, could be 'file',","           'folder' or 'all'. The 'all' is only available on macOS.","   :devMode - A Boolean which controls whether any newly opened windows","              should be in dev mode or not.","   :safeMode - A Boolean which controls whether any newly opened windows","               should be in safe mode or not.","   :window - An {AtomWindow} to use for opening a selected file path.","   :path - An optional String which controls the default path to which the","           file dialog opens."],"params":["type",["devMode","safeMode","window"],"path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"runTests","line":522,"func_location":"AtomApplication.handleEvents.(unnamed_function_56)","func_start_line":521,"func_end_line":527},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.runTests","start_line":1117,"end_line":1179,"comment":[" Opens up a new {AtomWindow} to run specs within.",""," options -","   :headless - A Boolean that, if true, will close the window upon","                   completion.","   :resourcePath - The path to include specs from.","   :specPath - The directory to load specs from.","   :safeMode - A Boolean that, if true, won't run specs from ~/.atom/packages","               and ~/.atom/dev/packages, defaults to false."],"params":[["headless","resourcePath","executedFrom","pathsToOpen","logFile","safeMode","timeout","env"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"runBenchmarks","line":530,"func_location":"AtomApplication.handleEvents.(unnamed_function_57)","func_start_line":529,"func_end_line":536},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.runBenchmarks","start_line":1181,"end_line":1225,"comment":[],"params":[["headless","test","resourcePath","executedFrom","pathsToOpen","env"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"promptForPathToOpen","line":545,"func_location":"AtomApplication.handleEvents.(unnamed_function_59)","func_start_line":542,"func_end_line":553,"args":[{"type":"string"},null,"defaultPath"],"code":"    this.disposable.add(ipcHelpers.on(ipcMain, 'open-command', (event, command, defaultPath) => {\r\n      switch (command) {\r\n        case 'application:open':\r\n          return this.promptForPathToOpen('all', getLoadSettings(), defaultPath)\r\n        case 'application:open-file':\r\n          return this.promptForPathToOpen('file', getLoadSettings(), defaultPath)\r\n        case 'application:open-folder':\r\n          return this.promptForPathToOpen('folder', getLoadSettings(), defaultPath)\r\n        default:\r\n          return console.log(`Invalid open-command received: ${command}`)\r\n      }\r\n    }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.promptForPathToOpen","start_line":1309,"end_line":1317,"comment":[" Opens a native dialog to prompt the user for a path.",""," Once paths are selected, they're opened in a new or existing {AtomWindow}s.",""," options -","   :type - A String which specifies the type of the dialog, could be 'file',","           'folder' or 'all'. The 'all' is only available on macOS.","   :devMode - A Boolean which controls whether any newly opened windows","              should be in dev mode or not.","   :safeMode - A Boolean which controls whether any newly opened windows","               should be in safe mode or not.","   :window - An {AtomWindow} to use for opening a selected file path.","   :path - An optional String which controls the default path to which the","           file dialog opens."],"params":["type",["devMode","safeMode","window"],"path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"promptForPathToOpen","line":547,"func_location":"AtomApplication.handleEvents.(unnamed_function_59)","func_start_line":542,"func_end_line":553,"args":[{"type":"string"},null,"defaultPath"],"code":"    this.disposable.add(ipcHelpers.on(ipcMain, 'open-command', (event, command, defaultPath) => {\r\n      switch (command) {\r\n        case 'application:open':\r\n          return this.promptForPathToOpen('all', getLoadSettings(), defaultPath)\r\n        case 'application:open-file':\r\n          return this.promptForPathToOpen('file', getLoadSettings(), defaultPath)\r\n        case 'application:open-folder':\r\n          return this.promptForPathToOpen('folder', getLoadSettings(), defaultPath)\r\n        default:\r\n          return console.log(`Invalid open-command received: ${command}`)\r\n      }\r\n    }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.promptForPathToOpen","start_line":1309,"end_line":1317,"comment":[" Opens a native dialog to prompt the user for a path.",""," Once paths are selected, they're opened in a new or existing {AtomWindow}s.",""," options -","   :type - A String which specifies the type of the dialog, could be 'file',","           'folder' or 'all'. The 'all' is only available on macOS.","   :devMode - A Boolean which controls whether any newly opened windows","              should be in dev mode or not.","   :safeMode - A Boolean which controls whether any newly opened windows","               should be in safe mode or not.","   :window - An {AtomWindow} to use for opening a selected file path.","   :path - An optional String which controls the default path to which the","           file dialog opens."],"params":["type",["devMode","safeMode","window"],"path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"promptForPathToOpen","line":549,"func_location":"AtomApplication.handleEvents.(unnamed_function_59)","func_start_line":542,"func_end_line":553,"args":[{"type":"string"},null,"defaultPath"],"code":"    this.disposable.add(ipcHelpers.on(ipcMain, 'open-command', (event, command, defaultPath) => {\r\n      switch (command) {\r\n        case 'application:open':\r\n          return this.promptForPathToOpen('all', getLoadSettings(), defaultPath)\r\n        case 'application:open-file':\r\n          return this.promptForPathToOpen('file', getLoadSettings(), defaultPath)\r\n        case 'application:open-folder':\r\n          return this.promptForPathToOpen('folder', getLoadSettings(), defaultPath)\r\n        default:\r\n          return console.log(`Invalid open-command received: ${command}`)\r\n      }\r\n    }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.promptForPathToOpen","start_line":1309,"end_line":1317,"comment":[" Opens a native dialog to prompt the user for a path.",""," Once paths are selected, they're opened in a new or existing {AtomWindow}s.",""," options -","   :type - A String which specifies the type of the dialog, could be 'file',","           'folder' or 'all'. The 'all' is only available on macOS.","   :devMode - A Boolean which controls whether any newly opened windows","              should be in dev mode or not.","   :safeMode - A Boolean which controls whether any newly opened windows","               should be in safe mode or not.","   :window - An {AtomWindow} to use for opening a selected file path.","   :path - An optional String which controls the default path to which the","           file dialog opens."],"params":["type",["devMode","safeMode","window"],"path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js","name":"onEvents","line":194,"func_location":"AtomNativeWatcher.doStart.(unnamed_function_5).announce.(unnamed_function_6)","func_start_line":191,"func_end_line":195,"args":[null],"code":"      const announce = (action, oldPath) => {\r\n        const payload = {action, path: realPath}\r\n        if (oldPath) payload.oldPath = oldPath\r\n        this.onEvents([payload])\r\n      }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js","name":"NativeWatcher.onEvents","start_line":157,"end_line":159,"comment":[" Private: Callback function invoked by the native watcher when a debounced group of filesystem events arrive."," Normalize and re-broadcast them to any subscribers.",""," * `events` An Array of filesystem events."],"params":["events"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"scheduleUpdateCheck","line":73,"func_location":"AutoUpdateManager.initialize.(unnamed_function_6)","func_start_line":71,"func_end_line":77,"args":[],"code":"    this.config.onDidChange('core.automaticallyUpdate', ({newValue}) => {\r\n      if (newValue) {\r\n        this.scheduleUpdateCheck()\r\n      } else {\r\n        this.cancelScheduledUpdateCheck()\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"AutoUpdateManager.scheduleUpdateCheck","start_line":118,"end_line":127,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"cancelScheduledUpdateCheck","line":75,"func_location":"AutoUpdateManager.initialize.(unnamed_function_6)","func_start_line":71,"func_end_line":77,"args":[],"code":"    this.config.onDidChange('core.automaticallyUpdate', ({newValue}) => {\r\n      if (newValue) {\r\n        this.scheduleUpdateCheck()\r\n      } else {\r\n        this.cancelScheduledUpdateCheck()\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"AutoUpdateManager.cancelScheduledUpdateCheck","start_line":129,"end_line":134,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"getEncoding","line":589,"func_location":"TextEditor.subscribeToBuffer.(unnamed_function_6)","func_start_line":588,"func_end_line":590,"args":[{"type":"string"},null],"code":"    this.disposables.add(this.buffer.onDidChangeEncoding(() => {\r\n      this.emitter.emit('did-change-encoding', this.getEncoding())\r\n    }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.getEncoding","start_line":1152,"end_line":1152,"comment":[" Extended: Returns the {String} character set encoding of this editor's text"," buffer."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"hasMatchingFoldSpec","line":335,"func_location":"TreeSitterLanguageMode.getFoldableRangeForNode.(unnamed_function_6)","func_start_line":335,"func_end_line":335,"args":[null],"code":"          foldStartNode = children.find(child => hasMatchingFoldSpec(startEntry.matchers, child))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"hasMatchingFoldSpec","start_line":1210,"end_line":1212,"comment":[],"params":["specs","node"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"handleURI","line":410,"func_location":"Package.registerURIHandler.(unnamed_function_6)","func_start_line":409,"func_end_line":411,"args":["methodName","args"],"code":"      this.uriHandlerSubscription = this.packageManager.registerURIHandlerForPackage(this.name, (...args) =>\r\n        this.handleURI(methodName, args)\r\n      )\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.handleURI","start_line":419,"end_line":424,"comment":[],"params":["methodName","args"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"getActivePackage","line":452,"func_location":"PackageManager.observeDisabledPackages.(unnamed_function_5).(unnamed_function_6)","func_start_line":452,"func_end_line":452,"args":[null],"code":"      packagesToDisable.forEach(name => { if (this.getActivePackage(name)) this.deactivatePackage(name) })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.getActivePackage","start_line":300,"end_line":302,"comment":[" Public: Get the active {Package} with the given name.",""," * `name` - The {String} package name.",""," Returns a {Package} or undefined."],"params":["name"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"deactivatePackage","line":452,"func_location":"PackageManager.observeDisabledPackages.(unnamed_function_5).(unnamed_function_6)","func_start_line":452,"func_end_line":452,"args":[null],"code":"      packagesToDisable.forEach(name => { if (this.getActivePackage(name)) this.deactivatePackage(name) })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.deactivatePackage","start_line":779,"end_line":797,"comment":[" Deactivate the package with the given name"],"params":["name","suppressSerialization"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"promptForRestart","line":176,"func_location":"AtomApplication.launch.(unnamed_function_6)","func_start_line":176,"func_end_line":176,"args":[{"type":"string"},null],"code":"      this.config.onDidChange('core.titleBar', () => this.promptForRestart())\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.promptForRestart","start_line":1349,"end_line":1356,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js","name":"removeChild","line":181,"func_location":"PaneAxis.subscribeToChild.subscription.(unnamed_function_6)","func_start_line":181,"func_end_line":181,"args":[null],"code":"    const subscription = child.onDidDestroy(() => this.removeChild(child))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js","name":"PaneAxis.removeChild","start_line":137,"end_line":149,"comment":[],"params":["child","replacing"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js","name":"createSymlink","line":82,"func_location":"CommandInstaller.installCommand.(unnamed_function_6)","func_start_line":79,"func_end_line":90},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js","name":"CommandInstaller.createSymlink","start_line":93,"end_line":101,"comment":[],"params":["fs","sourcePath","destinationPath","callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"atomWindowForBrowserWindow","line":561,"func_location":"AtomApplication.handleEvents.(unnamed_function_61)","func_start_line":560,"func_end_line":563,"args":["browserWindow"],"code":"    this.disposable.add(ipcHelpers.respondTo('window-method', (browserWindow, method, ...args) => {\r\n      const window = this.atomWindowForBrowserWindow(browserWindow)\r\n      if (window) window[method](...args)\r\n    }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.atomWindowForBrowserWindow","start_line":743,"end_line":745,"comment":[],"params":["browserWindow"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"promptForPath","line":566,"func_location":"AtomApplication.handleEvents.(unnamed_function_62)","func_start_line":565,"func_end_line":567,"args":[{"type":"string"},null],"code":"    this.disposable.add(ipcHelpers.on(ipcMain, 'pick-folder', (event, responseChannel) => {\r\n      this.promptForPath('folder', paths => event.sender.send(responseChannel, paths))\r\n    }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.promptForPath","start_line":1319,"end_line":1347,"comment":[],"params":["type","callback","path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"getGrammarScore","line":195,"func_location":"GrammarRegistry.selectGrammarWithScore.(unnamed_function_7)","func_start_line":194,"func_end_line":200,"args":["grammar","filePath","fileContents"],"code":"    this.forEachGrammar(grammar => {\r\n      const score = this.getGrammarScore(grammar, filePath, fileContents)\r\n      if (score > highestScore || bestMatch == null) {\r\n        bestMatch = grammar\r\n        highestScore = score\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.getGrammarScore","start_line":206,"end_line":242,"comment":[" Extended: Returns a {Number} representing how well the grammar matches the"," `filePath` and `contents`."],"params":["grammar","filePath","contents"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"check","line":122,"func_location":"AutoUpdateManager.scheduleUpdateCheck.checkForUpdates.(unnamed_function_7)","func_start_line":122,"func_end_line":123},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"AutoUpdateManager.check","start_line":136,"end_line":143,"comment":[],"params":[["hidePopups"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"destroy","line":591,"func_location":"TextEditor.subscribeToBuffer.(unnamed_function_7)","func_start_line":591,"func_end_line":591,"args":[null],"code":"    this.disposables.add(this.buffer.onDidDestroy(() => this.destroy()))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.destroy","start_line":621,"end_line":636,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"setDefaults","line":917,"func_location":"Config.setSchema.(unnamed_function_7)","func_start_line":916,"func_end_line":920,"args":["keyPath",null],"code":"    this.transact(() => {\r\n      this.setDefaults(keyPath, this.extractDefaultsFromSchema(schema))\r\n      this.setScopedDefaultsFromSchema(keyPath, schema)\r\n      this.resetSettingsForSchemaChange()\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.setDefaults","start_line":1070,"end_line":1090,"comment":[],"params":["keyPath","defaults"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"extractDefaultsFromSchema","line":917,"func_location":"Config.setSchema.(unnamed_function_7)","func_start_line":916,"func_end_line":920,"args":["keyPath",null],"code":"    this.transact(() => {\r\n      this.setDefaults(keyPath, this.extractDefaultsFromSchema(schema))\r\n      this.setScopedDefaultsFromSchema(keyPath, schema)\r\n      this.resetSettingsForSchemaChange()\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.extractDefaultsFromSchema","start_line":1153,"end_line":1162,"comment":[],"params":["schema"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"setScopedDefaultsFromSchema","line":918,"func_location":"Config.setSchema.(unnamed_function_7)","func_start_line":916,"func_end_line":920,"args":["keyPath","schema"],"code":"    this.transact(() => {\r\n      this.setDefaults(keyPath, this.extractDefaultsFromSchema(schema))\r\n      this.setScopedDefaultsFromSchema(keyPath, schema)\r\n      this.resetSettingsForSchemaChange()\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.setScopedDefaultsFromSchema","start_line":1131,"end_line":1151,"comment":[" `schema` will look something like this",""," ```coffee"," type: 'string'"," default: 'ok'"," scopes:","   '.source.js':","     default: 'omg'"," ```"],"params":["keyPath","schema"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"resetSettingsForSchemaChange","line":919,"func_location":"Config.setSchema.(unnamed_function_7)","func_start_line":916,"func_end_line":920,"args":[],"code":"    this.transact(() => {\r\n      this.setDefaults(keyPath, this.extractDefaultsFromSchema(schema))\r\n      this.setScopedDefaultsFromSchema(keyPath, schema)\r\n      this.resetSettingsForSchemaChange()\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.resetSettingsForSchemaChange","start_line":1182,"end_line":1194,"comment":[" When the schema is changed / added, there may be values set in the config"," that do not conform to the schema. This will reset make them conform."],"params":["source"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js","name":"createLabel","line":126,"func_location":"submenu.submenu.(unnamed_function_7)","func_start_line":125,"func_end_line":129,"args":["project"],"code":"          submenu: projects.map((project, index) => ({\r\n            label: this.createLabel(project),\r\n            command: 'application:reopen-project',\r\n            commandDetail: {index: index}\r\n          }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js","name":"ReopenProjectMenuManager.createLabel","start_line":135,"end_line":139,"comment":[],"params":["project"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/win-shell.js","name":"register","line":49,"func_location":"ShellOption.update.(unnamed_function_7)","func_start_line":45,"func_end_line":51,"args":["callback"],"code":"      .get(this.parts[0].name, (err, val) => {\r\n        if ((err != null) || (val == null)) {\r\n          callback(err)\r\n        } else {\r\n          this.register(callback)\r\n        }\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/win-shell.js","name":"ShellOption.register","start_line":25,"end_line":31,"comment":[],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"relativize","line":545,"func_location":"GitRepository.refreshStatus.relativeProjectPaths.(unnamed_function_7)","func_start_line":545,"func_end_line":545},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.relativize","start_line":208,"end_line":210,"comment":[" Public: Makes a path relative to the repository's working directory."],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"killProcess","line":203,"func_location":"BufferedProcess.killOnWindows.(unnamed_function_7)","func_start_line":191,"func_end_line":204,"args":[],"code":"    wmicProcess.stdout.on('close', () => {\r\n      for (let pid of output.split(/\\s+/)) {\r\n        if (!/^\\d{1,10}$/.test(pid)) continue\r\n        pid = parseInt(pid, 10)\r\n\r\n        if (!pid || pid === parentPid) continue\r\n\r\n        try {\r\n          process.kill(pid)\r\n        } catch (error) {}\r\n      }\r\n\r\n      this.killProcess()\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"BufferedProcess.killProcess","start_line":207,"end_line":210,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"hasMatchingFoldSpec","line":352,"func_location":"TreeSitterLanguageMode.getFoldableRangeForNode.(unnamed_function_7)","func_start_line":352,"func_end_line":352,"args":[null],"code":"          foldEndNode = children.find(child => hasMatchingFoldSpec(endEntry.matchers, child))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"hasMatchingFoldSpec","start_line":1210,"end_line":1212,"comment":[],"params":["specs","node"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"getUserInitScriptPath","line":319,"func_location":"AtomEnvironment.registerDefaultOpeners.(unnamed_function_7)","func_start_line":310,"func_end_line":321,"args":[null],"code":"    this.workspace.addOpener(uri => {\r\n      switch (uri) {\r\n        case 'atom://.atom/stylesheet':\r\n          return this.workspace.openTextFile(this.styles.getUserStyleSheetPath())\r\n        case 'atom://.atom/keymap':\r\n          return this.workspace.openTextFile(this.keymaps.getUserKeymapPath())\r\n        case 'atom://.atom/config':\r\n          return this.workspace.openTextFile(this.config.getUserConfigPath())\r\n        case 'atom://.atom/init-script':\r\n          return this.workspace.openTextFile(this.getUserInitScriptPath())\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.getUserInitScriptPath","start_line":1293,"end_line":1296,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"activatePackage","line":453,"func_location":"PackageManager.observeDisabledPackages.(unnamed_function_5).(unnamed_function_7)","func_start_line":453,"func_end_line":453,"args":[null],"code":"      packagesToEnable.forEach(name => this.activatePackage(name))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.activatePackage","start_line":696,"end_line":722,"comment":[" Activate a single package by name"],"params":["name"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"promptForRestart","line":177,"func_location":"AtomApplication.launch.(unnamed_function_7)","func_start_line":177,"func_end_line":177,"args":[{"type":"string"},null],"code":"      this.config.onDidChange('core.colorProfile', () => this.promptForRestart())\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.promptForRestart","start_line":1349,"end_line":1356,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js","name":"createSymlink","line":85,"func_location":"CommandInstaller.installCommand.(unnamed_function_6).(unnamed_function_7)","func_start_line":82,"func_end_line":89,"args":["fsAdmin","commandPath","destinationPath",null],"code":"      this.createSymlink(fs, commandPath, destinationPath, error => {\r\n        if (error && error.code === 'EACCES' && askForPrivilege) {\r\n          const fsAdmin = require('fs-admin')\r\n          this.createSymlink(fsAdmin, commandPath, destinationPath, (error) => { callback(error, commandName) })\r\n        } else {\r\n          callback(error)\r\n        }\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js","name":"CommandInstaller.createSymlink","start_line":93,"end_line":101,"comment":[],"params":["fs","sourcePath","destinationPath","callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"grammarForId","line":373,"func_location":"GrammarRegistry.grammarAddedOrUpdated.(unnamed_function_8)","func_start_line":368,"func_end_line":387,"args":["languageOverride"],"code":"    this.grammarScoresByBuffer.forEach((score, buffer) => {\r\n      const languageMode = buffer.getLanguageMode()\r\n      const languageOverride = this.languageOverridesByBufferId.get(buffer.id)\r\n\r\n      if (grammar === buffer.getLanguageMode().grammar ||\r\n          grammar === this.grammarForId(languageOverride)) {\r\n        buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(grammar, buffer))\r\n        return\r\n      } else if (!languageOverride) {\r\n        const score = this.getGrammarScore(grammar, buffer.getPath(), getGrammarSelectionContent(buffer))\r\n        const currentScore = this.grammarScoresByBuffer.get(buffer)\r\n        if (currentScore == null || score > currentScore) {\r\n          buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(grammar, buffer))\r\n          this.grammarScoresByBuffer.set(buffer, score)\r\n          return\r\n        }\r\n      }\r\n\r\n      languageMode.updateForInjection(grammar)\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.grammarForId","start_line":313,"end_line":326,"comment":[],"params":["languageId"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"languageModeForGrammarAndBuffer","line":374,"func_location":"GrammarRegistry.grammarAddedOrUpdated.(unnamed_function_8)","func_start_line":368,"func_end_line":387,"args":[null],"code":"    this.grammarScoresByBuffer.forEach((score, buffer) => {\r\n      const languageMode = buffer.getLanguageMode()\r\n      const languageOverride = this.languageOverridesByBufferId.get(buffer.id)\r\n\r\n      if (grammar === buffer.getLanguageMode().grammar ||\r\n          grammar === this.grammarForId(languageOverride)) {\r\n        buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(grammar, buffer))\r\n        return\r\n      } else if (!languageOverride) {\r\n        const score = this.getGrammarScore(grammar, buffer.getPath(), getGrammarSelectionContent(buffer))\r\n        const currentScore = this.grammarScoresByBuffer.get(buffer)\r\n        if (currentScore == null || score > currentScore) {\r\n          buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(grammar, buffer))\r\n          this.grammarScoresByBuffer.set(buffer, score)\r\n          return\r\n        }\r\n      }\r\n\r\n      languageMode.updateForInjection(grammar)\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.languageModeForGrammarAndBuffer","start_line":170,"end_line":176,"comment":[],"params":["grammar","buffer"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"getGrammarScore","line":377,"func_location":"GrammarRegistry.grammarAddedOrUpdated.(unnamed_function_8)","func_start_line":368,"func_end_line":387,"args":["grammar",null,null],"code":"    this.grammarScoresByBuffer.forEach((score, buffer) => {\r\n      const languageMode = buffer.getLanguageMode()\r\n      const languageOverride = this.languageOverridesByBufferId.get(buffer.id)\r\n\r\n      if (grammar === buffer.getLanguageMode().grammar ||\r\n          grammar === this.grammarForId(languageOverride)) {\r\n        buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(grammar, buffer))\r\n        return\r\n      } else if (!languageOverride) {\r\n        const score = this.getGrammarScore(grammar, buffer.getPath(), getGrammarSelectionContent(buffer))\r\n        const currentScore = this.grammarScoresByBuffer.get(buffer)\r\n        if (currentScore == null || score > currentScore) {\r\n          buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(grammar, buffer))\r\n          this.grammarScoresByBuffer.set(buffer, score)\r\n          return\r\n        }\r\n      }\r\n\r\n      languageMode.updateForInjection(grammar)\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.getGrammarScore","start_line":206,"end_line":242,"comment":[" Extended: Returns a {Number} representing how well the grammar matches the"," `filePath` and `contents`."],"params":["grammar","filePath","contents"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"getGrammarSelectionContent","line":377,"func_location":"GrammarRegistry.grammarAddedOrUpdated.(unnamed_function_8)","func_start_line":368,"func_end_line":387,"args":["grammar",null,null],"code":"    this.grammarScoresByBuffer.forEach((score, buffer) => {\r\n      const languageMode = buffer.getLanguageMode()\r\n      const languageOverride = this.languageOverridesByBufferId.get(buffer.id)\r\n\r\n      if (grammar === buffer.getLanguageMode().grammar ||\r\n          grammar === this.grammarForId(languageOverride)) {\r\n        buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(grammar, buffer))\r\n        return\r\n      } else if (!languageOverride) {\r\n        const score = this.getGrammarScore(grammar, buffer.getPath(), getGrammarSelectionContent(buffer))\r\n        const currentScore = this.grammarScoresByBuffer.get(buffer)\r\n        if (currentScore == null || score > currentScore) {\r\n          buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(grammar, buffer))\r\n          this.grammarScoresByBuffer.set(buffer, score)\r\n          return\r\n        }\r\n      }\r\n\r\n      languageMode.updateForInjection(grammar)\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"getGrammarSelectionContent","start_line":587,"end_line":592,"comment":[],"params":["buffer"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"languageModeForGrammarAndBuffer","line":380,"func_location":"GrammarRegistry.grammarAddedOrUpdated.(unnamed_function_8)","func_start_line":368,"func_end_line":387,"args":[null],"code":"    this.grammarScoresByBuffer.forEach((score, buffer) => {\r\n      const languageMode = buffer.getLanguageMode()\r\n      const languageOverride = this.languageOverridesByBufferId.get(buffer.id)\r\n\r\n      if (grammar === buffer.getLanguageMode().grammar ||\r\n          grammar === this.grammarForId(languageOverride)) {\r\n        buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(grammar, buffer))\r\n        return\r\n      } else if (!languageOverride) {\r\n        const score = this.getGrammarScore(grammar, buffer.getPath(), getGrammarSelectionContent(buffer))\r\n        const currentScore = this.grammarScoresByBuffer.get(buffer)\r\n        if (currentScore == null || score > currentScore) {\r\n          buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(grammar, buffer))\r\n          this.grammarScoresByBuffer.set(buffer, score)\r\n          return\r\n        }\r\n      }\r\n\r\n      languageMode.updateForInjection(grammar)\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.languageModeForGrammarAndBuffer","start_line":170,"end_line":176,"comment":[],"params":["grammar","buffer"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"terminatePendingState","line":593,"func_location":"TextEditor.subscribeToBuffer.(unnamed_function_8)","func_start_line":592,"func_end_line":594,"args":[],"code":"    this.disposables.add(this.buffer.onDidChangeModified(() => {\r\n      if (!this.hasTerminatedPendingState && this.buffer.isModified()) this.terminatePendingState()\r\n    }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.terminatePendingState","start_line":597,"end_line":600,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"boundingBoxForPaneView","line":281,"func_location":"WorkspaceElement.nearestVisiblePaneInDirection.paneViews.(unnamed_function_8)","func_start_line":280,"func_end_line":288,"args":["otherPaneView"],"code":"      .filter(otherPaneView => {\r\n        const otherBox = this.boundingBoxForPaneView(otherPaneView)\r\n        switch (direction) {\r\n          case 'left': return otherBox.right.x <= box.left.x\r\n          case 'right': return otherBox.left.x >= box.right.x\r\n          case 'above': return otherBox.bottom.y <= box.top.y\r\n          case 'below': return otherBox.top.y >= box.bottom.y\r\n        }\r\n      }).sort((paneViewA, paneViewB) => {\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.boundingBoxForPaneView","start_line":302,"end_line":311,"comment":[],"params":["paneView"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"_clearUnscopedSettingsForSource","line":956,"func_location":"Config._resetSettings.(unnamed_function_8)","func_start_line":955,"func_end_line":966,"args":["source"],"code":"    return this.transact(() => {\r\n      this._clearUnscopedSettingsForSource(source)\r\n      this.settingsLoaded = true\r\n      for (let key in newSettings) {\r\n        const value = newSettings[key]\r\n        this.set(key, value, {save: false, source})\r\n      }\r\n      if (this.pendingOperations.length) {\r\n        for (let op of this.pendingOperations) { op() }\r\n        this.pendingOperations = []\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config._clearUnscopedSettingsForSource","start_line":969,"end_line":975,"comment":[],"params":["source"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"set","line":960,"func_location":"Config._resetSettings.(unnamed_function_8)","func_start_line":955,"func_end_line":966,"args":["key","value",null],"code":"    return this.transact(() => {\r\n      this._clearUnscopedSettingsForSource(source)\r\n      this.settingsLoaded = true\r\n      for (let key in newSettings) {\r\n        const value = newSettings[key]\r\n        this.set(key, value, {save: false, source})\r\n      }\r\n      if (this.pendingOperations.length) {\r\n        for (let op of this.pendingOperations) { op() }\r\n        this.pendingOperations = []\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.set","start_line":687,"end_line":722,"comment":[" Essential: Sets the value for a configuration setting.",""," This value is stored in Atom's internal configuration file.",""," ### Examples",""," You might want to change the themes programmatically:",""," ```coffee"," atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])"," ```",""," You can also set scoped settings. For example, you might want change the"," `editor.tabLength` only for ruby files.",""," ```coffee"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4"," atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",""," # Set ruby to 2"," atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true",""," # Notice it's only set to 2 in the case of ruby"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," atom.config.get('editor.tabLength', scope: ['source.js']) # => 4"," ```",""," * `keyPath` The {String} name of the key."," * `value` The value of the setting. Passing `undefined` will revert the","   setting to the default value."," * `options` (optional) {Object}","   * `scopeSelector` (optional) {String}. eg. '.source.ruby'","     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)","     for more information.","   * `source` (optional) {String} The name of a file with which the setting","     is associated. Defaults to the user's config file.",""," Returns a {Boolean}"," * `true` if the value was set."," * `false` if the value was not able to be coerced to the type specified in the setting's schema."],"params":["args"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"handleError","line":248,"func_location":"BufferedProcess.spawn.(unnamed_function_8)","func_start_line":248,"func_end_line":248,"args":[null],"code":"      process.nextTick(() => this.handleError(spawnError))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"BufferedProcess.handleError","start_line":297,"end_line":312,"comment":[],"params":["error"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"setAutoHideMenuBar","line":330,"func_location":"AtomEnvironment.observeAutoHideMenuBar.(unnamed_function_8)","func_start_line":329,"func_end_line":331,"args":["newValue"],"code":"    this.disposables.add(this.config.onDidChange('core.autoHideMenuBar', ({newValue}) => {\r\n      this.setAutoHideMenuBar(newValue)\r\n    }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.setAutoHideMenuBar","start_line":1330,"end_line":1333,"comment":[],"params":["autoHide"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"getLoadedPackage","line":473,"func_location":"PackageManager.observePackagesWithKeymapsDisabled.performOnLoadedActivePackages.(unnamed_function_8)","func_start_line":470,"func_end_line":479,"args":["packageName"],"code":"    const performOnLoadedActivePackages = (packageNames, disabledPackageNames, action) => {\r\n      for (const packageName of packageNames) {\r\n        if (!disabledPackageNames.has(packageName)) {\r\n          var pack = this.getLoadedPackage(packageName)\r\n          if (pack != null) {\r\n            action(pack)\r\n          }\r\n        }\r\n      }\r\n    }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.getLoadedPackage","start_line":339,"end_line":341,"comment":[" Public: Get the loaded {Package} with the given name.",""," * `name` - The {String} package name.",""," Returns a {Package} or undefined."],"params":["name"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"openWithOptions","line":204,"func_location":"AtomApplication.launch.(unnamed_function_8)","func_start_line":204,"func_end_line":204,"args":[null],"code":"    return optionsForWindowsToOpen.map(options => this.openWithOptions(options))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.openWithOptions","start_line":207,"end_line":281,"comment":[],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"removeItem","line":620,"func_location":"Pane.addItem.(unnamed_function_8)","func_start_line":620,"func_end_line":620,"args":[null],"code":"      itemSubscriptions.add(item.onDidDestroy(() => this.removeItem(item, false)))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.removeItem","start_line":684,"end_line":705,"comment":[],"params":["item","moved"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"loadUserStylesheet","line":194,"func_location":"ThemeManager.loadUserStylesheet.reloadStylesheet.(unnamed_function_8)","func_start_line":194,"func_end_line":195},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.loadUserStylesheet","start_line":185,"end_line":218,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"saveCurrentWindowOptions","line":630,"func_location":"AtomApplication.handleEvents.(unnamed_function_82)","func_start_line":629,"func_end_line":631,"args":[{"type":"boolean"}],"code":"    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-paths', () =>\r\n      this.saveCurrentWindowOptions(false)\r\n    ))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.saveCurrentWindowOptions","start_line":968,"end_line":981,"comment":[],"params":["allowEmpty"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"focusedWindow","line":722,"func_location":"AtomApplication.openPathOnEvent.(unnamed_function_84)","func_start_line":721,"func_end_line":728,"args":[],"code":"    this.on(eventName, () => {\r\n      const window = this.focusedWindow()\r\n      if (window) {\r\n        return window.openPath(pathToOpen)\r\n      } else {\r\n        return this.openPath({pathToOpen})\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.focusedWindow","start_line":748,"end_line":750,"comment":[" Public: Returns the currently focused {AtomWindow} or undefined if none."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"openPath","line":726,"func_location":"AtomApplication.openPathOnEvent.(unnamed_function_84)","func_start_line":721,"func_end_line":728,"args":[null],"code":"    this.on(eventName, () => {\r\n      const window = this.focusedWindow()\r\n      if (window) {\r\n        return window.openPath(pathToOpen)\r\n      } else {\r\n        return this.openPath({pathToOpen})\r\n      }\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.openPath","start_line":786,"end_line":812,"comment":[" Public: Opens a single path, in an existing window if possible.",""," options -","   :pathToOpen - The file path to open","   :pidToKillWhenClosed - The integer of the pid to kill","   :newWindow - Boolean of whether this should be opened in a new window.","   :devMode - Boolean to control the opened window's dev mode.","   :safeMode - Boolean to control the opened window's safe mode.","   :profileStartup - Boolean to control creating a profile of the startup time.","   :window - {AtomWindow} to open file paths in.","   :addToLastWindow - Boolean of whether this should be opened in last focused window."],"params":[["initialPaths","pathToOpen","pidToKillWhenClosed","newWindow","devMode","safeMode","profileStartup","window","clearWindowState","addToLastWindow","env"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"boundingBoxForPaneView","line":289,"func_location":"WorkspaceElement.nearestVisiblePaneInDirection.paneViews.(unnamed_function_9)","func_start_line":288,"func_end_line":297,"args":["paneViewA"],"code":"      }).sort((paneViewA, paneViewB) => {\r\n        const boxA = this.boundingBoxForPaneView(paneViewA)\r\n        const boxB = this.boundingBoxForPaneView(paneViewB)\r\n        switch (direction) {\r\n          case 'left': return distance(box.left, boxA.right) - distance(box.left, boxB.right)\r\n          case 'right': return distance(box.right, boxA.left) - distance(box.right, boxB.left)\r\n          case 'above': return distance(box.top, boxA.bottom) - distance(box.top, boxB.bottom)\r\n          case 'below': return distance(box.bottom, boxA.top) - distance(box.bottom, boxB.top)\r\n        }\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.boundingBoxForPaneView","start_line":302,"end_line":311,"comment":[],"params":["paneView"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"boundingBoxForPaneView","line":290,"func_location":"WorkspaceElement.nearestVisiblePaneInDirection.paneViews.(unnamed_function_9)","func_start_line":288,"func_end_line":297,"args":["paneViewB"],"code":"      }).sort((paneViewA, paneViewB) => {\r\n        const boxA = this.boundingBoxForPaneView(paneViewA)\r\n        const boxB = this.boundingBoxForPaneView(paneViewB)\r\n        switch (direction) {\r\n          case 'left': return distance(box.left, boxA.right) - distance(box.left, boxB.right)\r\n          case 'right': return distance(box.right, boxA.left) - distance(box.right, boxB.left)\r\n          case 'above': return distance(box.top, boxA.bottom) - distance(box.top, boxB.bottom)\r\n          case 'below': return distance(box.bottom, boxA.top) - distance(box.bottom, boxB.top)\r\n        }\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.boundingBoxForPaneView","start_line":302,"end_line":311,"comment":[],"params":["paneView"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"distance","line":292,"func_location":"WorkspaceElement.nearestVisiblePaneInDirection.paneViews.(unnamed_function_9)","func_start_line":288,"func_end_line":297,"args":["box.left","boxA.right"],"code":"      }).sort((paneViewA, paneViewB) => {\r\n        const boxA = this.boundingBoxForPaneView(paneViewA)\r\n        const boxB = this.boundingBoxForPaneView(paneViewB)\r\n        switch (direction) {\r\n          case 'left': return distance(box.left, boxA.right) - distance(box.left, boxB.right)\r\n          case 'right': return distance(box.right, boxA.left) - distance(box.right, boxB.left)\r\n          case 'above': return distance(box.top, boxA.bottom) - distance(box.top, boxB.bottom)\r\n          case 'below': return distance(box.bottom, boxA.top) - distance(box.bottom, boxB.top)\r\n        }\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.nearestVisiblePaneInDirection.distance","start_line":269,"end_line":273,"comment":[],"params":["pointA","pointB"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"distance","line":292,"func_location":"WorkspaceElement.nearestVisiblePaneInDirection.paneViews.(unnamed_function_9)","func_start_line":288,"func_end_line":297,"args":["box.left","boxA.right"],"code":"      }).sort((paneViewA, paneViewB) => {\r\n        const boxA = this.boundingBoxForPaneView(paneViewA)\r\n        const boxB = this.boundingBoxForPaneView(paneViewB)\r\n        switch (direction) {\r\n          case 'left': return distance(box.left, boxA.right) - distance(box.left, boxB.right)\r\n          case 'right': return distance(box.right, boxA.left) - distance(box.right, boxB.left)\r\n          case 'above': return distance(box.top, boxA.bottom) - distance(box.top, boxB.bottom)\r\n          case 'below': return distance(box.bottom, boxA.top) - distance(box.bottom, boxB.top)\r\n        }\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.nearestVisiblePaneInDirection.distance","start_line":269,"end_line":273,"comment":[],"params":["pointA","pointB"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"distance","line":293,"func_location":"WorkspaceElement.nearestVisiblePaneInDirection.paneViews.(unnamed_function_9)","func_start_line":288,"func_end_line":297,"args":["box.right","boxA.left"],"code":"      }).sort((paneViewA, paneViewB) => {\r\n        const boxA = this.boundingBoxForPaneView(paneViewA)\r\n        const boxB = this.boundingBoxForPaneView(paneViewB)\r\n        switch (direction) {\r\n          case 'left': return distance(box.left, boxA.right) - distance(box.left, boxB.right)\r\n          case 'right': return distance(box.right, boxA.left) - distance(box.right, boxB.left)\r\n          case 'above': return distance(box.top, boxA.bottom) - distance(box.top, boxB.bottom)\r\n          case 'below': return distance(box.bottom, boxA.top) - distance(box.bottom, boxB.top)\r\n        }\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.nearestVisiblePaneInDirection.distance","start_line":269,"end_line":273,"comment":[],"params":["pointA","pointB"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"distance","line":293,"func_location":"WorkspaceElement.nearestVisiblePaneInDirection.paneViews.(unnamed_function_9)","func_start_line":288,"func_end_line":297,"args":["box.right","boxA.left"],"code":"      }).sort((paneViewA, paneViewB) => {\r\n        const boxA = this.boundingBoxForPaneView(paneViewA)\r\n        const boxB = this.boundingBoxForPaneView(paneViewB)\r\n        switch (direction) {\r\n          case 'left': return distance(box.left, boxA.right) - distance(box.left, boxB.right)\r\n          case 'right': return distance(box.right, boxA.left) - distance(box.right, boxB.left)\r\n          case 'above': return distance(box.top, boxA.bottom) - distance(box.top, boxB.bottom)\r\n          case 'below': return distance(box.bottom, boxA.top) - distance(box.bottom, boxB.top)\r\n        }\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.nearestVisiblePaneInDirection.distance","start_line":269,"end_line":273,"comment":[],"params":["pointA","pointB"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"distance","line":294,"func_location":"WorkspaceElement.nearestVisiblePaneInDirection.paneViews.(unnamed_function_9)","func_start_line":288,"func_end_line":297,"args":["box.top","boxA.bottom"],"code":"      }).sort((paneViewA, paneViewB) => {\r\n        const boxA = this.boundingBoxForPaneView(paneViewA)\r\n        const boxB = this.boundingBoxForPaneView(paneViewB)\r\n        switch (direction) {\r\n          case 'left': return distance(box.left, boxA.right) - distance(box.left, boxB.right)\r\n          case 'right': return distance(box.right, boxA.left) - distance(box.right, boxB.left)\r\n          case 'above': return distance(box.top, boxA.bottom) - distance(box.top, boxB.bottom)\r\n          case 'below': return distance(box.bottom, boxA.top) - distance(box.bottom, boxB.top)\r\n        }\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.nearestVisiblePaneInDirection.distance","start_line":269,"end_line":273,"comment":[],"params":["pointA","pointB"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"distance","line":294,"func_location":"WorkspaceElement.nearestVisiblePaneInDirection.paneViews.(unnamed_function_9)","func_start_line":288,"func_end_line":297,"args":["box.top","boxA.bottom"],"code":"      }).sort((paneViewA, paneViewB) => {\r\n        const boxA = this.boundingBoxForPaneView(paneViewA)\r\n        const boxB = this.boundingBoxForPaneView(paneViewB)\r\n        switch (direction) {\r\n          case 'left': return distance(box.left, boxA.right) - distance(box.left, boxB.right)\r\n          case 'right': return distance(box.right, boxA.left) - distance(box.right, boxB.left)\r\n          case 'above': return distance(box.top, boxA.bottom) - distance(box.top, boxB.bottom)\r\n          case 'below': return distance(box.bottom, boxA.top) - distance(box.bottom, boxB.top)\r\n        }\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.nearestVisiblePaneInDirection.distance","start_line":269,"end_line":273,"comment":[],"params":["pointA","pointB"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"distance","line":295,"func_location":"WorkspaceElement.nearestVisiblePaneInDirection.paneViews.(unnamed_function_9)","func_start_line":288,"func_end_line":297,"args":["box.bottom","boxA.top"],"code":"      }).sort((paneViewA, paneViewB) => {\r\n        const boxA = this.boundingBoxForPaneView(paneViewA)\r\n        const boxB = this.boundingBoxForPaneView(paneViewB)\r\n        switch (direction) {\r\n          case 'left': return distance(box.left, boxA.right) - distance(box.left, boxB.right)\r\n          case 'right': return distance(box.right, boxA.left) - distance(box.right, boxB.left)\r\n          case 'above': return distance(box.top, boxA.bottom) - distance(box.top, boxB.bottom)\r\n          case 'below': return distance(box.bottom, boxA.top) - distance(box.bottom, boxB.top)\r\n        }\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.nearestVisiblePaneInDirection.distance","start_line":269,"end_line":273,"comment":[],"params":["pointA","pointB"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"distance","line":295,"func_location":"WorkspaceElement.nearestVisiblePaneInDirection.paneViews.(unnamed_function_9)","func_start_line":288,"func_end_line":297,"args":["box.bottom","boxA.top"],"code":"      }).sort((paneViewA, paneViewB) => {\r\n        const boxA = this.boundingBoxForPaneView(paneViewA)\r\n        const boxB = this.boundingBoxForPaneView(paneViewB)\r\n        switch (direction) {\r\n          case 'left': return distance(box.left, boxA.right) - distance(box.left, boxB.right)\r\n          case 'right': return distance(box.right, boxA.left) - distance(box.right, boxB.left)\r\n          case 'above': return distance(box.top, boxA.bottom) - distance(box.top, boxB.bottom)\r\n          case 'below': return distance(box.bottom, boxA.top) - distance(box.bottom, boxB.top)\r\n        }\r\n      })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.nearestVisiblePaneInDirection.distance","start_line":269,"end_line":273,"comment":[],"params":["pointA","pointB"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"containsPath","line":153,"func_location":"AtomWindow.containsPaths.(unnamed_function_9)","func_start_line":153,"func_end_line":153,"args":[null],"code":"    return paths.every(p => this.containsPath(p))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"AtomWindow.containsPath","start_line":156,"end_line":165,"comment":[],"params":["pathToCheck"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"displayWindow","line":784,"func_location":"AtomEnvironment.startEditorWindow.loadStatePromise.(unnamed_function_9)","func_start_line":782,"func_end_line":854,"args":[],"code":"    const loadStatePromise = this.loadState().then(async state => {\r\n      this.windowDimensions = state && state.windowDimensions\r\n      await this.displayWindow()\r\n      this.commandInstaller.installAtomCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n      this.commandInstaller.installApmCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidChangeUserSettings(settings =>\r\n        this.config.resetUserSettings(settings)\r\n      ))\r\n      this.disposables.add(this.applicationDelegate.onDidFailToReadUserSettings(message =>\r\n        this.notifications.addError(message)\r\n      ))\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidOpenLocations(this.openLocations.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onApplicationMenuCommand(this.dispatchApplicationMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onContextMenuCommand(this.dispatchContextMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onURIMessage(this.dispatchURIMessage.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onDidRequestUnload(this.prepareToUnloadEditorWindow.bind(this)))\r\n\r\n      this.listenForUpdates()\r\n\r\n      this.registerDefaultTargetForKeymaps()\r\n\r\n      this.packages.loadPackages()\r\n\r\n      const startTime = Date.now()\r\n      await this.deserialize(state)\r\n      this.deserializeTimings.atom = Date.now() - startTime\r\n\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom-inset') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-inset-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'hidden') {\r\n        this.document.body.classList.add('hidden-title-bar')\r\n      }\r\n\r\n      this.document.body.appendChild(this.workspace.getElement())\r\n      if (this.backgroundStylesheet) this.backgroundStylesheet.remove()\r\n\r\n      let previousProjectPaths = this.project.getPaths()\r\n      this.disposables.add(this.project.onDidChangePaths(newPaths => {\r\n        for (let path of previousProjectPaths) {\r\n          if (this.pathsWithWaitSessions.has(path) && !newPaths.includes(path)) {\r\n            this.applicationDelegate.didClosePathWithWaitSession(path)\r\n          }\r\n        }\r\n        previousProjectPaths = newPaths\r\n        this.applicationDelegate.setRepresentedDirectoryPaths(newPaths)\r\n      }))\r\n      this.disposables.add(this.workspace.onDidDestroyPaneItem(({item}) => {\r\n        const path = item.getPath && item.getPath()\r\n        if (this.pathsWithWaitSessions.has(path)) {\r\n          this.applicationDelegate.didClosePathWithWaitSession(path)\r\n        }\r\n      }))\r\n\r\n      this.packages.activate()\r\n      this.keymaps.loadUserKeymap()\r\n      if (!this.getLoadSettings().safeMode) this.requireUserInitScript()\r\n\r\n      this.menu.update()\r\n\r\n      await this.openInitialEmptyEditorIfNecessary()\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.displayWindow","start_line":659,"end_line":673,"comment":[" Restore the window to its previous dimensions and show it.",""," Restores the full screen and maximized state after the window has resized to"," prevent resize glitches."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"listenForUpdates","line":805,"func_location":"AtomEnvironment.startEditorWindow.loadStatePromise.(unnamed_function_9)","func_start_line":782,"func_end_line":854,"args":[],"code":"    const loadStatePromise = this.loadState().then(async state => {\r\n      this.windowDimensions = state && state.windowDimensions\r\n      await this.displayWindow()\r\n      this.commandInstaller.installAtomCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n      this.commandInstaller.installApmCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidChangeUserSettings(settings =>\r\n        this.config.resetUserSettings(settings)\r\n      ))\r\n      this.disposables.add(this.applicationDelegate.onDidFailToReadUserSettings(message =>\r\n        this.notifications.addError(message)\r\n      ))\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidOpenLocations(this.openLocations.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onApplicationMenuCommand(this.dispatchApplicationMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onContextMenuCommand(this.dispatchContextMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onURIMessage(this.dispatchURIMessage.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onDidRequestUnload(this.prepareToUnloadEditorWindow.bind(this)))\r\n\r\n      this.listenForUpdates()\r\n\r\n      this.registerDefaultTargetForKeymaps()\r\n\r\n      this.packages.loadPackages()\r\n\r\n      const startTime = Date.now()\r\n      await this.deserialize(state)\r\n      this.deserializeTimings.atom = Date.now() - startTime\r\n\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom-inset') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-inset-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'hidden') {\r\n        this.document.body.classList.add('hidden-title-bar')\r\n      }\r\n\r\n      this.document.body.appendChild(this.workspace.getElement())\r\n      if (this.backgroundStylesheet) this.backgroundStylesheet.remove()\r\n\r\n      let previousProjectPaths = this.project.getPaths()\r\n      this.disposables.add(this.project.onDidChangePaths(newPaths => {\r\n        for (let path of previousProjectPaths) {\r\n          if (this.pathsWithWaitSessions.has(path) && !newPaths.includes(path)) {\r\n            this.applicationDelegate.didClosePathWithWaitSession(path)\r\n          }\r\n        }\r\n        previousProjectPaths = newPaths\r\n        this.applicationDelegate.setRepresentedDirectoryPaths(newPaths)\r\n      }))\r\n      this.disposables.add(this.workspace.onDidDestroyPaneItem(({item}) => {\r\n        const path = item.getPath && item.getPath()\r\n        if (this.pathsWithWaitSessions.has(path)) {\r\n          this.applicationDelegate.didClosePathWithWaitSession(path)\r\n        }\r\n      }))\r\n\r\n      this.packages.activate()\r\n      this.keymaps.loadUserKeymap()\r\n      if (!this.getLoadSettings().safeMode) this.requireUserInitScript()\r\n\r\n      this.menu.update()\r\n\r\n      await this.openInitialEmptyEditorIfNecessary()\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.listenForUpdates","start_line":1321,"end_line":1324,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"registerDefaultTargetForKeymaps","line":807,"func_location":"AtomEnvironment.startEditorWindow.loadStatePromise.(unnamed_function_9)","func_start_line":782,"func_end_line":854,"args":[],"code":"    const loadStatePromise = this.loadState().then(async state => {\r\n      this.windowDimensions = state && state.windowDimensions\r\n      await this.displayWindow()\r\n      this.commandInstaller.installAtomCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n      this.commandInstaller.installApmCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidChangeUserSettings(settings =>\r\n        this.config.resetUserSettings(settings)\r\n      ))\r\n      this.disposables.add(this.applicationDelegate.onDidFailToReadUserSettings(message =>\r\n        this.notifications.addError(message)\r\n      ))\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidOpenLocations(this.openLocations.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onApplicationMenuCommand(this.dispatchApplicationMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onContextMenuCommand(this.dispatchContextMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onURIMessage(this.dispatchURIMessage.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onDidRequestUnload(this.prepareToUnloadEditorWindow.bind(this)))\r\n\r\n      this.listenForUpdates()\r\n\r\n      this.registerDefaultTargetForKeymaps()\r\n\r\n      this.packages.loadPackages()\r\n\r\n      const startTime = Date.now()\r\n      await this.deserialize(state)\r\n      this.deserializeTimings.atom = Date.now() - startTime\r\n\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom-inset') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-inset-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'hidden') {\r\n        this.document.body.classList.add('hidden-title-bar')\r\n      }\r\n\r\n      this.document.body.appendChild(this.workspace.getElement())\r\n      if (this.backgroundStylesheet) this.backgroundStylesheet.remove()\r\n\r\n      let previousProjectPaths = this.project.getPaths()\r\n      this.disposables.add(this.project.onDidChangePaths(newPaths => {\r\n        for (let path of previousProjectPaths) {\r\n          if (this.pathsWithWaitSessions.has(path) && !newPaths.includes(path)) {\r\n            this.applicationDelegate.didClosePathWithWaitSession(path)\r\n          }\r\n        }\r\n        previousProjectPaths = newPaths\r\n        this.applicationDelegate.setRepresentedDirectoryPaths(newPaths)\r\n      }))\r\n      this.disposables.add(this.workspace.onDidDestroyPaneItem(({item}) => {\r\n        const path = item.getPath && item.getPath()\r\n        if (this.pathsWithWaitSessions.has(path)) {\r\n          this.applicationDelegate.didClosePathWithWaitSession(path)\r\n        }\r\n      }))\r\n\r\n      this.packages.activate()\r\n      this.keymaps.loadUserKeymap()\r\n      if (!this.getLoadSettings().safeMode) this.requireUserInitScript()\r\n\r\n      this.menu.update()\r\n\r\n      await this.openInitialEmptyEditorIfNecessary()\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.registerDefaultTargetForKeymaps","start_line":324,"end_line":326,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"deserialize","line":812,"func_location":"AtomEnvironment.startEditorWindow.loadStatePromise.(unnamed_function_9)","func_start_line":782,"func_end_line":854,"args":["state"],"code":"    const loadStatePromise = this.loadState().then(async state => {\r\n      this.windowDimensions = state && state.windowDimensions\r\n      await this.displayWindow()\r\n      this.commandInstaller.installAtomCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n      this.commandInstaller.installApmCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidChangeUserSettings(settings =>\r\n        this.config.resetUserSettings(settings)\r\n      ))\r\n      this.disposables.add(this.applicationDelegate.onDidFailToReadUserSettings(message =>\r\n        this.notifications.addError(message)\r\n      ))\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidOpenLocations(this.openLocations.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onApplicationMenuCommand(this.dispatchApplicationMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onContextMenuCommand(this.dispatchContextMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onURIMessage(this.dispatchURIMessage.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onDidRequestUnload(this.prepareToUnloadEditorWindow.bind(this)))\r\n\r\n      this.listenForUpdates()\r\n\r\n      this.registerDefaultTargetForKeymaps()\r\n\r\n      this.packages.loadPackages()\r\n\r\n      const startTime = Date.now()\r\n      await this.deserialize(state)\r\n      this.deserializeTimings.atom = Date.now() - startTime\r\n\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom-inset') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-inset-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'hidden') {\r\n        this.document.body.classList.add('hidden-title-bar')\r\n      }\r\n\r\n      this.document.body.appendChild(this.workspace.getElement())\r\n      if (this.backgroundStylesheet) this.backgroundStylesheet.remove()\r\n\r\n      let previousProjectPaths = this.project.getPaths()\r\n      this.disposables.add(this.project.onDidChangePaths(newPaths => {\r\n        for (let path of previousProjectPaths) {\r\n          if (this.pathsWithWaitSessions.has(path) && !newPaths.includes(path)) {\r\n            this.applicationDelegate.didClosePathWithWaitSession(path)\r\n          }\r\n        }\r\n        previousProjectPaths = newPaths\r\n        this.applicationDelegate.setRepresentedDirectoryPaths(newPaths)\r\n      }))\r\n      this.disposables.add(this.workspace.onDidDestroyPaneItem(({item}) => {\r\n        const path = item.getPath && item.getPath()\r\n        if (this.pathsWithWaitSessions.has(path)) {\r\n          this.applicationDelegate.didClosePathWithWaitSession(path)\r\n        }\r\n      }))\r\n\r\n      this.packages.activate()\r\n      this.keymaps.loadUserKeymap()\r\n      if (!this.getLoadSettings().safeMode) this.requireUserInitScript()\r\n\r\n      this.menu.update()\r\n\r\n      await this.openInitialEmptyEditorIfNecessary()\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.deserialize","start_line":1223,"end_line":1277,"comment":[],"params":["state"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"getLoadSettings","line":849,"func_location":"AtomEnvironment.startEditorWindow.loadStatePromise.(unnamed_function_9)","func_start_line":782,"func_end_line":854,"args":[],"code":"    const loadStatePromise = this.loadState().then(async state => {\r\n      this.windowDimensions = state && state.windowDimensions\r\n      await this.displayWindow()\r\n      this.commandInstaller.installAtomCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n      this.commandInstaller.installApmCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidChangeUserSettings(settings =>\r\n        this.config.resetUserSettings(settings)\r\n      ))\r\n      this.disposables.add(this.applicationDelegate.onDidFailToReadUserSettings(message =>\r\n        this.notifications.addError(message)\r\n      ))\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidOpenLocations(this.openLocations.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onApplicationMenuCommand(this.dispatchApplicationMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onContextMenuCommand(this.dispatchContextMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onURIMessage(this.dispatchURIMessage.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onDidRequestUnload(this.prepareToUnloadEditorWindow.bind(this)))\r\n\r\n      this.listenForUpdates()\r\n\r\n      this.registerDefaultTargetForKeymaps()\r\n\r\n      this.packages.loadPackages()\r\n\r\n      const startTime = Date.now()\r\n      await this.deserialize(state)\r\n      this.deserializeTimings.atom = Date.now() - startTime\r\n\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom-inset') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-inset-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'hidden') {\r\n        this.document.body.classList.add('hidden-title-bar')\r\n      }\r\n\r\n      this.document.body.appendChild(this.workspace.getElement())\r\n      if (this.backgroundStylesheet) this.backgroundStylesheet.remove()\r\n\r\n      let previousProjectPaths = this.project.getPaths()\r\n      this.disposables.add(this.project.onDidChangePaths(newPaths => {\r\n        for (let path of previousProjectPaths) {\r\n          if (this.pathsWithWaitSessions.has(path) && !newPaths.includes(path)) {\r\n            this.applicationDelegate.didClosePathWithWaitSession(path)\r\n          }\r\n        }\r\n        previousProjectPaths = newPaths\r\n        this.applicationDelegate.setRepresentedDirectoryPaths(newPaths)\r\n      }))\r\n      this.disposables.add(this.workspace.onDidDestroyPaneItem(({item}) => {\r\n        const path = item.getPath && item.getPath()\r\n        if (this.pathsWithWaitSessions.has(path)) {\r\n          this.applicationDelegate.didClosePathWithWaitSession(path)\r\n        }\r\n      }))\r\n\r\n      this.packages.activate()\r\n      this.keymaps.loadUserKeymap()\r\n      if (!this.getLoadSettings().safeMode) this.requireUserInitScript()\r\n\r\n      this.menu.update()\r\n\r\n      await this.openInitialEmptyEditorIfNecessary()\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.getLoadSettings","start_line":525,"end_line":527,"comment":[" Public: Get the load settings for the current window.",""," Returns an {Object} containing all the load setting key/value pairs."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"requireUserInitScript","line":849,"func_location":"AtomEnvironment.startEditorWindow.loadStatePromise.(unnamed_function_9)","func_start_line":782,"func_end_line":854,"args":[],"code":"    const loadStatePromise = this.loadState().then(async state => {\r\n      this.windowDimensions = state && state.windowDimensions\r\n      await this.displayWindow()\r\n      this.commandInstaller.installAtomCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n      this.commandInstaller.installApmCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidChangeUserSettings(settings =>\r\n        this.config.resetUserSettings(settings)\r\n      ))\r\n      this.disposables.add(this.applicationDelegate.onDidFailToReadUserSettings(message =>\r\n        this.notifications.addError(message)\r\n      ))\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidOpenLocations(this.openLocations.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onApplicationMenuCommand(this.dispatchApplicationMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onContextMenuCommand(this.dispatchContextMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onURIMessage(this.dispatchURIMessage.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onDidRequestUnload(this.prepareToUnloadEditorWindow.bind(this)))\r\n\r\n      this.listenForUpdates()\r\n\r\n      this.registerDefaultTargetForKeymaps()\r\n\r\n      this.packages.loadPackages()\r\n\r\n      const startTime = Date.now()\r\n      await this.deserialize(state)\r\n      this.deserializeTimings.atom = Date.now() - startTime\r\n\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom-inset') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-inset-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'hidden') {\r\n        this.document.body.classList.add('hidden-title-bar')\r\n      }\r\n\r\n      this.document.body.appendChild(this.workspace.getElement())\r\n      if (this.backgroundStylesheet) this.backgroundStylesheet.remove()\r\n\r\n      let previousProjectPaths = this.project.getPaths()\r\n      this.disposables.add(this.project.onDidChangePaths(newPaths => {\r\n        for (let path of previousProjectPaths) {\r\n          if (this.pathsWithWaitSessions.has(path) && !newPaths.includes(path)) {\r\n            this.applicationDelegate.didClosePathWithWaitSession(path)\r\n          }\r\n        }\r\n        previousProjectPaths = newPaths\r\n        this.applicationDelegate.setRepresentedDirectoryPaths(newPaths)\r\n      }))\r\n      this.disposables.add(this.workspace.onDidDestroyPaneItem(({item}) => {\r\n        const path = item.getPath && item.getPath()\r\n        if (this.pathsWithWaitSessions.has(path)) {\r\n          this.applicationDelegate.didClosePathWithWaitSession(path)\r\n        }\r\n      }))\r\n\r\n      this.packages.activate()\r\n      this.keymaps.loadUserKeymap()\r\n      if (!this.getLoadSettings().safeMode) this.requireUserInitScript()\r\n\r\n      this.menu.update()\r\n\r\n      await this.openInitialEmptyEditorIfNecessary()\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.requireUserInitScript","start_line":1298,"end_line":1310,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"openInitialEmptyEditorIfNecessary","line":853,"func_location":"AtomEnvironment.startEditorWindow.loadStatePromise.(unnamed_function_9)","func_start_line":782,"func_end_line":854,"args":[],"code":"    const loadStatePromise = this.loadState().then(async state => {\r\n      this.windowDimensions = state && state.windowDimensions\r\n      await this.displayWindow()\r\n      this.commandInstaller.installAtomCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n      this.commandInstaller.installApmCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidChangeUserSettings(settings =>\r\n        this.config.resetUserSettings(settings)\r\n      ))\r\n      this.disposables.add(this.applicationDelegate.onDidFailToReadUserSettings(message =>\r\n        this.notifications.addError(message)\r\n      ))\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidOpenLocations(this.openLocations.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onApplicationMenuCommand(this.dispatchApplicationMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onContextMenuCommand(this.dispatchContextMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onURIMessage(this.dispatchURIMessage.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onDidRequestUnload(this.prepareToUnloadEditorWindow.bind(this)))\r\n\r\n      this.listenForUpdates()\r\n\r\n      this.registerDefaultTargetForKeymaps()\r\n\r\n      this.packages.loadPackages()\r\n\r\n      const startTime = Date.now()\r\n      await this.deserialize(state)\r\n      this.deserializeTimings.atom = Date.now() - startTime\r\n\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom-inset') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-inset-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'hidden') {\r\n        this.document.body.classList.add('hidden-title-bar')\r\n      }\r\n\r\n      this.document.body.appendChild(this.workspace.getElement())\r\n      if (this.backgroundStylesheet) this.backgroundStylesheet.remove()\r\n\r\n      let previousProjectPaths = this.project.getPaths()\r\n      this.disposables.add(this.project.onDidChangePaths(newPaths => {\r\n        for (let path of previousProjectPaths) {\r\n          if (this.pathsWithWaitSessions.has(path) && !newPaths.includes(path)) {\r\n            this.applicationDelegate.didClosePathWithWaitSession(path)\r\n          }\r\n        }\r\n        previousProjectPaths = newPaths\r\n        this.applicationDelegate.setRepresentedDirectoryPaths(newPaths)\r\n      }))\r\n      this.disposables.add(this.workspace.onDidDestroyPaneItem(({item}) => {\r\n        const path = item.getPath && item.getPath()\r\n        if (this.pathsWithWaitSessions.has(path)) {\r\n          this.applicationDelegate.didClosePathWithWaitSession(path)\r\n        }\r\n      }))\r\n\r\n      this.packages.activate()\r\n      this.keymaps.loadUserKeymap()\r\n      if (!this.getLoadSettings().safeMode) this.requireUserInitScript()\r\n\r\n      this.menu.update()\r\n\r\n      await this.openInitialEmptyEditorIfNecessary()\r\n    })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.openInitialEmptyEditorIfNecessary","start_line":914,"end_line":920,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"openUrl","line":266,"func_location":"AtomApplication.openWithOptions.(unnamed_function_9)","func_start_line":266,"func_end_line":266,"args":[null],"code":"      return urlsToOpen.map(urlToOpen => this.openUrl({urlToOpen, devMode, safeMode, env}))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.openUrl","start_line":1008,"end_line":1025,"comment":[" Open an atom:// url.",""," The host of the URL being opened is assumed to be the package name"," responsible for opening the URL.  A new window will be created with"," that package's `urlMain` as the bootstrap script.",""," options -","   :urlToOpen - The atom:// url to open.","   :devMode - Boolean to control the opened window's dev mode.","   :safeMode - Boolean to control the opened window's safe mode."],"params":[["urlToOpen","devMode","safeMode","env"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js","name":"shouldEditorUseSoftTabs","line":276,"func_location":"TextEditorRegistry.subscribeToSettingsForEditorScope.updateTabTypes.(unnamed_function_8).(unnamed_function_9)","func_start_line":274,"func_end_line":278,"args":[null],"code":"        this.editorsWithMaintainedConfig.forEach((editor) => {\r\n          if (editor.getRootScopeDescriptor().isEqual(scopeDescriptor)) {\r\n            editor.setSoftTabs(shouldEditorUseSoftTabs(editor, tabType, softTabs))\r\n          }\r\n        })\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js","name":"shouldEditorUseSoftTabs","start_line":298,"end_line":314,"comment":[],"params":["editor","tabType","softTabs"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"focusedWindow","line":157,"func_location":"submenu.click.(unnamed_function_9)","func_start_line":156,"func_end_line":159,"args":[],"code":"          click: () => {\r\n            const window = this.focusedWindow()\r\n            if (window) window.reload()\r\n          }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"ApplicationMenu.focusedWindow","start_line":186,"end_line":188,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getPendingItem","line":624,"func_location":"Pane.addItem.(unnamed_function_9)","func_start_line":623,"func_end_line":625,"args":[],"code":"      itemSubscriptions.add(item.onDidTerminatePendingState(() => {\r\n        if (this.getPendingItem() === item) this.clearPendingItem()\r\n      }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getPendingItem","start_line":654,"end_line":656,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"clearPendingItem","line":624,"func_location":"Pane.addItem.(unnamed_function_9)","func_start_line":623,"func_end_line":625,"args":[],"code":"      itemSubscriptions.add(item.onDidTerminatePendingState(() => {\r\n        if (this.getPendingItem() === item) this.clearPendingItem()\r\n      }))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.clearPendingItem","start_line":658,"end_line":660,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"killProcessesForWindow","line":923,"func_location":"AtomApplication.openPaths.(unnamed_function_90)","func_start_line":923,"func_end_line":923,"args":[{"type":"string"},null],"code":"    openedWindow.browserWindow.once('closed', () => this.killProcessesForWindow(openedWindow))\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.killProcessesForWindow","start_line":934,"end_line":941,"comment":[],"params":["window"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"openPaths","line":1313,"func_location":"AtomApplication.promptForPathToOpen.(unnamed_function_97)","func_start_line":1312,"func_end_line":1314,"args":[null],"code":"      pathsToOpen => {\r\n        return this.openPaths({pathsToOpen, devMode, safeMode, window})\r\n      },\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.openPaths","start_line":825,"end_line":925,"comment":[" Public: Opens multiple paths, in existing windows if possible.",""," options -","   :pathsToOpen - The array of file paths to open","   :pidToKillWhenClosed - The integer of the pid to kill","   :newWindow - Boolean of whether this should be opened in a new window.","   :devMode - Boolean to control the opened window's dev mode.","   :safeMode - Boolean to control the opened window's safe mode.","   :windowDimensions - Object with height and width keys.","   :window - {AtomWindow} to open file paths in.","   :addToLastWindow - Boolean of whether this should be opened in last focused window."],"params":[["initialPaths","pathsToOpen","executedFrom","pidToKillWhenClosed","newWindow","devMode","safeMode","windowDimensions","profileStartup","window","clearWindowState","addToLastWindow","env"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/native-compile-cache.js","name":"computeHash","line":63,"func_location":"Module.prototype._compile","func_start_line":42,"func_end_line":88,"args":[null],"comment":[" Here we override Node's module.js"," (https://github.com/atom/node/blob/atom/lib/module.js#L378), changing"," only the bits that affect compilation in order to use the cached one."],"code":"    Module.prototype._compile = function (content, filename) {\r\n      let moduleSelf = this\r\n      // remove shebang\r\n      content = content.replace(/^#!.*/, '')\r\n      function require (path) {\r\n        return moduleSelf.require(path)\r\n      }\r\n      require.resolve = function (request) {\r\n        return Module._resolveFilename(request, moduleSelf)\r\n      }\r\n      require.main = process.mainModule\r\n\r\n      // Enable support to add extra extension types\r\n      require.extensions = Module._extensions\r\n      require.cache = Module._cache\r\n\r\n      let dirname = path.dirname(filename)\r\n\r\n      // create wrapper function\r\n      let wrapper = Module.wrap(content)\r\n\r\n      let cacheKey = computeHash(wrapper + self.v8Version)\r\n      let compiledWrapper = null\r\n      if (self.cacheStore.has(cacheKey)) {\r\n        let buffer = self.cacheStore.get(cacheKey)\r\n        let compilationResult = cachedVm.runInThisContextCached(wrapper, filename, buffer)\r\n        compiledWrapper = compilationResult.result\r\n        if (compilationResult.wasRejected) {\r\n          self.cacheStore.delete(cacheKey)\r\n        }\r\n      } else {\r\n        let compilationResult\r\n        try {\r\n          compilationResult = cachedVm.runInThisContext(wrapper, filename)\r\n        } catch (err) {\r\n          console.error(`Error running script ${filename}`)\r\n          throw err\r\n        }\r\n        if (compilationResult.cacheBuffer) {\r\n          self.cacheStore.set(cacheKey, compilationResult.cacheBuffer)\r\n        }\r\n        compiledWrapper = compilationResult.result\r\n      }\r\n\r\n      let args = [moduleSelf.exports, require, moduleSelf, filename, dirname, process, global, Buffer]\r\n      return compiledWrapper.apply(moduleSelf.exports, args)\r\n    }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/native-compile-cache.js","name":"computeHash","start_line":6,"end_line":8,"comment":[],"params":["contents"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"_currentScopeId","line":1035,"func_location":"LayerHighlightIterator._moveDown","func_start_line":1016,"func_end_line":1040,"args":[],"code":"  _moveDown () {\r\n    let result = false\r\n    const {startIndex} = this.treeCursor\r\n\r\n    // Once the iterator has found a scope boundary, it needs to stay at the same\r\n    // position, so it should not move down if the first child node starts later than the\r\n    // current node.\r\n    while (this.treeCursor.gotoFirstChild()) {\r\n      if ((this.closeTags.length || this.openTags.length) &&\r\n          this.treeCursor.startIndex > startIndex) {\r\n        this.treeCursor.gotoParent()\r\n        break\r\n      }\r\n\r\n      result = true\r\n      this.containingNodeTypes.push(this.treeCursor.nodeType)\r\n      this.containingNodeChildIndices.push(0)\r\n      this.containingNodeEndIndices.push(this.treeCursor.endIndex)\r\n\r\n      const scopeId = this._currentScopeId()\r\n      if (scopeId) this.openTags.push(scopeId)\r\n    }\r\n\r\n    return result\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"LayerHighlightIterator._currentScopeId","start_line":1052,"end_line":1062,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"_currentScopeId","line":1010,"func_location":"LayerHighlightIterator._moveUp","func_start_line":996,"func_end_line":1014,"args":[],"comment":[" Private methods"],"code":"  _moveUp (atLastChild) {\r\n    let result = false\r\n    const {endIndex} = this.treeCursor\r\n    let depth = this.containingNodeEndIndices.length\r\n\r\n    // The iterator should not move up until it has visited all of the children of this node.\r\n    while (depth > 1 && (atLastChild || this.containingNodeEndIndices[depth - 2] === endIndex)) {\r\n      atLastChild = false\r\n      result = true\r\n      this.treeCursor.gotoParent()\r\n      this.containingNodeTypes.pop()\r\n      this.containingNodeChildIndices.pop()\r\n      this.containingNodeEndIndices.pop()\r\n      --depth\r\n      const scopeId = this._currentScopeId()\r\n      if (scopeId) this.closeTags.push(scopeId)\r\n    }\r\n    return result\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"LayerHighlightIterator._currentScopeId","start_line":1052,"end_line":1062,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"_treeEditForBufferChange","line":652,"func_location":"LanguageLayer._performUpdate","func_start_line":623,"func_end_line":699},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"LanguageLayer._treeEditForBufferChange","start_line":783,"end_line":793,"comment":[],"params":["start","oldEnd","newEnd","oldText","newText"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"rangeForNode","line":667,"func_location":"LanguageLayer._performUpdate","func_start_line":623,"func_end_line":699,"args":[null],"code":"  async _performUpdate (nodeRangeSet, params) {\r\n    let includedRanges = null\r\n    if (nodeRangeSet) {\r\n      includedRanges = nodeRangeSet.getRanges()\r\n      if (includedRanges.length === 0) {\r\n        this.tree = null\r\n        this.destroyed = true\r\n        return\r\n      }\r\n    }\r\n\r\n    let affectedRange = this.editedRange\r\n    this.editedRange = null\r\n\r\n    this.patchSinceCurrentParseStarted = new Patch()\r\n    let tree = this.languageMode.parse(\r\n      this.grammar.languageModule,\r\n      this.tree,\r\n      includedRanges\r\n    )\r\n    if (tree.then) {\r\n      params.async = true\r\n      tree = await tree\r\n    }\r\n\r\n    const changes = this.patchSinceCurrentParseStarted.getChanges()\r\n    this.patchSinceCurrentParseStarted = null\r\n    for (const {oldStart, newStart, oldEnd, newEnd, oldText, newText} of changes) {\r\n      const newExtent = Point.fromObject(newEnd).traversalFrom(newStart)\r\n      tree.edit(this._treeEditForBufferChange(\r\n        newStart,\r\n        oldEnd,\r\n        Point.fromObject(oldStart).traverse(newExtent),\r\n        oldText,\r\n        newText\r\n      ))\r\n    }\r\n\r\n    if (this.tree) {\r\n      const rangesWithSyntaxChanges = this.tree.getChangedRanges(tree)\r\n      this.tree = tree\r\n\r\n      if (rangesWithSyntaxChanges.length > 0) {\r\n        for (const range of rangesWithSyntaxChanges) {\r\n          this.languageMode.emitRangeUpdate(rangeForNode(range))\r\n        }\r\n\r\n        const combinedRangeWithSyntaxChange = new Range(\r\n          rangesWithSyntaxChanges[0].startPosition,\r\n          last(rangesWithSyntaxChanges).endPosition\r\n        )\r\n\r\n        if (affectedRange) {\r\n          this.languageMode.emitRangeUpdate(affectedRange)\r\n          affectedRange = affectedRange.union(combinedRangeWithSyntaxChange)\r\n        } else {\r\n          affectedRange = combinedRangeWithSyntaxChange\r\n        }\r\n      }\r\n    } else {\r\n      this.tree = tree\r\n      this.languageMode.emitRangeUpdate(rangeForNode(tree.rootNode))\r\n      if (includedRanges) {\r\n        affectedRange = new Range(includedRanges[0].startPosition, last(includedRanges).endPosition)\r\n      } else {\r\n        affectedRange = MAX_RANGE\r\n      }\r\n    }\r\n\r\n    if (affectedRange) {\r\n      const injectionPromise = this._populateInjections(affectedRange, nodeRangeSet)\r\n      if (injectionPromise) {\r\n        params.async = true\r\n        return injectionPromise\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"rangeForNode","start_line":1190,"end_line":1192,"comment":[],"params":["node"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"last","line":672,"func_location":"LanguageLayer._performUpdate","func_start_line":623,"func_end_line":699,"args":["rangesWithSyntaxChanges"],"code":"  async _performUpdate (nodeRangeSet, params) {\r\n    let includedRanges = null\r\n    if (nodeRangeSet) {\r\n      includedRanges = nodeRangeSet.getRanges()\r\n      if (includedRanges.length === 0) {\r\n        this.tree = null\r\n        this.destroyed = true\r\n        return\r\n      }\r\n    }\r\n\r\n    let affectedRange = this.editedRange\r\n    this.editedRange = null\r\n\r\n    this.patchSinceCurrentParseStarted = new Patch()\r\n    let tree = this.languageMode.parse(\r\n      this.grammar.languageModule,\r\n      this.tree,\r\n      includedRanges\r\n    )\r\n    if (tree.then) {\r\n      params.async = true\r\n      tree = await tree\r\n    }\r\n\r\n    const changes = this.patchSinceCurrentParseStarted.getChanges()\r\n    this.patchSinceCurrentParseStarted = null\r\n    for (const {oldStart, newStart, oldEnd, newEnd, oldText, newText} of changes) {\r\n      const newExtent = Point.fromObject(newEnd).traversalFrom(newStart)\r\n      tree.edit(this._treeEditForBufferChange(\r\n        newStart,\r\n        oldEnd,\r\n        Point.fromObject(oldStart).traverse(newExtent),\r\n        oldText,\r\n        newText\r\n      ))\r\n    }\r\n\r\n    if (this.tree) {\r\n      const rangesWithSyntaxChanges = this.tree.getChangedRanges(tree)\r\n      this.tree = tree\r\n\r\n      if (rangesWithSyntaxChanges.length > 0) {\r\n        for (const range of rangesWithSyntaxChanges) {\r\n          this.languageMode.emitRangeUpdate(rangeForNode(range))\r\n        }\r\n\r\n        const combinedRangeWithSyntaxChange = new Range(\r\n          rangesWithSyntaxChanges[0].startPosition,\r\n          last(rangesWithSyntaxChanges).endPosition\r\n        )\r\n\r\n        if (affectedRange) {\r\n          this.languageMode.emitRangeUpdate(affectedRange)\r\n          affectedRange = affectedRange.union(combinedRangeWithSyntaxChange)\r\n        } else {\r\n          affectedRange = combinedRangeWithSyntaxChange\r\n        }\r\n      }\r\n    } else {\r\n      this.tree = tree\r\n      this.languageMode.emitRangeUpdate(rangeForNode(tree.rootNode))\r\n      if (includedRanges) {\r\n        affectedRange = new Range(includedRanges[0].startPosition, last(includedRanges).endPosition)\r\n      } else {\r\n        affectedRange = MAX_RANGE\r\n      }\r\n    }\r\n\r\n    if (affectedRange) {\r\n      const injectionPromise = this._populateInjections(affectedRange, nodeRangeSet)\r\n      if (injectionPromise) {\r\n        params.async = true\r\n        return injectionPromise\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"last","start_line":1206,"end_line":1208,"comment":[],"params":["array"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"rangeForNode","line":684,"func_location":"LanguageLayer._performUpdate","func_start_line":623,"func_end_line":699,"args":[null],"code":"  async _performUpdate (nodeRangeSet, params) {\r\n    let includedRanges = null\r\n    if (nodeRangeSet) {\r\n      includedRanges = nodeRangeSet.getRanges()\r\n      if (includedRanges.length === 0) {\r\n        this.tree = null\r\n        this.destroyed = true\r\n        return\r\n      }\r\n    }\r\n\r\n    let affectedRange = this.editedRange\r\n    this.editedRange = null\r\n\r\n    this.patchSinceCurrentParseStarted = new Patch()\r\n    let tree = this.languageMode.parse(\r\n      this.grammar.languageModule,\r\n      this.tree,\r\n      includedRanges\r\n    )\r\n    if (tree.then) {\r\n      params.async = true\r\n      tree = await tree\r\n    }\r\n\r\n    const changes = this.patchSinceCurrentParseStarted.getChanges()\r\n    this.patchSinceCurrentParseStarted = null\r\n    for (const {oldStart, newStart, oldEnd, newEnd, oldText, newText} of changes) {\r\n      const newExtent = Point.fromObject(newEnd).traversalFrom(newStart)\r\n      tree.edit(this._treeEditForBufferChange(\r\n        newStart,\r\n        oldEnd,\r\n        Point.fromObject(oldStart).traverse(newExtent),\r\n        oldText,\r\n        newText\r\n      ))\r\n    }\r\n\r\n    if (this.tree) {\r\n      const rangesWithSyntaxChanges = this.tree.getChangedRanges(tree)\r\n      this.tree = tree\r\n\r\n      if (rangesWithSyntaxChanges.length > 0) {\r\n        for (const range of rangesWithSyntaxChanges) {\r\n          this.languageMode.emitRangeUpdate(rangeForNode(range))\r\n        }\r\n\r\n        const combinedRangeWithSyntaxChange = new Range(\r\n          rangesWithSyntaxChanges[0].startPosition,\r\n          last(rangesWithSyntaxChanges).endPosition\r\n        )\r\n\r\n        if (affectedRange) {\r\n          this.languageMode.emitRangeUpdate(affectedRange)\r\n          affectedRange = affectedRange.union(combinedRangeWithSyntaxChange)\r\n        } else {\r\n          affectedRange = combinedRangeWithSyntaxChange\r\n        }\r\n      }\r\n    } else {\r\n      this.tree = tree\r\n      this.languageMode.emitRangeUpdate(rangeForNode(tree.rootNode))\r\n      if (includedRanges) {\r\n        affectedRange = new Range(includedRanges[0].startPosition, last(includedRanges).endPosition)\r\n      } else {\r\n        affectedRange = MAX_RANGE\r\n      }\r\n    }\r\n\r\n    if (affectedRange) {\r\n      const injectionPromise = this._populateInjections(affectedRange, nodeRangeSet)\r\n      if (injectionPromise) {\r\n        params.async = true\r\n        return injectionPromise\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"rangeForNode","start_line":1190,"end_line":1192,"comment":[],"params":["node"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"last","line":686,"func_location":"LanguageLayer._performUpdate","func_start_line":623,"func_end_line":699,"args":["includedRanges"],"code":"  async _performUpdate (nodeRangeSet, params) {\r\n    let includedRanges = null\r\n    if (nodeRangeSet) {\r\n      includedRanges = nodeRangeSet.getRanges()\r\n      if (includedRanges.length === 0) {\r\n        this.tree = null\r\n        this.destroyed = true\r\n        return\r\n      }\r\n    }\r\n\r\n    let affectedRange = this.editedRange\r\n    this.editedRange = null\r\n\r\n    this.patchSinceCurrentParseStarted = new Patch()\r\n    let tree = this.languageMode.parse(\r\n      this.grammar.languageModule,\r\n      this.tree,\r\n      includedRanges\r\n    )\r\n    if (tree.then) {\r\n      params.async = true\r\n      tree = await tree\r\n    }\r\n\r\n    const changes = this.patchSinceCurrentParseStarted.getChanges()\r\n    this.patchSinceCurrentParseStarted = null\r\n    for (const {oldStart, newStart, oldEnd, newEnd, oldText, newText} of changes) {\r\n      const newExtent = Point.fromObject(newEnd).traversalFrom(newStart)\r\n      tree.edit(this._treeEditForBufferChange(\r\n        newStart,\r\n        oldEnd,\r\n        Point.fromObject(oldStart).traverse(newExtent),\r\n        oldText,\r\n        newText\r\n      ))\r\n    }\r\n\r\n    if (this.tree) {\r\n      const rangesWithSyntaxChanges = this.tree.getChangedRanges(tree)\r\n      this.tree = tree\r\n\r\n      if (rangesWithSyntaxChanges.length > 0) {\r\n        for (const range of rangesWithSyntaxChanges) {\r\n          this.languageMode.emitRangeUpdate(rangeForNode(range))\r\n        }\r\n\r\n        const combinedRangeWithSyntaxChange = new Range(\r\n          rangesWithSyntaxChanges[0].startPosition,\r\n          last(rangesWithSyntaxChanges).endPosition\r\n        )\r\n\r\n        if (affectedRange) {\r\n          this.languageMode.emitRangeUpdate(affectedRange)\r\n          affectedRange = affectedRange.union(combinedRangeWithSyntaxChange)\r\n        } else {\r\n          affectedRange = combinedRangeWithSyntaxChange\r\n        }\r\n      }\r\n    } else {\r\n      this.tree = tree\r\n      this.languageMode.emitRangeUpdate(rangeForNode(tree.rootNode))\r\n      if (includedRanges) {\r\n        affectedRange = new Range(includedRanges[0].startPosition, last(includedRanges).endPosition)\r\n      } else {\r\n        affectedRange = MAX_RANGE\r\n      }\r\n    }\r\n\r\n    if (affectedRange) {\r\n      const injectionPromise = this._populateInjections(affectedRange, nodeRangeSet)\r\n      if (injectionPromise) {\r\n        params.async = true\r\n        return injectionPromise\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"last","start_line":1206,"end_line":1208,"comment":[],"params":["array"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"_populateInjections","line":693,"func_location":"LanguageLayer._performUpdate","func_start_line":623,"func_end_line":699,"args":["affectedRange","nodeRangeSet"],"code":"  async _performUpdate (nodeRangeSet, params) {\r\n    let includedRanges = null\r\n    if (nodeRangeSet) {\r\n      includedRanges = nodeRangeSet.getRanges()\r\n      if (includedRanges.length === 0) {\r\n        this.tree = null\r\n        this.destroyed = true\r\n        return\r\n      }\r\n    }\r\n\r\n    let affectedRange = this.editedRange\r\n    this.editedRange = null\r\n\r\n    this.patchSinceCurrentParseStarted = new Patch()\r\n    let tree = this.languageMode.parse(\r\n      this.grammar.languageModule,\r\n      this.tree,\r\n      includedRanges\r\n    )\r\n    if (tree.then) {\r\n      params.async = true\r\n      tree = await tree\r\n    }\r\n\r\n    const changes = this.patchSinceCurrentParseStarted.getChanges()\r\n    this.patchSinceCurrentParseStarted = null\r\n    for (const {oldStart, newStart, oldEnd, newEnd, oldText, newText} of changes) {\r\n      const newExtent = Point.fromObject(newEnd).traversalFrom(newStart)\r\n      tree.edit(this._treeEditForBufferChange(\r\n        newStart,\r\n        oldEnd,\r\n        Point.fromObject(oldStart).traverse(newExtent),\r\n        oldText,\r\n        newText\r\n      ))\r\n    }\r\n\r\n    if (this.tree) {\r\n      const rangesWithSyntaxChanges = this.tree.getChangedRanges(tree)\r\n      this.tree = tree\r\n\r\n      if (rangesWithSyntaxChanges.length > 0) {\r\n        for (const range of rangesWithSyntaxChanges) {\r\n          this.languageMode.emitRangeUpdate(rangeForNode(range))\r\n        }\r\n\r\n        const combinedRangeWithSyntaxChange = new Range(\r\n          rangesWithSyntaxChanges[0].startPosition,\r\n          last(rangesWithSyntaxChanges).endPosition\r\n        )\r\n\r\n        if (affectedRange) {\r\n          this.languageMode.emitRangeUpdate(affectedRange)\r\n          affectedRange = affectedRange.union(combinedRangeWithSyntaxChange)\r\n        } else {\r\n          affectedRange = combinedRangeWithSyntaxChange\r\n        }\r\n      }\r\n    } else {\r\n      this.tree = tree\r\n      this.languageMode.emitRangeUpdate(rangeForNode(tree.rootNode))\r\n      if (includedRanges) {\r\n        affectedRange = new Range(includedRanges[0].startPosition, last(includedRanges).endPosition)\r\n      } else {\r\n        affectedRange = MAX_RANGE\r\n      }\r\n    }\r\n\r\n    if (affectedRange) {\r\n      const injectionPromise = this._populateInjections(affectedRange, nodeRangeSet)\r\n      if (injectionPromise) {\r\n        params.async = true\r\n        return injectionPromise\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"LanguageLayer._populateInjections","start_line":701,"end_line":781,"comment":[],"params":["range","nodeRangeSet"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"last","line":709,"func_location":"LanguageLayer._populateInjections","func_start_line":701,"func_end_line":781,"args":[],"code":"  _populateInjections (range, nodeRangeSet) {\r\n    const existingInjectionMarkers = this.languageMode.injectionsMarkerLayer\r\n      .findMarkers({intersectsRange: range})\r\n      .filter(marker => marker.parentLanguageLayer === this)\r\n\r\n    if (existingInjectionMarkers.length > 0) {\r\n      range = range.union(new Range(\r\n        existingInjectionMarkers[0].getRange().start,\r\n        last(existingInjectionMarkers).getRange().end\r\n      ))\r\n    }\r\n\r\n    const markersToUpdate = new Map()\r\n    const nodes = this.tree.rootNode.descendantsOfType(\r\n      Object.keys(this.grammar.injectionPointsByType),\r\n      range.start,\r\n      range.end\r\n    )\r\n\r\n    let existingInjectionMarkerIndex = 0\r\n    for (const node of nodes) {\r\n      for (const injectionPoint of this.grammar.injectionPointsByType[node.type]) {\r\n        const languageName = injectionPoint.language(node)\r\n        if (!languageName) continue\r\n\r\n        const grammar = this.languageMode.grammarForLanguageString(languageName)\r\n        if (!grammar) continue\r\n\r\n        const contentNodes = injectionPoint.content(node)\r\n        if (!contentNodes) continue\r\n\r\n        const injectionNodes = [].concat(contentNodes)\r\n        if (!injectionNodes.length) continue\r\n\r\n        const injectionRange = rangeForNode(node)\r\n\r\n        let marker\r\n        for (let i = existingInjectionMarkerIndex, n = existingInjectionMarkers.length; i < n; i++) {\r\n          const existingMarker = existingInjectionMarkers[i]\r\n          const comparison = existingMarker.getRange().compare(injectionRange)\r\n          if (comparison > 0) {\r\n            break\r\n          } else if (comparison === 0) {\r\n            existingInjectionMarkerIndex = i\r\n            if (existingMarker.languageLayer.grammar === grammar) {\r\n              marker = existingMarker\r\n              marker.id === node.id\r\n              break\r\n            }\r\n          } else {\r\n            existingInjectionMarkerIndex = i\r\n          }\r\n        }\r\n\r\n        if (!marker) {\r\n          marker = this.languageMode.injectionsMarkerLayer.markRange(injectionRange)\r\n          marker.languageLayer = new LanguageLayer(this.languageMode, grammar, injectionPoint.contentChildTypes)\r\n          marker.parentLanguageLayer = this\r\n        }\r\n\r\n        markersToUpdate.set(marker, new NodeRangeSet(nodeRangeSet, injectionNodes))\r\n      }\r\n    }\r\n\r\n    for (const marker of existingInjectionMarkers) {\r\n      if (!markersToUpdate.has(marker)) {\r\n        marker.languageLayer.destroy()\r\n        this.languageMode.emitRangeUpdate(marker.getRange())\r\n        marker.destroy()\r\n      }\r\n    }\r\n\r\n    if (markersToUpdate.size > 0) {\r\n      this.lastUpdateWasAsync = true\r\n      const promises = []\r\n      for (const [marker, nodeRangeSet] of markersToUpdate) {\r\n        promises.push(marker.languageLayer.update(nodeRangeSet))\r\n      }\r\n      return Promise.all(promises)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"last","start_line":1206,"end_line":1208,"comment":[],"params":["array"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"rangeForNode","line":735,"func_location":"LanguageLayer._populateInjections","func_start_line":701,"func_end_line":781,"args":["node"],"code":"  _populateInjections (range, nodeRangeSet) {\r\n    const existingInjectionMarkers = this.languageMode.injectionsMarkerLayer\r\n      .findMarkers({intersectsRange: range})\r\n      .filter(marker => marker.parentLanguageLayer === this)\r\n\r\n    if (existingInjectionMarkers.length > 0) {\r\n      range = range.union(new Range(\r\n        existingInjectionMarkers[0].getRange().start,\r\n        last(existingInjectionMarkers).getRange().end\r\n      ))\r\n    }\r\n\r\n    const markersToUpdate = new Map()\r\n    const nodes = this.tree.rootNode.descendantsOfType(\r\n      Object.keys(this.grammar.injectionPointsByType),\r\n      range.start,\r\n      range.end\r\n    )\r\n\r\n    let existingInjectionMarkerIndex = 0\r\n    for (const node of nodes) {\r\n      for (const injectionPoint of this.grammar.injectionPointsByType[node.type]) {\r\n        const languageName = injectionPoint.language(node)\r\n        if (!languageName) continue\r\n\r\n        const grammar = this.languageMode.grammarForLanguageString(languageName)\r\n        if (!grammar) continue\r\n\r\n        const contentNodes = injectionPoint.content(node)\r\n        if (!contentNodes) continue\r\n\r\n        const injectionNodes = [].concat(contentNodes)\r\n        if (!injectionNodes.length) continue\r\n\r\n        const injectionRange = rangeForNode(node)\r\n\r\n        let marker\r\n        for (let i = existingInjectionMarkerIndex, n = existingInjectionMarkers.length; i < n; i++) {\r\n          const existingMarker = existingInjectionMarkers[i]\r\n          const comparison = existingMarker.getRange().compare(injectionRange)\r\n          if (comparison > 0) {\r\n            break\r\n          } else if (comparison === 0) {\r\n            existingInjectionMarkerIndex = i\r\n            if (existingMarker.languageLayer.grammar === grammar) {\r\n              marker = existingMarker\r\n              marker.id === node.id\r\n              break\r\n            }\r\n          } else {\r\n            existingInjectionMarkerIndex = i\r\n          }\r\n        }\r\n\r\n        if (!marker) {\r\n          marker = this.languageMode.injectionsMarkerLayer.markRange(injectionRange)\r\n          marker.languageLayer = new LanguageLayer(this.languageMode, grammar, injectionPoint.contentChildTypes)\r\n          marker.parentLanguageLayer = this\r\n        }\r\n\r\n        markersToUpdate.set(marker, new NodeRangeSet(nodeRangeSet, injectionNodes))\r\n      }\r\n    }\r\n\r\n    for (const marker of existingInjectionMarkers) {\r\n      if (!markersToUpdate.has(marker)) {\r\n        marker.languageLayer.destroy()\r\n        this.languageMode.emitRangeUpdate(marker.getRange())\r\n        marker.destroy()\r\n      }\r\n    }\r\n\r\n    if (markersToUpdate.size > 0) {\r\n      this.lastUpdateWasAsync = true\r\n      const promises = []\r\n      for (const [marker, nodeRangeSet] of markersToUpdate) {\r\n        promises.push(marker.languageLayer.update(nodeRangeSet))\r\n      }\r\n      return Promise.all(promises)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"rangeForNode","start_line":1190,"end_line":1192,"comment":[],"params":["node"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"constructor","line":757,"func_location":"LanguageLayer._populateInjections","func_start_line":701,"func_end_line":781},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"LanguageLayer.constructor","start_line":545,"end_line":552,"comment":[],"params":["languageMode","grammar","contentChildTypes"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"constructor","line":761,"func_location":"LanguageLayer._populateInjections","func_start_line":701,"func_end_line":781,"args":["marker",null],"code":"  _populateInjections (range, nodeRangeSet) {\r\n    const existingInjectionMarkers = this.languageMode.injectionsMarkerLayer\r\n      .findMarkers({intersectsRange: range})\r\n      .filter(marker => marker.parentLanguageLayer === this)\r\n\r\n    if (existingInjectionMarkers.length > 0) {\r\n      range = range.union(new Range(\r\n        existingInjectionMarkers[0].getRange().start,\r\n        last(existingInjectionMarkers).getRange().end\r\n      ))\r\n    }\r\n\r\n    const markersToUpdate = new Map()\r\n    const nodes = this.tree.rootNode.descendantsOfType(\r\n      Object.keys(this.grammar.injectionPointsByType),\r\n      range.start,\r\n      range.end\r\n    )\r\n\r\n    let existingInjectionMarkerIndex = 0\r\n    for (const node of nodes) {\r\n      for (const injectionPoint of this.grammar.injectionPointsByType[node.type]) {\r\n        const languageName = injectionPoint.language(node)\r\n        if (!languageName) continue\r\n\r\n        const grammar = this.languageMode.grammarForLanguageString(languageName)\r\n        if (!grammar) continue\r\n\r\n        const contentNodes = injectionPoint.content(node)\r\n        if (!contentNodes) continue\r\n\r\n        const injectionNodes = [].concat(contentNodes)\r\n        if (!injectionNodes.length) continue\r\n\r\n        const injectionRange = rangeForNode(node)\r\n\r\n        let marker\r\n        for (let i = existingInjectionMarkerIndex, n = existingInjectionMarkers.length; i < n; i++) {\r\n          const existingMarker = existingInjectionMarkers[i]\r\n          const comparison = existingMarker.getRange().compare(injectionRange)\r\n          if (comparison > 0) {\r\n            break\r\n          } else if (comparison === 0) {\r\n            existingInjectionMarkerIndex = i\r\n            if (existingMarker.languageLayer.grammar === grammar) {\r\n              marker = existingMarker\r\n              marker.id === node.id\r\n              break\r\n            }\r\n          } else {\r\n            existingInjectionMarkerIndex = i\r\n          }\r\n        }\r\n\r\n        if (!marker) {\r\n          marker = this.languageMode.injectionsMarkerLayer.markRange(injectionRange)\r\n          marker.languageLayer = new LanguageLayer(this.languageMode, grammar, injectionPoint.contentChildTypes)\r\n          marker.parentLanguageLayer = this\r\n        }\r\n\r\n        markersToUpdate.set(marker, new NodeRangeSet(nodeRangeSet, injectionNodes))\r\n      }\r\n    }\r\n\r\n    for (const marker of existingInjectionMarkers) {\r\n      if (!markersToUpdate.has(marker)) {\r\n        marker.languageLayer.destroy()\r\n        this.languageMode.emitRangeUpdate(marker.getRange())\r\n        marker.destroy()\r\n      }\r\n    }\r\n\r\n    if (markersToUpdate.size > 0) {\r\n      this.lastUpdateWasAsync = true\r\n      const promises = []\r\n      for (const [marker, nodeRangeSet] of markersToUpdate) {\r\n        promises.push(marker.languageLayer.update(nodeRangeSet))\r\n      }\r\n      return Promise.all(promises)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"NodeRangeSet.constructor","start_line":1104,"end_line":1107,"comment":[],"params":["previous","nodes"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"resetScopedSettings","line":952,"func_location":"Config._resetSettings","func_start_line":940,"func_end_line":967,"args":["scopedSettings",null],"code":"  _resetSettings (newSettings, options = {}) {\r\n    const source = options.source\r\n    newSettings = Object.assign({}, newSettings)\r\n    if (newSettings.global != null) {\r\n      newSettings['*'] = newSettings.global\r\n      delete newSettings.global\r\n    }\r\n\r\n    if (newSettings['*'] != null) {\r\n      const scopedSettings = newSettings\r\n      newSettings = newSettings['*']\r\n      delete scopedSettings['*']\r\n      this.resetScopedSettings(scopedSettings, {source})\r\n    }\r\n\r\n    return this.transact(() => {\r\n      this._clearUnscopedSettingsForSource(source)\r\n      this.settingsLoaded = true\r\n      for (let key in newSettings) {\r\n        const value = newSettings[key]\r\n        this.set(key, value, {save: false, source})\r\n      }\r\n      if (this.pendingOperations.length) {\r\n        for (let op of this.pendingOperations) { op() }\r\n        this.pendingOperations = []\r\n      }\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.resetScopedSettings","start_line":1215,"end_line":1229,"comment":[],"params":["newScopedSettings","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"transact","line":955,"func_location":"Config._resetSettings","func_start_line":940,"func_end_line":967},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.transact","start_line":816,"end_line":823,"comment":[" Extended: Suppress calls to handler functions registered with {::onDidChange}"," and {::observe} for the duration of `callback`. After `callback` executes,"," handlers will be called once if the value for their key-path has changed.",""," * `callback` {Function} to execute while suppressing calls to handlers."],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js","name":"resolveModulePath","line":279,"func_location":"Module._resolveFilename","func_start_line":278,"func_end_line":284,"args":["relativePath","parentModule"],"code":"  Module._resolveFilename = function (relativePath, parentModule) {\r\n    let resolvedPath = resolveModulePath(relativePath, parentModule)\r\n    if (!resolvedPath) {\r\n      resolvedPath = resolveFilePath(relativePath, parentModule)\r\n    }\r\n    return resolvedPath || originalResolveFilename(relativePath, parentModule)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js","name":"resolveModulePath","start_line":197,"end_line":227,"comment":[],"params":["relativePath","parentModule"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js","name":"resolveFilePath","line":281,"func_location":"Module._resolveFilename","func_start_line":278,"func_end_line":284,"args":["relativePath","parentModule"],"code":"  Module._resolveFilename = function (relativePath, parentModule) {\r\n    let resolvedPath = resolveModulePath(relativePath, parentModule)\r\n    if (!resolvedPath) {\r\n      resolvedPath = resolveFilePath(relativePath, parentModule)\r\n    }\r\n    return resolvedPath || originalResolveFilename(relativePath, parentModule)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js","name":"resolveFilePath","start_line":175,"end_line":195,"comment":[],"params":["relativePath","parentModule"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"increaseIndentRegexForScopeDescriptor","line":152,"func_location":"TextMateLanguageMode._suggestedIndentForLineWithScopeAtBufferRow","func_start_line":151,"func_end_line":179,"args":["scopeDescriptor"],"code":"  _suggestedIndentForLineWithScopeAtBufferRow (bufferRow, line, scopeDescriptor, tabLength, options) {\r\n    const increaseIndentRegex = this.increaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    const decreaseIndentRegex = this.decreaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    const decreaseNextIndentRegex = this.decreaseNextIndentRegexForScopeDescriptor(scopeDescriptor)\r\n\r\n    let precedingRow\r\n    if (!options || options.skipBlankLines !== false) {\r\n      precedingRow = this.buffer.previousNonBlankRow(bufferRow)\r\n      if (precedingRow == null) return 0\r\n    } else {\r\n      precedingRow = bufferRow - 1\r\n      if (precedingRow < 0) return 0\r\n    }\r\n\r\n    const precedingLine = this.buffer.lineForRow(precedingRow)\r\n    let desiredIndentLevel = this.indentLevelForLine(precedingLine, tabLength)\r\n    if (!increaseIndentRegex) return desiredIndentLevel\r\n\r\n    if (!this.isRowCommented(precedingRow)) {\r\n      if (increaseIndentRegex && increaseIndentRegex.testSync(precedingLine)) desiredIndentLevel += 1\r\n      if (decreaseNextIndentRegex && decreaseNextIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    if (!this.buffer.isRowBlank(precedingRow)) {\r\n      if (decreaseIndentRegex && decreaseIndentRegex.testSync(line)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    return Math.max(desiredIndentLevel, 0)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.increaseIndentRegexForScopeDescriptor","start_line":697,"end_line":699,"comment":[],"params":["scope"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"decreaseIndentRegexForScopeDescriptor","line":153,"func_location":"TextMateLanguageMode._suggestedIndentForLineWithScopeAtBufferRow","func_start_line":151,"func_end_line":179,"args":["scopeDescriptor"],"code":"  _suggestedIndentForLineWithScopeAtBufferRow (bufferRow, line, scopeDescriptor, tabLength, options) {\r\n    const increaseIndentRegex = this.increaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    const decreaseIndentRegex = this.decreaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    const decreaseNextIndentRegex = this.decreaseNextIndentRegexForScopeDescriptor(scopeDescriptor)\r\n\r\n    let precedingRow\r\n    if (!options || options.skipBlankLines !== false) {\r\n      precedingRow = this.buffer.previousNonBlankRow(bufferRow)\r\n      if (precedingRow == null) return 0\r\n    } else {\r\n      precedingRow = bufferRow - 1\r\n      if (precedingRow < 0) return 0\r\n    }\r\n\r\n    const precedingLine = this.buffer.lineForRow(precedingRow)\r\n    let desiredIndentLevel = this.indentLevelForLine(precedingLine, tabLength)\r\n    if (!increaseIndentRegex) return desiredIndentLevel\r\n\r\n    if (!this.isRowCommented(precedingRow)) {\r\n      if (increaseIndentRegex && increaseIndentRegex.testSync(precedingLine)) desiredIndentLevel += 1\r\n      if (decreaseNextIndentRegex && decreaseNextIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    if (!this.buffer.isRowBlank(precedingRow)) {\r\n      if (decreaseIndentRegex && decreaseIndentRegex.testSync(line)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    return Math.max(desiredIndentLevel, 0)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.decreaseIndentRegexForScopeDescriptor","start_line":701,"end_line":703,"comment":[],"params":["scope"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"decreaseNextIndentRegexForScopeDescriptor","line":154,"func_location":"TextMateLanguageMode._suggestedIndentForLineWithScopeAtBufferRow","func_start_line":151,"func_end_line":179,"args":["scopeDescriptor"],"code":"  _suggestedIndentForLineWithScopeAtBufferRow (bufferRow, line, scopeDescriptor, tabLength, options) {\r\n    const increaseIndentRegex = this.increaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    const decreaseIndentRegex = this.decreaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    const decreaseNextIndentRegex = this.decreaseNextIndentRegexForScopeDescriptor(scopeDescriptor)\r\n\r\n    let precedingRow\r\n    if (!options || options.skipBlankLines !== false) {\r\n      precedingRow = this.buffer.previousNonBlankRow(bufferRow)\r\n      if (precedingRow == null) return 0\r\n    } else {\r\n      precedingRow = bufferRow - 1\r\n      if (precedingRow < 0) return 0\r\n    }\r\n\r\n    const precedingLine = this.buffer.lineForRow(precedingRow)\r\n    let desiredIndentLevel = this.indentLevelForLine(precedingLine, tabLength)\r\n    if (!increaseIndentRegex) return desiredIndentLevel\r\n\r\n    if (!this.isRowCommented(precedingRow)) {\r\n      if (increaseIndentRegex && increaseIndentRegex.testSync(precedingLine)) desiredIndentLevel += 1\r\n      if (decreaseNextIndentRegex && decreaseNextIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    if (!this.buffer.isRowBlank(precedingRow)) {\r\n      if (decreaseIndentRegex && decreaseIndentRegex.testSync(line)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    return Math.max(desiredIndentLevel, 0)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.decreaseNextIndentRegexForScopeDescriptor","start_line":705,"end_line":707,"comment":[],"params":["scope"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"indentLevelForLine","line":166,"func_location":"TextMateLanguageMode._suggestedIndentForLineWithScopeAtBufferRow","func_start_line":151,"func_end_line":179,"args":["precedingLine","tabLength"],"code":"  _suggestedIndentForLineWithScopeAtBufferRow (bufferRow, line, scopeDescriptor, tabLength, options) {\r\n    const increaseIndentRegex = this.increaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    const decreaseIndentRegex = this.decreaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    const decreaseNextIndentRegex = this.decreaseNextIndentRegexForScopeDescriptor(scopeDescriptor)\r\n\r\n    let precedingRow\r\n    if (!options || options.skipBlankLines !== false) {\r\n      precedingRow = this.buffer.previousNonBlankRow(bufferRow)\r\n      if (precedingRow == null) return 0\r\n    } else {\r\n      precedingRow = bufferRow - 1\r\n      if (precedingRow < 0) return 0\r\n    }\r\n\r\n    const precedingLine = this.buffer.lineForRow(precedingRow)\r\n    let desiredIndentLevel = this.indentLevelForLine(precedingLine, tabLength)\r\n    if (!increaseIndentRegex) return desiredIndentLevel\r\n\r\n    if (!this.isRowCommented(precedingRow)) {\r\n      if (increaseIndentRegex && increaseIndentRegex.testSync(precedingLine)) desiredIndentLevel += 1\r\n      if (decreaseNextIndentRegex && decreaseNextIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    if (!this.buffer.isRowBlank(precedingRow)) {\r\n      if (decreaseIndentRegex && decreaseIndentRegex.testSync(line)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    return Math.max(desiredIndentLevel, 0)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.indentLevelForLine","start_line":492,"end_line":505,"comment":[],"params":["line","tabLength"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"isRowCommented","line":169,"func_location":"TextMateLanguageMode._suggestedIndentForLineWithScopeAtBufferRow","func_start_line":151,"func_end_line":179,"args":["precedingRow"],"code":"  _suggestedIndentForLineWithScopeAtBufferRow (bufferRow, line, scopeDescriptor, tabLength, options) {\r\n    const increaseIndentRegex = this.increaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    const decreaseIndentRegex = this.decreaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    const decreaseNextIndentRegex = this.decreaseNextIndentRegexForScopeDescriptor(scopeDescriptor)\r\n\r\n    let precedingRow\r\n    if (!options || options.skipBlankLines !== false) {\r\n      precedingRow = this.buffer.previousNonBlankRow(bufferRow)\r\n      if (precedingRow == null) return 0\r\n    } else {\r\n      precedingRow = bufferRow - 1\r\n      if (precedingRow < 0) return 0\r\n    }\r\n\r\n    const precedingLine = this.buffer.lineForRow(precedingRow)\r\n    let desiredIndentLevel = this.indentLevelForLine(precedingLine, tabLength)\r\n    if (!increaseIndentRegex) return desiredIndentLevel\r\n\r\n    if (!this.isRowCommented(precedingRow)) {\r\n      if (increaseIndentRegex && increaseIndentRegex.testSync(precedingLine)) desiredIndentLevel += 1\r\n      if (decreaseNextIndentRegex && decreaseNextIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    if (!this.buffer.isRowBlank(precedingRow)) {\r\n      if (decreaseIndentRegex && decreaseIndentRegex.testSync(line)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    return Math.max(desiredIndentLevel, 0)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.isRowCommented","start_line":600,"end_line":602,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js","name":"getActivePane","line":35,"func_location":"WorkspaceCenter.activate","func_start_line":34,"func_end_line":36,"args":[],"code":"  activate () {\r\n    this.getActivePane().activate()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js","name":"WorkspaceCenter.getActivePane","start_line":306,"end_line":308,"comment":[" Extended: Get the active {Pane}.",""," Returns a {Pane}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"loadGrammars","line":190,"func_location":"Package.activate","func_start_line":189,"func_end_line":210,"args":[],"code":"  activate () {\r\n    if (!this.grammarsPromise) this.grammarsPromise = this.loadGrammars()\r\n    if (!this.activationPromise) {\r\n      this.activationPromise = new Promise((resolve, reject) => {\r\n        this.resolveActivationPromise = resolve\r\n        this.measure('activateTime', () => {\r\n          try {\r\n            this.activateResources()\r\n            if (this.activationShouldBeDeferred()) {\r\n              return this.subscribeToDeferredActivation()\r\n            } else {\r\n              return this.activateNow()\r\n            }\r\n          } catch (error) {\r\n            return this.handleError(`Failed to activate the ${this.name} package`, error)\r\n          }\r\n        })\r\n      })\r\n    }\r\n\r\n    return Promise.all([this.grammarsPromise, this.settingsPromise, this.activationPromise])\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.loadGrammars","start_line":594,"end_line":632,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"getLoadedPackagesForTypes","line":659,"func_location":"PackageManager.activate","func_start_line":656,"func_end_line":667,"args":["types"],"comment":[" Activate all the packages that should be activated."],"code":"  activate () {\r\n    let promises = []\r\n    for (let [activator, types] of this.packageActivators) {\r\n      const packages = this.getLoadedPackagesForTypes(types)\r\n      promises = promises.concat(activator.activatePackages(packages))\r\n    }\r\n    return Promise.all(promises).then(() => {\r\n      this.triggerDeferredActivationHooks()\r\n      this.initialPackagesActivated = true\r\n      this.emitter.emit('did-activate-initial-packages')\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.getLoadedPackagesForTypes","start_line":330,"end_line":332,"comment":[" Get packages for a certain package type",""," * `types` an {Array} of {String}s like ['atom', 'textmate']."],"params":["types"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"getActivePane","line":115,"func_location":"Dock.activate","func_start_line":114,"func_end_line":116,"args":[],"comment":[" Extended: Show the dock and focus its active {Pane}."],"code":"  activate () {\r\n    this.getActivePane().activate()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.getActivePane","start_line":687,"end_line":689,"comment":[" Extended: Get the active {Pane}.",""," Returns a {Pane}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"isDestroyed","line":1013,"func_location":"Pane.activate","func_start_line":1012,"func_end_line":1016,"args":[],"comment":[" Public: Makes this pane the *active* pane, causing it to gain focus."],"code":"  activate () {\r\n    if (this.isDestroyed()) throw new Error('Pane has been destroyed')\r\n    if (this.container) this.container.didActivatePane(this)\r\n    this.emitter.emit('did-activate')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.isDestroyed","start_line":1046,"end_line":1046,"comment":[" Public: Determine whether this pane has been destroyed.",""," Returns a {Boolean}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"requireMainModule","line":261,"func_location":"Package.activateConfig","func_start_line":259,"func_end_line":263,"args":[],"comment":[" TODO: Remove. Settings view calls this method currently."],"code":"  activateConfig () {\r\n    if (this.configSchemaRegisteredOnLoad) return\r\n    this.requireMainModule()\r\n    this.registerConfigSchemaFromMainModule()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.requireMainModule","start_line":755,"end_line":784,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"registerConfigSchemaFromMainModule","line":262,"func_location":"Package.activateConfig","func_start_line":259,"func_end_line":263,"args":[],"comment":[" TODO: Remove. Settings view calls this method currently."],"code":"  activateConfig () {\r\n    if (this.configSchemaRegisteredOnLoad) return\r\n    this.requireMainModule()\r\n    this.registerConfigSchemaFromMainModule()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.registerConfigSchemaFromMainModule","start_line":248,"end_line":256,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"requireMainModule","line":514,"func_location":"Package.activateCoreStartupServices","func_start_line":509,"func_end_line":524,"args":[],"code":"  activateCoreStartupServices () {\r\n    const directoryProviderService =\r\n      this.metadata.providedServices &&\r\n      this.metadata.providedServices['atom.directory-provider']\r\n    if (directoryProviderService) {\r\n      this.requireMainModule()\r\n      const servicesByVersion = {}\r\n      for (let version in directoryProviderService.versions) {\r\n        const methodName = directoryProviderService.versions[version]\r\n        if (typeof this.mainModule[methodName] === 'function') {\r\n          servicesByVersion[version] = this.mainModule[methodName]()\r\n        }\r\n      }\r\n      this.packageManager.serviceHub.provide('atom.directory-provider', servicesByVersion)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.requireMainModule","start_line":755,"end_line":784,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js","name":"hasFocus","line":113,"func_location":"PaneElement.activated","func_start_line":111,"func_end_line":118,"args":[],"code":"  activated () {\r\n    this.isActivating = true\r\n    if (!this.hasFocus()) {\r\n      // Don't steal focus from children.\r\n      this.focus()\r\n    }\r\n    this.isActivating = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js","name":"PaneElement.hasFocus","start_line":209,"end_line":213,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getPendingItem","line":575,"func_location":"Pane.activateItem","func_start_line":573,"func_end_line":581,"args":[],"comment":[" Public: Make the given item *active*, causing it to be displayed by"," the pane's view.",""," * `item` The item to activate"," * `options` (optional) {Object}","   * `pending` (optional) {Boolean} indicating that the item should be added","     in a pending state if it does not yet exist in the pane. Existing pending","     items in a pane are replaced with new pending items when they are opened."],"code":"  activateItem (item, options = {}) {\r\n    if (item) {\r\n      const index = (this.getPendingItem() === this.activeItem)\r\n        ? this.getActiveItemIndex()\r\n        : this.getActiveItemIndex() + 1\r\n      this.addItem(item, Object.assign({}, options, {index}))\r\n      this.setActiveItem(item)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getPendingItem","start_line":654,"end_line":656,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getActiveItemIndex","line":576,"func_location":"Pane.activateItem","func_start_line":573,"func_end_line":581,"args":[],"comment":[" Public: Make the given item *active*, causing it to be displayed by"," the pane's view.",""," * `item` The item to activate"," * `options` (optional) {Object}","   * `pending` (optional) {Boolean} indicating that the item should be added","     in a pending state if it does not yet exist in the pane. Existing pending","     items in a pane are replaced with new pending items when they are opened."],"code":"  activateItem (item, options = {}) {\r\n    if (item) {\r\n      const index = (this.getPendingItem() === this.activeItem)\r\n        ? this.getActiveItemIndex()\r\n        : this.getActiveItemIndex() + 1\r\n      this.addItem(item, Object.assign({}, options, {index}))\r\n      this.setActiveItem(item)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getActiveItemIndex","start_line":553,"end_line":555,"comment":[" Public: Get the index of the active item.",""," Returns a {Number}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getActiveItemIndex","line":577,"func_location":"Pane.activateItem","func_start_line":573,"func_end_line":581,"args":[],"comment":[" Public: Make the given item *active*, causing it to be displayed by"," the pane's view.",""," * `item` The item to activate"," * `options` (optional) {Object}","   * `pending` (optional) {Boolean} indicating that the item should be added","     in a pending state if it does not yet exist in the pane. Existing pending","     items in a pane are replaced with new pending items when they are opened."],"code":"  activateItem (item, options = {}) {\r\n    if (item) {\r\n      const index = (this.getPendingItem() === this.activeItem)\r\n        ? this.getActiveItemIndex()\r\n        : this.getActiveItemIndex() + 1\r\n      this.addItem(item, Object.assign({}, options, {index}))\r\n      this.setActiveItem(item)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getActiveItemIndex","start_line":553,"end_line":555,"comment":[" Public: Get the index of the active item.",""," Returns a {Number}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"addItem","line":578,"func_location":"Pane.activateItem","func_start_line":573,"func_end_line":581,"args":["item",null],"comment":[" Public: Make the given item *active*, causing it to be displayed by"," the pane's view.",""," * `item` The item to activate"," * `options` (optional) {Object}","   * `pending` (optional) {Boolean} indicating that the item should be added","     in a pending state if it does not yet exist in the pane. Existing pending","     items in a pane are replaced with new pending items when they are opened."],"code":"  activateItem (item, options = {}) {\r\n    if (item) {\r\n      const index = (this.getPendingItem() === this.activeItem)\r\n        ? this.getActiveItemIndex()\r\n        : this.getActiveItemIndex() + 1\r\n      this.addItem(item, Object.assign({}, options, {index}))\r\n      this.setActiveItem(item)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.addItem","start_line":595,"end_line":642,"comment":[" Public: Add the given item to the pane.",""," * `item` The item to add. It can be a model with an associated view or a","   view."," * `options` (optional) {Object}","   * `index` (optional) {Number} indicating the index at which to add the item.","     If omitted, the item is added after the current active item.","   * `pending` (optional) {Boolean} indicating that the item should be","     added in a pending state. Existing pending items in a pane are replaced with","     new pending items when they are opened.",""," Returns the added item."],"params":["item","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"setActiveItem","line":579,"func_location":"Pane.activateItem","func_start_line":573,"func_end_line":581,"args":["item"],"comment":[" Public: Make the given item *active*, causing it to be displayed by"," the pane's view.",""," * `item` The item to activate"," * `options` (optional) {Object}","   * `pending` (optional) {Boolean} indicating that the item should be added","     in a pending state if it does not yet exist in the pane. Existing pending","     items in a pane are replaced with new pending items when they are opened."],"code":"  activateItem (item, options = {}) {\r\n    if (item) {\r\n      const index = (this.getPendingItem() === this.activeItem)\r\n        ? this.getActiveItemIndex()\r\n        : this.getActiveItemIndex() + 1\r\n      this.addItem(item, Object.assign({}, options, {index}))\r\n      this.setActiveItem(item)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.setActiveItem","start_line":434,"end_line":443,"comment":[],"params":["activeItem","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"itemAtIndex","line":561,"func_location":"Pane.activateItemAtIndex","func_start_line":560,"func_end_line":563,"args":["index"],"comment":[" Public: Activate the item at the given index.",""," * `index` {Number}"],"code":"  activateItemAtIndex (index) {\r\n    const item = this.itemAtIndex(index) || this.getActiveItem()\r\n    return this.setActiveItem(item)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.itemAtIndex","start_line":476,"end_line":478,"comment":[" Public: Return the item at the given index.",""," * `index` {Number}",""," Returns an item or `null` if no item exists at the given index."],"params":["index"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getActiveItem","line":561,"func_location":"Pane.activateItemAtIndex","func_start_line":560,"func_end_line":563,"args":["index"],"comment":[" Public: Activate the item at the given index.",""," * `index` {Number}"],"code":"  activateItemAtIndex (index) {\r\n    const item = this.itemAtIndex(index) || this.getActiveItem()\r\n    return this.setActiveItem(item)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getActiveItem","start_line":432,"end_line":432,"comment":[" Public: Get the active pane item in this pane.",""," Returns a pane item."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"setActiveItem","line":562,"func_location":"Pane.activateItemAtIndex","func_start_line":560,"func_end_line":563,"args":["item"],"comment":[" Public: Activate the item at the given index.",""," * `index` {Number}"],"code":"  activateItemAtIndex (index) {\r\n    const item = this.itemAtIndex(index) || this.getActiveItem()\r\n    return this.setActiveItem(item)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.setActiveItem","start_line":434,"end_line":443,"comment":[],"params":["activeItem","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"itemForURI","line":985,"func_location":"Pane.activateItemForURI","func_start_line":984,"func_end_line":992,"args":["uri"],"comment":[" Public: Activate the first item that matches the given URI.",""," * `uri` {String} containing a URI.",""," Returns a {Boolean} indicating whether an item matching the URI was found."],"code":"  activateItemForURI (uri) {\r\n    const item = this.itemForURI(uri)\r\n    if (item) {\r\n      this.activateItem(item)\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.itemForURI","start_line":969,"end_line":977,"comment":[" Public: Return the first item that matches the given URI or undefined if"," none exists.",""," * `uri` {String} containing a URI."],"params":["uri"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"activateItem","line":987,"func_location":"Pane.activateItemForURI","func_start_line":984,"func_end_line":992,"args":["item"],"comment":[" Public: Activate the first item that matches the given URI.",""," * `uri` {String} containing a URI.",""," Returns a {Boolean} indicating whether an item matching the URI was found."],"code":"  activateItemForURI (uri) {\r\n    const item = this.itemForURI(uri)\r\n    if (item) {\r\n      this.activateItem(item)\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.activateItem","start_line":573,"end_line":581,"comment":[" Public: Make the given item *active*, causing it to be displayed by"," the pane's view.",""," * `item` The item to activate"," * `options` (optional) {Object}","   * `pending` (optional) {Boolean} indicating that the item should be added","     in a pending state if it does not yet exist in the pane. Existing pending","     items in a pane are replaced with new pending items when they are opened."],"params":["item","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"activateItemAtIndex","line":533,"func_location":"Pane.activateLastItem","func_start_line":532,"func_end_line":534,"args":[null],"code":"  activateLastItem () {\r\n    this.activateItemAtIndex(this.items.length - 1)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.activateItemAtIndex","start_line":560,"end_line":563,"comment":[" Public: Activate the item at the given index.",""," * `index` {Number}"],"params":["index"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getActiveItemIndex","line":514,"func_location":"Pane.activateNextItem","func_start_line":513,"func_end_line":520,"args":[],"comment":[" Public: Makes the next item active."],"code":"  activateNextItem () {\r\n    const index = this.getActiveItemIndex()\r\n    if (index < (this.items.length - 1)) {\r\n      this.activateItemAtIndex(index + 1)\r\n    } else {\r\n      this.activateItemAtIndex(0)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getActiveItemIndex","start_line":553,"end_line":555,"comment":[" Public: Get the index of the active item.",""," Returns a {Number}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"activateItemAtIndex","line":516,"func_location":"Pane.activateNextItem","func_start_line":513,"func_end_line":520,"args":[null],"comment":[" Public: Makes the next item active."],"code":"  activateNextItem () {\r\n    const index = this.getActiveItemIndex()\r\n    if (index < (this.items.length - 1)) {\r\n      this.activateItemAtIndex(index + 1)\r\n    } else {\r\n      this.activateItemAtIndex(0)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.activateItemAtIndex","start_line":560,"end_line":563,"comment":[" Public: Activate the item at the given index.",""," * `index` {Number}"],"params":["index"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"activateItemAtIndex","line":518,"func_location":"Pane.activateNextItem","func_start_line":513,"func_end_line":520,"args":[{"type":"number"}],"comment":[" Public: Makes the next item active."],"code":"  activateNextItem () {\r\n    const index = this.getActiveItemIndex()\r\n    if (index < (this.items.length - 1)) {\r\n      this.activateItemAtIndex(index + 1)\r\n    } else {\r\n      this.activateItemAtIndex(0)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.activateItemAtIndex","start_line":560,"end_line":563,"comment":[" Public: Activate the item at the given index.",""," * `index` {Number}"],"params":["index"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"getPanes","line":189,"func_location":"PaneContainer.activateNextPane","func_start_line":188,"func_end_line":198,"args":[],"code":"  activateNextPane () {\r\n    const panes = this.getPanes()\r\n    if (panes.length > 1) {\r\n      const currentIndex = panes.indexOf(this.activePane)\r\n      const nextIndex = (currentIndex + 1) % panes.length\r\n      panes[nextIndex].activate()\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.getPanes","start_line":146,"end_line":152,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getActivePaneContainer","line":1448,"func_location":"Workspace.activateNextPane","func_start_line":1447,"func_end_line":1449,"args":[],"comment":[" Extended: Make the next pane active."],"code":"  activateNextPane () {\r\n    return this.getActivePaneContainer().activateNextPane()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getActivePaneContainer","start_line":1424,"end_line":1426,"comment":["\r\n  Section: Panes\r\n  "," Extended: Get the most recently focused pane container.",""," Returns a {Dock} or the {WorkspaceCenter}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"setActiveItem","line":488,"func_location":"Pane.activateNextRecentlyUsedItem","func_start_line":481,"func_end_line":490,"args":["nextRecentlyUsedItem",null],"comment":[" Makes the next item in the itemStack active."],"code":"  activateNextRecentlyUsedItem () {\r\n    if (this.items.length > 1) {\r\n      if (this.itemStackIndex == null) this.itemStackIndex = this.itemStack.length - 1\r\n      if (this.itemStackIndex === 0) this.itemStackIndex = this.itemStack.length\r\n      this.itemStackIndex--\r\n      const nextRecentlyUsedItem = this.itemStack[this.itemStackIndex]\r\n      this.emitter.emit('choose-next-mru-item', nextRecentlyUsedItem)\r\n      this.setActiveItem(nextRecentlyUsedItem, {modifyStack: false})\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.setActiveItem","start_line":434,"end_line":443,"comment":[],"params":["activeItem","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"requireMainModule","line":214,"func_location":"Package.activateNow","func_start_line":212,"func_end_line":236,"args":[],"code":"  activateNow () {\r\n    try {\r\n      if (!this.mainModule) this.requireMainModule()\r\n      this.configSchemaRegisteredOnActivate = this.registerConfigSchemaFromMainModule()\r\n      this.registerViewProviders()\r\n      this.activateStylesheets()\r\n      if (this.mainModule && !this.mainActivated) {\r\n        this.initializeIfNeeded()\r\n        if (typeof this.mainModule.activateConfig === 'function') {\r\n          this.mainModule.activateConfig()\r\n        }\r\n        if (typeof this.mainModule.activate === 'function') {\r\n          this.mainModule.activate(this.packageManager.getPackageState(this.name) || {})\r\n        }\r\n        this.mainActivated = true\r\n        this.activateServices()\r\n      }\r\n      if (this.activationCommandSubscriptions) this.activationCommandSubscriptions.dispose()\r\n      if (this.activationHookSubscriptions) this.activationHookSubscriptions.dispose()\r\n    } catch (error) {\r\n      this.handleError(`Failed to activate the ${this.name} package`, error)\r\n    }\r\n\r\n    if (typeof this.resolveActivationPromise === 'function') this.resolveActivationPromise()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.requireMainModule","start_line":755,"end_line":784,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"registerConfigSchemaFromMainModule","line":215,"func_location":"Package.activateNow","func_start_line":212,"func_end_line":236,"args":[],"code":"  activateNow () {\r\n    try {\r\n      if (!this.mainModule) this.requireMainModule()\r\n      this.configSchemaRegisteredOnActivate = this.registerConfigSchemaFromMainModule()\r\n      this.registerViewProviders()\r\n      this.activateStylesheets()\r\n      if (this.mainModule && !this.mainActivated) {\r\n        this.initializeIfNeeded()\r\n        if (typeof this.mainModule.activateConfig === 'function') {\r\n          this.mainModule.activateConfig()\r\n        }\r\n        if (typeof this.mainModule.activate === 'function') {\r\n          this.mainModule.activate(this.packageManager.getPackageState(this.name) || {})\r\n        }\r\n        this.mainActivated = true\r\n        this.activateServices()\r\n      }\r\n      if (this.activationCommandSubscriptions) this.activationCommandSubscriptions.dispose()\r\n      if (this.activationHookSubscriptions) this.activationHookSubscriptions.dispose()\r\n    } catch (error) {\r\n      this.handleError(`Failed to activate the ${this.name} package`, error)\r\n    }\r\n\r\n    if (typeof this.resolveActivationPromise === 'function') this.resolveActivationPromise()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.registerConfigSchemaFromMainModule","start_line":248,"end_line":256,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"registerViewProviders","line":216,"func_location":"Package.activateNow","func_start_line":212,"func_end_line":236,"args":[],"code":"  activateNow () {\r\n    try {\r\n      if (!this.mainModule) this.requireMainModule()\r\n      this.configSchemaRegisteredOnActivate = this.registerConfigSchemaFromMainModule()\r\n      this.registerViewProviders()\r\n      this.activateStylesheets()\r\n      if (this.mainModule && !this.mainActivated) {\r\n        this.initializeIfNeeded()\r\n        if (typeof this.mainModule.activateConfig === 'function') {\r\n          this.mainModule.activateConfig()\r\n        }\r\n        if (typeof this.mainModule.activate === 'function') {\r\n          this.mainModule.activate(this.packageManager.getPackageState(this.name) || {})\r\n        }\r\n        this.mainActivated = true\r\n        this.activateServices()\r\n      }\r\n      if (this.activationCommandSubscriptions) this.activationCommandSubscriptions.dispose()\r\n      if (this.activationHookSubscriptions) this.activationHookSubscriptions.dispose()\r\n    } catch (error) {\r\n      this.handleError(`Failed to activate the ${this.name} package`, error)\r\n    }\r\n\r\n    if (typeof this.resolveActivationPromise === 'function') this.resolveActivationPromise()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.registerViewProviders","start_line":526,"end_line":537,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"activateStylesheets","line":217,"func_location":"Package.activateNow","func_start_line":212,"func_end_line":236,"args":[],"code":"  activateNow () {\r\n    try {\r\n      if (!this.mainModule) this.requireMainModule()\r\n      this.configSchemaRegisteredOnActivate = this.registerConfigSchemaFromMainModule()\r\n      this.registerViewProviders()\r\n      this.activateStylesheets()\r\n      if (this.mainModule && !this.mainActivated) {\r\n        this.initializeIfNeeded()\r\n        if (typeof this.mainModule.activateConfig === 'function') {\r\n          this.mainModule.activateConfig()\r\n        }\r\n        if (typeof this.mainModule.activate === 'function') {\r\n          this.mainModule.activate(this.packageManager.getPackageState(this.name) || {})\r\n        }\r\n        this.mainActivated = true\r\n        this.activateServices()\r\n      }\r\n      if (this.activationCommandSubscriptions) this.activationCommandSubscriptions.dispose()\r\n      if (this.activationHookSubscriptions) this.activationHookSubscriptions.dispose()\r\n    } catch (error) {\r\n      this.handleError(`Failed to activate the ${this.name} package`, error)\r\n    }\r\n\r\n    if (typeof this.resolveActivationPromise === 'function') this.resolveActivationPromise()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.activateStylesheets","start_line":265,"end_line":295,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"initializeIfNeeded","line":219,"func_location":"Package.activateNow","func_start_line":212,"func_end_line":236,"args":[],"code":"  activateNow () {\r\n    try {\r\n      if (!this.mainModule) this.requireMainModule()\r\n      this.configSchemaRegisteredOnActivate = this.registerConfigSchemaFromMainModule()\r\n      this.registerViewProviders()\r\n      this.activateStylesheets()\r\n      if (this.mainModule && !this.mainActivated) {\r\n        this.initializeIfNeeded()\r\n        if (typeof this.mainModule.activateConfig === 'function') {\r\n          this.mainModule.activateConfig()\r\n        }\r\n        if (typeof this.mainModule.activate === 'function') {\r\n          this.mainModule.activate(this.packageManager.getPackageState(this.name) || {})\r\n        }\r\n        this.mainActivated = true\r\n        this.activateServices()\r\n      }\r\n      if (this.activationCommandSubscriptions) this.activationCommandSubscriptions.dispose()\r\n      if (this.activationHookSubscriptions) this.activationHookSubscriptions.dispose()\r\n    } catch (error) {\r\n      this.handleError(`Failed to activate the ${this.name} package`, error)\r\n    }\r\n\r\n    if (typeof this.resolveActivationPromise === 'function') this.resolveActivationPromise()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.initializeIfNeeded","start_line":170,"end_line":187,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"activateServices","line":227,"func_location":"Package.activateNow","func_start_line":212,"func_end_line":236,"args":[],"code":"  activateNow () {\r\n    try {\r\n      if (!this.mainModule) this.requireMainModule()\r\n      this.configSchemaRegisteredOnActivate = this.registerConfigSchemaFromMainModule()\r\n      this.registerViewProviders()\r\n      this.activateStylesheets()\r\n      if (this.mainModule && !this.mainActivated) {\r\n        this.initializeIfNeeded()\r\n        if (typeof this.mainModule.activateConfig === 'function') {\r\n          this.mainModule.activateConfig()\r\n        }\r\n        if (typeof this.mainModule.activate === 'function') {\r\n          this.mainModule.activate(this.packageManager.getPackageState(this.name) || {})\r\n        }\r\n        this.mainActivated = true\r\n        this.activateServices()\r\n      }\r\n      if (this.activationCommandSubscriptions) this.activationCommandSubscriptions.dispose()\r\n      if (this.activationHookSubscriptions) this.activationHookSubscriptions.dispose()\r\n    } catch (error) {\r\n      this.handleError(`Failed to activate the ${this.name} package`, error)\r\n    }\r\n\r\n    if (typeof this.resolveActivationPromise === 'function') this.resolveActivationPromise()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.activateServices","start_line":380,"end_line":403,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"handleError","line":232,"func_location":"Package.activateNow","func_start_line":212,"func_end_line":236,"args":[null,"error"],"code":"  activateNow () {\r\n    try {\r\n      if (!this.mainModule) this.requireMainModule()\r\n      this.configSchemaRegisteredOnActivate = this.registerConfigSchemaFromMainModule()\r\n      this.registerViewProviders()\r\n      this.activateStylesheets()\r\n      if (this.mainModule && !this.mainActivated) {\r\n        this.initializeIfNeeded()\r\n        if (typeof this.mainModule.activateConfig === 'function') {\r\n          this.mainModule.activateConfig()\r\n        }\r\n        if (typeof this.mainModule.activate === 'function') {\r\n          this.mainModule.activate(this.packageManager.getPackageState(this.name) || {})\r\n        }\r\n        this.mainActivated = true\r\n        this.activateServices()\r\n      }\r\n      if (this.activationCommandSubscriptions) this.activationCommandSubscriptions.dispose()\r\n      if (this.activationHookSubscriptions) this.activationHookSubscriptions.dispose()\r\n    } catch (error) {\r\n      this.handleError(`Failed to activate the ${this.name} package`, error)\r\n    }\r\n\r\n    if (typeof this.resolveActivationPromise === 'function') this.resolveActivationPromise()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.handleError","start_line":1085,"end_line":1105,"comment":[],"params":["message","error"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"getActivePackage","line":697,"func_location":"PackageManager.activatePackage","func_start_line":696,"func_end_line":722,"args":["name"],"comment":[" Activate a single package by name"],"code":"  activatePackage (name) {\r\n    let pack = this.getActivePackage(name)\r\n    if (pack) {\r\n      return Promise.resolve(pack)\r\n    }\r\n\r\n    pack = this.loadPackage(name)\r\n    if (!pack) {\r\n      return Promise.reject(new Error(`Failed to load package '${name}'`))\r\n    }\r\n\r\n    this.activatingPackages[pack.name] = pack\r\n    const activationPromise = pack.activate().then(() => {\r\n      if (this.activatingPackages[pack.name] != null) {\r\n        delete this.activatingPackages[pack.name]\r\n        this.activePackages[pack.name] = pack\r\n        this.emitter.emit('did-activate-package', pack)\r\n      }\r\n      return pack\r\n    })\r\n\r\n    if (this.deferredActivationHooks == null) {\r\n      this.triggeredActivationHooks.forEach(hook => this.activationHookEmitter.emit(hook))\r\n    }\r\n\r\n    return activationPromise\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.getActivePackage","start_line":300,"end_line":302,"comment":[" Public: Get the active {Package} with the given name.",""," * `name` - The {String} package name.",""," Returns a {Package} or undefined."],"params":["name"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"loadPackage","line":702,"func_location":"PackageManager.activatePackage","func_start_line":696,"func_end_line":722,"args":["name"],"comment":[" Activate a single package by name"],"code":"  activatePackage (name) {\r\n    let pack = this.getActivePackage(name)\r\n    if (pack) {\r\n      return Promise.resolve(pack)\r\n    }\r\n\r\n    pack = this.loadPackage(name)\r\n    if (!pack) {\r\n      return Promise.reject(new Error(`Failed to load package '${name}'`))\r\n    }\r\n\r\n    this.activatingPackages[pack.name] = pack\r\n    const activationPromise = pack.activate().then(() => {\r\n      if (this.activatingPackages[pack.name] != null) {\r\n        delete this.activatingPackages[pack.name]\r\n        this.activePackages[pack.name] = pack\r\n        this.emitter.emit('did-activate-package', pack)\r\n      }\r\n      return pack\r\n    })\r\n\r\n    if (this.deferredActivationHooks == null) {\r\n      this.triggeredActivationHooks.forEach(hook => this.activationHookEmitter.emit(hook))\r\n    }\r\n\r\n    return activationPromise\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.loadPackage","start_line":551,"end_line":569,"comment":[],"params":["nameOrPath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"observeDisabledPackages","line":690,"func_location":"PackageManager.activatePackages","func_start_line":679,"func_end_line":693,"args":[],"code":"  activatePackages (packages) {\r\n    const promises = []\r\n    this.config.transactAsync(() => {\r\n      for (const pack of packages) {\r\n        const promise = this.activatePackage(pack.name)\r\n        if (!pack.activationShouldBeDeferred()) {\r\n          promises.push(promise)\r\n        }\r\n      }\r\n      return Promise.all(promises)\r\n    })\r\n    this.observeDisabledPackages()\r\n    this.observePackagesWithKeymapsDisabled()\r\n    return promises\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.observeDisabledPackages","start_line":444,"end_line":456,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"observePackagesWithKeymapsDisabled","line":691,"func_location":"PackageManager.activatePackages","func_start_line":679,"func_end_line":693,"args":[],"code":"  activatePackages (packages) {\r\n    const promises = []\r\n    this.config.transactAsync(() => {\r\n      for (const pack of packages) {\r\n        const promise = this.activatePackage(pack.name)\r\n        if (!pack.activationShouldBeDeferred()) {\r\n          promises.push(promise)\r\n        }\r\n      }\r\n      return Promise.all(promises)\r\n    })\r\n    this.observeDisabledPackages()\r\n    this.observePackagesWithKeymapsDisabled()\r\n    return promises\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.observePackagesWithKeymapsDisabled","start_line":465,"end_line":490,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"activateThemes","line":97,"func_location":"ThemeManager.activatePackages","func_start_line":96,"func_end_line":98,"args":[],"code":"  activatePackages () {\r\n    return this.activateThemes()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.activateThemes","start_line":319,"end_line":348,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getActiveItemIndex","line":524,"func_location":"Pane.activatePreviousItem","func_start_line":523,"func_end_line":530,"args":[],"comment":[" Public: Makes the previous item active."],"code":"  activatePreviousItem () {\r\n    const index = this.getActiveItemIndex()\r\n    if (index > 0) {\r\n      this.activateItemAtIndex(index - 1)\r\n    } else {\r\n      this.activateItemAtIndex(this.items.length - 1)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getActiveItemIndex","start_line":553,"end_line":555,"comment":[" Public: Get the index of the active item.",""," Returns a {Number}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"activateItemAtIndex","line":526,"func_location":"Pane.activatePreviousItem","func_start_line":523,"func_end_line":530,"args":[null],"comment":[" Public: Makes the previous item active."],"code":"  activatePreviousItem () {\r\n    const index = this.getActiveItemIndex()\r\n    if (index > 0) {\r\n      this.activateItemAtIndex(index - 1)\r\n    } else {\r\n      this.activateItemAtIndex(this.items.length - 1)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.activateItemAtIndex","start_line":560,"end_line":563,"comment":[" Public: Activate the item at the given index.",""," * `index` {Number}"],"params":["index"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"activateItemAtIndex","line":528,"func_location":"Pane.activatePreviousItem","func_start_line":523,"func_end_line":530,"args":[null],"comment":[" Public: Makes the previous item active."],"code":"  activatePreviousItem () {\r\n    const index = this.getActiveItemIndex()\r\n    if (index > 0) {\r\n      this.activateItemAtIndex(index - 1)\r\n    } else {\r\n      this.activateItemAtIndex(this.items.length - 1)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.activateItemAtIndex","start_line":560,"end_line":563,"comment":[" Public: Activate the item at the given index.",""," * `index` {Number}"],"params":["index"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"getPanes","line":201,"func_location":"PaneContainer.activatePreviousPane","func_start_line":200,"func_end_line":211,"args":[],"code":"  activatePreviousPane () {\r\n    const panes = this.getPanes()\r\n    if (panes.length > 1) {\r\n      const currentIndex = panes.indexOf(this.activePane)\r\n      let previousIndex = currentIndex - 1\r\n      if (previousIndex < 0) { previousIndex = panes.length - 1 }\r\n      panes[previousIndex].activate()\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.getPanes","start_line":146,"end_line":152,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getActivePaneContainer","line":1453,"func_location":"Workspace.activatePreviousPane","func_start_line":1452,"func_end_line":1454,"args":[],"comment":[" Extended: Make the previous pane active."],"code":"  activatePreviousPane () {\r\n    return this.getActivePaneContainer().activatePreviousPane()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getActivePaneContainer","start_line":1424,"end_line":1426,"comment":["\r\n  Section: Panes\r\n  "," Extended: Get the most recently focused pane container.",""," Returns a {Dock} or the {WorkspaceCenter}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"setActiveItem","line":501,"func_location":"Pane.activatePreviousRecentlyUsedItem","func_start_line":493,"func_end_line":503,"args":["previousRecentlyUsedItem",null],"comment":[" Makes the previous item in the itemStack active."],"code":"  activatePreviousRecentlyUsedItem () {\r\n    if (this.items.length > 1) {\r\n      if (this.itemStackIndex + 1 === this.itemStack.length || this.itemStackIndex == null) {\r\n        this.itemStackIndex = -1\r\n      }\r\n      this.itemStackIndex++\r\n      const previousRecentlyUsedItem = this.itemStack[this.itemStackIndex]\r\n      this.emitter.emit('choose-last-mru-item', previousRecentlyUsedItem)\r\n      this.setActiveItem(previousRecentlyUsedItem, {modifyStack: false})\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.setActiveItem","start_line":434,"end_line":443,"comment":[],"params":["activeItem","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"deactivateKeymaps","line":302,"func_location":"Package.activateResources","func_start_line":297,"func_end_line":324,"args":[],"code":"  activateResources () {\r\n    if (!this.activationDisposables) this.activationDisposables = new CompositeDisposable()\r\n\r\n    const packagesWithKeymapsDisabled = this.config.get('core.packagesWithKeymapsDisabled')\r\n    if (packagesWithKeymapsDisabled && packagesWithKeymapsDisabled.includes(this.name)) {\r\n      this.deactivateKeymaps()\r\n    } else if (!this.keymapActivated) {\r\n      this.activateKeymaps()\r\n    }\r\n\r\n    if (!this.menusActivated) {\r\n      this.activateMenus()\r\n    }\r\n\r\n    if (!this.grammarsActivated) {\r\n      for (let grammar of this.grammars) {\r\n        grammar.activate()\r\n      }\r\n      this.grammarsActivated = true\r\n    }\r\n\r\n    if (!this.settingsActivated) {\r\n      for (let settings of this.settings) {\r\n        settings.activate(this.config)\r\n      }\r\n      this.settingsActivated = true\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.deactivateKeymaps","start_line":340,"end_line":347,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"activateKeymaps","line":304,"func_location":"Package.activateResources","func_start_line":297,"func_end_line":324,"args":[],"code":"  activateResources () {\r\n    if (!this.activationDisposables) this.activationDisposables = new CompositeDisposable()\r\n\r\n    const packagesWithKeymapsDisabled = this.config.get('core.packagesWithKeymapsDisabled')\r\n    if (packagesWithKeymapsDisabled && packagesWithKeymapsDisabled.includes(this.name)) {\r\n      this.deactivateKeymaps()\r\n    } else if (!this.keymapActivated) {\r\n      this.activateKeymaps()\r\n    }\r\n\r\n    if (!this.menusActivated) {\r\n      this.activateMenus()\r\n    }\r\n\r\n    if (!this.grammarsActivated) {\r\n      for (let grammar of this.grammars) {\r\n        grammar.activate()\r\n      }\r\n      this.grammarsActivated = true\r\n    }\r\n\r\n    if (!this.settingsActivated) {\r\n      for (let settings of this.settings) {\r\n        settings.activate(this.config)\r\n      }\r\n      this.settingsActivated = true\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.activateKeymaps","start_line":326,"end_line":338,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"activateMenus","line":308,"func_location":"Package.activateResources","func_start_line":297,"func_end_line":324,"args":[],"code":"  activateResources () {\r\n    if (!this.activationDisposables) this.activationDisposables = new CompositeDisposable()\r\n\r\n    const packagesWithKeymapsDisabled = this.config.get('core.packagesWithKeymapsDisabled')\r\n    if (packagesWithKeymapsDisabled && packagesWithKeymapsDisabled.includes(this.name)) {\r\n      this.deactivateKeymaps()\r\n    } else if (!this.keymapActivated) {\r\n      this.activateKeymaps()\r\n    }\r\n\r\n    if (!this.menusActivated) {\r\n      this.activateMenus()\r\n    }\r\n\r\n    if (!this.grammarsActivated) {\r\n      for (let grammar of this.grammars) {\r\n        grammar.activate()\r\n      }\r\n      this.grammarsActivated = true\r\n    }\r\n\r\n    if (!this.settingsActivated) {\r\n      for (let settings of this.settings) {\r\n        settings.activate(this.config)\r\n      }\r\n      this.settingsActivated = true\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.activateMenus","start_line":356,"end_line":378,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"getStyleSheetPriority","line":270,"func_location":"Package.activateStylesheets","func_start_line":265,"func_end_line":295,"args":[],"code":"  activateStylesheets () {\r\n    if (this.stylesheetsActivated) return\r\n\r\n    this.stylesheetDisposables = new CompositeDisposable()\r\n\r\n    const priority = this.getStyleSheetPriority()\r\n    for (let [sourcePath, source] of this.stylesheets) {\r\n      const match = path.basename(sourcePath).match(/[^.]*\\.([^.]*)\\./)\r\n\r\n      let context\r\n      if (match) {\r\n        context = match[1]\r\n      } else if (this.metadata.theme === 'syntax') {\r\n        context = 'atom-text-editor'\r\n      }\r\n\r\n      this.stylesheetDisposables.add(\r\n        this.styleManager.addStyleSheet(\r\n          source,\r\n          {\r\n            sourcePath,\r\n            priority,\r\n            context,\r\n            skipDeprecatedSelectorsTransformation: this.bundledPackage\r\n          }\r\n        )\r\n      )\r\n    }\r\n\r\n    this.stylesheetsActivated = true\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.getStyleSheetPriority","start_line":89,"end_line":89,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"hasActivationCommands","line":806,"func_location":"Package.activationShouldBeDeferred","func_start_line":805,"func_end_line":807,"args":[],"code":"  activationShouldBeDeferred () {\r\n    return this.hasActivationCommands() || this.hasActivationHooks() || this.hasDeferredURIHandler()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.hasActivationCommands","start_line":814,"end_line":821,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"hasActivationHooks","line":806,"func_location":"Package.activationShouldBeDeferred","func_start_line":805,"func_end_line":807,"args":[],"code":"  activationShouldBeDeferred () {\r\n    return this.hasActivationCommands() || this.hasActivationHooks() || this.hasDeferredURIHandler()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.hasActivationHooks","start_line":809,"end_line":812,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"hasDeferredURIHandler","line":806,"func_location":"Package.activationShouldBeDeferred","func_start_line":805,"func_end_line":807,"args":[],"code":"  activationShouldBeDeferred () {\r\n    return this.hasActivationCommands() || this.hasActivationHooks() || this.hasDeferredURIHandler()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.hasDeferredURIHandler","start_line":823,"end_line":826,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js","name":"hasFocus","line":137,"func_location":"PaneElement.activeItemChanged","func_start_line":128,"func_end_line":166,"args":[],"code":"  activeItemChanged (item) {\r\n    delete this.dataset.activeItemName\r\n    delete this.dataset.activeItemPath\r\n    if (this.changePathDisposable != null) {\r\n      this.changePathDisposable.dispose()\r\n    }\r\n    if (item == null) {\r\n      return\r\n    }\r\n    const hasFocus = this.hasFocus()\r\n    const itemView = this.views.getView(item)\r\n    const itemPath = typeof item.getPath === 'function' ? item.getPath() : null\r\n    if (itemPath) {\r\n      this.dataset.activeItemName = path.basename(itemPath)\r\n      this.dataset.activeItemPath = itemPath\r\n      if (item.onDidChangePath != null) {\r\n        this.changePathDisposable = item.onDidChangePath(() => {\r\n          const itemPath = item.getPath()\r\n          this.dataset.activeItemName = path.basename(itemPath)\r\n          this.dataset.activeItemPath = itemPath\r\n        })\r\n      }\r\n    }\r\n    if (!this.itemViews.contains(itemView)) {\r\n      this.itemViews.appendChild(itemView)\r\n    }\r\n    for (const child of this.itemViews.children) {\r\n      if (child === itemView) {\r\n        if (this.attached) {\r\n          this.showItemView(child)\r\n        }\r\n      } else {\r\n        this.hideItemView(child)\r\n      }\r\n    }\r\n    if (hasFocus) {\r\n      itemView.focus()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js","name":"PaneElement.hasFocus","start_line":209,"end_line":213,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js","name":"showItemView","line":157,"func_location":"PaneElement.activeItemChanged","func_start_line":128,"func_end_line":166,"args":["child"],"code":"  activeItemChanged (item) {\r\n    delete this.dataset.activeItemName\r\n    delete this.dataset.activeItemPath\r\n    if (this.changePathDisposable != null) {\r\n      this.changePathDisposable.dispose()\r\n    }\r\n    if (item == null) {\r\n      return\r\n    }\r\n    const hasFocus = this.hasFocus()\r\n    const itemView = this.views.getView(item)\r\n    const itemPath = typeof item.getPath === 'function' ? item.getPath() : null\r\n    if (itemPath) {\r\n      this.dataset.activeItemName = path.basename(itemPath)\r\n      this.dataset.activeItemPath = itemPath\r\n      if (item.onDidChangePath != null) {\r\n        this.changePathDisposable = item.onDidChangePath(() => {\r\n          const itemPath = item.getPath()\r\n          this.dataset.activeItemName = path.basename(itemPath)\r\n          this.dataset.activeItemPath = itemPath\r\n        })\r\n      }\r\n    }\r\n    if (!this.itemViews.contains(itemView)) {\r\n      this.itemViews.appendChild(itemView)\r\n    }\r\n    for (const child of this.itemViews.children) {\r\n      if (child === itemView) {\r\n        if (this.attached) {\r\n          this.showItemView(child)\r\n        }\r\n      } else {\r\n        this.hideItemView(child)\r\n      }\r\n    }\r\n    if (hasFocus) {\r\n      itemView.focus()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js","name":"PaneElement.showItemView","start_line":168,"end_line":175,"comment":[],"params":["itemView"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js","name":"hideItemView","line":160,"func_location":"PaneElement.activeItemChanged","func_start_line":128,"func_end_line":166,"args":["child"],"code":"  activeItemChanged (item) {\r\n    delete this.dataset.activeItemName\r\n    delete this.dataset.activeItemPath\r\n    if (this.changePathDisposable != null) {\r\n      this.changePathDisposable.dispose()\r\n    }\r\n    if (item == null) {\r\n      return\r\n    }\r\n    const hasFocus = this.hasFocus()\r\n    const itemView = this.views.getView(item)\r\n    const itemPath = typeof item.getPath === 'function' ? item.getPath() : null\r\n    if (itemPath) {\r\n      this.dataset.activeItemName = path.basename(itemPath)\r\n      this.dataset.activeItemPath = itemPath\r\n      if (item.onDidChangePath != null) {\r\n        this.changePathDisposable = item.onDidChangePath(() => {\r\n          const itemPath = item.getPath()\r\n          this.dataset.activeItemName = path.basename(itemPath)\r\n          this.dataset.activeItemPath = itemPath\r\n        })\r\n      }\r\n    }\r\n    if (!this.itemViews.contains(itemView)) {\r\n      this.itemViews.appendChild(itemView)\r\n    }\r\n    for (const child of this.itemViews.children) {\r\n      if (child === itemView) {\r\n        if (this.attached) {\r\n          this.showItemView(child)\r\n        }\r\n      } else {\r\n        this.hideItemView(child)\r\n      }\r\n    }\r\n    if (hasFocus) {\r\n      itemView.focus()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js","name":"PaneElement.hideItemView","start_line":177,"end_line":185,"comment":[],"params":["itemView"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js","name":"add","line":137,"func_location":"CommandRegistry.add","func_start_line":130,"func_end_line":163,"args":[null],"comment":[" Public: Add one or more command listeners associated with a selector.",""," ## Arguments: Registering One Command",""," * `target` A {String} containing a CSS selector or a DOM element. If you","   pass a selector, the command will be globally associated with all matching","   elements. The `,` combinator is not currently supported. If you pass a","   DOM element, the command will be associated with just that element."," * `commandName` A {String} containing the name of a command you want to","   handle such as `user:insert-date`."," * `listener` A listener which handles the event.  Either a {Function} to","   call when the given command is invoked on an element matching the","   selector, or an {Object} with a `didDispatch` property which is such a","   function.","","   The function (`listener` itself if it is a function, or the `didDispatch`","   method if `listener` is an object) will be called with `this` referencing","   the matching DOM node and the following argument:","     * `event`: A standard DOM event instance. Call `stopPropagation` or","       `stopImmediatePropagation` to terminate bubbling early.","","   Additionally, `listener` may have additional properties which are returned","   to those who query using `atom.commands.findCommands`, as well as several","   meaningful metadata properties:","     * `displayName`: Overrides any generated `displayName` that would","       otherwise be generated from the event name.","     * `description`: Used by consumers to display detailed information about","       the command.","     * `hiddenInCommandPalette`: If `true`, this command will not appear in","       the bundled command palette by default, but can still be shown with.","       the `Command Palette: Show Hidden Commands` command. This is a good","       option when you need to register large numbers of commands that don't","       make sense to be executed from the command palette. Please use this","       option conservatively, as it could reduce the discoverability of your","       package's commands.",""," ## Arguments: Registering Multiple Commands",""," * `target` A {String} containing a CSS selector or a DOM element. If you","   pass a selector, the commands will be globally associated with all","   matching elements. The `,` combinator is not currently supported.","   If you pass a DOM element, the command will be associated with just that","   element."," * `commands` An {Object} mapping command names like `user:insert-date` to","   listener {Function}s.",""," Returns a {Disposable} on which `.dispose()` can be called to remove the"," added command handler(s)."],"code":"  add (target, commandName, listener, throwOnInvalidSelector = true) {\r\n    if (typeof commandName === 'object') {\r\n      const commands = commandName\r\n      throwOnInvalidSelector = listener\r\n      const disposable = new CompositeDisposable()\r\n      for (commandName in commands) {\r\n        listener = commands[commandName]\r\n        disposable.add(this.add(target, commandName, listener, throwOnInvalidSelector))\r\n      }\r\n      return disposable\r\n    }\r\n\r\n    if (listener == null) {\r\n      throw new Error('Cannot register a command with a null listener.')\r\n    }\r\n\r\n    // type Listener = ((e: CustomEvent) => void) | {\r\n    //   displayName?: string,\r\n    //   description?: string,\r\n    //   didDispatch(e: CustomEvent): void,\r\n    // }\r\n    if ((typeof listener !== 'function') && (typeof listener.didDispatch !== 'function')) {\r\n      throw new Error('Listener must be a callback function or an object with a didDispatch method.')\r\n    }\r\n\r\n    if (typeof target === 'string') {\r\n      if (throwOnInvalidSelector) {\r\n        validateSelector(target)\r\n      }\r\n      return this.addSelectorBasedListener(target, commandName, listener)\r\n    } else {\r\n      return this.addInlineListener(target, commandName, listener)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js","name":"CommandRegistry.add","start_line":130,"end_line":163,"comment":[" Public: Add one or more command listeners associated with a selector.",""," ## Arguments: Registering One Command",""," * `target` A {String} containing a CSS selector or a DOM element. If you","   pass a selector, the command will be globally associated with all matching","   elements. The `,` combinator is not currently supported. If you pass a","   DOM element, the command will be associated with just that element."," * `commandName` A {String} containing the name of a command you want to","   handle such as `user:insert-date`."," * `listener` A listener which handles the event.  Either a {Function} to","   call when the given command is invoked on an element matching the","   selector, or an {Object} with a `didDispatch` property which is such a","   function.","","   The function (`listener` itself if it is a function, or the `didDispatch`","   method if `listener` is an object) will be called with `this` referencing","   the matching DOM node and the following argument:","     * `event`: A standard DOM event instance. Call `stopPropagation` or","       `stopImmediatePropagation` to terminate bubbling early.","","   Additionally, `listener` may have additional properties which are returned","   to those who query using `atom.commands.findCommands`, as well as several","   meaningful metadata properties:","     * `displayName`: Overrides any generated `displayName` that would","       otherwise be generated from the event name.","     * `description`: Used by consumers to display detailed information about","       the command.","     * `hiddenInCommandPalette`: If `true`, this command will not appear in","       the bundled command palette by default, but can still be shown with.","       the `Command Palette: Show Hidden Commands` command. This is a good","       option when you need to register large numbers of commands that don't","       make sense to be executed from the command palette. Please use this","       option conservatively, as it could reduce the discoverability of your","       package's commands.",""," ## Arguments: Registering Multiple Commands",""," * `target` A {String} containing a CSS selector or a DOM element. If you","   pass a selector, the commands will be globally associated with all","   matching elements. The `,` combinator is not currently supported.","   If you pass a DOM element, the command will be associated with just that","   element."," * `commands` An {Object} mapping command names like `user:insert-date` to","   listener {Function}s.",""," Returns a {Disposable} on which `.dispose()` can be called to remove the"," added command handler(s)."],"params":["target","commandName","listener","throwOnInvalidSelector"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js","name":"addSelectorBasedListener","line":159,"func_location":"CommandRegistry.add","func_start_line":130,"func_end_line":163,"args":["target","commandName","listener"],"comment":[" Public: Add one or more command listeners associated with a selector.",""," ## Arguments: Registering One Command",""," * `target` A {String} containing a CSS selector or a DOM element. If you","   pass a selector, the command will be globally associated with all matching","   elements. The `,` combinator is not currently supported. If you pass a","   DOM element, the command will be associated with just that element."," * `commandName` A {String} containing the name of a command you want to","   handle such as `user:insert-date`."," * `listener` A listener which handles the event.  Either a {Function} to","   call when the given command is invoked on an element matching the","   selector, or an {Object} with a `didDispatch` property which is such a","   function.","","   The function (`listener` itself if it is a function, or the `didDispatch`","   method if `listener` is an object) will be called with `this` referencing","   the matching DOM node and the following argument:","     * `event`: A standard DOM event instance. Call `stopPropagation` or","       `stopImmediatePropagation` to terminate bubbling early.","","   Additionally, `listener` may have additional properties which are returned","   to those who query using `atom.commands.findCommands`, as well as several","   meaningful metadata properties:","     * `displayName`: Overrides any generated `displayName` that would","       otherwise be generated from the event name.","     * `description`: Used by consumers to display detailed information about","       the command.","     * `hiddenInCommandPalette`: If `true`, this command will not appear in","       the bundled command palette by default, but can still be shown with.","       the `Command Palette: Show Hidden Commands` command. This is a good","       option when you need to register large numbers of commands that don't","       make sense to be executed from the command palette. Please use this","       option conservatively, as it could reduce the discoverability of your","       package's commands.",""," ## Arguments: Registering Multiple Commands",""," * `target` A {String} containing a CSS selector or a DOM element. If you","   pass a selector, the commands will be globally associated with all","   matching elements. The `,` combinator is not currently supported.","   If you pass a DOM element, the command will be associated with just that","   element."," * `commands` An {Object} mapping command names like `user:insert-date` to","   listener {Function}s.",""," Returns a {Disposable} on which `.dispose()` can be called to remove the"," added command handler(s)."],"code":"  add (target, commandName, listener, throwOnInvalidSelector = true) {\r\n    if (typeof commandName === 'object') {\r\n      const commands = commandName\r\n      throwOnInvalidSelector = listener\r\n      const disposable = new CompositeDisposable()\r\n      for (commandName in commands) {\r\n        listener = commands[commandName]\r\n        disposable.add(this.add(target, commandName, listener, throwOnInvalidSelector))\r\n      }\r\n      return disposable\r\n    }\r\n\r\n    if (listener == null) {\r\n      throw new Error('Cannot register a command with a null listener.')\r\n    }\r\n\r\n    // type Listener = ((e: CustomEvent) => void) | {\r\n    //   displayName?: string,\r\n    //   description?: string,\r\n    //   didDispatch(e: CustomEvent): void,\r\n    // }\r\n    if ((typeof listener !== 'function') && (typeof listener.didDispatch !== 'function')) {\r\n      throw new Error('Listener must be a callback function or an object with a didDispatch method.')\r\n    }\r\n\r\n    if (typeof target === 'string') {\r\n      if (throwOnInvalidSelector) {\r\n        validateSelector(target)\r\n      }\r\n      return this.addSelectorBasedListener(target, commandName, listener)\r\n    } else {\r\n      return this.addInlineListener(target, commandName, listener)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js","name":"CommandRegistry.addSelectorBasedListener","start_line":165,"end_line":181,"comment":[],"params":["selector","commandName","listener"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js","name":"addInlineListener","line":161,"func_location":"CommandRegistry.add","func_start_line":130,"func_end_line":163,"args":["target","commandName","listener"],"comment":[" Public: Add one or more command listeners associated with a selector.",""," ## Arguments: Registering One Command",""," * `target` A {String} containing a CSS selector or a DOM element. If you","   pass a selector, the command will be globally associated with all matching","   elements. The `,` combinator is not currently supported. If you pass a","   DOM element, the command will be associated with just that element."," * `commandName` A {String} containing the name of a command you want to","   handle such as `user:insert-date`."," * `listener` A listener which handles the event.  Either a {Function} to","   call when the given command is invoked on an element matching the","   selector, or an {Object} with a `didDispatch` property which is such a","   function.","","   The function (`listener` itself if it is a function, or the `didDispatch`","   method if `listener` is an object) will be called with `this` referencing","   the matching DOM node and the following argument:","     * `event`: A standard DOM event instance. Call `stopPropagation` or","       `stopImmediatePropagation` to terminate bubbling early.","","   Additionally, `listener` may have additional properties which are returned","   to those who query using `atom.commands.findCommands`, as well as several","   meaningful metadata properties:","     * `displayName`: Overrides any generated `displayName` that would","       otherwise be generated from the event name.","     * `description`: Used by consumers to display detailed information about","       the command.","     * `hiddenInCommandPalette`: If `true`, this command will not appear in","       the bundled command palette by default, but can still be shown with.","       the `Command Palette: Show Hidden Commands` command. This is a good","       option when you need to register large numbers of commands that don't","       make sense to be executed from the command palette. Please use this","       option conservatively, as it could reduce the discoverability of your","       package's commands.",""," ## Arguments: Registering Multiple Commands",""," * `target` A {String} containing a CSS selector or a DOM element. If you","   pass a selector, the commands will be globally associated with all","   matching elements. The `,` combinator is not currently supported.","   If you pass a DOM element, the command will be associated with just that","   element."," * `commands` An {Object} mapping command names like `user:insert-date` to","   listener {Function}s.",""," Returns a {Disposable} on which `.dispose()` can be called to remove the"," added command handler(s)."],"code":"  add (target, commandName, listener, throwOnInvalidSelector = true) {\r\n    if (typeof commandName === 'object') {\r\n      const commands = commandName\r\n      throwOnInvalidSelector = listener\r\n      const disposable = new CompositeDisposable()\r\n      for (commandName in commands) {\r\n        listener = commands[commandName]\r\n        disposable.add(this.add(target, commandName, listener, throwOnInvalidSelector))\r\n      }\r\n      return disposable\r\n    }\r\n\r\n    if (listener == null) {\r\n      throw new Error('Cannot register a command with a null listener.')\r\n    }\r\n\r\n    // type Listener = ((e: CustomEvent) => void) | {\r\n    //   displayName?: string,\r\n    //   description?: string,\r\n    //   didDispatch(e: CustomEvent): void,\r\n    // }\r\n    if ((typeof listener !== 'function') && (typeof listener.didDispatch !== 'function')) {\r\n      throw new Error('Listener must be a callback function or an object with a didDispatch method.')\r\n    }\r\n\r\n    if (typeof target === 'string') {\r\n      if (throwOnInvalidSelector) {\r\n        validateSelector(target)\r\n      }\r\n      return this.addSelectorBasedListener(target, commandName, listener)\r\n    } else {\r\n      return this.addInlineListener(target, commandName, listener)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js","name":"CommandRegistry.addInlineListener","start_line":183,"end_line":205,"comment":[],"params":["element","commandName","listener"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification-manager.js","name":"addNotification","line":188,"func_location":"NotificationManager.add","func_start_line":187,"func_end_line":189,"args":[null],"code":"  add (type, message, options) {\r\n    return this.addNotification(new Notification(type, message, options))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification-manager.js","name":"NotificationManager.addNotification","start_line":191,"end_line":195,"comment":[],"params":["notification"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip-manager.js","name":"add","line":118,"func_location":"TooltipManager.add","func_start_line":114,"func_end_line":177,"args":[null],"comment":[" Essential: Add a tooltip to the given element.",""," * `target` An `HTMLElement`"," * `options` An object with one or more of the following options:","   * `title` A {String} or {Function} to use for the text in the tip. If","     a function is passed, `this` will be set to the `target` element. This","     option is mutually exclusive with the `item` option.","   * `html` A {Boolean} affecting the interpretation of the `title` option.","     If `true` (the default), the `title` string will be interpreted as HTML.","     Otherwise it will be interpreted as plain text.","   * `item` A view (object with an `.element` property) or a DOM element","     containing custom content for the tooltip. This option is mutually","     exclusive with the `title` option.","   * `class` A {String} with a class to apply to the tooltip element to","     enable custom styling.","   * `placement` A {String} or {Function} returning a string to indicate","     the position of the tooltip relative to `element`. Can be `'top'`,","     `'bottom'`, `'left'`, `'right'`, or `'auto'`. When `'auto'` is","     specified, it will dynamically reorient the tooltip. For example, if","     placement is `'auto left'`, the tooltip will display to the left when","     possible, otherwise it will display right.","     When a function is used to determine the placement, it is called with","     the tooltip DOM node as its first argument and the triggering element","     DOM node as its second. The `this` context is set to the tooltip","     instance.","   * `trigger` A {String} indicating how the tooltip should be displayed.","     Choose from one of the following options:","       * `'hover'` Show the tooltip when the mouse hovers over the element.","         This is the default.","       * `'click'` Show the tooltip when the element is clicked. The tooltip","         will be hidden after clicking the element again or anywhere else","         outside of the tooltip itself.","       * `'focus'` Show the tooltip when the element is focused.","       * `'manual'` Show the tooltip immediately and only hide it when the","         returned disposable is disposed.","   * `delay` An object specifying the show and hide delay in milliseconds.","     Defaults to `{show: 1000, hide: 100}` if the `trigger` is `hover` and","     otherwise defaults to `0` for both values.","   * `keyBindingCommand` A {String} containing a command name. If you specify","     this option and a key binding exists that matches the command, it will","     be appended to the title or rendered alone if no title is specified.","   * `keyBindingTarget` An `HTMLElement` on which to look up the key binding.","     If this option is not supplied, the first of all matching key bindings","     for the given command will be rendered.",""," Returns a {Disposable} on which `.dispose()` can be called to remove the"," tooltip."],"code":"  add (target, options) {\r\n    if (target.jquery) {\r\n      const disposable = new CompositeDisposable()\r\n      for (let i = 0; i < target.length; i++) {\r\n        disposable.add(this.add(target[i], options))\r\n      }\r\n      return disposable\r\n    }\r\n\r\n    if (Tooltip == null) { Tooltip = require('./tooltip') }\r\n\r\n    const {keyBindingCommand, keyBindingTarget} = options\r\n\r\n    if (keyBindingCommand != null) {\r\n      const bindings = this.keymapManager.findKeyBindings({command: keyBindingCommand, target: keyBindingTarget})\r\n      const keystroke = getKeystroke(bindings)\r\n      if ((options.title != null) && (keystroke != null)) {\r\n        options.title += ` ${getKeystroke(bindings)}`\r\n      } else if (keystroke != null) {\r\n        options.title = getKeystroke(bindings)\r\n      }\r\n    }\r\n\r\n    delete options.selector\r\n    options = _.defaults(options, this.defaults)\r\n    if (options.trigger === 'hover') {\r\n      options = _.defaults(options, this.hoverDefaults)\r\n    }\r\n\r\n    const tooltip = new Tooltip(target, options, this.viewRegistry)\r\n\r\n    if (!this.tooltips.has(target)) {\r\n      this.tooltips.set(target, [])\r\n    }\r\n    this.tooltips.get(target).push(tooltip)\r\n\r\n    const hideTooltip = function () {\r\n      tooltip.leave({currentTarget: target})\r\n      tooltip.hide()\r\n    }\r\n\r\n    // note: adding a listener here adds a new listener for every tooltip element that's registered.  Adding unnecessary listeners is bad for performance.  It would be better to add/remove listeners when tooltips are actually created in the dom.\r\n    window.addEventListener('resize', hideTooltip)\r\n\r\n    const disposable = new Disposable(() => {\r\n      window.removeEventListener('resize', hideTooltip)\r\n\r\n      hideTooltip()\r\n      tooltip.destroy()\r\n\r\n      if (this.tooltips.has(target)) {\r\n        const tooltipsForTarget = this.tooltips.get(target)\r\n        const index = tooltipsForTarget.indexOf(tooltip)\r\n        if (index !== -1) {\r\n          tooltipsForTarget.splice(index, 1)\r\n        }\r\n        if (tooltipsForTarget.length === 0) {\r\n          this.tooltips.delete(target)\r\n        }\r\n      }\r\n    })\r\n\r\n    return disposable\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip-manager.js","name":"TooltipManager.add","start_line":114,"end_line":177,"comment":[" Essential: Add a tooltip to the given element.",""," * `target` An `HTMLElement`"," * `options` An object with one or more of the following options:","   * `title` A {String} or {Function} to use for the text in the tip. If","     a function is passed, `this` will be set to the `target` element. This","     option is mutually exclusive with the `item` option.","   * `html` A {Boolean} affecting the interpretation of the `title` option.","     If `true` (the default), the `title` string will be interpreted as HTML.","     Otherwise it will be interpreted as plain text.","   * `item` A view (object with an `.element` property) or a DOM element","     containing custom content for the tooltip. This option is mutually","     exclusive with the `title` option.","   * `class` A {String} with a class to apply to the tooltip element to","     enable custom styling.","   * `placement` A {String} or {Function} returning a string to indicate","     the position of the tooltip relative to `element`. Can be `'top'`,","     `'bottom'`, `'left'`, `'right'`, or `'auto'`. When `'auto'` is","     specified, it will dynamically reorient the tooltip. For example, if","     placement is `'auto left'`, the tooltip will display to the left when","     possible, otherwise it will display right.","     When a function is used to determine the placement, it is called with","     the tooltip DOM node as its first argument and the triggering element","     DOM node as its second. The `this` context is set to the tooltip","     instance.","   * `trigger` A {String} indicating how the tooltip should be displayed.","     Choose from one of the following options:","       * `'hover'` Show the tooltip when the mouse hovers over the element.","         This is the default.","       * `'click'` Show the tooltip when the element is clicked. The tooltip","         will be hidden after clicking the element again or anywhere else","         outside of the tooltip itself.","       * `'focus'` Show the tooltip when the element is focused.","       * `'manual'` Show the tooltip immediately and only hide it when the","         returned disposable is disposed.","   * `delay` An object specifying the show and hide delay in milliseconds.","     Defaults to `{show: 1000, hide: 100}` if the `trigger` is `hover` and","     otherwise defaults to `0` for both values.","   * `keyBindingCommand` A {String} containing a command name. If you specify","     this option and a key binding exists that matches the command, it will","     be appended to the title or rendered alone if no title is specified.","   * `keyBindingTarget` An `HTMLElement` on which to look up the key binding.","     If this option is not supplied, the first of all matching key bindings","     for the given command will be rendered.",""," Returns a {Disposable} on which `.dispose()` can be called to remove the"," tooltip."],"params":["target","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip-manager.js","name":"getKeystroke","line":129,"func_location":"TooltipManager.add","func_start_line":114,"func_end_line":177,"args":["bindings"],"comment":[" Essential: Add a tooltip to the given element.",""," * `target` An `HTMLElement`"," * `options` An object with one or more of the following options:","   * `title` A {String} or {Function} to use for the text in the tip. If","     a function is passed, `this` will be set to the `target` element. This","     option is mutually exclusive with the `item` option.","   * `html` A {Boolean} affecting the interpretation of the `title` option.","     If `true` (the default), the `title` string will be interpreted as HTML.","     Otherwise it will be interpreted as plain text.","   * `item` A view (object with an `.element` property) or a DOM element","     containing custom content for the tooltip. This option is mutually","     exclusive with the `title` option.","   * `class` A {String} with a class to apply to the tooltip element to","     enable custom styling.","   * `placement` A {String} or {Function} returning a string to indicate","     the position of the tooltip relative to `element`. Can be `'top'`,","     `'bottom'`, `'left'`, `'right'`, or `'auto'`. When `'auto'` is","     specified, it will dynamically reorient the tooltip. For example, if","     placement is `'auto left'`, the tooltip will display to the left when","     possible, otherwise it will display right.","     When a function is used to determine the placement, it is called with","     the tooltip DOM node as its first argument and the triggering element","     DOM node as its second. The `this` context is set to the tooltip","     instance.","   * `trigger` A {String} indicating how the tooltip should be displayed.","     Choose from one of the following options:","       * `'hover'` Show the tooltip when the mouse hovers over the element.","         This is the default.","       * `'click'` Show the tooltip when the element is clicked. The tooltip","         will be hidden after clicking the element again or anywhere else","         outside of the tooltip itself.","       * `'focus'` Show the tooltip when the element is focused.","       * `'manual'` Show the tooltip immediately and only hide it when the","         returned disposable is disposed.","   * `delay` An object specifying the show and hide delay in milliseconds.","     Defaults to `{show: 1000, hide: 100}` if the `trigger` is `hover` and","     otherwise defaults to `0` for both values.","   * `keyBindingCommand` A {String} containing a command name. If you specify","     this option and a key binding exists that matches the command, it will","     be appended to the title or rendered alone if no title is specified.","   * `keyBindingTarget` An `HTMLElement` on which to look up the key binding.","     If this option is not supplied, the first of all matching key bindings","     for the given command will be rendered.",""," Returns a {Disposable} on which `.dispose()` can be called to remove the"," tooltip."],"code":"  add (target, options) {\r\n    if (target.jquery) {\r\n      const disposable = new CompositeDisposable()\r\n      for (let i = 0; i < target.length; i++) {\r\n        disposable.add(this.add(target[i], options))\r\n      }\r\n      return disposable\r\n    }\r\n\r\n    if (Tooltip == null) { Tooltip = require('./tooltip') }\r\n\r\n    const {keyBindingCommand, keyBindingTarget} = options\r\n\r\n    if (keyBindingCommand != null) {\r\n      const bindings = this.keymapManager.findKeyBindings({command: keyBindingCommand, target: keyBindingTarget})\r\n      const keystroke = getKeystroke(bindings)\r\n      if ((options.title != null) && (keystroke != null)) {\r\n        options.title += ` ${getKeystroke(bindings)}`\r\n      } else if (keystroke != null) {\r\n        options.title = getKeystroke(bindings)\r\n      }\r\n    }\r\n\r\n    delete options.selector\r\n    options = _.defaults(options, this.defaults)\r\n    if (options.trigger === 'hover') {\r\n      options = _.defaults(options, this.hoverDefaults)\r\n    }\r\n\r\n    const tooltip = new Tooltip(target, options, this.viewRegistry)\r\n\r\n    if (!this.tooltips.has(target)) {\r\n      this.tooltips.set(target, [])\r\n    }\r\n    this.tooltips.get(target).push(tooltip)\r\n\r\n    const hideTooltip = function () {\r\n      tooltip.leave({currentTarget: target})\r\n      tooltip.hide()\r\n    }\r\n\r\n    // note: adding a listener here adds a new listener for every tooltip element that's registered.  Adding unnecessary listeners is bad for performance.  It would be better to add/remove listeners when tooltips are actually created in the dom.\r\n    window.addEventListener('resize', hideTooltip)\r\n\r\n    const disposable = new Disposable(() => {\r\n      window.removeEventListener('resize', hideTooltip)\r\n\r\n      hideTooltip()\r\n      tooltip.destroy()\r\n\r\n      if (this.tooltips.has(target)) {\r\n        const tooltipsForTarget = this.tooltips.get(target)\r\n        const index = tooltipsForTarget.indexOf(tooltip)\r\n        if (index !== -1) {\r\n          tooltipsForTarget.splice(index, 1)\r\n        }\r\n        if (tooltipsForTarget.length === 0) {\r\n          this.tooltips.delete(target)\r\n        }\r\n      }\r\n    })\r\n\r\n    return disposable\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip-manager.js","name":"getKeystroke","start_line":199,"end_line":203,"comment":[],"params":["bindings"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip-manager.js","name":"getKeystroke","line":131,"func_location":"TooltipManager.add","func_start_line":114,"func_end_line":177,"args":["bindings"],"comment":[" Essential: Add a tooltip to the given element.",""," * `target` An `HTMLElement`"," * `options` An object with one or more of the following options:","   * `title` A {String} or {Function} to use for the text in the tip. If","     a function is passed, `this` will be set to the `target` element. This","     option is mutually exclusive with the `item` option.","   * `html` A {Boolean} affecting the interpretation of the `title` option.","     If `true` (the default), the `title` string will be interpreted as HTML.","     Otherwise it will be interpreted as plain text.","   * `item` A view (object with an `.element` property) or a DOM element","     containing custom content for the tooltip. This option is mutually","     exclusive with the `title` option.","   * `class` A {String} with a class to apply to the tooltip element to","     enable custom styling.","   * `placement` A {String} or {Function} returning a string to indicate","     the position of the tooltip relative to `element`. Can be `'top'`,","     `'bottom'`, `'left'`, `'right'`, or `'auto'`. When `'auto'` is","     specified, it will dynamically reorient the tooltip. For example, if","     placement is `'auto left'`, the tooltip will display to the left when","     possible, otherwise it will display right.","     When a function is used to determine the placement, it is called with","     the tooltip DOM node as its first argument and the triggering element","     DOM node as its second. The `this` context is set to the tooltip","     instance.","   * `trigger` A {String} indicating how the tooltip should be displayed.","     Choose from one of the following options:","       * `'hover'` Show the tooltip when the mouse hovers over the element.","         This is the default.","       * `'click'` Show the tooltip when the element is clicked. The tooltip","         will be hidden after clicking the element again or anywhere else","         outside of the tooltip itself.","       * `'focus'` Show the tooltip when the element is focused.","       * `'manual'` Show the tooltip immediately and only hide it when the","         returned disposable is disposed.","   * `delay` An object specifying the show and hide delay in milliseconds.","     Defaults to `{show: 1000, hide: 100}` if the `trigger` is `hover` and","     otherwise defaults to `0` for both values.","   * `keyBindingCommand` A {String} containing a command name. If you specify","     this option and a key binding exists that matches the command, it will","     be appended to the title or rendered alone if no title is specified.","   * `keyBindingTarget` An `HTMLElement` on which to look up the key binding.","     If this option is not supplied, the first of all matching key bindings","     for the given command will be rendered.",""," Returns a {Disposable} on which `.dispose()` can be called to remove the"," tooltip."],"code":"  add (target, options) {\r\n    if (target.jquery) {\r\n      const disposable = new CompositeDisposable()\r\n      for (let i = 0; i < target.length; i++) {\r\n        disposable.add(this.add(target[i], options))\r\n      }\r\n      return disposable\r\n    }\r\n\r\n    if (Tooltip == null) { Tooltip = require('./tooltip') }\r\n\r\n    const {keyBindingCommand, keyBindingTarget} = options\r\n\r\n    if (keyBindingCommand != null) {\r\n      const bindings = this.keymapManager.findKeyBindings({command: keyBindingCommand, target: keyBindingTarget})\r\n      const keystroke = getKeystroke(bindings)\r\n      if ((options.title != null) && (keystroke != null)) {\r\n        options.title += ` ${getKeystroke(bindings)}`\r\n      } else if (keystroke != null) {\r\n        options.title = getKeystroke(bindings)\r\n      }\r\n    }\r\n\r\n    delete options.selector\r\n    options = _.defaults(options, this.defaults)\r\n    if (options.trigger === 'hover') {\r\n      options = _.defaults(options, this.hoverDefaults)\r\n    }\r\n\r\n    const tooltip = new Tooltip(target, options, this.viewRegistry)\r\n\r\n    if (!this.tooltips.has(target)) {\r\n      this.tooltips.set(target, [])\r\n    }\r\n    this.tooltips.get(target).push(tooltip)\r\n\r\n    const hideTooltip = function () {\r\n      tooltip.leave({currentTarget: target})\r\n      tooltip.hide()\r\n    }\r\n\r\n    // note: adding a listener here adds a new listener for every tooltip element that's registered.  Adding unnecessary listeners is bad for performance.  It would be better to add/remove listeners when tooltips are actually created in the dom.\r\n    window.addEventListener('resize', hideTooltip)\r\n\r\n    const disposable = new Disposable(() => {\r\n      window.removeEventListener('resize', hideTooltip)\r\n\r\n      hideTooltip()\r\n      tooltip.destroy()\r\n\r\n      if (this.tooltips.has(target)) {\r\n        const tooltipsForTarget = this.tooltips.get(target)\r\n        const index = tooltipsForTarget.indexOf(tooltip)\r\n        if (index !== -1) {\r\n          tooltipsForTarget.splice(index, 1)\r\n        }\r\n        if (tooltipsForTarget.length === 0) {\r\n          this.tooltips.delete(target)\r\n        }\r\n      }\r\n    })\r\n\r\n    return disposable\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip-manager.js","name":"getKeystroke","start_line":199,"end_line":203,"comment":[],"params":["bindings"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip-manager.js","name":"getKeystroke","line":133,"func_location":"TooltipManager.add","func_start_line":114,"func_end_line":177,"args":["bindings"],"comment":[" Essential: Add a tooltip to the given element.",""," * `target` An `HTMLElement`"," * `options` An object with one or more of the following options:","   * `title` A {String} or {Function} to use for the text in the tip. If","     a function is passed, `this` will be set to the `target` element. This","     option is mutually exclusive with the `item` option.","   * `html` A {Boolean} affecting the interpretation of the `title` option.","     If `true` (the default), the `title` string will be interpreted as HTML.","     Otherwise it will be interpreted as plain text.","   * `item` A view (object with an `.element` property) or a DOM element","     containing custom content for the tooltip. This option is mutually","     exclusive with the `title` option.","   * `class` A {String} with a class to apply to the tooltip element to","     enable custom styling.","   * `placement` A {String} or {Function} returning a string to indicate","     the position of the tooltip relative to `element`. Can be `'top'`,","     `'bottom'`, `'left'`, `'right'`, or `'auto'`. When `'auto'` is","     specified, it will dynamically reorient the tooltip. For example, if","     placement is `'auto left'`, the tooltip will display to the left when","     possible, otherwise it will display right.","     When a function is used to determine the placement, it is called with","     the tooltip DOM node as its first argument and the triggering element","     DOM node as its second. The `this` context is set to the tooltip","     instance.","   * `trigger` A {String} indicating how the tooltip should be displayed.","     Choose from one of the following options:","       * `'hover'` Show the tooltip when the mouse hovers over the element.","         This is the default.","       * `'click'` Show the tooltip when the element is clicked. The tooltip","         will be hidden after clicking the element again or anywhere else","         outside of the tooltip itself.","       * `'focus'` Show the tooltip when the element is focused.","       * `'manual'` Show the tooltip immediately and only hide it when the","         returned disposable is disposed.","   * `delay` An object specifying the show and hide delay in milliseconds.","     Defaults to `{show: 1000, hide: 100}` if the `trigger` is `hover` and","     otherwise defaults to `0` for both values.","   * `keyBindingCommand` A {String} containing a command name. If you specify","     this option and a key binding exists that matches the command, it will","     be appended to the title or rendered alone if no title is specified.","   * `keyBindingTarget` An `HTMLElement` on which to look up the key binding.","     If this option is not supplied, the first of all matching key bindings","     for the given command will be rendered.",""," Returns a {Disposable} on which `.dispose()` can be called to remove the"," tooltip."],"code":"  add (target, options) {\r\n    if (target.jquery) {\r\n      const disposable = new CompositeDisposable()\r\n      for (let i = 0; i < target.length; i++) {\r\n        disposable.add(this.add(target[i], options))\r\n      }\r\n      return disposable\r\n    }\r\n\r\n    if (Tooltip == null) { Tooltip = require('./tooltip') }\r\n\r\n    const {keyBindingCommand, keyBindingTarget} = options\r\n\r\n    if (keyBindingCommand != null) {\r\n      const bindings = this.keymapManager.findKeyBindings({command: keyBindingCommand, target: keyBindingTarget})\r\n      const keystroke = getKeystroke(bindings)\r\n      if ((options.title != null) && (keystroke != null)) {\r\n        options.title += ` ${getKeystroke(bindings)}`\r\n      } else if (keystroke != null) {\r\n        options.title = getKeystroke(bindings)\r\n      }\r\n    }\r\n\r\n    delete options.selector\r\n    options = _.defaults(options, this.defaults)\r\n    if (options.trigger === 'hover') {\r\n      options = _.defaults(options, this.hoverDefaults)\r\n    }\r\n\r\n    const tooltip = new Tooltip(target, options, this.viewRegistry)\r\n\r\n    if (!this.tooltips.has(target)) {\r\n      this.tooltips.set(target, [])\r\n    }\r\n    this.tooltips.get(target).push(tooltip)\r\n\r\n    const hideTooltip = function () {\r\n      tooltip.leave({currentTarget: target})\r\n      tooltip.hide()\r\n    }\r\n\r\n    // note: adding a listener here adds a new listener for every tooltip element that's registered.  Adding unnecessary listeners is bad for performance.  It would be better to add/remove listeners when tooltips are actually created in the dom.\r\n    window.addEventListener('resize', hideTooltip)\r\n\r\n    const disposable = new Disposable(() => {\r\n      window.removeEventListener('resize', hideTooltip)\r\n\r\n      hideTooltip()\r\n      tooltip.destroy()\r\n\r\n      if (this.tooltips.has(target)) {\r\n        const tooltipsForTarget = this.tooltips.get(target)\r\n        const index = tooltipsForTarget.indexOf(tooltip)\r\n        if (index !== -1) {\r\n          tooltipsForTarget.splice(index, 1)\r\n        }\r\n        if (tooltipsForTarget.length === 0) {\r\n          this.tooltips.delete(target)\r\n        }\r\n      }\r\n    })\r\n\r\n    return disposable\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip-manager.js","name":"getKeystroke","start_line":199,"end_line":203,"comment":[],"params":["bindings"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/native-watcher-registry.js","name":"absolute","line":40,"func_location":"RegistryTree.add","func_start_line":38,"func_end_line":54},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/native-watcher-registry.js","name":"absolute","start_line":4,"end_line":7,"comment":[" Private: re-join the segments split from an absolute path to form another absolute path."],"params":["parts"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"getActiveThemes","line":364,"func_location":"ThemeManager.addActiveThemeClasses","func_start_line":361,"func_end_line":368,"args":[],"code":"  addActiveThemeClasses () {\r\n    const workspaceElement = this.viewRegistry.getView(this.workspace)\r\n    if (workspaceElement) {\r\n      for (const pack of this.getActiveThemes()) {\r\n        workspaceElement.classList.add(`theme-${pack.name}`)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.getActiveThemes","start_line":92,"end_line":94,"comment":[" Public: Returns an {Array} of all the active themes."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"scheduleUpdate","line":2520,"func_location":"TextEditorComponent.addBlockDecoration","func_start_line":2508,"func_end_line":2560,"args":[],"code":"  addBlockDecoration (decoration, subscribeToChanges = true) {\r\n    const marker = decoration.getMarker()\r\n    const {item, position} = decoration.getProperties()\r\n    const element = TextEditor.viewForItem(item)\r\n\r\n    if (marker.isValid()) {\r\n      const row = marker.getHeadScreenPosition().row\r\n      this.lineTopIndex.insertBlock(decoration, row, 0, position === 'after')\r\n      this.blockDecorationsToMeasure.add(decoration)\r\n      this.blockDecorationsByElement.set(element, decoration)\r\n      this.blockDecorationResizeObserver.observe(element)\r\n\r\n      this.scheduleUpdate()\r\n    }\r\n\r\n    if (subscribeToChanges) {\r\n      let wasValid = marker.isValid()\r\n\r\n      const didUpdateDisposable = marker.bufferMarker.onDidChange(({textChanged}) => {\r\n        const isValid = marker.isValid()\r\n        if (wasValid && !isValid) {\r\n          wasValid = false\r\n          this.blockDecorationsToMeasure.delete(decoration)\r\n          this.heightsByBlockDecoration.delete(decoration)\r\n          this.blockDecorationsByElement.delete(element)\r\n          this.blockDecorationResizeObserver.unobserve(element)\r\n          this.lineTopIndex.removeBlock(decoration)\r\n          this.scheduleUpdate()\r\n        } else if (!wasValid && isValid) {\r\n          wasValid = true\r\n          this.addBlockDecoration(decoration, false)\r\n        } else if (isValid && !textChanged) {\r\n          this.lineTopIndex.moveBlock(decoration, marker.getHeadScreenPosition().row)\r\n          this.scheduleUpdate()\r\n        }\r\n      })\r\n\r\n      const didDestroyDisposable = decoration.onDidDestroy(() => {\r\n        didUpdateDisposable.dispose()\r\n        didDestroyDisposable.dispose()\r\n\r\n        if (wasValid) {\r\n          wasValid = false\r\n          this.blockDecorationsToMeasure.delete(decoration)\r\n          this.heightsByBlockDecoration.delete(decoration)\r\n          this.blockDecorationsByElement.delete(element)\r\n          this.blockDecorationResizeObserver.unobserve(element)\r\n          this.lineTopIndex.removeBlock(decoration)\r\n          this.scheduleUpdate()\r\n        }\r\n      })\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.scheduleUpdate","start_line":204,"end_line":219,"comment":[],"params":["nextUpdateOnlyBlinksCursors"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedStartRow","line":1177,"func_location":"TextEditorComponent.addBlockDecorationToRender","func_start_line":1175,"func_end_line":1194,"args":[],"code":"  addBlockDecorationToRender (decoration, screenRange, reversed) {\r\n    const {row} = reversed ? screenRange.start : screenRange.end\r\n    if (row < this.getRenderedStartRow() || row >= this.getRenderedEndRow()) return\r\n\r\n    const tileStartRow = this.tileStartRowForRow(row)\r\n    const screenLine = this.renderedScreenLines[row - this.getRenderedStartRow()]\r\n\r\n    let decorationsByScreenLine = this.decorationsToRender.blocks.get(tileStartRow)\r\n    if (!decorationsByScreenLine) {\r\n      decorationsByScreenLine = new Map()\r\n      this.decorationsToRender.blocks.set(tileStartRow, decorationsByScreenLine)\r\n    }\r\n\r\n    let decorations = decorationsByScreenLine.get(screenLine.id)\r\n    if (!decorations) {\r\n      decorations = []\r\n      decorationsByScreenLine.set(screenLine.id, decorations)\r\n    }\r\n    decorations.push(decoration)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedStartRow","start_line":2720,"end_line":2726,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedEndRow","line":1177,"func_location":"TextEditorComponent.addBlockDecorationToRender","func_start_line":1175,"func_end_line":1194,"args":[],"code":"  addBlockDecorationToRender (decoration, screenRange, reversed) {\r\n    const {row} = reversed ? screenRange.start : screenRange.end\r\n    if (row < this.getRenderedStartRow() || row >= this.getRenderedEndRow()) return\r\n\r\n    const tileStartRow = this.tileStartRowForRow(row)\r\n    const screenLine = this.renderedScreenLines[row - this.getRenderedStartRow()]\r\n\r\n    let decorationsByScreenLine = this.decorationsToRender.blocks.get(tileStartRow)\r\n    if (!decorationsByScreenLine) {\r\n      decorationsByScreenLine = new Map()\r\n      this.decorationsToRender.blocks.set(tileStartRow, decorationsByScreenLine)\r\n    }\r\n\r\n    let decorations = decorationsByScreenLine.get(screenLine.id)\r\n    if (!decorations) {\r\n      decorations = []\r\n      decorationsByScreenLine.set(screenLine.id, decorations)\r\n    }\r\n    decorations.push(decoration)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedEndRow","start_line":2728,"end_line":2737,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"tileStartRowForRow","line":1179,"func_location":"TextEditorComponent.addBlockDecorationToRender","func_start_line":1175,"func_end_line":1194,"args":["row"],"code":"  addBlockDecorationToRender (decoration, screenRange, reversed) {\r\n    const {row} = reversed ? screenRange.start : screenRange.end\r\n    if (row < this.getRenderedStartRow() || row >= this.getRenderedEndRow()) return\r\n\r\n    const tileStartRow = this.tileStartRowForRow(row)\r\n    const screenLine = this.renderedScreenLines[row - this.getRenderedStartRow()]\r\n\r\n    let decorationsByScreenLine = this.decorationsToRender.blocks.get(tileStartRow)\r\n    if (!decorationsByScreenLine) {\r\n      decorationsByScreenLine = new Map()\r\n      this.decorationsToRender.blocks.set(tileStartRow, decorationsByScreenLine)\r\n    }\r\n\r\n    let decorations = decorationsByScreenLine.get(screenLine.id)\r\n    if (!decorations) {\r\n      decorations = []\r\n      decorationsByScreenLine.set(screenLine.id, decorations)\r\n    }\r\n    decorations.push(decoration)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.tileStartRowForRow","start_line":2716,"end_line":2718,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedStartRow","line":1180,"func_location":"TextEditorComponent.addBlockDecorationToRender","func_start_line":1175,"func_end_line":1194,"args":[],"code":"  addBlockDecorationToRender (decoration, screenRange, reversed) {\r\n    const {row} = reversed ? screenRange.start : screenRange.end\r\n    if (row < this.getRenderedStartRow() || row >= this.getRenderedEndRow()) return\r\n\r\n    const tileStartRow = this.tileStartRowForRow(row)\r\n    const screenLine = this.renderedScreenLines[row - this.getRenderedStartRow()]\r\n\r\n    let decorationsByScreenLine = this.decorationsToRender.blocks.get(tileStartRow)\r\n    if (!decorationsByScreenLine) {\r\n      decorationsByScreenLine = new Map()\r\n      this.decorationsToRender.blocks.set(tileStartRow, decorationsByScreenLine)\r\n    }\r\n\r\n    let decorations = decorationsByScreenLine.get(screenLine.id)\r\n    if (!decorations) {\r\n      decorations = []\r\n      decorationsByScreenLine.set(screenLine.id, decorations)\r\n    }\r\n    decorations.push(decoration)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedStartRow","start_line":2720,"end_line":2726,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"addPanel","line":1665,"func_location":"Workspace.addBottomPanel","func_start_line":1664,"func_end_line":1666,"args":[{"type":"string"},"options"],"comment":[" Essential: Adds a panel item to the bottom of the editor window.",""," * `options` {Object}","   * `item` Your panel content. It can be DOM element, a jQuery element, or","     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the","     latter. See {ViewRegistry::addViewProvider} for more information.","   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden","     (default: true)","   * `priority` (optional) {Number} Determines stacking order. Lower priority items are","     forced closer to the edges of the window. (default: 100)",""," Returns a {Panel}"],"code":"  addBottomPanel (options) {\r\n    return this.addPanel('bottom', options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.addPanel","start_line":1816,"end_line":1819,"comment":[],"params":["location","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"subscribeToBuffer","line":731,"func_location":"Project.addBuffer","func_start_line":728,"func_end_line":734,"args":["buffer"],"code":"  addBuffer (buffer, options = {}) {\r\n    this.buffers.push(buffer)\r\n    this.subscriptions.add(this.grammarRegistry.maintainLanguageMode(buffer))\r\n    this.subscribeToBuffer(buffer)\r\n    this.emitter.emit('did-add-buffer', buffer)\r\n    return buffer\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.subscribeToBuffer","start_line":762,"end_line":781,"comment":[],"params":["buffer"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js","name":"subscribeToChild","line":121,"func_location":"PaneAxis.addChild","func_start_line":117,"func_end_line":123,"args":["child"],"code":"  addChild (child, index = this.children.length) {\r\n    this.children.splice(index, 0, child)\r\n    child.setParent(this)\r\n    child.setContainer(this.container)\r\n    this.subscribeToChild(child)\r\n    return this.emitter.emit('did-add-child', {child, index})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js","name":"PaneAxis.subscribeToChild","start_line":180,"end_line":184,"comment":[],"params":["child"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedStartRow","line":1118,"func_location":"TextEditorComponent.addCursorDecorationToMeasure","func_start_line":1108,"func_end_line":1145,"args":[],"code":"  addCursorDecorationToMeasure (decoration, marker, screenRange, reversed) {\r\n    const {model} = this.props\r\n    if (!model.getShowCursorOnSelection() && !screenRange.isEmpty()) return\r\n\r\n    let decorationToMeasure = this.decorationsToMeasure.cursors.get(marker)\r\n    if (!decorationToMeasure) {\r\n      const isLastCursor = model.getLastCursor().getMarker() === marker\r\n      const screenPosition = reversed ? screenRange.start : screenRange.end\r\n      const {row, column} = screenPosition\r\n\r\n      if (row < this.getRenderedStartRow() || row >= this.getRenderedEndRow()) return\r\n\r\n      this.requestHorizontalMeasurement(row, column)\r\n      let columnWidth = 0\r\n      if (model.lineLengthForScreenRow(row) > column) {\r\n        columnWidth = 1\r\n        this.requestHorizontalMeasurement(row, column + 1)\r\n      }\r\n      decorationToMeasure = {screenPosition, columnWidth, isLastCursor}\r\n      this.decorationsToMeasure.cursors.set(marker, decorationToMeasure)\r\n    }\r\n\r\n    if (decoration.class) {\r\n      if (decorationToMeasure.className) {\r\n        decorationToMeasure.className += ' ' + decoration.class\r\n      } else {\r\n        decorationToMeasure.className = decoration.class\r\n      }\r\n    }\r\n\r\n    if (decoration.style) {\r\n      if (decorationToMeasure.style) {\r\n        Object.assign(decorationToMeasure.style, decoration.style)\r\n      } else {\r\n        decorationToMeasure.style = Object.assign({}, decoration.style)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedStartRow","start_line":2720,"end_line":2726,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedEndRow","line":1118,"func_location":"TextEditorComponent.addCursorDecorationToMeasure","func_start_line":1108,"func_end_line":1145,"args":[],"code":"  addCursorDecorationToMeasure (decoration, marker, screenRange, reversed) {\r\n    const {model} = this.props\r\n    if (!model.getShowCursorOnSelection() && !screenRange.isEmpty()) return\r\n\r\n    let decorationToMeasure = this.decorationsToMeasure.cursors.get(marker)\r\n    if (!decorationToMeasure) {\r\n      const isLastCursor = model.getLastCursor().getMarker() === marker\r\n      const screenPosition = reversed ? screenRange.start : screenRange.end\r\n      const {row, column} = screenPosition\r\n\r\n      if (row < this.getRenderedStartRow() || row >= this.getRenderedEndRow()) return\r\n\r\n      this.requestHorizontalMeasurement(row, column)\r\n      let columnWidth = 0\r\n      if (model.lineLengthForScreenRow(row) > column) {\r\n        columnWidth = 1\r\n        this.requestHorizontalMeasurement(row, column + 1)\r\n      }\r\n      decorationToMeasure = {screenPosition, columnWidth, isLastCursor}\r\n      this.decorationsToMeasure.cursors.set(marker, decorationToMeasure)\r\n    }\r\n\r\n    if (decoration.class) {\r\n      if (decorationToMeasure.className) {\r\n        decorationToMeasure.className += ' ' + decoration.class\r\n      } else {\r\n        decorationToMeasure.className = decoration.class\r\n      }\r\n    }\r\n\r\n    if (decoration.style) {\r\n      if (decorationToMeasure.style) {\r\n        Object.assign(decorationToMeasure.style, decoration.style)\r\n      } else {\r\n        decorationToMeasure.style = Object.assign({}, decoration.style)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedEndRow","start_line":2728,"end_line":2737,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"requestHorizontalMeasurement","line":1120,"func_location":"TextEditorComponent.addCursorDecorationToMeasure","func_start_line":1108,"func_end_line":1145,"args":["row","column"],"code":"  addCursorDecorationToMeasure (decoration, marker, screenRange, reversed) {\r\n    const {model} = this.props\r\n    if (!model.getShowCursorOnSelection() && !screenRange.isEmpty()) return\r\n\r\n    let decorationToMeasure = this.decorationsToMeasure.cursors.get(marker)\r\n    if (!decorationToMeasure) {\r\n      const isLastCursor = model.getLastCursor().getMarker() === marker\r\n      const screenPosition = reversed ? screenRange.start : screenRange.end\r\n      const {row, column} = screenPosition\r\n\r\n      if (row < this.getRenderedStartRow() || row >= this.getRenderedEndRow()) return\r\n\r\n      this.requestHorizontalMeasurement(row, column)\r\n      let columnWidth = 0\r\n      if (model.lineLengthForScreenRow(row) > column) {\r\n        columnWidth = 1\r\n        this.requestHorizontalMeasurement(row, column + 1)\r\n      }\r\n      decorationToMeasure = {screenPosition, columnWidth, isLastCursor}\r\n      this.decorationsToMeasure.cursors.set(marker, decorationToMeasure)\r\n    }\r\n\r\n    if (decoration.class) {\r\n      if (decorationToMeasure.className) {\r\n        decorationToMeasure.className += ' ' + decoration.class\r\n      } else {\r\n        decorationToMeasure.className = decoration.class\r\n      }\r\n    }\r\n\r\n    if (decoration.style) {\r\n      if (decorationToMeasure.style) {\r\n        Object.assign(decorationToMeasure.style, decoration.style)\r\n      } else {\r\n        decorationToMeasure.style = Object.assign({}, decoration.style)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.requestHorizontalMeasurement","start_line":2243,"end_line":2257,"comment":[],"params":["row","column"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"requestHorizontalMeasurement","line":1124,"func_location":"TextEditorComponent.addCursorDecorationToMeasure","func_start_line":1108,"func_end_line":1145,"args":["row",null],"code":"  addCursorDecorationToMeasure (decoration, marker, screenRange, reversed) {\r\n    const {model} = this.props\r\n    if (!model.getShowCursorOnSelection() && !screenRange.isEmpty()) return\r\n\r\n    let decorationToMeasure = this.decorationsToMeasure.cursors.get(marker)\r\n    if (!decorationToMeasure) {\r\n      const isLastCursor = model.getLastCursor().getMarker() === marker\r\n      const screenPosition = reversed ? screenRange.start : screenRange.end\r\n      const {row, column} = screenPosition\r\n\r\n      if (row < this.getRenderedStartRow() || row >= this.getRenderedEndRow()) return\r\n\r\n      this.requestHorizontalMeasurement(row, column)\r\n      let columnWidth = 0\r\n      if (model.lineLengthForScreenRow(row) > column) {\r\n        columnWidth = 1\r\n        this.requestHorizontalMeasurement(row, column + 1)\r\n      }\r\n      decorationToMeasure = {screenPosition, columnWidth, isLastCursor}\r\n      this.decorationsToMeasure.cursors.set(marker, decorationToMeasure)\r\n    }\r\n\r\n    if (decoration.class) {\r\n      if (decorationToMeasure.className) {\r\n        decorationToMeasure.className += ' ' + decoration.class\r\n      } else {\r\n        decorationToMeasure.className = decoration.class\r\n      }\r\n    }\r\n\r\n    if (decoration.style) {\r\n      if (decorationToMeasure.style) {\r\n        Object.assign(decorationToMeasure.style, decoration.style)\r\n      } else {\r\n        decorationToMeasure.style = Object.assign({}, decoration.style)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.requestHorizontalMeasurement","start_line":2243,"end_line":2257,"comment":[],"params":["row","column"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelPositionAfterBlocksForRow","line":1164,"func_location":"TextEditorComponent.addCustomGutterDecorationToRender","func_start_line":1158,"func_end_line":1173,"args":["screenRange.start.row"],"code":"  addCustomGutterDecorationToRender (decoration, screenRange) {\r\n    let decorations = this.decorationsToRender.customGutter.get(decoration.gutterName)\r\n    if (!decorations) {\r\n      decorations = []\r\n      this.decorationsToRender.customGutter.set(decoration.gutterName, decorations)\r\n    }\r\n    const top = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const height = this.pixelPositionBeforeBlocksForRow(screenRange.end.row + 1) - top\r\n\r\n    decorations.push({\r\n      className: 'decoration' + (decoration.class ? ' ' + decoration.class : ''),\r\n      element: TextEditor.viewForItem(decoration.item),\r\n      top,\r\n      height\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelPositionAfterBlocksForRow","start_line":2364,"end_line":2366,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelPositionBeforeBlocksForRow","line":1165,"func_location":"TextEditorComponent.addCustomGutterDecorationToRender","func_start_line":1158,"func_end_line":1173,"args":[null],"code":"  addCustomGutterDecorationToRender (decoration, screenRange) {\r\n    let decorations = this.decorationsToRender.customGutter.get(decoration.gutterName)\r\n    if (!decorations) {\r\n      decorations = []\r\n      this.decorationsToRender.customGutter.set(decoration.gutterName, decorations)\r\n    }\r\n    const top = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const height = this.pixelPositionBeforeBlocksForRow(screenRange.end.row + 1) - top\r\n\r\n    decorations.push({\r\n      className: 'decoration' + (decoration.class ? ' ' + decoration.class : ''),\r\n      element: TextEditor.viewForItem(decoration.item),\r\n      top,\r\n      height\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelPositionBeforeBlocksForRow","start_line":2360,"end_line":2362,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"addDecorationToRender","line":1014,"func_location":"TextEditorComponent.addDecorationToRender","func_start_line":1011,"func_end_line":1042,"args":["type.i","decoration","marker","screenRange","reversed"],"code":"  addDecorationToRender (type, decoration, marker, screenRange, reversed) {\r\n    if (Array.isArray(type)) {\r\n      for (let i = 0, length = type.length; i < length; i++) {\r\n        this.addDecorationToRender(type[i], decoration, marker, screenRange, reversed)\r\n      }\r\n    } else {\r\n      switch (type) {\r\n        case 'line':\r\n        case 'line-number':\r\n          this.addLineDecorationToRender(type, decoration, screenRange, reversed)\r\n          break\r\n        case 'highlight':\r\n          this.addHighlightDecorationToMeasure(decoration, screenRange, marker.id)\r\n          break\r\n        case 'cursor':\r\n          this.addCursorDecorationToMeasure(decoration, marker, screenRange, reversed)\r\n          break\r\n        case 'overlay':\r\n          this.addOverlayDecorationToRender(decoration, marker)\r\n          break\r\n        case 'gutter':\r\n          this.addCustomGutterDecorationToRender(decoration, screenRange)\r\n          break\r\n        case 'block':\r\n          this.addBlockDecorationToRender(decoration, screenRange, reversed)\r\n          break\r\n        case 'text':\r\n          this.addTextDecorationToRender(decoration, screenRange, marker)\r\n          break\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.addDecorationToRender","start_line":1011,"end_line":1042,"comment":[],"params":["type","decoration","marker","screenRange","reversed"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"addLineDecorationToRender","line":1020,"func_location":"TextEditorComponent.addDecorationToRender","func_start_line":1011,"func_end_line":1042,"args":["type","decoration","screenRange","reversed"],"code":"  addDecorationToRender (type, decoration, marker, screenRange, reversed) {\r\n    if (Array.isArray(type)) {\r\n      for (let i = 0, length = type.length; i < length; i++) {\r\n        this.addDecorationToRender(type[i], decoration, marker, screenRange, reversed)\r\n      }\r\n    } else {\r\n      switch (type) {\r\n        case 'line':\r\n        case 'line-number':\r\n          this.addLineDecorationToRender(type, decoration, screenRange, reversed)\r\n          break\r\n        case 'highlight':\r\n          this.addHighlightDecorationToMeasure(decoration, screenRange, marker.id)\r\n          break\r\n        case 'cursor':\r\n          this.addCursorDecorationToMeasure(decoration, marker, screenRange, reversed)\r\n          break\r\n        case 'overlay':\r\n          this.addOverlayDecorationToRender(decoration, marker)\r\n          break\r\n        case 'gutter':\r\n          this.addCustomGutterDecorationToRender(decoration, screenRange)\r\n          break\r\n        case 'block':\r\n          this.addBlockDecorationToRender(decoration, screenRange, reversed)\r\n          break\r\n        case 'text':\r\n          this.addTextDecorationToRender(decoration, screenRange, marker)\r\n          break\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.addLineDecorationToRender","start_line":1044,"end_line":1088,"comment":[],"params":["type","decoration","screenRange","reversed"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"addHighlightDecorationToMeasure","line":1023,"func_location":"TextEditorComponent.addDecorationToRender","func_start_line":1011,"func_end_line":1042,"args":["decoration","screenRange","marker.id"],"code":"  addDecorationToRender (type, decoration, marker, screenRange, reversed) {\r\n    if (Array.isArray(type)) {\r\n      for (let i = 0, length = type.length; i < length; i++) {\r\n        this.addDecorationToRender(type[i], decoration, marker, screenRange, reversed)\r\n      }\r\n    } else {\r\n      switch (type) {\r\n        case 'line':\r\n        case 'line-number':\r\n          this.addLineDecorationToRender(type, decoration, screenRange, reversed)\r\n          break\r\n        case 'highlight':\r\n          this.addHighlightDecorationToMeasure(decoration, screenRange, marker.id)\r\n          break\r\n        case 'cursor':\r\n          this.addCursorDecorationToMeasure(decoration, marker, screenRange, reversed)\r\n          break\r\n        case 'overlay':\r\n          this.addOverlayDecorationToRender(decoration, marker)\r\n          break\r\n        case 'gutter':\r\n          this.addCustomGutterDecorationToRender(decoration, screenRange)\r\n          break\r\n        case 'block':\r\n          this.addBlockDecorationToRender(decoration, screenRange, reversed)\r\n          break\r\n        case 'text':\r\n          this.addTextDecorationToRender(decoration, screenRange, marker)\r\n          break\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.addHighlightDecorationToMeasure","start_line":1090,"end_line":1106,"comment":[],"params":["decoration","screenRange","key"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"addCursorDecorationToMeasure","line":1026,"func_location":"TextEditorComponent.addDecorationToRender","func_start_line":1011,"func_end_line":1042,"args":["decoration","marker","screenRange","reversed"],"code":"  addDecorationToRender (type, decoration, marker, screenRange, reversed) {\r\n    if (Array.isArray(type)) {\r\n      for (let i = 0, length = type.length; i < length; i++) {\r\n        this.addDecorationToRender(type[i], decoration, marker, screenRange, reversed)\r\n      }\r\n    } else {\r\n      switch (type) {\r\n        case 'line':\r\n        case 'line-number':\r\n          this.addLineDecorationToRender(type, decoration, screenRange, reversed)\r\n          break\r\n        case 'highlight':\r\n          this.addHighlightDecorationToMeasure(decoration, screenRange, marker.id)\r\n          break\r\n        case 'cursor':\r\n          this.addCursorDecorationToMeasure(decoration, marker, screenRange, reversed)\r\n          break\r\n        case 'overlay':\r\n          this.addOverlayDecorationToRender(decoration, marker)\r\n          break\r\n        case 'gutter':\r\n          this.addCustomGutterDecorationToRender(decoration, screenRange)\r\n          break\r\n        case 'block':\r\n          this.addBlockDecorationToRender(decoration, screenRange, reversed)\r\n          break\r\n        case 'text':\r\n          this.addTextDecorationToRender(decoration, screenRange, marker)\r\n          break\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.addCursorDecorationToMeasure","start_line":1108,"end_line":1145,"comment":[],"params":["decoration","marker","screenRange","reversed"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"addOverlayDecorationToRender","line":1029,"func_location":"TextEditorComponent.addDecorationToRender","func_start_line":1011,"func_end_line":1042,"args":["decoration","marker"],"code":"  addDecorationToRender (type, decoration, marker, screenRange, reversed) {\r\n    if (Array.isArray(type)) {\r\n      for (let i = 0, length = type.length; i < length; i++) {\r\n        this.addDecorationToRender(type[i], decoration, marker, screenRange, reversed)\r\n      }\r\n    } else {\r\n      switch (type) {\r\n        case 'line':\r\n        case 'line-number':\r\n          this.addLineDecorationToRender(type, decoration, screenRange, reversed)\r\n          break\r\n        case 'highlight':\r\n          this.addHighlightDecorationToMeasure(decoration, screenRange, marker.id)\r\n          break\r\n        case 'cursor':\r\n          this.addCursorDecorationToMeasure(decoration, marker, screenRange, reversed)\r\n          break\r\n        case 'overlay':\r\n          this.addOverlayDecorationToRender(decoration, marker)\r\n          break\r\n        case 'gutter':\r\n          this.addCustomGutterDecorationToRender(decoration, screenRange)\r\n          break\r\n        case 'block':\r\n          this.addBlockDecorationToRender(decoration, screenRange, reversed)\r\n          break\r\n        case 'text':\r\n          this.addTextDecorationToRender(decoration, screenRange, marker)\r\n          break\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.addOverlayDecorationToRender","start_line":1147,"end_line":1156,"comment":[],"params":["decoration","marker"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"addCustomGutterDecorationToRender","line":1032,"func_location":"TextEditorComponent.addDecorationToRender","func_start_line":1011,"func_end_line":1042,"args":["decoration","screenRange"],"code":"  addDecorationToRender (type, decoration, marker, screenRange, reversed) {\r\n    if (Array.isArray(type)) {\r\n      for (let i = 0, length = type.length; i < length; i++) {\r\n        this.addDecorationToRender(type[i], decoration, marker, screenRange, reversed)\r\n      }\r\n    } else {\r\n      switch (type) {\r\n        case 'line':\r\n        case 'line-number':\r\n          this.addLineDecorationToRender(type, decoration, screenRange, reversed)\r\n          break\r\n        case 'highlight':\r\n          this.addHighlightDecorationToMeasure(decoration, screenRange, marker.id)\r\n          break\r\n        case 'cursor':\r\n          this.addCursorDecorationToMeasure(decoration, marker, screenRange, reversed)\r\n          break\r\n        case 'overlay':\r\n          this.addOverlayDecorationToRender(decoration, marker)\r\n          break\r\n        case 'gutter':\r\n          this.addCustomGutterDecorationToRender(decoration, screenRange)\r\n          break\r\n        case 'block':\r\n          this.addBlockDecorationToRender(decoration, screenRange, reversed)\r\n          break\r\n        case 'text':\r\n          this.addTextDecorationToRender(decoration, screenRange, marker)\r\n          break\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.addCustomGutterDecorationToRender","start_line":1158,"end_line":1173,"comment":[],"params":["decoration","screenRange"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"addBlockDecorationToRender","line":1035,"func_location":"TextEditorComponent.addDecorationToRender","func_start_line":1011,"func_end_line":1042,"args":["decoration","screenRange","reversed"],"code":"  addDecorationToRender (type, decoration, marker, screenRange, reversed) {\r\n    if (Array.isArray(type)) {\r\n      for (let i = 0, length = type.length; i < length; i++) {\r\n        this.addDecorationToRender(type[i], decoration, marker, screenRange, reversed)\r\n      }\r\n    } else {\r\n      switch (type) {\r\n        case 'line':\r\n        case 'line-number':\r\n          this.addLineDecorationToRender(type, decoration, screenRange, reversed)\r\n          break\r\n        case 'highlight':\r\n          this.addHighlightDecorationToMeasure(decoration, screenRange, marker.id)\r\n          break\r\n        case 'cursor':\r\n          this.addCursorDecorationToMeasure(decoration, marker, screenRange, reversed)\r\n          break\r\n        case 'overlay':\r\n          this.addOverlayDecorationToRender(decoration, marker)\r\n          break\r\n        case 'gutter':\r\n          this.addCustomGutterDecorationToRender(decoration, screenRange)\r\n          break\r\n        case 'block':\r\n          this.addBlockDecorationToRender(decoration, screenRange, reversed)\r\n          break\r\n        case 'text':\r\n          this.addTextDecorationToRender(decoration, screenRange, marker)\r\n          break\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.addBlockDecorationToRender","start_line":1175,"end_line":1194,"comment":[],"params":["decoration","screenRange","reversed"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"addTextDecorationToRender","line":1038,"func_location":"TextEditorComponent.addDecorationToRender","func_start_line":1011,"func_end_line":1042,"args":["decoration","screenRange","marker"],"code":"  addDecorationToRender (type, decoration, marker, screenRange, reversed) {\r\n    if (Array.isArray(type)) {\r\n      for (let i = 0, length = type.length; i < length; i++) {\r\n        this.addDecorationToRender(type[i], decoration, marker, screenRange, reversed)\r\n      }\r\n    } else {\r\n      switch (type) {\r\n        case 'line':\r\n        case 'line-number':\r\n          this.addLineDecorationToRender(type, decoration, screenRange, reversed)\r\n          break\r\n        case 'highlight':\r\n          this.addHighlightDecorationToMeasure(decoration, screenRange, marker.id)\r\n          break\r\n        case 'cursor':\r\n          this.addCursorDecorationToMeasure(decoration, marker, screenRange, reversed)\r\n          break\r\n        case 'overlay':\r\n          this.addOverlayDecorationToRender(decoration, marker)\r\n          break\r\n        case 'gutter':\r\n          this.addCustomGutterDecorationToRender(decoration, screenRange)\r\n          break\r\n        case 'block':\r\n          this.addBlockDecorationToRender(decoration, screenRange, reversed)\r\n          break\r\n        case 'text':\r\n          this.addTextDecorationToRender(decoration, screenRange, marker)\r\n          break\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.addTextDecorationToRender","start_line":1196,"end_line":1207,"comment":[],"params":["decoration","screenRange","marker"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification-manager.js","name":"addNotification","line":154,"func_location":"NotificationManager.addError","func_start_line":153,"func_end_line":155,"args":[null],"comment":[" Public: Add an error notification.",""," * `message` A {String} message"," * `options` (optional) An options {Object} with the following keys:","    * `buttons` (optional) An {Array} of {Object} where each {Object} has","      the following options:","      * `className` (optional) {String} a class name to add to the button's","        default class name (`btn btn-error`).","      * `onDidClick` (optional) {Function} callback to call when the button","        has been clicked. The context will be set to the","        {NotificationElement} instance.","      * `text` {String} inner text for the button","    * `description` (optional) A Markdown {String} containing a longer","      description about the notification. By default, this **will not**","      preserve newlines and whitespace when it is rendered.","    * `detail` (optional) A plain-text {String} containing additional","      details about the notification. By default, this **will** preserve","      newlines and whitespace when it is rendered.","    * `dismissable` (optional) A {Boolean} indicating whether this","      notification can be dismissed by the user. Defaults to `false`.","    * `icon` (optional) A {String} name of an icon from Octicons to display","      in the notification header. Defaults to `'flame'`.","    * `stack` (optional) A preformatted {String} with stack trace","      information describing the location of the error.",""," Returns the {Notification} that was added."],"code":"  addError (message, options) {\r\n    return this.addNotification(new Notification('error', message, options))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification-manager.js","name":"NotificationManager.addNotification","start_line":191,"end_line":195,"comment":[],"params":["notification"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification-manager.js","name":"addNotification","line":184,"func_location":"NotificationManager.addFatalError","func_start_line":183,"func_end_line":185,"args":[null],"comment":[" Public: Add a fatal error notification.",""," * `message` A {String} message"," * `options` (optional) An options {Object} with the following keys:","    * `buttons` (optional) An {Array} of {Object} where each {Object} has","      the following options:","      * `className` (optional) {String} a class name to add to the button's","        default class name (`btn btn-error`).","      * `onDidClick` (optional) {Function} callback to call when the button","        has been clicked. The context will be set to the","        {NotificationElement} instance.","      * `text` {String} inner text for the button","    * `description` (optional) A Markdown {String} containing a longer","      description about the notification. By default, this **will not**","      preserve newlines and whitespace when it is rendered.","    * `detail` (optional) A plain-text {String} containing additional","      details about the notification. By default, this **will** preserve","      newlines and whitespace when it is rendered.","    * `dismissable` (optional) A {Boolean} indicating whether this","      notification can be dismissed by the user. Defaults to `false`.","    * `icon` (optional) A {String} name of an icon from Octicons to display","      in the notification header. Defaults to `'bug'`.","    * `stack` (optional) A preformatted {String} with stack trace","      information describing the location of the error.",""," Returns the {Notification} that was added."],"code":"  addFatalError (message, options) {\r\n    return this.addNotification(new Notification('fatal', message, options))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification-manager.js","name":"NotificationManager.addNotification","start_line":191,"end_line":195,"comment":[],"params":["notification"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"addPanel","line":1770,"func_location":"Workspace.addFooterPanel","func_start_line":1769,"func_end_line":1771,"args":[{"type":"string"},"options"],"comment":[" Essential: Adds a panel item to the footer.",""," * `options` {Object}","   * `item` Your panel content. It can be DOM element, a jQuery element, or","     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the","     latter. See {ViewRegistry::addViewProvider} for more information.","   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden","     (default: true)","   * `priority` (optional) {Number} Determines stacking order. Lower priority items are","     forced closer to the edges of the window. (default: 100)",""," Returns a {Panel}"],"code":"  addFooterPanel (options) {\r\n    return this.addPanel('footer', options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.addPanel","start_line":1816,"end_line":1819,"comment":[],"params":["location","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"grammarAddedOrUpdated","line":465,"func_location":"GrammarRegistry.addGrammar","func_start_line":456,"func_end_line":470,"args":["grammar"],"code":"  addGrammar (grammar) {\r\n    if (grammar instanceof TreeSitterGrammar) {\r\n      const existingParams = this.treeSitterGrammarsById[grammar.scopeName] || {}\r\n      if (grammar.scopeName) this.treeSitterGrammarsById[grammar.scopeName] = grammar\r\n      if (existingParams.injectionPoints) {\r\n        for (const injectionPoint of existingParams.injectionPoints) {\r\n          grammar.addInjectionPoint(injectionPoint)\r\n        }\r\n      }\r\n      this.grammarAddedOrUpdated(grammar)\r\n      return new Disposable(() => this.removeGrammar(grammar))\r\n    } else {\r\n      return this.textmateRegistry.addGrammar(grammar)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.grammarAddedOrUpdated","start_line":365,"end_line":388,"comment":[],"params":["grammar"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/gutter-container.js","name":"gutterWithName","line":32,"func_location":"GutterContainer.addGutter","func_start_line":26,"func_end_line":53,"args":["gutterName"],"code":"  addGutter (options) {\r\n    options = options || {}\r\n    const gutterName = options.name\r\n    if (gutterName === null) {\r\n      throw new Error('A name is required to create a gutter.')\r\n    }\r\n    if (this.gutterWithName(gutterName)) {\r\n      throw new Error('Tried to create a gutter with a name that is already in use.')\r\n    }\r\n    const newGutter = new Gutter(this, options)\r\n\r\n    let inserted = false\r\n    // Insert the gutter into the gutters array, sorted in ascending order by 'priority'.\r\n    // This could be optimized, but there are unlikely to be many gutters.\r\n    for (let i = 0; i < this.gutters.length; i++) {\r\n      if (this.gutters[i].priority >= newGutter.priority) {\r\n        this.gutters.splice(i, 0, newGutter)\r\n        inserted = true\r\n        break\r\n      }\r\n    }\r\n    if (!inserted) {\r\n      this.gutters.push(newGutter)\r\n    }\r\n    this.scheduleComponentUpdate()\r\n    this.emitter.emit('did-add-gutter', newGutter)\r\n    return newGutter\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/gutter-container.js","name":"GutterContainer.gutterWithName","start_line":59,"end_line":64,"comment":[],"params":["name"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/gutter-container.js","name":"scheduleComponentUpdate","line":50,"func_location":"GutterContainer.addGutter","func_start_line":26,"func_end_line":53,"args":[],"code":"  addGutter (options) {\r\n    options = options || {}\r\n    const gutterName = options.name\r\n    if (gutterName === null) {\r\n      throw new Error('A name is required to create a gutter.')\r\n    }\r\n    if (this.gutterWithName(gutterName)) {\r\n      throw new Error('Tried to create a gutter with a name that is already in use.')\r\n    }\r\n    const newGutter = new Gutter(this, options)\r\n\r\n    let inserted = false\r\n    // Insert the gutter into the gutters array, sorted in ascending order by 'priority'.\r\n    // This could be optimized, but there are unlikely to be many gutters.\r\n    for (let i = 0; i < this.gutters.length; i++) {\r\n      if (this.gutters[i].priority >= newGutter.priority) {\r\n        this.gutters.splice(i, 0, newGutter)\r\n        inserted = true\r\n        break\r\n      }\r\n    }\r\n    if (!inserted) {\r\n      this.gutters.push(newGutter)\r\n    }\r\n    this.scheduleComponentUpdate()\r\n    this.emitter.emit('did-add-gutter', newGutter)\r\n    return newGutter\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/gutter-container.js","name":"GutterContainer.scheduleComponentUpdate","start_line":11,"end_line":13,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"addPanel","line":1749,"func_location":"Workspace.addHeaderPanel","func_start_line":1748,"func_end_line":1750,"args":[{"type":"string"},"options"],"comment":[" Essential: Adds a panel item to the header.",""," * `options` {Object}","   * `item` Your panel content. It can be DOM element, a jQuery element, or","     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the","     latter. See {ViewRegistry::addViewProvider} for more information.","   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden","     (default: true)","   * `priority` (optional) {Number} Determines stacking order. Lower priority items are","     forced closer to the edges of the window. (default: 100)",""," Returns a {Panel}"],"code":"  addHeaderPanel (options) {\r\n    return this.addPanel('header', options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.addPanel","start_line":1816,"end_line":1819,"comment":[],"params":["location","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"constrainRangeToRows","line":1091,"func_location":"TextEditorComponent.addHighlightDecorationToMeasure","func_start_line":1090,"func_end_line":1106,"args":["screenRange",null,null],"code":"  addHighlightDecorationToMeasure (decoration, screenRange, key) {\r\n    screenRange = constrainRangeToRows(screenRange, this.getRenderedStartRow(), this.getRenderedEndRow())\r\n    if (screenRange.isEmpty()) return\r\n\r\n    const {class: className, flashRequested, flashClass, flashDuration} = decoration\r\n    decoration.flashRequested = false\r\n    this.decorationsToMeasure.highlights.push({\r\n      screenRange,\r\n      key,\r\n      className,\r\n      flashRequested,\r\n      flashClass,\r\n      flashDuration\r\n    })\r\n    this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n    this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"constrainRangeToRows","start_line":4378,"end_line":4391,"comment":[],"params":["range","startRow","endRow"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedStartRow","line":1091,"func_location":"TextEditorComponent.addHighlightDecorationToMeasure","func_start_line":1090,"func_end_line":1106,"args":["screenRange",null,null],"code":"  addHighlightDecorationToMeasure (decoration, screenRange, key) {\r\n    screenRange = constrainRangeToRows(screenRange, this.getRenderedStartRow(), this.getRenderedEndRow())\r\n    if (screenRange.isEmpty()) return\r\n\r\n    const {class: className, flashRequested, flashClass, flashDuration} = decoration\r\n    decoration.flashRequested = false\r\n    this.decorationsToMeasure.highlights.push({\r\n      screenRange,\r\n      key,\r\n      className,\r\n      flashRequested,\r\n      flashClass,\r\n      flashDuration\r\n    })\r\n    this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n    this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedStartRow","start_line":2720,"end_line":2726,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedEndRow","line":1091,"func_location":"TextEditorComponent.addHighlightDecorationToMeasure","func_start_line":1090,"func_end_line":1106,"args":["screenRange",null,null],"code":"  addHighlightDecorationToMeasure (decoration, screenRange, key) {\r\n    screenRange = constrainRangeToRows(screenRange, this.getRenderedStartRow(), this.getRenderedEndRow())\r\n    if (screenRange.isEmpty()) return\r\n\r\n    const {class: className, flashRequested, flashClass, flashDuration} = decoration\r\n    decoration.flashRequested = false\r\n    this.decorationsToMeasure.highlights.push({\r\n      screenRange,\r\n      key,\r\n      className,\r\n      flashRequested,\r\n      flashClass,\r\n      flashDuration\r\n    })\r\n    this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n    this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedEndRow","start_line":2728,"end_line":2737,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"requestHorizontalMeasurement","line":1104,"func_location":"TextEditorComponent.addHighlightDecorationToMeasure","func_start_line":1090,"func_end_line":1106,"args":["screenRange.start.row","screenRange.start.column"],"code":"  addHighlightDecorationToMeasure (decoration, screenRange, key) {\r\n    screenRange = constrainRangeToRows(screenRange, this.getRenderedStartRow(), this.getRenderedEndRow())\r\n    if (screenRange.isEmpty()) return\r\n\r\n    const {class: className, flashRequested, flashClass, flashDuration} = decoration\r\n    decoration.flashRequested = false\r\n    this.decorationsToMeasure.highlights.push({\r\n      screenRange,\r\n      key,\r\n      className,\r\n      flashRequested,\r\n      flashClass,\r\n      flashDuration\r\n    })\r\n    this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n    this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.requestHorizontalMeasurement","start_line":2243,"end_line":2257,"comment":[],"params":["row","column"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"requestHorizontalMeasurement","line":1105,"func_location":"TextEditorComponent.addHighlightDecorationToMeasure","func_start_line":1090,"func_end_line":1106,"args":["screenRange.end.row","screenRange.end.column"],"code":"  addHighlightDecorationToMeasure (decoration, screenRange, key) {\r\n    screenRange = constrainRangeToRows(screenRange, this.getRenderedStartRow(), this.getRenderedEndRow())\r\n    if (screenRange.isEmpty()) return\r\n\r\n    const {class: className, flashRequested, flashClass, flashDuration} = decoration\r\n    decoration.flashRequested = false\r\n    this.decorationsToMeasure.highlights.push({\r\n      screenRange,\r\n      key,\r\n      className,\r\n      flashRequested,\r\n      flashClass,\r\n      flashDuration\r\n    })\r\n    this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n    this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.requestHorizontalMeasurement","start_line":2243,"end_line":2257,"comment":[],"params":["row","column"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification-manager.js","name":"addNotification","line":96,"func_location":"NotificationManager.addInfo","func_start_line":95,"func_end_line":97,"args":[null],"comment":[" Public: Add an informational notification.",""," * `message` A {String} message"," * `options` (optional) An options {Object} with the following keys:","    * `buttons` (optional) An {Array} of {Object} where each {Object} has","      the following options:","      * `className` (optional) {String} a class name to add to the button's","        default class name (`btn btn-info`).","      * `onDidClick` (optional) {Function} callback to call when the button","        has been clicked. The context will be set to the","        {NotificationElement} instance.","      * `text` {String} inner text for the button","    * `description` (optional) A Markdown {String} containing a longer","      description about the notification. By default, this **will not**","      preserve newlines and whitespace when it is rendered.","    * `detail` (optional) A plain-text {String} containing additional","      details about the notification. By default, this **will** preserve","      newlines and whitespace when it is rendered.","    * `dismissable` (optional) A {Boolean} indicating whether this","      notification can be dismissed by the user. Defaults to `false`.","    * `icon` (optional) A {String} name of an icon from Octicons to display","      in the notification header. Defaults to `'info'`.",""," Returns the {Notification} that was added."],"code":"  addInfo (message, options) {\r\n    return this.addNotification(new Notification('info', message, options))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification-manager.js","name":"NotificationManager.addNotification","start_line":191,"end_line":195,"comment":[],"params":["notification"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js","name":"commandRegistered","line":197,"func_location":"CommandRegistry.addInlineListener","func_start_line":183,"func_end_line":205,"args":["commandName"],"code":"  addInlineListener (element, commandName, listener) {\r\n    if (this.inlineListenersByCommandName[commandName] == null) {\r\n      this.inlineListenersByCommandName[commandName] = new WeakMap()\r\n    }\r\n\r\n    const listenersForCommand = this.inlineListenersByCommandName[commandName]\r\n    let listenersForElement = listenersForCommand.get(element)\r\n    if (!listenersForElement) {\r\n      listenersForElement = []\r\n      listenersForCommand.set(element, listenersForElement)\r\n    }\r\n    const inlineListener = new InlineListener(commandName, listener)\r\n    listenersForElement.push(inlineListener)\r\n\r\n    this.commandRegistered(commandName)\r\n\r\n    return new Disposable(() => {\r\n      listenersForElement.splice(listenersForElement.indexOf(inlineListener), 1)\r\n      if (listenersForElement.length === 0) {\r\n        listenersForCommand.delete(element)\r\n      }\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js","name":"CommandRegistry.commandRegistered","start_line":401,"end_line":406,"comment":[],"params":["commandName"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/item-registry.js","name":"hasItem","line":8,"func_location":"ItemRegistry.addItem","func_start_line":7,"func_end_line":12,"args":["item"],"code":"  addItem (item) {\r\n    if (this.hasItem(item)) {\r\n      throw new Error(`The workspace can only contain one instance of item ${item}`)\r\n    }\r\n    return this.items.add(item)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/item-registry.js","name":"ItemRegistry.hasItem","start_line":18,"end_line":20,"comment":[],"params":["item"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getActiveItemIndex","line":603,"func_location":"Pane.addItem","func_start_line":595,"func_end_line":642,"args":[],"comment":[" Public: Add the given item to the pane.",""," * `item` The item to add. It can be a model with an associated view or a","   view."," * `options` (optional) {Object}","   * `index` (optional) {Number} indicating the index at which to add the item.","     If omitted, the item is added after the current active item.","   * `pending` (optional) {Boolean} indicating that the item should be","     added in a pending state. Existing pending items in a pane are replaced with","     new pending items when they are opened.",""," Returns the added item."],"code":"  addItem (item, options = {}) {\r\n    // Backward compat with old API:\r\n    //   addItem(item, index=@getActiveItemIndex() + 1)\r\n    if (typeof options === 'number') {\r\n      Grim.deprecate(`Pane::addItem(item, ${options}) is deprecated in favor of Pane::addItem(item, {index: ${options}})`)\r\n      options = {index: options}\r\n    }\r\n\r\n    const index = options.index != null ? options.index : this.getActiveItemIndex() + 1\r\n    const moved = options.moved != null ? options.moved : false\r\n    const pending = options.pending != null ? options.pending : false\r\n\r\n    if (!item || typeof item !== 'object') {\r\n      throw new Error(`Pane items must be objects. Attempted to add item ${item}.`)\r\n    }\r\n\r\n    if (typeof item.isDestroyed === 'function' && item.isDestroyed()) {\r\n      throw new Error(`Adding a pane item with URI '${typeof item.getURI === 'function' && item.getURI()}' that has already been destroyed`)\r\n    }\r\n\r\n    if (this.items.includes(item)) return\r\n\r\n    const itemSubscriptions = new CompositeDisposable()\r\n    this.subscriptionsPerItem.set(item, itemSubscriptions)\r\n    if (typeof item.onDidDestroy === 'function') {\r\n      itemSubscriptions.add(item.onDidDestroy(() => this.removeItem(item, false)))\r\n    }\r\n    if (typeof item.onDidTerminatePendingState === 'function') {\r\n      itemSubscriptions.add(item.onDidTerminatePendingState(() => {\r\n        if (this.getPendingItem() === item) this.clearPendingItem()\r\n      }))\r\n    }\r\n\r\n    this.items.splice(index, 0, item)\r\n    const lastPendingItem = this.getPendingItem()\r\n    const replacingPendingItem = lastPendingItem != null && !moved\r\n    if (replacingPendingItem) this.pendingItem = null\r\n    if (pending) this.setPendingItem(item)\r\n\r\n    this.emitter.emit('did-add-item', {item, index, moved})\r\n    if (!moved) {\r\n      if (this.container) this.container.didAddPaneItem(item, this, index)\r\n    }\r\n\r\n    if (replacingPendingItem) this.destroyItem(lastPendingItem)\r\n    if (!this.getActiveItem()) this.setActiveItem(item)\r\n    return item\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getActiveItemIndex","start_line":553,"end_line":555,"comment":[" Public: Get the index of the active item.",""," Returns a {Number}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getPendingItem","line":629,"func_location":"Pane.addItem","func_start_line":595,"func_end_line":642,"args":[],"comment":[" Public: Add the given item to the pane.",""," * `item` The item to add. It can be a model with an associated view or a","   view."," * `options` (optional) {Object}","   * `index` (optional) {Number} indicating the index at which to add the item.","     If omitted, the item is added after the current active item.","   * `pending` (optional) {Boolean} indicating that the item should be","     added in a pending state. Existing pending items in a pane are replaced with","     new pending items when they are opened.",""," Returns the added item."],"code":"  addItem (item, options = {}) {\r\n    // Backward compat with old API:\r\n    //   addItem(item, index=@getActiveItemIndex() + 1)\r\n    if (typeof options === 'number') {\r\n      Grim.deprecate(`Pane::addItem(item, ${options}) is deprecated in favor of Pane::addItem(item, {index: ${options}})`)\r\n      options = {index: options}\r\n    }\r\n\r\n    const index = options.index != null ? options.index : this.getActiveItemIndex() + 1\r\n    const moved = options.moved != null ? options.moved : false\r\n    const pending = options.pending != null ? options.pending : false\r\n\r\n    if (!item || typeof item !== 'object') {\r\n      throw new Error(`Pane items must be objects. Attempted to add item ${item}.`)\r\n    }\r\n\r\n    if (typeof item.isDestroyed === 'function' && item.isDestroyed()) {\r\n      throw new Error(`Adding a pane item with URI '${typeof item.getURI === 'function' && item.getURI()}' that has already been destroyed`)\r\n    }\r\n\r\n    if (this.items.includes(item)) return\r\n\r\n    const itemSubscriptions = new CompositeDisposable()\r\n    this.subscriptionsPerItem.set(item, itemSubscriptions)\r\n    if (typeof item.onDidDestroy === 'function') {\r\n      itemSubscriptions.add(item.onDidDestroy(() => this.removeItem(item, false)))\r\n    }\r\n    if (typeof item.onDidTerminatePendingState === 'function') {\r\n      itemSubscriptions.add(item.onDidTerminatePendingState(() => {\r\n        if (this.getPendingItem() === item) this.clearPendingItem()\r\n      }))\r\n    }\r\n\r\n    this.items.splice(index, 0, item)\r\n    const lastPendingItem = this.getPendingItem()\r\n    const replacingPendingItem = lastPendingItem != null && !moved\r\n    if (replacingPendingItem) this.pendingItem = null\r\n    if (pending) this.setPendingItem(item)\r\n\r\n    this.emitter.emit('did-add-item', {item, index, moved})\r\n    if (!moved) {\r\n      if (this.container) this.container.didAddPaneItem(item, this, index)\r\n    }\r\n\r\n    if (replacingPendingItem) this.destroyItem(lastPendingItem)\r\n    if (!this.getActiveItem()) this.setActiveItem(item)\r\n    return item\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getPendingItem","start_line":654,"end_line":656,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"setPendingItem","line":632,"func_location":"Pane.addItem","func_start_line":595,"func_end_line":642,"args":["item"],"comment":[" Public: Add the given item to the pane.",""," * `item` The item to add. It can be a model with an associated view or a","   view."," * `options` (optional) {Object}","   * `index` (optional) {Number} indicating the index at which to add the item.","     If omitted, the item is added after the current active item.","   * `pending` (optional) {Boolean} indicating that the item should be","     added in a pending state. Existing pending items in a pane are replaced with","     new pending items when they are opened.",""," Returns the added item."],"code":"  addItem (item, options = {}) {\r\n    // Backward compat with old API:\r\n    //   addItem(item, index=@getActiveItemIndex() + 1)\r\n    if (typeof options === 'number') {\r\n      Grim.deprecate(`Pane::addItem(item, ${options}) is deprecated in favor of Pane::addItem(item, {index: ${options}})`)\r\n      options = {index: options}\r\n    }\r\n\r\n    const index = options.index != null ? options.index : this.getActiveItemIndex() + 1\r\n    const moved = options.moved != null ? options.moved : false\r\n    const pending = options.pending != null ? options.pending : false\r\n\r\n    if (!item || typeof item !== 'object') {\r\n      throw new Error(`Pane items must be objects. Attempted to add item ${item}.`)\r\n    }\r\n\r\n    if (typeof item.isDestroyed === 'function' && item.isDestroyed()) {\r\n      throw new Error(`Adding a pane item with URI '${typeof item.getURI === 'function' && item.getURI()}' that has already been destroyed`)\r\n    }\r\n\r\n    if (this.items.includes(item)) return\r\n\r\n    const itemSubscriptions = new CompositeDisposable()\r\n    this.subscriptionsPerItem.set(item, itemSubscriptions)\r\n    if (typeof item.onDidDestroy === 'function') {\r\n      itemSubscriptions.add(item.onDidDestroy(() => this.removeItem(item, false)))\r\n    }\r\n    if (typeof item.onDidTerminatePendingState === 'function') {\r\n      itemSubscriptions.add(item.onDidTerminatePendingState(() => {\r\n        if (this.getPendingItem() === item) this.clearPendingItem()\r\n      }))\r\n    }\r\n\r\n    this.items.splice(index, 0, item)\r\n    const lastPendingItem = this.getPendingItem()\r\n    const replacingPendingItem = lastPendingItem != null && !moved\r\n    if (replacingPendingItem) this.pendingItem = null\r\n    if (pending) this.setPendingItem(item)\r\n\r\n    this.emitter.emit('did-add-item', {item, index, moved})\r\n    if (!moved) {\r\n      if (this.container) this.container.didAddPaneItem(item, this, index)\r\n    }\r\n\r\n    if (replacingPendingItem) this.destroyItem(lastPendingItem)\r\n    if (!this.getActiveItem()) this.setActiveItem(item)\r\n    return item\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.setPendingItem","start_line":644,"end_line":652,"comment":[],"params":["item"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"destroyItem","line":639,"func_location":"Pane.addItem","func_start_line":595,"func_end_line":642,"args":["lastPendingItem"],"comment":[" Public: Add the given item to the pane.",""," * `item` The item to add. It can be a model with an associated view or a","   view."," * `options` (optional) {Object}","   * `index` (optional) {Number} indicating the index at which to add the item.","     If omitted, the item is added after the current active item.","   * `pending` (optional) {Boolean} indicating that the item should be","     added in a pending state. Existing pending items in a pane are replaced with","     new pending items when they are opened.",""," Returns the added item."],"code":"  addItem (item, options = {}) {\r\n    // Backward compat with old API:\r\n    //   addItem(item, index=@getActiveItemIndex() + 1)\r\n    if (typeof options === 'number') {\r\n      Grim.deprecate(`Pane::addItem(item, ${options}) is deprecated in favor of Pane::addItem(item, {index: ${options}})`)\r\n      options = {index: options}\r\n    }\r\n\r\n    const index = options.index != null ? options.index : this.getActiveItemIndex() + 1\r\n    const moved = options.moved != null ? options.moved : false\r\n    const pending = options.pending != null ? options.pending : false\r\n\r\n    if (!item || typeof item !== 'object') {\r\n      throw new Error(`Pane items must be objects. Attempted to add item ${item}.`)\r\n    }\r\n\r\n    if (typeof item.isDestroyed === 'function' && item.isDestroyed()) {\r\n      throw new Error(`Adding a pane item with URI '${typeof item.getURI === 'function' && item.getURI()}' that has already been destroyed`)\r\n    }\r\n\r\n    if (this.items.includes(item)) return\r\n\r\n    const itemSubscriptions = new CompositeDisposable()\r\n    this.subscriptionsPerItem.set(item, itemSubscriptions)\r\n    if (typeof item.onDidDestroy === 'function') {\r\n      itemSubscriptions.add(item.onDidDestroy(() => this.removeItem(item, false)))\r\n    }\r\n    if (typeof item.onDidTerminatePendingState === 'function') {\r\n      itemSubscriptions.add(item.onDidTerminatePendingState(() => {\r\n        if (this.getPendingItem() === item) this.clearPendingItem()\r\n      }))\r\n    }\r\n\r\n    this.items.splice(index, 0, item)\r\n    const lastPendingItem = this.getPendingItem()\r\n    const replacingPendingItem = lastPendingItem != null && !moved\r\n    if (replacingPendingItem) this.pendingItem = null\r\n    if (pending) this.setPendingItem(item)\r\n\r\n    this.emitter.emit('did-add-item', {item, index, moved})\r\n    if (!moved) {\r\n      if (this.container) this.container.didAddPaneItem(item, this, index)\r\n    }\r\n\r\n    if (replacingPendingItem) this.destroyItem(lastPendingItem)\r\n    if (!this.getActiveItem()) this.setActiveItem(item)\r\n    return item\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.destroyItem","start_line":757,"end_line":782,"comment":[" Public: Destroy the given item.",""," If the item is active, the next item will be activated. If the item is the"," last item, the pane will be destroyed if the `core.destroyEmptyPanes` config"," setting is `true`.",""," * `item` Item to destroy"," * `force` (optional) {Boolean} Destroy the item without prompting to save","    it, even if the item's `isPermanentDockItem` method returns true.",""," Returns a {Promise} that resolves with a {Boolean} indicating whether or not"," the item was destroyed."],"params":["item","force"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getActiveItem","line":640,"func_location":"Pane.addItem","func_start_line":595,"func_end_line":642,"args":[],"comment":[" Public: Add the given item to the pane.",""," * `item` The item to add. It can be a model with an associated view or a","   view."," * `options` (optional) {Object}","   * `index` (optional) {Number} indicating the index at which to add the item.","     If omitted, the item is added after the current active item.","   * `pending` (optional) {Boolean} indicating that the item should be","     added in a pending state. Existing pending items in a pane are replaced with","     new pending items when they are opened.",""," Returns the added item."],"code":"  addItem (item, options = {}) {\r\n    // Backward compat with old API:\r\n    //   addItem(item, index=@getActiveItemIndex() + 1)\r\n    if (typeof options === 'number') {\r\n      Grim.deprecate(`Pane::addItem(item, ${options}) is deprecated in favor of Pane::addItem(item, {index: ${options}})`)\r\n      options = {index: options}\r\n    }\r\n\r\n    const index = options.index != null ? options.index : this.getActiveItemIndex() + 1\r\n    const moved = options.moved != null ? options.moved : false\r\n    const pending = options.pending != null ? options.pending : false\r\n\r\n    if (!item || typeof item !== 'object') {\r\n      throw new Error(`Pane items must be objects. Attempted to add item ${item}.`)\r\n    }\r\n\r\n    if (typeof item.isDestroyed === 'function' && item.isDestroyed()) {\r\n      throw new Error(`Adding a pane item with URI '${typeof item.getURI === 'function' && item.getURI()}' that has already been destroyed`)\r\n    }\r\n\r\n    if (this.items.includes(item)) return\r\n\r\n    const itemSubscriptions = new CompositeDisposable()\r\n    this.subscriptionsPerItem.set(item, itemSubscriptions)\r\n    if (typeof item.onDidDestroy === 'function') {\r\n      itemSubscriptions.add(item.onDidDestroy(() => this.removeItem(item, false)))\r\n    }\r\n    if (typeof item.onDidTerminatePendingState === 'function') {\r\n      itemSubscriptions.add(item.onDidTerminatePendingState(() => {\r\n        if (this.getPendingItem() === item) this.clearPendingItem()\r\n      }))\r\n    }\r\n\r\n    this.items.splice(index, 0, item)\r\n    const lastPendingItem = this.getPendingItem()\r\n    const replacingPendingItem = lastPendingItem != null && !moved\r\n    if (replacingPendingItem) this.pendingItem = null\r\n    if (pending) this.setPendingItem(item)\r\n\r\n    this.emitter.emit('did-add-item', {item, index, moved})\r\n    if (!moved) {\r\n      if (this.container) this.container.didAddPaneItem(item, this, index)\r\n    }\r\n\r\n    if (replacingPendingItem) this.destroyItem(lastPendingItem)\r\n    if (!this.getActiveItem()) this.setActiveItem(item)\r\n    return item\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getActiveItem","start_line":432,"end_line":432,"comment":[" Public: Get the active pane item in this pane.",""," Returns a pane item."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"setActiveItem","line":640,"func_location":"Pane.addItem","func_start_line":595,"func_end_line":642,"args":[],"comment":[" Public: Add the given item to the pane.",""," * `item` The item to add. It can be a model with an associated view or a","   view."," * `options` (optional) {Object}","   * `index` (optional) {Number} indicating the index at which to add the item.","     If omitted, the item is added after the current active item.","   * `pending` (optional) {Boolean} indicating that the item should be","     added in a pending state. Existing pending items in a pane are replaced with","     new pending items when they are opened.",""," Returns the added item."],"code":"  addItem (item, options = {}) {\r\n    // Backward compat with old API:\r\n    //   addItem(item, index=@getActiveItemIndex() + 1)\r\n    if (typeof options === 'number') {\r\n      Grim.deprecate(`Pane::addItem(item, ${options}) is deprecated in favor of Pane::addItem(item, {index: ${options}})`)\r\n      options = {index: options}\r\n    }\r\n\r\n    const index = options.index != null ? options.index : this.getActiveItemIndex() + 1\r\n    const moved = options.moved != null ? options.moved : false\r\n    const pending = options.pending != null ? options.pending : false\r\n\r\n    if (!item || typeof item !== 'object') {\r\n      throw new Error(`Pane items must be objects. Attempted to add item ${item}.`)\r\n    }\r\n\r\n    if (typeof item.isDestroyed === 'function' && item.isDestroyed()) {\r\n      throw new Error(`Adding a pane item with URI '${typeof item.getURI === 'function' && item.getURI()}' that has already been destroyed`)\r\n    }\r\n\r\n    if (this.items.includes(item)) return\r\n\r\n    const itemSubscriptions = new CompositeDisposable()\r\n    this.subscriptionsPerItem.set(item, itemSubscriptions)\r\n    if (typeof item.onDidDestroy === 'function') {\r\n      itemSubscriptions.add(item.onDidDestroy(() => this.removeItem(item, false)))\r\n    }\r\n    if (typeof item.onDidTerminatePendingState === 'function') {\r\n      itemSubscriptions.add(item.onDidTerminatePendingState(() => {\r\n        if (this.getPendingItem() === item) this.clearPendingItem()\r\n      }))\r\n    }\r\n\r\n    this.items.splice(index, 0, item)\r\n    const lastPendingItem = this.getPendingItem()\r\n    const replacingPendingItem = lastPendingItem != null && !moved\r\n    if (replacingPendingItem) this.pendingItem = null\r\n    if (pending) this.setPendingItem(item)\r\n\r\n    this.emitter.emit('did-add-item', {item, index, moved})\r\n    if (!moved) {\r\n      if (this.container) this.container.didAddPaneItem(item, this, index)\r\n    }\r\n\r\n    if (replacingPendingItem) this.destroyItem(lastPendingItem)\r\n    if (!this.getActiveItem()) this.setActiveItem(item)\r\n    return item\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.setActiveItem","start_line":434,"end_line":443,"comment":[],"params":["activeItem","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"addItem","line":679,"func_location":"Pane.addItems","func_start_line":675,"func_end_line":682,"args":["item",null],"comment":[" Public: Add the given items to the pane.",""," * `items` An {Array} of items to add. Items can be views or models with","   associated views. Any objects that are already present in the pane's","   current items will not be added again."," * `index` (optional) {Number} index at which to add the items. If omitted,","   the item is #   added after the current active item.",""," Returns an {Array} of added items."],"code":"  addItems (items, index = this.getActiveItemIndex() + 1) {\r\n    items = items.filter(item => !this.items.includes(item))\r\n    for (let i = 0; i < items.length; i++) {\r\n      const item = items[i]\r\n      this.addItem(item, {index: index + i})\r\n    }\r\n    return items\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.addItem","start_line":595,"end_line":642,"comment":[" Public: Add the given item to the pane.",""," * `item` The item to add. It can be a model with an associated view or a","   view."," * `options` (optional) {Object}","   * `index` (optional) {Number} indicating the index at which to add the item.","     If omitted, the item is added after the current active item.","   * `pending` (optional) {Boolean} indicating that the item should be","     added in a pending state. Existing pending items in a pane are replaced with","     new pending items when they are opened.",""," Returns the added item."],"params":["item","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"addItemToStack","line":453,"func_location":"Pane.addItemsToStack","func_start_line":446,"func_end_line":456,"args":[".items.itemIndex"],"comment":[" Build the itemStack after deserializing"],"code":"  addItemsToStack (itemStackIndices) {\r\n    if (this.items.length > 0) {\r\n      if (itemStackIndices.length !== this.items.length || itemStackIndices.includes(-1)) {\r\n        itemStackIndices = this.items.map((item, i) => i)\r\n      }\r\n\r\n      for (let itemIndex of itemStackIndices) {\r\n        this.addItemToStack(this.items[itemIndex])\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.addItemToStack","start_line":459,"end_line":464,"comment":[" Add item (or move item) to the end of the itemStack"],"params":["newItem"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"addPanel","line":1686,"func_location":"Workspace.addLeftPanel","func_start_line":1685,"func_end_line":1687,"args":[{"type":"string"},"options"],"comment":[" Essential: Adds a panel item to the left of the editor window.",""," * `options` {Object}","   * `item` Your panel content. It can be DOM element, a jQuery element, or","     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the","     latter. See {ViewRegistry::addViewProvider} for more information.","   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden","     (default: true)","   * `priority` (optional) {Number} Determines stacking order. Lower priority items are","     forced closer to the edges of the window. (default: 100)",""," Returns a {Panel}"],"code":"  addLeftPanel (options) {\r\n    return this.addPanel('left', options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.addPanel","start_line":1816,"end_line":1819,"comment":[],"params":["location","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedStartRow","line":1067,"func_location":"TextEditorComponent.addLineDecorationToRender","func_start_line":1044,"func_end_line":1088,"args":[],"code":"  addLineDecorationToRender (type, decoration, screenRange, reversed) {\r\n    let decorationsToRender\r\n    if (type === 'line') {\r\n      decorationsToRender = this.decorationsToRender.lines\r\n    } else {\r\n      const gutterName = decoration.gutterName || 'line-number'\r\n      decorationsToRender = this.decorationsToRender.lineNumbers.get(gutterName)\r\n      if (!decorationsToRender) {\r\n        decorationsToRender = []\r\n        this.decorationsToRender.lineNumbers.set(gutterName, decorationsToRender)\r\n      }\r\n    }\r\n\r\n    let omitLastRow = false\r\n    if (screenRange.isEmpty()) {\r\n      if (decoration.onlyNonEmpty) return\r\n    } else {\r\n      if (decoration.onlyEmpty) return\r\n      if (decoration.omitEmptyLastRow !== false) {\r\n        omitLastRow = screenRange.end.column === 0\r\n      }\r\n    }\r\n\r\n    const renderedStartRow = this.getRenderedStartRow()\r\n    let rangeStartRow = screenRange.start.row\r\n    let rangeEndRow = screenRange.end.row\r\n\r\n    if (decoration.onlyHead) {\r\n      if (reversed) {\r\n        rangeEndRow = rangeStartRow\r\n      } else {\r\n        rangeStartRow = rangeEndRow\r\n      }\r\n    }\r\n\r\n    rangeStartRow = Math.max(rangeStartRow, this.getRenderedStartRow())\r\n    rangeEndRow = Math.min(rangeEndRow, this.getRenderedEndRow() - 1)\r\n\r\n    for (let row = rangeStartRow; row <= rangeEndRow; row++) {\r\n      if (omitLastRow && row === screenRange.end.row) break\r\n      const currentClassName = decorationsToRender[row - renderedStartRow]\r\n      const newClassName = currentClassName ? currentClassName + ' ' + decoration.class : decoration.class\r\n      decorationsToRender[row - renderedStartRow] = newClassName\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedStartRow","start_line":2720,"end_line":2726,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedStartRow","line":1079,"func_location":"TextEditorComponent.addLineDecorationToRender","func_start_line":1044,"func_end_line":1088,"args":["rangeStartRow",null],"code":"  addLineDecorationToRender (type, decoration, screenRange, reversed) {\r\n    let decorationsToRender\r\n    if (type === 'line') {\r\n      decorationsToRender = this.decorationsToRender.lines\r\n    } else {\r\n      const gutterName = decoration.gutterName || 'line-number'\r\n      decorationsToRender = this.decorationsToRender.lineNumbers.get(gutterName)\r\n      if (!decorationsToRender) {\r\n        decorationsToRender = []\r\n        this.decorationsToRender.lineNumbers.set(gutterName, decorationsToRender)\r\n      }\r\n    }\r\n\r\n    let omitLastRow = false\r\n    if (screenRange.isEmpty()) {\r\n      if (decoration.onlyNonEmpty) return\r\n    } else {\r\n      if (decoration.onlyEmpty) return\r\n      if (decoration.omitEmptyLastRow !== false) {\r\n        omitLastRow = screenRange.end.column === 0\r\n      }\r\n    }\r\n\r\n    const renderedStartRow = this.getRenderedStartRow()\r\n    let rangeStartRow = screenRange.start.row\r\n    let rangeEndRow = screenRange.end.row\r\n\r\n    if (decoration.onlyHead) {\r\n      if (reversed) {\r\n        rangeEndRow = rangeStartRow\r\n      } else {\r\n        rangeStartRow = rangeEndRow\r\n      }\r\n    }\r\n\r\n    rangeStartRow = Math.max(rangeStartRow, this.getRenderedStartRow())\r\n    rangeEndRow = Math.min(rangeEndRow, this.getRenderedEndRow() - 1)\r\n\r\n    for (let row = rangeStartRow; row <= rangeEndRow; row++) {\r\n      if (omitLastRow && row === screenRange.end.row) break\r\n      const currentClassName = decorationsToRender[row - renderedStartRow]\r\n      const newClassName = currentClassName ? currentClassName + ' ' + decoration.class : decoration.class\r\n      decorationsToRender[row - renderedStartRow] = newClassName\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedStartRow","start_line":2720,"end_line":2726,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedEndRow","line":1080,"func_location":"TextEditorComponent.addLineDecorationToRender","func_start_line":1044,"func_end_line":1088,"args":["rangeEndRow",null],"code":"  addLineDecorationToRender (type, decoration, screenRange, reversed) {\r\n    let decorationsToRender\r\n    if (type === 'line') {\r\n      decorationsToRender = this.decorationsToRender.lines\r\n    } else {\r\n      const gutterName = decoration.gutterName || 'line-number'\r\n      decorationsToRender = this.decorationsToRender.lineNumbers.get(gutterName)\r\n      if (!decorationsToRender) {\r\n        decorationsToRender = []\r\n        this.decorationsToRender.lineNumbers.set(gutterName, decorationsToRender)\r\n      }\r\n    }\r\n\r\n    let omitLastRow = false\r\n    if (screenRange.isEmpty()) {\r\n      if (decoration.onlyNonEmpty) return\r\n    } else {\r\n      if (decoration.onlyEmpty) return\r\n      if (decoration.omitEmptyLastRow !== false) {\r\n        omitLastRow = screenRange.end.column === 0\r\n      }\r\n    }\r\n\r\n    const renderedStartRow = this.getRenderedStartRow()\r\n    let rangeStartRow = screenRange.start.row\r\n    let rangeEndRow = screenRange.end.row\r\n\r\n    if (decoration.onlyHead) {\r\n      if (reversed) {\r\n        rangeEndRow = rangeStartRow\r\n      } else {\r\n        rangeStartRow = rangeEndRow\r\n      }\r\n    }\r\n\r\n    rangeStartRow = Math.max(rangeStartRow, this.getRenderedStartRow())\r\n    rangeEndRow = Math.min(rangeEndRow, this.getRenderedEndRow() - 1)\r\n\r\n    for (let row = rangeStartRow; row <= rangeEndRow; row++) {\r\n      if (omitLastRow && row === screenRange.end.row) break\r\n      const currentClassName = decorationsToRender[row - renderedStartRow]\r\n      const newClassName = currentClassName ? currentClassName + ' ' + decoration.class : decoration.class\r\n      decorationsToRender[row - renderedStartRow] = newClassName\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedEndRow","start_line":2728,"end_line":2737,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"addPanel","line":1796,"func_location":"Workspace.addModalPanel","func_start_line":1795,"func_end_line":1797,"args":[{"type":"string"},"options"],"comment":[" Essential: Adds a panel item as a modal dialog.",""," * `options` {Object}","   * `item` Your panel content. It can be a DOM element, a jQuery element, or","     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the","     model option. See {ViewRegistry::addViewProvider} for more information.","   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden","     (default: true)","   * `priority` (optional) {Number} Determines stacking order. Lower priority items are","     forced closer to the edges of the window. (default: 100)","   * `autoFocus` (optional) {Boolean} true if you want modal focus managed for you by Atom.","     Atom will automatically focus your modal panel's first tabbable element when the modal","     opens and will restore the previously selected element when the modal closes. Atom will","     also automatically restrict user tab focus within your modal while it is open.","     (default: false)",""," Returns a {Panel}"],"code":"  addModalPanel (options = {}) {\r\n    return this.addPanel('modal', options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.addPanel","start_line":1816,"end_line":1819,"comment":[],"params":["location","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"requestHorizontalMeasurement","line":1154,"func_location":"TextEditorComponent.addOverlayDecorationToRender","func_start_line":1147,"func_end_line":1156,"args":["screenPosition.row","screenPosition.column"],"code":"  addOverlayDecorationToRender (decoration, marker) {\r\n    const {class: className, item, position, avoidOverflow} = decoration\r\n    const element = TextEditor.viewForItem(item)\r\n    const screenPosition = (position === 'tail')\r\n      ? marker.getTailScreenPosition()\r\n      : marker.getHeadScreenPosition()\r\n\r\n    this.requestHorizontalMeasurement(screenPosition.row, screenPosition.column)\r\n    this.decorationsToRender.overlays.push({className, element, avoidOverflow, screenPosition})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.requestHorizontalMeasurement","start_line":2243,"end_line":2257,"comment":[],"params":["row","column"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/panel-container.js","name":"getPanelIndex","line":59,"func_location":"PanelContainer.addPanel","func_start_line":56,"func_end_line":68,"args":["panel"],"code":"  addPanel (panel) {\r\n    this.subscriptions.add(panel.onDidDestroy(this.panelDestroyed.bind(this)))\r\n\r\n    const index = this.getPanelIndex(panel)\r\n    if (index === this.panels.length) {\r\n      this.panels.push(panel)\r\n    } else {\r\n      this.panels.splice(index, 0, panel)\r\n    }\r\n\r\n    this.emitter.emit('did-add-panel', {panel, index})\r\n    return panel\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/panel-container.js","name":"PanelContainer.getPanelIndex","start_line":85,"end_line":100,"comment":[],"params":["panel"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"getDirectoryForProjectPath","line":382,"func_location":"Project.addPath","func_start_line":381,"func_end_line":442,"args":["projectPath"],"comment":[" Public: Add a path to the project's list of root paths",""," * `projectPath` {String} The path to the directory to add."," * `options` An optional {Object} that may contain the following keys:","   * `mustExist` If `true`, throw an Error if the `projectPath` does not exist. If `false`, a `projectPath` that does","     not exist is ignored. Default: `false`.","   * `exact` If `true`, only add `projectPath` if it names an existing directory. If `false`, if `projectPath` is a","     a file or does not exist, its parent directory will be added instead."],"code":"  addPath (projectPath, options = {}) {\r\n    const directory = this.getDirectoryForProjectPath(projectPath)\r\n    let ok = true\r\n    if (options.exact === true) {\r\n      ok = (directory.getPath() === projectPath)\r\n    }\r\n    ok = ok && directory.existsSync()\r\n\r\n    if (!ok) {\r\n      if (options.mustExist === true) {\r\n        const err = new Error(`Project directory ${directory} does not exist`)\r\n        err.missingProjectPaths = [projectPath]\r\n        throw err\r\n      } else {\r\n        return\r\n      }\r\n    }\r\n\r\n    for (let existingDirectory of this.getDirectories()) {\r\n      if (existingDirectory.getPath() === directory.getPath()) { return }\r\n    }\r\n\r\n    this.rootDirectories.push(directory)\r\n\r\n    const didChangeCallback = events => {\r\n      // Stop event delivery immediately on removal of a rootDirectory, even if its watcher\r\n      // promise has yet to resolve at the time of removal\r\n      if (this.rootDirectories.includes(directory)) {\r\n        this.emitter.emit('did-change-files', events)\r\n      }\r\n    }\r\n\r\n    // We'll use the directory's custom onDidChangeFiles callback, if available.\r\n    // CustomDirectory::onDidChangeFiles should match the signature of\r\n    // Project::onDidChangeFiles below (although it may resolve asynchronously)\r\n    this.watcherPromisesByPath[directory.getPath()] =\r\n      directory.onDidChangeFiles != null\r\n        ? Promise.resolve(directory.onDidChangeFiles(didChangeCallback))\r\n        : watchPath(directory.getPath(), {}, didChangeCallback)\r\n\r\n    for (let watchedPath in this.watcherPromisesByPath) {\r\n      if (!this.rootDirectories.find(dir => dir.getPath() === watchedPath)) {\r\n        this.watcherPromisesByPath[watchedPath].then(watcher => { watcher.dispose() })\r\n      }\r\n    }\r\n\r\n    let repo = null\r\n    for (let provider of this.repositoryProviders) {\r\n      if (provider.repositoryForDirectorySync) {\r\n        repo = provider.repositoryForDirectorySync(directory)\r\n      }\r\n      if (repo) { break }\r\n    }\r\n    this.repositories.push(repo != null ? repo : null)\r\n    if (repo != null) {\r\n      this.emitter.emit('did-add-repository', repo)\r\n    }\r\n\r\n    if (options.emitEvent !== false) {\r\n      this.emitter.emit('did-change-paths', this.getPaths())\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.getDirectoryForProjectPath","start_line":444,"end_line":456,"comment":[],"params":["projectPath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"getDirectories","line":399,"func_location":"Project.addPath","func_start_line":381,"func_end_line":442,"args":[],"comment":[" Public: Add a path to the project's list of root paths",""," * `projectPath` {String} The path to the directory to add."," * `options` An optional {Object} that may contain the following keys:","   * `mustExist` If `true`, throw an Error if the `projectPath` does not exist. If `false`, a `projectPath` that does","     not exist is ignored. Default: `false`.","   * `exact` If `true`, only add `projectPath` if it names an existing directory. If `false`, if `projectPath` is a","     a file or does not exist, its parent directory will be added instead."],"code":"  addPath (projectPath, options = {}) {\r\n    const directory = this.getDirectoryForProjectPath(projectPath)\r\n    let ok = true\r\n    if (options.exact === true) {\r\n      ok = (directory.getPath() === projectPath)\r\n    }\r\n    ok = ok && directory.existsSync()\r\n\r\n    if (!ok) {\r\n      if (options.mustExist === true) {\r\n        const err = new Error(`Project directory ${directory} does not exist`)\r\n        err.missingProjectPaths = [projectPath]\r\n        throw err\r\n      } else {\r\n        return\r\n      }\r\n    }\r\n\r\n    for (let existingDirectory of this.getDirectories()) {\r\n      if (existingDirectory.getPath() === directory.getPath()) { return }\r\n    }\r\n\r\n    this.rootDirectories.push(directory)\r\n\r\n    const didChangeCallback = events => {\r\n      // Stop event delivery immediately on removal of a rootDirectory, even if its watcher\r\n      // promise has yet to resolve at the time of removal\r\n      if (this.rootDirectories.includes(directory)) {\r\n        this.emitter.emit('did-change-files', events)\r\n      }\r\n    }\r\n\r\n    // We'll use the directory's custom onDidChangeFiles callback, if available.\r\n    // CustomDirectory::onDidChangeFiles should match the signature of\r\n    // Project::onDidChangeFiles below (although it may resolve asynchronously)\r\n    this.watcherPromisesByPath[directory.getPath()] =\r\n      directory.onDidChangeFiles != null\r\n        ? Promise.resolve(directory.onDidChangeFiles(didChangeCallback))\r\n        : watchPath(directory.getPath(), {}, didChangeCallback)\r\n\r\n    for (let watchedPath in this.watcherPromisesByPath) {\r\n      if (!this.rootDirectories.find(dir => dir.getPath() === watchedPath)) {\r\n        this.watcherPromisesByPath[watchedPath].then(watcher => { watcher.dispose() })\r\n      }\r\n    }\r\n\r\n    let repo = null\r\n    for (let provider of this.repositoryProviders) {\r\n      if (provider.repositoryForDirectorySync) {\r\n        repo = provider.repositoryForDirectorySync(directory)\r\n      }\r\n      if (repo) { break }\r\n    }\r\n    this.repositories.push(repo != null ? repo : null)\r\n    if (repo != null) {\r\n      this.emitter.emit('did-add-repository', repo)\r\n    }\r\n\r\n    if (options.emitEvent !== false) {\r\n      this.emitter.emit('did-change-paths', this.getPaths())\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.getDirectories","start_line":510,"end_line":512,"comment":[" Public: Get an {Array} of {Directory}s associated with this project."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"getPaths","line":440,"func_location":"Project.addPath","func_start_line":381,"func_end_line":442,"args":[{"type":"string"},null],"comment":[" Public: Add a path to the project's list of root paths",""," * `projectPath` {String} The path to the directory to add."," * `options` An optional {Object} that may contain the following keys:","   * `mustExist` If `true`, throw an Error if the `projectPath` does not exist. If `false`, a `projectPath` that does","     not exist is ignored. Default: `false`.","   * `exact` If `true`, only add `projectPath` if it names an existing directory. If `false`, if `projectPath` is a","     a file or does not exist, its parent directory will be added instead."],"code":"  addPath (projectPath, options = {}) {\r\n    const directory = this.getDirectoryForProjectPath(projectPath)\r\n    let ok = true\r\n    if (options.exact === true) {\r\n      ok = (directory.getPath() === projectPath)\r\n    }\r\n    ok = ok && directory.existsSync()\r\n\r\n    if (!ok) {\r\n      if (options.mustExist === true) {\r\n        const err = new Error(`Project directory ${directory} does not exist`)\r\n        err.missingProjectPaths = [projectPath]\r\n        throw err\r\n      } else {\r\n        return\r\n      }\r\n    }\r\n\r\n    for (let existingDirectory of this.getDirectories()) {\r\n      if (existingDirectory.getPath() === directory.getPath()) { return }\r\n    }\r\n\r\n    this.rootDirectories.push(directory)\r\n\r\n    const didChangeCallback = events => {\r\n      // Stop event delivery immediately on removal of a rootDirectory, even if its watcher\r\n      // promise has yet to resolve at the time of removal\r\n      if (this.rootDirectories.includes(directory)) {\r\n        this.emitter.emit('did-change-files', events)\r\n      }\r\n    }\r\n\r\n    // We'll use the directory's custom onDidChangeFiles callback, if available.\r\n    // CustomDirectory::onDidChangeFiles should match the signature of\r\n    // Project::onDidChangeFiles below (although it may resolve asynchronously)\r\n    this.watcherPromisesByPath[directory.getPath()] =\r\n      directory.onDidChangeFiles != null\r\n        ? Promise.resolve(directory.onDidChangeFiles(didChangeCallback))\r\n        : watchPath(directory.getPath(), {}, didChangeCallback)\r\n\r\n    for (let watchedPath in this.watcherPromisesByPath) {\r\n      if (!this.rootDirectories.find(dir => dir.getPath() === watchedPath)) {\r\n        this.watcherPromisesByPath[watchedPath].then(watcher => { watcher.dispose() })\r\n      }\r\n    }\r\n\r\n    let repo = null\r\n    for (let provider of this.repositoryProviders) {\r\n      if (provider.repositoryForDirectorySync) {\r\n        repo = provider.repositoryForDirectorySync(directory)\r\n      }\r\n      if (repo) { break }\r\n    }\r\n    this.repositories.push(repo != null ? repo : null)\r\n    if (repo != null) {\r\n      this.emitter.emit('did-add-repository', repo)\r\n    }\r\n\r\n    if (options.emitEvent !== false) {\r\n      this.emitter.emit('did-change-paths', this.getPaths())\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.getPaths","start_line":327,"end_line":329,"comment":["\r\n  Section: Managing Paths\r\n  "," Public: Get an {Array} of {String}s containing the paths of the project's"," directories."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/compile-cache.js","name":"compileFileAtPath","line":66,"func_location":"exports.addPathToCache","func_start_line":53,"func_end_line":69,"args":["compiler","filePath","extension"],"code":"exports.addPathToCache = function (filePath, atomHome) {\r\n  this.setAtomHomeDirectory(atomHome)\r\n  var extension = path.extname(filePath)\r\n\r\n  if (extension === '.cson') {\r\n    if (!CSON) {\r\n      CSON = require('season')\r\n      CSON.setCacheDir(this.getCacheDirectory())\r\n    }\r\n    return CSON.readFileSync(filePath)\r\n  } else {\r\n    var compiler = COMPILERS[extension]\r\n    if (compiler) {\r\n      return compileFileAtPath(compiler, filePath, extension)\r\n    }\r\n  }\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/compile-cache.js","name":"compileFileAtPath","start_line":84,"end_line":99,"comment":[],"params":["compiler","filePath","extension"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"getProject","line":58,"func_location":"HistoryManager.addProject","func_start_line":55,"func_end_line":68,"args":["paths"],"code":"  async addProject (paths, lastOpened) {\r\n    if (paths.length === 0) return\r\n\r\n    let project = this.getProject(paths)\r\n    if (!project) {\r\n      project = new HistoryProject(paths)\r\n      this.projects.push(project)\r\n    }\r\n    project.lastOpened = lastOpened || new Date()\r\n    this.projects.sort((a, b) => b.lastOpened - a.lastOpened)\r\n\r\n    await this.saveState()\r\n    this.didChangeProjects()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"HistoryManager.getProject","start_line":83,"end_line":91,"comment":[],"params":["paths"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"constructor","line":60,"func_location":"HistoryManager.addProject","func_start_line":55,"func_end_line":68},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"HistoryProject.constructor","start_line":118,"end_line":121,"comment":[],"params":["paths","lastOpened"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"saveState","line":66,"func_location":"HistoryManager.addProject","func_start_line":55,"func_end_line":68,"args":[],"code":"  async addProject (paths, lastOpened) {\r\n    if (paths.length === 0) return\r\n\r\n    let project = this.getProject(paths)\r\n    if (!project) {\r\n      project = new HistoryProject(paths)\r\n      this.projects.push(project)\r\n    }\r\n    project.lastOpened = lastOpened || new Date()\r\n    this.projects.sort((a, b) => b.lastOpened - a.lastOpened)\r\n\r\n    await this.saveState()\r\n    this.didChangeProjects()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"HistoryManager.saveState","start_line":103,"end_line":106,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"didChangeProjects","line":67,"func_location":"HistoryManager.addProject","func_start_line":55,"func_end_line":68,"args":[],"code":"  async addProject (paths, lastOpened) {\r\n    if (paths.length === 0) return\r\n\r\n    let project = this.getProject(paths)\r\n    if (!project) {\r\n      project = new HistoryProject(paths)\r\n      this.projects.push(project)\r\n    }\r\n    project.lastOpened = lastOpened || new Date()\r\n    this.projects.sort((a, b) => b.lastOpened - a.lastOpened)\r\n\r\n    await this.saveState()\r\n    this.didChangeProjects()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"HistoryManager.didChangeProjects","start_line":51,"end_line":53,"comment":[],"params":["args"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"addPanel","line":1707,"func_location":"Workspace.addRightPanel","func_start_line":1706,"func_end_line":1708,"args":[{"type":"string"},"options"],"comment":[" Essential: Adds a panel item to the right of the editor window.",""," * `options` {Object}","   * `item` Your panel content. It can be DOM element, a jQuery element, or","     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the","     latter. See {ViewRegistry::addViewProvider} for more information.","   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden","     (default: true)","   * `priority` (optional) {Number} Determines stacking order. Lower priority items are","     forced closer to the edges of the window. (default: 100)",""," Returns a {Panel}"],"code":"  addRightPanel (options) {\r\n    return this.addPanel('right', options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.addPanel","start_line":1816,"end_line":1819,"comment":[],"params":["location","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"addSchemaEnforcer","line":375,"func_location":"Config.addSchemaEnforcers","func_start_line":370,"func_end_line":378,"args":["typeName","enforcerFunction"],"code":"  static addSchemaEnforcers (filters) {\r\n    for (let typeName in filters) {\r\n      const functions = filters[typeName]\r\n      for (let name in functions) {\r\n        const enforcerFunction = functions[name]\r\n        this.addSchemaEnforcer(typeName, enforcerFunction)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.addSchemaEnforcer","start_line":365,"end_line":368,"comment":[],"params":["typeName","enforcerFunction"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js","name":"commandRegistered","line":173,"func_location":"CommandRegistry.addSelectorBasedListener","func_start_line":165,"func_end_line":181,"args":["commandName"],"code":"  addSelectorBasedListener (selector, commandName, listener) {\r\n    if (this.selectorBasedListenersByCommandName[commandName] == null) {\r\n      this.selectorBasedListenersByCommandName[commandName] = []\r\n    }\r\n    const listenersForCommand = this.selectorBasedListenersByCommandName[commandName]\r\n    const selectorListener = new SelectorBasedListener(selector, commandName, listener)\r\n    listenersForCommand.push(selectorListener)\r\n\r\n    this.commandRegistered(commandName)\r\n\r\n    return new Disposable(() => {\r\n      listenersForCommand.splice(listenersForCommand.indexOf(selectorListener), 1)\r\n      if (listenersForCommand.length === 0) {\r\n        delete this.selectorBasedListenersByCommandName[commandName]\r\n      }\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js","name":"CommandRegistry.commandRegistered","start_line":401,"end_line":406,"comment":[],"params":["commandName"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js","name":"upgradeDeprecatedSelectorsForStyleSheet","line":143,"func_location":"StyleManager.addStyleSheet","func_start_line":117,"func_end_line":157,"args":["source","params.context"],"code":"  addStyleSheet (source, params = {}) {\r\n    let styleElement\r\n    let updated\r\n    if (params.sourcePath != null && this.styleElementsBySourcePath[params.sourcePath] != null) {\r\n      updated = true\r\n      styleElement = this.styleElementsBySourcePath[params.sourcePath]\r\n    } else {\r\n      updated = false\r\n      styleElement = document.createElement('style')\r\n      if (params.sourcePath != null) {\r\n        styleElement.sourcePath = params.sourcePath\r\n        styleElement.setAttribute('source-path', params.sourcePath)\r\n      }\r\n      if (params.context != null) {\r\n        styleElement.context = params.context\r\n        styleElement.setAttribute('context', params.context)\r\n      }\r\n      if (params.priority != null) {\r\n        styleElement.priority = params.priority\r\n        styleElement.setAttribute('priority', params.priority)\r\n      }\r\n    }\r\n\r\n    if (params.skipDeprecatedSelectorsTransformation) {\r\n      styleElement.textContent = source\r\n    } else {\r\n      const transformed = this.upgradeDeprecatedSelectorsForStyleSheet(source, params.context)\r\n      styleElement.textContent = transformed.source\r\n      if (transformed.deprecationMessage) {\r\n        this.deprecationsBySourcePath[params.sourcePath] = {message: transformed.deprecationMessage}\r\n        this.emitter.emit('did-update-deprecations')\r\n      }\r\n    }\r\n\r\n    if (updated) {\r\n      this.emitter.emit('did-update-style-element', styleElement)\r\n    } else {\r\n      this.addStyleElement(styleElement)\r\n    }\r\n    return new Disposable(() => { this.removeStyleElement(styleElement) })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js","name":"StyleManager.upgradeDeprecatedSelectorsForStyleSheet","start_line":189,"end_line":207,"comment":[],"params":["styleSheet","context"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js","name":"addStyleElement","line":154,"func_location":"StyleManager.addStyleSheet","func_start_line":117,"func_end_line":157,"args":["styleElement"],"code":"  addStyleSheet (source, params = {}) {\r\n    let styleElement\r\n    let updated\r\n    if (params.sourcePath != null && this.styleElementsBySourcePath[params.sourcePath] != null) {\r\n      updated = true\r\n      styleElement = this.styleElementsBySourcePath[params.sourcePath]\r\n    } else {\r\n      updated = false\r\n      styleElement = document.createElement('style')\r\n      if (params.sourcePath != null) {\r\n        styleElement.sourcePath = params.sourcePath\r\n        styleElement.setAttribute('source-path', params.sourcePath)\r\n      }\r\n      if (params.context != null) {\r\n        styleElement.context = params.context\r\n        styleElement.setAttribute('context', params.context)\r\n      }\r\n      if (params.priority != null) {\r\n        styleElement.priority = params.priority\r\n        styleElement.setAttribute('priority', params.priority)\r\n      }\r\n    }\r\n\r\n    if (params.skipDeprecatedSelectorsTransformation) {\r\n      styleElement.textContent = source\r\n    } else {\r\n      const transformed = this.upgradeDeprecatedSelectorsForStyleSheet(source, params.context)\r\n      styleElement.textContent = transformed.source\r\n      if (transformed.deprecationMessage) {\r\n        this.deprecationsBySourcePath[params.sourcePath] = {message: transformed.deprecationMessage}\r\n        this.emitter.emit('did-update-deprecations')\r\n      }\r\n    }\r\n\r\n    if (updated) {\r\n      this.emitter.emit('did-update-style-element', styleElement)\r\n    } else {\r\n      this.addStyleElement(styleElement)\r\n    }\r\n    return new Disposable(() => { this.removeStyleElement(styleElement) })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js","name":"StyleManager.addStyleElement","start_line":159,"end_line":176,"comment":[],"params":["styleElement"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification-manager.js","name":"addNotification","line":68,"func_location":"NotificationManager.addSuccess","func_start_line":67,"func_end_line":69,"args":[null],"comment":["\r\n  Section: Adding Notifications\r\n  "," Public: Add a success notification.",""," * `message` A {String} message"," * `options` (optional) An options {Object} with the following keys:","    * `buttons` (optional) An {Array} of {Object} where each {Object} has","      the following options:","      * `className` (optional) {String} a class name to add to the button's","        default class name (`btn btn-success`).","      * `onDidClick` (optional) {Function} callback to call when the button","        has been clicked. The context will be set to the","        {NotificationElement} instance.","      * `text` {String} inner text for the button","    * `description` (optional) A Markdown {String} containing a longer","      description about the notification. By default, this **will not**","      preserve newlines and whitespace when it is rendered.","    * `detail` (optional) A plain-text {String} containing additional","      details about the notification. By default, this **will** preserve","      newlines and whitespace when it is rendered.","    * `dismissable` (optional) A {Boolean} indicating whether this","      notification can be dismissed by the user. Defaults to `false`.","    * `icon` (optional) A {String} name of an icon from Octicons to display","      in the notification header. Defaults to `'check'`.",""," Returns the {Notification} that was added."],"code":"  addSuccess (message, options) {\r\n    return this.addNotification(new Notification('success', message, options))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification-manager.js","name":"NotificationManager.addNotification","start_line":191,"end_line":195,"comment":[],"params":["notification"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedStartRow","line":1312,"func_location":"TextEditorComponent.addTextDecorationStart","func_start_line":1311,"func_end_line":1319,"args":[],"code":"  addTextDecorationStart (row, column, className, style) {\r\n    const renderedStartRow = this.getRenderedStartRow()\r\n    let decorationStarts = this.decorationsToRender.text[row - renderedStartRow]\r\n    if (!decorationStarts) {\r\n      decorationStarts = []\r\n      this.decorationsToRender.text[row - renderedStartRow] = decorationStarts\r\n    }\r\n    decorationStarts.push({column, className, style})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedStartRow","start_line":2720,"end_line":2726,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"addPanel","line":1728,"func_location":"Workspace.addTopPanel","func_start_line":1727,"func_end_line":1729,"args":[{"type":"string"},"options"],"comment":[" Essential: Adds a panel item to the top of the editor window above the tabs.",""," * `options` {Object}","   * `item` Your panel content. It can be DOM element, a jQuery element, or","     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the","     latter. See {ViewRegistry::addViewProvider} for more information.","   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden","     (default: true)","   * `priority` (optional) {Number} Determines stacking order. Lower priority items are","     forced closer to the edges of the window. (default: 100)",""," Returns a {Panel}"],"code":"  addTopPanel (options) {\r\n    return this.addPanel('top', options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.addPanel","start_line":1816,"end_line":1819,"comment":[],"params":["location","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"loadState","line":1121,"func_location":"AtomEnvironment.addToProject","func_start_line":1120,"func_end_line":1127,"args":[null],"code":"  async addToProject (projectPaths) {\r\n    const state = await this.loadState(this.getStateKey(projectPaths))\r\n    if (state && (this.project.getPaths().length === 0)) {\r\n      this.attemptRestoreProjectStateForPaths(state, projectPaths)\r\n    } else {\r\n      projectPaths.map((folder) => this.project.addPath(folder))\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.loadState","start_line":1210,"end_line":1221,"comment":[],"params":["stateKey"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"getStateKey","line":1121,"func_location":"AtomEnvironment.addToProject","func_start_line":1120,"func_end_line":1127,"args":[null],"code":"  async addToProject (projectPaths) {\r\n    const state = await this.loadState(this.getStateKey(projectPaths))\r\n    if (state && (this.project.getPaths().length === 0)) {\r\n      this.attemptRestoreProjectStateForPaths(state, projectPaths)\r\n    } else {\r\n      projectPaths.map((folder) => this.project.addPath(folder))\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.getStateKey","start_line":1279,"end_line":1286,"comment":[],"params":["paths"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"attemptRestoreProjectStateForPaths","line":1123,"func_location":"AtomEnvironment.addToProject","func_start_line":1120,"func_end_line":1127,"args":["state","projectPaths"],"code":"  async addToProject (projectPaths) {\r\n    const state = await this.loadState(this.getStateKey(projectPaths))\r\n    if (state && (this.project.getPaths().length === 0)) {\r\n      this.attemptRestoreProjectStateForPaths(state, projectPaths)\r\n    } else {\r\n      projectPaths.map((folder) => this.project.addPath(folder))\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.attemptRestoreProjectStateForPaths","start_line":1129,"end_line":1181,"comment":[],"params":["state","projectPaths","filesToOpen"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification-manager.js","name":"addNotification","line":124,"func_location":"NotificationManager.addWarning","func_start_line":123,"func_end_line":125,"args":[null],"comment":[" Public: Add a warning notification.",""," * `message` A {String} message"," * `options` (optional) An options {Object} with the following keys:","    * `buttons` (optional) An {Array} of {Object} where each {Object} has","      the following options:","      * `className` (optional) {String} a class name to add to the button's","        default class name (`btn btn-warning`).","      * `onDidClick` (optional) {Function} callback to call when the button","        has been clicked. The context will be set to the","        {NotificationElement} instance.","      * `text` {String} inner text for the button","    * `description` (optional) A Markdown {String} containing a longer","      description about the notification. By default, this **will not**","      preserve newlines and whitespace when it is rendered.","    * `detail` (optional) A plain-text {String} containing additional","      details about the notification. By default, this **will** preserve","      newlines and whitespace when it is rendered.","    * `dismissable` (optional) A {Boolean} indicating whether this","      notification can be dismissed by the user. Defaults to `false`.","    * `icon` (optional) A {String} name of an icon from Octicons to display","      in the notification header. Defaults to `'alert'`.",""," Returns the {Notification} that was added."],"code":"  addWarning (message, options) {\r\n    return this.addNotification(new Notification('warning', message, options))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification-manager.js","name":"NotificationManager.addNotification","start_line":191,"end_line":195,"comment":[],"params":["notification"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"removeWindow","line":1400,"func_location":"WindowStack.addWindow","func_start_line":1399,"func_end_line":1402,"args":["window"],"code":"  addWindow (window) {\r\n    this.removeWindow(window)\r\n    return this.windows.unshift(window)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"WindowStack.removeWindow","start_line":1408,"end_line":1413,"comment":[],"params":["window"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"enableWindowSpecificItems","line":59,"func_location":"ApplicationMenu.addWindow","func_start_line":43,"func_end_line":60,"args":[{"type":"boolean"}],"comment":[" Register a BrowserWindow with this application menu."],"code":"  addWindow (window) {\r\n    if (this.lastFocusedWindow == null) this.lastFocusedWindow = window\r\n\r\n    const focusHandler = () => {\r\n      this.lastFocusedWindow = window\r\n      const template = this.windowTemplates.get(window)\r\n      if (template) this.setActiveTemplate(template)\r\n    }\r\n\r\n    window.on('focus', focusHandler)\r\n    window.once('closed', () => {\r\n      if (window === this.lastFocusedWindow) this.lastFocusedWindow = null\r\n      this.windowTemplates.delete(window)\r\n      window.removeListener('focus', focusHandler)\r\n    })\r\n\r\n    this.enableWindowSpecificItems(true)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"ApplicationMenu.enableWindowSpecificItems","start_line":96,"end_line":100,"comment":[" Public: Used to make all window related menu items are active.",""," enable - If true enables all window specific items, if false disables all","          window specific items."],"params":["enable"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"appendTextNode","line":4009,"func_location":"LineComponent.appendContents","func_start_line":3975,"func_end_line":4039,"args":["openScopeNode","text","activeClassName","activeStyle"],"code":"  appendContents () {\r\n    const {displayLayer, nodePool, screenLine, textDecorations} = this.props\r\n\r\n    this.textNodes.length = 0\r\n\r\n    const {lineText, tags} = screenLine\r\n    let openScopeNode = nodePool.getElement('SPAN', null, null)\r\n    this.element.appendChild(openScopeNode)\r\n\r\n    let decorationIndex = 0\r\n    let column = 0\r\n    let activeClassName = null\r\n    let activeStyle = null\r\n    let nextDecoration = textDecorations ? textDecorations[decorationIndex] : null\r\n    if (nextDecoration && nextDecoration.column === 0) {\r\n      column = nextDecoration.column\r\n      activeClassName = nextDecoration.className\r\n      activeStyle = nextDecoration.style\r\n      nextDecoration = textDecorations[++decorationIndex]\r\n    }\r\n\r\n    for (let i = 0; i < tags.length; i++) {\r\n      const tag = tags[i]\r\n      if (tag !== 0) {\r\n        if (displayLayer.isCloseTag(tag)) {\r\n          openScopeNode = openScopeNode.parentElement\r\n        } else if (displayLayer.isOpenTag(tag)) {\r\n          const newScopeNode = nodePool.getElement('SPAN', displayLayer.classNameForTag(tag), null)\r\n          openScopeNode.appendChild(newScopeNode)\r\n          openScopeNode = newScopeNode\r\n        } else {\r\n          const nextTokenColumn = column + tag\r\n          while (nextDecoration && nextDecoration.column <= nextTokenColumn) {\r\n            const text = lineText.substring(column, nextDecoration.column)\r\n            this.appendTextNode(openScopeNode, text, activeClassName, activeStyle)\r\n            column = nextDecoration.column\r\n            activeClassName = nextDecoration.className\r\n            activeStyle = nextDecoration.style\r\n            nextDecoration = textDecorations[++decorationIndex]\r\n          }\r\n\r\n          if (column < nextTokenColumn) {\r\n            const text = lineText.substring(column, nextTokenColumn)\r\n            this.appendTextNode(openScopeNode, text, activeClassName, activeStyle)\r\n            column = nextTokenColumn\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (column === 0) {\r\n      const textNode = nodePool.getTextNode(' ')\r\n      this.element.appendChild(textNode)\r\n      this.textNodes.push(textNode)\r\n    }\r\n\r\n    if (lineText.endsWith(displayLayer.foldCharacter)) {\r\n      // Insert a zero-width non-breaking whitespace, so that LinesYardstick can\r\n      // take the fold-marker::after pseudo-element into account during\r\n      // measurements when such marker is the last character on the line.\r\n      const textNode = nodePool.getTextNode(ZERO_WIDTH_NBSP_CHARACTER)\r\n      this.element.appendChild(textNode)\r\n      this.textNodes.push(textNode)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"LineComponent.appendTextNode","start_line":4041,"end_line":4053,"comment":[],"params":["openScopeNode","text","activeClassName","activeStyle"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"appendTextNode","line":4018,"func_location":"LineComponent.appendContents","func_start_line":3975,"func_end_line":4039,"args":["openScopeNode","text","activeClassName","activeStyle"],"code":"  appendContents () {\r\n    const {displayLayer, nodePool, screenLine, textDecorations} = this.props\r\n\r\n    this.textNodes.length = 0\r\n\r\n    const {lineText, tags} = screenLine\r\n    let openScopeNode = nodePool.getElement('SPAN', null, null)\r\n    this.element.appendChild(openScopeNode)\r\n\r\n    let decorationIndex = 0\r\n    let column = 0\r\n    let activeClassName = null\r\n    let activeStyle = null\r\n    let nextDecoration = textDecorations ? textDecorations[decorationIndex] : null\r\n    if (nextDecoration && nextDecoration.column === 0) {\r\n      column = nextDecoration.column\r\n      activeClassName = nextDecoration.className\r\n      activeStyle = nextDecoration.style\r\n      nextDecoration = textDecorations[++decorationIndex]\r\n    }\r\n\r\n    for (let i = 0; i < tags.length; i++) {\r\n      const tag = tags[i]\r\n      if (tag !== 0) {\r\n        if (displayLayer.isCloseTag(tag)) {\r\n          openScopeNode = openScopeNode.parentElement\r\n        } else if (displayLayer.isOpenTag(tag)) {\r\n          const newScopeNode = nodePool.getElement('SPAN', displayLayer.classNameForTag(tag), null)\r\n          openScopeNode.appendChild(newScopeNode)\r\n          openScopeNode = newScopeNode\r\n        } else {\r\n          const nextTokenColumn = column + tag\r\n          while (nextDecoration && nextDecoration.column <= nextTokenColumn) {\r\n            const text = lineText.substring(column, nextDecoration.column)\r\n            this.appendTextNode(openScopeNode, text, activeClassName, activeStyle)\r\n            column = nextDecoration.column\r\n            activeClassName = nextDecoration.className\r\n            activeStyle = nextDecoration.style\r\n            nextDecoration = textDecorations[++decorationIndex]\r\n          }\r\n\r\n          if (column < nextTokenColumn) {\r\n            const text = lineText.substring(column, nextTokenColumn)\r\n            this.appendTextNode(openScopeNode, text, activeClassName, activeStyle)\r\n            column = nextTokenColumn\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (column === 0) {\r\n      const textNode = nodePool.getTextNode(' ')\r\n      this.element.appendChild(textNode)\r\n      this.textNodes.push(textNode)\r\n    }\r\n\r\n    if (lineText.endsWith(displayLayer.foldCharacter)) {\r\n      // Insert a zero-width non-breaking whitespace, so that LinesYardstick can\r\n      // take the fold-marker::after pseudo-element into account during\r\n      // measurements when such marker is the last character on the line.\r\n      const textNode = nodePool.getTextNode(ZERO_WIDTH_NBSP_CHARACTER)\r\n      this.element.appendChild(textNode)\r\n      this.textNodes.push(textNode)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"LineComponent.appendTextNode","start_line":4041,"end_line":4053,"comment":[],"params":["openScopeNode","text","activeClassName","activeStyle"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js","name":"taskDescription","line":69,"func_location":"ReopenProjectMenuManager.applyWindowsJumpListRemovals","func_start_line":60,"func_end_line":73,"args":[null],"comment":[" Windows users can right-click Atom taskbar and remove project from the jump list."," We have to honor that or the group stops working. As we only get a partial list"," each time we remove them from history entirely."],"code":"  async applyWindowsJumpListRemovals () {\r\n    if (process.platform !== 'win32') return\r\n    if (this.app === undefined) {\r\n      this.app = require('remote').app\r\n    }\r\n\r\n    const removed = this.app.getJumpListSettings().removedItems.map(i => i.description)\r\n    if (removed.length === 0) return\r\n    for (let project of this.historyManager.getProjects()) {\r\n      if (removed.includes(ReopenProjectMenuManager.taskDescription(project.paths))) {\r\n        await this.historyManager.removeProject(project.paths)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js","name":"ReopenProjectMenuManager.taskDescription","start_line":53,"end_line":55,"comment":[],"params":["paths"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"isReleasedVersion","line":1091,"func_location":"AtomEnvironment.assert","func_start_line":1076,"func_end_line":1094,"args":[],"comment":["\r\n  Section: Private\r\n  "],"code":"  assert (condition, message, callbackOrMetadata) {\r\n    if (condition) return true\r\n\r\n    const error = new Error(`Assertion failed: ${message}`)\r\n    Error.captureStackTrace(error, this.assert)\r\n\r\n    if (callbackOrMetadata) {\r\n      if (typeof callbackOrMetadata === 'function') {\r\n        callbackOrMetadata(error)\r\n      } else {\r\n        error.metadata = callbackOrMetadata\r\n      }\r\n    }\r\n\r\n    this.emitter.emit('did-fail-assertion', error)\r\n    if (!this.isReleasedVersion()) throw error\r\n\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.isReleasedVersion","start_line":507,"end_line":509,"comment":[" Public: Returns a {Boolean} that is `true` if the current version is an official release."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"grammarForId","line":129,"func_location":"GrammarRegistry.assignLanguageMode","func_start_line":124,"func_end_line":143,"args":["languageId"],"comment":[" Extended: Force a {TextBuffer} to use a different grammar than the"," one that would otherwise be selected for it.",""," * `buffer` The {TextBuffer} whose grammar will be set."," * `languageId` The {String} id of the desired language.",""," Returns a {Boolean} that indicates whether the language was successfully"," found."],"code":"  assignLanguageMode (buffer, languageId) {\r\n    if (buffer.getBuffer) buffer = buffer.getBuffer()\r\n\r\n    let grammar = null\r\n    if (languageId != null) {\r\n      grammar = this.grammarForId(languageId)\r\n      if (!grammar) return false\r\n      this.languageOverridesByBufferId.set(buffer.id, languageId)\r\n    } else {\r\n      this.languageOverridesByBufferId.set(buffer.id, null)\r\n      grammar = this.textmateRegistry.nullGrammar\r\n    }\r\n\r\n    this.grammarScoresByBuffer.set(buffer, null)\r\n    if (grammar !== buffer.getLanguageMode().grammar) {\r\n      buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(grammar, buffer))\r\n    }\r\n\r\n    return true\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.grammarForId","start_line":313,"end_line":326,"comment":[],"params":["languageId"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"languageModeForGrammarAndBuffer","line":139,"func_location":"GrammarRegistry.assignLanguageMode","func_start_line":124,"func_end_line":143,"args":[null],"comment":[" Extended: Force a {TextBuffer} to use a different grammar than the"," one that would otherwise be selected for it.",""," * `buffer` The {TextBuffer} whose grammar will be set."," * `languageId` The {String} id of the desired language.",""," Returns a {Boolean} that indicates whether the language was successfully"," found."],"code":"  assignLanguageMode (buffer, languageId) {\r\n    if (buffer.getBuffer) buffer = buffer.getBuffer()\r\n\r\n    let grammar = null\r\n    if (languageId != null) {\r\n      grammar = this.grammarForId(languageId)\r\n      if (!grammar) return false\r\n      this.languageOverridesByBufferId.set(buffer.id, languageId)\r\n    } else {\r\n      this.languageOverridesByBufferId.set(buffer.id, null)\r\n      grammar = this.textmateRegistry.nullGrammar\r\n    }\r\n\r\n    this.grammarScoresByBuffer.set(buffer, null)\r\n    if (grammar !== buffer.getLanguageMode().grammar) {\r\n      buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(grammar, buffer))\r\n    }\r\n\r\n    return true\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.languageModeForGrammarAndBuffer","start_line":170,"end_line":176,"comment":[],"params":["grammar","buffer"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"getAllWindows","line":744,"func_location":"AtomApplication.atomWindowForBrowserWindow","func_start_line":743,"func_end_line":745,"args":[null],"code":"  atomWindowForBrowserWindow (browserWindow) {\r\n    return this.getAllWindows().find(atomWindow => atomWindow.browserWindow === browserWindow)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.getAllWindows","start_line":321,"end_line":323,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"atomWindowForBrowserWindow","line":740,"func_location":"AtomApplication.atomWindowForEvent","func_start_line":739,"func_end_line":741,"args":[null],"comment":[" Returns the {AtomWindow} for the given ipcMain event."],"code":"  atomWindowForEvent ({sender}) {\r\n    return this.atomWindowForBrowserWindow(BrowserWindow.fromWebContents(sender))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.atomWindowForBrowserWindow","start_line":743,"end_line":745,"comment":[],"params":["browserWindow"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js","name":"commandRegistered","line":64,"func_location":"CommandRegistry.attach","func_start_line":61,"func_end_line":70,"args":["command"],"code":"  attach (rootNode) {\r\n    this.rootNode = rootNode\r\n    for (const command in this.selectorBasedListenersByCommandName) {\r\n      this.commandRegistered(command)\r\n    }\r\n\r\n    for (const command in this.inlineListenersByCommandName) {\r\n      this.commandRegistered(command)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js","name":"CommandRegistry.commandRegistered","start_line":401,"end_line":406,"comment":[],"params":["commandName"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js","name":"commandRegistered","line":68,"func_location":"CommandRegistry.attach","func_start_line":61,"func_end_line":70,"args":["command"],"code":"  attach (rootNode) {\r\n    this.rootNode = rootNode\r\n    for (const command in this.selectorBasedListenersByCommandName) {\r\n      this.commandRegistered(command)\r\n    }\r\n\r\n    for (const command in this.inlineListenersByCommandName) {\r\n      this.commandRegistered(command)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js","name":"CommandRegistry.commandRegistered","start_line":401,"end_line":406,"comment":[],"params":["commandName"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":41,"func_location":"TextEditorElement.attachedCallback","func_start_line":40,"func_end_line":43,"args":[],"code":"  attachedCallback () {\r\n    this.getComponent().didAttach()\r\n    this.emitter.emit('did-attach')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"restoreStateIntoThisEnvironment","line":1145,"func_location":"AtomEnvironment.attemptRestoreProjectStateForPaths","func_start_line":1129,"func_end_line":1181,"args":["state"],"code":"  async attemptRestoreProjectStateForPaths (state, projectPaths, filesToOpen = []) {\r\n    const center = this.workspace.getCenter()\r\n    const windowIsUnused = () => {\r\n      for (let container of this.workspace.getPaneContainers()) {\r\n        for (let item of container.getPaneItems()) {\r\n          if (item instanceof TextEditor) {\r\n            if (item.getPath() || item.isModified()) return false\r\n          } else {\r\n            if (container === center) return false\r\n          }\r\n        }\r\n      }\r\n      return true\r\n    }\r\n\r\n    if (windowIsUnused()) {\r\n      await this.restoreStateIntoThisEnvironment(state)\r\n      return Promise.all(filesToOpen.map(file => this.workspace.open(file)))\r\n    } else {\r\n      let resolveDiscardStatePromise = null\r\n      const discardStatePromise = new Promise((resolve) => {\r\n        resolveDiscardStatePromise = resolve\r\n      })\r\n      const nouns = projectPaths.length === 1 ? 'folder' : 'folders'\r\n      this.confirm({\r\n        message: 'Previous automatically-saved project state detected',\r\n        detail: `There is previously saved state for the selected ${nouns}. ` +\r\n          `Would you like to add the ${nouns} to this window, permanently discarding the saved state, ` +\r\n          `or open the ${nouns} in a new window, restoring the saved state?`,\r\n        buttons: [\r\n          '&Open in new window and recover state',\r\n          '&Add to this window and discard state'\r\n        ]\r\n      }, response => {\r\n        if (response === 0) {\r\n          this.open({\r\n            pathsToOpen: projectPaths.concat(filesToOpen),\r\n            newWindow: true,\r\n            devMode: this.inDevMode(),\r\n            safeMode: this.inSafeMode()\r\n          })\r\n          resolveDiscardStatePromise(Promise.resolve(null))\r\n        } else if (response === 1) {\r\n          for (let selectedPath of projectPaths) {\r\n            this.project.addPath(selectedPath)\r\n          }\r\n          resolveDiscardStatePromise(Promise.all(filesToOpen.map(file => this.workspace.open(file))))\r\n        }\r\n      })\r\n\r\n      return discardStatePromise\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.restoreStateIntoThisEnvironment","start_line":1183,"end_line":1189,"comment":[],"params":["state"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"confirm","line":1153,"func_location":"AtomEnvironment.attemptRestoreProjectStateForPaths","func_start_line":1129,"func_end_line":1181},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.confirm","start_line":1039,"end_line":1046,"comment":[" Essential: A flexible way to open a dialog akin to an alert dialog.",""," While both async and sync versions are provided, it is recommended to use the async version"," such that the renderer process is not blocked while the dialog box is open.",""," The async version accepts the same options as Electron's `dialog.showMessageBox`."," For convenience, it sets `type` to `'info'` and `normalizeAccessKeys` to `true` by default.",""," If the dialog is closed (via `Esc` key or `X` in the top corner) without selecting a button"," the first button will be clicked unless a \"Cancel\" or \"No\" button is provided.",""," ## Examples",""," ```js"," // Async version (recommended)"," atom.confirm({","   message: 'How you feeling?',","   detail: 'Be honest.',","   buttons: ['Good', 'Bad']"," }, response => {","   if (response === 0) {","     window.alert('good to hear')","   } else {","     window.alert('bummer')","   }"," })",""," ```js"," // Legacy sync version"," const chosen = atom.confirm({","   message: 'How you feeling?',","   detailedMessage: 'Be honest.',","   buttons: {","     Good: () => window.alert('good to hear'),","     Bad: () => window.alert('bummer')","   }"," })"," ```",""," * `options` An options {Object}. If the callback argument is also supplied, see the documentation at"," https://electronjs.org/docs/api/dialog#dialogshowmessageboxbrowserwindow-options-callback for the list of"," available options. Otherwise, only the following keys are accepted:","   * `message` The {String} message to display.","   * `detailedMessage` (optional) The {String} detailed message to display.","   * `buttons` (optional) Either an {Array} of {String}s or an {Object} where keys are","     button names and the values are callback {Function}s to invoke when clicked."," * `callback` (optional) A {Function} that will be called with the index of the chosen option.","   If a callback is supplied, the dialog will be non-blocking. This argument is recommended.",""," Returns the chosen button index {Number} if the buttons option is an array"," or the return value of the callback if the buttons option is an object."," If a callback function is supplied, returns `undefined`."],"params":["options","callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js","name":"indexOfGroupContainingCommand","line":77,"func_location":"attemptToMergeAGroup","func_start_line":71,"func_end_line":91,"args":["groups","command","group"],"code":"function attemptToMergeAGroup (groups) {\r\n  for (let i = 0; i < groups.length; i++) {\r\n    const group = groups[i]\r\n    for (const item of group) {\r\n      const toCommands = [...(item.before || []), ...(item.after || [])]\r\n      for (const command of toCommands) {\r\n        const index = indexOfGroupContainingCommand(groups, command, group)\r\n        if (index === -1) {\r\n          // No valid edge for this command\r\n          continue\r\n        }\r\n        const mergeTarget = groups[index]\r\n        // Merge with group containing `command`\r\n        mergeTarget.push(...group)\r\n        groups.splice(i, 1)\r\n        return true\r\n      }\r\n    }\r\n  }\r\n  return false\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js","name":"indexOfGroupContainingCommand","start_line":37,"end_line":45,"comment":[],"params":["groups","command","ignoreGroup"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getModel","line":54,"func_location":"TextEditorElement.attributeChangedCallback","func_start_line":50,"func_end_line":67,"args":[null],"code":"  attributeChangedCallback (name, oldValue, newValue) {\r\n    if (this.component) {\r\n      switch (name) {\r\n        case 'mini':\r\n          this.getModel().update({mini: newValue != null})\r\n          break\r\n        case 'placeholder-text':\r\n          this.getModel().update({placeholderText: newValue})\r\n          break\r\n        case 'gutter-hidden':\r\n          this.getModel().update({lineNumberGutterVisible: newValue == null})\r\n          break\r\n        case 'readonly':\r\n          this.getModel().update({readOnly: newValue != null})\r\n          break\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getModel","start_line":80,"end_line":82,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getModel","line":57,"func_location":"TextEditorElement.attributeChangedCallback","func_start_line":50,"func_end_line":67,"args":[null],"code":"  attributeChangedCallback (name, oldValue, newValue) {\r\n    if (this.component) {\r\n      switch (name) {\r\n        case 'mini':\r\n          this.getModel().update({mini: newValue != null})\r\n          break\r\n        case 'placeholder-text':\r\n          this.getModel().update({placeholderText: newValue})\r\n          break\r\n        case 'gutter-hidden':\r\n          this.getModel().update({lineNumberGutterVisible: newValue == null})\r\n          break\r\n        case 'readonly':\r\n          this.getModel().update({readOnly: newValue != null})\r\n          break\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getModel","start_line":80,"end_line":82,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getModel","line":60,"func_location":"TextEditorElement.attributeChangedCallback","func_start_line":50,"func_end_line":67,"args":[null],"code":"  attributeChangedCallback (name, oldValue, newValue) {\r\n    if (this.component) {\r\n      switch (name) {\r\n        case 'mini':\r\n          this.getModel().update({mini: newValue != null})\r\n          break\r\n        case 'placeholder-text':\r\n          this.getModel().update({placeholderText: newValue})\r\n          break\r\n        case 'gutter-hidden':\r\n          this.getModel().update({lineNumberGutterVisible: newValue == null})\r\n          break\r\n        case 'readonly':\r\n          this.getModel().update({readOnly: newValue != null})\r\n          break\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getModel","start_line":80,"end_line":82,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getModel","line":63,"func_location":"TextEditorElement.attributeChangedCallback","func_start_line":50,"func_end_line":67,"args":[null],"code":"  attributeChangedCallback (name, oldValue, newValue) {\r\n    if (this.component) {\r\n      switch (name) {\r\n        case 'mini':\r\n          this.getModel().update({mini: newValue != null})\r\n          break\r\n        case 'placeholder-text':\r\n          this.getModel().update({placeholderText: newValue})\r\n          break\r\n        case 'gutter-hidden':\r\n          this.getModel().update({lineNumberGutterVisible: newValue == null})\r\n          break\r\n        case 'readonly':\r\n          this.getModel().update({readOnly: newValue != null})\r\n          break\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getModel","start_line":80,"end_line":82,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"selectGrammarWithScore","line":159,"func_location":"GrammarRegistry.autoAssignLanguageMode","func_start_line":158,"func_end_line":168},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.selectGrammarWithScore","start_line":191,"end_line":202,"comment":[],"params":["filePath","fileContents"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"getGrammarSelectionContent","line":161,"func_location":"GrammarRegistry.autoAssignLanguageMode","func_start_line":158,"func_end_line":168,"args":["buffer"],"comment":[" Extended: Remove any language mode override that has been set for the"," given {TextBuffer}. This will assign to the buffer the best language"," mode available.",""," * `buffer` The {TextBuffer}."],"code":"  autoAssignLanguageMode (buffer) {\r\n    const result = this.selectGrammarWithScore(\r\n      buffer.getPath(),\r\n      getGrammarSelectionContent(buffer)\r\n    )\r\n    this.languageOverridesByBufferId.delete(buffer.id)\r\n    this.grammarScoresByBuffer.set(buffer, result.score)\r\n    if (result.grammar !== buffer.getLanguageMode().grammar) {\r\n      buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(result.grammar, buffer))\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"getGrammarSelectionContent","start_line":587,"end_line":592,"comment":[],"params":["buffer"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"languageModeForGrammarAndBuffer","line":166,"func_location":"GrammarRegistry.autoAssignLanguageMode","func_start_line":158,"func_end_line":168,"args":[null],"comment":[" Extended: Remove any language mode override that has been set for the"," given {TextBuffer}. This will assign to the buffer the best language"," mode available.",""," * `buffer` The {TextBuffer}."],"code":"  autoAssignLanguageMode (buffer) {\r\n    const result = this.selectGrammarWithScore(\r\n      buffer.getPath(),\r\n      getGrammarSelectionContent(buffer)\r\n    )\r\n    this.languageOverridesByBufferId.delete(buffer.id)\r\n    this.grammarScoresByBuffer.set(buffer, result.score)\r\n    if (result.grammar !== buffer.getLanguageMode().grammar) {\r\n      buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(result.grammar, buffer))\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.languageModeForGrammarAndBuffer","start_line":170,"end_line":176,"comment":[],"params":["grammar","buffer"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getScreenRange","line":737,"func_location":"Cursor.autoscroll","func_start_line":735,"func_end_line":738,"args":[null,"options"],"code":"  autoscroll (options = {}) {\r\n    options.clip = false\r\n    this.editor.scrollToScreenRange(this.getScreenRange(), options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getScreenRange","start_line":730,"end_line":733,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getHorizontalAutoscrollMargin","line":2072,"func_location":"TextEditorComponent.autoscrollHorizontally","func_start_line":2071,"func_end_line":2095,"args":[],"code":"  autoscrollHorizontally (screenRange, options) {\r\n    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin()\r\n\r\n    const gutterContainerWidth = this.getGutterContainerWidth()\r\n    let left = this.pixelLeftForRowAndColumn(screenRange.start.row, screenRange.start.column) + gutterContainerWidth\r\n    let right = this.pixelLeftForRowAndColumn(screenRange.end.row, screenRange.end.column) + gutterContainerWidth\r\n    const desiredScrollLeft = Math.max(0, left - horizontalScrollMargin - gutterContainerWidth)\r\n    const desiredScrollRight = Math.min(this.getScrollWidth(), right + horizontalScrollMargin)\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n    } else {\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getHorizontalAutoscrollMargin","start_line":2108,"end_line":2117,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getGutterContainerWidth","line":2074,"func_location":"TextEditorComponent.autoscrollHorizontally","func_start_line":2071,"func_end_line":2095,"args":[],"code":"  autoscrollHorizontally (screenRange, options) {\r\n    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin()\r\n\r\n    const gutterContainerWidth = this.getGutterContainerWidth()\r\n    let left = this.pixelLeftForRowAndColumn(screenRange.start.row, screenRange.start.column) + gutterContainerWidth\r\n    let right = this.pixelLeftForRowAndColumn(screenRange.end.row, screenRange.end.column) + gutterContainerWidth\r\n    const desiredScrollLeft = Math.max(0, left - horizontalScrollMargin - gutterContainerWidth)\r\n    const desiredScrollRight = Math.min(this.getScrollWidth(), right + horizontalScrollMargin)\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n    } else {\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getGutterContainerWidth","start_line":2696,"end_line":2698,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelLeftForRowAndColumn","line":2075,"func_location":"TextEditorComponent.autoscrollHorizontally","func_start_line":2071,"func_end_line":2095,"args":["screenRange.start.row","screenRange.start.column"],"code":"  autoscrollHorizontally (screenRange, options) {\r\n    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin()\r\n\r\n    const gutterContainerWidth = this.getGutterContainerWidth()\r\n    let left = this.pixelLeftForRowAndColumn(screenRange.start.row, screenRange.start.column) + gutterContainerWidth\r\n    let right = this.pixelLeftForRowAndColumn(screenRange.end.row, screenRange.end.column) + gutterContainerWidth\r\n    const desiredScrollLeft = Math.max(0, left - horizontalScrollMargin - gutterContainerWidth)\r\n    const desiredScrollRight = Math.min(this.getScrollWidth(), right + horizontalScrollMargin)\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n    } else {\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelLeftForRowAndColumn","start_line":2368,"end_line":2377,"comment":[],"params":["row","column"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelLeftForRowAndColumn","line":2076,"func_location":"TextEditorComponent.autoscrollHorizontally","func_start_line":2071,"func_end_line":2095,"args":["screenRange.end.row","screenRange.end.column"],"code":"  autoscrollHorizontally (screenRange, options) {\r\n    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin()\r\n\r\n    const gutterContainerWidth = this.getGutterContainerWidth()\r\n    let left = this.pixelLeftForRowAndColumn(screenRange.start.row, screenRange.start.column) + gutterContainerWidth\r\n    let right = this.pixelLeftForRowAndColumn(screenRange.end.row, screenRange.end.column) + gutterContainerWidth\r\n    const desiredScrollLeft = Math.max(0, left - horizontalScrollMargin - gutterContainerWidth)\r\n    const desiredScrollRight = Math.min(this.getScrollWidth(), right + horizontalScrollMargin)\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n    } else {\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelLeftForRowAndColumn","start_line":2368,"end_line":2377,"comment":[],"params":["row","column"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollWidth","line":2078,"func_location":"TextEditorComponent.autoscrollHorizontally","func_start_line":2071,"func_end_line":2095,"args":[null,null],"code":"  autoscrollHorizontally (screenRange, options) {\r\n    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin()\r\n\r\n    const gutterContainerWidth = this.getGutterContainerWidth()\r\n    let left = this.pixelLeftForRowAndColumn(screenRange.start.row, screenRange.start.column) + gutterContainerWidth\r\n    let right = this.pixelLeftForRowAndColumn(screenRange.end.row, screenRange.end.column) + gutterContainerWidth\r\n    const desiredScrollLeft = Math.max(0, left - horizontalScrollMargin - gutterContainerWidth)\r\n    const desiredScrollRight = Math.min(this.getScrollWidth(), right + horizontalScrollMargin)\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n    } else {\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollWidth","start_line":2672,"end_line":2682,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollRight","line":2081,"func_location":"TextEditorComponent.autoscrollHorizontally","func_start_line":2071,"func_end_line":2095,"args":[],"code":"  autoscrollHorizontally (screenRange, options) {\r\n    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin()\r\n\r\n    const gutterContainerWidth = this.getGutterContainerWidth()\r\n    let left = this.pixelLeftForRowAndColumn(screenRange.start.row, screenRange.start.column) + gutterContainerWidth\r\n    let right = this.pixelLeftForRowAndColumn(screenRange.end.row, screenRange.end.column) + gutterContainerWidth\r\n    const desiredScrollLeft = Math.max(0, left - horizontalScrollMargin - gutterContainerWidth)\r\n    const desiredScrollRight = Math.min(this.getScrollWidth(), right + horizontalScrollMargin)\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n    } else {\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollRight","start_line":2845,"end_line":2847,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"setScrollRight","line":2082,"func_location":"TextEditorComponent.autoscrollHorizontally","func_start_line":2071,"func_end_line":2095,"args":["desiredScrollRight"],"code":"  autoscrollHorizontally (screenRange, options) {\r\n    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin()\r\n\r\n    const gutterContainerWidth = this.getGutterContainerWidth()\r\n    let left = this.pixelLeftForRowAndColumn(screenRange.start.row, screenRange.start.column) + gutterContainerWidth\r\n    let right = this.pixelLeftForRowAndColumn(screenRange.end.row, screenRange.end.column) + gutterContainerWidth\r\n    const desiredScrollLeft = Math.max(0, left - horizontalScrollMargin - gutterContainerWidth)\r\n    const desiredScrollRight = Math.min(this.getScrollWidth(), right + horizontalScrollMargin)\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n    } else {\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.setScrollRight","start_line":2849,"end_line":2851,"comment":[],"params":["scrollRight"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollLeft","line":2084,"func_location":"TextEditorComponent.autoscrollHorizontally","func_start_line":2071,"func_end_line":2095,"args":[],"code":"  autoscrollHorizontally (screenRange, options) {\r\n    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin()\r\n\r\n    const gutterContainerWidth = this.getGutterContainerWidth()\r\n    let left = this.pixelLeftForRowAndColumn(screenRange.start.row, screenRange.start.column) + gutterContainerWidth\r\n    let right = this.pixelLeftForRowAndColumn(screenRange.end.row, screenRange.end.column) + gutterContainerWidth\r\n    const desiredScrollLeft = Math.max(0, left - horizontalScrollMargin - gutterContainerWidth)\r\n    const desiredScrollRight = Math.min(this.getScrollWidth(), right + horizontalScrollMargin)\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n    } else {\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollLeft","start_line":2823,"end_line":2825,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"setScrollLeft","line":2085,"func_location":"TextEditorComponent.autoscrollHorizontally","func_start_line":2071,"func_end_line":2095,"args":["desiredScrollLeft"],"code":"  autoscrollHorizontally (screenRange, options) {\r\n    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin()\r\n\r\n    const gutterContainerWidth = this.getGutterContainerWidth()\r\n    let left = this.pixelLeftForRowAndColumn(screenRange.start.row, screenRange.start.column) + gutterContainerWidth\r\n    let right = this.pixelLeftForRowAndColumn(screenRange.end.row, screenRange.end.column) + gutterContainerWidth\r\n    const desiredScrollLeft = Math.max(0, left - horizontalScrollMargin - gutterContainerWidth)\r\n    const desiredScrollRight = Math.min(this.getScrollWidth(), right + horizontalScrollMargin)\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n    } else {\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.setScrollLeft","start_line":2827,"end_line":2839,"comment":[],"params":["scrollLeft"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollLeft","line":2088,"func_location":"TextEditorComponent.autoscrollHorizontally","func_start_line":2071,"func_end_line":2095,"args":[],"code":"  autoscrollHorizontally (screenRange, options) {\r\n    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin()\r\n\r\n    const gutterContainerWidth = this.getGutterContainerWidth()\r\n    let left = this.pixelLeftForRowAndColumn(screenRange.start.row, screenRange.start.column) + gutterContainerWidth\r\n    let right = this.pixelLeftForRowAndColumn(screenRange.end.row, screenRange.end.column) + gutterContainerWidth\r\n    const desiredScrollLeft = Math.max(0, left - horizontalScrollMargin - gutterContainerWidth)\r\n    const desiredScrollRight = Math.min(this.getScrollWidth(), right + horizontalScrollMargin)\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n    } else {\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollLeft","start_line":2823,"end_line":2825,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"setScrollLeft","line":2089,"func_location":"TextEditorComponent.autoscrollHorizontally","func_start_line":2071,"func_end_line":2095,"args":["desiredScrollLeft"],"code":"  autoscrollHorizontally (screenRange, options) {\r\n    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin()\r\n\r\n    const gutterContainerWidth = this.getGutterContainerWidth()\r\n    let left = this.pixelLeftForRowAndColumn(screenRange.start.row, screenRange.start.column) + gutterContainerWidth\r\n    let right = this.pixelLeftForRowAndColumn(screenRange.end.row, screenRange.end.column) + gutterContainerWidth\r\n    const desiredScrollLeft = Math.max(0, left - horizontalScrollMargin - gutterContainerWidth)\r\n    const desiredScrollRight = Math.min(this.getScrollWidth(), right + horizontalScrollMargin)\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n    } else {\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.setScrollLeft","start_line":2827,"end_line":2839,"comment":[],"params":["scrollLeft"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollRight","line":2091,"func_location":"TextEditorComponent.autoscrollHorizontally","func_start_line":2071,"func_end_line":2095,"args":[],"code":"  autoscrollHorizontally (screenRange, options) {\r\n    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin()\r\n\r\n    const gutterContainerWidth = this.getGutterContainerWidth()\r\n    let left = this.pixelLeftForRowAndColumn(screenRange.start.row, screenRange.start.column) + gutterContainerWidth\r\n    let right = this.pixelLeftForRowAndColumn(screenRange.end.row, screenRange.end.column) + gutterContainerWidth\r\n    const desiredScrollLeft = Math.max(0, left - horizontalScrollMargin - gutterContainerWidth)\r\n    const desiredScrollRight = Math.min(this.getScrollWidth(), right + horizontalScrollMargin)\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n    } else {\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollRight","start_line":2845,"end_line":2847,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"setScrollRight","line":2092,"func_location":"TextEditorComponent.autoscrollHorizontally","func_start_line":2071,"func_end_line":2095,"args":["desiredScrollRight"],"code":"  autoscrollHorizontally (screenRange, options) {\r\n    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin()\r\n\r\n    const gutterContainerWidth = this.getGutterContainerWidth()\r\n    let left = this.pixelLeftForRowAndColumn(screenRange.start.row, screenRange.start.column) + gutterContainerWidth\r\n    let right = this.pixelLeftForRowAndColumn(screenRange.end.row, screenRange.end.column) + gutterContainerWidth\r\n    const desiredScrollLeft = Math.max(0, left - horizontalScrollMargin - gutterContainerWidth)\r\n    const desiredScrollRight = Math.min(this.getScrollWidth(), right + horizontalScrollMargin)\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n    } else {\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.setScrollRight","start_line":2849,"end_line":2851,"comment":[],"params":["scrollRight"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"scaleMouseDragAutoscrollDelta","line":1949,"func_location":"TextEditorComponent.autoscrollOnMouseDrag","func_start_line":1922,"func_end_line":1959,"args":["yDelta"],"code":"  autoscrollOnMouseDrag ({clientX, clientY}, verticalOnly = false) {\r\n    var {top, bottom, left, right} = this.refs.scrollContainer.getBoundingClientRect() // Using var to avoid deopt on += assignments below\r\n    top += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    bottom -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    left += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    right -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n\r\n    let yDelta, yDirection\r\n    if (clientY < top) {\r\n      yDelta = top - clientY\r\n      yDirection = -1\r\n    } else if (clientY > bottom) {\r\n      yDelta = clientY - bottom\r\n      yDirection = 1\r\n    }\r\n\r\n    let xDelta, xDirection\r\n    if (clientX < left) {\r\n      xDelta = left - clientX\r\n      xDirection = -1\r\n    } else if (clientX > right) {\r\n      xDelta = clientX - right\r\n      xDirection = 1\r\n    }\r\n\r\n    let scrolled = false\r\n    if (yDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(yDelta) * yDirection\r\n      scrolled = this.setScrollTop(this.getScrollTop() + scaledDelta)\r\n    }\r\n\r\n    if (!verticalOnly && xDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(xDelta) * xDirection\r\n      scrolled = this.setScrollLeft(this.getScrollLeft() + scaledDelta)\r\n    }\r\n\r\n    if (scrolled) this.updateSync()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"scaleMouseDragAutoscrollDelta","start_line":25,"end_line":27,"comment":[],"params":["delta"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"setScrollTop","line":1950,"func_location":"TextEditorComponent.autoscrollOnMouseDrag","func_start_line":1922,"func_end_line":1959,"args":[null],"code":"  autoscrollOnMouseDrag ({clientX, clientY}, verticalOnly = false) {\r\n    var {top, bottom, left, right} = this.refs.scrollContainer.getBoundingClientRect() // Using var to avoid deopt on += assignments below\r\n    top += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    bottom -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    left += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    right -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n\r\n    let yDelta, yDirection\r\n    if (clientY < top) {\r\n      yDelta = top - clientY\r\n      yDirection = -1\r\n    } else if (clientY > bottom) {\r\n      yDelta = clientY - bottom\r\n      yDirection = 1\r\n    }\r\n\r\n    let xDelta, xDirection\r\n    if (clientX < left) {\r\n      xDelta = left - clientX\r\n      xDirection = -1\r\n    } else if (clientX > right) {\r\n      xDelta = clientX - right\r\n      xDirection = 1\r\n    }\r\n\r\n    let scrolled = false\r\n    if (yDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(yDelta) * yDirection\r\n      scrolled = this.setScrollTop(this.getScrollTop() + scaledDelta)\r\n    }\r\n\r\n    if (!verticalOnly && xDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(xDelta) * xDirection\r\n      scrolled = this.setScrollLeft(this.getScrollLeft() + scaledDelta)\r\n    }\r\n\r\n    if (scrolled) this.updateSync()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.setScrollTop","start_line":2796,"end_line":2809,"comment":[],"params":["scrollTop"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollTop","line":1950,"func_location":"TextEditorComponent.autoscrollOnMouseDrag","func_start_line":1922,"func_end_line":1959,"args":[null],"code":"  autoscrollOnMouseDrag ({clientX, clientY}, verticalOnly = false) {\r\n    var {top, bottom, left, right} = this.refs.scrollContainer.getBoundingClientRect() // Using var to avoid deopt on += assignments below\r\n    top += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    bottom -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    left += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    right -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n\r\n    let yDelta, yDirection\r\n    if (clientY < top) {\r\n      yDelta = top - clientY\r\n      yDirection = -1\r\n    } else if (clientY > bottom) {\r\n      yDelta = clientY - bottom\r\n      yDirection = 1\r\n    }\r\n\r\n    let xDelta, xDirection\r\n    if (clientX < left) {\r\n      xDelta = left - clientX\r\n      xDirection = -1\r\n    } else if (clientX > right) {\r\n      xDelta = clientX - right\r\n      xDirection = 1\r\n    }\r\n\r\n    let scrolled = false\r\n    if (yDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(yDelta) * yDirection\r\n      scrolled = this.setScrollTop(this.getScrollTop() + scaledDelta)\r\n    }\r\n\r\n    if (!verticalOnly && xDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(xDelta) * xDirection\r\n      scrolled = this.setScrollLeft(this.getScrollLeft() + scaledDelta)\r\n    }\r\n\r\n    if (scrolled) this.updateSync()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollTop","start_line":2791,"end_line":2794,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"scaleMouseDragAutoscrollDelta","line":1954,"func_location":"TextEditorComponent.autoscrollOnMouseDrag","func_start_line":1922,"func_end_line":1959,"args":["xDelta"],"code":"  autoscrollOnMouseDrag ({clientX, clientY}, verticalOnly = false) {\r\n    var {top, bottom, left, right} = this.refs.scrollContainer.getBoundingClientRect() // Using var to avoid deopt on += assignments below\r\n    top += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    bottom -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    left += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    right -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n\r\n    let yDelta, yDirection\r\n    if (clientY < top) {\r\n      yDelta = top - clientY\r\n      yDirection = -1\r\n    } else if (clientY > bottom) {\r\n      yDelta = clientY - bottom\r\n      yDirection = 1\r\n    }\r\n\r\n    let xDelta, xDirection\r\n    if (clientX < left) {\r\n      xDelta = left - clientX\r\n      xDirection = -1\r\n    } else if (clientX > right) {\r\n      xDelta = clientX - right\r\n      xDirection = 1\r\n    }\r\n\r\n    let scrolled = false\r\n    if (yDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(yDelta) * yDirection\r\n      scrolled = this.setScrollTop(this.getScrollTop() + scaledDelta)\r\n    }\r\n\r\n    if (!verticalOnly && xDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(xDelta) * xDirection\r\n      scrolled = this.setScrollLeft(this.getScrollLeft() + scaledDelta)\r\n    }\r\n\r\n    if (scrolled) this.updateSync()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"scaleMouseDragAutoscrollDelta","start_line":25,"end_line":27,"comment":[],"params":["delta"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"setScrollLeft","line":1955,"func_location":"TextEditorComponent.autoscrollOnMouseDrag","func_start_line":1922,"func_end_line":1959,"args":[null],"code":"  autoscrollOnMouseDrag ({clientX, clientY}, verticalOnly = false) {\r\n    var {top, bottom, left, right} = this.refs.scrollContainer.getBoundingClientRect() // Using var to avoid deopt on += assignments below\r\n    top += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    bottom -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    left += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    right -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n\r\n    let yDelta, yDirection\r\n    if (clientY < top) {\r\n      yDelta = top - clientY\r\n      yDirection = -1\r\n    } else if (clientY > bottom) {\r\n      yDelta = clientY - bottom\r\n      yDirection = 1\r\n    }\r\n\r\n    let xDelta, xDirection\r\n    if (clientX < left) {\r\n      xDelta = left - clientX\r\n      xDirection = -1\r\n    } else if (clientX > right) {\r\n      xDelta = clientX - right\r\n      xDirection = 1\r\n    }\r\n\r\n    let scrolled = false\r\n    if (yDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(yDelta) * yDirection\r\n      scrolled = this.setScrollTop(this.getScrollTop() + scaledDelta)\r\n    }\r\n\r\n    if (!verticalOnly && xDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(xDelta) * xDirection\r\n      scrolled = this.setScrollLeft(this.getScrollLeft() + scaledDelta)\r\n    }\r\n\r\n    if (scrolled) this.updateSync()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.setScrollLeft","start_line":2827,"end_line":2839,"comment":[],"params":["scrollLeft"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollLeft","line":1955,"func_location":"TextEditorComponent.autoscrollOnMouseDrag","func_start_line":1922,"func_end_line":1959,"args":[null],"code":"  autoscrollOnMouseDrag ({clientX, clientY}, verticalOnly = false) {\r\n    var {top, bottom, left, right} = this.refs.scrollContainer.getBoundingClientRect() // Using var to avoid deopt on += assignments below\r\n    top += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    bottom -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    left += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    right -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n\r\n    let yDelta, yDirection\r\n    if (clientY < top) {\r\n      yDelta = top - clientY\r\n      yDirection = -1\r\n    } else if (clientY > bottom) {\r\n      yDelta = clientY - bottom\r\n      yDirection = 1\r\n    }\r\n\r\n    let xDelta, xDirection\r\n    if (clientX < left) {\r\n      xDelta = left - clientX\r\n      xDirection = -1\r\n    } else if (clientX > right) {\r\n      xDelta = clientX - right\r\n      xDirection = 1\r\n    }\r\n\r\n    let scrolled = false\r\n    if (yDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(yDelta) * yDirection\r\n      scrolled = this.setScrollTop(this.getScrollTop() + scaledDelta)\r\n    }\r\n\r\n    if (!verticalOnly && xDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(xDelta) * xDirection\r\n      scrolled = this.setScrollLeft(this.getScrollLeft() + scaledDelta)\r\n    }\r\n\r\n    if (scrolled) this.updateSync()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollLeft","start_line":2823,"end_line":2825,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateSync","line":1958,"func_location":"TextEditorComponent.autoscrollOnMouseDrag","func_start_line":1922,"func_end_line":1959,"args":[],"code":"  autoscrollOnMouseDrag ({clientX, clientY}, verticalOnly = false) {\r\n    var {top, bottom, left, right} = this.refs.scrollContainer.getBoundingClientRect() // Using var to avoid deopt on += assignments below\r\n    top += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    bottom -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    left += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    right -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n\r\n    let yDelta, yDirection\r\n    if (clientY < top) {\r\n      yDelta = top - clientY\r\n      yDirection = -1\r\n    } else if (clientY > bottom) {\r\n      yDelta = clientY - bottom\r\n      yDirection = 1\r\n    }\r\n\r\n    let xDelta, xDirection\r\n    if (clientX < left) {\r\n      xDelta = left - clientX\r\n      xDirection = -1\r\n    } else if (clientX > right) {\r\n      xDelta = clientX - right\r\n      xDirection = 1\r\n    }\r\n\r\n    let scrolled = false\r\n    if (yDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(yDelta) * yDirection\r\n      scrolled = this.setScrollTop(this.getScrollTop() + scaledDelta)\r\n    }\r\n\r\n    if (!verticalOnly && xDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(xDelta) * xDirection\r\n      scrolled = this.setScrollLeft(this.getScrollLeft() + scaledDelta)\r\n    }\r\n\r\n    if (scrolled) this.updateSync()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateSync","start_line":221,"end_line":289,"comment":[],"params":["useScheduler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelPositionAfterBlocksForRow","line":2036,"func_location":"TextEditorComponent.autoscrollVertically","func_start_line":2035,"func_end_line":2069,"args":["screenRange.start.row"],"code":"  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelPositionAfterBlocksForRow","start_line":2364,"end_line":2366,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelPositionAfterBlocksForRow","line":2037,"func_location":"TextEditorComponent.autoscrollVertically","func_start_line":2035,"func_end_line":2069,"args":["screenRange.end.row"],"code":"  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelPositionAfterBlocksForRow","start_line":2364,"end_line":2366,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getLineHeight","line":2037,"func_location":"TextEditorComponent.autoscrollVertically","func_start_line":2035,"func_end_line":2069,"args":["screenRange.end.row"],"code":"  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getLineHeight","start_line":2600,"end_line":2602,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getVerticalAutoscrollMargin","line":2038,"func_location":"TextEditorComponent.autoscrollVertically","func_start_line":2035,"func_end_line":2069,"args":[],"code":"  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getVerticalAutoscrollMargin","start_line":2097,"end_line":2106,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollTop","line":2043,"func_location":"TextEditorComponent.autoscrollVertically","func_start_line":2035,"func_end_line":2069,"args":[],"code":"  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollTop","start_line":2791,"end_line":2794,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollBottom","line":2043,"func_location":"TextEditorComponent.autoscrollVertically","func_start_line":2035,"func_end_line":2069,"args":[],"code":"  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollBottom","start_line":2815,"end_line":2817,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollContainerClientHeight","line":2044,"func_location":"TextEditorComponent.autoscrollVertically","func_start_line":2035,"func_end_line":2069,"args":[],"code":"  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollContainerClientHeight","start_line":2640,"end_line":2642,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollContainerClientHeight","line":2045,"func_location":"TextEditorComponent.autoscrollVertically","func_start_line":2035,"func_end_line":2069,"args":[],"code":"  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollContainerClientHeight","start_line":2640,"end_line":2642,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollBottom","line":2053,"func_location":"TextEditorComponent.autoscrollVertically","func_start_line":2035,"func_end_line":2069,"args":[],"code":"  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollBottom","start_line":2815,"end_line":2817,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"setScrollBottom","line":2054,"func_location":"TextEditorComponent.autoscrollVertically","func_start_line":2035,"func_end_line":2069,"args":["desiredScrollBottom"],"code":"  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.setScrollBottom","start_line":2819,"end_line":2821,"comment":[],"params":["scrollBottom"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollTop","line":2056,"func_location":"TextEditorComponent.autoscrollVertically","func_start_line":2035,"func_end_line":2069,"args":[],"code":"  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollTop","start_line":2791,"end_line":2794,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"setScrollTop","line":2057,"func_location":"TextEditorComponent.autoscrollVertically","func_start_line":2035,"func_end_line":2069,"args":["desiredScrollTop"],"code":"  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.setScrollTop","start_line":2796,"end_line":2809,"comment":[],"params":["scrollTop"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollTop","line":2060,"func_location":"TextEditorComponent.autoscrollVertically","func_start_line":2035,"func_end_line":2069,"args":[],"code":"  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollTop","start_line":2791,"end_line":2794,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"setScrollTop","line":2061,"func_location":"TextEditorComponent.autoscrollVertically","func_start_line":2035,"func_end_line":2069,"args":["desiredScrollTop"],"code":"  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.setScrollTop","start_line":2796,"end_line":2809,"comment":[],"params":["scrollTop"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollBottom","line":2063,"func_location":"TextEditorComponent.autoscrollVertically","func_start_line":2035,"func_end_line":2069,"args":[],"code":"  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollBottom","start_line":2815,"end_line":2817,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"setScrollBottom","line":2064,"func_location":"TextEditorComponent.autoscrollVertically","func_start_line":2035,"func_end_line":2069,"args":["desiredScrollBottom"],"code":"  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.setScrollBottom","start_line":2819,"end_line":2821,"comment":[],"params":["scrollBottom"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"ensureWritable","line":521,"func_location":"Selection.backspace","func_start_line":520,"func_end_line":524,"args":[{"type":"string"},"options"],"comment":[" Public: Removes the first character before the selection if the selection"," is empty otherwise it deletes the selection.",""," * `options` (optional) {Object}","   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"],"code":"  backspace (options = {}) {\r\n    if (!this.ensureWritable('backspace', options)) return\r\n    if (this.isEmpty()) this.selectLeft()\r\n    this.deleteSelectedText(options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.ensureWritable","start_line":412,"end_line":427,"comment":[" Private: Ensure that the {TextEditor} is not marked read-only before allowing a buffer modification to occur. if"," the editor is read-only, require an explicit opt-in option to proceed (`bypassReadOnly`) or throw an Error."],"params":["methodName","opts"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"isEmpty","line":522,"func_location":"Selection.backspace","func_start_line":520,"func_end_line":524,"args":[],"comment":[" Public: Removes the first character before the selection if the selection"," is empty otherwise it deletes the selection.",""," * `options` (optional) {Object}","   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"],"code":"  backspace (options = {}) {\r\n    if (!this.ensureWritable('backspace', options)) return\r\n    if (this.isEmpty()) this.selectLeft()\r\n    this.deleteSelectedText(options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.isEmpty","start_line":139,"end_line":141,"comment":["\r\n  Section: Info about the selection\r\n  "," Public: Determines if the selection contains anything."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"selectLeft","line":522,"func_location":"Selection.backspace","func_start_line":520,"func_end_line":524,"args":[],"comment":[" Public: Removes the first character before the selection if the selection"," is empty otherwise it deletes the selection.",""," * `options` (optional) {Object}","   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"],"code":"  backspace (options = {}) {\r\n    if (!this.ensureWritable('backspace', options)) return\r\n    if (this.isEmpty()) this.selectLeft()\r\n    this.deleteSelectedText(options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.selectLeft","start_line":251,"end_line":253,"comment":[" Public: Selects the text one position left of the cursor.",""," * `columnCount` (optional) {Number} number of columns to select (default: 1)"],"params":["columnCount"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"updateInvalidRows","line":364,"func_location":"TextMateLanguageMode.bufferDidChange","func_start_line":354,"func_end_line":376,"args":["start","end","delta"],"code":"  bufferDidChange (e) {\r\n    this.changeCount = this.buffer.changeCount\r\n\r\n    const {oldRange, newRange} = e\r\n    const start = oldRange.start.row\r\n    const end = oldRange.end.row\r\n    const delta = newRange.end.row - oldRange.end.row\r\n    const oldLineCount = (oldRange.end.row - oldRange.start.row) + 1\r\n    const newLineCount = (newRange.end.row - newRange.start.row) + 1\r\n\r\n    this.updateInvalidRows(start, end, delta)\r\n    const previousEndStack = this.stackForRow(end) // used in spill detection below\r\n    if (this.largeFileMode || (this.grammar.name === 'Null Grammar')) {\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, new Array(newLineCount))\r\n    } else {\r\n      const newTokenizedLines = this.buildTokenizedLinesForRows(start, end + delta, this.stackForRow(start - 1), this.openScopesForRow(start))\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, newTokenizedLines)\r\n      const newEndStack = this.stackForRow(end + delta)\r\n      if (newEndStack && !_.isEqual(newEndStack, previousEndStack)) {\r\n        this.invalidateRow(end + delta + 1)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.updateInvalidRows","start_line":342,"end_line":352,"comment":[],"params":["start","end","delta"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"stackForRow","line":365,"func_location":"TextMateLanguageMode.bufferDidChange","func_start_line":354,"func_end_line":376,"args":["end"],"code":"  bufferDidChange (e) {\r\n    this.changeCount = this.buffer.changeCount\r\n\r\n    const {oldRange, newRange} = e\r\n    const start = oldRange.start.row\r\n    const end = oldRange.end.row\r\n    const delta = newRange.end.row - oldRange.end.row\r\n    const oldLineCount = (oldRange.end.row - oldRange.start.row) + 1\r\n    const newLineCount = (newRange.end.row - newRange.start.row) + 1\r\n\r\n    this.updateInvalidRows(start, end, delta)\r\n    const previousEndStack = this.stackForRow(end) // used in spill detection below\r\n    if (this.largeFileMode || (this.grammar.name === 'Null Grammar')) {\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, new Array(newLineCount))\r\n    } else {\r\n      const newTokenizedLines = this.buildTokenizedLinesForRows(start, end + delta, this.stackForRow(start - 1), this.openScopesForRow(start))\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, newTokenizedLines)\r\n      const newEndStack = this.stackForRow(end + delta)\r\n      if (newEndStack && !_.isEqual(newEndStack, previousEndStack)) {\r\n        this.invalidateRow(end + delta + 1)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.stackForRow","start_line":459,"end_line":461,"comment":[],"params":["bufferRow"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"buildTokenizedLinesForRows","line":369,"func_location":"TextMateLanguageMode.bufferDidChange","func_start_line":354,"func_end_line":376,"args":["start",null,null,null],"code":"  bufferDidChange (e) {\r\n    this.changeCount = this.buffer.changeCount\r\n\r\n    const {oldRange, newRange} = e\r\n    const start = oldRange.start.row\r\n    const end = oldRange.end.row\r\n    const delta = newRange.end.row - oldRange.end.row\r\n    const oldLineCount = (oldRange.end.row - oldRange.start.row) + 1\r\n    const newLineCount = (newRange.end.row - newRange.start.row) + 1\r\n\r\n    this.updateInvalidRows(start, end, delta)\r\n    const previousEndStack = this.stackForRow(end) // used in spill detection below\r\n    if (this.largeFileMode || (this.grammar.name === 'Null Grammar')) {\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, new Array(newLineCount))\r\n    } else {\r\n      const newTokenizedLines = this.buildTokenizedLinesForRows(start, end + delta, this.stackForRow(start - 1), this.openScopesForRow(start))\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, newTokenizedLines)\r\n      const newEndStack = this.stackForRow(end + delta)\r\n      if (newEndStack && !_.isEqual(newEndStack, previousEndStack)) {\r\n        this.invalidateRow(end + delta + 1)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.buildTokenizedLinesForRows","start_line":384,"end_line":405,"comment":[],"params":["startRow","endRow","startingStack","startingopenScopes"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"stackForRow","line":369,"func_location":"TextMateLanguageMode.bufferDidChange","func_start_line":354,"func_end_line":376,"args":["start",null,null,null],"code":"  bufferDidChange (e) {\r\n    this.changeCount = this.buffer.changeCount\r\n\r\n    const {oldRange, newRange} = e\r\n    const start = oldRange.start.row\r\n    const end = oldRange.end.row\r\n    const delta = newRange.end.row - oldRange.end.row\r\n    const oldLineCount = (oldRange.end.row - oldRange.start.row) + 1\r\n    const newLineCount = (newRange.end.row - newRange.start.row) + 1\r\n\r\n    this.updateInvalidRows(start, end, delta)\r\n    const previousEndStack = this.stackForRow(end) // used in spill detection below\r\n    if (this.largeFileMode || (this.grammar.name === 'Null Grammar')) {\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, new Array(newLineCount))\r\n    } else {\r\n      const newTokenizedLines = this.buildTokenizedLinesForRows(start, end + delta, this.stackForRow(start - 1), this.openScopesForRow(start))\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, newTokenizedLines)\r\n      const newEndStack = this.stackForRow(end + delta)\r\n      if (newEndStack && !_.isEqual(newEndStack, previousEndStack)) {\r\n        this.invalidateRow(end + delta + 1)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.stackForRow","start_line":459,"end_line":461,"comment":[],"params":["bufferRow"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"openScopesForRow","line":369,"func_location":"TextMateLanguageMode.bufferDidChange","func_start_line":354,"func_end_line":376,"args":["start",null,null,null],"code":"  bufferDidChange (e) {\r\n    this.changeCount = this.buffer.changeCount\r\n\r\n    const {oldRange, newRange} = e\r\n    const start = oldRange.start.row\r\n    const end = oldRange.end.row\r\n    const delta = newRange.end.row - oldRange.end.row\r\n    const oldLineCount = (oldRange.end.row - oldRange.start.row) + 1\r\n    const newLineCount = (newRange.end.row - newRange.start.row) + 1\r\n\r\n    this.updateInvalidRows(start, end, delta)\r\n    const previousEndStack = this.stackForRow(end) // used in spill detection below\r\n    if (this.largeFileMode || (this.grammar.name === 'Null Grammar')) {\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, new Array(newLineCount))\r\n    } else {\r\n      const newTokenizedLines = this.buildTokenizedLinesForRows(start, end + delta, this.stackForRow(start - 1), this.openScopesForRow(start))\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, newTokenizedLines)\r\n      const newEndStack = this.stackForRow(end + delta)\r\n      if (newEndStack && !_.isEqual(newEndStack, previousEndStack)) {\r\n        this.invalidateRow(end + delta + 1)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.openScopesForRow","start_line":463,"end_line":470,"comment":[],"params":["bufferRow"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"stackForRow","line":371,"func_location":"TextMateLanguageMode.bufferDidChange","func_start_line":354,"func_end_line":376,"args":[null],"code":"  bufferDidChange (e) {\r\n    this.changeCount = this.buffer.changeCount\r\n\r\n    const {oldRange, newRange} = e\r\n    const start = oldRange.start.row\r\n    const end = oldRange.end.row\r\n    const delta = newRange.end.row - oldRange.end.row\r\n    const oldLineCount = (oldRange.end.row - oldRange.start.row) + 1\r\n    const newLineCount = (newRange.end.row - newRange.start.row) + 1\r\n\r\n    this.updateInvalidRows(start, end, delta)\r\n    const previousEndStack = this.stackForRow(end) // used in spill detection below\r\n    if (this.largeFileMode || (this.grammar.name === 'Null Grammar')) {\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, new Array(newLineCount))\r\n    } else {\r\n      const newTokenizedLines = this.buildTokenizedLinesForRows(start, end + delta, this.stackForRow(start - 1), this.openScopesForRow(start))\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, newTokenizedLines)\r\n      const newEndStack = this.stackForRow(end + delta)\r\n      if (newEndStack && !_.isEqual(newEndStack, previousEndStack)) {\r\n        this.invalidateRow(end + delta + 1)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.stackForRow","start_line":459,"end_line":461,"comment":[],"params":["bufferRow"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"invalidateRow","line":373,"func_location":"TextMateLanguageMode.bufferDidChange","func_start_line":354,"func_end_line":376,"args":[null],"code":"  bufferDidChange (e) {\r\n    this.changeCount = this.buffer.changeCount\r\n\r\n    const {oldRange, newRange} = e\r\n    const start = oldRange.start.row\r\n    const end = oldRange.end.row\r\n    const delta = newRange.end.row - oldRange.end.row\r\n    const oldLineCount = (oldRange.end.row - oldRange.start.row) + 1\r\n    const newLineCount = (newRange.end.row - newRange.start.row) + 1\r\n\r\n    this.updateInvalidRows(start, end, delta)\r\n    const previousEndStack = this.stackForRow(end) // used in spill detection below\r\n    if (this.largeFileMode || (this.grammar.name === 'Null Grammar')) {\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, new Array(newLineCount))\r\n    } else {\r\n      const newTokenizedLines = this.buildTokenizedLinesForRows(start, end + delta, this.stackForRow(start - 1), this.openScopesForRow(start))\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, newTokenizedLines)\r\n      const newEndStack = this.stackForRow(end + delta)\r\n      if (newEndStack && !_.isEqual(newEndStack, previousEndStack)) {\r\n        this.invalidateRow(end + delta + 1)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.invalidateRow","start_line":336,"end_line":340,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"findBufferForId","line":654,"func_location":"Project.bufferForIdSync","func_start_line":650,"func_end_line":656,"args":["id"],"comment":[" Only to be used when deserializing"],"code":"  bufferForIdSync (id) {\r\n    if (this.retiredBufferIDs.has(id)) { return null }\r\n\r\n    let existingBuffer\r\n    if (id) { existingBuffer = this.findBufferForId(id) }\r\n    return existingBuffer != null ? existingBuffer : this.buildBufferSync()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.findBufferForId","start_line":635,"end_line":637,"comment":[],"params":["id"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"buildBufferSync","line":655,"func_location":"Project.bufferForIdSync","func_start_line":650,"func_end_line":656,"args":[],"comment":[" Only to be used when deserializing"],"code":"  bufferForIdSync (id) {\r\n    if (this.retiredBufferIDs.has(id)) { return null }\r\n\r\n    let existingBuffer\r\n    if (id) { existingBuffer = this.findBufferForId(id) }\r\n    return existingBuffer != null ? existingBuffer : this.buildBufferSync()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.buildBufferSync","start_line":681,"end_line":692,"comment":[" Still needed when deserializing a tokenized buffer"],"params":["absoluteFilePath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"findBufferForPath","line":668,"func_location":"Project.bufferForPath","func_start_line":666,"func_end_line":674,"args":["absoluteFilePath"],"comment":[" Given a file path, this retrieves or creates a new {TextBuffer}.",""," If the `filePath` already has a `buffer`, that value is used instead. Otherwise,"," `text` is used as the contents of the new buffer.",""," * `filePath` A {String} representing a path. If `null`, an \"Untitled\" buffer is created.",""," Returns a {Promise} that resolves to the {TextBuffer}."],"code":"  bufferForPath (absoluteFilePath) {\r\n    let existingBuffer\r\n    if (absoluteFilePath != null) { existingBuffer = this.findBufferForPath(absoluteFilePath) }\r\n    if (existingBuffer) {\r\n      return Promise.resolve(existingBuffer)\r\n    } else {\r\n      return this.buildBuffer(absoluteFilePath)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.findBufferForPath","start_line":631,"end_line":633,"comment":[],"params":["filePath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"buildBuffer","line":672,"func_location":"Project.bufferForPath","func_start_line":666,"func_end_line":674,"args":["absoluteFilePath"],"comment":[" Given a file path, this retrieves or creates a new {TextBuffer}.",""," If the `filePath` already has a `buffer`, that value is used instead. Otherwise,"," `text` is used as the contents of the new buffer.",""," * `filePath` A {String} representing a path. If `null`, an \"Untitled\" buffer is created.",""," Returns a {Promise} that resolves to the {TextBuffer}."],"code":"  bufferForPath (absoluteFilePath) {\r\n    let existingBuffer\r\n    if (absoluteFilePath != null) { existingBuffer = this.findBufferForPath(absoluteFilePath) }\r\n    if (existingBuffer) {\r\n      return Promise.resolve(existingBuffer)\r\n    } else {\r\n      return this.buildBuffer(absoluteFilePath)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.buildBuffer","start_line":700,"end_line":726,"comment":[" Given a file path, this sets its {TextBuffer}.",""," * `absoluteFilePath` A {String} representing a path."," * `text` The {String} text to use as a buffer.",""," Returns a {Promise} that resolves to the {TextBuffer}."],"params":["absoluteFilePath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"resolvePath","line":641,"func_location":"Project.bufferForPathSync","func_start_line":640,"func_end_line":647,"args":["filePath"],"comment":[" Only to be used in specs"],"code":"  bufferForPathSync (filePath) {\r\n    const absoluteFilePath = this.resolvePath(filePath)\r\n    if (this.retiredBufferPaths.has(absoluteFilePath)) { return null }\r\n\r\n    let existingBuffer\r\n    if (filePath) { existingBuffer = this.findBufferForPath(absoluteFilePath) }\r\n    return existingBuffer != null ? existingBuffer : this.buildBufferSync(absoluteFilePath)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.resolvePath","start_line":514,"end_line":530,"comment":[],"params":["uri"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"findBufferForPath","line":645,"func_location":"Project.bufferForPathSync","func_start_line":640,"func_end_line":647,"args":["absoluteFilePath"],"comment":[" Only to be used in specs"],"code":"  bufferForPathSync (filePath) {\r\n    const absoluteFilePath = this.resolvePath(filePath)\r\n    if (this.retiredBufferPaths.has(absoluteFilePath)) { return null }\r\n\r\n    let existingBuffer\r\n    if (filePath) { existingBuffer = this.findBufferForPath(absoluteFilePath) }\r\n    return existingBuffer != null ? existingBuffer : this.buildBufferSync(absoluteFilePath)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.findBufferForPath","start_line":631,"end_line":633,"comment":[],"params":["filePath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"buildBufferSync","line":646,"func_location":"Project.bufferForPathSync","func_start_line":640,"func_end_line":647,"args":["absoluteFilePath"],"comment":[" Only to be used in specs"],"code":"  bufferForPathSync (filePath) {\r\n    const absoluteFilePath = this.resolvePath(filePath)\r\n    if (this.retiredBufferPaths.has(absoluteFilePath)) { return null }\r\n\r\n    let existingBuffer\r\n    if (filePath) { existingBuffer = this.findBufferForPath(absoluteFilePath) }\r\n    return existingBuffer != null ? existingBuffer : this.buildBufferSync(absoluteFilePath)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.buildBufferSync","start_line":681,"end_line":692,"comment":[" Still needed when deserializing a tokenized buffer"],"params":["absoluteFilePath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"tokenizedLineForRow","line":543,"func_location":"TextMateLanguageMode.bufferRangeForScopeAtPosition","func_start_line":539,"func_end_line":598,"args":["position.row"],"code":"  bufferRangeForScopeAtPosition (selector, position) {\r\n    let endColumn, tag, tokenIndex\r\n    position = Point.fromObject(position)\r\n\r\n    const {openScopes, tags} = this.tokenizedLineForRow(position.row)\r\n    const scopes = openScopes.map(tag => this.grammar.scopeForId(tag))\r\n\r\n    let startColumn = 0\r\n    for (tokenIndex = 0; tokenIndex < tags.length; tokenIndex++) {\r\n      tag = tags[tokenIndex]\r\n      if (tag < 0) {\r\n        if ((tag % 2) === -1) {\r\n          scopes.push(this.grammar.scopeForId(tag))\r\n        } else {\r\n          scopes.pop()\r\n        }\r\n      } else {\r\n        endColumn = startColumn + tag\r\n        if (endColumn >= position.column) {\r\n          break\r\n        } else {\r\n          startColumn = endColumn\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!selectorMatchesAnyScope(selector, scopes)) return\r\n\r\n    const startScopes = scopes.slice()\r\n    for (let startTokenIndex = tokenIndex - 1; startTokenIndex >= 0; startTokenIndex--) {\r\n      tag = tags[startTokenIndex]\r\n      if (tag < 0) {\r\n        if ((tag % 2) === -1) {\r\n          startScopes.pop()\r\n        } else {\r\n          startScopes.push(this.grammar.scopeForId(tag))\r\n        }\r\n      } else {\r\n        if (!selectorMatchesAnyScope(selector, startScopes)) { break }\r\n        startColumn -= tag\r\n      }\r\n    }\r\n\r\n    const endScopes = scopes.slice()\r\n    for (let endTokenIndex = tokenIndex + 1, end = tags.length; endTokenIndex < end; endTokenIndex++) {\r\n      tag = tags[endTokenIndex]\r\n      if (tag < 0) {\r\n        if ((tag % 2) === -1) {\r\n          endScopes.push(this.grammar.scopeForId(tag))\r\n        } else {\r\n          endScopes.pop()\r\n        }\r\n      } else {\r\n        if (!selectorMatchesAnyScope(selector, endScopes)) { break }\r\n        endColumn += tag\r\n      }\r\n    }\r\n\r\n    return new Range(new Point(position.row, startColumn), new Point(position.row, endColumn))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.tokenizedLineForRow","start_line":425,"end_line":449,"comment":[],"params":["bufferRow"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"getSyntaxNodeAtPosition","line":434,"func_location":"TreeSitterLanguageMode.bufferRangeForScopeAtPosition","func_start_line":420,"func_end_line":436,"args":["position","selector"],"code":"  bufferRangeForScopeAtPosition (selector, position) {\r\n    const nodeCursorAdapter = new NodeCursorAdaptor()\r\n    if (typeof selector === 'string') {\r\n      const match = matcherForSelector(selector)\r\n      selector = (node, grammar) => {\r\n        const rules = grammar.scopeMap.get([node.type], [0], node.named)\r\n        nodeCursorAdapter.node = node\r\n        const scopeName = applyLeafRules(rules, nodeCursorAdapter)\r\n        if (scopeName != null) {\r\n          return match(scopeName)\r\n        }\r\n      }\r\n    }\r\n    if (selector === null) selector = undefined\r\n    const node = this.getSyntaxNodeAtPosition(position, selector)\r\n    return node && node.range\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"TreeSitterLanguageMode.getSyntaxNodeAtPosition","start_line":416,"end_line":418,"comment":[],"params":["position","where"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js","name":"textEditorParamsForScope","line":112,"func_location":"TextEditorRegistry.build","func_start_line":101,"func_end_line":115,"args":["params",null],"code":"  build (params) {\r\n    params = Object.assign({assert: this.assert}, params)\r\n\r\n    let scope = null\r\n    if (params.buffer) {\r\n      const {grammar} = params.buffer.getLanguageMode()\r\n      if (grammar) {\r\n        scope = new ScopeDescriptor({scopes: [grammar.scopeName]})\r\n      }\r\n    }\r\n\r\n    Object.assign(params, this.textEditorParamsForScope(scope))\r\n\r\n    return new TextEditor(params)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js","name":"TextEditorRegistry.textEditorParamsForScope","start_line":288,"end_line":295,"comment":[],"params":["scopeDescriptor"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"addBuffer","line":724,"func_location":"Project.buildBuffer","func_start_line":700,"func_end_line":726,"args":["buffer"],"comment":[" Given a file path, this sets its {TextBuffer}.",""," * `absoluteFilePath` A {String} representing a path."," * `text` The {String} text to use as a buffer.",""," Returns a {Promise} that resolves to the {TextBuffer}."],"code":"  async buildBuffer (absoluteFilePath) {\r\n    const params = {shouldDestroyOnFileDelete: this.shouldDestroyBufferOnFileDelete}\r\n\r\n    let buffer\r\n    if (absoluteFilePath != null) {\r\n      if (this.loadPromisesByPath[absoluteFilePath] == null) {\r\n        this.loadPromisesByPath[absoluteFilePath] =\r\n          TextBuffer.load(absoluteFilePath, params)\r\n            .then(result => {\r\n              delete this.loadPromisesByPath[absoluteFilePath]\r\n              return result\r\n            })\r\n            .catch(error => {\r\n              delete this.loadPromisesByPath[absoluteFilePath]\r\n              throw error\r\n            })\r\n      }\r\n      buffer = await this.loadPromisesByPath[absoluteFilePath]\r\n    } else {\r\n      buffer = new TextBuffer(params)\r\n    }\r\n\r\n    this.grammarRegistry.autoAssignLanguageMode(buffer)\r\n\r\n    this.addBuffer(buffer)\r\n    return buffer\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.addBuffer","start_line":728,"end_line":734,"comment":[],"params":["buffer","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"addBuffer","line":690,"func_location":"Project.buildBufferSync","func_start_line":681,"func_end_line":692,"args":["buffer"],"comment":[" Still needed when deserializing a tokenized buffer"],"code":"  buildBufferSync (absoluteFilePath) {\r\n    const params = {shouldDestroyOnFileDelete: this.shouldDestroyBufferOnFileDelete}\r\n\r\n    let buffer\r\n    if (absoluteFilePath != null) {\r\n      buffer = TextBuffer.loadSync(absoluteFilePath, params)\r\n    } else {\r\n      buffer = new TextBuffer(params)\r\n    }\r\n    this.addBuffer(buffer)\r\n    return buffer\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.addBuffer","start_line":728,"end_line":734,"comment":[],"params":["buffer","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"constructor","line":204,"func_location":"TextMateLanguageMode.buildHighlightIterator","func_start_line":203,"func_end_line":205},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateHighlightIterator.constructor","start_line":733,"end_line":737,"comment":[],"params":["languageMode"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"constructor","line":143,"func_location":"TreeSitterLanguageMode.buildHighlightIterator","func_start_line":141,"func_end_line":144},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"HighlightIterator.constructor","start_line":797,"end_line":800,"comment":[],"params":["languageMode"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"constructor","line":556,"func_location":"LanguageLayer.buildHighlightIterator","func_start_line":554,"func_end_line":560,"args":[],"code":"  buildHighlightIterator () {\r\n    if (this.tree) {\r\n      return new LayerHighlightIterator(this, this.tree.walk())\r\n    } else {\r\n      return new NullHighlightIterator()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"LayerHighlightIterator.constructor","start_line":863,"end_line":883,"comment":[],"params":["languageLayer","treeCursor"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"buildTokenizedLineForRowWithText","line":408,"func_location":"TextMateLanguageMode.buildTokenizedLineForRow","func_start_line":407,"func_end_line":409,"args":["row",null,"ruleStack","openScopes"],"code":"  buildTokenizedLineForRow (row, ruleStack, openScopes) {\r\n    return this.buildTokenizedLineForRowWithText(row, this.buffer.lineForRow(row), ruleStack, openScopes)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.buildTokenizedLineForRowWithText","start_line":411,"end_line":423,"comment":[],"params":["row","text","currentRuleStack","openScopes"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"buildTokenizedLineForRow","line":392,"func_location":"TextMateLanguageMode.buildTokenizedLinesForRows","func_start_line":384,"func_end_line":405,"args":["row","ruleStack","openScopes"],"code":"  buildTokenizedLinesForRows (startRow, endRow, startingStack, startingopenScopes) {\r\n    let ruleStack = startingStack\r\n    let openScopes = startingopenScopes\r\n    const stopTokenizingAt = startRow + this.chunkSize\r\n    const tokenizedLines = []\r\n    for (let row = startRow, end = endRow; row <= end; row++) {\r\n      let tokenizedLine\r\n      if ((ruleStack || (row === 0)) && row < stopTokenizingAt) {\r\n        tokenizedLine = this.buildTokenizedLineForRow(row, ruleStack, openScopes)\r\n        ruleStack = tokenizedLine.ruleStack\r\n        openScopes = this.scopesFromTags(openScopes, tokenizedLine.tags)\r\n      }\r\n      tokenizedLines.push(tokenizedLine)\r\n    }\r\n\r\n    if (endRow >= stopTokenizingAt) {\r\n      this.invalidateRow(stopTokenizingAt)\r\n      this.tokenizeInBackground()\r\n    }\r\n\r\n    return tokenizedLines\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.buildTokenizedLineForRow","start_line":407,"end_line":409,"comment":[],"params":["row","ruleStack","openScopes"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"scopesFromTags","line":394,"func_location":"TextMateLanguageMode.buildTokenizedLinesForRows","func_start_line":384,"func_end_line":405,"args":["openScopes","tokenizedLine.tags"],"code":"  buildTokenizedLinesForRows (startRow, endRow, startingStack, startingopenScopes) {\r\n    let ruleStack = startingStack\r\n    let openScopes = startingopenScopes\r\n    const stopTokenizingAt = startRow + this.chunkSize\r\n    const tokenizedLines = []\r\n    for (let row = startRow, end = endRow; row <= end; row++) {\r\n      let tokenizedLine\r\n      if ((ruleStack || (row === 0)) && row < stopTokenizingAt) {\r\n        tokenizedLine = this.buildTokenizedLineForRow(row, ruleStack, openScopes)\r\n        ruleStack = tokenizedLine.ruleStack\r\n        openScopes = this.scopesFromTags(openScopes, tokenizedLine.tags)\r\n      }\r\n      tokenizedLines.push(tokenizedLine)\r\n    }\r\n\r\n    if (endRow >= stopTokenizingAt) {\r\n      this.invalidateRow(stopTokenizingAt)\r\n      this.tokenizeInBackground()\r\n    }\r\n\r\n    return tokenizedLines\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.scopesFromTags","start_line":472,"end_line":490,"comment":[],"params":["startingScopes","tags"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"invalidateRow","line":400,"func_location":"TextMateLanguageMode.buildTokenizedLinesForRows","func_start_line":384,"func_end_line":405,"args":["stopTokenizingAt"],"code":"  buildTokenizedLinesForRows (startRow, endRow, startingStack, startingopenScopes) {\r\n    let ruleStack = startingStack\r\n    let openScopes = startingopenScopes\r\n    const stopTokenizingAt = startRow + this.chunkSize\r\n    const tokenizedLines = []\r\n    for (let row = startRow, end = endRow; row <= end; row++) {\r\n      let tokenizedLine\r\n      if ((ruleStack || (row === 0)) && row < stopTokenizingAt) {\r\n        tokenizedLine = this.buildTokenizedLineForRow(row, ruleStack, openScopes)\r\n        ruleStack = tokenizedLine.ruleStack\r\n        openScopes = this.scopesFromTags(openScopes, tokenizedLine.tags)\r\n      }\r\n      tokenizedLines.push(tokenizedLine)\r\n    }\r\n\r\n    if (endRow >= stopTokenizingAt) {\r\n      this.invalidateRow(stopTokenizingAt)\r\n      this.tokenizeInBackground()\r\n    }\r\n\r\n    return tokenizedLines\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.invalidateRow","start_line":336,"end_line":340,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"tokenizeInBackground","line":401,"func_location":"TextMateLanguageMode.buildTokenizedLinesForRows","func_start_line":384,"func_end_line":405,"args":[],"code":"  buildTokenizedLinesForRows (startRow, endRow, startingStack, startingopenScopes) {\r\n    let ruleStack = startingStack\r\n    let openScopes = startingopenScopes\r\n    const stopTokenizingAt = startRow + this.chunkSize\r\n    const tokenizedLines = []\r\n    for (let row = startRow, end = endRow; row <= end; row++) {\r\n      let tokenizedLine\r\n      if ((ruleStack || (row === 0)) && row < stopTokenizingAt) {\r\n        tokenizedLine = this.buildTokenizedLineForRow(row, ruleStack, openScopes)\r\n        ruleStack = tokenizedLine.ruleStack\r\n        openScopes = this.scopesFromTags(openScopes, tokenizedLine.tags)\r\n      }\r\n      tokenizedLines.push(tokenizedLine)\r\n    }\r\n\r\n    if (endRow >= stopTokenizingAt) {\r\n      this.invalidateRow(stopTokenizingAt)\r\n      this.tokenizeInBackground()\r\n    }\r\n\r\n    return tokenizedLines\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.tokenizeInBackground","start_line":272,"end_line":280,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getContentWidth","line":2656,"func_location":"TextEditorComponent.canScrollHorizontally","func_start_line":2651,"func_end_line":2657,"args":[],"code":"  canScrollHorizontally () {\r\n    const {model} = this.props\r\n    if (model.isMini()) return false\r\n    if (model.getAutoWidth()) return false\r\n    if (model.isSoftWrapped()) return false\r\n    return this.getContentWidth() > this.getScrollContainerClientWidth()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getContentWidth","start_line":2688,"end_line":2690,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollContainerClientWidth","line":2656,"func_location":"TextEditorComponent.canScrollHorizontally","func_start_line":2651,"func_end_line":2657,"args":[],"code":"  canScrollHorizontally () {\r\n    const {model} = this.props\r\n    if (model.isMini()) return false\r\n    if (model.getAutoWidth()) return false\r\n    if (model.isSoftWrapped()) return false\r\n    return this.getContentWidth() > this.getScrollContainerClientWidth()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollContainerClientWidth","start_line":2636,"end_line":2638,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getContentHeight","line":2648,"func_location":"TextEditorComponent.canScrollVertically","func_start_line":2644,"func_end_line":2649,"args":[],"code":"  canScrollVertically () {\r\n    const {model} = this.props\r\n    if (model.isMini()) return false\r\n    if (model.getAutoHeight()) return false\r\n    return this.getContentHeight() > this.getScrollContainerClientHeight()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getContentHeight","start_line":2684,"end_line":2686,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollContainerClientHeight","line":2648,"func_location":"TextEditorComponent.canScrollVertically","func_start_line":2644,"func_end_line":2649,"args":[],"code":"  canScrollVertically () {\r\n    const {model} = this.props\r\n    if (model.isMini()) return false\r\n    if (model.getAutoHeight()) return false\r\n    return this.getContentHeight() > this.getScrollContainerClientHeight()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollContainerClientHeight","start_line":2640,"end_line":2642,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"clearSelection","line":721,"func_location":"Cursor.changePosition","func_start_line":720,"func_end_line":728,"args":[null],"code":"  changePosition (options, fn) {\r\n    this.clearSelection({autoscroll: false})\r\n    fn()\r\n    this.goalColumn = null\r\n    const autoscroll = (options && options.autoscroll != null)\r\n      ? options.autoscroll\r\n      : this.isLastCursor()\r\n    if (autoscroll) this.autoscroll()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.clearSelection","start_line":663,"end_line":665,"comment":["\r\n  Section: Utilities\r\n  "," Public: Deselects the current selection."],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"isLastCursor","line":726,"func_location":"Cursor.changePosition","func_start_line":720,"func_end_line":728,"args":[],"code":"  changePosition (options, fn) {\r\n    this.clearSelection({autoscroll: false})\r\n    fn()\r\n    this.goalColumn = null\r\n    const autoscroll = (options && options.autoscroll != null)\r\n      ? options.autoscroll\r\n      : this.isLastCursor()\r\n    if (autoscroll) this.autoscroll()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.isLastCursor","start_line":227,"end_line":229,"comment":[" Public: Identifies if this cursor is the last in the {TextEditor}.",""," \"Last\" is defined as the most recently added cursor.",""," Returns a {Boolean}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"autoscroll","line":727,"func_location":"Cursor.changePosition","func_start_line":720,"func_end_line":728,"args":[],"code":"  changePosition (options, fn) {\r\n    this.clearSelection({autoscroll: false})\r\n    fn()\r\n    this.goalColumn = null\r\n    const autoscroll = (options && options.autoscroll != null)\r\n      ? options.autoscroll\r\n      : this.isLastCursor()\r\n    if (autoscroll) this.autoscroll()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.autoscroll","start_line":735,"end_line":738,"comment":[],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-updater-win32.js","name":"downloadUpdate","line":55,"func_location":"AutoUpdater.checkForUpdates","func_start_line":45,"func_end_line":85},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-updater-win32.js","name":"AutoUpdater.downloadUpdate","start_line":17,"end_line":35,"comment":[],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getRepo","line":473,"func_location":"GitRepository.checkoutHead","func_start_line":472,"func_end_line":477,"args":["path"],"comment":["\r\n  Section: Checking Out\r\n  "," Public: Restore the contents of a path in the working directory and index"," to the version at `HEAD`.",""," This is essentially the same as running:",""," ```sh","   git reset HEAD -- <path>","   git checkout HEAD -- <path>"," ```",""," * `path` The {String} path to checkout.",""," Returns a {Boolean} that's true if the method was successful."],"code":"  checkoutHead (path) {\r\n    const repo = this.getRepo(path)\r\n    const headCheckedOut = repo.checkoutHead(repo.relativize(path))\r\n    if (headCheckedOut) this.getPathStatus(path)\r\n    return headCheckedOut\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getRepo","start_line":524,"end_line":530,"comment":[" Returns the corresponding {Repository}"],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getPathStatus","line":475,"func_location":"GitRepository.checkoutHead","func_start_line":472,"func_end_line":477,"args":["path"],"comment":["\r\n  Section: Checking Out\r\n  "," Public: Restore the contents of a path in the working directory and index"," to the version at `HEAD`.",""," This is essentially the same as running:",""," ```sh","   git reset HEAD -- <path>","   git checkout HEAD -- <path>"," ```",""," * `path` The {String} path to checkout.",""," Returns a {Boolean} that's true if the method was successful."],"code":"  checkoutHead (path) {\r\n    const repo = this.getRepo(path)\r\n    const headCheckedOut = repo.checkoutHead(repo.relativize(path))\r\n    if (headCheckedOut) this.getPathStatus(path)\r\n    return headCheckedOut\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getPathStatus","start_line":374,"end_line":390,"comment":[" Public: Get the status of a single path in the repository.",""," * `path` A {String} repository-relative path.",""," Returns a {Number} representing the status. This value can be passed to"," {::isStatusModified} or {::isStatusNew} to get more information."],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"checkoutHead","line":518,"func_location":"GitRepository.checkoutHeadForEditor","func_start_line":514,"func_end_line":521,"args":["bufferPath"],"comment":[" Subscribes to editor view event."],"code":"  checkoutHeadForEditor (editor) {\r\n    const buffer = editor.getBuffer()\r\n    const bufferPath = buffer.getPath()\r\n    if (bufferPath) {\r\n      this.checkoutHead(bufferPath)\r\n      return buffer.reload()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.checkoutHead","start_line":472,"end_line":477,"comment":["\r\n  Section: Checking Out\r\n  "," Public: Restore the contents of a path in the working directory and index"," to the version at `HEAD`.",""," This is essentially the same as running:",""," ```sh","   git reset HEAD -- <path>","   git checkout HEAD -- <path>"," ```",""," * `path` The {String} path to checkout.",""," Returns a {Boolean} that's true if the method was successful."],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getRepo","line":487,"func_location":"GitRepository.checkoutReference","func_start_line":486,"func_end_line":488,"args":["reference","create"],"comment":[" Public: Checks out a branch in your repository.",""," * `reference` The {String} reference to checkout."," * `create`    A {Boolean} value which, if true creates the new reference if","   it doesn't exist.",""," Returns a Boolean that's true if the method was successful."],"code":"  checkoutReference (reference, create) {\r\n    return this.getRepo().checkoutReference(reference, create)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getRepo","start_line":524,"end_line":530,"comment":[" Returns the corresponding {Repository}"],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/view-registry.js","name":"clearDocumentRequests","line":38,"func_location":"ViewRegistry.clear","func_start_line":35,"func_end_line":39,"args":[],"code":"  clear () {\r\n    this.views = new WeakMap()\r\n    this.providers = []\r\n    this.clearDocumentRequests()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/view-registry.js","name":"ViewRegistry.clearDocumentRequests","start_line":213,"end_line":222,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"isLastSelection","line":202,"func_location":"Selection.clear","func_start_line":197,"func_end_line":205,"args":[],"comment":["\r\n  Section: Modifying the selected range\r\n  "," Public: Clears the selection, moving the marker to the head.",""," * `options` (optional) {Object} with the following keys:","   * `autoscroll` {Boolean} indicating whether to autoscroll to the new","     range. Defaults to `true` if this is the most recently added selection,","     `false` otherwise."],"code":"  clear (options) {\r\n    this.goalScreenRange = null\r\n    if (!this.retainSelection) this.marker.clearTail()\r\n    const autoscroll = options && options.autoscroll != null\r\n      ? options.autoscroll\r\n      : this.isLastSelection()\r\n    if (autoscroll) this.autoscroll()\r\n    this.finalize()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.isLastSelection","start_line":29,"end_line":31,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"setPendingItem","line":659,"func_location":"Pane.clearPendingItem","func_start_line":658,"func_end_line":660,"args":[{"type":"object"}],"code":"  clearPendingItem () {\r\n    this.setPendingItem(null)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.setPendingItem","start_line":644,"end_line":652,"comment":[],"params":["item"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"saveState","line":38,"func_location":"HistoryManager.clearProjects","func_start_line":36,"func_end_line":40,"args":[],"comment":[" Public: Clear all projects from the history.",""," Note: This is not a privacy function - other traces will still exist,"," e.g. window state.",""," Return a {Promise} that resolves when the history has been successfully"," cleared."],"code":"  async clearProjects () {\r\n    this.projects = []\r\n    await this.saveState()\r\n    this.didChangeProjects()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"HistoryManager.saveState","start_line":103,"end_line":106,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"didChangeProjects","line":39,"func_location":"HistoryManager.clearProjects","func_start_line":36,"func_end_line":40,"args":[],"comment":[" Public: Clear all projects from the history.",""," Note: This is not a privacy function - other traces will still exist,"," e.g. window state.",""," Return a {Promise} that resolves when the history has been successfully"," cleared."],"code":"  async clearProjects () {\r\n    this.projects = []\r\n    await this.saveState()\r\n    this.didChangeProjects()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"HistoryManager.didChangeProjects","start_line":51,"end_line":53,"comment":[],"params":["args"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"resetProjectSettings","line":991,"func_location":"Config.clearProjectSettings","func_start_line":990,"func_end_line":992,"args":[null,{"type":"object"}],"code":"  clearProjectSettings () {\r\n    this.resetProjectSettings({}, null)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.resetProjectSettings","start_line":977,"end_line":988,"comment":[],"params":["newSettings","projectFile"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js","name":"constructor","line":112,"func_location":"Color.clone","func_start_line":111,"func_end_line":113},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js","name":"Color.constructor","start_line":38,"end_line":43,"comment":[],"params":["red","green","blue","alpha"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getItems","line":1215,"func_location":"Pane.close","func_start_line":1214,"func_end_line":1219,"args":[null],"comment":[" Private: Close the pane unless the user cancels the action via a dialog.",""," Returns a {Promise} that resolves once the pane is either closed, or the"," closing has been cancelled."],"code":"  close () {\r\n    return Promise.all(this.getItems().map(item => this.promptToSaveItem(item)))\r\n      .then(results => {\r\n        if (!results.includes(false)) return this.destroy()\r\n      })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getItems","start_line":425,"end_line":427,"comment":["\r\n  Section: Items\r\n  "," Public: Get the items in this pane.",""," Returns an {Array} of items."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getCenter","line":1516,"func_location":"Workspace.closeActivePaneItemOrEmptyPaneOrWindow","func_start_line":1515,"func_end_line":1523,"args":[],"comment":[" Close the active center pane item, or the active center pane if it is"," empty, or the current window if there is only the empty root pane."],"code":"  closeActivePaneItemOrEmptyPaneOrWindow () {\r\n    if (this.getCenter().getActivePaneItem() != null) {\r\n      this.getCenter().getActivePane().destroyActiveItem()\r\n    } else if (this.getCenter().getPanes().length > 1) {\r\n      this.getCenter().destroyActivePane()\r\n    } else if (this.config.get('core.closeEmptyWindows')) {\r\n      atom.close()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getCenter","start_line":1599,"end_line":1601,"comment":["\r\n  Section: Pane Locations\r\n  "," Essential: Get the {WorkspaceCenter} at the center of the editor window."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getCenter","line":1517,"func_location":"Workspace.closeActivePaneItemOrEmptyPaneOrWindow","func_start_line":1515,"func_end_line":1523,"args":[],"comment":[" Close the active center pane item, or the active center pane if it is"," empty, or the current window if there is only the empty root pane."],"code":"  closeActivePaneItemOrEmptyPaneOrWindow () {\r\n    if (this.getCenter().getActivePaneItem() != null) {\r\n      this.getCenter().getActivePane().destroyActiveItem()\r\n    } else if (this.getCenter().getPanes().length > 1) {\r\n      this.getCenter().destroyActivePane()\r\n    } else if (this.config.get('core.closeEmptyWindows')) {\r\n      atom.close()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getCenter","start_line":1599,"end_line":1601,"comment":["\r\n  Section: Pane Locations\r\n  "," Essential: Get the {WorkspaceCenter} at the center of the editor window."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getCenter","line":1518,"func_location":"Workspace.closeActivePaneItemOrEmptyPaneOrWindow","func_start_line":1515,"func_end_line":1523,"args":[],"comment":[" Close the active center pane item, or the active center pane if it is"," empty, or the current window if there is only the empty root pane."],"code":"  closeActivePaneItemOrEmptyPaneOrWindow () {\r\n    if (this.getCenter().getActivePaneItem() != null) {\r\n      this.getCenter().getActivePane().destroyActiveItem()\r\n    } else if (this.getCenter().getPanes().length > 1) {\r\n      this.getCenter().destroyActivePane()\r\n    } else if (this.config.get('core.closeEmptyWindows')) {\r\n      atom.close()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getCenter","start_line":1599,"end_line":1601,"comment":["\r\n  Section: Pane Locations\r\n  "," Essential: Get the {WorkspaceCenter} at the center of the editor window."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getCenter","line":1519,"func_location":"Workspace.closeActivePaneItemOrEmptyPaneOrWindow","func_start_line":1515,"func_end_line":1523,"args":[],"comment":[" Close the active center pane item, or the active center pane if it is"," empty, or the current window if there is only the empty root pane."],"code":"  closeActivePaneItemOrEmptyPaneOrWindow () {\r\n    if (this.getCenter().getActivePaneItem() != null) {\r\n      this.getCenter().getActivePane().destroyActiveItem()\r\n    } else if (this.getCenter().getPanes().length > 1) {\r\n      this.getCenter().destroyActivePane()\r\n    } else if (this.config.get('core.closeEmptyWindows')) {\r\n      atom.close()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getCenter","start_line":1599,"end_line":1601,"comment":["\r\n  Section: Pane Locations\r\n  "," Essential: Get the {WorkspaceCenter} at the center of the editor window."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"scopeDescriptorForPosition","line":186,"func_location":"TextMateLanguageMode.commentStringsForPosition","func_start_line":185,"func_end_line":197,"args":["position"],"comment":["\r\n  Section - Comments\r\n  "],"code":"  commentStringsForPosition (position) {\r\n    const scope = this.scopeDescriptorForPosition(position)\r\n    const commentStartEntries = this.config.getAll('editor.commentStart', {scope})\r\n    const commentEndEntries = this.config.getAll('editor.commentEnd', {scope})\r\n    const commentStartEntry = commentStartEntries[0]\r\n    const commentEndEntry = commentEndEntries.find((entry) => {\r\n      return entry.scopeSelector === commentStartEntry.scopeSelector\r\n    })\r\n    return {\r\n      commentStartString: commentStartEntry && commentStartEntry.value,\r\n      commentEndString: commentEndEntry && commentEndEntry.value\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.scopeDescriptorForPosition","start_line":507,"end_line":526,"comment":[],"params":["position"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"firstNonWhitespaceRange","line":163,"func_location":"TreeSitterLanguageMode.commentStringsForPosition","func_start_line":162,"func_end_line":166,"args":["position.row"],"comment":["\r\n  Section - Commenting\r\n  "],"code":"  commentStringsForPosition (position) {\r\n    const range = this.firstNonWhitespaceRange(position.row) || new Range(position, position)\r\n    const {grammar} = this.getSyntaxNodeAndGrammarContainingRange(range)\r\n    return grammar.commentStrings\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"TreeSitterLanguageMode.firstNonWhitespaceRange","start_line":526,"end_line":528,"comment":["\r\n  Section - Private\r\n  "],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"getSyntaxNodeAndGrammarContainingRange","line":164,"func_location":"TreeSitterLanguageMode.commentStringsForPosition","func_start_line":162,"func_end_line":166,"args":["range"],"comment":["\r\n  Section - Commenting\r\n  "],"code":"  commentStringsForPosition (position) {\r\n    const range = this.firstNonWhitespaceRange(position.row) || new Range(position, position)\r\n    const {grammar} = this.getSyntaxNodeAndGrammarContainingRange(range)\r\n    return grammar.commentStrings\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"TreeSitterLanguageMode.getSyntaxNodeAndGrammarContainingRange","start_line":387,"end_line":409,"comment":[],"params":["range","where"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferPosition","line":655,"func_location":"Cursor.compare","func_start_line":654,"func_end_line":656,"args":[null],"comment":["\r\n  Section: Visibility\r\n  ","\r\n  Section: Comparing to another cursor\r\n  "," Public: Compare this cursor's buffer position to another cursor's buffer position.",""," See {Point::compare} for more details.",""," * `otherCursor`{Cursor} to compare against"],"code":"  compare (otherCursor) {\r\n    return this.getBufferPosition().compare(otherCursor.getBufferPosition())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferPosition","start_line":91,"end_line":93,"comment":[" Public: Returns the current buffer position as an Array."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/compile-cache.js","name":"readCachedJavaScript","line":88,"func_location":"compileFileAtPath","func_start_line":84,"func_end_line":99,"args":["cachePath"],"code":"function compileFileAtPath (compiler, filePath, extension) {\r\n  var sourceCode = fs.readFileSync(filePath, 'utf8')\r\n  if (compiler.shouldCompile(sourceCode, filePath)) {\r\n    var cachePath = compiler.getCachePath(sourceCode, filePath)\r\n    var compiledCode = readCachedJavaScript(cachePath)\r\n    if (compiledCode != null) {\r\n      cacheStats[extension].hits++\r\n    } else {\r\n      cacheStats[extension].misses++\r\n      compiledCode = compiler.compile(sourceCode, filePath)\r\n      writeCachedJavaScript(cachePath, compiledCode)\r\n    }\r\n    return compiledCode\r\n  }\r\n  return sourceCode\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/compile-cache.js","name":"readCachedJavaScript","start_line":101,"end_line":109,"comment":[],"params":["relativeCachePath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/compile-cache.js","name":"writeCachedJavaScript","line":94,"func_location":"compileFileAtPath","func_start_line":84,"func_end_line":99,"args":["cachePath","compiledCode"],"code":"function compileFileAtPath (compiler, filePath, extension) {\r\n  var sourceCode = fs.readFileSync(filePath, 'utf8')\r\n  if (compiler.shouldCompile(sourceCode, filePath)) {\r\n    var cachePath = compiler.getCachePath(sourceCode, filePath)\r\n    var compiledCode = readCachedJavaScript(cachePath)\r\n    if (compiledCode != null) {\r\n      cacheStats[extension].hits++\r\n    } else {\r\n      cacheStats[extension].misses++\r\n      compiledCode = compiler.compile(sourceCode, filePath)\r\n      writeCachedJavaScript(cachePath, compiledCode)\r\n    }\r\n    return compiledCode\r\n  }\r\n  return sourceCode\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/compile-cache.js","name":"writeCachedJavaScript","start_line":111,"end_line":114,"comment":[],"params":["relativeCachePath","code"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"getPanes","line":180,"func_location":"PaneContainer.confirmClose","func_start_line":178,"func_end_line":186,"args":[],"code":"  confirmClose (options) {\r\n    const promises = []\r\n    for (const pane of this.getPanes()) {\r\n      for (const item of pane.getItems()) {\r\n        promises.push(pane.promptToSaveItem(item, options))\r\n      }\r\n    }\r\n    return Promise.all(promises).then((results) => !results.includes(false))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.getPanes","start_line":146,"end_line":152,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getPaneContainers","line":1385,"func_location":"Workspace.confirmClose","func_start_line":1384,"func_end_line":1388,"args":[],"code":"  confirmClose (options) {\r\n    return Promise.all(this.getPaneContainers().map(container =>\r\n      container.confirmClose(options)\r\n    )).then((results) => !results.includes(false))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getPaneContainers","start_line":1618,"end_line":1625,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"clear","line":25,"func_location":"GrammarRegistry.constructor","func_start_line":21,"func_end_line":26,"args":[],"code":"  constructor ({config} = {}) {\r\n    this.config = config\r\n    this.subscriptions = new CompositeDisposable()\r\n    this.textmateRegistry = new FirstMate.GrammarRegistry({maxTokensPerLine: 100, maxLineLength: 1000})\r\n    this.clear()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.clear","start_line":28,"end_line":49,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/view-registry.js","name":"clear","line":32,"func_location":"ViewRegistry.constructor","func_start_line":27,"func_end_line":33,"args":[],"code":"  constructor (atomEnvironment) {\r\n    this.animationFrameRequest = null\r\n    this.documentReadInProgress = false\r\n    this.performDocumentUpdate = this.performDocumentUpdate.bind(this)\r\n    this.atomEnvironment = atomEnvironment\r\n    this.clear()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/view-registry.js","name":"ViewRegistry.clear","start_line":35,"end_line":39,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/title-bar.js","name":"updateTitle","line":20,"func_location":"TitleBar.constructor","func_start_line":3,"func_end_line":22,"args":[],"code":"  constructor ({workspace, themes, applicationDelegate}) {\r\n    this.dblclickHandler = this.dblclickHandler.bind(this)\r\n    this.workspace = workspace\r\n    this.themes = themes\r\n    this.applicationDelegate = applicationDelegate\r\n    this.element = document.createElement('div')\r\n    this.element.classList.add('title-bar')\r\n\r\n    this.titleElement = document.createElement('div')\r\n    this.titleElement.classList.add('title')\r\n    this.element.appendChild(this.titleElement)\r\n\r\n    this.element.addEventListener('dblclick', this.dblclickHandler)\r\n\r\n    this.workspace.onDidChangeWindowTitle(() => this.updateTitle())\r\n    this.themes.onDidChangeActiveThemes(() => this.updateWindowSheetOffset())\r\n\r\n    this.updateTitle()\r\n    this.updateWindowSheetOffset()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/title-bar.js","name":"TitleBar.updateTitle","start_line":40,"end_line":42,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/title-bar.js","name":"updateWindowSheetOffset","line":21,"func_location":"TitleBar.constructor","func_start_line":3,"func_end_line":22,"args":[],"code":"  constructor ({workspace, themes, applicationDelegate}) {\r\n    this.dblclickHandler = this.dblclickHandler.bind(this)\r\n    this.workspace = workspace\r\n    this.themes = themes\r\n    this.applicationDelegate = applicationDelegate\r\n    this.element = document.createElement('div')\r\n    this.element.classList.add('title-bar')\r\n\r\n    this.titleElement = document.createElement('div')\r\n    this.titleElement.classList.add('title')\r\n    this.element.appendChild(this.titleElement)\r\n\r\n    this.element.addEventListener('dblclick', this.dblclickHandler)\r\n\r\n    this.workspace.onDidChangeWindowTitle(() => this.updateTitle())\r\n    this.themes.onDidChangeActiveThemes(() => this.updateWindowSheetOffset())\r\n\r\n    this.updateTitle()\r\n    this.updateWindowSheetOffset()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/title-bar.js","name":"TitleBar.updateWindowSheetOffset","start_line":44,"end_line":46,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js","name":"extractDidDispatch","line":416,"func_location":"SelectorBasedListener.constructor","func_start_line":414,"func_end_line":420,"args":["listener"],"code":"  constructor (selector, commandName, listener) {\r\n    this.selector = selector\r\n    this.didDispatch = extractDidDispatch(listener)\r\n    this.descriptor = extractDescriptor(commandName, listener)\r\n    this.specificity = calculateSpecificity(this.selector)\r\n    this.sequenceNumber = SequenceCount++\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js","name":"extractDidDispatch","start_line":455,"end_line":457,"comment":[],"params":["listener"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js","name":"extractDescriptor","line":417,"func_location":"SelectorBasedListener.constructor","func_start_line":414,"func_end_line":420,"args":["commandName","listener"],"code":"  constructor (selector, commandName, listener) {\r\n    this.selector = selector\r\n    this.didDispatch = extractDidDispatch(listener)\r\n    this.descriptor = extractDescriptor(commandName, listener)\r\n    this.specificity = calculateSpecificity(this.selector)\r\n    this.sequenceNumber = SequenceCount++\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js","name":"extractDescriptor","start_line":445,"end_line":453,"comment":[" type CommandDescriptor = {","   name: string,","   displayName: string,"," };"],"params":["name","listener"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js","name":"extractDidDispatch","line":436,"func_location":"InlineListener.constructor","func_start_line":435,"func_end_line":438,"args":["listener"],"code":"  constructor (commandName, listener) {\r\n    this.didDispatch = extractDidDispatch(listener)\r\n    this.descriptor = extractDescriptor(commandName, listener)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js","name":"extractDidDispatch","start_line":455,"end_line":457,"comment":[],"params":["listener"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js","name":"extractDescriptor","line":437,"func_location":"InlineListener.constructor","func_start_line":435,"func_end_line":438,"args":["commandName","listener"],"code":"  constructor (commandName, listener) {\r\n    this.didDispatch = extractDidDispatch(listener)\r\n    this.descriptor = extractDescriptor(commandName, listener)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js","name":"extractDescriptor","start_line":445,"end_line":453,"comment":[" type CommandDescriptor = {","   name: string,","   displayName: string,"," };"],"params":["name","listener"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js","name":"clear","line":51,"func_location":"CommandRegistry.constructor","func_start_line":48,"func_end_line":52,"args":[],"code":"  constructor () {\r\n    this.handleCommandEvent = this.handleCommandEvent.bind(this)\r\n    this.rootNode = null\r\n    this.clear()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js","name":"CommandRegistry.clear","start_line":54,"end_line":59,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"isMini","line":241,"func_location":"TextEditor.constructor","func_start_line":125,"func_end_line":265,"args":[],"code":"  constructor (params = {}) {\r\n    if (this.constructor.clipboard == null) {\r\n      throw new Error('Must call TextEditor.setClipboard at least once before creating TextEditor instances')\r\n    }\r\n\r\n    this.id = params.id != null ? params.id : nextId++\r\n    if (this.id >= nextId) {\r\n      // Ensure that new editors get unique ids:\r\n      nextId = this.id + 1\r\n    }\r\n    this.initialScrollTopRow = params.initialScrollTopRow\r\n    this.initialScrollLeftColumn = params.initialScrollLeftColumn\r\n    this.decorationManager = params.decorationManager\r\n    this.selectionsMarkerLayer = params.selectionsMarkerLayer\r\n    this.mini = (params.mini != null) ? params.mini : false\r\n    this.keyboardInputEnabled = (params.keyboardInputEnabled != null) ? params.keyboardInputEnabled : true\r\n    this.readOnly = (params.readOnly != null) ? params.readOnly : false\r\n    this.placeholderText = params.placeholderText\r\n    this.showLineNumbers = params.showLineNumbers\r\n    this.assert = params.assert || (condition => condition)\r\n    this.showInvisibles = (params.showInvisibles != null) ? params.showInvisibles : true\r\n    this.autoHeight = params.autoHeight\r\n    this.autoWidth = params.autoWidth\r\n    this.scrollPastEnd = (params.scrollPastEnd != null) ? params.scrollPastEnd : false\r\n    this.scrollSensitivity = (params.scrollSensitivity != null) ? params.scrollSensitivity : 40\r\n    this.editorWidthInChars = params.editorWidthInChars\r\n    this.invisibles = params.invisibles\r\n    this.showIndentGuide = params.showIndentGuide\r\n    this.softWrapped = params.softWrapped\r\n    this.softWrapAtPreferredLineLength = params.softWrapAtPreferredLineLength\r\n    this.preferredLineLength = params.preferredLineLength\r\n    this.showCursorOnSelection = (params.showCursorOnSelection != null) ? params.showCursorOnSelection : true\r\n    this.maxScreenLineLength = params.maxScreenLineLength\r\n    this.softTabs = (params.softTabs != null) ? params.softTabs : true\r\n    this.autoIndent = (params.autoIndent != null) ? params.autoIndent : true\r\n    this.autoIndentOnPaste = (params.autoIndentOnPaste != null) ? params.autoIndentOnPaste : true\r\n    this.undoGroupingInterval = (params.undoGroupingInterval != null) ? params.undoGroupingInterval : 300\r\n    this.softWrapped = (params.softWrapped != null) ? params.softWrapped : false\r\n    this.softWrapAtPreferredLineLength = (params.softWrapAtPreferredLineLength != null) ? params.softWrapAtPreferredLineLength : false\r\n    this.preferredLineLength = (params.preferredLineLength != null) ? params.preferredLineLength : 80\r\n    this.maxScreenLineLength = (params.maxScreenLineLength != null) ? params.maxScreenLineLength : 500\r\n    this.showLineNumbers = (params.showLineNumbers != null) ? params.showLineNumbers : true\r\n    const {tabLength = 2} = params\r\n\r\n    this.alive = true\r\n    this.doBackgroundWork = this.doBackgroundWork.bind(this)\r\n    this.serializationVersion = 1\r\n    this.suppressSelectionMerging = false\r\n    this.selectionFlashDuration = 500\r\n    this.gutterContainer = null\r\n    this.verticalScrollMargin = 2\r\n    this.horizontalScrollMargin = 6\r\n    this.lineHeightInPixels = null\r\n    this.defaultCharWidth = null\r\n    this.height = null\r\n    this.width = null\r\n    this.registered = false\r\n    this.atomicSoftTabs = true\r\n    this.emitter = new Emitter()\r\n    this.disposables = new CompositeDisposable()\r\n    this.cursors = []\r\n    this.cursorsByMarkerId = new Map()\r\n    this.selections = []\r\n    this.hasTerminatedPendingState = false\r\n\r\n    if (params.buffer) {\r\n      this.buffer = params.buffer\r\n    } else {\r\n      this.buffer = new TextBuffer({\r\n        shouldDestroyOnFileDelete () { return atom.config.get('core.closeDeletedFileTabs') }\r\n      })\r\n      this.buffer.setLanguageMode(new TextMateLanguageMode({buffer: this.buffer, config: atom.config}))\r\n    }\r\n\r\n    const languageMode = this.buffer.getLanguageMode()\r\n    this.languageModeSubscription = languageMode.onDidTokenize && languageMode.onDidTokenize(() => {\r\n      this.emitter.emit('did-tokenize')\r\n    })\r\n    if (this.languageModeSubscription) this.disposables.add(this.languageModeSubscription)\r\n\r\n    if (params.displayLayer) {\r\n      this.displayLayer = params.displayLayer\r\n    } else {\r\n      const displayLayerParams = {\r\n        invisibles: this.getInvisibles(),\r\n        softWrapColumn: this.getSoftWrapColumn(),\r\n        showIndentGuides: this.doesShowIndentGuide(),\r\n        atomicSoftTabs: params.atomicSoftTabs != null ? params.atomicSoftTabs : true,\r\n        tabLength,\r\n        ratioForCharacter: this.ratioForCharacter.bind(this),\r\n        isWrapBoundary,\r\n        foldCharacter: ZERO_WIDTH_NBSP,\r\n        softWrapHangingIndent: params.softWrapHangingIndentLength != null ? params.softWrapHangingIndentLength : 0\r\n      }\r\n\r\n      this.displayLayer = this.buffer.getDisplayLayer(params.displayLayerId)\r\n      if (this.displayLayer) {\r\n        this.displayLayer.reset(displayLayerParams)\r\n        this.selectionsMarkerLayer = this.displayLayer.getMarkerLayer(params.selectionsMarkerLayerId)\r\n      } else {\r\n        this.displayLayer = this.buffer.addDisplayLayer(displayLayerParams)\r\n      }\r\n    }\r\n\r\n    this.backgroundWorkHandle = requestIdleCallback(this.doBackgroundWork)\r\n    this.disposables.add(new Disposable(() => {\r\n      if (this.backgroundWorkHandle != null) return cancelIdleCallback(this.backgroundWorkHandle)\r\n    }))\r\n\r\n    this.defaultMarkerLayer = this.displayLayer.addMarkerLayer()\r\n    if (!this.selectionsMarkerLayer) {\r\n      this.selectionsMarkerLayer = this.addMarkerLayer({maintainHistory: true, persistent: true, role: 'selections'})\r\n    }\r\n\r\n    this.decorationManager = new DecorationManager(this)\r\n    this.decorateMarkerLayer(this.selectionsMarkerLayer, {type: 'cursor'})\r\n    if (!this.isMini()) this.decorateCursorLine()\r\n\r\n    this.decorateMarkerLayer(this.displayLayer.foldsMarkerLayer, {type: 'line-number', class: 'folded'})\r\n\r\n    for (let marker of this.selectionsMarkerLayer.getMarkers()) {\r\n      this.addSelection(marker)\r\n    }\r\n\r\n    this.subscribeToBuffer()\r\n    this.subscribeToDisplayLayer()\r\n\r\n    if (this.cursors.length === 0 && !params.suppressCursorCreation) {\r\n      const initialLine = Math.max(parseInt(params.initialLine) || 0, 0)\r\n      const initialColumn = Math.max(parseInt(params.initialColumn) || 0, 0)\r\n      this.addCursorAtBufferPosition([initialLine, initialColumn])\r\n    }\r\n\r\n    this.gutterContainer = new GutterContainer(this)\r\n    this.lineNumberGutter = this.gutterContainer.addGutter({\r\n      name: 'line-number',\r\n      type: 'line-number',\r\n      priority: 0,\r\n      visible: params.lineNumberGutterVisible\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.isMini","start_line":1002,"end_line":1002,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"decorateCursorLine","line":241,"func_location":"TextEditor.constructor","func_start_line":125,"func_end_line":265,"args":[],"code":"  constructor (params = {}) {\r\n    if (this.constructor.clipboard == null) {\r\n      throw new Error('Must call TextEditor.setClipboard at least once before creating TextEditor instances')\r\n    }\r\n\r\n    this.id = params.id != null ? params.id : nextId++\r\n    if (this.id >= nextId) {\r\n      // Ensure that new editors get unique ids:\r\n      nextId = this.id + 1\r\n    }\r\n    this.initialScrollTopRow = params.initialScrollTopRow\r\n    this.initialScrollLeftColumn = params.initialScrollLeftColumn\r\n    this.decorationManager = params.decorationManager\r\n    this.selectionsMarkerLayer = params.selectionsMarkerLayer\r\n    this.mini = (params.mini != null) ? params.mini : false\r\n    this.keyboardInputEnabled = (params.keyboardInputEnabled != null) ? params.keyboardInputEnabled : true\r\n    this.readOnly = (params.readOnly != null) ? params.readOnly : false\r\n    this.placeholderText = params.placeholderText\r\n    this.showLineNumbers = params.showLineNumbers\r\n    this.assert = params.assert || (condition => condition)\r\n    this.showInvisibles = (params.showInvisibles != null) ? params.showInvisibles : true\r\n    this.autoHeight = params.autoHeight\r\n    this.autoWidth = params.autoWidth\r\n    this.scrollPastEnd = (params.scrollPastEnd != null) ? params.scrollPastEnd : false\r\n    this.scrollSensitivity = (params.scrollSensitivity != null) ? params.scrollSensitivity : 40\r\n    this.editorWidthInChars = params.editorWidthInChars\r\n    this.invisibles = params.invisibles\r\n    this.showIndentGuide = params.showIndentGuide\r\n    this.softWrapped = params.softWrapped\r\n    this.softWrapAtPreferredLineLength = params.softWrapAtPreferredLineLength\r\n    this.preferredLineLength = params.preferredLineLength\r\n    this.showCursorOnSelection = (params.showCursorOnSelection != null) ? params.showCursorOnSelection : true\r\n    this.maxScreenLineLength = params.maxScreenLineLength\r\n    this.softTabs = (params.softTabs != null) ? params.softTabs : true\r\n    this.autoIndent = (params.autoIndent != null) ? params.autoIndent : true\r\n    this.autoIndentOnPaste = (params.autoIndentOnPaste != null) ? params.autoIndentOnPaste : true\r\n    this.undoGroupingInterval = (params.undoGroupingInterval != null) ? params.undoGroupingInterval : 300\r\n    this.softWrapped = (params.softWrapped != null) ? params.softWrapped : false\r\n    this.softWrapAtPreferredLineLength = (params.softWrapAtPreferredLineLength != null) ? params.softWrapAtPreferredLineLength : false\r\n    this.preferredLineLength = (params.preferredLineLength != null) ? params.preferredLineLength : 80\r\n    this.maxScreenLineLength = (params.maxScreenLineLength != null) ? params.maxScreenLineLength : 500\r\n    this.showLineNumbers = (params.showLineNumbers != null) ? params.showLineNumbers : true\r\n    const {tabLength = 2} = params\r\n\r\n    this.alive = true\r\n    this.doBackgroundWork = this.doBackgroundWork.bind(this)\r\n    this.serializationVersion = 1\r\n    this.suppressSelectionMerging = false\r\n    this.selectionFlashDuration = 500\r\n    this.gutterContainer = null\r\n    this.verticalScrollMargin = 2\r\n    this.horizontalScrollMargin = 6\r\n    this.lineHeightInPixels = null\r\n    this.defaultCharWidth = null\r\n    this.height = null\r\n    this.width = null\r\n    this.registered = false\r\n    this.atomicSoftTabs = true\r\n    this.emitter = new Emitter()\r\n    this.disposables = new CompositeDisposable()\r\n    this.cursors = []\r\n    this.cursorsByMarkerId = new Map()\r\n    this.selections = []\r\n    this.hasTerminatedPendingState = false\r\n\r\n    if (params.buffer) {\r\n      this.buffer = params.buffer\r\n    } else {\r\n      this.buffer = new TextBuffer({\r\n        shouldDestroyOnFileDelete () { return atom.config.get('core.closeDeletedFileTabs') }\r\n      })\r\n      this.buffer.setLanguageMode(new TextMateLanguageMode({buffer: this.buffer, config: atom.config}))\r\n    }\r\n\r\n    const languageMode = this.buffer.getLanguageMode()\r\n    this.languageModeSubscription = languageMode.onDidTokenize && languageMode.onDidTokenize(() => {\r\n      this.emitter.emit('did-tokenize')\r\n    })\r\n    if (this.languageModeSubscription) this.disposables.add(this.languageModeSubscription)\r\n\r\n    if (params.displayLayer) {\r\n      this.displayLayer = params.displayLayer\r\n    } else {\r\n      const displayLayerParams = {\r\n        invisibles: this.getInvisibles(),\r\n        softWrapColumn: this.getSoftWrapColumn(),\r\n        showIndentGuides: this.doesShowIndentGuide(),\r\n        atomicSoftTabs: params.atomicSoftTabs != null ? params.atomicSoftTabs : true,\r\n        tabLength,\r\n        ratioForCharacter: this.ratioForCharacter.bind(this),\r\n        isWrapBoundary,\r\n        foldCharacter: ZERO_WIDTH_NBSP,\r\n        softWrapHangingIndent: params.softWrapHangingIndentLength != null ? params.softWrapHangingIndentLength : 0\r\n      }\r\n\r\n      this.displayLayer = this.buffer.getDisplayLayer(params.displayLayerId)\r\n      if (this.displayLayer) {\r\n        this.displayLayer.reset(displayLayerParams)\r\n        this.selectionsMarkerLayer = this.displayLayer.getMarkerLayer(params.selectionsMarkerLayerId)\r\n      } else {\r\n        this.displayLayer = this.buffer.addDisplayLayer(displayLayerParams)\r\n      }\r\n    }\r\n\r\n    this.backgroundWorkHandle = requestIdleCallback(this.doBackgroundWork)\r\n    this.disposables.add(new Disposable(() => {\r\n      if (this.backgroundWorkHandle != null) return cancelIdleCallback(this.backgroundWorkHandle)\r\n    }))\r\n\r\n    this.defaultMarkerLayer = this.displayLayer.addMarkerLayer()\r\n    if (!this.selectionsMarkerLayer) {\r\n      this.selectionsMarkerLayer = this.addMarkerLayer({maintainHistory: true, persistent: true, role: 'selections'})\r\n    }\r\n\r\n    this.decorationManager = new DecorationManager(this)\r\n    this.decorateMarkerLayer(this.selectionsMarkerLayer, {type: 'cursor'})\r\n    if (!this.isMini()) this.decorateCursorLine()\r\n\r\n    this.decorateMarkerLayer(this.displayLayer.foldsMarkerLayer, {type: 'line-number', class: 'folded'})\r\n\r\n    for (let marker of this.selectionsMarkerLayer.getMarkers()) {\r\n      this.addSelection(marker)\r\n    }\r\n\r\n    this.subscribeToBuffer()\r\n    this.subscribeToDisplayLayer()\r\n\r\n    if (this.cursors.length === 0 && !params.suppressCursorCreation) {\r\n      const initialLine = Math.max(parseInt(params.initialLine) || 0, 0)\r\n      const initialColumn = Math.max(parseInt(params.initialColumn) || 0, 0)\r\n      this.addCursorAtBufferPosition([initialLine, initialColumn])\r\n    }\r\n\r\n    this.gutterContainer = new GutterContainer(this)\r\n    this.lineNumberGutter = this.gutterContainer.addGutter({\r\n      name: 'line-number',\r\n      type: 'line-number',\r\n      priority: 0,\r\n      visible: params.lineNumberGutterVisible\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.decorateCursorLine","start_line":299,"end_line":305,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"subscribeToBuffer","line":249,"func_location":"TextEditor.constructor","func_start_line":125,"func_end_line":265,"args":[],"code":"  constructor (params = {}) {\r\n    if (this.constructor.clipboard == null) {\r\n      throw new Error('Must call TextEditor.setClipboard at least once before creating TextEditor instances')\r\n    }\r\n\r\n    this.id = params.id != null ? params.id : nextId++\r\n    if (this.id >= nextId) {\r\n      // Ensure that new editors get unique ids:\r\n      nextId = this.id + 1\r\n    }\r\n    this.initialScrollTopRow = params.initialScrollTopRow\r\n    this.initialScrollLeftColumn = params.initialScrollLeftColumn\r\n    this.decorationManager = params.decorationManager\r\n    this.selectionsMarkerLayer = params.selectionsMarkerLayer\r\n    this.mini = (params.mini != null) ? params.mini : false\r\n    this.keyboardInputEnabled = (params.keyboardInputEnabled != null) ? params.keyboardInputEnabled : true\r\n    this.readOnly = (params.readOnly != null) ? params.readOnly : false\r\n    this.placeholderText = params.placeholderText\r\n    this.showLineNumbers = params.showLineNumbers\r\n    this.assert = params.assert || (condition => condition)\r\n    this.showInvisibles = (params.showInvisibles != null) ? params.showInvisibles : true\r\n    this.autoHeight = params.autoHeight\r\n    this.autoWidth = params.autoWidth\r\n    this.scrollPastEnd = (params.scrollPastEnd != null) ? params.scrollPastEnd : false\r\n    this.scrollSensitivity = (params.scrollSensitivity != null) ? params.scrollSensitivity : 40\r\n    this.editorWidthInChars = params.editorWidthInChars\r\n    this.invisibles = params.invisibles\r\n    this.showIndentGuide = params.showIndentGuide\r\n    this.softWrapped = params.softWrapped\r\n    this.softWrapAtPreferredLineLength = params.softWrapAtPreferredLineLength\r\n    this.preferredLineLength = params.preferredLineLength\r\n    this.showCursorOnSelection = (params.showCursorOnSelection != null) ? params.showCursorOnSelection : true\r\n    this.maxScreenLineLength = params.maxScreenLineLength\r\n    this.softTabs = (params.softTabs != null) ? params.softTabs : true\r\n    this.autoIndent = (params.autoIndent != null) ? params.autoIndent : true\r\n    this.autoIndentOnPaste = (params.autoIndentOnPaste != null) ? params.autoIndentOnPaste : true\r\n    this.undoGroupingInterval = (params.undoGroupingInterval != null) ? params.undoGroupingInterval : 300\r\n    this.softWrapped = (params.softWrapped != null) ? params.softWrapped : false\r\n    this.softWrapAtPreferredLineLength = (params.softWrapAtPreferredLineLength != null) ? params.softWrapAtPreferredLineLength : false\r\n    this.preferredLineLength = (params.preferredLineLength != null) ? params.preferredLineLength : 80\r\n    this.maxScreenLineLength = (params.maxScreenLineLength != null) ? params.maxScreenLineLength : 500\r\n    this.showLineNumbers = (params.showLineNumbers != null) ? params.showLineNumbers : true\r\n    const {tabLength = 2} = params\r\n\r\n    this.alive = true\r\n    this.doBackgroundWork = this.doBackgroundWork.bind(this)\r\n    this.serializationVersion = 1\r\n    this.suppressSelectionMerging = false\r\n    this.selectionFlashDuration = 500\r\n    this.gutterContainer = null\r\n    this.verticalScrollMargin = 2\r\n    this.horizontalScrollMargin = 6\r\n    this.lineHeightInPixels = null\r\n    this.defaultCharWidth = null\r\n    this.height = null\r\n    this.width = null\r\n    this.registered = false\r\n    this.atomicSoftTabs = true\r\n    this.emitter = new Emitter()\r\n    this.disposables = new CompositeDisposable()\r\n    this.cursors = []\r\n    this.cursorsByMarkerId = new Map()\r\n    this.selections = []\r\n    this.hasTerminatedPendingState = false\r\n\r\n    if (params.buffer) {\r\n      this.buffer = params.buffer\r\n    } else {\r\n      this.buffer = new TextBuffer({\r\n        shouldDestroyOnFileDelete () { return atom.config.get('core.closeDeletedFileTabs') }\r\n      })\r\n      this.buffer.setLanguageMode(new TextMateLanguageMode({buffer: this.buffer, config: atom.config}))\r\n    }\r\n\r\n    const languageMode = this.buffer.getLanguageMode()\r\n    this.languageModeSubscription = languageMode.onDidTokenize && languageMode.onDidTokenize(() => {\r\n      this.emitter.emit('did-tokenize')\r\n    })\r\n    if (this.languageModeSubscription) this.disposables.add(this.languageModeSubscription)\r\n\r\n    if (params.displayLayer) {\r\n      this.displayLayer = params.displayLayer\r\n    } else {\r\n      const displayLayerParams = {\r\n        invisibles: this.getInvisibles(),\r\n        softWrapColumn: this.getSoftWrapColumn(),\r\n        showIndentGuides: this.doesShowIndentGuide(),\r\n        atomicSoftTabs: params.atomicSoftTabs != null ? params.atomicSoftTabs : true,\r\n        tabLength,\r\n        ratioForCharacter: this.ratioForCharacter.bind(this),\r\n        isWrapBoundary,\r\n        foldCharacter: ZERO_WIDTH_NBSP,\r\n        softWrapHangingIndent: params.softWrapHangingIndentLength != null ? params.softWrapHangingIndentLength : 0\r\n      }\r\n\r\n      this.displayLayer = this.buffer.getDisplayLayer(params.displayLayerId)\r\n      if (this.displayLayer) {\r\n        this.displayLayer.reset(displayLayerParams)\r\n        this.selectionsMarkerLayer = this.displayLayer.getMarkerLayer(params.selectionsMarkerLayerId)\r\n      } else {\r\n        this.displayLayer = this.buffer.addDisplayLayer(displayLayerParams)\r\n      }\r\n    }\r\n\r\n    this.backgroundWorkHandle = requestIdleCallback(this.doBackgroundWork)\r\n    this.disposables.add(new Disposable(() => {\r\n      if (this.backgroundWorkHandle != null) return cancelIdleCallback(this.backgroundWorkHandle)\r\n    }))\r\n\r\n    this.defaultMarkerLayer = this.displayLayer.addMarkerLayer()\r\n    if (!this.selectionsMarkerLayer) {\r\n      this.selectionsMarkerLayer = this.addMarkerLayer({maintainHistory: true, persistent: true, role: 'selections'})\r\n    }\r\n\r\n    this.decorationManager = new DecorationManager(this)\r\n    this.decorateMarkerLayer(this.selectionsMarkerLayer, {type: 'cursor'})\r\n    if (!this.isMini()) this.decorateCursorLine()\r\n\r\n    this.decorateMarkerLayer(this.displayLayer.foldsMarkerLayer, {type: 'line-number', class: 'folded'})\r\n\r\n    for (let marker of this.selectionsMarkerLayer.getMarkers()) {\r\n      this.addSelection(marker)\r\n    }\r\n\r\n    this.subscribeToBuffer()\r\n    this.subscribeToDisplayLayer()\r\n\r\n    if (this.cursors.length === 0 && !params.suppressCursorCreation) {\r\n      const initialLine = Math.max(parseInt(params.initialLine) || 0, 0)\r\n      const initialColumn = Math.max(parseInt(params.initialColumn) || 0, 0)\r\n      this.addCursorAtBufferPosition([initialLine, initialColumn])\r\n    }\r\n\r\n    this.gutterContainer = new GutterContainer(this)\r\n    this.lineNumberGutter = this.gutterContainer.addGutter({\r\n      name: 'line-number',\r\n      type: 'line-number',\r\n      priority: 0,\r\n      visible: params.lineNumberGutterVisible\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.subscribeToBuffer","start_line":581,"end_line":595,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"subscribeToDisplayLayer","line":250,"func_location":"TextEditor.constructor","func_start_line":125,"func_end_line":265,"args":[],"code":"  constructor (params = {}) {\r\n    if (this.constructor.clipboard == null) {\r\n      throw new Error('Must call TextEditor.setClipboard at least once before creating TextEditor instances')\r\n    }\r\n\r\n    this.id = params.id != null ? params.id : nextId++\r\n    if (this.id >= nextId) {\r\n      // Ensure that new editors get unique ids:\r\n      nextId = this.id + 1\r\n    }\r\n    this.initialScrollTopRow = params.initialScrollTopRow\r\n    this.initialScrollLeftColumn = params.initialScrollLeftColumn\r\n    this.decorationManager = params.decorationManager\r\n    this.selectionsMarkerLayer = params.selectionsMarkerLayer\r\n    this.mini = (params.mini != null) ? params.mini : false\r\n    this.keyboardInputEnabled = (params.keyboardInputEnabled != null) ? params.keyboardInputEnabled : true\r\n    this.readOnly = (params.readOnly != null) ? params.readOnly : false\r\n    this.placeholderText = params.placeholderText\r\n    this.showLineNumbers = params.showLineNumbers\r\n    this.assert = params.assert || (condition => condition)\r\n    this.showInvisibles = (params.showInvisibles != null) ? params.showInvisibles : true\r\n    this.autoHeight = params.autoHeight\r\n    this.autoWidth = params.autoWidth\r\n    this.scrollPastEnd = (params.scrollPastEnd != null) ? params.scrollPastEnd : false\r\n    this.scrollSensitivity = (params.scrollSensitivity != null) ? params.scrollSensitivity : 40\r\n    this.editorWidthInChars = params.editorWidthInChars\r\n    this.invisibles = params.invisibles\r\n    this.showIndentGuide = params.showIndentGuide\r\n    this.softWrapped = params.softWrapped\r\n    this.softWrapAtPreferredLineLength = params.softWrapAtPreferredLineLength\r\n    this.preferredLineLength = params.preferredLineLength\r\n    this.showCursorOnSelection = (params.showCursorOnSelection != null) ? params.showCursorOnSelection : true\r\n    this.maxScreenLineLength = params.maxScreenLineLength\r\n    this.softTabs = (params.softTabs != null) ? params.softTabs : true\r\n    this.autoIndent = (params.autoIndent != null) ? params.autoIndent : true\r\n    this.autoIndentOnPaste = (params.autoIndentOnPaste != null) ? params.autoIndentOnPaste : true\r\n    this.undoGroupingInterval = (params.undoGroupingInterval != null) ? params.undoGroupingInterval : 300\r\n    this.softWrapped = (params.softWrapped != null) ? params.softWrapped : false\r\n    this.softWrapAtPreferredLineLength = (params.softWrapAtPreferredLineLength != null) ? params.softWrapAtPreferredLineLength : false\r\n    this.preferredLineLength = (params.preferredLineLength != null) ? params.preferredLineLength : 80\r\n    this.maxScreenLineLength = (params.maxScreenLineLength != null) ? params.maxScreenLineLength : 500\r\n    this.showLineNumbers = (params.showLineNumbers != null) ? params.showLineNumbers : true\r\n    const {tabLength = 2} = params\r\n\r\n    this.alive = true\r\n    this.doBackgroundWork = this.doBackgroundWork.bind(this)\r\n    this.serializationVersion = 1\r\n    this.suppressSelectionMerging = false\r\n    this.selectionFlashDuration = 500\r\n    this.gutterContainer = null\r\n    this.verticalScrollMargin = 2\r\n    this.horizontalScrollMargin = 6\r\n    this.lineHeightInPixels = null\r\n    this.defaultCharWidth = null\r\n    this.height = null\r\n    this.width = null\r\n    this.registered = false\r\n    this.atomicSoftTabs = true\r\n    this.emitter = new Emitter()\r\n    this.disposables = new CompositeDisposable()\r\n    this.cursors = []\r\n    this.cursorsByMarkerId = new Map()\r\n    this.selections = []\r\n    this.hasTerminatedPendingState = false\r\n\r\n    if (params.buffer) {\r\n      this.buffer = params.buffer\r\n    } else {\r\n      this.buffer = new TextBuffer({\r\n        shouldDestroyOnFileDelete () { return atom.config.get('core.closeDeletedFileTabs') }\r\n      })\r\n      this.buffer.setLanguageMode(new TextMateLanguageMode({buffer: this.buffer, config: atom.config}))\r\n    }\r\n\r\n    const languageMode = this.buffer.getLanguageMode()\r\n    this.languageModeSubscription = languageMode.onDidTokenize && languageMode.onDidTokenize(() => {\r\n      this.emitter.emit('did-tokenize')\r\n    })\r\n    if (this.languageModeSubscription) this.disposables.add(this.languageModeSubscription)\r\n\r\n    if (params.displayLayer) {\r\n      this.displayLayer = params.displayLayer\r\n    } else {\r\n      const displayLayerParams = {\r\n        invisibles: this.getInvisibles(),\r\n        softWrapColumn: this.getSoftWrapColumn(),\r\n        showIndentGuides: this.doesShowIndentGuide(),\r\n        atomicSoftTabs: params.atomicSoftTabs != null ? params.atomicSoftTabs : true,\r\n        tabLength,\r\n        ratioForCharacter: this.ratioForCharacter.bind(this),\r\n        isWrapBoundary,\r\n        foldCharacter: ZERO_WIDTH_NBSP,\r\n        softWrapHangingIndent: params.softWrapHangingIndentLength != null ? params.softWrapHangingIndentLength : 0\r\n      }\r\n\r\n      this.displayLayer = this.buffer.getDisplayLayer(params.displayLayerId)\r\n      if (this.displayLayer) {\r\n        this.displayLayer.reset(displayLayerParams)\r\n        this.selectionsMarkerLayer = this.displayLayer.getMarkerLayer(params.selectionsMarkerLayerId)\r\n      } else {\r\n        this.displayLayer = this.buffer.addDisplayLayer(displayLayerParams)\r\n      }\r\n    }\r\n\r\n    this.backgroundWorkHandle = requestIdleCallback(this.doBackgroundWork)\r\n    this.disposables.add(new Disposable(() => {\r\n      if (this.backgroundWorkHandle != null) return cancelIdleCallback(this.backgroundWorkHandle)\r\n    }))\r\n\r\n    this.defaultMarkerLayer = this.displayLayer.addMarkerLayer()\r\n    if (!this.selectionsMarkerLayer) {\r\n      this.selectionsMarkerLayer = this.addMarkerLayer({maintainHistory: true, persistent: true, role: 'selections'})\r\n    }\r\n\r\n    this.decorationManager = new DecorationManager(this)\r\n    this.decorateMarkerLayer(this.selectionsMarkerLayer, {type: 'cursor'})\r\n    if (!this.isMini()) this.decorateCursorLine()\r\n\r\n    this.decorateMarkerLayer(this.displayLayer.foldsMarkerLayer, {type: 'line-number', class: 'folded'})\r\n\r\n    for (let marker of this.selectionsMarkerLayer.getMarkers()) {\r\n      this.addSelection(marker)\r\n    }\r\n\r\n    this.subscribeToBuffer()\r\n    this.subscribeToDisplayLayer()\r\n\r\n    if (this.cursors.length === 0 && !params.suppressCursorCreation) {\r\n      const initialLine = Math.max(parseInt(params.initialLine) || 0, 0)\r\n      const initialColumn = Math.max(parseInt(params.initialColumn) || 0, 0)\r\n      this.addCursorAtBufferPosition([initialLine, initialColumn])\r\n    }\r\n\r\n    this.gutterContainer = new GutterContainer(this)\r\n    this.lineNumberGutter = this.gutterContainer.addGutter({\r\n      name: 'line-number',\r\n      type: 'line-number',\r\n      priority: 0,\r\n      visible: params.lineNumberGutterVisible\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.subscribeToDisplayLayer","start_line":606,"end_line":619,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"debounce","line":89,"func_location":"TextEditorComponent.constructor","func_start_line":55,"func_end_line":182},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"debounce","start_line":4393,"end_line":4410,"comment":[],"params":["fn","wait"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"constructor","line":94,"func_location":"TextEditorComponent.constructor","func_start_line":55,"func_end_line":182},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"NodePool.constructor","start_line":4413,"end_line":4416,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"queryGuttersToRender","line":177,"func_location":"TextEditorComponent.constructor","func_start_line":55,"func_end_line":182,"args":[],"code":"  constructor (props) {\r\n    this.props = props\r\n\r\n    if (!props.model) {\r\n      props.model = new TextEditor({mini: props.mini, readOnly: props.readOnly})\r\n    }\r\n    this.props.model.component = this\r\n\r\n    if (props.element) {\r\n      this.element = props.element\r\n    } else {\r\n      if (!TextEditorElement) TextEditorElement = require('./text-editor-element')\r\n      this.element = new TextEditorElement()\r\n    }\r\n    this.element.initialize(this)\r\n    this.virtualNode = $('atom-text-editor')\r\n    this.virtualNode.domNode = this.element\r\n    this.refs = {}\r\n\r\n    this.updateSync = this.updateSync.bind(this)\r\n    this.didBlurHiddenInput = this.didBlurHiddenInput.bind(this)\r\n    this.didFocusHiddenInput = this.didFocusHiddenInput.bind(this)\r\n    this.didPaste = this.didPaste.bind(this)\r\n    this.didTextInput = this.didTextInput.bind(this)\r\n    this.didKeydown = this.didKeydown.bind(this)\r\n    this.didKeyup = this.didKeyup.bind(this)\r\n    this.didKeypress = this.didKeypress.bind(this)\r\n    this.didCompositionStart = this.didCompositionStart.bind(this)\r\n    this.didCompositionUpdate = this.didCompositionUpdate.bind(this)\r\n    this.didCompositionEnd = this.didCompositionEnd.bind(this)\r\n\r\n    this.updatedSynchronously = this.props.updatedSynchronously\r\n    this.didScrollDummyScrollbar = this.didScrollDummyScrollbar.bind(this)\r\n    this.didMouseDownOnContent = this.didMouseDownOnContent.bind(this)\r\n    this.debouncedResumeCursorBlinking = debounce(\r\n      this.resumeCursorBlinking.bind(this),\r\n      (this.props.cursorBlinkResumeDelay || CURSOR_BLINK_RESUME_DELAY)\r\n    )\r\n    this.lineTopIndex = new LineTopIndex()\r\n    this.lineNodesPool = new NodePool()\r\n    this.updateScheduled = false\r\n    this.suppressUpdates = false\r\n    this.hasInitialMeasurements = false\r\n    this.measurements = {\r\n      lineHeight: 0,\r\n      baseCharacterWidth: 0,\r\n      doubleWidthCharacterWidth: 0,\r\n      halfWidthCharacterWidth: 0,\r\n      koreanCharacterWidth: 0,\r\n      gutterContainerWidth: 0,\r\n      lineNumberGutterWidth: 0,\r\n      clientContainerHeight: 0,\r\n      clientContainerWidth: 0,\r\n      verticalScrollbarWidth: 0,\r\n      horizontalScrollbarHeight: 0,\r\n      longestLineWidth: 0\r\n    }\r\n    this.derivedDimensionsCache = {}\r\n    this.visible = false\r\n    this.cursorsBlinking = false\r\n    this.cursorsBlinkedOff = false\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    this.linesToMeasure = new Map()\r\n    this.extraRenderedScreenLines = new Map()\r\n    this.horizontalPositionsToMeasure = new Map() // Keys are rows with positions we want to measure, values are arrays of columns to measure\r\n    this.horizontalPixelPositionsByScreenLineId = new Map() // Values are maps from column to horizontal pixel positions\r\n    this.blockDecorationsToMeasure = new Set()\r\n    this.blockDecorationsByElement = new WeakMap()\r\n    this.blockDecorationSentinel = document.createElement('div')\r\n    this.blockDecorationSentinel.style.height = '1px'\r\n    this.heightsByBlockDecoration = new WeakMap()\r\n    this.blockDecorationResizeObserver = new ResizeObserver(this.didResizeBlockDecorations.bind(this))\r\n    this.lineComponentsByScreenLineId = new Map()\r\n    this.overlayComponents = new Set()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.remeasureScrollbars = false\r\n    this.pendingAutoscroll = null\r\n    this.scrollTopPending = false\r\n    this.scrollLeftPending = false\r\n    this.scrollTop = 0\r\n    this.scrollLeft = 0\r\n    this.previousScrollWidth = 0\r\n    this.previousScrollHeight = 0\r\n    this.lastKeydown = null\r\n    this.lastKeydownBeforeKeypress = null\r\n    this.accentedCharacterMenuIsOpen = false\r\n    this.remeasureGutterDimensions = false\r\n    this.guttersToRender = [this.props.model.getLineNumberGutter()]\r\n    this.guttersVisibility = [this.guttersToRender[0].visible]\r\n    this.idsByTileStartRow = new Map()\r\n    this.nextTileId = 0\r\n    this.renderedTileStartRows = []\r\n    this.showLineNumbers = this.props.model.doesShowLineNumbers()\r\n    this.lineNumbersToRender = {\r\n      maxDigits: 2,\r\n      bufferRows: [],\r\n      screenRows: [],\r\n      keys: [],\r\n      softWrappedFlags: [],\r\n      foldableFlags: []\r\n    }\r\n    this.decorationsToRender = {\r\n      lineNumbers: new Map(),\r\n      lines: null,\r\n      highlights: [],\r\n      cursors: [],\r\n      overlays: [],\r\n      customGutter: new Map(),\r\n      blocks: new Map(),\r\n      text: []\r\n    }\r\n    this.decorationsToMeasure = {\r\n      highlights: [],\r\n      cursors: new Map()\r\n    }\r\n    this.textDecorationsByMarker = new Map()\r\n    this.textDecorationBoundaries = []\r\n    this.pendingScrollTopRow = this.props.initialScrollTopRow\r\n    this.pendingScrollLeftColumn = this.props.initialScrollLeftColumn\r\n    this.tabIndex = this.props.element && this.props.element.tabIndex ? this.props.element.tabIndex : -1\r\n\r\n    this.measuredContent = false\r\n    this.queryGuttersToRender()\r\n    this.queryMaxLineNumberDigits()\r\n    this.observeBlockDecorations()\r\n    this.updateClassList()\r\n    etch.updateSync(this)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.queryGuttersToRender","start_line":963,"end_line":979,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"queryMaxLineNumberDigits","line":178,"func_location":"TextEditorComponent.constructor","func_start_line":55,"func_end_line":182,"args":[],"code":"  constructor (props) {\r\n    this.props = props\r\n\r\n    if (!props.model) {\r\n      props.model = new TextEditor({mini: props.mini, readOnly: props.readOnly})\r\n    }\r\n    this.props.model.component = this\r\n\r\n    if (props.element) {\r\n      this.element = props.element\r\n    } else {\r\n      if (!TextEditorElement) TextEditorElement = require('./text-editor-element')\r\n      this.element = new TextEditorElement()\r\n    }\r\n    this.element.initialize(this)\r\n    this.virtualNode = $('atom-text-editor')\r\n    this.virtualNode.domNode = this.element\r\n    this.refs = {}\r\n\r\n    this.updateSync = this.updateSync.bind(this)\r\n    this.didBlurHiddenInput = this.didBlurHiddenInput.bind(this)\r\n    this.didFocusHiddenInput = this.didFocusHiddenInput.bind(this)\r\n    this.didPaste = this.didPaste.bind(this)\r\n    this.didTextInput = this.didTextInput.bind(this)\r\n    this.didKeydown = this.didKeydown.bind(this)\r\n    this.didKeyup = this.didKeyup.bind(this)\r\n    this.didKeypress = this.didKeypress.bind(this)\r\n    this.didCompositionStart = this.didCompositionStart.bind(this)\r\n    this.didCompositionUpdate = this.didCompositionUpdate.bind(this)\r\n    this.didCompositionEnd = this.didCompositionEnd.bind(this)\r\n\r\n    this.updatedSynchronously = this.props.updatedSynchronously\r\n    this.didScrollDummyScrollbar = this.didScrollDummyScrollbar.bind(this)\r\n    this.didMouseDownOnContent = this.didMouseDownOnContent.bind(this)\r\n    this.debouncedResumeCursorBlinking = debounce(\r\n      this.resumeCursorBlinking.bind(this),\r\n      (this.props.cursorBlinkResumeDelay || CURSOR_BLINK_RESUME_DELAY)\r\n    )\r\n    this.lineTopIndex = new LineTopIndex()\r\n    this.lineNodesPool = new NodePool()\r\n    this.updateScheduled = false\r\n    this.suppressUpdates = false\r\n    this.hasInitialMeasurements = false\r\n    this.measurements = {\r\n      lineHeight: 0,\r\n      baseCharacterWidth: 0,\r\n      doubleWidthCharacterWidth: 0,\r\n      halfWidthCharacterWidth: 0,\r\n      koreanCharacterWidth: 0,\r\n      gutterContainerWidth: 0,\r\n      lineNumberGutterWidth: 0,\r\n      clientContainerHeight: 0,\r\n      clientContainerWidth: 0,\r\n      verticalScrollbarWidth: 0,\r\n      horizontalScrollbarHeight: 0,\r\n      longestLineWidth: 0\r\n    }\r\n    this.derivedDimensionsCache = {}\r\n    this.visible = false\r\n    this.cursorsBlinking = false\r\n    this.cursorsBlinkedOff = false\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    this.linesToMeasure = new Map()\r\n    this.extraRenderedScreenLines = new Map()\r\n    this.horizontalPositionsToMeasure = new Map() // Keys are rows with positions we want to measure, values are arrays of columns to measure\r\n    this.horizontalPixelPositionsByScreenLineId = new Map() // Values are maps from column to horizontal pixel positions\r\n    this.blockDecorationsToMeasure = new Set()\r\n    this.blockDecorationsByElement = new WeakMap()\r\n    this.blockDecorationSentinel = document.createElement('div')\r\n    this.blockDecorationSentinel.style.height = '1px'\r\n    this.heightsByBlockDecoration = new WeakMap()\r\n    this.blockDecorationResizeObserver = new ResizeObserver(this.didResizeBlockDecorations.bind(this))\r\n    this.lineComponentsByScreenLineId = new Map()\r\n    this.overlayComponents = new Set()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.remeasureScrollbars = false\r\n    this.pendingAutoscroll = null\r\n    this.scrollTopPending = false\r\n    this.scrollLeftPending = false\r\n    this.scrollTop = 0\r\n    this.scrollLeft = 0\r\n    this.previousScrollWidth = 0\r\n    this.previousScrollHeight = 0\r\n    this.lastKeydown = null\r\n    this.lastKeydownBeforeKeypress = null\r\n    this.accentedCharacterMenuIsOpen = false\r\n    this.remeasureGutterDimensions = false\r\n    this.guttersToRender = [this.props.model.getLineNumberGutter()]\r\n    this.guttersVisibility = [this.guttersToRender[0].visible]\r\n    this.idsByTileStartRow = new Map()\r\n    this.nextTileId = 0\r\n    this.renderedTileStartRows = []\r\n    this.showLineNumbers = this.props.model.doesShowLineNumbers()\r\n    this.lineNumbersToRender = {\r\n      maxDigits: 2,\r\n      bufferRows: [],\r\n      screenRows: [],\r\n      keys: [],\r\n      softWrappedFlags: [],\r\n      foldableFlags: []\r\n    }\r\n    this.decorationsToRender = {\r\n      lineNumbers: new Map(),\r\n      lines: null,\r\n      highlights: [],\r\n      cursors: [],\r\n      overlays: [],\r\n      customGutter: new Map(),\r\n      blocks: new Map(),\r\n      text: []\r\n    }\r\n    this.decorationsToMeasure = {\r\n      highlights: [],\r\n      cursors: new Map()\r\n    }\r\n    this.textDecorationsByMarker = new Map()\r\n    this.textDecorationBoundaries = []\r\n    this.pendingScrollTopRow = this.props.initialScrollTopRow\r\n    this.pendingScrollLeftColumn = this.props.initialScrollLeftColumn\r\n    this.tabIndex = this.props.element && this.props.element.tabIndex ? this.props.element.tabIndex : -1\r\n\r\n    this.measuredContent = false\r\n    this.queryGuttersToRender()\r\n    this.queryMaxLineNumberDigits()\r\n    this.observeBlockDecorations()\r\n    this.updateClassList()\r\n    etch.updateSync(this)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.queryMaxLineNumberDigits","start_line":945,"end_line":954,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"observeBlockDecorations","line":179,"func_location":"TextEditorComponent.constructor","func_start_line":55,"func_end_line":182,"args":[],"code":"  constructor (props) {\r\n    this.props = props\r\n\r\n    if (!props.model) {\r\n      props.model = new TextEditor({mini: props.mini, readOnly: props.readOnly})\r\n    }\r\n    this.props.model.component = this\r\n\r\n    if (props.element) {\r\n      this.element = props.element\r\n    } else {\r\n      if (!TextEditorElement) TextEditorElement = require('./text-editor-element')\r\n      this.element = new TextEditorElement()\r\n    }\r\n    this.element.initialize(this)\r\n    this.virtualNode = $('atom-text-editor')\r\n    this.virtualNode.domNode = this.element\r\n    this.refs = {}\r\n\r\n    this.updateSync = this.updateSync.bind(this)\r\n    this.didBlurHiddenInput = this.didBlurHiddenInput.bind(this)\r\n    this.didFocusHiddenInput = this.didFocusHiddenInput.bind(this)\r\n    this.didPaste = this.didPaste.bind(this)\r\n    this.didTextInput = this.didTextInput.bind(this)\r\n    this.didKeydown = this.didKeydown.bind(this)\r\n    this.didKeyup = this.didKeyup.bind(this)\r\n    this.didKeypress = this.didKeypress.bind(this)\r\n    this.didCompositionStart = this.didCompositionStart.bind(this)\r\n    this.didCompositionUpdate = this.didCompositionUpdate.bind(this)\r\n    this.didCompositionEnd = this.didCompositionEnd.bind(this)\r\n\r\n    this.updatedSynchronously = this.props.updatedSynchronously\r\n    this.didScrollDummyScrollbar = this.didScrollDummyScrollbar.bind(this)\r\n    this.didMouseDownOnContent = this.didMouseDownOnContent.bind(this)\r\n    this.debouncedResumeCursorBlinking = debounce(\r\n      this.resumeCursorBlinking.bind(this),\r\n      (this.props.cursorBlinkResumeDelay || CURSOR_BLINK_RESUME_DELAY)\r\n    )\r\n    this.lineTopIndex = new LineTopIndex()\r\n    this.lineNodesPool = new NodePool()\r\n    this.updateScheduled = false\r\n    this.suppressUpdates = false\r\n    this.hasInitialMeasurements = false\r\n    this.measurements = {\r\n      lineHeight: 0,\r\n      baseCharacterWidth: 0,\r\n      doubleWidthCharacterWidth: 0,\r\n      halfWidthCharacterWidth: 0,\r\n      koreanCharacterWidth: 0,\r\n      gutterContainerWidth: 0,\r\n      lineNumberGutterWidth: 0,\r\n      clientContainerHeight: 0,\r\n      clientContainerWidth: 0,\r\n      verticalScrollbarWidth: 0,\r\n      horizontalScrollbarHeight: 0,\r\n      longestLineWidth: 0\r\n    }\r\n    this.derivedDimensionsCache = {}\r\n    this.visible = false\r\n    this.cursorsBlinking = false\r\n    this.cursorsBlinkedOff = false\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    this.linesToMeasure = new Map()\r\n    this.extraRenderedScreenLines = new Map()\r\n    this.horizontalPositionsToMeasure = new Map() // Keys are rows with positions we want to measure, values are arrays of columns to measure\r\n    this.horizontalPixelPositionsByScreenLineId = new Map() // Values are maps from column to horizontal pixel positions\r\n    this.blockDecorationsToMeasure = new Set()\r\n    this.blockDecorationsByElement = new WeakMap()\r\n    this.blockDecorationSentinel = document.createElement('div')\r\n    this.blockDecorationSentinel.style.height = '1px'\r\n    this.heightsByBlockDecoration = new WeakMap()\r\n    this.blockDecorationResizeObserver = new ResizeObserver(this.didResizeBlockDecorations.bind(this))\r\n    this.lineComponentsByScreenLineId = new Map()\r\n    this.overlayComponents = new Set()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.remeasureScrollbars = false\r\n    this.pendingAutoscroll = null\r\n    this.scrollTopPending = false\r\n    this.scrollLeftPending = false\r\n    this.scrollTop = 0\r\n    this.scrollLeft = 0\r\n    this.previousScrollWidth = 0\r\n    this.previousScrollHeight = 0\r\n    this.lastKeydown = null\r\n    this.lastKeydownBeforeKeypress = null\r\n    this.accentedCharacterMenuIsOpen = false\r\n    this.remeasureGutterDimensions = false\r\n    this.guttersToRender = [this.props.model.getLineNumberGutter()]\r\n    this.guttersVisibility = [this.guttersToRender[0].visible]\r\n    this.idsByTileStartRow = new Map()\r\n    this.nextTileId = 0\r\n    this.renderedTileStartRows = []\r\n    this.showLineNumbers = this.props.model.doesShowLineNumbers()\r\n    this.lineNumbersToRender = {\r\n      maxDigits: 2,\r\n      bufferRows: [],\r\n      screenRows: [],\r\n      keys: [],\r\n      softWrappedFlags: [],\r\n      foldableFlags: []\r\n    }\r\n    this.decorationsToRender = {\r\n      lineNumbers: new Map(),\r\n      lines: null,\r\n      highlights: [],\r\n      cursors: [],\r\n      overlays: [],\r\n      customGutter: new Map(),\r\n      blocks: new Map(),\r\n      text: []\r\n    }\r\n    this.decorationsToMeasure = {\r\n      highlights: [],\r\n      cursors: new Map()\r\n    }\r\n    this.textDecorationsByMarker = new Map()\r\n    this.textDecorationBoundaries = []\r\n    this.pendingScrollTopRow = this.props.initialScrollTopRow\r\n    this.pendingScrollLeftColumn = this.props.initialScrollLeftColumn\r\n    this.tabIndex = this.props.element && this.props.element.tabIndex ? this.props.element.tabIndex : -1\r\n\r\n    this.measuredContent = false\r\n    this.queryGuttersToRender()\r\n    this.queryMaxLineNumberDigits()\r\n    this.observeBlockDecorations()\r\n    this.updateClassList()\r\n    etch.updateSync(this)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.observeBlockDecorations","start_line":2500,"end_line":2506,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateClassList","line":180,"func_location":"TextEditorComponent.constructor","func_start_line":55,"func_end_line":182,"args":[],"code":"  constructor (props) {\r\n    this.props = props\r\n\r\n    if (!props.model) {\r\n      props.model = new TextEditor({mini: props.mini, readOnly: props.readOnly})\r\n    }\r\n    this.props.model.component = this\r\n\r\n    if (props.element) {\r\n      this.element = props.element\r\n    } else {\r\n      if (!TextEditorElement) TextEditorElement = require('./text-editor-element')\r\n      this.element = new TextEditorElement()\r\n    }\r\n    this.element.initialize(this)\r\n    this.virtualNode = $('atom-text-editor')\r\n    this.virtualNode.domNode = this.element\r\n    this.refs = {}\r\n\r\n    this.updateSync = this.updateSync.bind(this)\r\n    this.didBlurHiddenInput = this.didBlurHiddenInput.bind(this)\r\n    this.didFocusHiddenInput = this.didFocusHiddenInput.bind(this)\r\n    this.didPaste = this.didPaste.bind(this)\r\n    this.didTextInput = this.didTextInput.bind(this)\r\n    this.didKeydown = this.didKeydown.bind(this)\r\n    this.didKeyup = this.didKeyup.bind(this)\r\n    this.didKeypress = this.didKeypress.bind(this)\r\n    this.didCompositionStart = this.didCompositionStart.bind(this)\r\n    this.didCompositionUpdate = this.didCompositionUpdate.bind(this)\r\n    this.didCompositionEnd = this.didCompositionEnd.bind(this)\r\n\r\n    this.updatedSynchronously = this.props.updatedSynchronously\r\n    this.didScrollDummyScrollbar = this.didScrollDummyScrollbar.bind(this)\r\n    this.didMouseDownOnContent = this.didMouseDownOnContent.bind(this)\r\n    this.debouncedResumeCursorBlinking = debounce(\r\n      this.resumeCursorBlinking.bind(this),\r\n      (this.props.cursorBlinkResumeDelay || CURSOR_BLINK_RESUME_DELAY)\r\n    )\r\n    this.lineTopIndex = new LineTopIndex()\r\n    this.lineNodesPool = new NodePool()\r\n    this.updateScheduled = false\r\n    this.suppressUpdates = false\r\n    this.hasInitialMeasurements = false\r\n    this.measurements = {\r\n      lineHeight: 0,\r\n      baseCharacterWidth: 0,\r\n      doubleWidthCharacterWidth: 0,\r\n      halfWidthCharacterWidth: 0,\r\n      koreanCharacterWidth: 0,\r\n      gutterContainerWidth: 0,\r\n      lineNumberGutterWidth: 0,\r\n      clientContainerHeight: 0,\r\n      clientContainerWidth: 0,\r\n      verticalScrollbarWidth: 0,\r\n      horizontalScrollbarHeight: 0,\r\n      longestLineWidth: 0\r\n    }\r\n    this.derivedDimensionsCache = {}\r\n    this.visible = false\r\n    this.cursorsBlinking = false\r\n    this.cursorsBlinkedOff = false\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    this.linesToMeasure = new Map()\r\n    this.extraRenderedScreenLines = new Map()\r\n    this.horizontalPositionsToMeasure = new Map() // Keys are rows with positions we want to measure, values are arrays of columns to measure\r\n    this.horizontalPixelPositionsByScreenLineId = new Map() // Values are maps from column to horizontal pixel positions\r\n    this.blockDecorationsToMeasure = new Set()\r\n    this.blockDecorationsByElement = new WeakMap()\r\n    this.blockDecorationSentinel = document.createElement('div')\r\n    this.blockDecorationSentinel.style.height = '1px'\r\n    this.heightsByBlockDecoration = new WeakMap()\r\n    this.blockDecorationResizeObserver = new ResizeObserver(this.didResizeBlockDecorations.bind(this))\r\n    this.lineComponentsByScreenLineId = new Map()\r\n    this.overlayComponents = new Set()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.remeasureScrollbars = false\r\n    this.pendingAutoscroll = null\r\n    this.scrollTopPending = false\r\n    this.scrollLeftPending = false\r\n    this.scrollTop = 0\r\n    this.scrollLeft = 0\r\n    this.previousScrollWidth = 0\r\n    this.previousScrollHeight = 0\r\n    this.lastKeydown = null\r\n    this.lastKeydownBeforeKeypress = null\r\n    this.accentedCharacterMenuIsOpen = false\r\n    this.remeasureGutterDimensions = false\r\n    this.guttersToRender = [this.props.model.getLineNumberGutter()]\r\n    this.guttersVisibility = [this.guttersToRender[0].visible]\r\n    this.idsByTileStartRow = new Map()\r\n    this.nextTileId = 0\r\n    this.renderedTileStartRows = []\r\n    this.showLineNumbers = this.props.model.doesShowLineNumbers()\r\n    this.lineNumbersToRender = {\r\n      maxDigits: 2,\r\n      bufferRows: [],\r\n      screenRows: [],\r\n      keys: [],\r\n      softWrappedFlags: [],\r\n      foldableFlags: []\r\n    }\r\n    this.decorationsToRender = {\r\n      lineNumbers: new Map(),\r\n      lines: null,\r\n      highlights: [],\r\n      cursors: [],\r\n      overlays: [],\r\n      customGutter: new Map(),\r\n      blocks: new Map(),\r\n      text: []\r\n    }\r\n    this.decorationsToMeasure = {\r\n      highlights: [],\r\n      cursors: new Map()\r\n    }\r\n    this.textDecorationsByMarker = new Map()\r\n    this.textDecorationBoundaries = []\r\n    this.pendingScrollTopRow = this.props.initialScrollTopRow\r\n    this.pendingScrollLeftColumn = this.props.initialScrollLeftColumn\r\n    this.tabIndex = this.props.element && this.props.element.tabIndex ? this.props.element.tabIndex : -1\r\n\r\n    this.measuredContent = false\r\n    this.queryGuttersToRender()\r\n    this.queryMaxLineNumberDigits()\r\n    this.observeBlockDecorations()\r\n    this.updateClassList()\r\n    etch.updateSync(this)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateClassList","start_line":829,"end_line":857,"comment":[" Imperatively manipulate the class list of the root element to avoid"," clearing classes assigned by package authors."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"didAttach","line":4290,"func_location":"OverlayComponent.constructor","func_start_line":4260,"func_end_line":4292,"args":[],"code":"  constructor (props) {\r\n    this.props = props\r\n    this.element = document.createElement('atom-overlay')\r\n    if (this.props.className != null) this.element.classList.add(this.props.className)\r\n    this.element.appendChild(this.props.element)\r\n    this.element.style.position = 'fixed'\r\n    this.element.style.zIndex = 4\r\n    this.element.style.top = (this.props.pixelTop || 0) + 'px'\r\n    this.element.style.left = (this.props.pixelLeft || 0) + 'px'\r\n    this.currentContentRect = null\r\n\r\n    // Synchronous DOM updates in response to resize events might trigger a\r\n    // \"loop limit exceeded\" error. We disconnect the observer before\r\n    // potentially mutating the DOM, and then reconnect it on the next tick.\r\n    // Note: ResizeObserver calls its callback when .observe is called\r\n    this.resizeObserver = new ResizeObserver((entries) => {\r\n      const {contentRect} = entries[0]\r\n\r\n      if (\r\n        this.currentContentRect &&\r\n        (this.currentContentRect.width !== contentRect.width ||\r\n          this.currentContentRect.height !== contentRect.height)\r\n      ) {\r\n        this.resizeObserver.disconnect()\r\n        this.props.didResize(this)\r\n        process.nextTick(() => { this.resizeObserver.observe(this.props.element) })\r\n      }\r\n\r\n      this.currentContentRect = contentRect\r\n    })\r\n    this.didAttach()\r\n    this.props.overlayComponents.add(this)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"OverlayComponent.didAttach","start_line":4325,"end_line":4327,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"createLines","line":3655,"func_location":"LinesTileComponent.constructor","func_start_line":3652,"func_end_line":3657,"args":[],"code":"  constructor (props) {\r\n    this.props = props\r\n    etch.initialize(this)\r\n    this.createLines()\r\n    this.updateBlockDecorations({}, props)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"LinesTileComponent.createLines","start_line":3697,"end_line":3717,"comment":[" Lines and block decorations will be manually inserted here for efficiency"],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateBlockDecorations","line":3656,"func_location":"LinesTileComponent.constructor","func_start_line":3652,"func_end_line":3657,"args":[null,"props"],"code":"  constructor (props) {\r\n    this.props = props\r\n    etch.initialize(this)\r\n    this.createLines()\r\n    this.updateBlockDecorations({}, props)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"LinesTileComponent.updateBlockDecorations","start_line":3845,"end_line":3880,"comment":[],"params":["oldProps","newProps"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"constructor","line":3195,"func_location":"LineNumberGutterComponent.constructor","func_start_line":3190,"func_end_line":3197},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"NodePool.constructor","start_line":4413,"end_line":4416,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"buildClassName","line":3932,"func_location":"LineComponent.constructor","func_start_line":3929,"func_end_line":3944,"args":[{"type":"string"},null,{"type":"object"}],"code":"  constructor (props) {\r\n    const {nodePool, screenRow, screenLine, lineComponentsByScreenLineId, offScreen} = props\r\n    this.props = props\r\n    this.element = nodePool.getElement('DIV', this.buildClassName(), null)\r\n    this.element.dataset.screenRow = screenRow\r\n    this.textNodes = []\r\n\r\n    if (offScreen) {\r\n      this.element.style.position = 'absolute'\r\n      this.element.style.visibility = 'hidden'\r\n      this.element.dataset.offScreen = true\r\n    }\r\n\r\n    this.appendContents()\r\n    lineComponentsByScreenLineId.set(screenLine.id, this)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"LineComponent.buildClassName","start_line":4055,"end_line":4060,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"appendContents","line":3942,"func_location":"LineComponent.constructor","func_start_line":3929,"func_end_line":3944,"args":[],"code":"  constructor (props) {\r\n    const {nodePool, screenRow, screenLine, lineComponentsByScreenLineId, offScreen} = props\r\n    this.props = props\r\n    this.element = nodePool.getElement('DIV', this.buildClassName(), null)\r\n    this.element.dataset.screenRow = screenRow\r\n    this.textNodes = []\r\n\r\n    if (offScreen) {\r\n      this.element.style.position = 'absolute'\r\n      this.element.style.visibility = 'hidden'\r\n      this.element.dataset.offScreen = true\r\n    }\r\n\r\n    this.appendContents()\r\n    lineComponentsByScreenLineId.set(screenLine.id, this)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"LineComponent.appendContents","start_line":3975,"end_line":4039,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"update","line":4073,"func_location":"HighlightsComponent.constructor","func_start_line":4064,"func_end_line":4074,"args":["props"],"code":"  constructor (props) {\r\n    this.props = {}\r\n    this.element = document.createElement('div')\r\n    this.element.className = 'highlights'\r\n    this.element.style.contain = 'strict'\r\n    this.element.style.position = 'absolute'\r\n    this.element.style.overflow = 'hidden'\r\n    this.element.style.userSelect = 'none'\r\n    this.highlightComponentsByKey = new Map()\r\n    this.update(props)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"HighlightsComponent.update","start_line":4083,"end_line":4118,"comment":[],"params":["newProps"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"performFlash","line":4152,"func_location":"HighlightComponent.constructor","func_start_line":4149,"func_end_line":4153,"args":[],"code":"  constructor (props) {\r\n    this.props = props\r\n    etch.initialize(this)\r\n    if (this.props.flashRequested) this.performFlash()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"HighlightComponent.performFlash","start_line":4172,"end_line":4190,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"clear","line":404,"func_location":"Config.constructor","func_start_line":403,"func_end_line":406,"args":[],"comment":[" Created during initialization, available as `atom.config`"],"code":"  constructor (params = {}) {\r\n    this.clear()\r\n    this.initialize(params)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.clear","start_line":419,"end_line":438,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"initialize","line":405,"func_location":"Config.constructor","func_start_line":403,"func_end_line":406,"args":["params"],"comment":[" Created during initialization, available as `atom.config`"],"code":"  constructor (params = {}) {\r\n    this.clear()\r\n    this.initialize(params)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.initialize","start_line":408,"end_line":417,"comment":[],"params":[["saveCallback","mainSource","projectHomeSchema"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js","name":"applyWindowsJumpListRemovals","line":22,"func_location":"ReopenProjectMenuManager.constructor","func_start_line":6,"func_end_line":23,"args":[],"code":"  constructor ({menu, commands, history, config, open}) {\r\n    this.menuManager = menu\r\n    this.historyManager = history\r\n    this.config = config\r\n    this.open = open\r\n    this.projects = []\r\n\r\n    this.subscriptions = new CompositeDisposable()\r\n    this.subscriptions.add(\r\n      history.onDidChangeProjects(this.update.bind(this)),\r\n      config.onDidChange('core.reopenProjectMenuCount', ({oldValue, newValue}) => {\r\n        this.update()\r\n      }),\r\n      commands.add('atom-workspace', { 'application:reopen-project': this.reopenProjectCommand.bind(this) })\r\n    )\r\n\r\n    this.applyWindowsJumpListRemovals()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js","name":"ReopenProjectMenuManager.applyWindowsJumpListRemovals","start_line":60,"end_line":73,"comment":[" Windows users can right-click Atom taskbar and remove project from the jump list."," We have to honor that or the group stops working. As we only get a partial list"," each time we remove them from history entirely."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"shouldAddCustomTitleBar","line":53,"func_location":"AtomWindow.constructor","func_start_line":14,"func_end_line":138,"args":[],"code":"  constructor (atomApplication, fileRecoveryService, settings = {}) {\r\n    super()\r\n\r\n    this.id = nextId++\r\n    this.atomApplication = atomApplication\r\n    this.fileRecoveryService = fileRecoveryService\r\n    this.isSpec = settings.isSpec\r\n    this.headless = settings.headless\r\n    this.safeMode = settings.safeMode\r\n    this.devMode = settings.devMode\r\n    this.resourcePath = settings.resourcePath\r\n\r\n    let {pathToOpen, locationsToOpen} = settings\r\n    if (!locationsToOpen && pathToOpen) locationsToOpen = [{pathToOpen}]\r\n    if (!locationsToOpen) locationsToOpen = []\r\n\r\n    this.loadedPromise = new Promise(resolve => { this.resolveLoadedPromise = resolve })\r\n    this.closedPromise = new Promise(resolve => { this.resolveClosedPromise = resolve })\r\n\r\n    const options = {\r\n      show: false,\r\n      title: 'Atom',\r\n      tabbingIdentifier: 'atom',\r\n      webPreferences: {\r\n        // Prevent specs from throttling when the window is in the background:\r\n        // this should result in faster CI builds, and an improvement in the\r\n        // local development experience when running specs through the UI (which\r\n        // now won't pause when e.g. minimizing the window).\r\n        backgroundThrottling: !this.isSpec,\r\n        // Disable the `auxclick` feature so that `click` events are triggered in\r\n        // response to a middle-click.\r\n        // (Ref: https://github.com/atom/atom/pull/12696#issuecomment-290496960)\r\n        disableBlinkFeatures: 'Auxclick'\r\n      }\r\n    }\r\n\r\n    // Don't set icon on Windows so the exe's ico will be used as window and\r\n    // taskbar's icon. See https://github.com/atom/atom/issues/4811 for more.\r\n    if (process.platform === 'linux') options.icon = ICON_PATH\r\n    if (this.shouldAddCustomTitleBar()) options.titleBarStyle = 'hidden'\r\n    if (this.shouldAddCustomInsetTitleBar()) options.titleBarStyle = 'hiddenInset'\r\n    if (this.shouldHideTitleBar()) options.frame = false\r\n    this.browserWindow = new BrowserWindow(options)\r\n\r\n    Object.defineProperty(this.browserWindow, 'loadSettingsJSON', {\r\n      get: () => JSON.stringify(Object.assign({\r\n        userSettings: !this.isSpec\r\n          ? this.atomApplication.configFile.get()\r\n          : null\r\n      }, this.loadSettings))\r\n    })\r\n\r\n    this.handleEvents()\r\n\r\n    this.loadSettings = Object.assign({}, settings)\r\n    this.loadSettings.appVersion = app.getVersion()\r\n    this.loadSettings.resourcePath = this.resourcePath\r\n    this.loadSettings.atomHome = process.env.ATOM_HOME\r\n    if (this.loadSettings.devMode == null) this.loadSettings.devMode = false\r\n    if (this.loadSettings.safeMode == null) this.loadSettings.safeMode = false\r\n    if (this.loadSettings.clearWindowState == null) this.loadSettings.clearWindowState = false\r\n\r\n    if (!this.loadSettings.initialPaths) {\r\n      this.loadSettings.initialPaths = []\r\n      for (const {pathToOpen, stat} of locationsToOpen) {\r\n        if (!pathToOpen) continue\r\n        if (stat && stat.isDirectory()) {\r\n          this.loadSettings.initialPaths.push(pathToOpen)\r\n        } else {\r\n          const parentDirectory = path.dirname(pathToOpen)\r\n          if (stat && stat.isFile() || fs.existsSync(parentDirectory)) {\r\n            this.loadSettings.initialPaths.push(parentDirectory)\r\n          } else {\r\n            this.loadSettings.initialPaths.push(pathToOpen)\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    this.loadSettings.initialPaths.sort()\r\n\r\n    // Only send to the first non-spec window created\r\n    if (includeShellLoadTime && !this.isSpec) {\r\n      includeShellLoadTime = false\r\n      if (!this.loadSettings.shellLoadTime) {\r\n        this.loadSettings.shellLoadTime = Date.now() - global.shellStartTime\r\n      }\r\n    }\r\n\r\n    this.representedDirectoryPaths = this.loadSettings.initialPaths\r\n    if (!this.loadSettings.env) this.env = this.loadSettings.env\r\n\r\n    this.browserWindow.on('window:loaded', () => {\r\n      this.disableZoom()\r\n      this.emit('window:loaded')\r\n      this.resolveLoadedPromise()\r\n    })\r\n\r\n    this.browserWindow.on('window:locations-opened', () => {\r\n      this.emit('window:locations-opened')\r\n    })\r\n\r\n    this.browserWindow.on('enter-full-screen', () => {\r\n      this.browserWindow.webContents.send('did-enter-full-screen')\r\n    })\r\n\r\n    this.browserWindow.on('leave-full-screen', () => {\r\n      this.browserWindow.webContents.send('did-leave-full-screen')\r\n    })\r\n\r\n    this.browserWindow.loadURL(\r\n      url.format({\r\n        protocol: 'file',\r\n        pathname: `${this.resourcePath}/static/index.html`,\r\n        slashes: true\r\n      })\r\n    )\r\n\r\n    this.browserWindow.showSaveDialog = this.showSaveDialog.bind(this)\r\n\r\n    if (this.isSpec) this.browserWindow.focusOnWebView()\r\n\r\n    const hasPathToOpen = !(locationsToOpen.length === 1 && locationsToOpen[0].pathToOpen == null)\r\n    if (hasPathToOpen && !this.isSpecWindow()) this.openLocations(locationsToOpen)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"AtomWindow.shouldAddCustomTitleBar","start_line":306,"end_line":312,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"shouldAddCustomInsetTitleBar","line":54,"func_location":"AtomWindow.constructor","func_start_line":14,"func_end_line":138,"args":[],"code":"  constructor (atomApplication, fileRecoveryService, settings = {}) {\r\n    super()\r\n\r\n    this.id = nextId++\r\n    this.atomApplication = atomApplication\r\n    this.fileRecoveryService = fileRecoveryService\r\n    this.isSpec = settings.isSpec\r\n    this.headless = settings.headless\r\n    this.safeMode = settings.safeMode\r\n    this.devMode = settings.devMode\r\n    this.resourcePath = settings.resourcePath\r\n\r\n    let {pathToOpen, locationsToOpen} = settings\r\n    if (!locationsToOpen && pathToOpen) locationsToOpen = [{pathToOpen}]\r\n    if (!locationsToOpen) locationsToOpen = []\r\n\r\n    this.loadedPromise = new Promise(resolve => { this.resolveLoadedPromise = resolve })\r\n    this.closedPromise = new Promise(resolve => { this.resolveClosedPromise = resolve })\r\n\r\n    const options = {\r\n      show: false,\r\n      title: 'Atom',\r\n      tabbingIdentifier: 'atom',\r\n      webPreferences: {\r\n        // Prevent specs from throttling when the window is in the background:\r\n        // this should result in faster CI builds, and an improvement in the\r\n        // local development experience when running specs through the UI (which\r\n        // now won't pause when e.g. minimizing the window).\r\n        backgroundThrottling: !this.isSpec,\r\n        // Disable the `auxclick` feature so that `click` events are triggered in\r\n        // response to a middle-click.\r\n        // (Ref: https://github.com/atom/atom/pull/12696#issuecomment-290496960)\r\n        disableBlinkFeatures: 'Auxclick'\r\n      }\r\n    }\r\n\r\n    // Don't set icon on Windows so the exe's ico will be used as window and\r\n    // taskbar's icon. See https://github.com/atom/atom/issues/4811 for more.\r\n    if (process.platform === 'linux') options.icon = ICON_PATH\r\n    if (this.shouldAddCustomTitleBar()) options.titleBarStyle = 'hidden'\r\n    if (this.shouldAddCustomInsetTitleBar()) options.titleBarStyle = 'hiddenInset'\r\n    if (this.shouldHideTitleBar()) options.frame = false\r\n    this.browserWindow = new BrowserWindow(options)\r\n\r\n    Object.defineProperty(this.browserWindow, 'loadSettingsJSON', {\r\n      get: () => JSON.stringify(Object.assign({\r\n        userSettings: !this.isSpec\r\n          ? this.atomApplication.configFile.get()\r\n          : null\r\n      }, this.loadSettings))\r\n    })\r\n\r\n    this.handleEvents()\r\n\r\n    this.loadSettings = Object.assign({}, settings)\r\n    this.loadSettings.appVersion = app.getVersion()\r\n    this.loadSettings.resourcePath = this.resourcePath\r\n    this.loadSettings.atomHome = process.env.ATOM_HOME\r\n    if (this.loadSettings.devMode == null) this.loadSettings.devMode = false\r\n    if (this.loadSettings.safeMode == null) this.loadSettings.safeMode = false\r\n    if (this.loadSettings.clearWindowState == null) this.loadSettings.clearWindowState = false\r\n\r\n    if (!this.loadSettings.initialPaths) {\r\n      this.loadSettings.initialPaths = []\r\n      for (const {pathToOpen, stat} of locationsToOpen) {\r\n        if (!pathToOpen) continue\r\n        if (stat && stat.isDirectory()) {\r\n          this.loadSettings.initialPaths.push(pathToOpen)\r\n        } else {\r\n          const parentDirectory = path.dirname(pathToOpen)\r\n          if (stat && stat.isFile() || fs.existsSync(parentDirectory)) {\r\n            this.loadSettings.initialPaths.push(parentDirectory)\r\n          } else {\r\n            this.loadSettings.initialPaths.push(pathToOpen)\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    this.loadSettings.initialPaths.sort()\r\n\r\n    // Only send to the first non-spec window created\r\n    if (includeShellLoadTime && !this.isSpec) {\r\n      includeShellLoadTime = false\r\n      if (!this.loadSettings.shellLoadTime) {\r\n        this.loadSettings.shellLoadTime = Date.now() - global.shellStartTime\r\n      }\r\n    }\r\n\r\n    this.representedDirectoryPaths = this.loadSettings.initialPaths\r\n    if (!this.loadSettings.env) this.env = this.loadSettings.env\r\n\r\n    this.browserWindow.on('window:loaded', () => {\r\n      this.disableZoom()\r\n      this.emit('window:loaded')\r\n      this.resolveLoadedPromise()\r\n    })\r\n\r\n    this.browserWindow.on('window:locations-opened', () => {\r\n      this.emit('window:locations-opened')\r\n    })\r\n\r\n    this.browserWindow.on('enter-full-screen', () => {\r\n      this.browserWindow.webContents.send('did-enter-full-screen')\r\n    })\r\n\r\n    this.browserWindow.on('leave-full-screen', () => {\r\n      this.browserWindow.webContents.send('did-leave-full-screen')\r\n    })\r\n\r\n    this.browserWindow.loadURL(\r\n      url.format({\r\n        protocol: 'file',\r\n        pathname: `${this.resourcePath}/static/index.html`,\r\n        slashes: true\r\n      })\r\n    )\r\n\r\n    this.browserWindow.showSaveDialog = this.showSaveDialog.bind(this)\r\n\r\n    if (this.isSpec) this.browserWindow.focusOnWebView()\r\n\r\n    const hasPathToOpen = !(locationsToOpen.length === 1 && locationsToOpen[0].pathToOpen == null)\r\n    if (hasPathToOpen && !this.isSpecWindow()) this.openLocations(locationsToOpen)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"AtomWindow.shouldAddCustomInsetTitleBar","start_line":314,"end_line":320,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"shouldHideTitleBar","line":55,"func_location":"AtomWindow.constructor","func_start_line":14,"func_end_line":138,"args":[],"code":"  constructor (atomApplication, fileRecoveryService, settings = {}) {\r\n    super()\r\n\r\n    this.id = nextId++\r\n    this.atomApplication = atomApplication\r\n    this.fileRecoveryService = fileRecoveryService\r\n    this.isSpec = settings.isSpec\r\n    this.headless = settings.headless\r\n    this.safeMode = settings.safeMode\r\n    this.devMode = settings.devMode\r\n    this.resourcePath = settings.resourcePath\r\n\r\n    let {pathToOpen, locationsToOpen} = settings\r\n    if (!locationsToOpen && pathToOpen) locationsToOpen = [{pathToOpen}]\r\n    if (!locationsToOpen) locationsToOpen = []\r\n\r\n    this.loadedPromise = new Promise(resolve => { this.resolveLoadedPromise = resolve })\r\n    this.closedPromise = new Promise(resolve => { this.resolveClosedPromise = resolve })\r\n\r\n    const options = {\r\n      show: false,\r\n      title: 'Atom',\r\n      tabbingIdentifier: 'atom',\r\n      webPreferences: {\r\n        // Prevent specs from throttling when the window is in the background:\r\n        // this should result in faster CI builds, and an improvement in the\r\n        // local development experience when running specs through the UI (which\r\n        // now won't pause when e.g. minimizing the window).\r\n        backgroundThrottling: !this.isSpec,\r\n        // Disable the `auxclick` feature so that `click` events are triggered in\r\n        // response to a middle-click.\r\n        // (Ref: https://github.com/atom/atom/pull/12696#issuecomment-290496960)\r\n        disableBlinkFeatures: 'Auxclick'\r\n      }\r\n    }\r\n\r\n    // Don't set icon on Windows so the exe's ico will be used as window and\r\n    // taskbar's icon. See https://github.com/atom/atom/issues/4811 for more.\r\n    if (process.platform === 'linux') options.icon = ICON_PATH\r\n    if (this.shouldAddCustomTitleBar()) options.titleBarStyle = 'hidden'\r\n    if (this.shouldAddCustomInsetTitleBar()) options.titleBarStyle = 'hiddenInset'\r\n    if (this.shouldHideTitleBar()) options.frame = false\r\n    this.browserWindow = new BrowserWindow(options)\r\n\r\n    Object.defineProperty(this.browserWindow, 'loadSettingsJSON', {\r\n      get: () => JSON.stringify(Object.assign({\r\n        userSettings: !this.isSpec\r\n          ? this.atomApplication.configFile.get()\r\n          : null\r\n      }, this.loadSettings))\r\n    })\r\n\r\n    this.handleEvents()\r\n\r\n    this.loadSettings = Object.assign({}, settings)\r\n    this.loadSettings.appVersion = app.getVersion()\r\n    this.loadSettings.resourcePath = this.resourcePath\r\n    this.loadSettings.atomHome = process.env.ATOM_HOME\r\n    if (this.loadSettings.devMode == null) this.loadSettings.devMode = false\r\n    if (this.loadSettings.safeMode == null) this.loadSettings.safeMode = false\r\n    if (this.loadSettings.clearWindowState == null) this.loadSettings.clearWindowState = false\r\n\r\n    if (!this.loadSettings.initialPaths) {\r\n      this.loadSettings.initialPaths = []\r\n      for (const {pathToOpen, stat} of locationsToOpen) {\r\n        if (!pathToOpen) continue\r\n        if (stat && stat.isDirectory()) {\r\n          this.loadSettings.initialPaths.push(pathToOpen)\r\n        } else {\r\n          const parentDirectory = path.dirname(pathToOpen)\r\n          if (stat && stat.isFile() || fs.existsSync(parentDirectory)) {\r\n            this.loadSettings.initialPaths.push(parentDirectory)\r\n          } else {\r\n            this.loadSettings.initialPaths.push(pathToOpen)\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    this.loadSettings.initialPaths.sort()\r\n\r\n    // Only send to the first non-spec window created\r\n    if (includeShellLoadTime && !this.isSpec) {\r\n      includeShellLoadTime = false\r\n      if (!this.loadSettings.shellLoadTime) {\r\n        this.loadSettings.shellLoadTime = Date.now() - global.shellStartTime\r\n      }\r\n    }\r\n\r\n    this.representedDirectoryPaths = this.loadSettings.initialPaths\r\n    if (!this.loadSettings.env) this.env = this.loadSettings.env\r\n\r\n    this.browserWindow.on('window:loaded', () => {\r\n      this.disableZoom()\r\n      this.emit('window:loaded')\r\n      this.resolveLoadedPromise()\r\n    })\r\n\r\n    this.browserWindow.on('window:locations-opened', () => {\r\n      this.emit('window:locations-opened')\r\n    })\r\n\r\n    this.browserWindow.on('enter-full-screen', () => {\r\n      this.browserWindow.webContents.send('did-enter-full-screen')\r\n    })\r\n\r\n    this.browserWindow.on('leave-full-screen', () => {\r\n      this.browserWindow.webContents.send('did-leave-full-screen')\r\n    })\r\n\r\n    this.browserWindow.loadURL(\r\n      url.format({\r\n        protocol: 'file',\r\n        pathname: `${this.resourcePath}/static/index.html`,\r\n        slashes: true\r\n      })\r\n    )\r\n\r\n    this.browserWindow.showSaveDialog = this.showSaveDialog.bind(this)\r\n\r\n    if (this.isSpec) this.browserWindow.focusOnWebView()\r\n\r\n    const hasPathToOpen = !(locationsToOpen.length === 1 && locationsToOpen[0].pathToOpen == null)\r\n    if (hasPathToOpen && !this.isSpecWindow()) this.openLocations(locationsToOpen)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"AtomWindow.shouldHideTitleBar","start_line":322,"end_line":328,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"handleEvents","line":66,"func_location":"AtomWindow.constructor","func_start_line":14,"func_end_line":138,"args":[],"code":"  constructor (atomApplication, fileRecoveryService, settings = {}) {\r\n    super()\r\n\r\n    this.id = nextId++\r\n    this.atomApplication = atomApplication\r\n    this.fileRecoveryService = fileRecoveryService\r\n    this.isSpec = settings.isSpec\r\n    this.headless = settings.headless\r\n    this.safeMode = settings.safeMode\r\n    this.devMode = settings.devMode\r\n    this.resourcePath = settings.resourcePath\r\n\r\n    let {pathToOpen, locationsToOpen} = settings\r\n    if (!locationsToOpen && pathToOpen) locationsToOpen = [{pathToOpen}]\r\n    if (!locationsToOpen) locationsToOpen = []\r\n\r\n    this.loadedPromise = new Promise(resolve => { this.resolveLoadedPromise = resolve })\r\n    this.closedPromise = new Promise(resolve => { this.resolveClosedPromise = resolve })\r\n\r\n    const options = {\r\n      show: false,\r\n      title: 'Atom',\r\n      tabbingIdentifier: 'atom',\r\n      webPreferences: {\r\n        // Prevent specs from throttling when the window is in the background:\r\n        // this should result in faster CI builds, and an improvement in the\r\n        // local development experience when running specs through the UI (which\r\n        // now won't pause when e.g. minimizing the window).\r\n        backgroundThrottling: !this.isSpec,\r\n        // Disable the `auxclick` feature so that `click` events are triggered in\r\n        // response to a middle-click.\r\n        // (Ref: https://github.com/atom/atom/pull/12696#issuecomment-290496960)\r\n        disableBlinkFeatures: 'Auxclick'\r\n      }\r\n    }\r\n\r\n    // Don't set icon on Windows so the exe's ico will be used as window and\r\n    // taskbar's icon. See https://github.com/atom/atom/issues/4811 for more.\r\n    if (process.platform === 'linux') options.icon = ICON_PATH\r\n    if (this.shouldAddCustomTitleBar()) options.titleBarStyle = 'hidden'\r\n    if (this.shouldAddCustomInsetTitleBar()) options.titleBarStyle = 'hiddenInset'\r\n    if (this.shouldHideTitleBar()) options.frame = false\r\n    this.browserWindow = new BrowserWindow(options)\r\n\r\n    Object.defineProperty(this.browserWindow, 'loadSettingsJSON', {\r\n      get: () => JSON.stringify(Object.assign({\r\n        userSettings: !this.isSpec\r\n          ? this.atomApplication.configFile.get()\r\n          : null\r\n      }, this.loadSettings))\r\n    })\r\n\r\n    this.handleEvents()\r\n\r\n    this.loadSettings = Object.assign({}, settings)\r\n    this.loadSettings.appVersion = app.getVersion()\r\n    this.loadSettings.resourcePath = this.resourcePath\r\n    this.loadSettings.atomHome = process.env.ATOM_HOME\r\n    if (this.loadSettings.devMode == null) this.loadSettings.devMode = false\r\n    if (this.loadSettings.safeMode == null) this.loadSettings.safeMode = false\r\n    if (this.loadSettings.clearWindowState == null) this.loadSettings.clearWindowState = false\r\n\r\n    if (!this.loadSettings.initialPaths) {\r\n      this.loadSettings.initialPaths = []\r\n      for (const {pathToOpen, stat} of locationsToOpen) {\r\n        if (!pathToOpen) continue\r\n        if (stat && stat.isDirectory()) {\r\n          this.loadSettings.initialPaths.push(pathToOpen)\r\n        } else {\r\n          const parentDirectory = path.dirname(pathToOpen)\r\n          if (stat && stat.isFile() || fs.existsSync(parentDirectory)) {\r\n            this.loadSettings.initialPaths.push(parentDirectory)\r\n          } else {\r\n            this.loadSettings.initialPaths.push(pathToOpen)\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    this.loadSettings.initialPaths.sort()\r\n\r\n    // Only send to the first non-spec window created\r\n    if (includeShellLoadTime && !this.isSpec) {\r\n      includeShellLoadTime = false\r\n      if (!this.loadSettings.shellLoadTime) {\r\n        this.loadSettings.shellLoadTime = Date.now() - global.shellStartTime\r\n      }\r\n    }\r\n\r\n    this.representedDirectoryPaths = this.loadSettings.initialPaths\r\n    if (!this.loadSettings.env) this.env = this.loadSettings.env\r\n\r\n    this.browserWindow.on('window:loaded', () => {\r\n      this.disableZoom()\r\n      this.emit('window:loaded')\r\n      this.resolveLoadedPromise()\r\n    })\r\n\r\n    this.browserWindow.on('window:locations-opened', () => {\r\n      this.emit('window:locations-opened')\r\n    })\r\n\r\n    this.browserWindow.on('enter-full-screen', () => {\r\n      this.browserWindow.webContents.send('did-enter-full-screen')\r\n    })\r\n\r\n    this.browserWindow.on('leave-full-screen', () => {\r\n      this.browserWindow.webContents.send('did-leave-full-screen')\r\n    })\r\n\r\n    this.browserWindow.loadURL(\r\n      url.format({\r\n        protocol: 'file',\r\n        pathname: `${this.resourcePath}/static/index.html`,\r\n        slashes: true\r\n      })\r\n    )\r\n\r\n    this.browserWindow.showSaveDialog = this.showSaveDialog.bind(this)\r\n\r\n    if (this.isSpec) this.browserWindow.focusOnWebView()\r\n\r\n    const hasPathToOpen = !(locationsToOpen.length === 1 && locationsToOpen[0].pathToOpen == null)\r\n    if (hasPathToOpen && !this.isSpecWindow()) this.openLocations(locationsToOpen)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"AtomWindow.handleEvents","start_line":167,"end_line":225,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"isSpecWindow","line":137,"func_location":"AtomWindow.constructor","func_start_line":14,"func_end_line":138,"args":[],"code":"  constructor (atomApplication, fileRecoveryService, settings = {}) {\r\n    super()\r\n\r\n    this.id = nextId++\r\n    this.atomApplication = atomApplication\r\n    this.fileRecoveryService = fileRecoveryService\r\n    this.isSpec = settings.isSpec\r\n    this.headless = settings.headless\r\n    this.safeMode = settings.safeMode\r\n    this.devMode = settings.devMode\r\n    this.resourcePath = settings.resourcePath\r\n\r\n    let {pathToOpen, locationsToOpen} = settings\r\n    if (!locationsToOpen && pathToOpen) locationsToOpen = [{pathToOpen}]\r\n    if (!locationsToOpen) locationsToOpen = []\r\n\r\n    this.loadedPromise = new Promise(resolve => { this.resolveLoadedPromise = resolve })\r\n    this.closedPromise = new Promise(resolve => { this.resolveClosedPromise = resolve })\r\n\r\n    const options = {\r\n      show: false,\r\n      title: 'Atom',\r\n      tabbingIdentifier: 'atom',\r\n      webPreferences: {\r\n        // Prevent specs from throttling when the window is in the background:\r\n        // this should result in faster CI builds, and an improvement in the\r\n        // local development experience when running specs through the UI (which\r\n        // now won't pause when e.g. minimizing the window).\r\n        backgroundThrottling: !this.isSpec,\r\n        // Disable the `auxclick` feature so that `click` events are triggered in\r\n        // response to a middle-click.\r\n        // (Ref: https://github.com/atom/atom/pull/12696#issuecomment-290496960)\r\n        disableBlinkFeatures: 'Auxclick'\r\n      }\r\n    }\r\n\r\n    // Don't set icon on Windows so the exe's ico will be used as window and\r\n    // taskbar's icon. See https://github.com/atom/atom/issues/4811 for more.\r\n    if (process.platform === 'linux') options.icon = ICON_PATH\r\n    if (this.shouldAddCustomTitleBar()) options.titleBarStyle = 'hidden'\r\n    if (this.shouldAddCustomInsetTitleBar()) options.titleBarStyle = 'hiddenInset'\r\n    if (this.shouldHideTitleBar()) options.frame = false\r\n    this.browserWindow = new BrowserWindow(options)\r\n\r\n    Object.defineProperty(this.browserWindow, 'loadSettingsJSON', {\r\n      get: () => JSON.stringify(Object.assign({\r\n        userSettings: !this.isSpec\r\n          ? this.atomApplication.configFile.get()\r\n          : null\r\n      }, this.loadSettings))\r\n    })\r\n\r\n    this.handleEvents()\r\n\r\n    this.loadSettings = Object.assign({}, settings)\r\n    this.loadSettings.appVersion = app.getVersion()\r\n    this.loadSettings.resourcePath = this.resourcePath\r\n    this.loadSettings.atomHome = process.env.ATOM_HOME\r\n    if (this.loadSettings.devMode == null) this.loadSettings.devMode = false\r\n    if (this.loadSettings.safeMode == null) this.loadSettings.safeMode = false\r\n    if (this.loadSettings.clearWindowState == null) this.loadSettings.clearWindowState = false\r\n\r\n    if (!this.loadSettings.initialPaths) {\r\n      this.loadSettings.initialPaths = []\r\n      for (const {pathToOpen, stat} of locationsToOpen) {\r\n        if (!pathToOpen) continue\r\n        if (stat && stat.isDirectory()) {\r\n          this.loadSettings.initialPaths.push(pathToOpen)\r\n        } else {\r\n          const parentDirectory = path.dirname(pathToOpen)\r\n          if (stat && stat.isFile() || fs.existsSync(parentDirectory)) {\r\n            this.loadSettings.initialPaths.push(parentDirectory)\r\n          } else {\r\n            this.loadSettings.initialPaths.push(pathToOpen)\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    this.loadSettings.initialPaths.sort()\r\n\r\n    // Only send to the first non-spec window created\r\n    if (includeShellLoadTime && !this.isSpec) {\r\n      includeShellLoadTime = false\r\n      if (!this.loadSettings.shellLoadTime) {\r\n        this.loadSettings.shellLoadTime = Date.now() - global.shellStartTime\r\n      }\r\n    }\r\n\r\n    this.representedDirectoryPaths = this.loadSettings.initialPaths\r\n    if (!this.loadSettings.env) this.env = this.loadSettings.env\r\n\r\n    this.browserWindow.on('window:loaded', () => {\r\n      this.disableZoom()\r\n      this.emit('window:loaded')\r\n      this.resolveLoadedPromise()\r\n    })\r\n\r\n    this.browserWindow.on('window:locations-opened', () => {\r\n      this.emit('window:locations-opened')\r\n    })\r\n\r\n    this.browserWindow.on('enter-full-screen', () => {\r\n      this.browserWindow.webContents.send('did-enter-full-screen')\r\n    })\r\n\r\n    this.browserWindow.on('leave-full-screen', () => {\r\n      this.browserWindow.webContents.send('did-leave-full-screen')\r\n    })\r\n\r\n    this.browserWindow.loadURL(\r\n      url.format({\r\n        protocol: 'file',\r\n        pathname: `${this.resourcePath}/static/index.html`,\r\n        slashes: true\r\n      })\r\n    )\r\n\r\n    this.browserWindow.showSaveDialog = this.showSaveDialog.bind(this)\r\n\r\n    if (this.isSpec) this.browserWindow.focusOnWebView()\r\n\r\n    const hasPathToOpen = !(locationsToOpen.length === 1 && locationsToOpen[0].pathToOpen == null)\r\n    if (hasPathToOpen && !this.isSpecWindow()) this.openLocations(locationsToOpen)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"AtomWindow.isSpecWindow","start_line":382,"end_line":384,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"openLocations","line":137,"func_location":"AtomWindow.constructor","func_start_line":14,"func_end_line":138,"args":[],"code":"  constructor (atomApplication, fileRecoveryService, settings = {}) {\r\n    super()\r\n\r\n    this.id = nextId++\r\n    this.atomApplication = atomApplication\r\n    this.fileRecoveryService = fileRecoveryService\r\n    this.isSpec = settings.isSpec\r\n    this.headless = settings.headless\r\n    this.safeMode = settings.safeMode\r\n    this.devMode = settings.devMode\r\n    this.resourcePath = settings.resourcePath\r\n\r\n    let {pathToOpen, locationsToOpen} = settings\r\n    if (!locationsToOpen && pathToOpen) locationsToOpen = [{pathToOpen}]\r\n    if (!locationsToOpen) locationsToOpen = []\r\n\r\n    this.loadedPromise = new Promise(resolve => { this.resolveLoadedPromise = resolve })\r\n    this.closedPromise = new Promise(resolve => { this.resolveClosedPromise = resolve })\r\n\r\n    const options = {\r\n      show: false,\r\n      title: 'Atom',\r\n      tabbingIdentifier: 'atom',\r\n      webPreferences: {\r\n        // Prevent specs from throttling when the window is in the background:\r\n        // this should result in faster CI builds, and an improvement in the\r\n        // local development experience when running specs through the UI (which\r\n        // now won't pause when e.g. minimizing the window).\r\n        backgroundThrottling: !this.isSpec,\r\n        // Disable the `auxclick` feature so that `click` events are triggered in\r\n        // response to a middle-click.\r\n        // (Ref: https://github.com/atom/atom/pull/12696#issuecomment-290496960)\r\n        disableBlinkFeatures: 'Auxclick'\r\n      }\r\n    }\r\n\r\n    // Don't set icon on Windows so the exe's ico will be used as window and\r\n    // taskbar's icon. See https://github.com/atom/atom/issues/4811 for more.\r\n    if (process.platform === 'linux') options.icon = ICON_PATH\r\n    if (this.shouldAddCustomTitleBar()) options.titleBarStyle = 'hidden'\r\n    if (this.shouldAddCustomInsetTitleBar()) options.titleBarStyle = 'hiddenInset'\r\n    if (this.shouldHideTitleBar()) options.frame = false\r\n    this.browserWindow = new BrowserWindow(options)\r\n\r\n    Object.defineProperty(this.browserWindow, 'loadSettingsJSON', {\r\n      get: () => JSON.stringify(Object.assign({\r\n        userSettings: !this.isSpec\r\n          ? this.atomApplication.configFile.get()\r\n          : null\r\n      }, this.loadSettings))\r\n    })\r\n\r\n    this.handleEvents()\r\n\r\n    this.loadSettings = Object.assign({}, settings)\r\n    this.loadSettings.appVersion = app.getVersion()\r\n    this.loadSettings.resourcePath = this.resourcePath\r\n    this.loadSettings.atomHome = process.env.ATOM_HOME\r\n    if (this.loadSettings.devMode == null) this.loadSettings.devMode = false\r\n    if (this.loadSettings.safeMode == null) this.loadSettings.safeMode = false\r\n    if (this.loadSettings.clearWindowState == null) this.loadSettings.clearWindowState = false\r\n\r\n    if (!this.loadSettings.initialPaths) {\r\n      this.loadSettings.initialPaths = []\r\n      for (const {pathToOpen, stat} of locationsToOpen) {\r\n        if (!pathToOpen) continue\r\n        if (stat && stat.isDirectory()) {\r\n          this.loadSettings.initialPaths.push(pathToOpen)\r\n        } else {\r\n          const parentDirectory = path.dirname(pathToOpen)\r\n          if (stat && stat.isFile() || fs.existsSync(parentDirectory)) {\r\n            this.loadSettings.initialPaths.push(parentDirectory)\r\n          } else {\r\n            this.loadSettings.initialPaths.push(pathToOpen)\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    this.loadSettings.initialPaths.sort()\r\n\r\n    // Only send to the first non-spec window created\r\n    if (includeShellLoadTime && !this.isSpec) {\r\n      includeShellLoadTime = false\r\n      if (!this.loadSettings.shellLoadTime) {\r\n        this.loadSettings.shellLoadTime = Date.now() - global.shellStartTime\r\n      }\r\n    }\r\n\r\n    this.representedDirectoryPaths = this.loadSettings.initialPaths\r\n    if (!this.loadSettings.env) this.env = this.loadSettings.env\r\n\r\n    this.browserWindow.on('window:loaded', () => {\r\n      this.disableZoom()\r\n      this.emit('window:loaded')\r\n      this.resolveLoadedPromise()\r\n    })\r\n\r\n    this.browserWindow.on('window:locations-opened', () => {\r\n      this.emit('window:locations-opened')\r\n    })\r\n\r\n    this.browserWindow.on('enter-full-screen', () => {\r\n      this.browserWindow.webContents.send('did-enter-full-screen')\r\n    })\r\n\r\n    this.browserWindow.on('leave-full-screen', () => {\r\n      this.browserWindow.webContents.send('did-leave-full-screen')\r\n    })\r\n\r\n    this.browserWindow.loadURL(\r\n      url.format({\r\n        protocol: 'file',\r\n        pathname: `${this.resourcePath}/static/index.html`,\r\n        slashes: true\r\n      })\r\n    )\r\n\r\n    this.browserWindow.showSaveDialog = this.showSaveDialog.bind(this)\r\n\r\n    if (this.isSpec) this.browserWindow.focusOnWebView()\r\n\r\n    const hasPathToOpen = !(locationsToOpen.length === 1 && locationsToOpen[0].pathToOpen == null)\r\n    if (hasPathToOpen && !this.isSpecWindow()) this.openLocations(locationsToOpen)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"AtomWindow.openLocations","start_line":252,"end_line":255,"comment":[],"params":["locationsToOpen"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/clipboard.js","name":"reset","line":18,"func_location":"Clipboard.constructor","func_start_line":17,"func_end_line":19,"args":[],"code":"  constructor () {\r\n    this.reset()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/clipboard.js","name":"Clipboard.reset","start_line":21,"end_line":24,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"retokenizeLines","line":37,"func_location":"TextMateLanguageMode.constructor","func_start_line":18,"func_end_line":38,"args":[],"code":"  constructor (params) {\r\n    this.emitter = new Emitter()\r\n    this.disposables = new CompositeDisposable()\r\n    this.tokenIterator = new TokenIterator(this)\r\n    this.regexesByPattern = {}\r\n\r\n    this.alive = true\r\n    this.tokenizationStarted = false\r\n    this.id = params.id != null ? params.id : nextId++\r\n    this.buffer = params.buffer\r\n    this.largeFileMode = params.largeFileMode\r\n    this.config = params.config\r\n    this.largeFileMode = params.largeFileMode != null\r\n      ? params.largeFileMode\r\n      : this.buffer.buffer.getLength() >= 2 * 1024 * 1024\r\n\r\n    this.grammar = params.grammar || NullGrammar\r\n    this.rootScopeDescriptor = new ScopeDescriptor({scopes: [this.grammar.scopeName]})\r\n    this.disposables.add(this.grammar.onDidUpdate(() => this.retokenizeLines()))\r\n    this.retokenizeLines()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.retokenizeLines","start_line":253,"end_line":263,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js","name":"isDismissable","line":14,"func_location":"Notification.constructor","func_start_line":7,"func_end_line":17,"args":[],"code":"  constructor (type, message, options = {}) {\r\n    this.type = type\r\n    this.message = message\r\n    this.options = options\r\n    this.emitter = new Emitter()\r\n    this.timestamp = new Date()\r\n    this.dismissed = true\r\n    if (this.isDismissable()) this.dismissed = false\r\n    this.displayed = false\r\n    this.validate()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js","name":"Notification.isDismissable","start_line":95,"end_line":97,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js","name":"validate","line":16,"func_location":"Notification.constructor","func_start_line":7,"func_end_line":17,"args":[],"code":"  constructor (type, message, options = {}) {\r\n    this.type = type\r\n    this.message = message\r\n    this.options = options\r\n    this.emitter = new Emitter()\r\n    this.timestamp = new Date()\r\n    this.dismissed = true\r\n    if (this.isDismissable()) this.dismissed = false\r\n    this.displayed = false\r\n    this.validate()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js","name":"Notification.validate","start_line":19,"end_line":27,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"setRoot","line":21,"func_location":"PaneContainer.constructor","func_start_line":12,"func_end_line":23,"args":[null],"code":"  constructor (params) {\r\n    let applicationDelegate, deserializerManager, notificationManager;\r\n    ({config: this.config, applicationDelegate, notificationManager, deserializerManager, viewRegistry: this.viewRegistry, location: this.location} = params)\r\n    this.emitter = new Emitter()\r\n    this.subscriptions = new CompositeDisposable()\r\n    this.itemRegistry = new ItemRegistry()\r\n    this.alive = true\r\n    this.stoppedChangingActivePaneItemTimeout = null\r\n\r\n    this.setRoot(new Pane({container: this, config: this.config, applicationDelegate, notificationManager, deserializerManager, viewRegistry: this.viewRegistry}))\r\n    this.didActivatePane(this.getRoot())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.setRoot","start_line":131,"end_line":139,"comment":[],"params":["root"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"didActivatePane","line":22,"func_location":"PaneContainer.constructor","func_start_line":12,"func_end_line":23,"args":[null],"code":"  constructor (params) {\r\n    let applicationDelegate, deserializerManager, notificationManager;\r\n    ({config: this.config, applicationDelegate, notificationManager, deserializerManager, viewRegistry: this.viewRegistry, location: this.location} = params)\r\n    this.emitter = new Emitter()\r\n    this.subscriptions = new CompositeDisposable()\r\n    this.itemRegistry = new ItemRegistry()\r\n    this.alive = true\r\n    this.stoppedChangingActivePaneItemTimeout = null\r\n\r\n    this.setRoot(new Pane({container: this, config: this.config, applicationDelegate, notificationManager, deserializerManager, viewRegistry: this.viewRegistry}))\r\n    this.didActivatePane(this.getRoot())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.didActivatePane","start_line":251,"end_line":263,"comment":[],"params":["activePane"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"getRoot","line":22,"func_location":"PaneContainer.constructor","func_start_line":12,"func_end_line":23,"args":[null],"code":"  constructor (params) {\r\n    let applicationDelegate, deserializerManager, notificationManager;\r\n    ({config: this.config, applicationDelegate, notificationManager, deserializerManager, viewRegistry: this.viewRegistry, location: this.location} = params)\r\n    this.emitter = new Emitter()\r\n    this.subscriptions = new CompositeDisposable()\r\n    this.itemRegistry = new ItemRegistry()\r\n    this.alive = true\r\n    this.stoppedChangingActivePaneItemTimeout = null\r\n\r\n    this.setRoot(new Pane({container: this, config: this.config, applicationDelegate, notificationManager, deserializerManager, viewRegistry: this.viewRegistry}))\r\n    this.didActivatePane(this.getRoot())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.getRoot","start_line":129,"end_line":129,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/context-menu.js","name":"createClickHandlers","line":7,"func_location":"ContextMenu.constructor","func_start_line":5,"func_end_line":10,"args":["template"],"code":"  constructor (template, atomWindow) {\r\n    this.atomWindow = atomWindow\r\n    this.createClickHandlers(template)\r\n    const menu = Menu.buildFromTemplate(template)\r\n    menu.popup(this.atomWindow.browserWindow, {async: true})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/context-menu.js","name":"ContextMenu.createClickHandlers","start_line":15,"end_line":32,"comment":[" It's necessary to build the event handlers in this process, otherwise"," closures are dragged across processes and failed to be garbage collected"," appropriately."],"params":["template"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"start","line":60,"func_location":"BufferedProcess.constructor","func_start_line":51,"func_end_line":63,"args":[],"comment":["\r\n  Section: Construction\r\n  "," Public: Runs the given command by spawning a new child process.",""," * `options` An {Object} with the following keys:","   * `command` The {String} command to execute.","   * `args` The {Array} of arguments to pass to the command (optional).","   * `options` {Object} (optional) The options {Object} to pass to Node's","     `ChildProcess.spawn` method.","   * `stdout` {Function} (optional) The callback that receives a single","     argument which contains the standard output from the command. The","     callback is called as data is received but it's buffered to ensure only","     complete lines are passed until the source stream closes. After the","     source stream has closed all remaining data is sent in a final call.","     * `data` {String}","   * `stderr` {Function} (optional) The callback that receives a single","     argument which contains the standard error output from the command. The","     callback is called as data is received but it's buffered to ensure only","     complete lines are passed until the source stream closes. After the","     source stream has closed all remaining data is sent in a final call.","     * `data` {String}","   * `exit` {Function} (optional) The callback which receives a single","     argument containing the exit status.","     * `code` {Number}","   * `autoStart` {Boolean} (optional) Whether the command will automatically start","     when this BufferedProcess is created. Defaults to true.  When set to false you","     must call the `start` method to start the process."],"code":"  constructor ({command, args, options = {}, stdout, stderr, exit, autoStart = true} = {}) {\r\n    this.emitter = new Emitter()\r\n    this.command = command\r\n    this.args = args\r\n    this.options = options\r\n    this.stdout = stdout\r\n    this.stderr = stderr\r\n    this.exit = exit\r\n    if (autoStart === true) {\r\n      this.start()\r\n    }\r\n    this.killed = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"BufferedProcess.start","start_line":65,"end_line":76,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"consumeServices","line":207,"func_location":"Workspace.constructor","func_start_line":176,"func_end_line":231,"args":[".packageManager"],"code":"  constructor (params) {\r\n    super(...arguments)\r\n\r\n    this.updateWindowTitle = this.updateWindowTitle.bind(this)\r\n    this.updateDocumentEdited = this.updateDocumentEdited.bind(this)\r\n    this.didDestroyPaneItem = this.didDestroyPaneItem.bind(this)\r\n    this.didChangeActivePaneOnPaneContainer = this.didChangeActivePaneOnPaneContainer.bind(this)\r\n    this.didChangeActivePaneItemOnPaneContainer = this.didChangeActivePaneItemOnPaneContainer.bind(this)\r\n    this.didActivatePaneContainer = this.didActivatePaneContainer.bind(this)\r\n\r\n    this.enablePersistence = params.enablePersistence\r\n    this.packageManager = params.packageManager\r\n    this.config = params.config\r\n    this.project = params.project\r\n    this.notificationManager = params.notificationManager\r\n    this.viewRegistry = params.viewRegistry\r\n    this.grammarRegistry = params.grammarRegistry\r\n    this.applicationDelegate = params.applicationDelegate\r\n    this.assert = params.assert\r\n    this.deserializerManager = params.deserializerManager\r\n    this.textEditorRegistry = params.textEditorRegistry\r\n    this.styleManager = params.styleManager\r\n    this.draggingItem = false\r\n    this.itemLocationStore = new StateStore('AtomPreviousItemLocations', 1)\r\n\r\n    this.emitter = new Emitter()\r\n    this.openers = []\r\n    this.destroyedItemURIs = []\r\n    this.stoppedChangingActivePaneItemTimeout = null\r\n\r\n    this.defaultDirectorySearcher = new DefaultDirectorySearcher()\r\n    this.consumeServices(this.packageManager)\r\n\r\n    this.paneContainers = {\r\n      center: this.createCenter(),\r\n      left: this.createDock('left'),\r\n      right: this.createDock('right'),\r\n      bottom: this.createDock('bottom')\r\n    }\r\n    this.activePaneContainer = this.paneContainers.center\r\n    this.hasActiveTextEditor = false\r\n\r\n    this.panelContainers = {\r\n      top: new PanelContainer({viewRegistry: this.viewRegistry, location: 'top'}),\r\n      left: new PanelContainer({viewRegistry: this.viewRegistry, location: 'left', dock: this.paneContainers.left}),\r\n      right: new PanelContainer({viewRegistry: this.viewRegistry, location: 'right', dock: this.paneContainers.right}),\r\n      bottom: new PanelContainer({viewRegistry: this.viewRegistry, location: 'bottom', dock: this.paneContainers.bottom}),\r\n      header: new PanelContainer({viewRegistry: this.viewRegistry, location: 'header'}),\r\n      footer: new PanelContainer({viewRegistry: this.viewRegistry, location: 'footer'}),\r\n      modal: new PanelContainer({viewRegistry: this.viewRegistry, location: 'modal'})\r\n    }\r\n\r\n    this.incoming = new Map()\r\n\r\n    this.subscribeToEvents()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.consumeServices","start_line":328,"end_line":335,"comment":[],"params":[["serviceHub"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"createCenter","line":210,"func_location":"Workspace.constructor","func_start_line":176,"func_end_line":231,"args":[],"code":"  constructor (params) {\r\n    super(...arguments)\r\n\r\n    this.updateWindowTitle = this.updateWindowTitle.bind(this)\r\n    this.updateDocumentEdited = this.updateDocumentEdited.bind(this)\r\n    this.didDestroyPaneItem = this.didDestroyPaneItem.bind(this)\r\n    this.didChangeActivePaneOnPaneContainer = this.didChangeActivePaneOnPaneContainer.bind(this)\r\n    this.didChangeActivePaneItemOnPaneContainer = this.didChangeActivePaneItemOnPaneContainer.bind(this)\r\n    this.didActivatePaneContainer = this.didActivatePaneContainer.bind(this)\r\n\r\n    this.enablePersistence = params.enablePersistence\r\n    this.packageManager = params.packageManager\r\n    this.config = params.config\r\n    this.project = params.project\r\n    this.notificationManager = params.notificationManager\r\n    this.viewRegistry = params.viewRegistry\r\n    this.grammarRegistry = params.grammarRegistry\r\n    this.applicationDelegate = params.applicationDelegate\r\n    this.assert = params.assert\r\n    this.deserializerManager = params.deserializerManager\r\n    this.textEditorRegistry = params.textEditorRegistry\r\n    this.styleManager = params.styleManager\r\n    this.draggingItem = false\r\n    this.itemLocationStore = new StateStore('AtomPreviousItemLocations', 1)\r\n\r\n    this.emitter = new Emitter()\r\n    this.openers = []\r\n    this.destroyedItemURIs = []\r\n    this.stoppedChangingActivePaneItemTimeout = null\r\n\r\n    this.defaultDirectorySearcher = new DefaultDirectorySearcher()\r\n    this.consumeServices(this.packageManager)\r\n\r\n    this.paneContainers = {\r\n      center: this.createCenter(),\r\n      left: this.createDock('left'),\r\n      right: this.createDock('right'),\r\n      bottom: this.createDock('bottom')\r\n    }\r\n    this.activePaneContainer = this.paneContainers.center\r\n    this.hasActiveTextEditor = false\r\n\r\n    this.panelContainers = {\r\n      top: new PanelContainer({viewRegistry: this.viewRegistry, location: 'top'}),\r\n      left: new PanelContainer({viewRegistry: this.viewRegistry, location: 'left', dock: this.paneContainers.left}),\r\n      right: new PanelContainer({viewRegistry: this.viewRegistry, location: 'right', dock: this.paneContainers.right}),\r\n      bottom: new PanelContainer({viewRegistry: this.viewRegistry, location: 'bottom', dock: this.paneContainers.bottom}),\r\n      header: new PanelContainer({viewRegistry: this.viewRegistry, location: 'header'}),\r\n      footer: new PanelContainer({viewRegistry: this.viewRegistry, location: 'footer'}),\r\n      modal: new PanelContainer({viewRegistry: this.viewRegistry, location: 'modal'})\r\n    }\r\n\r\n    this.incoming = new Map()\r\n\r\n    this.subscribeToEvents()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.createCenter","start_line":250,"end_line":262,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"createDock","line":211,"func_location":"Workspace.constructor","func_start_line":176,"func_end_line":231,"args":[{"type":"string"}],"code":"  constructor (params) {\r\n    super(...arguments)\r\n\r\n    this.updateWindowTitle = this.updateWindowTitle.bind(this)\r\n    this.updateDocumentEdited = this.updateDocumentEdited.bind(this)\r\n    this.didDestroyPaneItem = this.didDestroyPaneItem.bind(this)\r\n    this.didChangeActivePaneOnPaneContainer = this.didChangeActivePaneOnPaneContainer.bind(this)\r\n    this.didChangeActivePaneItemOnPaneContainer = this.didChangeActivePaneItemOnPaneContainer.bind(this)\r\n    this.didActivatePaneContainer = this.didActivatePaneContainer.bind(this)\r\n\r\n    this.enablePersistence = params.enablePersistence\r\n    this.packageManager = params.packageManager\r\n    this.config = params.config\r\n    this.project = params.project\r\n    this.notificationManager = params.notificationManager\r\n    this.viewRegistry = params.viewRegistry\r\n    this.grammarRegistry = params.grammarRegistry\r\n    this.applicationDelegate = params.applicationDelegate\r\n    this.assert = params.assert\r\n    this.deserializerManager = params.deserializerManager\r\n    this.textEditorRegistry = params.textEditorRegistry\r\n    this.styleManager = params.styleManager\r\n    this.draggingItem = false\r\n    this.itemLocationStore = new StateStore('AtomPreviousItemLocations', 1)\r\n\r\n    this.emitter = new Emitter()\r\n    this.openers = []\r\n    this.destroyedItemURIs = []\r\n    this.stoppedChangingActivePaneItemTimeout = null\r\n\r\n    this.defaultDirectorySearcher = new DefaultDirectorySearcher()\r\n    this.consumeServices(this.packageManager)\r\n\r\n    this.paneContainers = {\r\n      center: this.createCenter(),\r\n      left: this.createDock('left'),\r\n      right: this.createDock('right'),\r\n      bottom: this.createDock('bottom')\r\n    }\r\n    this.activePaneContainer = this.paneContainers.center\r\n    this.hasActiveTextEditor = false\r\n\r\n    this.panelContainers = {\r\n      top: new PanelContainer({viewRegistry: this.viewRegistry, location: 'top'}),\r\n      left: new PanelContainer({viewRegistry: this.viewRegistry, location: 'left', dock: this.paneContainers.left}),\r\n      right: new PanelContainer({viewRegistry: this.viewRegistry, location: 'right', dock: this.paneContainers.right}),\r\n      bottom: new PanelContainer({viewRegistry: this.viewRegistry, location: 'bottom', dock: this.paneContainers.bottom}),\r\n      header: new PanelContainer({viewRegistry: this.viewRegistry, location: 'header'}),\r\n      footer: new PanelContainer({viewRegistry: this.viewRegistry, location: 'footer'}),\r\n      modal: new PanelContainer({viewRegistry: this.viewRegistry, location: 'modal'})\r\n    }\r\n\r\n    this.incoming = new Map()\r\n\r\n    this.subscribeToEvents()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.createDock","start_line":264,"end_line":277,"comment":[],"params":["location"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"createDock","line":212,"func_location":"Workspace.constructor","func_start_line":176,"func_end_line":231,"args":[{"type":"string"}],"code":"  constructor (params) {\r\n    super(...arguments)\r\n\r\n    this.updateWindowTitle = this.updateWindowTitle.bind(this)\r\n    this.updateDocumentEdited = this.updateDocumentEdited.bind(this)\r\n    this.didDestroyPaneItem = this.didDestroyPaneItem.bind(this)\r\n    this.didChangeActivePaneOnPaneContainer = this.didChangeActivePaneOnPaneContainer.bind(this)\r\n    this.didChangeActivePaneItemOnPaneContainer = this.didChangeActivePaneItemOnPaneContainer.bind(this)\r\n    this.didActivatePaneContainer = this.didActivatePaneContainer.bind(this)\r\n\r\n    this.enablePersistence = params.enablePersistence\r\n    this.packageManager = params.packageManager\r\n    this.config = params.config\r\n    this.project = params.project\r\n    this.notificationManager = params.notificationManager\r\n    this.viewRegistry = params.viewRegistry\r\n    this.grammarRegistry = params.grammarRegistry\r\n    this.applicationDelegate = params.applicationDelegate\r\n    this.assert = params.assert\r\n    this.deserializerManager = params.deserializerManager\r\n    this.textEditorRegistry = params.textEditorRegistry\r\n    this.styleManager = params.styleManager\r\n    this.draggingItem = false\r\n    this.itemLocationStore = new StateStore('AtomPreviousItemLocations', 1)\r\n\r\n    this.emitter = new Emitter()\r\n    this.openers = []\r\n    this.destroyedItemURIs = []\r\n    this.stoppedChangingActivePaneItemTimeout = null\r\n\r\n    this.defaultDirectorySearcher = new DefaultDirectorySearcher()\r\n    this.consumeServices(this.packageManager)\r\n\r\n    this.paneContainers = {\r\n      center: this.createCenter(),\r\n      left: this.createDock('left'),\r\n      right: this.createDock('right'),\r\n      bottom: this.createDock('bottom')\r\n    }\r\n    this.activePaneContainer = this.paneContainers.center\r\n    this.hasActiveTextEditor = false\r\n\r\n    this.panelContainers = {\r\n      top: new PanelContainer({viewRegistry: this.viewRegistry, location: 'top'}),\r\n      left: new PanelContainer({viewRegistry: this.viewRegistry, location: 'left', dock: this.paneContainers.left}),\r\n      right: new PanelContainer({viewRegistry: this.viewRegistry, location: 'right', dock: this.paneContainers.right}),\r\n      bottom: new PanelContainer({viewRegistry: this.viewRegistry, location: 'bottom', dock: this.paneContainers.bottom}),\r\n      header: new PanelContainer({viewRegistry: this.viewRegistry, location: 'header'}),\r\n      footer: new PanelContainer({viewRegistry: this.viewRegistry, location: 'footer'}),\r\n      modal: new PanelContainer({viewRegistry: this.viewRegistry, location: 'modal'})\r\n    }\r\n\r\n    this.incoming = new Map()\r\n\r\n    this.subscribeToEvents()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.createDock","start_line":264,"end_line":277,"comment":[],"params":["location"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"createDock","line":213,"func_location":"Workspace.constructor","func_start_line":176,"func_end_line":231,"args":[{"type":"string"}],"code":"  constructor (params) {\r\n    super(...arguments)\r\n\r\n    this.updateWindowTitle = this.updateWindowTitle.bind(this)\r\n    this.updateDocumentEdited = this.updateDocumentEdited.bind(this)\r\n    this.didDestroyPaneItem = this.didDestroyPaneItem.bind(this)\r\n    this.didChangeActivePaneOnPaneContainer = this.didChangeActivePaneOnPaneContainer.bind(this)\r\n    this.didChangeActivePaneItemOnPaneContainer = this.didChangeActivePaneItemOnPaneContainer.bind(this)\r\n    this.didActivatePaneContainer = this.didActivatePaneContainer.bind(this)\r\n\r\n    this.enablePersistence = params.enablePersistence\r\n    this.packageManager = params.packageManager\r\n    this.config = params.config\r\n    this.project = params.project\r\n    this.notificationManager = params.notificationManager\r\n    this.viewRegistry = params.viewRegistry\r\n    this.grammarRegistry = params.grammarRegistry\r\n    this.applicationDelegate = params.applicationDelegate\r\n    this.assert = params.assert\r\n    this.deserializerManager = params.deserializerManager\r\n    this.textEditorRegistry = params.textEditorRegistry\r\n    this.styleManager = params.styleManager\r\n    this.draggingItem = false\r\n    this.itemLocationStore = new StateStore('AtomPreviousItemLocations', 1)\r\n\r\n    this.emitter = new Emitter()\r\n    this.openers = []\r\n    this.destroyedItemURIs = []\r\n    this.stoppedChangingActivePaneItemTimeout = null\r\n\r\n    this.defaultDirectorySearcher = new DefaultDirectorySearcher()\r\n    this.consumeServices(this.packageManager)\r\n\r\n    this.paneContainers = {\r\n      center: this.createCenter(),\r\n      left: this.createDock('left'),\r\n      right: this.createDock('right'),\r\n      bottom: this.createDock('bottom')\r\n    }\r\n    this.activePaneContainer = this.paneContainers.center\r\n    this.hasActiveTextEditor = false\r\n\r\n    this.panelContainers = {\r\n      top: new PanelContainer({viewRegistry: this.viewRegistry, location: 'top'}),\r\n      left: new PanelContainer({viewRegistry: this.viewRegistry, location: 'left', dock: this.paneContainers.left}),\r\n      right: new PanelContainer({viewRegistry: this.viewRegistry, location: 'right', dock: this.paneContainers.right}),\r\n      bottom: new PanelContainer({viewRegistry: this.viewRegistry, location: 'bottom', dock: this.paneContainers.bottom}),\r\n      header: new PanelContainer({viewRegistry: this.viewRegistry, location: 'header'}),\r\n      footer: new PanelContainer({viewRegistry: this.viewRegistry, location: 'footer'}),\r\n      modal: new PanelContainer({viewRegistry: this.viewRegistry, location: 'modal'})\r\n    }\r\n\r\n    this.incoming = new Map()\r\n\r\n    this.subscribeToEvents()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.createDock","start_line":264,"end_line":277,"comment":[],"params":["location"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"subscribeToEvents","line":230,"func_location":"Workspace.constructor","func_start_line":176,"func_end_line":231,"args":[],"code":"  constructor (params) {\r\n    super(...arguments)\r\n\r\n    this.updateWindowTitle = this.updateWindowTitle.bind(this)\r\n    this.updateDocumentEdited = this.updateDocumentEdited.bind(this)\r\n    this.didDestroyPaneItem = this.didDestroyPaneItem.bind(this)\r\n    this.didChangeActivePaneOnPaneContainer = this.didChangeActivePaneOnPaneContainer.bind(this)\r\n    this.didChangeActivePaneItemOnPaneContainer = this.didChangeActivePaneItemOnPaneContainer.bind(this)\r\n    this.didActivatePaneContainer = this.didActivatePaneContainer.bind(this)\r\n\r\n    this.enablePersistence = params.enablePersistence\r\n    this.packageManager = params.packageManager\r\n    this.config = params.config\r\n    this.project = params.project\r\n    this.notificationManager = params.notificationManager\r\n    this.viewRegistry = params.viewRegistry\r\n    this.grammarRegistry = params.grammarRegistry\r\n    this.applicationDelegate = params.applicationDelegate\r\n    this.assert = params.assert\r\n    this.deserializerManager = params.deserializerManager\r\n    this.textEditorRegistry = params.textEditorRegistry\r\n    this.styleManager = params.styleManager\r\n    this.draggingItem = false\r\n    this.itemLocationStore = new StateStore('AtomPreviousItemLocations', 1)\r\n\r\n    this.emitter = new Emitter()\r\n    this.openers = []\r\n    this.destroyedItemURIs = []\r\n    this.stoppedChangingActivePaneItemTimeout = null\r\n\r\n    this.defaultDirectorySearcher = new DefaultDirectorySearcher()\r\n    this.consumeServices(this.packageManager)\r\n\r\n    this.paneContainers = {\r\n      center: this.createCenter(),\r\n      left: this.createDock('left'),\r\n      right: this.createDock('right'),\r\n      bottom: this.createDock('bottom')\r\n    }\r\n    this.activePaneContainer = this.paneContainers.center\r\n    this.hasActiveTextEditor = false\r\n\r\n    this.panelContainers = {\r\n      top: new PanelContainer({viewRegistry: this.viewRegistry, location: 'top'}),\r\n      left: new PanelContainer({viewRegistry: this.viewRegistry, location: 'left', dock: this.paneContainers.left}),\r\n      right: new PanelContainer({viewRegistry: this.viewRegistry, location: 'right', dock: this.paneContainers.right}),\r\n      bottom: new PanelContainer({viewRegistry: this.viewRegistry, location: 'bottom', dock: this.paneContainers.bottom}),\r\n      header: new PanelContainer({viewRegistry: this.viewRegistry, location: 'header'}),\r\n      footer: new PanelContainer({viewRegistry: this.viewRegistry, location: 'footer'}),\r\n      modal: new PanelContainer({viewRegistry: this.viewRegistry, location: 'modal'})\r\n    }\r\n\r\n    this.incoming = new Map()\r\n\r\n    this.subscribeToEvents()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.subscribeToEvents","start_line":320,"end_line":326,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"consumeServices","line":41,"func_location":"Project.constructor","func_start_line":22,"func_end_line":42,"args":["packageManager"],"comment":["\r\n  Section: Construction and Destruction\r\n  "],"code":"  constructor ({notificationManager, packageManager, config, applicationDelegate, grammarRegistry}) {\r\n    super()\r\n    this.notificationManager = notificationManager\r\n    this.applicationDelegate = applicationDelegate\r\n    this.grammarRegistry = grammarRegistry\r\n\r\n    this.emitter = new Emitter()\r\n    this.buffers = []\r\n    this.rootDirectories = []\r\n    this.repositories = []\r\n    this.directoryProviders = []\r\n    this.defaultDirectoryProvider = new DefaultDirectoryProvider()\r\n    this.repositoryPromisesByPath = new Map()\r\n    this.repositoryProviders = [new GitRepositoryProvider(this, config)]\r\n    this.loadPromisesByPath = {}\r\n    this.watcherPromisesByPath = {}\r\n    this.retiredBufferIDs = new Set()\r\n    this.retiredBufferPaths = new Set()\r\n    this.subscriptions = new CompositeDisposable()\r\n    this.consumeServices(packageManager)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.consumeServices","start_line":594,"end_line":615,"comment":["\r\n  Section: Private\r\n  "],"params":[["serviceHub"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"_patchSyntaxNode","line":28,"func_location":"TreeSitterLanguageMode.constructor","func_start_line":27,"func_end_line":56,"args":[],"code":"  constructor ({buffer, grammar, config, grammars, syncOperationLimit}) {\r\n    TreeSitterLanguageMode._patchSyntaxNode()\r\n    this.id = nextId++\r\n    this.buffer = buffer\r\n    this.grammar = grammar\r\n    this.config = config\r\n    this.grammarRegistry = grammars\r\n    this.parser = new Parser()\r\n    this.rootLanguageLayer = new LanguageLayer(this, grammar)\r\n    this.injectionsMarkerLayer = buffer.addMarkerLayer()\r\n\r\n    if (syncOperationLimit != null) {\r\n      this.syncOperationLimit = syncOperationLimit\r\n    }\r\n\r\n    this.rootScopeDescriptor = new ScopeDescriptor({scopes: [this.grammar.scopeName]})\r\n    this.emitter = new Emitter()\r\n    this.isFoldableCache = []\r\n    this.hasQueuedParse = false\r\n\r\n    this.grammarForLanguageString = this.grammarForLanguageString.bind(this)\r\n\r\n    this.rootLanguageLayer.update(null).then(() =>\r\n      this.emitter.emit('did-tokenize')\r\n    )\r\n\r\n    // TODO: Remove this once TreeSitterLanguageMode implements its own auto-indentation system. This\r\n    // is temporarily needed in order to delegate to the TextMateLanguageMode's auto-indent system.\r\n    this.regexesByPattern = {}\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"TreeSitterLanguageMode._patchSyntaxNode","start_line":17,"end_line":25,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"constructor","line":35,"func_location":"TreeSitterLanguageMode.constructor","func_start_line":27,"func_end_line":56},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"LanguageLayer.constructor","start_line":545,"end_line":552,"comment":[],"params":["languageMode","grammar","contentChildTypes"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-protocol-handler.js","name":"registerAtomProtocol","line":29,"func_location":"AtomProtocolHandler.constructor","func_start_line":18,"func_end_line":30,"args":[],"code":"  constructor (resourcePath, safeMode) {\r\n    this.loadPaths = []\r\n\r\n    if (!safeMode) {\r\n      this.loadPaths.push(path.join(process.env.ATOM_HOME, 'dev', 'packages'))\r\n      this.loadPaths.push(path.join(resourcePath, 'packages'))\r\n    }\r\n\r\n    this.loadPaths.push(path.join(process.env.ATOM_HOME, 'packages'))\r\n    this.loadPaths.push(path.join(resourcePath, 'node_modules'))\r\n\r\n    this.registerAtomProtocol()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-protocol-handler.js","name":"AtomProtocolHandler.registerAtomProtocol","start_line":33,"end_line":54,"comment":[" Creates the 'atom' custom protocol handler."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"registerDefaultCommands","line":186,"func_location":"AtomEnvironment.constructor","func_start_line":57,"func_end_line":199,"args":[],"comment":["\r\n  Section: Properties\r\n  "],"code":"  constructor (params = {}) {\r\n    this.id = (params.id != null) ? params.id : nextId++\r\n\r\n    // Public: A {Clipboard} instance\r\n    this.clipboard = params.clipboard\r\n    this.updateProcessEnv = params.updateProcessEnv || updateProcessEnv\r\n    this.enablePersistence = params.enablePersistence\r\n    this.applicationDelegate = params.applicationDelegate\r\n\r\n    this.nextProxyRequestId = 0\r\n    this.unloading = false\r\n    this.loadTime = null\r\n    this.emitter = new Emitter()\r\n    this.disposables = new CompositeDisposable()\r\n    this.pathsWithWaitSessions = new Set()\r\n\r\n    // Public: A {DeserializerManager} instance\r\n    this.deserializers = new DeserializerManager(this)\r\n    this.deserializeTimings = {}\r\n\r\n    // Public: A {ViewRegistry} instance\r\n    this.views = new ViewRegistry(this)\r\n\r\n    // Public: A {NotificationManager} instance\r\n    this.notifications = new NotificationManager()\r\n\r\n    this.stateStore = new StateStore('AtomEnvironments', 1)\r\n\r\n    // Public: A {Config} instance\r\n    this.config = new Config({\r\n      saveCallback: settings => {\r\n        if (this.enablePersistence) {\r\n          this.applicationDelegate.setUserSettings(settings, this.config.getUserConfigPath())\r\n        }\r\n      }\r\n    })\r\n    this.config.setSchema(null, {type: 'object', properties: _.clone(ConfigSchema)})\r\n\r\n    // Public: A {KeymapManager} instance\r\n    this.keymaps = new KeymapManager({notificationManager: this.notifications})\r\n\r\n    // Public: A {TooltipManager} instance\r\n    this.tooltips = new TooltipManager({keymapManager: this.keymaps, viewRegistry: this.views})\r\n\r\n    // Public: A {CommandRegistry} instance\r\n    this.commands = new CommandRegistry()\r\n    this.uriHandlerRegistry = new URIHandlerRegistry()\r\n\r\n    // Public: A {GrammarRegistry} instance\r\n    this.grammars = new GrammarRegistry({config: this.config})\r\n\r\n    // Public: A {StyleManager} instance\r\n    this.styles = new StyleManager()\r\n\r\n    // Public: A {PackageManager} instance\r\n    this.packages = new PackageManager({\r\n      config: this.config,\r\n      styleManager: this.styles,\r\n      commandRegistry: this.commands,\r\n      keymapManager: this.keymaps,\r\n      notificationManager: this.notifications,\r\n      grammarRegistry: this.grammars,\r\n      deserializerManager: this.deserializers,\r\n      viewRegistry: this.views,\r\n      uriHandlerRegistry: this.uriHandlerRegistry\r\n    })\r\n\r\n    // Public: A {ThemeManager} instance\r\n    this.themes = new ThemeManager({\r\n      packageManager: this.packages,\r\n      config: this.config,\r\n      styleManager: this.styles,\r\n      notificationManager: this.notifications,\r\n      viewRegistry: this.views\r\n    })\r\n\r\n    // Public: A {MenuManager} instance\r\n    this.menu = new MenuManager({keymapManager: this.keymaps, packageManager: this.packages})\r\n\r\n    // Public: A {ContextMenuManager} instance\r\n    this.contextMenu = new ContextMenuManager({keymapManager: this.keymaps})\r\n\r\n    this.packages.setMenuManager(this.menu)\r\n    this.packages.setContextMenuManager(this.contextMenu)\r\n    this.packages.setThemeManager(this.themes)\r\n\r\n    // Public: A {Project} instance\r\n    this.project = new Project({\r\n      notificationManager: this.notifications,\r\n      packageManager: this.packages,\r\n      grammarRegistry: this.grammars,\r\n      config: this.config,\r\n      applicationDelegate: this.applicationDelegate\r\n    })\r\n    this.commandInstaller = new CommandInstaller(this.applicationDelegate)\r\n    this.protocolHandlerInstaller = new ProtocolHandlerInstaller()\r\n\r\n    // Public: A {TextEditorRegistry} instance\r\n    this.textEditors = new TextEditorRegistry({\r\n      config: this.config,\r\n      grammarRegistry: this.grammars,\r\n      assert: this.assert.bind(this),\r\n      packageManager: this.packages\r\n    })\r\n\r\n    // Public: A {Workspace} instance\r\n    this.workspace = new Workspace({\r\n      config: this.config,\r\n      project: this.project,\r\n      packageManager: this.packages,\r\n      grammarRegistry: this.grammars,\r\n      deserializerManager: this.deserializers,\r\n      notificationManager: this.notifications,\r\n      applicationDelegate: this.applicationDelegate,\r\n      viewRegistry: this.views,\r\n      assert: this.assert.bind(this),\r\n      textEditorRegistry: this.textEditors,\r\n      styleManager: this.styles,\r\n      enablePersistence: this.enablePersistence\r\n    })\r\n\r\n    this.themes.workspace = this.workspace\r\n\r\n    this.autoUpdater = new AutoUpdateManager({applicationDelegate: this.applicationDelegate})\r\n\r\n    if (this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.registerDefaultCommands()\r\n    this.registerDefaultOpeners()\r\n    this.registerDefaultDeserializers()\r\n\r\n    this.windowEventHandler = new WindowEventHandler({atomEnvironment: this, applicationDelegate: this.applicationDelegate})\r\n\r\n    // Public: A {HistoryManager} instance\r\n    this.history = new HistoryManager({project: this.project, commands: this.commands, stateStore: this.stateStore})\r\n\r\n    // Keep instances of HistoryManager in sync\r\n    this.disposables.add(this.history.onDidChangeProjects(event => {\r\n      if (!event.reloaded) this.applicationDelegate.didChangeHistoryManager()\r\n    }))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.registerDefaultCommands","start_line":305,"end_line":307,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"registerDefaultOpeners","line":187,"func_location":"AtomEnvironment.constructor","func_start_line":57,"func_end_line":199,"args":[],"comment":["\r\n  Section: Properties\r\n  "],"code":"  constructor (params = {}) {\r\n    this.id = (params.id != null) ? params.id : nextId++\r\n\r\n    // Public: A {Clipboard} instance\r\n    this.clipboard = params.clipboard\r\n    this.updateProcessEnv = params.updateProcessEnv || updateProcessEnv\r\n    this.enablePersistence = params.enablePersistence\r\n    this.applicationDelegate = params.applicationDelegate\r\n\r\n    this.nextProxyRequestId = 0\r\n    this.unloading = false\r\n    this.loadTime = null\r\n    this.emitter = new Emitter()\r\n    this.disposables = new CompositeDisposable()\r\n    this.pathsWithWaitSessions = new Set()\r\n\r\n    // Public: A {DeserializerManager} instance\r\n    this.deserializers = new DeserializerManager(this)\r\n    this.deserializeTimings = {}\r\n\r\n    // Public: A {ViewRegistry} instance\r\n    this.views = new ViewRegistry(this)\r\n\r\n    // Public: A {NotificationManager} instance\r\n    this.notifications = new NotificationManager()\r\n\r\n    this.stateStore = new StateStore('AtomEnvironments', 1)\r\n\r\n    // Public: A {Config} instance\r\n    this.config = new Config({\r\n      saveCallback: settings => {\r\n        if (this.enablePersistence) {\r\n          this.applicationDelegate.setUserSettings(settings, this.config.getUserConfigPath())\r\n        }\r\n      }\r\n    })\r\n    this.config.setSchema(null, {type: 'object', properties: _.clone(ConfigSchema)})\r\n\r\n    // Public: A {KeymapManager} instance\r\n    this.keymaps = new KeymapManager({notificationManager: this.notifications})\r\n\r\n    // Public: A {TooltipManager} instance\r\n    this.tooltips = new TooltipManager({keymapManager: this.keymaps, viewRegistry: this.views})\r\n\r\n    // Public: A {CommandRegistry} instance\r\n    this.commands = new CommandRegistry()\r\n    this.uriHandlerRegistry = new URIHandlerRegistry()\r\n\r\n    // Public: A {GrammarRegistry} instance\r\n    this.grammars = new GrammarRegistry({config: this.config})\r\n\r\n    // Public: A {StyleManager} instance\r\n    this.styles = new StyleManager()\r\n\r\n    // Public: A {PackageManager} instance\r\n    this.packages = new PackageManager({\r\n      config: this.config,\r\n      styleManager: this.styles,\r\n      commandRegistry: this.commands,\r\n      keymapManager: this.keymaps,\r\n      notificationManager: this.notifications,\r\n      grammarRegistry: this.grammars,\r\n      deserializerManager: this.deserializers,\r\n      viewRegistry: this.views,\r\n      uriHandlerRegistry: this.uriHandlerRegistry\r\n    })\r\n\r\n    // Public: A {ThemeManager} instance\r\n    this.themes = new ThemeManager({\r\n      packageManager: this.packages,\r\n      config: this.config,\r\n      styleManager: this.styles,\r\n      notificationManager: this.notifications,\r\n      viewRegistry: this.views\r\n    })\r\n\r\n    // Public: A {MenuManager} instance\r\n    this.menu = new MenuManager({keymapManager: this.keymaps, packageManager: this.packages})\r\n\r\n    // Public: A {ContextMenuManager} instance\r\n    this.contextMenu = new ContextMenuManager({keymapManager: this.keymaps})\r\n\r\n    this.packages.setMenuManager(this.menu)\r\n    this.packages.setContextMenuManager(this.contextMenu)\r\n    this.packages.setThemeManager(this.themes)\r\n\r\n    // Public: A {Project} instance\r\n    this.project = new Project({\r\n      notificationManager: this.notifications,\r\n      packageManager: this.packages,\r\n      grammarRegistry: this.grammars,\r\n      config: this.config,\r\n      applicationDelegate: this.applicationDelegate\r\n    })\r\n    this.commandInstaller = new CommandInstaller(this.applicationDelegate)\r\n    this.protocolHandlerInstaller = new ProtocolHandlerInstaller()\r\n\r\n    // Public: A {TextEditorRegistry} instance\r\n    this.textEditors = new TextEditorRegistry({\r\n      config: this.config,\r\n      grammarRegistry: this.grammars,\r\n      assert: this.assert.bind(this),\r\n      packageManager: this.packages\r\n    })\r\n\r\n    // Public: A {Workspace} instance\r\n    this.workspace = new Workspace({\r\n      config: this.config,\r\n      project: this.project,\r\n      packageManager: this.packages,\r\n      grammarRegistry: this.grammars,\r\n      deserializerManager: this.deserializers,\r\n      notificationManager: this.notifications,\r\n      applicationDelegate: this.applicationDelegate,\r\n      viewRegistry: this.views,\r\n      assert: this.assert.bind(this),\r\n      textEditorRegistry: this.textEditors,\r\n      styleManager: this.styles,\r\n      enablePersistence: this.enablePersistence\r\n    })\r\n\r\n    this.themes.workspace = this.workspace\r\n\r\n    this.autoUpdater = new AutoUpdateManager({applicationDelegate: this.applicationDelegate})\r\n\r\n    if (this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.registerDefaultCommands()\r\n    this.registerDefaultOpeners()\r\n    this.registerDefaultDeserializers()\r\n\r\n    this.windowEventHandler = new WindowEventHandler({atomEnvironment: this, applicationDelegate: this.applicationDelegate})\r\n\r\n    // Public: A {HistoryManager} instance\r\n    this.history = new HistoryManager({project: this.project, commands: this.commands, stateStore: this.stateStore})\r\n\r\n    // Keep instances of HistoryManager in sync\r\n    this.disposables.add(this.history.onDidChangeProjects(event => {\r\n      if (!event.reloaded) this.applicationDelegate.didChangeHistoryManager()\r\n    }))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.registerDefaultOpeners","start_line":309,"end_line":322,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"registerDefaultDeserializers","line":188,"func_location":"AtomEnvironment.constructor","func_start_line":57,"func_end_line":199,"args":[],"comment":["\r\n  Section: Properties\r\n  "],"code":"  constructor (params = {}) {\r\n    this.id = (params.id != null) ? params.id : nextId++\r\n\r\n    // Public: A {Clipboard} instance\r\n    this.clipboard = params.clipboard\r\n    this.updateProcessEnv = params.updateProcessEnv || updateProcessEnv\r\n    this.enablePersistence = params.enablePersistence\r\n    this.applicationDelegate = params.applicationDelegate\r\n\r\n    this.nextProxyRequestId = 0\r\n    this.unloading = false\r\n    this.loadTime = null\r\n    this.emitter = new Emitter()\r\n    this.disposables = new CompositeDisposable()\r\n    this.pathsWithWaitSessions = new Set()\r\n\r\n    // Public: A {DeserializerManager} instance\r\n    this.deserializers = new DeserializerManager(this)\r\n    this.deserializeTimings = {}\r\n\r\n    // Public: A {ViewRegistry} instance\r\n    this.views = new ViewRegistry(this)\r\n\r\n    // Public: A {NotificationManager} instance\r\n    this.notifications = new NotificationManager()\r\n\r\n    this.stateStore = new StateStore('AtomEnvironments', 1)\r\n\r\n    // Public: A {Config} instance\r\n    this.config = new Config({\r\n      saveCallback: settings => {\r\n        if (this.enablePersistence) {\r\n          this.applicationDelegate.setUserSettings(settings, this.config.getUserConfigPath())\r\n        }\r\n      }\r\n    })\r\n    this.config.setSchema(null, {type: 'object', properties: _.clone(ConfigSchema)})\r\n\r\n    // Public: A {KeymapManager} instance\r\n    this.keymaps = new KeymapManager({notificationManager: this.notifications})\r\n\r\n    // Public: A {TooltipManager} instance\r\n    this.tooltips = new TooltipManager({keymapManager: this.keymaps, viewRegistry: this.views})\r\n\r\n    // Public: A {CommandRegistry} instance\r\n    this.commands = new CommandRegistry()\r\n    this.uriHandlerRegistry = new URIHandlerRegistry()\r\n\r\n    // Public: A {GrammarRegistry} instance\r\n    this.grammars = new GrammarRegistry({config: this.config})\r\n\r\n    // Public: A {StyleManager} instance\r\n    this.styles = new StyleManager()\r\n\r\n    // Public: A {PackageManager} instance\r\n    this.packages = new PackageManager({\r\n      config: this.config,\r\n      styleManager: this.styles,\r\n      commandRegistry: this.commands,\r\n      keymapManager: this.keymaps,\r\n      notificationManager: this.notifications,\r\n      grammarRegistry: this.grammars,\r\n      deserializerManager: this.deserializers,\r\n      viewRegistry: this.views,\r\n      uriHandlerRegistry: this.uriHandlerRegistry\r\n    })\r\n\r\n    // Public: A {ThemeManager} instance\r\n    this.themes = new ThemeManager({\r\n      packageManager: this.packages,\r\n      config: this.config,\r\n      styleManager: this.styles,\r\n      notificationManager: this.notifications,\r\n      viewRegistry: this.views\r\n    })\r\n\r\n    // Public: A {MenuManager} instance\r\n    this.menu = new MenuManager({keymapManager: this.keymaps, packageManager: this.packages})\r\n\r\n    // Public: A {ContextMenuManager} instance\r\n    this.contextMenu = new ContextMenuManager({keymapManager: this.keymaps})\r\n\r\n    this.packages.setMenuManager(this.menu)\r\n    this.packages.setContextMenuManager(this.contextMenu)\r\n    this.packages.setThemeManager(this.themes)\r\n\r\n    // Public: A {Project} instance\r\n    this.project = new Project({\r\n      notificationManager: this.notifications,\r\n      packageManager: this.packages,\r\n      grammarRegistry: this.grammars,\r\n      config: this.config,\r\n      applicationDelegate: this.applicationDelegate\r\n    })\r\n    this.commandInstaller = new CommandInstaller(this.applicationDelegate)\r\n    this.protocolHandlerInstaller = new ProtocolHandlerInstaller()\r\n\r\n    // Public: A {TextEditorRegistry} instance\r\n    this.textEditors = new TextEditorRegistry({\r\n      config: this.config,\r\n      grammarRegistry: this.grammars,\r\n      assert: this.assert.bind(this),\r\n      packageManager: this.packages\r\n    })\r\n\r\n    // Public: A {Workspace} instance\r\n    this.workspace = new Workspace({\r\n      config: this.config,\r\n      project: this.project,\r\n      packageManager: this.packages,\r\n      grammarRegistry: this.grammars,\r\n      deserializerManager: this.deserializers,\r\n      notificationManager: this.notifications,\r\n      applicationDelegate: this.applicationDelegate,\r\n      viewRegistry: this.views,\r\n      assert: this.assert.bind(this),\r\n      textEditorRegistry: this.textEditors,\r\n      styleManager: this.styles,\r\n      enablePersistence: this.enablePersistence\r\n    })\r\n\r\n    this.themes.workspace = this.workspace\r\n\r\n    this.autoUpdater = new AutoUpdateManager({applicationDelegate: this.applicationDelegate})\r\n\r\n    if (this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.registerDefaultCommands()\r\n    this.registerDefaultOpeners()\r\n    this.registerDefaultDeserializers()\r\n\r\n    this.windowEventHandler = new WindowEventHandler({atomEnvironment: this, applicationDelegate: this.applicationDelegate})\r\n\r\n    // Public: A {HistoryManager} instance\r\n    this.history = new HistoryManager({project: this.project, commands: this.commands, stateStore: this.stateStore})\r\n\r\n    // Keep instances of HistoryManager in sync\r\n    this.disposables.add(this.history.onDidChangeProjects(event => {\r\n      if (!event.reloaded) this.applicationDelegate.didChangeHistoryManager()\r\n    }))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.registerDefaultDeserializers","start_line":294,"end_line":303,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"reset","line":48,"func_location":"Package.constructor","func_start_line":20,"func_end_line":49,"args":[],"comment":["\r\n  Section: Construction\r\n  "],"code":"  constructor (params) {\r\n    this.config = params.config\r\n    this.packageManager = params.packageManager\r\n    this.styleManager = params.styleManager\r\n    this.commandRegistry = params.commandRegistry\r\n    this.keymapManager = params.keymapManager\r\n    this.notificationManager = params.notificationManager\r\n    this.grammarRegistry = params.grammarRegistry\r\n    this.themeManager = params.themeManager\r\n    this.menuManager = params.menuManager\r\n    this.contextMenuManager = params.contextMenuManager\r\n    this.deserializerManager = params.deserializerManager\r\n    this.viewRegistry = params.viewRegistry\r\n    this.emitter = new Emitter()\r\n\r\n    this.mainModule = null\r\n    this.path = params.path\r\n    this.preloadedPackage = params.preloadedPackage\r\n    this.metadata =\r\n      params.metadata ||\r\n      this.packageManager.loadPackageMetadata(this.path)\r\n    this.bundledPackage = params.bundledPackage != null\r\n      ? params.bundledPackage\r\n      : this.packageManager.isBundledPackagePath(this.path)\r\n    this.name =\r\n      (this.metadata && this.metadata.name) ||\r\n      params.name ||\r\n      path.basename(this.path)\r\n    this.reset()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.reset","start_line":160,"end_line":168,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"registerPackageActivator","line":57,"func_location":"PackageManager.constructor","func_start_line":31,"func_end_line":58,"args":[null,null],"code":"  constructor (params) {\r\n    ({\r\n      config: this.config, styleManager: this.styleManager, notificationManager: this.notificationManager, keymapManager: this.keymapManager,\r\n      commandRegistry: this.commandRegistry, grammarRegistry: this.grammarRegistry, deserializerManager: this.deserializerManager, viewRegistry: this.viewRegistry,\r\n      uriHandlerRegistry: this.uriHandlerRegistry\r\n    } = params)\r\n\r\n    this.emitter = new Emitter()\r\n    this.activationHookEmitter = new Emitter()\r\n    this.packageDirPaths = []\r\n    this.deferredActivationHooks = []\r\n    this.triggeredActivationHooks = new Set()\r\n    this.packagesCache = packageJSON._atomPackages != null ? packageJSON._atomPackages : {}\r\n    this.packageDependencies = packageJSON.packageDependencies != null ? packageJSON.packageDependencies : {}\r\n    this.deprecatedPackages = packageJSON._deprecatedPackages || {}\r\n    this.deprecatedPackageRanges = {}\r\n    this.initialPackagesLoaded = false\r\n    this.initialPackagesActivated = false\r\n    this.preloadedPackages = {}\r\n    this.loadedPackages = {}\r\n    this.activePackages = {}\r\n    this.activatingPackages = {}\r\n    this.packageStates = {}\r\n    this.serviceHub = new ServiceHub()\r\n\r\n    this.packageActivators = []\r\n    this.registerPackageActivator(this, ['atom', 'textmate'])\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.registerPackageActivator","start_line":675,"end_line":677,"comment":[" another type of package manager can handle other package types."," See ThemeManager"],"params":["activator","types"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"constructor","line":108,"func_location":"AtomApplication.constructor","func_start_line":91,"func_end_line":136},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"WindowStack.constructor","start_line":1390,"end_line":1397,"comment":[],"params":["windows"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"initializeAtomHome","line":110,"func_location":"AtomApplication.constructor","func_start_line":91,"func_end_line":136,"args":["process.env.ATOM_HOME"],"code":"  constructor (options) {\r\n    super()\r\n    this.quitting = false\r\n    this.getAllWindows = this.getAllWindows.bind(this)\r\n    this.getLastFocusedWindow = this.getLastFocusedWindow.bind(this)\r\n    this.resourcePath = options.resourcePath\r\n    this.devResourcePath = options.devResourcePath\r\n    this.version = options.version\r\n    this.devMode = options.devMode\r\n    this.safeMode = options.safeMode\r\n    this.socketPath = options.socketPath\r\n    this.logFile = options.logFile\r\n    this.userDataDir = options.userDataDir\r\n    this._killProcess = options.killProcess || process.kill.bind(process)\r\n    if (options.test || options.benchmark || options.benchmarkTest) this.socketPath = null\r\n\r\n    this.waitSessionsByWindow = new Map()\r\n    this.windowStack = new WindowStack()\r\n\r\n    this.initializeAtomHome(process.env.ATOM_HOME)\r\n\r\n    const configFilePath = fs.existsSync(path.join(process.env.ATOM_HOME, 'config.json'))\r\n      ? path.join(process.env.ATOM_HOME, 'config.json')\r\n      : path.join(process.env.ATOM_HOME, 'config.cson')\r\n\r\n    this.configFile = ConfigFile.at(configFilePath)\r\n    this.config = new Config({\r\n      saveCallback: settings => {\r\n        if (!this.quitting) {\r\n          return this.configFile.update(settings)\r\n        }\r\n      }\r\n    })\r\n    this.config.setSchema(null, {type: 'object', properties: _.clone(ConfigSchema)})\r\n\r\n    this.fileRecoveryService = new FileRecoveryService(path.join(process.env.ATOM_HOME, 'recovery'))\r\n    this.storageFolder = new StorageFolder(process.env.ATOM_HOME)\r\n    this.autoUpdateManager = new AutoUpdateManager(\r\n      this.version,\r\n      options.test || options.benchmark || options.benchmarkTest,\r\n      this.config\r\n    )\r\n\r\n    this.disposable = new CompositeDisposable()\r\n    this.handleEvents()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.initializeAtomHome","start_line":644,"end_line":649,"comment":[],"params":["configDirPath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"handleEvents","line":135,"func_location":"AtomApplication.constructor","func_start_line":91,"func_end_line":136,"args":[],"code":"  constructor (options) {\r\n    super()\r\n    this.quitting = false\r\n    this.getAllWindows = this.getAllWindows.bind(this)\r\n    this.getLastFocusedWindow = this.getLastFocusedWindow.bind(this)\r\n    this.resourcePath = options.resourcePath\r\n    this.devResourcePath = options.devResourcePath\r\n    this.version = options.version\r\n    this.devMode = options.devMode\r\n    this.safeMode = options.safeMode\r\n    this.socketPath = options.socketPath\r\n    this.logFile = options.logFile\r\n    this.userDataDir = options.userDataDir\r\n    this._killProcess = options.killProcess || process.kill.bind(process)\r\n    if (options.test || options.benchmark || options.benchmarkTest) this.socketPath = null\r\n\r\n    this.waitSessionsByWindow = new Map()\r\n    this.windowStack = new WindowStack()\r\n\r\n    this.initializeAtomHome(process.env.ATOM_HOME)\r\n\r\n    const configFilePath = fs.existsSync(path.join(process.env.ATOM_HOME, 'config.json'))\r\n      ? path.join(process.env.ATOM_HOME, 'config.json')\r\n      : path.join(process.env.ATOM_HOME, 'config.cson')\r\n\r\n    this.configFile = ConfigFile.at(configFilePath)\r\n    this.config = new Config({\r\n      saveCallback: settings => {\r\n        if (!this.quitting) {\r\n          return this.configFile.update(settings)\r\n        }\r\n      }\r\n    })\r\n    this.config.setSchema(null, {type: 'object', properties: _.clone(ConfigSchema)})\r\n\r\n    this.fileRecoveryService = new FileRecoveryService(path.join(process.env.ATOM_HOME, 'recovery'))\r\n    this.storageFolder = new StorageFolder(process.env.ATOM_HOME)\r\n    this.autoUpdateManager = new AutoUpdateManager(\r\n      this.version,\r\n      options.test || options.benchmark || options.benchmarkTest,\r\n      this.config\r\n    )\r\n\r\n    this.disposable = new CompositeDisposable()\r\n    this.handleEvents()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.handleEvents","start_line":364,"end_line":634,"comment":[" Registers basic application commands, non-idempotent."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js","name":"clear","line":43,"func_location":"TextEditorRegistry.constructor","func_start_line":40,"func_end_line":54,"args":[],"code":"  constructor ({config, assert, packageManager}) {\r\n    this.assert = assert\r\n    this.config = config\r\n    this.clear()\r\n\r\n    this.initialPackageActivationPromise = new Promise((resolve) => {\r\n      // TODO: Remove this usage of a private property of PackageManager.\r\n      // Should PackageManager just expose a promise-based API like this?\r\n      if (packageManager.deferredActivationHooks) {\r\n        packageManager.onDidActivateInitialPackages(resolve)\r\n      } else {\r\n        resolve()\r\n      }\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js","name":"TextEditorRegistry.clear","start_line":66,"end_line":79,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js","name":"addSelector","line":9,"func_location":"SyntaxScopeMap.constructor","func_start_line":5,"func_end_line":13,"args":["selector","resultsBySelector.selector"],"code":"  constructor (resultsBySelector) {\r\n    this.namedScopeTable = {}\r\n    this.anonymousScopeTable = {}\r\n    for (let selector in resultsBySelector) {\r\n      this.addSelector(selector, resultsBySelector[selector])\r\n    }\r\n    setTableDefaults(this.namedScopeTable, true)\r\n    setTableDefaults(this.anonymousScopeTable, false)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js","name":"SyntaxScopeMap.addSelector","start_line":15,"end_line":97,"comment":[],"params":["selector","result"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js","name":"setTableDefaults","line":11,"func_location":"SyntaxScopeMap.constructor","func_start_line":5,"func_end_line":13,"args":[".namedScopeTable",{"type":"boolean"}],"code":"  constructor (resultsBySelector) {\r\n    this.namedScopeTable = {}\r\n    this.anonymousScopeTable = {}\r\n    for (let selector in resultsBySelector) {\r\n      this.addSelector(selector, resultsBySelector[selector])\r\n    }\r\n    setTableDefaults(this.namedScopeTable, true)\r\n    setTableDefaults(this.anonymousScopeTable, false)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js","name":"setTableDefaults","start_line":129,"end_line":152,"comment":[],"params":["table","allowWildcardSelector"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js","name":"setTableDefaults","line":12,"func_location":"SyntaxScopeMap.constructor","func_start_line":5,"func_end_line":13,"args":[".anonymousScopeTable",{"type":"boolean"}],"code":"  constructor (resultsBySelector) {\r\n    this.namedScopeTable = {}\r\n    this.anonymousScopeTable = {}\r\n    for (let selector in resultsBySelector) {\r\n      this.addSelector(selector, resultsBySelector[selector])\r\n    }\r\n    setTableDefaults(this.namedScopeTable, true)\r\n    setTableDefaults(this.anonymousScopeTable, false)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js","name":"setTableDefaults","start_line":129,"end_line":152,"comment":[],"params":["table","allowWildcardSelector"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js","name":"addChild","line":25,"func_location":"PaneAxis.constructor","func_start_line":12,"func_end_line":28,"args":["child"],"code":"  constructor ({orientation, children, flexScale}, viewRegistry) {\r\n    super()\r\n    this.parent = null\r\n    this.container = null\r\n    this.orientation = orientation\r\n    this.viewRegistry = viewRegistry\r\n    this.emitter = new Emitter()\r\n    this.subscriptionsByChild = new WeakMap()\r\n    this.subscriptions = new CompositeDisposable()\r\n    this.flexScale = flexScale != null ? flexScale : 1\r\n    this.children = []\r\n    if (children) {\r\n      for (let child of children) {\r\n        this.addChild(child)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js","name":"PaneAxis.addChild","start_line":117,"end_line":123,"comment":[],"params":["child","index"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration.js","name":"setProperties","line":79,"func_location":"Decoration.constructor","func_start_line":74,"func_end_line":82,"args":["properties"],"comment":["\r\n  Section: Construction and Destruction\r\n  "],"code":"  constructor (marker, decorationManager, properties) {\r\n    this.marker = marker\r\n    this.decorationManager = decorationManager\r\n    this.emitter = new Emitter()\r\n    this.id = nextId()\r\n    this.setProperties(properties)\r\n    this.destroyed = false\r\n    this.markerDestroyDisposable = this.marker.onDidDestroy(() => this.destroy())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration.js","name":"Decoration.setProperties","start_line":164,"end_line":173,"comment":[" Essential: Update the marker with new Properties. Allows you to change the decoration's class.",""," ## Examples",""," ```coffee"," decoration.setProperties({type: 'line-number', class: 'my-new-class'})"," ```",""," * `newProperties` {Object} eg. `{type: 'line-number', class: 'my-new-class'}`"],"params":["newProperties"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"setActiveTemplate","line":15,"func_location":"ApplicationMenu.constructor","func_start_line":11,"func_end_line":17,"args":[null],"code":"  constructor (version, autoUpdateManager) {\r\n    this.version = version\r\n    this.autoUpdateManager = autoUpdateManager\r\n    this.windowTemplates = new WeakMap()\r\n    this.setActiveTemplate(this.getDefaultTemplate())\r\n    this.autoUpdateManager.on('state-changed', state => this.showUpdateMenuItem(state))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"ApplicationMenu.setActiveTemplate","start_line":32,"end_line":40,"comment":[],"params":["template"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"getDefaultTemplate","line":15,"func_location":"ApplicationMenu.constructor","func_start_line":11,"func_end_line":17,"args":[null],"code":"  constructor (version, autoUpdateManager) {\r\n    this.version = version\r\n    this.autoUpdateManager = autoUpdateManager\r\n    this.windowTemplates = new WeakMap()\r\n    this.setActiveTemplate(this.getDefaultTemplate())\r\n    this.autoUpdateManager.on('state-changed', state => this.showUpdateMenuItem(state))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"ApplicationMenu.getDefaultTemplate","start_line":145,"end_line":184,"comment":[" Default list of menu items.",""," Returns an Array of menu item Objects."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js","name":"handleNativeKeybindings","line":28,"func_location":"WindowEventHandler.constructor","func_start_line":7,"func_end_line":29,"args":[],"code":"  constructor ({atomEnvironment, applicationDelegate}) {\r\n    this.handleDocumentKeyEvent = this.handleDocumentKeyEvent.bind(this)\r\n    this.handleFocusNext = this.handleFocusNext.bind(this)\r\n    this.handleFocusPrevious = this.handleFocusPrevious.bind(this)\r\n    this.handleWindowBlur = this.handleWindowBlur.bind(this)\r\n    this.handleWindowResize = this.handleWindowResize.bind(this)\r\n    this.handleEnterFullScreen = this.handleEnterFullScreen.bind(this)\r\n    this.handleLeaveFullScreen = this.handleLeaveFullScreen.bind(this)\r\n    this.handleWindowBeforeunload = this.handleWindowBeforeunload.bind(this)\r\n    this.handleWindowToggleFullScreen = this.handleWindowToggleFullScreen.bind(this)\r\n    this.handleWindowClose = this.handleWindowClose.bind(this)\r\n    this.handleWindowReload = this.handleWindowReload.bind(this)\r\n    this.handleWindowToggleDevTools = this.handleWindowToggleDevTools.bind(this)\r\n    this.handleWindowToggleMenuBar = this.handleWindowToggleMenuBar.bind(this)\r\n    this.handleLinkClick = this.handleLinkClick.bind(this)\r\n    this.handleDocumentContextmenu = this.handleDocumentContextmenu.bind(this)\r\n    this.atomEnvironment = atomEnvironment\r\n    this.applicationDelegate = applicationDelegate\r\n    this.reloadRequested = false\r\n    this.subscriptions = new CompositeDisposable()\r\n\r\n    this.handleNativeKeybindings()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js","name":"WindowEventHandler.handleNativeKeybindings","start_line":71,"end_line":89,"comment":[" Wire commands that should be handled by Chromium for elements with the"," `.native-key-bindings` class."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"getWidthOrHeight","line":33,"func_location":"Dock.constructor","func_start_line":22,"func_end_line":72,"args":[".location"],"code":"  constructor (params) {\r\n    this.handleResizeHandleDragStart = this.handleResizeHandleDragStart.bind(this)\r\n    this.handleResizeToFit = this.handleResizeToFit.bind(this)\r\n    this.handleMouseMove = this.handleMouseMove.bind(this)\r\n    this.handleMouseUp = this.handleMouseUp.bind(this)\r\n    this.handleDrag = _.throttle(this.handleDrag.bind(this), 30)\r\n    this.handleDragEnd = this.handleDragEnd.bind(this)\r\n    this.handleToggleButtonDragEnter = this.handleToggleButtonDragEnter.bind(this)\r\n    this.toggle = this.toggle.bind(this)\r\n\r\n    this.location = params.location\r\n    this.widthOrHeight = getWidthOrHeight(this.location)\r\n    this.config = params.config\r\n    this.applicationDelegate = params.applicationDelegate\r\n    this.deserializerManager = params.deserializerManager\r\n    this.notificationManager = params.notificationManager\r\n    this.viewRegistry = params.viewRegistry\r\n    this.didActivate = params.didActivate\r\n\r\n    this.emitter = new Emitter()\r\n\r\n    this.paneContainer = new PaneContainer({\r\n      location: this.location,\r\n      config: this.config,\r\n      applicationDelegate: this.applicationDelegate,\r\n      deserializerManager: this.deserializerManager,\r\n      notificationManager: this.notificationManager,\r\n      viewRegistry: this.viewRegistry\r\n    })\r\n\r\n    this.state = {\r\n      size: null,\r\n      visible: false,\r\n      shouldAnimate: false\r\n    }\r\n\r\n    this.subscriptions = new CompositeDisposable(\r\n      this.emitter,\r\n      this.paneContainer.onDidActivatePane(() => {\r\n        this.show()\r\n        this.didActivate(this)\r\n      }),\r\n      this.paneContainer.observePanes(pane => {\r\n        pane.onDidAddItem(this.handleDidAddPaneItem.bind(this))\r\n        pane.onDidRemoveItem(this.handleDidRemovePaneItem.bind(this))\r\n      }),\r\n      this.paneContainer.onDidChangeActivePane((item) => params.didChangeActivePane(this, item)),\r\n      this.paneContainer.onDidChangeActivePaneItem((item) => params.didChangeActivePaneItem(this, item)),\r\n      this.paneContainer.onDidDestroyPaneItem((item) => params.didDestroyPaneItem(item))\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"getWidthOrHeight","start_line":821,"end_line":823,"comment":[],"params":["location"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js","name":"buildRegex","line":14,"func_location":"TreeSitterGrammar.constructor","func_start_line":7,"func_end_line":63,"args":[null],"code":"  constructor (registry, filePath, params) {\r\n    this.registry = registry\r\n    this.name = params.name\r\n    this.scopeName = params.scopeName\r\n\r\n    // TODO - Remove the `RegExp` spelling and only support `Regex`, once all of the existing\r\n    // Tree-sitter grammars are updated to spell it `Regex`.\r\n    this.contentRegex = buildRegex(params.contentRegex || params.contentRegExp)\r\n    this.injectionRegex = buildRegex(params.injectionRegex || params.injectionRegExp)\r\n    this.firstLineRegex = buildRegex(params.firstLineRegex)\r\n\r\n    this.folds = params.folds || []\r\n    this.folds.forEach(normalizeFoldSpecification)\r\n\r\n    this.commentStrings = {\r\n      commentStartString: params.comments && params.comments.start,\r\n      commentEndString: params.comments && params.comments.end\r\n    }\r\n\r\n    const scopeSelectors = {}\r\n    for (const key in params.scopes || {}) {\r\n      const classes = preprocessScopes(params.scopes[key])\r\n      const selectors = key.split(/,\\s+/)\r\n      for (let selector of selectors) {\r\n        selector = selector.trim()\r\n        if (!selector) continue\r\n        if (scopeSelectors[selector]) {\r\n          scopeSelectors[selector] = [].concat(scopeSelectors[selector], classes)\r\n        } else {\r\n          scopeSelectors[selector] = classes\r\n        }\r\n      }\r\n    }\r\n\r\n    this.scopeMap = new SyntaxScopeMap(scopeSelectors)\r\n    this.fileTypes = params.fileTypes || []\r\n    this.injectionPointsByType = {}\r\n\r\n    for (const injectionPoint of params.injectionPoints || []) {\r\n      this.addInjectionPoint(injectionPoint)\r\n    }\r\n\r\n    // TODO - When we upgrade to a new enough version of node, use `require.resolve`\r\n    // with the new `paths` option instead of this private API.\r\n    const languageModulePath = Module._resolveFilename(params.parser, {\r\n      id: filePath,\r\n      filename: filePath,\r\n      paths: Module._nodeModulePaths(path.dirname(filePath))\r\n    })\r\n\r\n    this.languageModule = require(languageModulePath)\r\n    this.classNamesById = new Map()\r\n    this.scopeNamesById = new Map()\r\n    this.idsByScope = Object.create(null)\r\n    this.nextScopeId = 256 + 1\r\n    this.registration = null\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js","name":"buildRegex","start_line":159,"end_line":165,"comment":[],"params":["value"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js","name":"buildRegex","line":15,"func_location":"TreeSitterGrammar.constructor","func_start_line":7,"func_end_line":63,"args":[null],"code":"  constructor (registry, filePath, params) {\r\n    this.registry = registry\r\n    this.name = params.name\r\n    this.scopeName = params.scopeName\r\n\r\n    // TODO - Remove the `RegExp` spelling and only support `Regex`, once all of the existing\r\n    // Tree-sitter grammars are updated to spell it `Regex`.\r\n    this.contentRegex = buildRegex(params.contentRegex || params.contentRegExp)\r\n    this.injectionRegex = buildRegex(params.injectionRegex || params.injectionRegExp)\r\n    this.firstLineRegex = buildRegex(params.firstLineRegex)\r\n\r\n    this.folds = params.folds || []\r\n    this.folds.forEach(normalizeFoldSpecification)\r\n\r\n    this.commentStrings = {\r\n      commentStartString: params.comments && params.comments.start,\r\n      commentEndString: params.comments && params.comments.end\r\n    }\r\n\r\n    const scopeSelectors = {}\r\n    for (const key in params.scopes || {}) {\r\n      const classes = preprocessScopes(params.scopes[key])\r\n      const selectors = key.split(/,\\s+/)\r\n      for (let selector of selectors) {\r\n        selector = selector.trim()\r\n        if (!selector) continue\r\n        if (scopeSelectors[selector]) {\r\n          scopeSelectors[selector] = [].concat(scopeSelectors[selector], classes)\r\n        } else {\r\n          scopeSelectors[selector] = classes\r\n        }\r\n      }\r\n    }\r\n\r\n    this.scopeMap = new SyntaxScopeMap(scopeSelectors)\r\n    this.fileTypes = params.fileTypes || []\r\n    this.injectionPointsByType = {}\r\n\r\n    for (const injectionPoint of params.injectionPoints || []) {\r\n      this.addInjectionPoint(injectionPoint)\r\n    }\r\n\r\n    // TODO - When we upgrade to a new enough version of node, use `require.resolve`\r\n    // with the new `paths` option instead of this private API.\r\n    const languageModulePath = Module._resolveFilename(params.parser, {\r\n      id: filePath,\r\n      filename: filePath,\r\n      paths: Module._nodeModulePaths(path.dirname(filePath))\r\n    })\r\n\r\n    this.languageModule = require(languageModulePath)\r\n    this.classNamesById = new Map()\r\n    this.scopeNamesById = new Map()\r\n    this.idsByScope = Object.create(null)\r\n    this.nextScopeId = 256 + 1\r\n    this.registration = null\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js","name":"buildRegex","start_line":159,"end_line":165,"comment":[],"params":["value"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js","name":"buildRegex","line":16,"func_location":"TreeSitterGrammar.constructor","func_start_line":7,"func_end_line":63,"args":["params.firstLineRegex"],"code":"  constructor (registry, filePath, params) {\r\n    this.registry = registry\r\n    this.name = params.name\r\n    this.scopeName = params.scopeName\r\n\r\n    // TODO - Remove the `RegExp` spelling and only support `Regex`, once all of the existing\r\n    // Tree-sitter grammars are updated to spell it `Regex`.\r\n    this.contentRegex = buildRegex(params.contentRegex || params.contentRegExp)\r\n    this.injectionRegex = buildRegex(params.injectionRegex || params.injectionRegExp)\r\n    this.firstLineRegex = buildRegex(params.firstLineRegex)\r\n\r\n    this.folds = params.folds || []\r\n    this.folds.forEach(normalizeFoldSpecification)\r\n\r\n    this.commentStrings = {\r\n      commentStartString: params.comments && params.comments.start,\r\n      commentEndString: params.comments && params.comments.end\r\n    }\r\n\r\n    const scopeSelectors = {}\r\n    for (const key in params.scopes || {}) {\r\n      const classes = preprocessScopes(params.scopes[key])\r\n      const selectors = key.split(/,\\s+/)\r\n      for (let selector of selectors) {\r\n        selector = selector.trim()\r\n        if (!selector) continue\r\n        if (scopeSelectors[selector]) {\r\n          scopeSelectors[selector] = [].concat(scopeSelectors[selector], classes)\r\n        } else {\r\n          scopeSelectors[selector] = classes\r\n        }\r\n      }\r\n    }\r\n\r\n    this.scopeMap = new SyntaxScopeMap(scopeSelectors)\r\n    this.fileTypes = params.fileTypes || []\r\n    this.injectionPointsByType = {}\r\n\r\n    for (const injectionPoint of params.injectionPoints || []) {\r\n      this.addInjectionPoint(injectionPoint)\r\n    }\r\n\r\n    // TODO - When we upgrade to a new enough version of node, use `require.resolve`\r\n    // with the new `paths` option instead of this private API.\r\n    const languageModulePath = Module._resolveFilename(params.parser, {\r\n      id: filePath,\r\n      filename: filePath,\r\n      paths: Module._nodeModulePaths(path.dirname(filePath))\r\n    })\r\n\r\n    this.languageModule = require(languageModulePath)\r\n    this.classNamesById = new Map()\r\n    this.scopeNamesById = new Map()\r\n    this.idsByScope = Object.create(null)\r\n    this.nextScopeId = 256 + 1\r\n    this.registration = null\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js","name":"buildRegex","start_line":159,"end_line":165,"comment":[],"params":["value"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js","name":"addInjectionPoint","line":46,"func_location":"TreeSitterGrammar.constructor","func_start_line":7,"func_end_line":63,"args":["injectionPoint"],"code":"  constructor (registry, filePath, params) {\r\n    this.registry = registry\r\n    this.name = params.name\r\n    this.scopeName = params.scopeName\r\n\r\n    // TODO - Remove the `RegExp` spelling and only support `Regex`, once all of the existing\r\n    // Tree-sitter grammars are updated to spell it `Regex`.\r\n    this.contentRegex = buildRegex(params.contentRegex || params.contentRegExp)\r\n    this.injectionRegex = buildRegex(params.injectionRegex || params.injectionRegExp)\r\n    this.firstLineRegex = buildRegex(params.firstLineRegex)\r\n\r\n    this.folds = params.folds || []\r\n    this.folds.forEach(normalizeFoldSpecification)\r\n\r\n    this.commentStrings = {\r\n      commentStartString: params.comments && params.comments.start,\r\n      commentEndString: params.comments && params.comments.end\r\n    }\r\n\r\n    const scopeSelectors = {}\r\n    for (const key in params.scopes || {}) {\r\n      const classes = preprocessScopes(params.scopes[key])\r\n      const selectors = key.split(/,\\s+/)\r\n      for (let selector of selectors) {\r\n        selector = selector.trim()\r\n        if (!selector) continue\r\n        if (scopeSelectors[selector]) {\r\n          scopeSelectors[selector] = [].concat(scopeSelectors[selector], classes)\r\n        } else {\r\n          scopeSelectors[selector] = classes\r\n        }\r\n      }\r\n    }\r\n\r\n    this.scopeMap = new SyntaxScopeMap(scopeSelectors)\r\n    this.fileTypes = params.fileTypes || []\r\n    this.injectionPointsByType = {}\r\n\r\n    for (const injectionPoint of params.injectionPoints || []) {\r\n      this.addInjectionPoint(injectionPoint)\r\n    }\r\n\r\n    // TODO - When we upgrade to a new enough version of node, use `require.resolve`\r\n    // with the new `paths` option instead of this private API.\r\n    const languageModulePath = Module._resolveFilename(params.parser, {\r\n      id: filePath,\r\n      filename: filePath,\r\n      paths: Module._nodeModulePaths(path.dirname(filePath))\r\n    })\r\n\r\n    this.languageModule = require(languageModulePath)\r\n    this.classNamesById = new Map()\r\n    this.scopeNamesById = new Map()\r\n    this.idsByScope = Object.create(null)\r\n    this.nextScopeId = 256 + 1\r\n    this.registration = null\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js","name":"TreeSitterGrammar.addInjectionPoint","start_line":97,"end_line":103,"comment":[],"params":["injectionPoint"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/file-system-blob-store.js","name":"reset","line":18,"func_location":"FileSystemBlobStore.constructor","func_start_line":14,"func_end_line":19,"args":[],"code":"  constructor (directory) {\r\n    this.blobFilename = path.join(directory, 'BLOB')\r\n    this.blobMapFilename = path.join(directory, 'MAP')\r\n    this.lockFilename = path.join(directory, 'LOCK')\r\n    this.reset()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/file-system-blob-store.js","name":"FileSystemBlobStore.reset","start_line":21,"end_line":26,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"addItems","line":83,"func_location":"Pane.constructor","func_start_line":53,"func_end_line":87,"args":[null],"code":"  constructor (params = {}) {\r\n    this.setPendingItem = this.setPendingItem.bind(this)\r\n    this.getPendingItem = this.getPendingItem.bind(this)\r\n    this.clearPendingItem = this.clearPendingItem.bind(this)\r\n    this.onItemDidTerminatePendingState = this.onItemDidTerminatePendingState.bind(this)\r\n    this.saveItem = this.saveItem.bind(this)\r\n    this.saveItemAs = this.saveItemAs.bind(this)\r\n\r\n    this.id = params.id\r\n    if (this.id != null) {\r\n      nextInstanceId = Math.max(nextInstanceId, this.id + 1)\r\n    } else {\r\n      this.id = nextInstanceId++\r\n    }\r\n\r\n    this.activeItem = params.activeItem\r\n    this.focused = params.focused != null ? params.focused : false\r\n    this.applicationDelegate = params.applicationDelegate\r\n    this.notificationManager = params.notificationManager\r\n    this.config = params.config\r\n    this.deserializerManager = params.deserializerManager\r\n    this.viewRegistry = params.viewRegistry\r\n\r\n    this.emitter = new Emitter()\r\n    this.alive = true\r\n    this.subscriptionsPerItem = new WeakMap()\r\n    this.items = []\r\n    this.itemStack = []\r\n    this.container = null\r\n\r\n    this.addItems((params.items || []).filter(item => item))\r\n    if (!this.getActiveItem()) this.setActiveItem(this.items[0])\r\n    this.addItemsToStack(params.itemStackIndices || [])\r\n    this.setFlexScale(params.flexScale || 1)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.addItems","start_line":675,"end_line":682,"comment":[" Public: Add the given items to the pane.",""," * `items` An {Array} of items to add. Items can be views or models with","   associated views. Any objects that are already present in the pane's","   current items will not be added again."," * `index` (optional) {Number} index at which to add the items. If omitted,","   the item is #   added after the current active item.",""," Returns an {Array} of added items."],"params":["items","index"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getActiveItem","line":84,"func_location":"Pane.constructor","func_start_line":53,"func_end_line":87,"args":[],"code":"  constructor (params = {}) {\r\n    this.setPendingItem = this.setPendingItem.bind(this)\r\n    this.getPendingItem = this.getPendingItem.bind(this)\r\n    this.clearPendingItem = this.clearPendingItem.bind(this)\r\n    this.onItemDidTerminatePendingState = this.onItemDidTerminatePendingState.bind(this)\r\n    this.saveItem = this.saveItem.bind(this)\r\n    this.saveItemAs = this.saveItemAs.bind(this)\r\n\r\n    this.id = params.id\r\n    if (this.id != null) {\r\n      nextInstanceId = Math.max(nextInstanceId, this.id + 1)\r\n    } else {\r\n      this.id = nextInstanceId++\r\n    }\r\n\r\n    this.activeItem = params.activeItem\r\n    this.focused = params.focused != null ? params.focused : false\r\n    this.applicationDelegate = params.applicationDelegate\r\n    this.notificationManager = params.notificationManager\r\n    this.config = params.config\r\n    this.deserializerManager = params.deserializerManager\r\n    this.viewRegistry = params.viewRegistry\r\n\r\n    this.emitter = new Emitter()\r\n    this.alive = true\r\n    this.subscriptionsPerItem = new WeakMap()\r\n    this.items = []\r\n    this.itemStack = []\r\n    this.container = null\r\n\r\n    this.addItems((params.items || []).filter(item => item))\r\n    if (!this.getActiveItem()) this.setActiveItem(this.items[0])\r\n    this.addItemsToStack(params.itemStackIndices || [])\r\n    this.setFlexScale(params.flexScale || 1)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getActiveItem","start_line":432,"end_line":432,"comment":[" Public: Get the active pane item in this pane.",""," Returns a pane item."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"setActiveItem","line":84,"func_location":"Pane.constructor","func_start_line":53,"func_end_line":87,"args":[],"code":"  constructor (params = {}) {\r\n    this.setPendingItem = this.setPendingItem.bind(this)\r\n    this.getPendingItem = this.getPendingItem.bind(this)\r\n    this.clearPendingItem = this.clearPendingItem.bind(this)\r\n    this.onItemDidTerminatePendingState = this.onItemDidTerminatePendingState.bind(this)\r\n    this.saveItem = this.saveItem.bind(this)\r\n    this.saveItemAs = this.saveItemAs.bind(this)\r\n\r\n    this.id = params.id\r\n    if (this.id != null) {\r\n      nextInstanceId = Math.max(nextInstanceId, this.id + 1)\r\n    } else {\r\n      this.id = nextInstanceId++\r\n    }\r\n\r\n    this.activeItem = params.activeItem\r\n    this.focused = params.focused != null ? params.focused : false\r\n    this.applicationDelegate = params.applicationDelegate\r\n    this.notificationManager = params.notificationManager\r\n    this.config = params.config\r\n    this.deserializerManager = params.deserializerManager\r\n    this.viewRegistry = params.viewRegistry\r\n\r\n    this.emitter = new Emitter()\r\n    this.alive = true\r\n    this.subscriptionsPerItem = new WeakMap()\r\n    this.items = []\r\n    this.itemStack = []\r\n    this.container = null\r\n\r\n    this.addItems((params.items || []).filter(item => item))\r\n    if (!this.getActiveItem()) this.setActiveItem(this.items[0])\r\n    this.addItemsToStack(params.itemStackIndices || [])\r\n    this.setFlexScale(params.flexScale || 1)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.setActiveItem","start_line":434,"end_line":443,"comment":[],"params":["activeItem","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"addItemsToStack","line":85,"func_location":"Pane.constructor","func_start_line":53,"func_end_line":87,"args":[null],"code":"  constructor (params = {}) {\r\n    this.setPendingItem = this.setPendingItem.bind(this)\r\n    this.getPendingItem = this.getPendingItem.bind(this)\r\n    this.clearPendingItem = this.clearPendingItem.bind(this)\r\n    this.onItemDidTerminatePendingState = this.onItemDidTerminatePendingState.bind(this)\r\n    this.saveItem = this.saveItem.bind(this)\r\n    this.saveItemAs = this.saveItemAs.bind(this)\r\n\r\n    this.id = params.id\r\n    if (this.id != null) {\r\n      nextInstanceId = Math.max(nextInstanceId, this.id + 1)\r\n    } else {\r\n      this.id = nextInstanceId++\r\n    }\r\n\r\n    this.activeItem = params.activeItem\r\n    this.focused = params.focused != null ? params.focused : false\r\n    this.applicationDelegate = params.applicationDelegate\r\n    this.notificationManager = params.notificationManager\r\n    this.config = params.config\r\n    this.deserializerManager = params.deserializerManager\r\n    this.viewRegistry = params.viewRegistry\r\n\r\n    this.emitter = new Emitter()\r\n    this.alive = true\r\n    this.subscriptionsPerItem = new WeakMap()\r\n    this.items = []\r\n    this.itemStack = []\r\n    this.container = null\r\n\r\n    this.addItems((params.items || []).filter(item => item))\r\n    if (!this.getActiveItem()) this.setActiveItem(this.items[0])\r\n    this.addItemsToStack(params.itemStackIndices || [])\r\n    this.setFlexScale(params.flexScale || 1)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.addItemsToStack","start_line":446,"end_line":456,"comment":[" Build the itemStack after deserializing"],"params":["itemStackIndices"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"setFlexScale","line":86,"func_location":"Pane.constructor","func_start_line":53,"func_end_line":87,"args":[null],"code":"  constructor (params = {}) {\r\n    this.setPendingItem = this.setPendingItem.bind(this)\r\n    this.getPendingItem = this.getPendingItem.bind(this)\r\n    this.clearPendingItem = this.clearPendingItem.bind(this)\r\n    this.onItemDidTerminatePendingState = this.onItemDidTerminatePendingState.bind(this)\r\n    this.saveItem = this.saveItem.bind(this)\r\n    this.saveItemAs = this.saveItemAs.bind(this)\r\n\r\n    this.id = params.id\r\n    if (this.id != null) {\r\n      nextInstanceId = Math.max(nextInstanceId, this.id + 1)\r\n    } else {\r\n      this.id = nextInstanceId++\r\n    }\r\n\r\n    this.activeItem = params.activeItem\r\n    this.focused = params.focused != null ? params.focused : false\r\n    this.applicationDelegate = params.applicationDelegate\r\n    this.notificationManager = params.notificationManager\r\n    this.config = params.config\r\n    this.deserializerManager = params.deserializerManager\r\n    this.viewRegistry = params.viewRegistry\r\n\r\n    this.emitter = new Emitter()\r\n    this.alive = true\r\n    this.subscriptionsPerItem = new WeakMap()\r\n    this.items = []\r\n    this.itemStack = []\r\n    this.container = null\r\n\r\n    this.addItems((params.items || []).filter(item => item))\r\n    if (!this.getActiveItem()) this.setActiveItem(this.items[0])\r\n    this.addItemsToStack(params.itemStackIndices || [])\r\n    this.setFlexScale(params.flexScale || 1)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.setFlexScale","start_line":150,"end_line":154,"comment":[],"params":["flexScale"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"constructor","line":973,"func_location":"TextEditor.copy","func_start_line":969,"func_end_line":988},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.constructor","start_line":125,"end_line":265,"comment":[],"params":["params"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js","name":"loadDependencies","line":266,"func_location":"exports.create","func_start_line":252,"func_end_line":272,"args":["modulePath","modulePath","metadata","moduleCache"],"code":"exports.create = function (modulePath) {\r\n  const fs = require('fs-plus')\r\n\r\n  modulePath = fs.realpathSync(modulePath)\r\n  const metadataPath = path.join(modulePath, 'package.json')\r\n  const metadata = JSON.parse(fs.readFileSync(metadataPath))\r\n\r\n  const moduleCache = {\r\n    version: 1,\r\n    dependencies: [],\r\n    extensions: {},\r\n    folders: []\r\n  }\r\n\r\n  loadDependencies(modulePath, modulePath, metadata, moduleCache)\r\n  loadFolderCompatibility(modulePath, modulePath, metadata, moduleCache)\r\n  loadExtensions(modulePath, modulePath, metadata, moduleCache)\r\n\r\n  metadata._atomModuleCache = moduleCache\r\n  fs.writeFileSync(metadataPath, JSON.stringify(metadata, null, 2))\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js","name":"loadDependencies","start_line":52,"end_line":84,"comment":[],"params":["modulePath","rootPath","rootMetadata","moduleCache"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js","name":"loadFolderCompatibility","line":267,"func_location":"exports.create","func_start_line":252,"func_end_line":272,"args":["modulePath","modulePath","metadata","moduleCache"],"code":"exports.create = function (modulePath) {\r\n  const fs = require('fs-plus')\r\n\r\n  modulePath = fs.realpathSync(modulePath)\r\n  const metadataPath = path.join(modulePath, 'package.json')\r\n  const metadata = JSON.parse(fs.readFileSync(metadataPath))\r\n\r\n  const moduleCache = {\r\n    version: 1,\r\n    dependencies: [],\r\n    extensions: {},\r\n    folders: []\r\n  }\r\n\r\n  loadDependencies(modulePath, modulePath, metadata, moduleCache)\r\n  loadFolderCompatibility(modulePath, modulePath, metadata, moduleCache)\r\n  loadExtensions(modulePath, modulePath, metadata, moduleCache)\r\n\r\n  metadata._atomModuleCache = moduleCache\r\n  fs.writeFileSync(metadataPath, JSON.stringify(metadata, null, 2))\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js","name":"loadFolderCompatibility","start_line":86,"end_line":126,"comment":[],"params":["modulePath","rootPath","rootMetadata","moduleCache"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js","name":"loadExtensions","line":268,"func_location":"exports.create","func_start_line":252,"func_end_line":272,"args":["modulePath","modulePath","metadata","moduleCache"],"code":"exports.create = function (modulePath) {\r\n  const fs = require('fs-plus')\r\n\r\n  modulePath = fs.realpathSync(modulePath)\r\n  const metadataPath = path.join(modulePath, 'package.json')\r\n  const metadata = JSON.parse(fs.readFileSync(metadataPath))\r\n\r\n  const moduleCache = {\r\n    version: 1,\r\n    dependencies: [],\r\n    extensions: {},\r\n    folders: []\r\n  }\r\n\r\n  loadDependencies(modulePath, modulePath, metadata, moduleCache)\r\n  loadFolderCompatibility(modulePath, modulePath, metadata, moduleCache)\r\n  loadExtensions(modulePath, modulePath, metadata, moduleCache)\r\n\r\n  metadata._atomModuleCache = moduleCache\r\n  fs.writeFileSync(metadataPath, JSON.stringify(metadata, null, 2))\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js","name":"loadExtensions","start_line":128,"end_line":164,"comment":[],"params":["modulePath","rootPath","rootMetadata","moduleCache"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js","name":"initializeContent","line":9,"func_location":"PaneElement.createdCallback","func_start_line":5,"func_end_line":11,"args":[],"code":"  createdCallback () {\r\n    this.attached = false\r\n    this.subscriptions = new CompositeDisposable()\r\n    this.inlineDisplayStyles = new WeakMap()\r\n    this.initializeContent()\r\n    this.subscribeToDOMEvents()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js","name":"PaneElement.initializeContent","start_line":24,"end_line":30,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js","name":"subscribeToDOMEvents","line":10,"func_location":"PaneElement.createdCallback","func_start_line":5,"func_end_line":11,"args":[],"code":"  createdCallback () {\r\n    this.attached = false\r\n    this.subscriptions = new CompositeDisposable()\r\n    this.inlineDisplayStyles = new WeakMap()\r\n    this.initializeContent()\r\n    this.subscribeToDOMEvents()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js","name":"PaneElement.subscribeToDOMEvents","start_line":32,"end_line":72,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getOpeners","line":1193,"func_location":"Workspace.createItemForURI","func_start_line":1191,"func_end_line":1229,"args":[],"comment":[" Public: Creates a new item that corresponds to the provided URI.",""," If no URI is given, or no registered opener can open the URI, a new empty"," {TextEditor} will be created.",""," * `uri` A {String} containing a URI.",""," Returns a {Promise} that resolves to the {TextEditor} (or other item) for the given URI."],"code":"  async createItemForURI (uri, options) {\r\n    if (uri != null) {\r\n      for (const opener of this.getOpeners()) {\r\n        const item = opener(uri, options)\r\n        if (item != null) return item\r\n      }\r\n    }\r\n\r\n    try {\r\n      const item = await this.openTextFile(uri, options)\r\n      return item\r\n    } catch (error) {\r\n      switch (error.code) {\r\n        case 'CANCELLED':\r\n          return Promise.resolve()\r\n        case 'EACCES':\r\n          this.notificationManager.addWarning(`Permission denied '${error.path}'`)\r\n          return Promise.resolve()\r\n        case 'EPERM':\r\n        case 'EBUSY':\r\n        case 'ENXIO':\r\n        case 'EIO':\r\n        case 'ENOTCONN':\r\n        case 'UNKNOWN':\r\n        case 'ECONNRESET':\r\n        case 'EINVAL':\r\n        case 'EMFILE':\r\n        case 'ENOTDIR':\r\n        case 'EAGAIN':\r\n          this.notificationManager.addWarning(\r\n            `Unable to open '${error.path != null ? error.path : uri}'`,\r\n            {detail: error.message}\r\n          )\r\n          return Promise.resolve()\r\n        default:\r\n          throw error\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getOpeners","start_line":1339,"end_line":1341,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"openTextFile","line":1200,"func_location":"Workspace.createItemForURI","func_start_line":1191,"func_end_line":1229,"args":["uri","options"],"comment":[" Public: Creates a new item that corresponds to the provided URI.",""," If no URI is given, or no registered opener can open the URI, a new empty"," {TextEditor} will be created.",""," * `uri` A {String} containing a URI.",""," Returns a {Promise} that resolves to the {TextEditor} (or other item) for the given URI."],"code":"  async createItemForURI (uri, options) {\r\n    if (uri != null) {\r\n      for (const opener of this.getOpeners()) {\r\n        const item = opener(uri, options)\r\n        if (item != null) return item\r\n      }\r\n    }\r\n\r\n    try {\r\n      const item = await this.openTextFile(uri, options)\r\n      return item\r\n    } catch (error) {\r\n      switch (error.code) {\r\n        case 'CANCELLED':\r\n          return Promise.resolve()\r\n        case 'EACCES':\r\n          this.notificationManager.addWarning(`Permission denied '${error.path}'`)\r\n          return Promise.resolve()\r\n        case 'EPERM':\r\n        case 'EBUSY':\r\n        case 'ENXIO':\r\n        case 'EIO':\r\n        case 'ENOTCONN':\r\n        case 'UNKNOWN':\r\n        case 'ECONNRESET':\r\n        case 'EINVAL':\r\n        case 'EMFILE':\r\n        case 'ENOTDIR':\r\n        case 'EAGAIN':\r\n          this.notificationManager.addWarning(\r\n            `Unable to open '${error.path != null ? error.path : uri}'`,\r\n            {detail: error.message}\r\n          )\r\n          return Promise.resolve()\r\n        default:\r\n          throw error\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.openTextFile","start_line":1231,"end_line":1267,"comment":[],"params":["uri","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"unregisterURIHandler","line":691,"func_location":"Package.deactivate","func_start_line":685,"func_end_line":722,"args":[],"code":"  async deactivate () {\r\n    this.activationPromise = null\r\n    this.resolveActivationPromise = null\r\n    if (this.activationCommandSubscriptions) this.activationCommandSubscriptions.dispose()\r\n    if (this.activationHookSubscriptions) this.activationHookSubscriptions.dispose()\r\n    this.configSchemaRegisteredOnActivate = false\r\n    this.unregisterURIHandler()\r\n    this.deactivateResources()\r\n    this.deactivateKeymaps()\r\n\r\n    if (!this.mainActivated) {\r\n      this.emitter.emit('did-deactivate')\r\n      return\r\n    }\r\n\r\n    if (typeof this.mainModule.deactivate === 'function') {\r\n      try {\r\n        const deactivationResult = this.mainModule.deactivate()\r\n        if (deactivationResult && typeof deactivationResult.then === 'function') {\r\n          await deactivationResult\r\n        }\r\n      } catch (error) {\r\n        console.error(`Error deactivating package '${this.name}'`, error.stack)\r\n      }\r\n    }\r\n\r\n    if (typeof this.mainModule.deactivateConfig === 'function') {\r\n      try {\r\n        await this.mainModule.deactivateConfig()\r\n      } catch (error) {\r\n        console.error(`Error deactivating package '${this.name}'`, error.stack)\r\n      }\r\n    }\r\n\r\n    this.mainActivated = false\r\n    this.mainInitialized = false\r\n    this.emitter.emit('did-deactivate')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.unregisterURIHandler","start_line":415,"end_line":417,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"deactivateResources","line":692,"func_location":"Package.deactivate","func_start_line":685,"func_end_line":722,"args":[],"code":"  async deactivate () {\r\n    this.activationPromise = null\r\n    this.resolveActivationPromise = null\r\n    if (this.activationCommandSubscriptions) this.activationCommandSubscriptions.dispose()\r\n    if (this.activationHookSubscriptions) this.activationHookSubscriptions.dispose()\r\n    this.configSchemaRegisteredOnActivate = false\r\n    this.unregisterURIHandler()\r\n    this.deactivateResources()\r\n    this.deactivateKeymaps()\r\n\r\n    if (!this.mainActivated) {\r\n      this.emitter.emit('did-deactivate')\r\n      return\r\n    }\r\n\r\n    if (typeof this.mainModule.deactivate === 'function') {\r\n      try {\r\n        const deactivationResult = this.mainModule.deactivate()\r\n        if (deactivationResult && typeof deactivationResult.then === 'function') {\r\n          await deactivationResult\r\n        }\r\n      } catch (error) {\r\n        console.error(`Error deactivating package '${this.name}'`, error.stack)\r\n      }\r\n    }\r\n\r\n    if (typeof this.mainModule.deactivateConfig === 'function') {\r\n      try {\r\n        await this.mainModule.deactivateConfig()\r\n      } catch (error) {\r\n        console.error(`Error deactivating package '${this.name}'`, error.stack)\r\n      }\r\n    }\r\n\r\n    this.mainActivated = false\r\n    this.mainInitialized = false\r\n    this.emitter.emit('did-deactivate')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.deactivateResources","start_line":724,"end_line":740,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"deactivateKeymaps","line":693,"func_location":"Package.deactivate","func_start_line":685,"func_end_line":722,"args":[],"code":"  async deactivate () {\r\n    this.activationPromise = null\r\n    this.resolveActivationPromise = null\r\n    if (this.activationCommandSubscriptions) this.activationCommandSubscriptions.dispose()\r\n    if (this.activationHookSubscriptions) this.activationHookSubscriptions.dispose()\r\n    this.configSchemaRegisteredOnActivate = false\r\n    this.unregisterURIHandler()\r\n    this.deactivateResources()\r\n    this.deactivateKeymaps()\r\n\r\n    if (!this.mainActivated) {\r\n      this.emitter.emit('did-deactivate')\r\n      return\r\n    }\r\n\r\n    if (typeof this.mainModule.deactivate === 'function') {\r\n      try {\r\n        const deactivationResult = this.mainModule.deactivate()\r\n        if (deactivationResult && typeof deactivationResult.then === 'function') {\r\n          await deactivationResult\r\n        }\r\n      } catch (error) {\r\n        console.error(`Error deactivating package '${this.name}'`, error.stack)\r\n      }\r\n    }\r\n\r\n    if (typeof this.mainModule.deactivateConfig === 'function') {\r\n      try {\r\n        await this.mainModule.deactivateConfig()\r\n      } catch (error) {\r\n        console.error(`Error deactivating package '${this.name}'`, error.stack)\r\n      }\r\n    }\r\n\r\n    this.mainActivated = false\r\n    this.mainInitialized = false\r\n    this.emitter.emit('did-deactivate')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.deactivateKeymaps","start_line":340,"end_line":347,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"getLoadedPackage","line":780,"func_location":"PackageManager.deactivatePackage","func_start_line":779,"func_end_line":797,"args":["name"],"comment":[" Deactivate the package with the given name"],"code":"  async deactivatePackage (name, suppressSerialization) {\r\n    const pack = this.getLoadedPackage(name)\r\n    if (pack == null) {\r\n      return\r\n    }\r\n\r\n    if (!suppressSerialization && this.isPackageActive(pack.name)) {\r\n      this.serializePackage(pack)\r\n    }\r\n\r\n    const deactivationResult = pack.deactivate()\r\n    if (deactivationResult && typeof deactivationResult.then === 'function') {\r\n      await deactivationResult\r\n    }\r\n\r\n    delete this.activePackages[pack.name]\r\n    delete this.activatingPackages[pack.name]\r\n    this.emitter.emit('did-deactivate-package', pack)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.getLoadedPackage","start_line":339,"end_line":341,"comment":[" Public: Get the loaded {Package} with the given name.",""," * `name` - The {String} package name.",""," Returns a {Package} or undefined."],"params":["name"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"isPackageActive","line":785,"func_location":"PackageManager.deactivatePackage","func_start_line":779,"func_end_line":797,"args":["pack.name"],"comment":[" Deactivate the package with the given name"],"code":"  async deactivatePackage (name, suppressSerialization) {\r\n    const pack = this.getLoadedPackage(name)\r\n    if (pack == null) {\r\n      return\r\n    }\r\n\r\n    if (!suppressSerialization && this.isPackageActive(pack.name)) {\r\n      this.serializePackage(pack)\r\n    }\r\n\r\n    const deactivationResult = pack.deactivate()\r\n    if (deactivationResult && typeof deactivationResult.then === 'function') {\r\n      await deactivationResult\r\n    }\r\n\r\n    delete this.activePackages[pack.name]\r\n    delete this.activatingPackages[pack.name]\r\n    this.emitter.emit('did-deactivate-package', pack)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.isPackageActive","start_line":309,"end_line":311,"comment":[" Public: Is the {Package} with the given name active?",""," * `name` - The {String} package name.",""," Returns a {Boolean}."],"params":["name"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"serializePackage","line":786,"func_location":"PackageManager.deactivatePackage","func_start_line":779,"func_end_line":797,"args":["pack"],"comment":[" Deactivate the package with the given name"],"code":"  async deactivatePackage (name, suppressSerialization) {\r\n    const pack = this.getLoadedPackage(name)\r\n    if (pack == null) {\r\n      return\r\n    }\r\n\r\n    if (!suppressSerialization && this.isPackageActive(pack.name)) {\r\n      this.serializePackage(pack)\r\n    }\r\n\r\n    const deactivationResult = pack.deactivate()\r\n    if (deactivationResult && typeof deactivationResult.then === 'function') {\r\n      await deactivationResult\r\n    }\r\n\r\n    delete this.activePackages[pack.name]\r\n    delete this.activatingPackages[pack.name]\r\n    this.emitter.emit('did-deactivate-package', pack)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.serializePackage","start_line":763,"end_line":767,"comment":[],"params":["pack"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"unobserveDisabledPackages","line":774,"func_location":"PackageManager.deactivatePackages","func_start_line":770,"func_end_line":776,"args":[],"comment":[" Deactivate all packages"],"code":"  async deactivatePackages () {\r\n    await this.config.transactAsync(() =>\r\n      Promise.all(this.getLoadedPackages().map(pack => this.deactivatePackage(pack.name, true)))\r\n    )\r\n    this.unobserveDisabledPackages()\r\n    this.unobservePackagesWithKeymapsDisabled()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.unobserveDisabledPackages","start_line":437,"end_line":442,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"unobservePackagesWithKeymapsDisabled","line":775,"func_location":"PackageManager.deactivatePackages","func_start_line":770,"func_end_line":776,"args":[],"comment":[" Deactivate all packages"],"code":"  async deactivatePackages () {\r\n    await this.config.transactAsync(() =>\r\n      Promise.all(this.getLoadedPackages().map(pack => this.deactivatePackage(pack.name, true)))\r\n    )\r\n    this.unobserveDisabledPackages()\r\n    this.unobservePackagesWithKeymapsDisabled()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.unobservePackagesWithKeymapsDisabled","start_line":458,"end_line":463,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"removeActiveThemeClasses","line":351,"func_location":"ThemeManager.deactivateThemes","func_start_line":350,"func_end_line":355,"args":[],"code":"  deactivateThemes () {\r\n    this.removeActiveThemeClasses()\r\n    this.unwatchUserStylesheet()\r\n    const results = this.getActiveThemes().map(pack => this.packageManager.deactivatePackage(pack.name))\r\n    return Promise.all(results.filter((r) => (r != null) && (typeof r.then === 'function')))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.removeActiveThemeClasses","start_line":370,"end_line":375,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"unwatchUserStylesheet","line":352,"func_location":"ThemeManager.deactivateThemes","func_start_line":350,"func_end_line":355,"args":[],"code":"  deactivateThemes () {\r\n    this.removeActiveThemeClasses()\r\n    this.unwatchUserStylesheet()\r\n    const results = this.getActiveThemes().map(pack => this.packageManager.deactivatePackage(pack.name))\r\n    return Promise.all(results.filter((r) => (r != null) && (typeof r.then === 'function')))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.unwatchUserStylesheet","start_line":177,"end_line":183,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"getActiveThemes","line":353,"func_location":"ThemeManager.deactivateThemes","func_start_line":350,"func_end_line":355,"args":[null],"code":"  deactivateThemes () {\r\n    this.removeActiveThemeClasses()\r\n    this.unwatchUserStylesheet()\r\n    const results = this.getActiveThemes().map(pack => this.packageManager.deactivatePackage(pack.name))\r\n    return Promise.all(results.filter((r) => (r != null) && (typeof r.then === 'function')))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.getActiveThemes","start_line":92,"end_line":94,"comment":[" Public: Returns an {Array} of all the active themes."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js","name":"observeDecoratedLayer","line":202,"func_location":"DecorationManager.decorateMarker","func_start_line":181,"func_end_line":207,"args":["marker.layer",{"type":"boolean"}],"code":"  decorateMarker (marker, decorationParams) {\r\n    if (marker.isDestroyed()) {\r\n      const error = new Error('Cannot decorate a destroyed marker')\r\n      error.metadata = {markerLayerIsDestroyed: marker.layer.isDestroyed()}\r\n      if (marker.destroyStackTrace != null) {\r\n        error.metadata.destroyStackTrace = marker.destroyStackTrace\r\n      }\r\n      if (marker.bufferMarker != null && marker.bufferMarker.destroyStackTrace != null) {\r\n        error.metadata.destroyStackTrace = marker.bufferMarker.destroyStackTrace\r\n      }\r\n      throw error\r\n    }\r\n    marker = this.displayLayer.getMarkerLayer(marker.layer.id).getMarker(marker.id)\r\n    const decoration = new Decoration(marker, this, decorationParams)\r\n    let decorationsForMarker = this.decorationsByMarker.get(marker)\r\n    if (!decorationsForMarker) {\r\n      decorationsForMarker = new Set()\r\n      this.decorationsByMarker.set(marker, decorationsForMarker)\r\n    }\r\n    decorationsForMarker.add(decoration)\r\n    if (decoration.isType('overlay')) this.overlayDecorations.add(decoration)\r\n    this.observeDecoratedLayer(marker.layer, true)\r\n    this.editor.didAddDecoration(decoration)\r\n    this.emitDidUpdateDecorations()\r\n    this.emitter.emit('did-add-decoration', decoration)\r\n    return decoration\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js","name":"DecorationManager.observeDecoratedLayer","start_line":266,"end_line":275,"comment":[],"params":["layer","isMarkerDecoration"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js","name":"emitDidUpdateDecorations","line":204,"func_location":"DecorationManager.decorateMarker","func_start_line":181,"func_end_line":207,"args":[],"code":"  decorateMarker (marker, decorationParams) {\r\n    if (marker.isDestroyed()) {\r\n      const error = new Error('Cannot decorate a destroyed marker')\r\n      error.metadata = {markerLayerIsDestroyed: marker.layer.isDestroyed()}\r\n      if (marker.destroyStackTrace != null) {\r\n        error.metadata.destroyStackTrace = marker.destroyStackTrace\r\n      }\r\n      if (marker.bufferMarker != null && marker.bufferMarker.destroyStackTrace != null) {\r\n        error.metadata.destroyStackTrace = marker.bufferMarker.destroyStackTrace\r\n      }\r\n      throw error\r\n    }\r\n    marker = this.displayLayer.getMarkerLayer(marker.layer.id).getMarker(marker.id)\r\n    const decoration = new Decoration(marker, this, decorationParams)\r\n    let decorationsForMarker = this.decorationsByMarker.get(marker)\r\n    if (!decorationsForMarker) {\r\n      decorationsForMarker = new Set()\r\n      this.decorationsByMarker.set(marker, decorationsForMarker)\r\n    }\r\n    decorationsForMarker.add(decoration)\r\n    if (decoration.isType('overlay')) this.overlayDecorations.add(decoration)\r\n    this.observeDecoratedLayer(marker.layer, true)\r\n    this.editor.didAddDecoration(decoration)\r\n    this.emitDidUpdateDecorations()\r\n    this.emitter.emit('did-add-decoration', decoration)\r\n    return decoration\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js","name":"DecorationManager.emitDidUpdateDecorations","start_line":226,"end_line":229,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js","name":"observeDecoratedLayer","line":221,"func_location":"DecorationManager.decorateMarkerLayer","func_start_line":209,"func_end_line":224,"args":["markerLayer",{"type":"boolean"}],"code":"  decorateMarkerLayer (markerLayer, decorationParams) {\r\n    if (markerLayer.isDestroyed()) {\r\n      throw new Error('Cannot decorate a destroyed marker layer')\r\n    }\r\n    markerLayer = this.displayLayer.getMarkerLayer(markerLayer.id)\r\n    const decoration = new LayerDecoration(markerLayer, this, decorationParams)\r\n    let layerDecorations = this.layerDecorationsByMarkerLayer.get(markerLayer)\r\n    if (layerDecorations == null) {\r\n      layerDecorations = new Set()\r\n      this.layerDecorationsByMarkerLayer.set(markerLayer, layerDecorations)\r\n    }\r\n    layerDecorations.add(decoration)\r\n    this.observeDecoratedLayer(markerLayer, false)\r\n    this.emitDidUpdateDecorations()\r\n    return decoration\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js","name":"DecorationManager.observeDecoratedLayer","start_line":266,"end_line":275,"comment":[],"params":["layer","isMarkerDecoration"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js","name":"emitDidUpdateDecorations","line":222,"func_location":"DecorationManager.decorateMarkerLayer","func_start_line":209,"func_end_line":224,"args":[],"code":"  decorateMarkerLayer (markerLayer, decorationParams) {\r\n    if (markerLayer.isDestroyed()) {\r\n      throw new Error('Cannot decorate a destroyed marker layer')\r\n    }\r\n    markerLayer = this.displayLayer.getMarkerLayer(markerLayer.id)\r\n    const decoration = new LayerDecoration(markerLayer, this, decorationParams)\r\n    let layerDecorations = this.layerDecorationsByMarkerLayer.get(markerLayer)\r\n    if (layerDecorations == null) {\r\n      layerDecorations = new Set()\r\n      this.layerDecorationsByMarkerLayer.set(markerLayer, layerDecorations)\r\n    }\r\n    layerDecorations.add(decoration)\r\n    this.observeDecoratedLayer(markerLayer, false)\r\n    this.emitDidUpdateDecorations()\r\n    return decoration\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js","name":"DecorationManager.emitDidUpdateDecorations","start_line":226,"end_line":229,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"regexForPattern","line":702,"func_location":"TextMateLanguageMode.decreaseIndentRegexForScopeDescriptor","func_start_line":701,"func_end_line":703,"args":[null],"code":"  decreaseIndentRegexForScopeDescriptor (scope) {\r\n    return this.regexForPattern(this.config.get('editor.decreaseIndentPattern', {scope}))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.regexForPattern","start_line":713,"end_line":720,"comment":[],"params":["pattern"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"regexForPattern","line":706,"func_location":"TextMateLanguageMode.decreaseNextIndentRegexForScopeDescriptor","func_start_line":705,"func_end_line":707,"args":[null],"code":"  decreaseNextIndentRegexForScopeDescriptor (scope) {\r\n    return this.regexForPattern(this.config.get('editor.decreaseNextIndentPattern', {scope}))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.regexForPattern","start_line":713,"end_line":720,"comment":[],"params":["pattern"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getContainer","line":165,"func_location":"Pane.decreaseSize","func_start_line":164,"func_end_line":168,"args":[],"code":"  decreaseSize () {\r\n    if (this.getContainer().getPanes().length > 1) {\r\n      this.setFlexScale(this.getFlexScale() / 1.1)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getContainer","start_line":128,"end_line":128,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"setFlexScale","line":166,"func_location":"Pane.decreaseSize","func_start_line":164,"func_end_line":168,"args":[null],"code":"  decreaseSize () {\r\n    if (this.getContainer().getPanes().length > 1) {\r\n      this.setFlexScale(this.getFlexScale() / 1.1)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.setFlexScale","start_line":150,"end_line":154,"comment":[],"params":["flexScale"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getFlexScale","line":166,"func_location":"Pane.decreaseSize","func_start_line":164,"func_end_line":168,"args":[null],"code":"  decreaseSize () {\r\n    if (this.getContainer().getPanes().length > 1) {\r\n      this.setFlexScale(this.getFlexScale() / 1.1)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getFlexScale","start_line":156,"end_line":156,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"deepDefaults","line":1111,"func_location":"Config.deepDefaults","func_start_line":1104,"func_end_line":1120,"args":["result.key","object.key"],"code":"  deepDefaults (target) {\r\n    let result = target\r\n    let i = 0\r\n    while (++i < arguments.length) {\r\n      const object = arguments[i]\r\n      if (isPlainObject(result) && isPlainObject(object)) {\r\n        for (let key of Object.keys(object)) {\r\n          result[key] = this.deepDefaults(result[key], object[key])\r\n        }\r\n      } else {\r\n        if ((result == null)) {\r\n          result = this.deepClone(object)\r\n        }\r\n      }\r\n    }\r\n    return result\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.deepDefaults","start_line":1104,"end_line":1120,"comment":[],"params":["target"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"deepClone","line":1115,"func_location":"Config.deepDefaults","func_start_line":1104,"func_end_line":1120,"args":["object"],"code":"  deepDefaults (target) {\r\n    let result = target\r\n    let i = 0\r\n    while (++i < arguments.length) {\r\n      const object = arguments[i]\r\n      if (isPlainObject(result) && isPlainObject(object)) {\r\n        for (let key of Object.keys(object)) {\r\n          result[key] = this.deepDefaults(result[key], object[key])\r\n        }\r\n      } else {\r\n        if ((result == null)) {\r\n          result = this.deepClone(object)\r\n        }\r\n      }\r\n    }\r\n    return result\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.deepClone","start_line":1092,"end_line":1102,"comment":[],"params":["object"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"ensureWritable","line":567,"func_location":"Selection.deleteToBeginningOfLine","func_start_line":566,"func_end_line":574,"args":[{"type":"string"},"options"],"comment":[" Public: Removes from the beginning of the line which the selection begins on"," all the way through to the end of the selection.",""," * `options` (optional) {Object}","   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"],"code":"  deleteToBeginningOfLine (options = {}) {\r\n    if (!this.ensureWritable('deleteToBeginningOfLine', options)) return\r\n    if (this.isEmpty() && this.cursor.isAtBeginningOfLine()) {\r\n      this.selectLeft()\r\n    } else {\r\n      this.selectToBeginningOfLine()\r\n    }\r\n    this.deleteSelectedText(options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.ensureWritable","start_line":412,"end_line":427,"comment":[" Private: Ensure that the {TextEditor} is not marked read-only before allowing a buffer modification to occur. if"," the editor is read-only, require an explicit opt-in option to proceed (`bypassReadOnly`) or throw an Error."],"params":["methodName","opts"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"isEmpty","line":568,"func_location":"Selection.deleteToBeginningOfLine","func_start_line":566,"func_end_line":574,"args":[],"comment":[" Public: Removes from the beginning of the line which the selection begins on"," all the way through to the end of the selection.",""," * `options` (optional) {Object}","   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"],"code":"  deleteToBeginningOfLine (options = {}) {\r\n    if (!this.ensureWritable('deleteToBeginningOfLine', options)) return\r\n    if (this.isEmpty() && this.cursor.isAtBeginningOfLine()) {\r\n      this.selectLeft()\r\n    } else {\r\n      this.selectToBeginningOfLine()\r\n    }\r\n    this.deleteSelectedText(options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.isEmpty","start_line":139,"end_line":141,"comment":["\r\n  Section: Info about the selection\r\n  "," Public: Determines if the selection contains anything."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"selectLeft","line":569,"func_location":"Selection.deleteToBeginningOfLine","func_start_line":566,"func_end_line":574,"args":[],"comment":[" Public: Removes from the beginning of the line which the selection begins on"," all the way through to the end of the selection.",""," * `options` (optional) {Object}","   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"],"code":"  deleteToBeginningOfLine (options = {}) {\r\n    if (!this.ensureWritable('deleteToBeginningOfLine', options)) return\r\n    if (this.isEmpty() && this.cursor.isAtBeginningOfLine()) {\r\n      this.selectLeft()\r\n    } else {\r\n      this.selectToBeginningOfLine()\r\n    }\r\n    this.deleteSelectedText(options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.selectLeft","start_line":251,"end_line":253,"comment":[" Public: Selects the text one position left of the cursor.",""," * `columnCount` (optional) {Number} number of columns to select (default: 1)"],"params":["columnCount"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"selectToBeginningOfLine","line":571,"func_location":"Selection.deleteToBeginningOfLine","func_start_line":566,"func_end_line":574,"args":[],"comment":[" Public: Removes from the beginning of the line which the selection begins on"," all the way through to the end of the selection.",""," * `options` (optional) {Object}","   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"],"code":"  deleteToBeginningOfLine (options = {}) {\r\n    if (!this.ensureWritable('deleteToBeginningOfLine', options)) return\r\n    if (this.isEmpty() && this.cursor.isAtBeginningOfLine()) {\r\n      this.selectLeft()\r\n    } else {\r\n      this.selectToBeginningOfLine()\r\n    }\r\n    this.deleteSelectedText(options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.selectToBeginningOfLine","start_line":288,"end_line":290,"comment":[" Public: Selects all the text from the current cursor position to the"," beginning of the line."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"ensureWritable","line":556,"func_location":"Selection.deleteToBeginningOfWord","func_start_line":555,"func_end_line":559,"args":[{"type":"string"},"options"],"comment":[" Public: Removes from the start of the selection to the beginning of the"," current word if the selection is empty otherwise it deletes the selection.",""," * `options` (optional) {Object}","   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"],"code":"  deleteToBeginningOfWord (options = {}) {\r\n    if (!this.ensureWritable('deleteToBeginningOfWord', options)) return\r\n    if (this.isEmpty()) this.selectToBeginningOfWord()\r\n    this.deleteSelectedText(options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.ensureWritable","start_line":412,"end_line":427,"comment":[" Private: Ensure that the {TextEditor} is not marked read-only before allowing a buffer modification to occur. if"," the editor is read-only, require an explicit opt-in option to proceed (`bypassReadOnly`) or throw an Error."],"params":["methodName","opts"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"isEmpty","line":557,"func_location":"Selection.deleteToBeginningOfWord","func_start_line":555,"func_end_line":559,"args":[],"comment":[" Public: Removes from the start of the selection to the beginning of the"," current word if the selection is empty otherwise it deletes the selection.",""," * `options` (optional) {Object}","   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"],"code":"  deleteToBeginningOfWord (options = {}) {\r\n    if (!this.ensureWritable('deleteToBeginningOfWord', options)) return\r\n    if (this.isEmpty()) this.selectToBeginningOfWord()\r\n    this.deleteSelectedText(options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.isEmpty","start_line":139,"end_line":141,"comment":["\r\n  Section: Info about the selection\r\n  "," Public: Determines if the selection contains anything."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"selectToBeginningOfWord","line":557,"func_location":"Selection.deleteToBeginningOfWord","func_start_line":555,"func_end_line":559,"args":[],"comment":[" Public: Removes from the start of the selection to the beginning of the"," current word if the selection is empty otherwise it deletes the selection.",""," * `options` (optional) {Object}","   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"],"code":"  deleteToBeginningOfWord (options = {}) {\r\n    if (!this.ensureWritable('deleteToBeginningOfWord', options)) return\r\n    if (this.isEmpty()) this.selectToBeginningOfWord()\r\n    this.deleteSelectedText(options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.selectToBeginningOfWord","start_line":312,"end_line":314,"comment":[" Public: Selects all the text from the current cursor position to the"," beginning of the word."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"ensureWritable","line":545,"func_location":"Selection.deleteToNextWordBoundary","func_start_line":544,"func_end_line":548,"args":[{"type":"string"},"options"],"comment":[" Public: Removes the selection or, if nothing is selected, then all"," characters from the start of the selection up to the next word"," boundary.",""," * `options` (optional) {Object}","   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"],"code":"  deleteToNextWordBoundary (options = {}) {\r\n    if (!this.ensureWritable('deleteToNextWordBoundary', options)) return\r\n    if (this.isEmpty()) this.selectToNextWordBoundary()\r\n    this.deleteSelectedText(options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.ensureWritable","start_line":412,"end_line":427,"comment":[" Private: Ensure that the {TextEditor} is not marked read-only before allowing a buffer modification to occur. if"," the editor is read-only, require an explicit opt-in option to proceed (`bypassReadOnly`) or throw an Error."],"params":["methodName","opts"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"isEmpty","line":546,"func_location":"Selection.deleteToNextWordBoundary","func_start_line":544,"func_end_line":548,"args":[],"comment":[" Public: Removes the selection or, if nothing is selected, then all"," characters from the start of the selection up to the next word"," boundary.",""," * `options` (optional) {Object}","   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"],"code":"  deleteToNextWordBoundary (options = {}) {\r\n    if (!this.ensureWritable('deleteToNextWordBoundary', options)) return\r\n    if (this.isEmpty()) this.selectToNextWordBoundary()\r\n    this.deleteSelectedText(options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.isEmpty","start_line":139,"end_line":141,"comment":["\r\n  Section: Info about the selection\r\n  "," Public: Determines if the selection contains anything."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"selectToNextWordBoundary","line":546,"func_location":"Selection.deleteToNextWordBoundary","func_start_line":544,"func_end_line":548,"args":[],"comment":[" Public: Removes the selection or, if nothing is selected, then all"," characters from the start of the selection up to the next word"," boundary.",""," * `options` (optional) {Object}","   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"],"code":"  deleteToNextWordBoundary (options = {}) {\r\n    if (!this.ensureWritable('deleteToNextWordBoundary', options)) return\r\n    if (this.isEmpty()) this.selectToNextWordBoundary()\r\n    this.deleteSelectedText(options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.selectToNextWordBoundary","start_line":334,"end_line":336,"comment":[" Public: Selects text to the next word boundary."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"ensureWritable","line":533,"func_location":"Selection.deleteToPreviousWordBoundary","func_start_line":532,"func_end_line":536,"args":[{"type":"string"},"options"],"comment":[" Public: Removes the selection or, if nothing is selected, then all"," characters from the start of the selection back to the previous word"," boundary.",""," * `options` (optional) {Object}","   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"],"code":"  deleteToPreviousWordBoundary (options = {}) {\r\n    if (!this.ensureWritable('deleteToPreviousWordBoundary', options)) return\r\n    if (this.isEmpty()) this.selectToPreviousWordBoundary()\r\n    this.deleteSelectedText(options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.ensureWritable","start_line":412,"end_line":427,"comment":[" Private: Ensure that the {TextEditor} is not marked read-only before allowing a buffer modification to occur. if"," the editor is read-only, require an explicit opt-in option to proceed (`bypassReadOnly`) or throw an Error."],"params":["methodName","opts"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"isEmpty","line":534,"func_location":"Selection.deleteToPreviousWordBoundary","func_start_line":532,"func_end_line":536,"args":[],"comment":[" Public: Removes the selection or, if nothing is selected, then all"," characters from the start of the selection back to the previous word"," boundary.",""," * `options` (optional) {Object}","   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"],"code":"  deleteToPreviousWordBoundary (options = {}) {\r\n    if (!this.ensureWritable('deleteToPreviousWordBoundary', options)) return\r\n    if (this.isEmpty()) this.selectToPreviousWordBoundary()\r\n    this.deleteSelectedText(options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.isEmpty","start_line":139,"end_line":141,"comment":["\r\n  Section: Info about the selection\r\n  "," Public: Determines if the selection contains anything."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"selectToPreviousWordBoundary","line":534,"func_location":"Selection.deleteToPreviousWordBoundary","func_start_line":532,"func_end_line":536,"args":[],"comment":[" Public: Removes the selection or, if nothing is selected, then all"," characters from the start of the selection back to the previous word"," boundary.",""," * `options` (optional) {Object}","   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"],"code":"  deleteToPreviousWordBoundary (options = {}) {\r\n    if (!this.ensureWritable('deleteToPreviousWordBoundary', options)) return\r\n    if (this.isEmpty()) this.selectToPreviousWordBoundary()\r\n    this.deleteSelectedText(options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.selectToPreviousWordBoundary","start_line":329,"end_line":331,"comment":[" Public: Selects text to the previous word boundary."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/win-shell.js","name":"isRegistered","line":34,"func_location":"ShellOption.deregister","func_start_line":33,"func_end_line":41},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/win-shell.js","name":"ShellOption.isRegistered","start_line":20,"end_line":23,"comment":[],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"setRoot","line":55,"func_location":"PaneContainer.deserialize","func_start_line":52,"func_end_line":58,"args":[null],"code":"  deserialize (state, deserializerManager) {\r\n    if (state.version !== SERIALIZATION_VERSION) return\r\n    this.itemRegistry = new ItemRegistry()\r\n    this.setRoot(deserializerManager.deserialize(state.root))\r\n    this.activePane = find(this.getRoot().getPanes(), pane => pane.id === state.activePaneId) || this.getPanes()[0]\r\n    if (this.config.get('core.destroyEmptyPanes')) this.destroyEmptyPanes()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.setRoot","start_line":131,"end_line":139,"comment":[],"params":["root"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"getRoot","line":56,"func_location":"PaneContainer.deserialize","func_start_line":52,"func_end_line":58,"args":[null,null],"code":"  deserialize (state, deserializerManager) {\r\n    if (state.version !== SERIALIZATION_VERSION) return\r\n    this.itemRegistry = new ItemRegistry()\r\n    this.setRoot(deserializerManager.deserialize(state.root))\r\n    this.activePane = find(this.getRoot().getPanes(), pane => pane.id === state.activePaneId) || this.getPanes()[0]\r\n    if (this.config.get('core.destroyEmptyPanes')) this.destroyEmptyPanes()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.getRoot","start_line":129,"end_line":129,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"getPanes","line":56,"func_location":"PaneContainer.deserialize","func_start_line":52,"func_end_line":58,"args":[null,null],"code":"  deserialize (state, deserializerManager) {\r\n    if (state.version !== SERIALIZATION_VERSION) return\r\n    this.itemRegistry = new ItemRegistry()\r\n    this.setRoot(deserializerManager.deserialize(state.root))\r\n    this.activePane = find(this.getRoot().getPanes(), pane => pane.id === state.activePaneId) || this.getPanes()[0]\r\n    if (this.config.get('core.destroyEmptyPanes')) this.destroyEmptyPanes()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.getPanes","start_line":146,"end_line":152,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"destroyEmptyPanes","line":57,"func_location":"PaneContainer.deserialize","func_start_line":52,"func_end_line":58,"args":[{"type":"string"}],"code":"  deserialize (state, deserializerManager) {\r\n    if (state.version !== SERIALIZATION_VERSION) return\r\n    this.itemRegistry = new ItemRegistry()\r\n    this.setRoot(deserializerManager.deserialize(state.root))\r\n    this.activePane = find(this.getRoot().getPanes(), pane => pane.id === state.activePaneId) || this.getPanes()[0]\r\n    if (this.config.get('core.destroyEmptyPanes')) this.destroyEmptyPanes()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.destroyEmptyPanes","start_line":230,"end_line":232,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getActiveTextEditor","line":378,"func_location":"Workspace.deserialize","func_start_line":355,"func_end_line":381,"args":[],"code":"  deserialize (state, deserializerManager) {\r\n    const packagesWithActiveGrammars =\r\n      state.packagesWithActiveGrammars != null ? state.packagesWithActiveGrammars : []\r\n    for (let packageName of packagesWithActiveGrammars) {\r\n      const pkg = this.packageManager.getLoadedPackage(packageName)\r\n      if (pkg != null) {\r\n        pkg.loadGrammarsSync()\r\n      }\r\n    }\r\n    if (state.destroyedItemURIs != null) {\r\n      this.destroyedItemURIs = state.destroyedItemURIs\r\n    }\r\n\r\n    if (state.paneContainers) {\r\n      this.paneContainers.center.deserialize(state.paneContainers.center, deserializerManager)\r\n      this.paneContainers.left.deserialize(state.paneContainers.left, deserializerManager)\r\n      this.paneContainers.right.deserialize(state.paneContainers.right, deserializerManager)\r\n      this.paneContainers.bottom.deserialize(state.paneContainers.bottom, deserializerManager)\r\n    } else if (state.paneContainer) {\r\n      // TODO: Remove this fallback once a lot of time has passed since 1.17 was released\r\n      this.paneContainers.center.deserialize(state.paneContainer, deserializerManager)\r\n    }\r\n\r\n    this.hasActiveTextEditor = this.getActiveTextEditor() != null\r\n\r\n    this.updateWindowTitle()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getActiveTextEditor","start_line":1372,"end_line":1375,"comment":[" Essential: Get the workspace center's active item if it is a {TextEditor}.",""," Returns a {TextEditor} or `undefined` if the workspace center's current"," active item is not a {TextEditor}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"updateWindowTitle","line":380,"func_location":"Workspace.deserialize","func_start_line":355,"func_end_line":381,"args":[],"code":"  deserialize (state, deserializerManager) {\r\n    const packagesWithActiveGrammars =\r\n      state.packagesWithActiveGrammars != null ? state.packagesWithActiveGrammars : []\r\n    for (let packageName of packagesWithActiveGrammars) {\r\n      const pkg = this.packageManager.getLoadedPackage(packageName)\r\n      if (pkg != null) {\r\n        pkg.loadGrammarsSync()\r\n      }\r\n    }\r\n    if (state.destroyedItemURIs != null) {\r\n      this.destroyedItemURIs = state.destroyedItemURIs\r\n    }\r\n\r\n    if (state.paneContainers) {\r\n      this.paneContainers.center.deserialize(state.paneContainers.center, deserializerManager)\r\n      this.paneContainers.left.deserialize(state.paneContainers.left, deserializerManager)\r\n      this.paneContainers.right.deserialize(state.paneContainers.right, deserializerManager)\r\n      this.paneContainers.bottom.deserialize(state.paneContainers.bottom, deserializerManager)\r\n    } else if (state.paneContainer) {\r\n      // TODO: Remove this fallback once a lot of time has passed since 1.17 was released\r\n      this.paneContainers.center.deserialize(state.paneContainer, deserializerManager)\r\n    }\r\n\r\n    this.hasActiveTextEditor = this.getActiveTextEditor() != null\r\n\r\n    this.updateWindowTitle()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.updateWindowTitle","start_line":561,"end_line":604,"comment":[" Updates the application's title and proxy icon based on whichever file is"," open."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/deserializer-manager.js","name":"get","line":64,"func_location":"DeserializerManager.deserialize","func_start_line":59,"func_end_line":78,"args":["state"],"comment":[" Public: Deserialize the state and params.",""," * `state` The state {Object} to deserialize."],"code":"  deserialize (state) {\r\n    if (state == null) {\r\n      return\r\n    }\r\n\r\n    const deserializer = this.get(state)\r\n    if (deserializer) {\r\n      let stateVersion = (\r\n        (typeof state.get === 'function') && state.get('version') ||\r\n        state.version\r\n      )\r\n\r\n      if ((deserializer.version != null) && deserializer.version !== stateVersion) {\r\n        return\r\n      }\r\n      return deserializer.deserialize(state, this.atomEnvironment)\r\n    } else {\r\n      return console.warn('No deserializer found for', state)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/deserializer-manager.js","name":"DeserializerManager.get","start_line":83,"end_line":94,"comment":[" Get the deserializer for the state.",""," * `state` The state {Object} being deserialized."],"params":["state"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"setFullScreen","line":1226,"func_location":"AtomEnvironment.deserialize","func_start_line":1223,"func_end_line":1277,"args":["state.fullScreen"],"code":"  async deserialize (state) {\r\n    if (!state) return Promise.resolve()\r\n\r\n    this.setFullScreen(state.fullScreen)\r\n\r\n    const missingProjectPaths = []\r\n\r\n    this.packages.packageStates = state.packageStates || {}\r\n\r\n    let startTime = Date.now()\r\n    if (state.project) {\r\n      try {\r\n        await this.project.deserialize(state.project, this.deserializers)\r\n      } catch (error) {\r\n        if (error.missingProjectPaths) {\r\n          missingProjectPaths.push(...error.missingProjectPaths)\r\n        } else {\r\n          this.notifications.addError('Unable to deserialize project', {\r\n            description: error.message,\r\n            stack: error.stack\r\n          })\r\n        }\r\n      }\r\n    }\r\n\r\n    this.deserializeTimings.project = Date.now() - startTime\r\n\r\n    if (state.grammars) this.grammars.deserialize(state.grammars)\r\n\r\n    startTime = Date.now()\r\n    if (state.workspace) this.workspace.deserialize(state.workspace, this.deserializers)\r\n    this.deserializeTimings.workspace = Date.now() - startTime\r\n\r\n    if (missingProjectPaths.length > 0) {\r\n      const count = missingProjectPaths.length === 1 ? '' : missingProjectPaths.length + ' '\r\n      const noun = missingProjectPaths.length === 1 ? 'directory' : 'directories'\r\n      const toBe = missingProjectPaths.length === 1 ? 'is' : 'are'\r\n      const escaped = missingProjectPaths.map(projectPath => `\\`${projectPath}\\``)\r\n      let group\r\n      switch (escaped.length) {\r\n        case 1:\r\n          group = escaped[0]\r\n          break\r\n        case 2:\r\n          group = `${escaped[0]} and ${escaped[1]}`\r\n          break\r\n        default:\r\n          group = escaped.slice(0, -1).join(', ') + `, and ${escaped[escaped.length - 1]}`\r\n      }\r\n\r\n      this.notifications.addError(`Unable to open ${count}project ${noun}`, {\r\n        description: `Project ${noun} ${group} ${toBe} no longer on disk.`\r\n      })\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.setFullScreen","start_line":646,"end_line":648,"comment":[" Extended: Set the full screen state of the current window."],"params":["fullScreen"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js","name":"constructor","line":9,"func_location":"PaneAxis.deserialize","func_start_line":7,"func_end_line":10},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js","name":"PaneAxis.constructor","start_line":12,"end_line":28,"comment":[],"params":[["orientation","children","flexScale"],"viewRegistry"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"setState","line":427,"func_location":"Dock.deserialize","func_start_line":425,"func_end_line":432},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.setState","start_line":144,"end_line":177,"comment":[],"params":["newState"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"getInitialSize","line":428,"func_location":"Dock.deserialize","func_start_line":425,"func_end_line":432,"args":[],"code":"  deserialize (serialized, deserializerManager) {\r\n    this.paneContainer.deserialize(serialized.paneContainer, deserializerManager)\r\n    this.setState({\r\n      size: serialized.size || this.getInitialSize(),\r\n      // If no items could be deserialized, we don't want to show the dock (even if it was visible last time)\r\n      visible: serialized.visible && (this.paneContainer.getPaneItems().length > 0)\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.getInitialSize","start_line":407,"end_line":414,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"constructor","line":44,"func_location":"Pane.deserialize","func_start_line":26,"func_end_line":51},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.constructor","start_line":53,"end_line":87,"comment":[],"params":["params"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"didDetach","line":4296,"func_location":"OverlayComponent.destroy","func_start_line":4294,"func_end_line":4297,"args":[],"code":"  destroy () {\r\n    this.props.overlayComponents.delete(this)\r\n    this.didDetach()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"OverlayComponent.didDetach","start_line":4329,"end_line":4331,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"getRoot","line":33,"func_location":"PaneContainer.destroy","func_start_line":31,"func_end_line":37,"args":[],"code":"  destroy () {\r\n    this.alive = false\r\n    for (let pane of this.getRoot().getPanes()) { pane.destroy() }\r\n    this.cancelStoppedChangingActivePaneItemTimeout()\r\n    this.subscriptions.dispose()\r\n    this.emitter.dispose()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.getRoot","start_line":129,"end_line":129,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"cancelStoppedChangingActivePaneItemTimeout","line":34,"func_location":"PaneContainer.destroy","func_start_line":31,"func_end_line":37,"args":[],"code":"  destroy () {\r\n    this.alive = false\r\n    for (let pane of this.getRoot().getPanes()) { pane.destroy() }\r\n    this.cancelStoppedChangingActivePaneItemTimeout()\r\n    this.subscriptions.dispose()\r\n    this.emitter.dispose()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.cancelStoppedChangingActivePaneItemTimeout","start_line":294,"end_line":298,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/panel-container.js","name":"getPanels","line":17,"func_location":"PanelContainer.destroy","func_start_line":16,"func_end_line":21,"args":[],"code":"  destroy () {\r\n    for (let panel of this.getPanels()) { panel.destroy() }\r\n    this.subscriptions.dispose()\r\n    this.emitter.emit('did-destroy', this)\r\n    this.emitter.dispose()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/panel-container.js","name":"PanelContainer.getPanels","start_line":54,"end_line":54,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/panel.js","name":"hide","line":31,"func_location":"Panel.destroy","func_start_line":28,"func_end_line":35,"args":[],"comment":[" Public: Destroy and remove this panel from the UI."],"code":"  destroy () {\r\n    if (this.destroyed) return\r\n    this.destroyed = true\r\n    this.hide()\r\n    if (this.element) this.element.remove()\r\n    this.emitter.emit('did-destroy', this)\r\n    return this.emitter.dispose()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/panel.js","name":"Panel.hide","start_line":95,"end_line":100,"comment":[" Public: Hide this panel"],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"uninstallWindowEventHandler","line":383,"func_location":"AtomEnvironment.destroy","func_start_line":369,"func_end_line":384,"args":[],"code":"  destroy () {\r\n    if (!this.project) return\r\n\r\n    this.disposables.dispose()\r\n    if (this.workspace) this.workspace.destroy()\r\n    this.workspace = null\r\n    this.themes.workspace = null\r\n    if (this.project) this.project.destroy()\r\n    this.project = null\r\n    this.commands.clear()\r\n    if (this.stylesElement) this.stylesElement.remove()\r\n    this.autoUpdater.destroy()\r\n    this.uriHandlerRegistry.destroy()\r\n\r\n    this.uninstallWindowEventHandler()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.uninstallWindowEventHandler","start_line":956,"end_line":961,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"getAllWindows","line":164,"func_location":"AtomApplication.destroy","func_start_line":163,"func_end_line":170,"args":[],"code":"  async destroy () {\r\n    const windowsClosePromises = this.getAllWindows().map(window => {\r\n      window.close()\r\n      return window.closedPromise\r\n    })\r\n    await Promise.all(windowsClosePromises)\r\n    this.disposable.dispose()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.getAllWindows","start_line":321,"end_line":323,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"destroyItems","line":1024,"func_location":"Pane.destroy","func_start_line":1022,"func_end_line":1039,"args":[],"comment":[" Public: Close the pane and destroy all its items.",""," If this is the last pane, all the items will be destroyed but the pane"," itself will not be destroyed."],"code":"  destroy () {\r\n    if (this.container && this.container.isAlive() && this.container.getPanes().length === 1) {\r\n      return this.destroyItems()\r\n    }\r\n\r\n    this.emitter.emit('will-destroy')\r\n    this.alive = false\r\n    if (this.container) {\r\n      this.container.willDestroyPane({pane: this})\r\n      if (this.isActive()) this.container.activateNextPane()\r\n    }\r\n    this.emitter.emit('did-destroy')\r\n    this.emitter.dispose()\r\n    for (let item of this.items.slice()) {\r\n      if (typeof item.destroy === 'function') item.destroy()\r\n    }\r\n    if (this.container) this.container.didDestroyPane({pane: this})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.destroyItems","start_line":785,"end_line":789,"comment":[" Public: Destroy all items."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"isActive","line":1031,"func_location":"Pane.destroy","func_start_line":1022,"func_end_line":1039,"args":[],"comment":[" Public: Close the pane and destroy all its items.",""," If this is the last pane, all the items will be destroyed but the pane"," itself will not be destroyed."],"code":"  destroy () {\r\n    if (this.container && this.container.isAlive() && this.container.getPanes().length === 1) {\r\n      return this.destroyItems()\r\n    }\r\n\r\n    this.emitter.emit('will-destroy')\r\n    this.alive = false\r\n    if (this.container) {\r\n      this.container.willDestroyPane({pane: this})\r\n      if (this.isActive()) this.container.activateNextPane()\r\n    }\r\n    this.emitter.emit('did-destroy')\r\n    this.emitter.dispose()\r\n    for (let item of this.items.slice()) {\r\n      if (typeof item.destroy === 'function') item.destroy()\r\n    }\r\n    if (this.container) this.container.didDestroyPane({pane: this})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.isActive","start_line":1007,"end_line":1009,"comment":["\r\n  Section: Lifecycle\r\n  "," Public: Determine whether the pane is active.",""," Returns a {Boolean}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"destroyItem","line":742,"func_location":"Pane.destroyActiveItem","func_start_line":741,"func_end_line":743,"args":[".activeItem"],"comment":[" Public: Destroy the active item and activate the next item.",""," Returns a {Promise} that resolves when the item is destroyed."],"code":"  destroyActiveItem () {\r\n    return this.destroyItem(this.activeItem)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.destroyItem","start_line":757,"end_line":782,"comment":[" Public: Destroy the given item.",""," If the item is active, the next item will be activated. If the item is the"," last item, the pane will be destroyed if the `core.destroyEmptyPanes` config"," setting is `true`.",""," * `item` Item to destroy"," * `force` (optional) {Boolean} Destroy the item without prompting to save","    it, even if the item's `isPermanentDockItem` method returns true.",""," Returns a {Promise} that resolves with a {Boolean} indicating whether or not"," the item was destroyed."],"params":["item","force"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js","name":"getActivePane","line":330,"func_location":"WorkspaceCenter.destroyActivePane","func_start_line":329,"func_end_line":334,"args":[],"comment":[" Destroy (close) the active pane."],"code":"  destroyActivePane () {\r\n    const activePane = this.getActivePane()\r\n    if (activePane != null) {\r\n      activePane.destroy()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js","name":"WorkspaceCenter.getActivePane","start_line":306,"end_line":308,"comment":[" Extended: Get the active {Pane}.",""," Returns a {Pane}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getActivePane","line":1507,"func_location":"Workspace.destroyActivePane","func_start_line":1506,"func_end_line":1511,"args":[],"comment":[" Destroy (close) the active pane."],"code":"  destroyActivePane () {\r\n    const activePane = this.getActivePane()\r\n    if (activePane != null) {\r\n      activePane.destroy()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getActivePane","start_line":1442,"end_line":1444,"comment":[" Extended: Get the active {Pane}.",""," Returns a {Pane}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"getActivePane","line":711,"func_location":"Dock.destroyActivePane","func_start_line":710,"func_end_line":715,"args":[],"comment":[" Destroy (close) the active pane."],"code":"  destroyActivePane () {\r\n    const activePane = this.getActivePane()\r\n    if (activePane != null) {\r\n      activePane.destroy()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.getActivePane","start_line":687,"end_line":689,"comment":[" Extended: Get the active {Pane}.",""," Returns a {Pane}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getActivePane","line":1414,"func_location":"Workspace.destroyActivePaneItem","func_start_line":1413,"func_end_line":1415,"args":[],"comment":[" Destroy (close) the active pane item.",""," Removes the active pane item and calls the `.destroy` method on it if one is"," defined."],"code":"  destroyActivePaneItem () {\r\n    return this.getActivePane().destroyActiveItem()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getActivePane","start_line":1442,"end_line":1444,"comment":[" Extended: Get the active {Pane}.",""," Returns a {Pane}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"cancelStoppedChangingActivePaneItemTimeout","line":1587,"func_location":"Workspace.destroyed","func_start_line":1582,"func_end_line":1592,"args":[],"comment":[" Called by Model superclass when destroyed"],"code":"  destroyed () {\r\n    this.paneContainers.center.destroy()\r\n    this.paneContainers.left.destroy()\r\n    this.paneContainers.right.destroy()\r\n    this.paneContainers.bottom.destroy()\r\n    this.cancelStoppedChangingActivePaneItemTimeout()\r\n    if (this.activeItemSubscriptions != null) {\r\n      this.activeItemSubscriptions.dispose()\r\n    }\r\n    if (this.element) this.element.destroy()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.cancelStoppedChangingActivePaneItemTimeout","start_line":483,"end_line":487,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"getPanes","line":231,"func_location":"PaneContainer.destroyEmptyPanes","func_start_line":230,"func_end_line":232,"args":[],"code":"  destroyEmptyPanes () {\r\n    for (let pane of this.getPanes()) { if (pane.items.length === 0) { pane.destroy() } }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.getPanes","start_line":146,"end_line":152,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getItems","line":794,"func_location":"Pane.destroyInactiveItems","func_start_line":792,"func_end_line":798,"args":[],"comment":[" Public: Destroy all items except for the active item."],"code":"  destroyInactiveItems () {\r\n    return Promise.all(\r\n      this.getItems()\r\n        .filter(item => item !== this.activeItem)\r\n        .map(item => this.destroyItem(item))\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getItems","start_line":425,"end_line":427,"comment":["\r\n  Section: Items\r\n  "," Public: Get the items in this pane.",""," Returns an {Array} of items."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"promptToSaveItem","line":777,"func_location":"Pane.destroyItem","func_start_line":757,"func_end_line":782,"args":["item"],"comment":[" Public: Destroy the given item.",""," If the item is active, the next item will be activated. If the item is the"," last item, the pane will be destroyed if the `core.destroyEmptyPanes` config"," setting is `true`.",""," * `item` Item to destroy"," * `force` (optional) {Boolean} Destroy the item without prompting to save","    it, even if the item's `isPermanentDockItem` method returns true.",""," Returns a {Promise} that resolves with a {Boolean} indicating whether or not"," the item was destroyed."],"code":"  async destroyItem (item, force) {\r\n    const index = this.items.indexOf(item)\r\n    if (index === -1) return false\r\n\r\n    if (!force &&\r\n        typeof item.isPermanentDockItem === 'function' && item.isPermanentDockItem() &&\r\n        (!this.container || this.container.getLocation() !== 'center')) {\r\n      return false\r\n    }\r\n\r\n    // In the case where there are no `onWillDestroyPaneItem` listeners, preserve the old behavior\r\n    // where `Pane.destroyItem` and callers such as `Pane.close` take effect synchronously.\r\n    if (this.emitter.listenerCountForEventName('will-destroy-item') > 0) {\r\n      await this.emitter.emitAsync('will-destroy-item', {item, index})\r\n    }\r\n    if (this.container && this.container.emitter.listenerCountForEventName('will-destroy-pane-item') > 0) {\r\n      await this.container.willDestroyPaneItem({item, index, pane: this})\r\n    }\r\n\r\n    if (!force && typeof item.shouldPromptToSave === 'function' && item.shouldPromptToSave()) {\r\n      if (!await this.promptToSaveItem(item)) return false\r\n    }\r\n    this.removeItem(item, false)\r\n    if (typeof item.destroy === 'function') item.destroy()\r\n    return true\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.promptToSaveItem","start_line":800,"end_line":848,"comment":[],"params":["item","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"removeItem","line":779,"func_location":"Pane.destroyItem","func_start_line":757,"func_end_line":782,"args":["item",{"type":"boolean"}],"comment":[" Public: Destroy the given item.",""," If the item is active, the next item will be activated. If the item is the"," last item, the pane will be destroyed if the `core.destroyEmptyPanes` config"," setting is `true`.",""," * `item` Item to destroy"," * `force` (optional) {Boolean} Destroy the item without prompting to save","    it, even if the item's `isPermanentDockItem` method returns true.",""," Returns a {Promise} that resolves with a {Boolean} indicating whether or not"," the item was destroyed."],"code":"  async destroyItem (item, force) {\r\n    const index = this.items.indexOf(item)\r\n    if (index === -1) return false\r\n\r\n    if (!force &&\r\n        typeof item.isPermanentDockItem === 'function' && item.isPermanentDockItem() &&\r\n        (!this.container || this.container.getLocation() !== 'center')) {\r\n      return false\r\n    }\r\n\r\n    // In the case where there are no `onWillDestroyPaneItem` listeners, preserve the old behavior\r\n    // where `Pane.destroyItem` and callers such as `Pane.close` take effect synchronously.\r\n    if (this.emitter.listenerCountForEventName('will-destroy-item') > 0) {\r\n      await this.emitter.emitAsync('will-destroy-item', {item, index})\r\n    }\r\n    if (this.container && this.container.emitter.listenerCountForEventName('will-destroy-pane-item') > 0) {\r\n      await this.container.willDestroyPaneItem({item, index, pane: this})\r\n    }\r\n\r\n    if (!force && typeof item.shouldPromptToSave === 'function' && item.shouldPromptToSave()) {\r\n      if (!await this.promptToSaveItem(item)) return false\r\n    }\r\n    this.removeItem(item, false)\r\n    if (typeof item.destroy === 'function') item.destroy()\r\n    return true\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.removeItem","start_line":684,"end_line":705,"comment":[],"params":["item","moved"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getItems","line":787,"func_location":"Pane.destroyItems","func_start_line":785,"func_end_line":789,"args":[null],"comment":[" Public: Destroy all items."],"code":"  destroyItems () {\r\n    return Promise.all(\r\n      this.getItems().map(item => this.destroyItem(item))\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getItems","start_line":425,"end_line":427,"comment":["\r\n  Section: Items\r\n  "," Public: Get the items in this pane.",""," Returns an {Array} of items."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"getBuffers","line":75,"func_location":"Project.destroyUnretainedBuffers","func_start_line":74,"func_end_line":78,"args":[],"code":"  destroyUnretainedBuffers () {\r\n    for (let buffer of this.getBuffers()) {\r\n      if (!buffer.isRetained()) buffer.destroy()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.getBuffers","start_line":621,"end_line":623,"comment":[" Retrieves all the {TextBuffer}s in the project; that is, the"," buffers for all open files.",""," Returns an {Array} of {TextBuffer}s."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":47,"func_location":"TextEditorElement.detachedCallback","func_start_line":45,"func_end_line":48,"args":[],"code":"  detachedCallback () {\r\n    this.emitter.emit('did-detach')\r\n    this.getComponent().didDetach()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"getPanes","line":253,"func_location":"PaneContainer.didActivatePane","func_start_line":251,"func_end_line":263,"args":["activePane"],"code":"  didActivatePane (activePane) {\r\n    if (activePane !== this.activePane) {\r\n      if (!this.getPanes().includes(activePane)) {\r\n        throw new Error('Setting active pane that is not present in pane container')\r\n      }\r\n\r\n      this.activePane = activePane\r\n      this.emitter.emit('did-change-active-pane', this.activePane)\r\n      this.didChangeActiveItemOnPane(this.activePane, this.activePane.getActiveItem())\r\n    }\r\n    this.emitter.emit('did-activate-pane', this.activePane)\r\n    return this.activePane\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.getPanes","start_line":146,"end_line":152,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"didChangeActiveItemOnPane","line":259,"func_location":"PaneContainer.didActivatePane","func_start_line":251,"func_end_line":263,"args":[".activePane",null],"code":"  didActivatePane (activePane) {\r\n    if (activePane !== this.activePane) {\r\n      if (!this.getPanes().includes(activePane)) {\r\n        throw new Error('Setting active pane that is not present in pane container')\r\n      }\r\n\r\n      this.activePane = activePane\r\n      this.emitter.emit('did-change-active-pane', this.activePane)\r\n      this.didChangeActiveItemOnPane(this.activePane, this.activePane.getActiveItem())\r\n    }\r\n    this.emitter.emit('did-activate-pane', this.activePane)\r\n    return this.activePane\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.didChangeActiveItemOnPane","start_line":279,"end_line":292,"comment":[],"params":["pane","activeItem"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getActivePaneContainer","line":411,"func_location":"Workspace.didActivatePaneContainer","func_start_line":410,"func_end_line":418,"args":[],"code":"  didActivatePaneContainer (paneContainer) {\r\n    if (paneContainer !== this.getActivePaneContainer()) {\r\n      this.activePaneContainer = paneContainer\r\n      this.didChangeActivePaneItem(this.activePaneContainer.getActivePaneItem())\r\n      this.emitter.emit('did-change-active-pane-container', this.activePaneContainer)\r\n      this.emitter.emit('did-change-active-pane', this.activePaneContainer.getActivePane())\r\n      this.emitter.emit('did-change-active-pane-item', this.activePaneContainer.getActivePaneItem())\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getActivePaneContainer","start_line":1424,"end_line":1426,"comment":["\r\n  Section: Panes\r\n  "," Extended: Get the most recently focused pane container.",""," Returns a {Dock} or the {WorkspaceCenter}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"didChangeActivePaneItem","line":413,"func_location":"Workspace.didActivatePaneContainer","func_start_line":410,"func_end_line":418,"args":[null],"code":"  didActivatePaneContainer (paneContainer) {\r\n    if (paneContainer !== this.getActivePaneContainer()) {\r\n      this.activePaneContainer = paneContainer\r\n      this.didChangeActivePaneItem(this.activePaneContainer.getActivePaneItem())\r\n      this.emitter.emit('did-change-active-pane-container', this.activePaneContainer)\r\n      this.emitter.emit('did-change-active-pane', this.activePaneContainer.getActivePane())\r\n      this.emitter.emit('did-change-active-pane-item', this.activePaneContainer.getActivePaneItem())\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.didChangeActivePaneItem","start_line":443,"end_line":481,"comment":[],"params":["item"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"didAddPaneItem","line":239,"func_location":"PaneContainer.didAddPane","func_start_line":234,"func_end_line":241,"args":["item","event.pane","i"],"code":"  didAddPane (event) {\r\n    this.emitter.emit('did-add-pane', event)\r\n    const items = event.pane.getItems()\r\n    for (let i = 0, length = items.length; i < length; i++) {\r\n      const item = items[i]\r\n      this.didAddPaneItem(item, event.pane, i)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.didAddPaneItem","start_line":265,"end_line":268,"comment":[],"params":["item","pane","index"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"isVisible","line":1428,"func_location":"TextEditorComponent.didAttach","func_start_line":1405,"func_end_line":1441,"args":[],"code":"  didAttach () {\r\n    if (!this.attached) {\r\n      this.attached = true\r\n      this.intersectionObserver = new IntersectionObserver((entries) => {\r\n        const {intersectionRect} = entries[entries.length - 1]\r\n        if (intersectionRect.width > 0 || intersectionRect.height > 0) {\r\n          this.didShow()\r\n        } else {\r\n          this.didHide()\r\n        }\r\n      })\r\n      this.intersectionObserver.observe(this.element)\r\n\r\n      this.resizeObserver = new ResizeObserver(this.didResize.bind(this))\r\n      this.resizeObserver.observe(this.element)\r\n\r\n      if (this.refs.gutterContainer) {\r\n        this.gutterContainerResizeObserver = new ResizeObserver(this.didResizeGutterContainer.bind(this))\r\n        this.gutterContainerResizeObserver.observe(this.refs.gutterContainer.element)\r\n      }\r\n\r\n      this.overlayComponents.forEach((component) => component.didAttach())\r\n\r\n      if (this.isVisible()) {\r\n        this.didShow()\r\n\r\n        if (this.refs.verticalScrollbar) this.refs.verticalScrollbar.flushScrollPosition()\r\n        if (this.refs.horizontalScrollbar) this.refs.horizontalScrollbar.flushScrollPosition()\r\n      } else {\r\n        this.didHide()\r\n      }\r\n      if (!this.constructor.attachedComponents) {\r\n        this.constructor.attachedComponents = new Set()\r\n      }\r\n      this.constructor.attachedComponents.add(this)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.isVisible","start_line":2588,"end_line":2590,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"didShow","line":1429,"func_location":"TextEditorComponent.didAttach","func_start_line":1405,"func_end_line":1441,"args":[],"code":"  didAttach () {\r\n    if (!this.attached) {\r\n      this.attached = true\r\n      this.intersectionObserver = new IntersectionObserver((entries) => {\r\n        const {intersectionRect} = entries[entries.length - 1]\r\n        if (intersectionRect.width > 0 || intersectionRect.height > 0) {\r\n          this.didShow()\r\n        } else {\r\n          this.didHide()\r\n        }\r\n      })\r\n      this.intersectionObserver.observe(this.element)\r\n\r\n      this.resizeObserver = new ResizeObserver(this.didResize.bind(this))\r\n      this.resizeObserver.observe(this.element)\r\n\r\n      if (this.refs.gutterContainer) {\r\n        this.gutterContainerResizeObserver = new ResizeObserver(this.didResizeGutterContainer.bind(this))\r\n        this.gutterContainerResizeObserver.observe(this.refs.gutterContainer.element)\r\n      }\r\n\r\n      this.overlayComponents.forEach((component) => component.didAttach())\r\n\r\n      if (this.isVisible()) {\r\n        this.didShow()\r\n\r\n        if (this.refs.verticalScrollbar) this.refs.verticalScrollbar.flushScrollPosition()\r\n        if (this.refs.horizontalScrollbar) this.refs.horizontalScrollbar.flushScrollPosition()\r\n      } else {\r\n        this.didHide()\r\n      }\r\n      if (!this.constructor.attachedComponents) {\r\n        this.constructor.attachedComponents = new Set()\r\n      }\r\n      this.constructor.attachedComponents.add(this)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.didShow","start_line":1456,"end_line":1465,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"didHide","line":1434,"func_location":"TextEditorComponent.didAttach","func_start_line":1405,"func_end_line":1441,"args":[],"code":"  didAttach () {\r\n    if (!this.attached) {\r\n      this.attached = true\r\n      this.intersectionObserver = new IntersectionObserver((entries) => {\r\n        const {intersectionRect} = entries[entries.length - 1]\r\n        if (intersectionRect.width > 0 || intersectionRect.height > 0) {\r\n          this.didShow()\r\n        } else {\r\n          this.didHide()\r\n        }\r\n      })\r\n      this.intersectionObserver.observe(this.element)\r\n\r\n      this.resizeObserver = new ResizeObserver(this.didResize.bind(this))\r\n      this.resizeObserver.observe(this.element)\r\n\r\n      if (this.refs.gutterContainer) {\r\n        this.gutterContainerResizeObserver = new ResizeObserver(this.didResizeGutterContainer.bind(this))\r\n        this.gutterContainerResizeObserver.observe(this.refs.gutterContainer.element)\r\n      }\r\n\r\n      this.overlayComponents.forEach((component) => component.didAttach())\r\n\r\n      if (this.isVisible()) {\r\n        this.didShow()\r\n\r\n        if (this.refs.verticalScrollbar) this.refs.verticalScrollbar.flushScrollPosition()\r\n        if (this.refs.horizontalScrollbar) this.refs.horizontalScrollbar.flushScrollPosition()\r\n      } else {\r\n        this.didHide()\r\n      }\r\n      if (!this.constructor.attachedComponents) {\r\n        this.constructor.attachedComponents = new Set()\r\n      }\r\n      this.constructor.attachedComponents.add(this)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.didHide","start_line":1467,"end_line":1472,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getHiddenInput","line":1501,"func_location":"TextEditorComponent.didBlur","func_start_line":1500,"func_end_line":1504,"args":[],"comment":[" Called by TextEditorElement so that this function is always the first"," listener to be fired, even if other listeners are bound before creating"," the component."],"code":"  didBlur (event) {\r\n    if (event.relatedTarget === this.getHiddenInput()) {\r\n      event.stopImmediatePropagation()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getHiddenInput","start_line":2960,"end_line":2962,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"stopCursorBlinking","line":1509,"func_location":"TextEditorComponent.didBlurHiddenInput","func_start_line":1506,"func_end_line":1513,"args":[],"code":"  didBlurHiddenInput (event) {\r\n    if (this.element !== event.relatedTarget && !this.element.contains(event.relatedTarget)) {\r\n      this.focused = false\r\n      this.stopCursorBlinking()\r\n      this.scheduleUpdate()\r\n      this.element.dispatchEvent(new FocusEvent(event.type, event))\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.stopCursorBlinking","start_line":1991,"end_line":1999,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"scheduleUpdate","line":1510,"func_location":"TextEditorComponent.didBlurHiddenInput","func_start_line":1506,"func_end_line":1513,"args":[],"code":"  didBlurHiddenInput (event) {\r\n    if (this.element !== event.relatedTarget && !this.element.contains(event.relatedTarget)) {\r\n      this.focused = false\r\n      this.stopCursorBlinking()\r\n      this.scheduleUpdate()\r\n      this.element.dispatchEvent(new FocusEvent(event.type, event))\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.scheduleUpdate","start_line":204,"end_line":219,"comment":[],"params":["nextUpdateOnlyBlinksCursors"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"getActivePane","line":280,"func_location":"PaneContainer.didChangeActiveItemOnPane","func_start_line":279,"func_end_line":292,"args":[],"code":"  didChangeActiveItemOnPane (pane, activeItem) {\r\n    if (pane === this.getActivePane()) {\r\n      this.emitter.emit('did-change-active-pane-item', activeItem)\r\n\r\n      this.cancelStoppedChangingActivePaneItemTimeout()\r\n      // `setTimeout()` isn't available during the snapshotting phase, but that's okay.\r\n      if (typeof setTimeout === 'function') {\r\n        this.stoppedChangingActivePaneItemTimeout = setTimeout(() => {\r\n          this.stoppedChangingActivePaneItemTimeout = null\r\n          this.emitter.emit('did-stop-changing-active-pane-item', activeItem)\r\n        }, STOPPED_CHANGING_ACTIVE_PANE_ITEM_DELAY)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.getActivePane","start_line":158,"end_line":160,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"cancelStoppedChangingActivePaneItemTimeout","line":283,"func_location":"PaneContainer.didChangeActiveItemOnPane","func_start_line":279,"func_end_line":292,"args":[],"code":"  didChangeActiveItemOnPane (pane, activeItem) {\r\n    if (pane === this.getActivePane()) {\r\n      this.emitter.emit('did-change-active-pane-item', activeItem)\r\n\r\n      this.cancelStoppedChangingActivePaneItemTimeout()\r\n      // `setTimeout()` isn't available during the snapshotting phase, but that's okay.\r\n      if (typeof setTimeout === 'function') {\r\n        this.stoppedChangingActivePaneItemTimeout = setTimeout(() => {\r\n          this.stoppedChangingActivePaneItemTimeout = null\r\n          this.emitter.emit('did-stop-changing-active-pane-item', activeItem)\r\n        }, STOPPED_CHANGING_ACTIVE_PANE_ITEM_DELAY)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.cancelStoppedChangingActivePaneItemTimeout","start_line":294,"end_line":298,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"updateWindowTitle","line":444,"func_location":"Workspace.didChangeActivePaneItem","func_start_line":443,"func_end_line":481,"args":[],"code":"  didChangeActivePaneItem (item) {\r\n    this.updateWindowTitle()\r\n    this.updateDocumentEdited()\r\n    if (this.activeItemSubscriptions) this.activeItemSubscriptions.dispose()\r\n    this.activeItemSubscriptions = new CompositeDisposable()\r\n\r\n    let modifiedSubscription, titleSubscription\r\n\r\n    if (item != null && typeof item.onDidChangeTitle === 'function') {\r\n      titleSubscription = item.onDidChangeTitle(this.updateWindowTitle)\r\n    } else if (item != null && typeof item.on === 'function') {\r\n      titleSubscription = item.on('title-changed', this.updateWindowTitle)\r\n      if (titleSubscription == null || typeof titleSubscription.dispose !== 'function') {\r\n        titleSubscription = new Disposable(() => {\r\n          item.off('title-changed', this.updateWindowTitle)\r\n        })\r\n      }\r\n    }\r\n\r\n    if (item != null && typeof item.onDidChangeModified === 'function') {\r\n      modifiedSubscription = item.onDidChangeModified(this.updateDocumentEdited)\r\n    } else if (item != null && typeof item.on === 'function') {\r\n      modifiedSubscription = item.on('modified-status-changed', this.updateDocumentEdited)\r\n      if (modifiedSubscription == null || typeof modifiedSubscription.dispose !== 'function') {\r\n        modifiedSubscription = new Disposable(() => {\r\n          item.off('modified-status-changed', this.updateDocumentEdited)\r\n        })\r\n      }\r\n    }\r\n\r\n    if (titleSubscription != null) { this.activeItemSubscriptions.add(titleSubscription) }\r\n    if (modifiedSubscription != null) { this.activeItemSubscriptions.add(modifiedSubscription) }\r\n\r\n    this.cancelStoppedChangingActivePaneItemTimeout()\r\n    this.stoppedChangingActivePaneItemTimeout = setTimeout(() => {\r\n      this.stoppedChangingActivePaneItemTimeout = null\r\n      this.emitter.emit('did-stop-changing-active-pane-item', item)\r\n    }, STOPPED_CHANGING_ACTIVE_PANE_ITEM_DELAY)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.updateWindowTitle","start_line":561,"end_line":604,"comment":[" Updates the application's title and proxy icon based on whichever file is"," open."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"updateDocumentEdited","line":445,"func_location":"Workspace.didChangeActivePaneItem","func_start_line":443,"func_end_line":481,"args":[],"code":"  didChangeActivePaneItem (item) {\r\n    this.updateWindowTitle()\r\n    this.updateDocumentEdited()\r\n    if (this.activeItemSubscriptions) this.activeItemSubscriptions.dispose()\r\n    this.activeItemSubscriptions = new CompositeDisposable()\r\n\r\n    let modifiedSubscription, titleSubscription\r\n\r\n    if (item != null && typeof item.onDidChangeTitle === 'function') {\r\n      titleSubscription = item.onDidChangeTitle(this.updateWindowTitle)\r\n    } else if (item != null && typeof item.on === 'function') {\r\n      titleSubscription = item.on('title-changed', this.updateWindowTitle)\r\n      if (titleSubscription == null || typeof titleSubscription.dispose !== 'function') {\r\n        titleSubscription = new Disposable(() => {\r\n          item.off('title-changed', this.updateWindowTitle)\r\n        })\r\n      }\r\n    }\r\n\r\n    if (item != null && typeof item.onDidChangeModified === 'function') {\r\n      modifiedSubscription = item.onDidChangeModified(this.updateDocumentEdited)\r\n    } else if (item != null && typeof item.on === 'function') {\r\n      modifiedSubscription = item.on('modified-status-changed', this.updateDocumentEdited)\r\n      if (modifiedSubscription == null || typeof modifiedSubscription.dispose !== 'function') {\r\n        modifiedSubscription = new Disposable(() => {\r\n          item.off('modified-status-changed', this.updateDocumentEdited)\r\n        })\r\n      }\r\n    }\r\n\r\n    if (titleSubscription != null) { this.activeItemSubscriptions.add(titleSubscription) }\r\n    if (modifiedSubscription != null) { this.activeItemSubscriptions.add(modifiedSubscription) }\r\n\r\n    this.cancelStoppedChangingActivePaneItemTimeout()\r\n    this.stoppedChangingActivePaneItemTimeout = setTimeout(() => {\r\n      this.stoppedChangingActivePaneItemTimeout = null\r\n      this.emitter.emit('did-stop-changing-active-pane-item', item)\r\n    }, STOPPED_CHANGING_ACTIVE_PANE_ITEM_DELAY)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.updateDocumentEdited","start_line":608,"end_line":614,"comment":[" On macOS, fades the application window's proxy icon when the current file"," has been modified."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"cancelStoppedChangingActivePaneItemTimeout","line":476,"func_location":"Workspace.didChangeActivePaneItem","func_start_line":443,"func_end_line":481,"args":[],"code":"  didChangeActivePaneItem (item) {\r\n    this.updateWindowTitle()\r\n    this.updateDocumentEdited()\r\n    if (this.activeItemSubscriptions) this.activeItemSubscriptions.dispose()\r\n    this.activeItemSubscriptions = new CompositeDisposable()\r\n\r\n    let modifiedSubscription, titleSubscription\r\n\r\n    if (item != null && typeof item.onDidChangeTitle === 'function') {\r\n      titleSubscription = item.onDidChangeTitle(this.updateWindowTitle)\r\n    } else if (item != null && typeof item.on === 'function') {\r\n      titleSubscription = item.on('title-changed', this.updateWindowTitle)\r\n      if (titleSubscription == null || typeof titleSubscription.dispose !== 'function') {\r\n        titleSubscription = new Disposable(() => {\r\n          item.off('title-changed', this.updateWindowTitle)\r\n        })\r\n      }\r\n    }\r\n\r\n    if (item != null && typeof item.onDidChangeModified === 'function') {\r\n      modifiedSubscription = item.onDidChangeModified(this.updateDocumentEdited)\r\n    } else if (item != null && typeof item.on === 'function') {\r\n      modifiedSubscription = item.on('modified-status-changed', this.updateDocumentEdited)\r\n      if (modifiedSubscription == null || typeof modifiedSubscription.dispose !== 'function') {\r\n        modifiedSubscription = new Disposable(() => {\r\n          item.off('modified-status-changed', this.updateDocumentEdited)\r\n        })\r\n      }\r\n    }\r\n\r\n    if (titleSubscription != null) { this.activeItemSubscriptions.add(titleSubscription) }\r\n    if (modifiedSubscription != null) { this.activeItemSubscriptions.add(modifiedSubscription) }\r\n\r\n    this.cancelStoppedChangingActivePaneItemTimeout()\r\n    this.stoppedChangingActivePaneItemTimeout = setTimeout(() => {\r\n      this.stoppedChangingActivePaneItemTimeout = null\r\n      this.emitter.emit('did-stop-changing-active-pane-item', item)\r\n    }, STOPPED_CHANGING_ACTIVE_PANE_ITEM_DELAY)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.cancelStoppedChangingActivePaneItemTimeout","start_line":483,"end_line":487,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getActivePaneContainer","line":427,"func_location":"Workspace.didChangeActivePaneItemOnPaneContainer","func_start_line":426,"func_end_line":441,"args":[],"code":"  didChangeActivePaneItemOnPaneContainer (paneContainer, item) {\r\n    if (paneContainer === this.getActivePaneContainer()) {\r\n      this.didChangeActivePaneItem(item)\r\n      this.emitter.emit('did-change-active-pane-item', item)\r\n    }\r\n\r\n    if (paneContainer === this.getCenter()) {\r\n      const hadActiveTextEditor = this.hasActiveTextEditor\r\n      this.hasActiveTextEditor = item instanceof TextEditor\r\n\r\n      if (this.hasActiveTextEditor || hadActiveTextEditor) {\r\n        const itemValue = this.hasActiveTextEditor ? item : undefined\r\n        this.emitter.emit('did-change-active-text-editor', itemValue)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getActivePaneContainer","start_line":1424,"end_line":1426,"comment":["\r\n  Section: Panes\r\n  "," Extended: Get the most recently focused pane container.",""," Returns a {Dock} or the {WorkspaceCenter}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"didChangeActivePaneItem","line":428,"func_location":"Workspace.didChangeActivePaneItemOnPaneContainer","func_start_line":426,"func_end_line":441,"args":["item"],"code":"  didChangeActivePaneItemOnPaneContainer (paneContainer, item) {\r\n    if (paneContainer === this.getActivePaneContainer()) {\r\n      this.didChangeActivePaneItem(item)\r\n      this.emitter.emit('did-change-active-pane-item', item)\r\n    }\r\n\r\n    if (paneContainer === this.getCenter()) {\r\n      const hadActiveTextEditor = this.hasActiveTextEditor\r\n      this.hasActiveTextEditor = item instanceof TextEditor\r\n\r\n      if (this.hasActiveTextEditor || hadActiveTextEditor) {\r\n        const itemValue = this.hasActiveTextEditor ? item : undefined\r\n        this.emitter.emit('did-change-active-text-editor', itemValue)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.didChangeActivePaneItem","start_line":443,"end_line":481,"comment":[],"params":["item"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getCenter","line":432,"func_location":"Workspace.didChangeActivePaneItemOnPaneContainer","func_start_line":426,"func_end_line":441,"args":[],"code":"  didChangeActivePaneItemOnPaneContainer (paneContainer, item) {\r\n    if (paneContainer === this.getActivePaneContainer()) {\r\n      this.didChangeActivePaneItem(item)\r\n      this.emitter.emit('did-change-active-pane-item', item)\r\n    }\r\n\r\n    if (paneContainer === this.getCenter()) {\r\n      const hadActiveTextEditor = this.hasActiveTextEditor\r\n      this.hasActiveTextEditor = item instanceof TextEditor\r\n\r\n      if (this.hasActiveTextEditor || hadActiveTextEditor) {\r\n        const itemValue = this.hasActiveTextEditor ? item : undefined\r\n        this.emitter.emit('did-change-active-text-editor', itemValue)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getCenter","start_line":1599,"end_line":1601,"comment":["\r\n  Section: Pane Locations\r\n  "," Essential: Get the {WorkspaceCenter} at the center of the editor window."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getActivePaneContainer","line":421,"func_location":"Workspace.didChangeActivePaneOnPaneContainer","func_start_line":420,"func_end_line":424,"args":[],"code":"  didChangeActivePaneOnPaneContainer (paneContainer, pane) {\r\n    if (paneContainer === this.getActivePaneContainer()) {\r\n      this.emitter.emit('did-change-active-pane', pane)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getActivePaneContainer","start_line":1424,"end_line":1426,"comment":["\r\n  Section: Panes\r\n  "," Extended: Get the most recently focused pane container.",""," Returns a {Dock} or the {WorkspaceCenter}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"spliceLineTopIndex","line":2466,"func_location":"TextEditorComponent.didChangeDisplayLayer","func_start_line":2463,"func_end_line":2474},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.spliceLineTopIndex","start_line":2580,"end_line":2586,"comment":[],"params":["startRow","oldExtent","newExtent"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"scheduleUpdate","line":2473,"func_location":"TextEditorComponent.didChangeDisplayLayer","func_start_line":2463,"func_end_line":2474,"args":[],"code":"  didChangeDisplayLayer (changes) {\r\n    for (let i = 0; i < changes.length; i++) {\r\n      const {oldRange, newRange} = changes[i]\r\n      this.spliceLineTopIndex(\r\n        newRange.start.row,\r\n        oldRange.end.row - oldRange.start.row,\r\n        newRange.end.row - newRange.start.row\r\n      )\r\n    }\r\n\r\n    this.scheduleUpdate()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.scheduleUpdate","start_line":204,"end_line":219,"comment":[],"params":["nextUpdateOnlyBlinksCursors"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getPlatform","line":2479,"func_location":"TextEditorComponent.didChangeSelectionRange","func_start_line":2476,"func_end_line":2498,"args":[],"code":"  didChangeSelectionRange () {\r\n    const {model} = this.props\r\n\r\n    if (this.getPlatform() === 'linux') {\r\n      if (this.selectionClipboardImmediateId) {\r\n        clearImmediate(this.selectionClipboardImmediateId)\r\n      }\r\n\r\n      this.selectionClipboardImmediateId = setImmediate(() => {\r\n        this.selectionClipboardImmediateId = null\r\n\r\n        if (model.isDestroyed()) return\r\n\r\n        const selectedText = model.getSelectedText()\r\n        if (selectedText) {\r\n          // This uses ipcRenderer.send instead of clipboard.writeText because\r\n          // clipboard.writeText is a sync ipcRenderer call on Linux and that\r\n          // will slow down selections.\r\n          electron.ipcRenderer.send('write-text-to-selection-clipboard', selectedText)\r\n        }\r\n      })\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getPlatform","start_line":2964,"end_line":2966,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"sendMessage","line":258,"func_location":"AtomWindow.didChangeUserSettings","func_start_line":257,"func_end_line":259,"args":[{"type":"string"},"settings"],"code":"  didChangeUserSettings (settings) {\r\n    this.sendMessage('did-change-user-settings', settings)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"AtomWindow.sendMessage","start_line":269,"end_line":271,"comment":[],"params":["message","detail"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getHiddenInput","line":1720,"func_location":"TextEditorComponent.didCompositionStart","func_start_line":1716,"func_end_line":1734,"args":[],"comment":[" The IME composition events work like this:",""," User types 's', chromium pops up the completion helper","   1. compositionstart fired","   2. compositionupdate fired; event.data == 's'"," User hits arrow keys to move around in completion helper","   3. compositionupdate fired; event.data == 's' for each arry key press"," User escape to cancel OR User chooses a completion","   4. compositionend fired","   5. textInput fired; event.data == the completion string"],"code":"  didCompositionStart () {\r\n    // Workaround for Chromium not preventing composition events when\r\n    // preventDefault is called on the keydown event that precipitated them.\r\n    if (this.lastKeydown && this.lastKeydown.defaultPrevented) {\r\n      this.getHiddenInput().disabled = true\r\n      process.nextTick(() => {\r\n        // Disabling the hidden input makes it lose focus as well, so we have to\r\n        // re-enable and re-focus it.\r\n        this.getHiddenInput().disabled = false\r\n        this.getHiddenInput().focus()\r\n      })\r\n      return\r\n    }\r\n\r\n    this.compositionCheckpoint = this.props.model.createCheckpoint()\r\n    if (this.accentedCharacterMenuIsOpen) {\r\n      this.props.model.selectLeft()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getHiddenInput","start_line":2960,"end_line":2962,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js","name":"unobserveDecoratedLayer","line":261,"func_location":"DecorationManager.didDestroyLayerDecoration","func_start_line":252,"func_end_line":264,"args":["markerLayer",{"type":"boolean"}],"code":"  didDestroyLayerDecoration (decoration) {\r\n    const {markerLayer} = decoration\r\n    const decorations = this.layerDecorationsByMarkerLayer.get(markerLayer)\r\n\r\n    if (decorations && decorations.has(decoration)) {\r\n      decorations.delete(decoration)\r\n      if (decorations.size === 0) {\r\n        this.layerDecorationsByMarkerLayer.delete(markerLayer)\r\n      }\r\n      this.unobserveDecoratedLayer(markerLayer, true)\r\n      this.emitDidUpdateDecorations()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js","name":"DecorationManager.unobserveDecoratedLayer","start_line":277,"end_line":288,"comment":[],"params":["layer","isMarkerDecoration"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js","name":"emitDidUpdateDecorations","line":262,"func_location":"DecorationManager.didDestroyLayerDecoration","func_start_line":252,"func_end_line":264,"args":[],"code":"  didDestroyLayerDecoration (decoration) {\r\n    const {markerLayer} = decoration\r\n    const decorations = this.layerDecorationsByMarkerLayer.get(markerLayer)\r\n\r\n    if (decorations && decorations.has(decoration)) {\r\n      decorations.delete(decoration)\r\n      if (decorations.size === 0) {\r\n        this.layerDecorationsByMarkerLayer.delete(markerLayer)\r\n      }\r\n      this.unobserveDecoratedLayer(markerLayer, true)\r\n      this.emitDidUpdateDecorations()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js","name":"DecorationManager.emitDidUpdateDecorations","start_line":226,"end_line":229,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js","name":"unobserveDecoratedLayer","line":246,"func_location":"DecorationManager.didDestroyMarkerDecoration","func_start_line":239,"func_end_line":250,"args":["marker.layer",{"type":"boolean"}],"code":"  didDestroyMarkerDecoration (decoration) {\r\n    const {marker} = decoration\r\n    const decorations = this.decorationsByMarker.get(marker)\r\n    if (decorations && decorations.has(decoration)) {\r\n      decorations.delete(decoration)\r\n      if (decorations.size === 0) this.decorationsByMarker.delete(marker)\r\n      this.overlayDecorations.delete(decoration)\r\n      this.unobserveDecoratedLayer(marker.layer, true)\r\n      this.emitter.emit('did-remove-decoration', decoration)\r\n      this.emitDidUpdateDecorations()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js","name":"DecorationManager.unobserveDecoratedLayer","start_line":277,"end_line":288,"comment":[],"params":["layer","isMarkerDecoration"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js","name":"emitDidUpdateDecorations","line":248,"func_location":"DecorationManager.didDestroyMarkerDecoration","func_start_line":239,"func_end_line":250,"args":[],"code":"  didDestroyMarkerDecoration (decoration) {\r\n    const {marker} = decoration\r\n    const decorations = this.decorationsByMarker.get(marker)\r\n    if (decorations && decorations.has(decoration)) {\r\n      decorations.delete(decoration)\r\n      if (decorations.size === 0) this.decorationsByMarker.delete(marker)\r\n      this.overlayDecorations.delete(decoration)\r\n      this.unobserveDecoratedLayer(marker.layer, true)\r\n      this.emitter.emit('did-remove-decoration', decoration)\r\n      this.emitDidUpdateDecorations()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js","name":"DecorationManager.emitDidUpdateDecorations","start_line":226,"end_line":229,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"didHide","line":1450,"func_location":"TextEditorComponent.didDetach","func_start_line":1443,"func_end_line":1454,"args":[],"code":"  didDetach () {\r\n    if (this.attached) {\r\n      this.intersectionObserver.disconnect()\r\n      this.resizeObserver.disconnect()\r\n      if (this.gutterContainerResizeObserver) this.gutterContainerResizeObserver.disconnect()\r\n      this.overlayComponents.forEach((component) => component.didDetach())\r\n\r\n      this.didHide()\r\n      this.attached = false\r\n      this.constructor.attachedComponents.delete(this)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.didHide","start_line":1467,"end_line":1472,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"sendMessage","line":262,"func_location":"AtomWindow.didFailToReadUserSettings","func_start_line":261,"func_end_line":263,"args":[{"type":"string"},"message"],"code":"  didFailToReadUserSettings (message) {\r\n    this.sendMessage('did-fail-to-read-user-settings', message)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"AtomWindow.sendMessage","start_line":269,"end_line":271,"comment":[],"params":["message","detail"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"didAttach","line":1480,"func_location":"TextEditorComponent.didFocus","func_start_line":1476,"func_end_line":1495,"args":[],"comment":[" Called by TextEditorElement so that focus events can be handled before"," the element is attached to the DOM."],"code":"  didFocus () {\r\n    // This element can be focused from a parent custom element's\r\n    // attachedCallback before *its* attachedCallback is fired. This protects\r\n    // against that case.\r\n    if (!this.attached) this.didAttach()\r\n\r\n    // The element can be focused before the intersection observer detects that\r\n    // it has been shown for the first time. If this element is being focused,\r\n    // it is necessarily visible, so we call `didShow` to ensure the hidden\r\n    // input is rendered before we try to shift focus to it.\r\n    if (!this.visible) this.didShow()\r\n\r\n    if (!this.focused) {\r\n      this.focused = true\r\n      this.startCursorBlinking()\r\n      this.scheduleUpdate()\r\n    }\r\n\r\n    this.getHiddenInput().focus()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.didAttach","start_line":1405,"end_line":1441,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"didShow","line":1486,"func_location":"TextEditorComponent.didFocus","func_start_line":1476,"func_end_line":1495,"args":[],"comment":[" Called by TextEditorElement so that focus events can be handled before"," the element is attached to the DOM."],"code":"  didFocus () {\r\n    // This element can be focused from a parent custom element's\r\n    // attachedCallback before *its* attachedCallback is fired. This protects\r\n    // against that case.\r\n    if (!this.attached) this.didAttach()\r\n\r\n    // The element can be focused before the intersection observer detects that\r\n    // it has been shown for the first time. If this element is being focused,\r\n    // it is necessarily visible, so we call `didShow` to ensure the hidden\r\n    // input is rendered before we try to shift focus to it.\r\n    if (!this.visible) this.didShow()\r\n\r\n    if (!this.focused) {\r\n      this.focused = true\r\n      this.startCursorBlinking()\r\n      this.scheduleUpdate()\r\n    }\r\n\r\n    this.getHiddenInput().focus()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.didShow","start_line":1456,"end_line":1465,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"startCursorBlinking","line":1490,"func_location":"TextEditorComponent.didFocus","func_start_line":1476,"func_end_line":1495,"args":[],"comment":[" Called by TextEditorElement so that focus events can be handled before"," the element is attached to the DOM."],"code":"  didFocus () {\r\n    // This element can be focused from a parent custom element's\r\n    // attachedCallback before *its* attachedCallback is fired. This protects\r\n    // against that case.\r\n    if (!this.attached) this.didAttach()\r\n\r\n    // The element can be focused before the intersection observer detects that\r\n    // it has been shown for the first time. If this element is being focused,\r\n    // it is necessarily visible, so we call `didShow` to ensure the hidden\r\n    // input is rendered before we try to shift focus to it.\r\n    if (!this.visible) this.didShow()\r\n\r\n    if (!this.focused) {\r\n      this.focused = true\r\n      this.startCursorBlinking()\r\n      this.scheduleUpdate()\r\n    }\r\n\r\n    this.getHiddenInput().focus()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.startCursorBlinking","start_line":2001,"end_line":2010,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"scheduleUpdate","line":1491,"func_location":"TextEditorComponent.didFocus","func_start_line":1476,"func_end_line":1495,"args":[],"comment":[" Called by TextEditorElement so that focus events can be handled before"," the element is attached to the DOM."],"code":"  didFocus () {\r\n    // This element can be focused from a parent custom element's\r\n    // attachedCallback before *its* attachedCallback is fired. This protects\r\n    // against that case.\r\n    if (!this.attached) this.didAttach()\r\n\r\n    // The element can be focused before the intersection observer detects that\r\n    // it has been shown for the first time. If this element is being focused,\r\n    // it is necessarily visible, so we call `didShow` to ensure the hidden\r\n    // input is rendered before we try to shift focus to it.\r\n    if (!this.visible) this.didShow()\r\n\r\n    if (!this.focused) {\r\n      this.focused = true\r\n      this.startCursorBlinking()\r\n      this.scheduleUpdate()\r\n    }\r\n\r\n    this.getHiddenInput().focus()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.scheduleUpdate","start_line":204,"end_line":219,"comment":[],"params":["nextUpdateOnlyBlinksCursors"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getHiddenInput","line":1494,"func_location":"TextEditorComponent.didFocus","func_start_line":1476,"func_end_line":1495,"args":[],"comment":[" Called by TextEditorElement so that focus events can be handled before"," the element is attached to the DOM."],"code":"  didFocus () {\r\n    // This element can be focused from a parent custom element's\r\n    // attachedCallback before *its* attachedCallback is fired. This protects\r\n    // against that case.\r\n    if (!this.attached) this.didAttach()\r\n\r\n    // The element can be focused before the intersection observer detects that\r\n    // it has been shown for the first time. If this element is being focused,\r\n    // it is necessarily visible, so we call `didShow` to ensure the hidden\r\n    // input is rendered before we try to shift focus to it.\r\n    if (!this.visible) this.didShow()\r\n\r\n    if (!this.focused) {\r\n      this.focused = true\r\n      this.startCursorBlinking()\r\n      this.scheduleUpdate()\r\n    }\r\n\r\n    this.getHiddenInput().focus()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getHiddenInput","start_line":2960,"end_line":2962,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"startCursorBlinking","line":1524,"func_location":"TextEditorComponent.didFocusHiddenInput","func_start_line":1515,"func_end_line":1527,"args":[],"code":"  didFocusHiddenInput () {\r\n    // Focusing the hidden input when it is off-screen causes the browser to\r\n    // scroll it into view. Since we use synthetic scrolling this behavior\r\n    // causes all the lines to disappear so we counteract it by always setting\r\n    // the scroll position to 0.\r\n    this.refs.scrollContainer.scrollTop = 0\r\n    this.refs.scrollContainer.scrollLeft = 0\r\n    if (!this.focused) {\r\n      this.focused = true\r\n      this.startCursorBlinking()\r\n      this.scheduleUpdate()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.startCursorBlinking","start_line":2001,"end_line":2010,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"scheduleUpdate","line":1525,"func_location":"TextEditorComponent.didFocusHiddenInput","func_start_line":1515,"func_end_line":1527,"args":[],"code":"  didFocusHiddenInput () {\r\n    // Focusing the hidden input when it is off-screen causes the browser to\r\n    // scroll it into view. Since we use synthetic scrolling this behavior\r\n    // causes all the lines to disappear so we counteract it by always setting\r\n    // the scroll position to 0.\r\n    this.refs.scrollContainer.scrollTop = 0\r\n    this.refs.scrollContainer.scrollLeft = 0\r\n    if (!this.focused) {\r\n      this.focused = true\r\n      this.startCursorBlinking()\r\n      this.scheduleUpdate()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.scheduleUpdate","start_line":204,"end_line":219,"comment":[],"params":["nextUpdateOnlyBlinksCursors"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRealScrollbarHeight","line":3055,"func_location":"DummyScrollbarComponent.didMouseDown","func_start_line":3052,"func_end_line":3058,"args":[],"code":"  didMouseDown (event) {\r\n    let {bottom, right} = this.element.getBoundingClientRect()\r\n    const clickedOnScrollbar = (this.props.orientation === 'horizontal')\r\n      ? event.clientY >= (bottom - this.getRealScrollbarHeight())\r\n      : event.clientX >= (right - this.getRealScrollbarWidth())\r\n    if (!clickedOnScrollbar) this.props.didMouseDown(event)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"DummyScrollbarComponent.getRealScrollbarHeight","start_line":3064,"end_line":3066,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRealScrollbarWidth","line":3056,"func_location":"DummyScrollbarComponent.didMouseDown","func_start_line":3052,"func_end_line":3058,"args":[],"code":"  didMouseDown (event) {\r\n    let {bottom, right} = this.element.getBoundingClientRect()\r\n    const clickedOnScrollbar = (this.props.orientation === 'horizontal')\r\n      ? event.clientY >= (bottom - this.getRealScrollbarHeight())\r\n      : event.clientX >= (right - this.getRealScrollbarWidth())\r\n    if (!clickedOnScrollbar) this.props.didMouseDown(event)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"DummyScrollbarComponent.getRealScrollbarWidth","start_line":3060,"end_line":3062,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getPlatform","line":1747,"func_location":"TextEditorComponent.didMouseDownOnContent","func_start_line":1744,"func_end_line":1826,"args":[],"code":"  didMouseDownOnContent (event) {\r\n    const {model} = this.props\r\n    const {target, button, detail, ctrlKey, shiftKey, metaKey} = event\r\n    const platform = this.getPlatform()\r\n\r\n    // Ignore clicks on block decorations.\r\n    if (target) {\r\n      let element = target\r\n      while (element && element !== this.element) {\r\n        if (this.blockDecorationsByElement.has(element)) {\r\n          return\r\n        }\r\n\r\n        element = element.parentElement\r\n      }\r\n    }\r\n\r\n    const screenPosition = this.screenPositionForMouseEvent(event)\r\n\r\n    if (button === 1) {\r\n      model.setCursorScreenPosition(screenPosition, {autoscroll: false})\r\n\r\n      // On Linux, pasting happens on middle click. A textInput event with the\r\n      // contents of the selection clipboard will be dispatched by the browser\r\n      // automatically on mouseup.\r\n      if (platform === 'linux' && this.isInputEnabled()) model.insertText(clipboard.readText('selection'))\r\n      return\r\n    }\r\n\r\n    if (button !== 0) return\r\n\r\n    // Ctrl-click brings up the context menu on macOS\r\n    if (platform === 'darwin' && ctrlKey) return\r\n\r\n    if (target && target.matches('.fold-marker')) {\r\n      const bufferPosition = model.bufferPositionForScreenPosition(screenPosition)\r\n      model.destroyFoldsContainingBufferPositions([bufferPosition], false)\r\n      return\r\n    }\r\n\r\n    const addOrRemoveSelection = metaKey || (ctrlKey && platform !== 'darwin')\r\n\r\n    switch (detail) {\r\n      case 1:\r\n        if (addOrRemoveSelection) {\r\n          const existingSelection = model.getSelectionAtScreenPosition(screenPosition)\r\n          if (existingSelection) {\r\n            if (model.hasMultipleCursors()) existingSelection.destroy()\r\n          } else {\r\n            model.addCursorAtScreenPosition(screenPosition, {autoscroll: false})\r\n          }\r\n        } else {\r\n          if (shiftKey) {\r\n            model.selectToScreenPosition(screenPosition, {autoscroll: false})\r\n          } else {\r\n            model.setCursorScreenPosition(screenPosition, {autoscroll: false})\r\n          }\r\n        }\r\n        break\r\n      case 2:\r\n        if (addOrRemoveSelection) model.addCursorAtScreenPosition(screenPosition, {autoscroll: false})\r\n        model.getLastSelection().selectWord({autoscroll: false})\r\n        break\r\n      case 3:\r\n        if (addOrRemoveSelection) model.addCursorAtScreenPosition(screenPosition, {autoscroll: false})\r\n        model.getLastSelection().selectLine(null, {autoscroll: false})\r\n        break\r\n    }\r\n\r\n    this.handleMouseDragUntilMouseUp({\r\n      didDrag: (event) => {\r\n        this.autoscrollOnMouseDrag(event)\r\n        const screenPosition = this.screenPositionForMouseEvent(event)\r\n        model.selectToScreenPosition(screenPosition, {suppressSelectionMerge: true, autoscroll: false})\r\n        this.updateSync()\r\n      },\r\n      didStopDragging: () => {\r\n        model.finalizeSelections()\r\n        model.mergeIntersectingSelections()\r\n        this.updateSync()\r\n      }\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getPlatform","start_line":2964,"end_line":2966,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"screenPositionForMouseEvent","line":1761,"func_location":"TextEditorComponent.didMouseDownOnContent","func_start_line":1744,"func_end_line":1826,"args":["event"],"code":"  didMouseDownOnContent (event) {\r\n    const {model} = this.props\r\n    const {target, button, detail, ctrlKey, shiftKey, metaKey} = event\r\n    const platform = this.getPlatform()\r\n\r\n    // Ignore clicks on block decorations.\r\n    if (target) {\r\n      let element = target\r\n      while (element && element !== this.element) {\r\n        if (this.blockDecorationsByElement.has(element)) {\r\n          return\r\n        }\r\n\r\n        element = element.parentElement\r\n      }\r\n    }\r\n\r\n    const screenPosition = this.screenPositionForMouseEvent(event)\r\n\r\n    if (button === 1) {\r\n      model.setCursorScreenPosition(screenPosition, {autoscroll: false})\r\n\r\n      // On Linux, pasting happens on middle click. A textInput event with the\r\n      // contents of the selection clipboard will be dispatched by the browser\r\n      // automatically on mouseup.\r\n      if (platform === 'linux' && this.isInputEnabled()) model.insertText(clipboard.readText('selection'))\r\n      return\r\n    }\r\n\r\n    if (button !== 0) return\r\n\r\n    // Ctrl-click brings up the context menu on macOS\r\n    if (platform === 'darwin' && ctrlKey) return\r\n\r\n    if (target && target.matches('.fold-marker')) {\r\n      const bufferPosition = model.bufferPositionForScreenPosition(screenPosition)\r\n      model.destroyFoldsContainingBufferPositions([bufferPosition], false)\r\n      return\r\n    }\r\n\r\n    const addOrRemoveSelection = metaKey || (ctrlKey && platform !== 'darwin')\r\n\r\n    switch (detail) {\r\n      case 1:\r\n        if (addOrRemoveSelection) {\r\n          const existingSelection = model.getSelectionAtScreenPosition(screenPosition)\r\n          if (existingSelection) {\r\n            if (model.hasMultipleCursors()) existingSelection.destroy()\r\n          } else {\r\n            model.addCursorAtScreenPosition(screenPosition, {autoscroll: false})\r\n          }\r\n        } else {\r\n          if (shiftKey) {\r\n            model.selectToScreenPosition(screenPosition, {autoscroll: false})\r\n          } else {\r\n            model.setCursorScreenPosition(screenPosition, {autoscroll: false})\r\n          }\r\n        }\r\n        break\r\n      case 2:\r\n        if (addOrRemoveSelection) model.addCursorAtScreenPosition(screenPosition, {autoscroll: false})\r\n        model.getLastSelection().selectWord({autoscroll: false})\r\n        break\r\n      case 3:\r\n        if (addOrRemoveSelection) model.addCursorAtScreenPosition(screenPosition, {autoscroll: false})\r\n        model.getLastSelection().selectLine(null, {autoscroll: false})\r\n        break\r\n    }\r\n\r\n    this.handleMouseDragUntilMouseUp({\r\n      didDrag: (event) => {\r\n        this.autoscrollOnMouseDrag(event)\r\n        const screenPosition = this.screenPositionForMouseEvent(event)\r\n        model.selectToScreenPosition(screenPosition, {suppressSelectionMerge: true, autoscroll: false})\r\n        this.updateSync()\r\n      },\r\n      didStopDragging: () => {\r\n        model.finalizeSelections()\r\n        model.mergeIntersectingSelections()\r\n        this.updateSync()\r\n      }\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.screenPositionForMouseEvent","start_line":1961,"end_line":1963,"comment":[],"params":["event"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"isInputEnabled","line":1769,"func_location":"TextEditorComponent.didMouseDownOnContent","func_start_line":1744,"func_end_line":1826,"args":[],"code":"  didMouseDownOnContent (event) {\r\n    const {model} = this.props\r\n    const {target, button, detail, ctrlKey, shiftKey, metaKey} = event\r\n    const platform = this.getPlatform()\r\n\r\n    // Ignore clicks on block decorations.\r\n    if (target) {\r\n      let element = target\r\n      while (element && element !== this.element) {\r\n        if (this.blockDecorationsByElement.has(element)) {\r\n          return\r\n        }\r\n\r\n        element = element.parentElement\r\n      }\r\n    }\r\n\r\n    const screenPosition = this.screenPositionForMouseEvent(event)\r\n\r\n    if (button === 1) {\r\n      model.setCursorScreenPosition(screenPosition, {autoscroll: false})\r\n\r\n      // On Linux, pasting happens on middle click. A textInput event with the\r\n      // contents of the selection clipboard will be dispatched by the browser\r\n      // automatically on mouseup.\r\n      if (platform === 'linux' && this.isInputEnabled()) model.insertText(clipboard.readText('selection'))\r\n      return\r\n    }\r\n\r\n    if (button !== 0) return\r\n\r\n    // Ctrl-click brings up the context menu on macOS\r\n    if (platform === 'darwin' && ctrlKey) return\r\n\r\n    if (target && target.matches('.fold-marker')) {\r\n      const bufferPosition = model.bufferPositionForScreenPosition(screenPosition)\r\n      model.destroyFoldsContainingBufferPositions([bufferPosition], false)\r\n      return\r\n    }\r\n\r\n    const addOrRemoveSelection = metaKey || (ctrlKey && platform !== 'darwin')\r\n\r\n    switch (detail) {\r\n      case 1:\r\n        if (addOrRemoveSelection) {\r\n          const existingSelection = model.getSelectionAtScreenPosition(screenPosition)\r\n          if (existingSelection) {\r\n            if (model.hasMultipleCursors()) existingSelection.destroy()\r\n          } else {\r\n            model.addCursorAtScreenPosition(screenPosition, {autoscroll: false})\r\n          }\r\n        } else {\r\n          if (shiftKey) {\r\n            model.selectToScreenPosition(screenPosition, {autoscroll: false})\r\n          } else {\r\n            model.setCursorScreenPosition(screenPosition, {autoscroll: false})\r\n          }\r\n        }\r\n        break\r\n      case 2:\r\n        if (addOrRemoveSelection) model.addCursorAtScreenPosition(screenPosition, {autoscroll: false})\r\n        model.getLastSelection().selectWord({autoscroll: false})\r\n        break\r\n      case 3:\r\n        if (addOrRemoveSelection) model.addCursorAtScreenPosition(screenPosition, {autoscroll: false})\r\n        model.getLastSelection().selectLine(null, {autoscroll: false})\r\n        break\r\n    }\r\n\r\n    this.handleMouseDragUntilMouseUp({\r\n      didDrag: (event) => {\r\n        this.autoscrollOnMouseDrag(event)\r\n        const screenPosition = this.screenPositionForMouseEvent(event)\r\n        model.selectToScreenPosition(screenPosition, {suppressSelectionMerge: true, autoscroll: false})\r\n        this.updateSync()\r\n      },\r\n      didStopDragging: () => {\r\n        model.finalizeSelections()\r\n        model.mergeIntersectingSelections()\r\n        this.updateSync()\r\n      }\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.isInputEnabled","start_line":2956,"end_line":2958,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"handleMouseDragUntilMouseUp","line":1813,"func_location":"TextEditorComponent.didMouseDownOnContent","func_start_line":1744,"func_end_line":1826},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.handleMouseDragUntilMouseUp","start_line":1886,"end_line":1920,"comment":[],"params":[["didDrag","didStopDragging"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"screenPositionForMouseEvent","line":1835,"func_location":"TextEditorComponent.didMouseDownOnLineNumberGutter","func_start_line":1828,"func_end_line":1884,"args":["event"],"code":"  didMouseDownOnLineNumberGutter (event) {\r\n    const {model} = this.props\r\n    const {target, button, ctrlKey, shiftKey, metaKey} = event\r\n\r\n    // Only handle mousedown events for left mouse button\r\n    if (button !== 0) return\r\n\r\n    const clickedScreenRow = this.screenPositionForMouseEvent(event).row\r\n    const startBufferRow = model.bufferPositionForScreenPosition([clickedScreenRow, 0]).row\r\n\r\n    if (target && (target.matches('.foldable .icon-right') || target.matches('.folded .icon-right'))) {\r\n      model.toggleFoldAtBufferRow(startBufferRow)\r\n      return\r\n    }\r\n\r\n    const addOrRemoveSelection = metaKey || (ctrlKey && this.getPlatform() !== 'darwin')\r\n    const endBufferRow = model.bufferPositionForScreenPosition([clickedScreenRow, Infinity]).row\r\n    const clickedLineBufferRange = Range(Point(startBufferRow, 0), Point(endBufferRow + 1, 0))\r\n\r\n    let initialBufferRange\r\n    if (shiftKey) {\r\n      const lastSelection = model.getLastSelection()\r\n      initialBufferRange = lastSelection.getBufferRange()\r\n      lastSelection.setBufferRange(initialBufferRange.union(clickedLineBufferRange), {\r\n        reversed: clickedScreenRow < lastSelection.getScreenRange().start.row,\r\n        autoscroll: false,\r\n        preserveFolds: true,\r\n        suppressSelectionMerge: true\r\n      })\r\n    } else {\r\n      initialBufferRange = clickedLineBufferRange\r\n      if (addOrRemoveSelection) {\r\n        model.addSelectionForBufferRange(clickedLineBufferRange, {autoscroll: false, preserveFolds: true})\r\n      } else {\r\n        model.setSelectedBufferRange(clickedLineBufferRange, {autoscroll: false, preserveFolds: true})\r\n      }\r\n    }\r\n\r\n    const initialScreenRange = model.screenRangeForBufferRange(initialBufferRange)\r\n    this.handleMouseDragUntilMouseUp({\r\n      didDrag: (event) => {\r\n        this.autoscrollOnMouseDrag(event, true)\r\n        const dragRow = this.screenPositionForMouseEvent(event).row\r\n        const draggedLineScreenRange = Range(Point(dragRow, 0), Point(dragRow + 1, 0))\r\n        model.getLastSelection().setScreenRange(draggedLineScreenRange.union(initialScreenRange), {\r\n          reversed: dragRow < initialScreenRange.start.row,\r\n          autoscroll: false,\r\n          preserveFolds: true\r\n        })\r\n        this.updateSync()\r\n      },\r\n      didStopDragging: () => {\r\n        model.mergeIntersectingSelections()\r\n        this.updateSync()\r\n      }\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.screenPositionForMouseEvent","start_line":1961,"end_line":1963,"comment":[],"params":["event"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getPlatform","line":1843,"func_location":"TextEditorComponent.didMouseDownOnLineNumberGutter","func_start_line":1828,"func_end_line":1884,"args":[],"code":"  didMouseDownOnLineNumberGutter (event) {\r\n    const {model} = this.props\r\n    const {target, button, ctrlKey, shiftKey, metaKey} = event\r\n\r\n    // Only handle mousedown events for left mouse button\r\n    if (button !== 0) return\r\n\r\n    const clickedScreenRow = this.screenPositionForMouseEvent(event).row\r\n    const startBufferRow = model.bufferPositionForScreenPosition([clickedScreenRow, 0]).row\r\n\r\n    if (target && (target.matches('.foldable .icon-right') || target.matches('.folded .icon-right'))) {\r\n      model.toggleFoldAtBufferRow(startBufferRow)\r\n      return\r\n    }\r\n\r\n    const addOrRemoveSelection = metaKey || (ctrlKey && this.getPlatform() !== 'darwin')\r\n    const endBufferRow = model.bufferPositionForScreenPosition([clickedScreenRow, Infinity]).row\r\n    const clickedLineBufferRange = Range(Point(startBufferRow, 0), Point(endBufferRow + 1, 0))\r\n\r\n    let initialBufferRange\r\n    if (shiftKey) {\r\n      const lastSelection = model.getLastSelection()\r\n      initialBufferRange = lastSelection.getBufferRange()\r\n      lastSelection.setBufferRange(initialBufferRange.union(clickedLineBufferRange), {\r\n        reversed: clickedScreenRow < lastSelection.getScreenRange().start.row,\r\n        autoscroll: false,\r\n        preserveFolds: true,\r\n        suppressSelectionMerge: true\r\n      })\r\n    } else {\r\n      initialBufferRange = clickedLineBufferRange\r\n      if (addOrRemoveSelection) {\r\n        model.addSelectionForBufferRange(clickedLineBufferRange, {autoscroll: false, preserveFolds: true})\r\n      } else {\r\n        model.setSelectedBufferRange(clickedLineBufferRange, {autoscroll: false, preserveFolds: true})\r\n      }\r\n    }\r\n\r\n    const initialScreenRange = model.screenRangeForBufferRange(initialBufferRange)\r\n    this.handleMouseDragUntilMouseUp({\r\n      didDrag: (event) => {\r\n        this.autoscrollOnMouseDrag(event, true)\r\n        const dragRow = this.screenPositionForMouseEvent(event).row\r\n        const draggedLineScreenRange = Range(Point(dragRow, 0), Point(dragRow + 1, 0))\r\n        model.getLastSelection().setScreenRange(draggedLineScreenRange.union(initialScreenRange), {\r\n          reversed: dragRow < initialScreenRange.start.row,\r\n          autoscroll: false,\r\n          preserveFolds: true\r\n        })\r\n        this.updateSync()\r\n      },\r\n      didStopDragging: () => {\r\n        model.mergeIntersectingSelections()\r\n        this.updateSync()\r\n      }\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getPlatform","start_line":2964,"end_line":2966,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"handleMouseDragUntilMouseUp","line":1867,"func_location":"TextEditorComponent.didMouseDownOnLineNumberGutter","func_start_line":1828,"func_end_line":1884},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.handleMouseDragUntilMouseUp","start_line":1886,"end_line":1920,"comment":[],"params":[["didDrag","didStopDragging"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getPlatform","line":1542,"func_location":"TextEditorComponent.didMouseWheel","func_start_line":1529,"func_end_line":1552,"args":[],"code":"  didMouseWheel (event) {\r\n    const scrollSensitivity = this.props.model.getScrollSensitivity() / 100\r\n\r\n    let {wheelDeltaX, wheelDeltaY} = event\r\n\r\n    if (Math.abs(wheelDeltaX) > Math.abs(wheelDeltaY)) {\r\n      wheelDeltaX = wheelDeltaX * scrollSensitivity\r\n      wheelDeltaY = 0\r\n    } else {\r\n      wheelDeltaX = 0\r\n      wheelDeltaY = wheelDeltaY * scrollSensitivity\r\n    }\r\n\r\n    if (this.getPlatform() !== 'darwin' && event.shiftKey) {\r\n      let temp = wheelDeltaX\r\n      wheelDeltaX = wheelDeltaY\r\n      wheelDeltaY = temp\r\n    }\r\n\r\n    const scrollLeftChanged = wheelDeltaX !== 0 && this.setScrollLeft(this.getScrollLeft() - wheelDeltaX)\r\n    const scrollTopChanged = wheelDeltaY !== 0 && this.setScrollTop(this.getScrollTop() - wheelDeltaY)\r\n\r\n    if (scrollLeftChanged || scrollTopChanged) this.updateSync()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getPlatform","start_line":2964,"end_line":2966,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"setScrollLeft","line":1548,"func_location":"TextEditorComponent.didMouseWheel","func_start_line":1529,"func_end_line":1552,"args":[null],"code":"  didMouseWheel (event) {\r\n    const scrollSensitivity = this.props.model.getScrollSensitivity() / 100\r\n\r\n    let {wheelDeltaX, wheelDeltaY} = event\r\n\r\n    if (Math.abs(wheelDeltaX) > Math.abs(wheelDeltaY)) {\r\n      wheelDeltaX = wheelDeltaX * scrollSensitivity\r\n      wheelDeltaY = 0\r\n    } else {\r\n      wheelDeltaX = 0\r\n      wheelDeltaY = wheelDeltaY * scrollSensitivity\r\n    }\r\n\r\n    if (this.getPlatform() !== 'darwin' && event.shiftKey) {\r\n      let temp = wheelDeltaX\r\n      wheelDeltaX = wheelDeltaY\r\n      wheelDeltaY = temp\r\n    }\r\n\r\n    const scrollLeftChanged = wheelDeltaX !== 0 && this.setScrollLeft(this.getScrollLeft() - wheelDeltaX)\r\n    const scrollTopChanged = wheelDeltaY !== 0 && this.setScrollTop(this.getScrollTop() - wheelDeltaY)\r\n\r\n    if (scrollLeftChanged || scrollTopChanged) this.updateSync()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.setScrollLeft","start_line":2827,"end_line":2839,"comment":[],"params":["scrollLeft"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollLeft","line":1548,"func_location":"TextEditorComponent.didMouseWheel","func_start_line":1529,"func_end_line":1552,"args":[null],"code":"  didMouseWheel (event) {\r\n    const scrollSensitivity = this.props.model.getScrollSensitivity() / 100\r\n\r\n    let {wheelDeltaX, wheelDeltaY} = event\r\n\r\n    if (Math.abs(wheelDeltaX) > Math.abs(wheelDeltaY)) {\r\n      wheelDeltaX = wheelDeltaX * scrollSensitivity\r\n      wheelDeltaY = 0\r\n    } else {\r\n      wheelDeltaX = 0\r\n      wheelDeltaY = wheelDeltaY * scrollSensitivity\r\n    }\r\n\r\n    if (this.getPlatform() !== 'darwin' && event.shiftKey) {\r\n      let temp = wheelDeltaX\r\n      wheelDeltaX = wheelDeltaY\r\n      wheelDeltaY = temp\r\n    }\r\n\r\n    const scrollLeftChanged = wheelDeltaX !== 0 && this.setScrollLeft(this.getScrollLeft() - wheelDeltaX)\r\n    const scrollTopChanged = wheelDeltaY !== 0 && this.setScrollTop(this.getScrollTop() - wheelDeltaY)\r\n\r\n    if (scrollLeftChanged || scrollTopChanged) this.updateSync()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollLeft","start_line":2823,"end_line":2825,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"setScrollTop","line":1549,"func_location":"TextEditorComponent.didMouseWheel","func_start_line":1529,"func_end_line":1552,"args":[null],"code":"  didMouseWheel (event) {\r\n    const scrollSensitivity = this.props.model.getScrollSensitivity() / 100\r\n\r\n    let {wheelDeltaX, wheelDeltaY} = event\r\n\r\n    if (Math.abs(wheelDeltaX) > Math.abs(wheelDeltaY)) {\r\n      wheelDeltaX = wheelDeltaX * scrollSensitivity\r\n      wheelDeltaY = 0\r\n    } else {\r\n      wheelDeltaX = 0\r\n      wheelDeltaY = wheelDeltaY * scrollSensitivity\r\n    }\r\n\r\n    if (this.getPlatform() !== 'darwin' && event.shiftKey) {\r\n      let temp = wheelDeltaX\r\n      wheelDeltaX = wheelDeltaY\r\n      wheelDeltaY = temp\r\n    }\r\n\r\n    const scrollLeftChanged = wheelDeltaX !== 0 && this.setScrollLeft(this.getScrollLeft() - wheelDeltaX)\r\n    const scrollTopChanged = wheelDeltaY !== 0 && this.setScrollTop(this.getScrollTop() - wheelDeltaY)\r\n\r\n    if (scrollLeftChanged || scrollTopChanged) this.updateSync()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.setScrollTop","start_line":2796,"end_line":2809,"comment":[],"params":["scrollTop"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollTop","line":1549,"func_location":"TextEditorComponent.didMouseWheel","func_start_line":1529,"func_end_line":1552,"args":[null],"code":"  didMouseWheel (event) {\r\n    const scrollSensitivity = this.props.model.getScrollSensitivity() / 100\r\n\r\n    let {wheelDeltaX, wheelDeltaY} = event\r\n\r\n    if (Math.abs(wheelDeltaX) > Math.abs(wheelDeltaY)) {\r\n      wheelDeltaX = wheelDeltaX * scrollSensitivity\r\n      wheelDeltaY = 0\r\n    } else {\r\n      wheelDeltaX = 0\r\n      wheelDeltaY = wheelDeltaY * scrollSensitivity\r\n    }\r\n\r\n    if (this.getPlatform() !== 'darwin' && event.shiftKey) {\r\n      let temp = wheelDeltaX\r\n      wheelDeltaX = wheelDeltaY\r\n      wheelDeltaY = temp\r\n    }\r\n\r\n    const scrollLeftChanged = wheelDeltaX !== 0 && this.setScrollLeft(this.getScrollLeft() - wheelDeltaX)\r\n    const scrollTopChanged = wheelDeltaY !== 0 && this.setScrollTop(this.getScrollTop() - wheelDeltaY)\r\n\r\n    if (scrollLeftChanged || scrollTopChanged) this.updateSync()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollTop","start_line":2791,"end_line":2794,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateSync","line":1551,"func_location":"TextEditorComponent.didMouseWheel","func_start_line":1529,"func_end_line":1552,"args":[],"code":"  didMouseWheel (event) {\r\n    const scrollSensitivity = this.props.model.getScrollSensitivity() / 100\r\n\r\n    let {wheelDeltaX, wheelDeltaY} = event\r\n\r\n    if (Math.abs(wheelDeltaX) > Math.abs(wheelDeltaY)) {\r\n      wheelDeltaX = wheelDeltaX * scrollSensitivity\r\n      wheelDeltaY = 0\r\n    } else {\r\n      wheelDeltaX = 0\r\n      wheelDeltaY = wheelDeltaY * scrollSensitivity\r\n    }\r\n\r\n    if (this.getPlatform() !== 'darwin' && event.shiftKey) {\r\n      let temp = wheelDeltaX\r\n      wheelDeltaX = wheelDeltaY\r\n      wheelDeltaY = temp\r\n    }\r\n\r\n    const scrollLeftChanged = wheelDeltaX !== 0 && this.setScrollLeft(this.getScrollLeft() - wheelDeltaX)\r\n    const scrollTopChanged = wheelDeltaY !== 0 && this.setScrollTop(this.getScrollTop() - wheelDeltaY)\r\n\r\n    if (scrollLeftChanged || scrollTopChanged) this.updateSync()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateSync","start_line":221,"end_line":289,"comment":[],"params":["useScheduler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getPlatform","line":1614,"func_location":"TextEditorComponent.didPaste","func_start_line":1607,"func_end_line":1615,"args":[],"code":"  didPaste (event) {\r\n    // On Linux, Chromium translates a middle-button mouse click into a\r\n    // mousedown event *and* a paste event. Since Atom supports the middle mouse\r\n    // click as a way of closing a tab, we only want the mousedown event, not\r\n    // the paste event. And since we don't use the `paste` event for any\r\n    // behavior in Atom, we can no-op the event to eliminate this issue.\r\n    // See https://github.com/atom/atom/pull/15183#issue-248432413.\r\n    if (this.getPlatform() === 'linux') event.preventDefault()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getPlatform","start_line":2964,"end_line":2966,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"scheduleUpdate","line":2014,"func_location":"TextEditorComponent.didRequestAutoscroll","func_start_line":2012,"func_end_line":2015,"args":[],"code":"  didRequestAutoscroll (autoscroll) {\r\n    this.pendingAutoscroll = autoscroll\r\n    this.scheduleUpdate()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.scheduleUpdate","start_line":204,"end_line":219,"comment":[],"params":["nextUpdateOnlyBlinksCursors"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"spliceLineTopIndex","line":2459,"func_location":"TextEditorComponent.didResetDisplayLayer","func_start_line":2458,"func_end_line":2461,"args":[{"type":"number"},"Infinity","Infinity"],"code":"  didResetDisplayLayer () {\r\n    this.spliceLineTopIndex(0, Infinity, Infinity)\r\n    this.scheduleUpdate()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.spliceLineTopIndex","start_line":2580,"end_line":2586,"comment":[],"params":["startRow","oldExtent","newExtent"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"scheduleUpdate","line":2460,"func_location":"TextEditorComponent.didResetDisplayLayer","func_start_line":2458,"func_end_line":2461,"args":[],"code":"  didResetDisplayLayer () {\r\n    this.spliceLineTopIndex(0, Infinity, Infinity)\r\n    this.scheduleUpdate()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.scheduleUpdate","start_line":204,"end_line":219,"comment":[],"params":["nextUpdateOnlyBlinksCursors"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"isVisible","line":1557,"func_location":"TextEditorComponent.didResize","func_start_line":1554,"func_end_line":1570,"args":[],"code":"  didResize () {\r\n    // Prevent the component from measuring the client container dimensions when\r\n    // getting spurious resize events.\r\n    if (this.isVisible()) {\r\n      const clientContainerWidthChanged = this.measureClientContainerWidth()\r\n      const clientContainerHeightChanged = this.measureClientContainerHeight()\r\n      if (clientContainerWidthChanged || clientContainerHeightChanged) {\r\n        if (clientContainerWidthChanged) {\r\n          this.remeasureAllBlockDecorations = true\r\n        }\r\n\r\n        this.resizeObserver.disconnect()\r\n        this.scheduleUpdate()\r\n        process.nextTick(() => { this.resizeObserver.observe(this.element) })\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.isVisible","start_line":2588,"end_line":2590,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"measureClientContainerWidth","line":1558,"func_location":"TextEditorComponent.didResize","func_start_line":1554,"func_end_line":1570,"args":[],"code":"  didResize () {\r\n    // Prevent the component from measuring the client container dimensions when\r\n    // getting spurious resize events.\r\n    if (this.isVisible()) {\r\n      const clientContainerWidthChanged = this.measureClientContainerWidth()\r\n      const clientContainerHeightChanged = this.measureClientContainerHeight()\r\n      if (clientContainerWidthChanged || clientContainerHeightChanged) {\r\n        if (clientContainerWidthChanged) {\r\n          this.remeasureAllBlockDecorations = true\r\n        }\r\n\r\n        this.resizeObserver.disconnect()\r\n        this.scheduleUpdate()\r\n        process.nextTick(() => { this.resizeObserver.observe(this.element) })\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.measureClientContainerWidth","start_line":2211,"end_line":2219,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"measureClientContainerHeight","line":1559,"func_location":"TextEditorComponent.didResize","func_start_line":1554,"func_end_line":1570,"args":[],"code":"  didResize () {\r\n    // Prevent the component from measuring the client container dimensions when\r\n    // getting spurious resize events.\r\n    if (this.isVisible()) {\r\n      const clientContainerWidthChanged = this.measureClientContainerWidth()\r\n      const clientContainerHeightChanged = this.measureClientContainerHeight()\r\n      if (clientContainerWidthChanged || clientContainerHeightChanged) {\r\n        if (clientContainerWidthChanged) {\r\n          this.remeasureAllBlockDecorations = true\r\n        }\r\n\r\n        this.resizeObserver.disconnect()\r\n        this.scheduleUpdate()\r\n        process.nextTick(() => { this.resizeObserver.observe(this.element) })\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.measureClientContainerHeight","start_line":2201,"end_line":2209,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"scheduleUpdate","line":1566,"func_location":"TextEditorComponent.didResize","func_start_line":1554,"func_end_line":1570,"args":[],"code":"  didResize () {\r\n    // Prevent the component from measuring the client container dimensions when\r\n    // getting spurious resize events.\r\n    if (this.isVisible()) {\r\n      const clientContainerWidthChanged = this.measureClientContainerWidth()\r\n      const clientContainerHeightChanged = this.measureClientContainerHeight()\r\n      if (clientContainerWidthChanged || clientContainerHeightChanged) {\r\n        if (clientContainerWidthChanged) {\r\n          this.remeasureAllBlockDecorations = true\r\n        }\r\n\r\n        this.resizeObserver.disconnect()\r\n        this.scheduleUpdate()\r\n        process.nextTick(() => { this.resizeObserver.observe(this.element) })\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.scheduleUpdate","start_line":204,"end_line":219,"comment":[],"params":["nextUpdateOnlyBlinksCursors"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"invalidateBlockDecorationDimensions","line":2570,"func_location":"TextEditorComponent.didResizeBlockDecorations","func_start_line":2562,"func_end_line":2573,"args":["decoration"],"code":"  didResizeBlockDecorations (entries) {\r\n    if (!this.visible) return\r\n\r\n    for (let i = 0; i < entries.length; i++) {\r\n      const {target, contentRect} = entries[i]\r\n      const decoration = this.blockDecorationsByElement.get(target)\r\n      const previousHeight = this.heightsByBlockDecoration.get(decoration)\r\n      if (this.element.contains(target) && contentRect.height !== previousHeight) {\r\n        this.invalidateBlockDecorationDimensions(decoration)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.invalidateBlockDecorationDimensions","start_line":2575,"end_line":2578,"comment":[],"params":["decoration"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"isVisible","line":1575,"func_location":"TextEditorComponent.didResizeGutterContainer","func_start_line":1572,"func_end_line":1580,"args":[],"code":"  didResizeGutterContainer () {\r\n    // Prevent the component from measuring the gutter dimensions when getting\r\n    // spurious resize events.\r\n    if (this.isVisible() && this.measureGutterDimensions()) {\r\n      this.gutterContainerResizeObserver.disconnect()\r\n      this.scheduleUpdate()\r\n      process.nextTick(() => { this.gutterContainerResizeObserver.observe(this.refs.gutterContainer.element) })\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.isVisible","start_line":2588,"end_line":2590,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"measureGutterDimensions","line":1575,"func_location":"TextEditorComponent.didResizeGutterContainer","func_start_line":1572,"func_end_line":1580,"args":[],"code":"  didResizeGutterContainer () {\r\n    // Prevent the component from measuring the gutter dimensions when getting\r\n    // spurious resize events.\r\n    if (this.isVisible() && this.measureGutterDimensions()) {\r\n      this.gutterContainerResizeObserver.disconnect()\r\n      this.scheduleUpdate()\r\n      process.nextTick(() => { this.gutterContainerResizeObserver.observe(this.refs.gutterContainer.element) })\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.measureGutterDimensions","start_line":2175,"end_line":2199,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"scheduleUpdate","line":1577,"func_location":"TextEditorComponent.didResizeGutterContainer","func_start_line":1572,"func_end_line":1580,"args":[],"code":"  didResizeGutterContainer () {\r\n    // Prevent the component from measuring the gutter dimensions when getting\r\n    // spurious resize events.\r\n    if (this.isVisible() && this.measureGutterDimensions()) {\r\n      this.gutterContainerResizeObserver.disconnect()\r\n      this.scheduleUpdate()\r\n      process.nextTick(() => { this.gutterContainerResizeObserver.observe(this.refs.gutterContainer.element) })\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.scheduleUpdate","start_line":204,"end_line":219,"comment":[],"params":["nextUpdateOnlyBlinksCursors"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"setScrollTop","line":1586,"func_location":"TextEditorComponent.didScrollDummyScrollbar","func_start_line":1582,"func_end_line":1592,"args":[".refs.verticalScrollbar.element.scrollTop"],"code":"  didScrollDummyScrollbar () {\r\n    let scrollTopChanged = false\r\n    let scrollLeftChanged = false\r\n    if (!this.scrollTopPending) {\r\n      scrollTopChanged = this.setScrollTop(this.refs.verticalScrollbar.element.scrollTop)\r\n    }\r\n    if (!this.scrollLeftPending) {\r\n      scrollLeftChanged = this.setScrollLeft(this.refs.horizontalScrollbar.element.scrollLeft)\r\n    }\r\n    if (scrollTopChanged || scrollLeftChanged) this.updateSync()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.setScrollTop","start_line":2796,"end_line":2809,"comment":[],"params":["scrollTop"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"setScrollLeft","line":1589,"func_location":"TextEditorComponent.didScrollDummyScrollbar","func_start_line":1582,"func_end_line":1592,"args":[".refs.horizontalScrollbar.element.scrollLeft"],"code":"  didScrollDummyScrollbar () {\r\n    let scrollTopChanged = false\r\n    let scrollLeftChanged = false\r\n    if (!this.scrollTopPending) {\r\n      scrollTopChanged = this.setScrollTop(this.refs.verticalScrollbar.element.scrollTop)\r\n    }\r\n    if (!this.scrollLeftPending) {\r\n      scrollLeftChanged = this.setScrollLeft(this.refs.horizontalScrollbar.element.scrollLeft)\r\n    }\r\n    if (scrollTopChanged || scrollLeftChanged) this.updateSync()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.setScrollLeft","start_line":2827,"end_line":2839,"comment":[],"params":["scrollLeft"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateSync","line":1591,"func_location":"TextEditorComponent.didScrollDummyScrollbar","func_start_line":1582,"func_end_line":1592,"args":[],"code":"  didScrollDummyScrollbar () {\r\n    let scrollTopChanged = false\r\n    let scrollLeftChanged = false\r\n    if (!this.scrollTopPending) {\r\n      scrollTopChanged = this.setScrollTop(this.refs.verticalScrollbar.element.scrollTop)\r\n    }\r\n    if (!this.scrollLeftPending) {\r\n      scrollLeftChanged = this.setScrollLeft(this.refs.horizontalScrollbar.element.scrollLeft)\r\n    }\r\n    if (scrollTopChanged || scrollLeftChanged) this.updateSync()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateSync","start_line":221,"end_line":289,"comment":[],"params":["useScheduler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"onPathsSearched","line":1906,"func_location":"Workspace.scan.(unnamed_function_41).searchOptions.didSearchPaths","func_start_line":1905,"func_end_line":1907,"args":["searcher","count"],"code":"        didSearchPaths (count) {\r\n          return onPathsSearched(searcher, count)\r\n        }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.scan.onPathsSearched","start_line":1866,"end_line":1881}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"isVisible","line":1457,"func_location":"TextEditorComponent.didShow","func_start_line":1456,"func_end_line":1465,"args":[],"code":"  didShow () {\r\n    if (!this.visible && this.isVisible()) {\r\n      if (!this.hasInitialMeasurements) this.measureDimensions()\r\n      this.visible = true\r\n      this.props.model.setVisible(true)\r\n      this.resizeBlockDecorationMeasurementsArea = true\r\n      this.updateSync()\r\n      this.flushPendingLogicalScrollPosition()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.isVisible","start_line":2588,"end_line":2590,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"measureDimensions","line":1458,"func_location":"TextEditorComponent.didShow","func_start_line":1456,"func_end_line":1465,"args":[],"code":"  didShow () {\r\n    if (!this.visible && this.isVisible()) {\r\n      if (!this.hasInitialMeasurements) this.measureDimensions()\r\n      this.visible = true\r\n      this.props.model.setVisible(true)\r\n      this.resizeBlockDecorationMeasurementsArea = true\r\n      this.updateSync()\r\n      this.flushPendingLogicalScrollPosition()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.measureDimensions","start_line":2149,"end_line":2156,"comment":[" This method exists because it existed in the previous implementation and some"," package tests relied on it"],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateSync","line":1462,"func_location":"TextEditorComponent.didShow","func_start_line":1456,"func_end_line":1465,"args":[],"code":"  didShow () {\r\n    if (!this.visible && this.isVisible()) {\r\n      if (!this.hasInitialMeasurements) this.measureDimensions()\r\n      this.visible = true\r\n      this.props.model.setVisible(true)\r\n      this.resizeBlockDecorationMeasurementsArea = true\r\n      this.updateSync()\r\n      this.flushPendingLogicalScrollPosition()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateSync","start_line":221,"end_line":289,"comment":[],"params":["useScheduler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"flushPendingLogicalScrollPosition","line":1463,"func_location":"TextEditorComponent.didShow","func_start_line":1456,"func_end_line":1465,"args":[],"code":"  didShow () {\r\n    if (!this.visible && this.isVisible()) {\r\n      if (!this.hasInitialMeasurements) this.measureDimensions()\r\n      this.visible = true\r\n      this.props.model.setVisible(true)\r\n      this.resizeBlockDecorationMeasurementsArea = true\r\n      this.updateSync()\r\n      this.flushPendingLogicalScrollPosition()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.flushPendingLogicalScrollPosition","start_line":2017,"end_line":2033,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"isInputEnabled","line":1623,"func_location":"TextEditorComponent.didTextInput","func_start_line":1617,"func_end_line":1654,"args":[],"code":"  didTextInput (event) {\r\n    if (this.compositionCheckpoint) {\r\n      this.props.model.revertToCheckpoint(this.compositionCheckpoint)\r\n      this.compositionCheckpoint = null\r\n    }\r\n\r\n    if (this.isInputEnabled()) {\r\n      event.stopPropagation()\r\n\r\n      // WARNING: If we call preventDefault on the input of a space\r\n      // character, then the browser interprets the spacebar keypress as a\r\n      // page-down command, causing spaces to scroll elements containing\r\n      // editors. This means typing space will actually change the contents\r\n      // of the hidden input, which will cause the browser to autoscroll the\r\n      // scroll container to reveal the input if it is off screen (See\r\n      // https://github.com/atom/atom/issues/16046). To correct for this\r\n      // situation, we automatically reset the scroll position to 0,0 after\r\n      // typing a space. None of this can really be tested.\r\n      if (event.data === ' ') {\r\n        window.setImmediate(() => {\r\n          this.refs.scrollContainer.scrollTop = 0\r\n          this.refs.scrollContainer.scrollLeft = 0\r\n        })\r\n      } else {\r\n        event.preventDefault()\r\n      }\r\n\r\n      // If the input event is fired while the accented character menu is open it\r\n      // means that the user has chosen one of the accented alternatives. Thus, we\r\n      // will replace the original non accented character with the selected\r\n      // alternative.\r\n      if (this.accentedCharacterMenuIsOpen) {\r\n        this.props.model.selectLeft()\r\n      }\r\n\r\n      this.props.model.insertText(event.data, {groupUndo: true})\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.isInputEnabled","start_line":2956,"end_line":2958,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"scheduleUpdate","line":1603,"func_location":"TextEditorComponent.didUpdateScrollbarStyles","func_start_line":1600,"func_end_line":1605,"args":[],"code":"  didUpdateScrollbarStyles () {\r\n    if (!this.props.model.isMini()) {\r\n      this.remeasureScrollbars = true\r\n      this.scheduleUpdate()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.scheduleUpdate","start_line":204,"end_line":219,"comment":[],"params":["nextUpdateOnlyBlinksCursors"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pauseCursorBlinking","line":1977,"func_location":"TextEditorComponent.didUpdateSelections","func_start_line":1976,"func_end_line":1979,"args":[],"code":"  didUpdateSelections () {\r\n    this.pauseCursorBlinking()\r\n    this.scheduleUpdate()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pauseCursorBlinking","start_line":1981,"end_line":1984,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"scheduleUpdate","line":1978,"func_location":"TextEditorComponent.didUpdateSelections","func_start_line":1976,"func_end_line":1979,"args":[],"code":"  didUpdateSelections () {\r\n    this.pauseCursorBlinking()\r\n    this.scheduleUpdate()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.scheduleUpdate","start_line":204,"end_line":219,"comment":[],"params":["nextUpdateOnlyBlinksCursors"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"scheduleUpdate","line":1597,"func_location":"TextEditorComponent.didUpdateStyles","func_start_line":1594,"func_end_line":1598,"args":[],"code":"  didUpdateStyles () {\r\n    this.remeasureCharacterDimensions = true\r\n    this.horizontalPixelPositionsByScreenLineId.clear()\r\n    this.scheduleUpdate()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.scheduleUpdate","start_line":204,"end_line":219,"comment":[],"params":["nextUpdateOnlyBlinksCursors"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"loadPackage","line":270,"func_location":"PackageManager.disablePackage","func_start_line":269,"func_end_line":275,"args":["name"],"comment":[" Public: Disable the package with the given name.",""," * `name` - The {String} package name.",""," Returns the {Package} that was disabled or null if it isn't loaded."],"code":"  disablePackage (name) {\r\n    const pack = this.loadPackage(name)\r\n    if (!this.isPackageDisabled(name) && pack != null) {\r\n      pack.disable()\r\n    }\r\n    return pack\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.loadPackage","start_line":551,"end_line":569,"comment":[],"params":["nameOrPath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"isPackageDisabled","line":271,"func_location":"PackageManager.disablePackage","func_start_line":269,"func_end_line":275,"args":["name"],"comment":[" Public: Disable the package with the given name.",""," * `name` - The {String} package name.",""," Returns the {Package} that was disabled or null if it isn't loaded."],"code":"  disablePackage (name) {\r\n    const pack = this.loadPackage(name)\r\n    if (!this.isPackageDisabled(name) && pack != null) {\r\n      pack.disable()\r\n    }\r\n    return pack\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.isPackageDisabled","start_line":282,"end_line":284,"comment":[" Public: Is the package with the given name disabled?",""," * `name` - The {String} package name.",""," Returns a {Boolean}."],"params":["name"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js","name":"isDismissable","line":86,"func_location":"Notification.dismiss","func_start_line":85,"func_end_line":89,"args":[],"comment":[" Extended: Dismisses the notification, removing it from the UI. Calling this"," programmatically will call all callbacks added via `onDidDismiss`."],"code":"  dismiss () {\r\n    if (!this.isDismissable() || this.isDismissed()) return\r\n    this.dismissed = true\r\n    this.emitter.emit('did-dismiss', this)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js","name":"Notification.isDismissable","start_line":95,"end_line":97,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js","name":"isDismissed","line":86,"func_location":"Notification.dismiss","func_start_line":85,"func_end_line":89,"args":[],"comment":[" Extended: Dismisses the notification, removing it from the UI. Calling this"," programmatically will call all callbacks added via `onDidDismiss`."],"code":"  dismiss () {\r\n    if (!this.isDismissable() || this.isDismissed()) return\r\n    this.dismissed = true\r\n    this.emitter.emit('did-dismiss', this)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js","name":"Notification.isDismissed","start_line":91,"end_line":93,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js","name":"handleCommandEvent","line":273,"func_location":"CommandRegistry.dispatch","func_start_line":270,"func_end_line":274,"args":["event"],"comment":[" Public: Simulate the dispatch of a command on a DOM node.",""," This can be useful for testing when you want to simulate the invocation of a"," command on a detached DOM node. Otherwise, the DOM node in question needs to"," be attached to the document so the event bubbles up to the root node to be"," processed.",""," * `target` The DOM node at which to start bubbling the command event."," * `commandName` {String} indicating the name of the command to dispatch."],"code":"  dispatch (target, commandName, detail) {\r\n    const event = new CustomEvent(commandName, { bubbles: true, detail })\r\n    Object.defineProperty(event, 'target', { value: target })\r\n    return this.handleCommandEvent(event)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js","name":"CommandRegistry.handleCommandEvent","start_line":309,"end_line":399,"comment":[],"params":["event"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"restoreWindowDimensions","line":660,"func_location":"AtomEnvironment.displayWindow","func_start_line":659,"func_end_line":673,"args":[],"comment":[" Restore the window to its previous dimensions and show it.",""," Restores the full screen and maximized state after the window has resized to"," prevent resize glitches."],"code":"  async displayWindow () {\r\n    await this.restoreWindowDimensions()\r\n    const steps = [\r\n      this.restoreWindowBackground(),\r\n      this.show(),\r\n      this.focus()\r\n    ]\r\n    if (this.windowDimensions && this.windowDimensions.fullScreen) {\r\n      steps.push(this.setFullScreen(true))\r\n    }\r\n    if (this.windowDimensions && this.windowDimensions.maximized && process.platform !== 'darwin') {\r\n      steps.push(this.maximize())\r\n    }\r\n    await Promise.all(steps)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.restoreWindowDimensions","start_line":747,"end_line":753,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"restoreWindowBackground","line":662,"func_location":"AtomEnvironment.displayWindow","func_start_line":659,"func_end_line":673,"args":[],"comment":[" Restore the window to its previous dimensions and show it.",""," Restores the full screen and maximized state after the window has resized to"," prevent resize glitches."],"code":"  async displayWindow () {\r\n    await this.restoreWindowDimensions()\r\n    const steps = [\r\n      this.restoreWindowBackground(),\r\n      this.show(),\r\n      this.focus()\r\n    ]\r\n    if (this.windowDimensions && this.windowDimensions.fullScreen) {\r\n      steps.push(this.setFullScreen(true))\r\n    }\r\n    if (this.windowDimensions && this.windowDimensions.maximized && process.platform !== 'darwin') {\r\n      steps.push(this.maximize())\r\n    }\r\n    await Promise.all(steps)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.restoreWindowBackground","start_line":755,"end_line":763,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"show","line":663,"func_location":"AtomEnvironment.displayWindow","func_start_line":659,"func_end_line":673,"args":[],"comment":[" Restore the window to its previous dimensions and show it.",""," Restores the full screen and maximized state after the window has resized to"," prevent resize glitches."],"code":"  async displayWindow () {\r\n    await this.restoreWindowDimensions()\r\n    const steps = [\r\n      this.restoreWindowBackground(),\r\n      this.show(),\r\n      this.focus()\r\n    ]\r\n    if (this.windowDimensions && this.windowDimensions.fullScreen) {\r\n      steps.push(this.setFullScreen(true))\r\n    }\r\n    if (this.windowDimensions && this.windowDimensions.maximized && process.platform !== 'darwin') {\r\n      steps.push(this.maximize())\r\n    }\r\n    await Promise.all(steps)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.show","start_line":612,"end_line":614,"comment":[" Extended: Show the current window."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"focus","line":664,"func_location":"AtomEnvironment.displayWindow","func_start_line":659,"func_end_line":673,"args":[],"comment":[" Restore the window to its previous dimensions and show it.",""," Restores the full screen and maximized state after the window has resized to"," prevent resize glitches."],"code":"  async displayWindow () {\r\n    await this.restoreWindowDimensions()\r\n    const steps = [\r\n      this.restoreWindowBackground(),\r\n      this.show(),\r\n      this.focus()\r\n    ]\r\n    if (this.windowDimensions && this.windowDimensions.fullScreen) {\r\n      steps.push(this.setFullScreen(true))\r\n    }\r\n    if (this.windowDimensions && this.windowDimensions.maximized && process.platform !== 'darwin') {\r\n      steps.push(this.maximize())\r\n    }\r\n    await Promise.all(steps)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.focus","start_line":606,"end_line":609,"comment":[" Extended: Focus the current window."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"setFullScreen","line":667,"func_location":"AtomEnvironment.displayWindow","func_start_line":659,"func_end_line":673,"args":[null],"comment":[" Restore the window to its previous dimensions and show it.",""," Restores the full screen and maximized state after the window has resized to"," prevent resize glitches."],"code":"  async displayWindow () {\r\n    await this.restoreWindowDimensions()\r\n    const steps = [\r\n      this.restoreWindowBackground(),\r\n      this.show(),\r\n      this.focus()\r\n    ]\r\n    if (this.windowDimensions && this.windowDimensions.fullScreen) {\r\n      steps.push(this.setFullScreen(true))\r\n    }\r\n    if (this.windowDimensions && this.windowDimensions.maximized && process.platform !== 'darwin') {\r\n      steps.push(this.maximize())\r\n    }\r\n    await Promise.all(steps)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.setFullScreen","start_line":646,"end_line":648,"comment":[" Extended: Set the full screen state of the current window."],"params":["fullScreen"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"maximize","line":670,"func_location":"AtomEnvironment.displayWindow","func_start_line":659,"func_end_line":673,"args":[null],"comment":[" Restore the window to its previous dimensions and show it.",""," Restores the full screen and maximized state after the window has resized to"," prevent resize glitches."],"code":"  async displayWindow () {\r\n    await this.restoreWindowDimensions()\r\n    const steps = [\r\n      this.restoreWindowBackground(),\r\n      this.show(),\r\n      this.focus()\r\n    ]\r\n    if (this.windowDimensions && this.windowDimensions.fullScreen) {\r\n      steps.push(this.setFullScreen(true))\r\n    }\r\n    if (this.windowDimensions && this.windowDimensions.maximized && process.platform !== 'darwin') {\r\n      steps.push(this.maximize())\r\n    }\r\n    await Promise.all(steps)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.maximize","start_line":636,"end_line":638,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js","name":"disposeProjectMenu","line":106,"func_location":"ReopenProjectMenuManager.dispose","func_start_line":104,"func_end_line":110,"args":[],"code":"  dispose () {\r\n    this.subscriptions.dispose()\r\n    this.disposeProjectMenu()\r\n    if (this.reopenProjectListView != null) {\r\n      this.reopenProjectListView.dispose()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js","name":"ReopenProjectMenuManager.disposeProjectMenu","start_line":112,"end_line":117,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js","name":"cancel","line":36,"func_location":"ReopenProjectListView.dispose","func_start_line":35,"func_end_line":38,"args":[],"code":"  dispose () {\r\n    this.cancel()\r\n    return this.selectListView.destroy()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js","name":"ReopenProjectListView.cancel","start_line":40,"end_line":50,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"getApproximateLongestScreenRow","line":308,"func_location":"TextEditor.doBackgroundWork","func_start_line":307,"func_end_line":318,"args":[],"code":"  doBackgroundWork (deadline) {\r\n    const previousLongestRow = this.getApproximateLongestScreenRow()\r\n    if (this.displayLayer.doBackgroundWork(deadline)) {\r\n      this.backgroundWorkHandle = requestIdleCallback(this.doBackgroundWork)\r\n    } else {\r\n      this.backgroundWorkHandle = null\r\n    }\r\n\r\n    if (this.component && this.getApproximateLongestScreenRow() !== previousLongestRow) {\r\n      this.component.scheduleUpdate()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.getApproximateLongestScreenRow","start_line":1296,"end_line":1296,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"getApproximateLongestScreenRow","line":315,"func_location":"TextEditor.doBackgroundWork","func_start_line":307,"func_end_line":318,"args":[],"code":"  doBackgroundWork (deadline) {\r\n    const previousLongestRow = this.getApproximateLongestScreenRow()\r\n    if (this.displayLayer.doBackgroundWork(deadline)) {\r\n      this.backgroundWorkHandle = requestIdleCallback(this.doBackgroundWork)\r\n    } else {\r\n      this.backgroundWorkHandle = null\r\n    }\r\n\r\n    if (this.component && this.getApproximateLongestScreenRow() !== previousLongestRow) {\r\n      this.component.scheduleUpdate()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.getApproximateLongestScreenRow","start_line":1296,"end_line":1296,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"setState","line":322,"func_location":"Dock.draggedOut","func_start_line":321,"func_end_line":325,"args":[null],"code":"  draggedOut () {\r\n    this.setState({showDropTarget: false})\r\n    window.removeEventListener('drag', this.handleDrag)\r\n    window.removeEventListener('dragend', this.handleDragEnd)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.setState","start_line":144,"end_line":177,"comment":[],"params":["newState"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"getBuffers","line":754,"func_location":"Project.eachBuffer","func_start_line":749,"func_end_line":760,"args":[],"code":"  eachBuffer (...args) {\r\n    let subscriber\r\n    if (args.length > 1) { subscriber = args.shift() }\r\n    const callback = args.shift()\r\n\r\n    for (let buffer of this.getBuffers()) { callback(buffer) }\r\n    if (subscriber) {\r\n      return subscriber.subscribe(this, 'buffer-created', buffer => callback(buffer))\r\n    } else {\r\n      return this.on('buffer-created', buffer => callback(buffer))\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.getBuffers","start_line":621,"end_line":623,"comment":[" Retrieves all the {TextBuffer}s in the project; that is, the"," buffers for all open files.",""," Returns an {Array} of {TextBuffer}s."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"emitWindowEvent","line":94,"func_location":"AutoUpdateManager.emitUpdateAvailableEvent","func_start_line":92,"func_end_line":95,"args":[{"type":"string"},null],"code":"  emitUpdateAvailableEvent () {\r\n    if (this.releaseVersion == null) return\r\n    this.emitWindowEvent('update-available', {releaseVersion: this.releaseVersion})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"AutoUpdateManager.emitWindowEvent","start_line":97,"end_line":101,"comment":[],"params":["eventName","payload"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"getWindows","line":98,"func_location":"AutoUpdateManager.emitWindowEvent","func_start_line":97,"func_end_line":101,"args":[],"code":"  emitWindowEvent (eventName, payload) {\r\n    for (let atomWindow of this.getWindows()) {\r\n      atomWindow.sendMessage(eventName, payload)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"AutoUpdateManager.getWindows","start_line":175,"end_line":177,"comment":[" noop callback to get async behavior"],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"update","line":1011,"func_location":"TextEditor.enableKeyboardInput","func_start_line":1010,"func_end_line":1012,"args":[null],"code":"  enableKeyboardInput (enabled) {\r\n    this.update({keyboardInputEnabled: enabled})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.update","start_line":320,"end_line":539,"comment":[],"params":["params"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"loadPackage","line":257,"func_location":"PackageManager.enablePackage","func_start_line":256,"func_end_line":262,"args":["name"],"comment":["\r\n  Section: Enabling and disabling packages\r\n  "," Public: Enable the package with the given name.",""," * `name` - The {String} package name.",""," Returns the {Package} that was enabled or null if it isn't loaded."],"code":"  enablePackage (name) {\r\n    const pack = this.loadPackage(name)\r\n    if (pack != null) {\r\n      pack.enable()\r\n    }\r\n    return pack\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.loadPackage","start_line":551,"end_line":569,"comment":[],"params":["nameOrPath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"flattenMenuItems","line":97,"func_location":"ApplicationMenu.enableWindowSpecificItems","func_start_line":96,"func_end_line":100,"args":[".menu"],"comment":[" Public: Used to make all window related menu items are active.",""," enable - If true enables all window specific items, if false disables all","          window specific items."],"code":"  enableWindowSpecificItems (enable) {\r\n    for (let item of this.flattenMenuItems(this.menu)) {\r\n      if (item.metadata && item.metadata.windowSpecific) item.enabled = enable\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"ApplicationMenu.flattenMenuItems","start_line":67,"end_line":76,"comment":[" Flattens the given menu and submenu items into an single Array.",""," menu - A complete menu configuration object for atom-shell's menu API.",""," Returns an Array of native menu items."],"params":["menu"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"indentLevelForLine","line":678,"func_location":"TextMateLanguageMode.endRowForCodeFoldAtRow","func_start_line":674,"func_end_line":695,"args":["line","tabLength"],"code":"  endRowForCodeFoldAtRow (row, tabLength, existenceOnly) {\r\n    let foldEndRow\r\n    const line = this.buffer.lineForRow(row)\r\n    if (!NON_WHITESPACE_REGEX.test(line)) return\r\n    const startIndentLevel = this.indentLevelForLine(line, tabLength)\r\n    const scopeDescriptor = this.scopeDescriptorForPosition([row, 0])\r\n    const foldEndRegex = this.foldEndRegexForScopeDescriptor(scopeDescriptor)\r\n    for (let nextRow = row + 1, end = this.buffer.getLineCount(); nextRow < end; nextRow++) {\r\n      const line = this.buffer.lineForRow(nextRow)\r\n      if (!NON_WHITESPACE_REGEX.test(line)) continue\r\n      const indentation = this.indentLevelForLine(line, tabLength)\r\n      if (indentation < startIndentLevel) {\r\n        break\r\n      } else if (indentation === startIndentLevel) {\r\n        if (foldEndRegex && foldEndRegex.searchSync(line)) foldEndRow = nextRow\r\n        break\r\n      }\r\n      foldEndRow = nextRow\r\n      if (existenceOnly) break\r\n    }\r\n    return foldEndRow\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.indentLevelForLine","start_line":492,"end_line":505,"comment":[],"params":["line","tabLength"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"scopeDescriptorForPosition","line":679,"func_location":"TextMateLanguageMode.endRowForCodeFoldAtRow","func_start_line":674,"func_end_line":695,"args":[null],"code":"  endRowForCodeFoldAtRow (row, tabLength, existenceOnly) {\r\n    let foldEndRow\r\n    const line = this.buffer.lineForRow(row)\r\n    if (!NON_WHITESPACE_REGEX.test(line)) return\r\n    const startIndentLevel = this.indentLevelForLine(line, tabLength)\r\n    const scopeDescriptor = this.scopeDescriptorForPosition([row, 0])\r\n    const foldEndRegex = this.foldEndRegexForScopeDescriptor(scopeDescriptor)\r\n    for (let nextRow = row + 1, end = this.buffer.getLineCount(); nextRow < end; nextRow++) {\r\n      const line = this.buffer.lineForRow(nextRow)\r\n      if (!NON_WHITESPACE_REGEX.test(line)) continue\r\n      const indentation = this.indentLevelForLine(line, tabLength)\r\n      if (indentation < startIndentLevel) {\r\n        break\r\n      } else if (indentation === startIndentLevel) {\r\n        if (foldEndRegex && foldEndRegex.searchSync(line)) foldEndRow = nextRow\r\n        break\r\n      }\r\n      foldEndRow = nextRow\r\n      if (existenceOnly) break\r\n    }\r\n    return foldEndRow\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.scopeDescriptorForPosition","start_line":507,"end_line":526,"comment":[],"params":["position"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"foldEndRegexForScopeDescriptor","line":680,"func_location":"TextMateLanguageMode.endRowForCodeFoldAtRow","func_start_line":674,"func_end_line":695,"args":["scopeDescriptor"],"code":"  endRowForCodeFoldAtRow (row, tabLength, existenceOnly) {\r\n    let foldEndRow\r\n    const line = this.buffer.lineForRow(row)\r\n    if (!NON_WHITESPACE_REGEX.test(line)) return\r\n    const startIndentLevel = this.indentLevelForLine(line, tabLength)\r\n    const scopeDescriptor = this.scopeDescriptorForPosition([row, 0])\r\n    const foldEndRegex = this.foldEndRegexForScopeDescriptor(scopeDescriptor)\r\n    for (let nextRow = row + 1, end = this.buffer.getLineCount(); nextRow < end; nextRow++) {\r\n      const line = this.buffer.lineForRow(nextRow)\r\n      if (!NON_WHITESPACE_REGEX.test(line)) continue\r\n      const indentation = this.indentLevelForLine(line, tabLength)\r\n      if (indentation < startIndentLevel) {\r\n        break\r\n      } else if (indentation === startIndentLevel) {\r\n        if (foldEndRegex && foldEndRegex.searchSync(line)) foldEndRow = nextRow\r\n        break\r\n      }\r\n      foldEndRow = nextRow\r\n      if (existenceOnly) break\r\n    }\r\n    return foldEndRow\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.foldEndRegexForScopeDescriptor","start_line":709,"end_line":711,"comment":[],"params":["scope"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"indentLevelForLine","line":684,"func_location":"TextMateLanguageMode.endRowForCodeFoldAtRow","func_start_line":674,"func_end_line":695,"args":["line","tabLength"],"code":"  endRowForCodeFoldAtRow (row, tabLength, existenceOnly) {\r\n    let foldEndRow\r\n    const line = this.buffer.lineForRow(row)\r\n    if (!NON_WHITESPACE_REGEX.test(line)) return\r\n    const startIndentLevel = this.indentLevelForLine(line, tabLength)\r\n    const scopeDescriptor = this.scopeDescriptorForPosition([row, 0])\r\n    const foldEndRegex = this.foldEndRegexForScopeDescriptor(scopeDescriptor)\r\n    for (let nextRow = row + 1, end = this.buffer.getLineCount(); nextRow < end; nextRow++) {\r\n      const line = this.buffer.lineForRow(nextRow)\r\n      if (!NON_WHITESPACE_REGEX.test(line)) continue\r\n      const indentation = this.indentLevelForLine(line, tabLength)\r\n      if (indentation < startIndentLevel) {\r\n        break\r\n      } else if (indentation === startIndentLevel) {\r\n        if (foldEndRegex && foldEndRegex.searchSync(line)) foldEndRow = nextRow\r\n        break\r\n      }\r\n      foldEndRow = nextRow\r\n      if (existenceOnly) break\r\n    }\r\n    return foldEndRow\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.indentLevelForLine","start_line":492,"end_line":505,"comment":[],"params":["line","tabLength"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"isRowCommented","line":662,"func_location":"TextMateLanguageMode.endRowForCommentFoldAtRow","func_start_line":661,"func_end_line":672,"args":[null],"code":"  endRowForCommentFoldAtRow (row, existenceOnly) {\r\n    if (this.isRowCommented(row - 1)) return\r\n\r\n    let endRow\r\n    for (let nextRow = row + 1, end = this.buffer.getLineCount(); nextRow < end; nextRow++) {\r\n      if (!this.isRowCommented(nextRow)) break\r\n      endRow = nextRow\r\n      if (existenceOnly) break\r\n    }\r\n\r\n    return endRow\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.isRowCommented","start_line":600,"end_line":602,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"isRowCommented","line":666,"func_location":"TextMateLanguageMode.endRowForCommentFoldAtRow","func_start_line":661,"func_end_line":672,"args":["nextRow"],"code":"  endRowForCommentFoldAtRow (row, existenceOnly) {\r\n    if (this.isRowCommented(row - 1)) return\r\n\r\n    let endRow\r\n    for (let nextRow = row + 1, end = this.buffer.getLineCount(); nextRow < end; nextRow++) {\r\n      if (!this.isRowCommented(nextRow)) break\r\n      endRow = nextRow\r\n      if (existenceOnly) break\r\n    }\r\n\r\n    return endRow\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.isRowCommented","start_line":600,"end_line":602,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"isRowCommented","line":654,"func_location":"TextMateLanguageMode.endRowForFoldAtRow","func_start_line":653,"func_end_line":659,"args":["row"],"code":"  endRowForFoldAtRow (row, tabLength, existenceOnly = false) {\r\n    if (this.isRowCommented(row)) {\r\n      return this.endRowForCommentFoldAtRow(row, existenceOnly)\r\n    } else {\r\n      return this.endRowForCodeFoldAtRow(row, tabLength, existenceOnly)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.isRowCommented","start_line":600,"end_line":602,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"endRowForCommentFoldAtRow","line":655,"func_location":"TextMateLanguageMode.endRowForFoldAtRow","func_start_line":653,"func_end_line":659,"args":["row","existenceOnly"],"code":"  endRowForFoldAtRow (row, tabLength, existenceOnly = false) {\r\n    if (this.isRowCommented(row)) {\r\n      return this.endRowForCommentFoldAtRow(row, existenceOnly)\r\n    } else {\r\n      return this.endRowForCodeFoldAtRow(row, tabLength, existenceOnly)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.endRowForCommentFoldAtRow","start_line":661,"end_line":672,"comment":[],"params":["row","existenceOnly"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"endRowForCodeFoldAtRow","line":657,"func_location":"TextMateLanguageMode.endRowForFoldAtRow","func_start_line":653,"func_end_line":659,"args":["row","tabLength","existenceOnly"],"code":"  endRowForFoldAtRow (row, tabLength, existenceOnly = false) {\r\n    if (this.isRowCommented(row)) {\r\n      return this.endRowForCommentFoldAtRow(row, existenceOnly)\r\n    } else {\r\n      return this.endRowForCodeFoldAtRow(row, tabLength, existenceOnly)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.endRowForCodeFoldAtRow","start_line":674,"end_line":695,"comment":[],"params":["row","tabLength","existenceOnly"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"emitChangeEvent","line":868,"func_location":"Config.endTransaction","func_start_line":866,"func_end_line":869,"args":[],"code":"  endTransaction () {\r\n    this.transactDepth--\r\n    this.emitChangeEvent()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.emitChangeEvent","start_line":1211,"end_line":1213,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"open","line":44,"func_location":"GitRepository.exists","func_start_line":43,"func_end_line":51,"args":["path"],"code":"  static exists (path) {\r\n    const git = this.open(path)\r\n    if (git) {\r\n      git.destroy()\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.open","start_line":65,"end_line":72,"comment":["\r\n  Section: Construction and Destruction\r\n  "," Public: Creates a new GitRepository instance.",""," * `path` The {String} path to the Git repository to open."," * `options` An optional {Object} with the following keys:","   * `refreshOnWindowFocus` A {Boolean}, `true` to refresh the index and","     statuses when the window is focused.",""," Returns a {GitRepository} instance or `null` if the repository could not be opened."],"params":["path","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"getBufferRange","line":404,"func_location":"Selection.expandOverLine","func_start_line":403,"func_end_line":408,"args":[null],"comment":[" Public: Expands the newest selection to include the entire line on which"," the cursor currently rests.",""," It also includes the newline character."],"code":"  expandOverLine (options) {\r\n    const range = this.getBufferRange().union(this.cursor.getCurrentLineBufferRange({includeNewline: true}))\r\n    this.setBufferRange(range, {autoscroll: false})\r\n    const autoscroll = options && options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.cursor.autoscroll()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.getBufferRange","start_line":79,"end_line":81,"comment":[" Public: Returns the buffer {Range} for the selection."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"setBufferRange","line":405,"func_location":"Selection.expandOverLine","func_start_line":403,"func_end_line":408,"args":["range",null],"comment":[" Public: Expands the newest selection to include the entire line on which"," the cursor currently rests.",""," It also includes the newline character."],"code":"  expandOverLine (options) {\r\n    const range = this.getBufferRange().union(this.cursor.getCurrentLineBufferRange({includeNewline: true}))\r\n    this.setBufferRange(range, {autoscroll: false})\r\n    const autoscroll = options && options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.cursor.autoscroll()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.setBufferRange","start_line":92,"end_line":104,"comment":[" Public: Modifies the buffer {Range} for the selection.",""," * `bufferRange` The new {Range} to select."," * `options` (optional) {Object} with the keys:","   * `preserveFolds` if `true`, the fold settings are preserved after the","     selection moves.","   * `autoscroll` {Boolean} indicating whether to autoscroll to the new","     range. Defaults to `true` if this is the most recently added selection,","     `false` otherwise."],"params":["bufferRange","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"isLastSelection","line":406,"func_location":"Selection.expandOverLine","func_start_line":403,"func_end_line":408,"args":[],"comment":[" Public: Expands the newest selection to include the entire line on which"," the cursor currently rests.",""," It also includes the newline character."],"code":"  expandOverLine (options) {\r\n    const range = this.getBufferRange().union(this.cursor.getCurrentLineBufferRange({includeNewline: true}))\r\n    this.setBufferRange(range, {autoscroll: false})\r\n    const autoscroll = options && options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.cursor.autoscroll()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.isLastSelection","start_line":29,"end_line":31,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"setBufferRange","line":377,"func_location":"Selection.expandOverWord","func_start_line":376,"func_end_line":380,"args":[null,null],"comment":[" Public: Expands the newest selection to include the entire word on which"," the cursors rests."],"code":"  expandOverWord (options) {\r\n    this.setBufferRange(this.getBufferRange().union(this.cursor.getCurrentWordBufferRange()), {autoscroll: false})\r\n    const autoscroll = options && options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.cursor.autoscroll()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.setBufferRange","start_line":92,"end_line":104,"comment":[" Public: Modifies the buffer {Range} for the selection.",""," * `bufferRange` The new {Range} to select."," * `options` (optional) {Object} with the keys:","   * `preserveFolds` if `true`, the fold settings are preserved after the","     selection moves.","   * `autoscroll` {Boolean} indicating whether to autoscroll to the new","     range. Defaults to `true` if this is the most recently added selection,","     `false` otherwise."],"params":["bufferRange","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"getBufferRange","line":377,"func_location":"Selection.expandOverWord","func_start_line":376,"func_end_line":380,"args":[null,null],"comment":[" Public: Expands the newest selection to include the entire word on which"," the cursors rests."],"code":"  expandOverWord (options) {\r\n    this.setBufferRange(this.getBufferRange().union(this.cursor.getCurrentWordBufferRange()), {autoscroll: false})\r\n    const autoscroll = options && options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.cursor.autoscroll()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.getBufferRange","start_line":79,"end_line":81,"comment":[" Public: Returns the buffer {Range} for the selection."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"isLastSelection","line":378,"func_location":"Selection.expandOverWord","func_start_line":376,"func_end_line":380,"args":[],"comment":[" Public: Expands the newest selection to include the entire word on which"," the cursors rests."],"code":"  expandOverWord (options) {\r\n    this.setBufferRange(this.getBufferRange().union(this.cursor.getCurrentWordBufferRange()), {autoscroll: false})\r\n    const autoscroll = options && options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.cursor.autoscroll()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.isLastSelection","start_line":29,"end_line":31,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/initialize-benchmark-window.js","name":"exitWithStatusCode","line":97,"func_location":"module.exports","func_start_line":6,"func_end_line":108,"args":["statusCode"],"code":"module.exports = async function () {\r\n  const getWindowLoadSettings = require('./get-window-load-settings')\r\n  const {test, headless, resourcePath, benchmarkPaths} = getWindowLoadSettings()\r\n  try {\r\n    const Clipboard = require('../src/clipboard')\r\n    const ApplicationDelegate = require('../src/application-delegate')\r\n    const AtomEnvironment = require('../src/atom-environment')\r\n    const TextEditor = require('../src/text-editor')\r\n    require('./electron-shims')\r\n\r\n    const exportsPath = path.join(resourcePath, 'exports')\r\n    require('module').globalPaths.push(exportsPath) // Add 'exports' to module search path.\r\n    process.env.NODE_PATH = exportsPath // Set NODE_PATH env variable since tasks may need it.\r\n\r\n    document.title = 'Benchmarks'\r\n    // Allow `document.title` to be assigned in benchmarks without actually changing the window title.\r\n    let documentTitle = null\r\n    Object.defineProperty(document, 'title', {\r\n      get () { return documentTitle },\r\n      set (title) { documentTitle = title }\r\n    })\r\n\r\n    window.addEventListener('keydown', (event) => {\r\n      // Reload: cmd-r / ctrl-r\r\n      if ((event.metaKey || event.ctrlKey) && event.keyCode === 82) {\r\n        ipcHelpers.call('window-method', 'reload')\r\n      }\r\n\r\n      // Toggle Dev Tools: cmd-alt-i (Mac) / ctrl-shift-i (Linux/Windows)\r\n      if (event.keyCode === 73) {\r\n        const isDarwin = process.platform === 'darwin'\r\n        if ((isDarwin && event.metaKey && event.altKey) || (!isDarwin && event.ctrlKey && event.shiftKey)) {\r\n          ipcHelpers.call('window-method', 'toggleDevTools')\r\n        }\r\n      }\r\n\r\n      // Close: cmd-w / ctrl-w\r\n      if ((event.metaKey || event.ctrlKey) && event.keyCode === 87) {\r\n        ipcHelpers.call('window-method', 'close')\r\n      }\r\n\r\n      // Copy: cmd-c / ctrl-c\r\n      if ((event.metaKey || event.ctrlKey) && event.keyCode === 67) {\r\n        ipcHelpers.call('window-method', 'copy')\r\n      }\r\n    }, true)\r\n\r\n    const clipboard = new Clipboard()\r\n    TextEditor.setClipboard(clipboard)\r\n    TextEditor.viewForItem = (item) => atom.views.getView(item)\r\n\r\n    const applicationDelegate = new ApplicationDelegate()\r\n    const environmentParams = {\r\n      applicationDelegate,\r\n      window,\r\n      document,\r\n      clipboard,\r\n      configDirPath: process.env.ATOM_HOME,\r\n      enablePersistence: false\r\n    }\r\n    global.atom = new AtomEnvironment(environmentParams)\r\n    global.atom.initialize(environmentParams)\r\n\r\n    // Prevent benchmarks from modifying application menus\r\n    global.atom.menu.sendToBrowserProcess = function () { }\r\n\r\n    if (headless) {\r\n      Object.defineProperties(process, {\r\n        stdout: { value: remote.process.stdout },\r\n        stderr: { value: remote.process.stderr }\r\n      })\r\n\r\n      console.log = function (...args) {\r\n        const formatted = util.format(...args)\r\n        process.stdout.write(formatted + '\\n')\r\n      }\r\n      console.warn = function (...args) {\r\n        const formatted = util.format(...args)\r\n        process.stderr.write(formatted + '\\n')\r\n      }\r\n      console.error = function (...args) {\r\n        const formatted = util.format(...args)\r\n        process.stderr.write(formatted + '\\n')\r\n      }\r\n    } else {\r\n      remote.getCurrentWindow().show()\r\n    }\r\n\r\n    const benchmarkRunner = require('../benchmarks/benchmark-runner')\r\n    const statusCode = await benchmarkRunner({test, benchmarkPaths})\r\n    if (headless) {\r\n      exitWithStatusCode(statusCode)\r\n    }\r\n  } catch (error) {\r\n    if (headless) {\r\n      console.error(error.stack || error)\r\n      exitWithStatusCode(1)\r\n    } else {\r\n      ipcHelpers.call('window-method', 'openDevTools')\r\n      throw error\r\n    }\r\n  }\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/initialize-benchmark-window.js","name":"exitWithStatusCode","start_line":110,"end_line":113,"comment":[],"params":["statusCode"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/initialize-benchmark-window.js","name":"error","line":101,"func_location":"module.exports","func_start_line":6,"func_end_line":108,"args":[null],"code":"module.exports = async function () {\r\n  const getWindowLoadSettings = require('./get-window-load-settings')\r\n  const {test, headless, resourcePath, benchmarkPaths} = getWindowLoadSettings()\r\n  try {\r\n    const Clipboard = require('../src/clipboard')\r\n    const ApplicationDelegate = require('../src/application-delegate')\r\n    const AtomEnvironment = require('../src/atom-environment')\r\n    const TextEditor = require('../src/text-editor')\r\n    require('./electron-shims')\r\n\r\n    const exportsPath = path.join(resourcePath, 'exports')\r\n    require('module').globalPaths.push(exportsPath) // Add 'exports' to module search path.\r\n    process.env.NODE_PATH = exportsPath // Set NODE_PATH env variable since tasks may need it.\r\n\r\n    document.title = 'Benchmarks'\r\n    // Allow `document.title` to be assigned in benchmarks without actually changing the window title.\r\n    let documentTitle = null\r\n    Object.defineProperty(document, 'title', {\r\n      get () { return documentTitle },\r\n      set (title) { documentTitle = title }\r\n    })\r\n\r\n    window.addEventListener('keydown', (event) => {\r\n      // Reload: cmd-r / ctrl-r\r\n      if ((event.metaKey || event.ctrlKey) && event.keyCode === 82) {\r\n        ipcHelpers.call('window-method', 'reload')\r\n      }\r\n\r\n      // Toggle Dev Tools: cmd-alt-i (Mac) / ctrl-shift-i (Linux/Windows)\r\n      if (event.keyCode === 73) {\r\n        const isDarwin = process.platform === 'darwin'\r\n        if ((isDarwin && event.metaKey && event.altKey) || (!isDarwin && event.ctrlKey && event.shiftKey)) {\r\n          ipcHelpers.call('window-method', 'toggleDevTools')\r\n        }\r\n      }\r\n\r\n      // Close: cmd-w / ctrl-w\r\n      if ((event.metaKey || event.ctrlKey) && event.keyCode === 87) {\r\n        ipcHelpers.call('window-method', 'close')\r\n      }\r\n\r\n      // Copy: cmd-c / ctrl-c\r\n      if ((event.metaKey || event.ctrlKey) && event.keyCode === 67) {\r\n        ipcHelpers.call('window-method', 'copy')\r\n      }\r\n    }, true)\r\n\r\n    const clipboard = new Clipboard()\r\n    TextEditor.setClipboard(clipboard)\r\n    TextEditor.viewForItem = (item) => atom.views.getView(item)\r\n\r\n    const applicationDelegate = new ApplicationDelegate()\r\n    const environmentParams = {\r\n      applicationDelegate,\r\n      window,\r\n      document,\r\n      clipboard,\r\n      configDirPath: process.env.ATOM_HOME,\r\n      enablePersistence: false\r\n    }\r\n    global.atom = new AtomEnvironment(environmentParams)\r\n    global.atom.initialize(environmentParams)\r\n\r\n    // Prevent benchmarks from modifying application menus\r\n    global.atom.menu.sendToBrowserProcess = function () { }\r\n\r\n    if (headless) {\r\n      Object.defineProperties(process, {\r\n        stdout: { value: remote.process.stdout },\r\n        stderr: { value: remote.process.stderr }\r\n      })\r\n\r\n      console.log = function (...args) {\r\n        const formatted = util.format(...args)\r\n        process.stdout.write(formatted + '\\n')\r\n      }\r\n      console.warn = function (...args) {\r\n        const formatted = util.format(...args)\r\n        process.stderr.write(formatted + '\\n')\r\n      }\r\n      console.error = function (...args) {\r\n        const formatted = util.format(...args)\r\n        process.stderr.write(formatted + '\\n')\r\n      }\r\n    } else {\r\n      remote.getCurrentWindow().show()\r\n    }\r\n\r\n    const benchmarkRunner = require('../benchmarks/benchmark-runner')\r\n    const statusCode = await benchmarkRunner({test, benchmarkPaths})\r\n    if (headless) {\r\n      exitWithStatusCode(statusCode)\r\n    }\r\n  } catch (error) {\r\n    if (headless) {\r\n      console.error(error.stack || error)\r\n      exitWithStatusCode(1)\r\n    } else {\r\n      ipcHelpers.call('window-method', 'openDevTools')\r\n      throw error\r\n    }\r\n  }\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/initialize-benchmark-window.js","name":"console.error","start_line":86,"end_line":89,"comment":[],"params":["args"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/initialize-benchmark-window.js","name":"exitWithStatusCode","line":102,"func_location":"module.exports","func_start_line":6,"func_end_line":108,"args":[{"type":"number"}],"code":"module.exports = async function () {\r\n  const getWindowLoadSettings = require('./get-window-load-settings')\r\n  const {test, headless, resourcePath, benchmarkPaths} = getWindowLoadSettings()\r\n  try {\r\n    const Clipboard = require('../src/clipboard')\r\n    const ApplicationDelegate = require('../src/application-delegate')\r\n    const AtomEnvironment = require('../src/atom-environment')\r\n    const TextEditor = require('../src/text-editor')\r\n    require('./electron-shims')\r\n\r\n    const exportsPath = path.join(resourcePath, 'exports')\r\n    require('module').globalPaths.push(exportsPath) // Add 'exports' to module search path.\r\n    process.env.NODE_PATH = exportsPath // Set NODE_PATH env variable since tasks may need it.\r\n\r\n    document.title = 'Benchmarks'\r\n    // Allow `document.title` to be assigned in benchmarks without actually changing the window title.\r\n    let documentTitle = null\r\n    Object.defineProperty(document, 'title', {\r\n      get () { return documentTitle },\r\n      set (title) { documentTitle = title }\r\n    })\r\n\r\n    window.addEventListener('keydown', (event) => {\r\n      // Reload: cmd-r / ctrl-r\r\n      if ((event.metaKey || event.ctrlKey) && event.keyCode === 82) {\r\n        ipcHelpers.call('window-method', 'reload')\r\n      }\r\n\r\n      // Toggle Dev Tools: cmd-alt-i (Mac) / ctrl-shift-i (Linux/Windows)\r\n      if (event.keyCode === 73) {\r\n        const isDarwin = process.platform === 'darwin'\r\n        if ((isDarwin && event.metaKey && event.altKey) || (!isDarwin && event.ctrlKey && event.shiftKey)) {\r\n          ipcHelpers.call('window-method', 'toggleDevTools')\r\n        }\r\n      }\r\n\r\n      // Close: cmd-w / ctrl-w\r\n      if ((event.metaKey || event.ctrlKey) && event.keyCode === 87) {\r\n        ipcHelpers.call('window-method', 'close')\r\n      }\r\n\r\n      // Copy: cmd-c / ctrl-c\r\n      if ((event.metaKey || event.ctrlKey) && event.keyCode === 67) {\r\n        ipcHelpers.call('window-method', 'copy')\r\n      }\r\n    }, true)\r\n\r\n    const clipboard = new Clipboard()\r\n    TextEditor.setClipboard(clipboard)\r\n    TextEditor.viewForItem = (item) => atom.views.getView(item)\r\n\r\n    const applicationDelegate = new ApplicationDelegate()\r\n    const environmentParams = {\r\n      applicationDelegate,\r\n      window,\r\n      document,\r\n      clipboard,\r\n      configDirPath: process.env.ATOM_HOME,\r\n      enablePersistence: false\r\n    }\r\n    global.atom = new AtomEnvironment(environmentParams)\r\n    global.atom.initialize(environmentParams)\r\n\r\n    // Prevent benchmarks from modifying application menus\r\n    global.atom.menu.sendToBrowserProcess = function () { }\r\n\r\n    if (headless) {\r\n      Object.defineProperties(process, {\r\n        stdout: { value: remote.process.stdout },\r\n        stderr: { value: remote.process.stderr }\r\n      })\r\n\r\n      console.log = function (...args) {\r\n        const formatted = util.format(...args)\r\n        process.stdout.write(formatted + '\\n')\r\n      }\r\n      console.warn = function (...args) {\r\n        const formatted = util.format(...args)\r\n        process.stderr.write(formatted + '\\n')\r\n      }\r\n      console.error = function (...args) {\r\n        const formatted = util.format(...args)\r\n        process.stderr.write(formatted + '\\n')\r\n      }\r\n    } else {\r\n      remote.getCurrentWindow().show()\r\n    }\r\n\r\n    const benchmarkRunner = require('../benchmarks/benchmark-runner')\r\n    const statusCode = await benchmarkRunner({test, benchmarkPaths})\r\n    if (headless) {\r\n      exitWithStatusCode(statusCode)\r\n    }\r\n  } catch (error) {\r\n    if (headless) {\r\n      console.error(error.stack || error)\r\n      exitWithStatusCode(1)\r\n    } else {\r\n      ipcHelpers.call('window-method', 'openDevTools')\r\n      throw error\r\n    }\r\n  }\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/initialize-benchmark-window.js","name":"exitWithStatusCode","start_line":110,"end_line":113,"comment":[],"params":["statusCode"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"extractDefaultsFromSchema","line":1159,"func_location":"Config.extractDefaultsFromSchema","func_start_line":1153,"func_end_line":1162,"args":["value"],"code":"  extractDefaultsFromSchema (schema) {\r\n    if (schema.default != null) {\r\n      return schema.default\r\n    } else if ((schema.type === 'object') && (schema.properties != null) && isPlainObject(schema.properties)) {\r\n      const defaults = {}\r\n      const properties = schema.properties || {}\r\n      for (let key in properties) { const value = properties[key]; defaults[key] = this.extractDefaultsFromSchema(value) }\r\n      return defaults\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.extractDefaultsFromSchema","start_line":1153,"end_line":1162,"comment":[],"params":["schema"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js","name":"indexOfGroupContainingCommand","line":137,"func_location":"findEdgesInGroup","func_start_line":132,"func_end_line":154,"args":["groups","command","group"],"code":"function findEdgesInGroup (groups, i, edges) {\r\n  const group = groups[i]\r\n  for (const item of group) {\r\n    if (item.beforeGroupContaining) {\r\n      for (const command of item.beforeGroupContaining) {\r\n        const to = indexOfGroupContainingCommand(groups, command, group)\r\n        if (to !== -1) {\r\n          pushOntoMultiMap(edges, to, i)\r\n          return\r\n        }\r\n      }\r\n    }\r\n    if (item.afterGroupContaining) {\r\n      for (const command of item.afterGroupContaining) {\r\n        const to = indexOfGroupContainingCommand(groups, command, group)\r\n        if (to !== -1) {\r\n          pushOntoMultiMap(edges, i, to)\r\n          return\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js","name":"indexOfGroupContainingCommand","start_line":37,"end_line":45,"comment":[],"params":["groups","command","ignoreGroup"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js","name":"indexOfGroupContainingCommand","line":146,"func_location":"findEdgesInGroup","func_start_line":132,"func_end_line":154,"args":["groups","command","group"],"code":"function findEdgesInGroup (groups, i, edges) {\r\n  const group = groups[i]\r\n  for (const item of group) {\r\n    if (item.beforeGroupContaining) {\r\n      for (const command of item.beforeGroupContaining) {\r\n        const to = indexOfGroupContainingCommand(groups, command, group)\r\n        if (to !== -1) {\r\n          pushOntoMultiMap(edges, to, i)\r\n          return\r\n        }\r\n      }\r\n    }\r\n    if (item.afterGroupContaining) {\r\n      for (const command of item.afterGroupContaining) {\r\n        const to = indexOfGroupContainingCommand(groups, command, group)\r\n        if (to !== -1) {\r\n          pushOntoMultiMap(edges, i, to)\r\n          return\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js","name":"indexOfGroupContainingCommand","start_line":37,"end_line":45,"comment":[],"params":["groups","command","ignoreGroup"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js","name":"normalizeLabel","line":59,"func_location":"findMatchingItemIndex","func_start_line":52,"func_end_line":66,"args":["item.label"],"code":"function findMatchingItemIndex (menu, { type, label, submenu }) {\r\n  if (type === 'separator') {\r\n    return -1\r\n  }\r\n  for (let index = 0; index < menu.length; index++) {\r\n    const item = menu[index]\r\n    if (\r\n      normalizeLabel(item.label) === normalizeLabel(label) &&\r\n      (item.submenu != null) === (submenu != null)\r\n    ) {\r\n      return index\r\n    }\r\n  }\r\n  return -1\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js","name":"normalizeLabel","start_line":68,"end_line":73,"comment":[],"params":["label"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js","name":"normalizeLabel","line":59,"func_location":"findMatchingItemIndex","func_start_line":52,"func_end_line":66,"args":["item.label"],"code":"function findMatchingItemIndex (menu, { type, label, submenu }) {\r\n  if (type === 'separator') {\r\n    return -1\r\n  }\r\n  for (let index = 0; index < menu.length; index++) {\r\n    const item = menu[index]\r\n    if (\r\n      normalizeLabel(item.label) === normalizeLabel(label) &&\r\n      (item.submenu != null) === (submenu != null)\r\n    ) {\r\n      return index\r\n    }\r\n  }\r\n  return -1\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js","name":"normalizeLabel","start_line":68,"end_line":73,"comment":[],"params":["label"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"findBottommostSibling","line":1202,"func_location":"Pane.findOrCreateBottommostSibling","func_start_line":1201,"func_end_line":1208,"args":[],"comment":[" If the parent is a vertical axis, returns its last child if it is a pane;"," otherwise returns a new pane created by splitting this pane bottomward."],"code":"  findOrCreateBottommostSibling () {\r\n    const bottommostSibling = this.findBottommostSibling()\r\n    if (bottommostSibling === this) {\r\n      return this.splitDown()\r\n    } else {\r\n      return bottommostSibling\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.findBottommostSibling","start_line":1186,"end_line":1197,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"splitDown","line":1204,"func_location":"Pane.findOrCreateBottommostSibling","func_start_line":1201,"func_end_line":1208,"args":[],"comment":[" If the parent is a vertical axis, returns its last child if it is a pane;"," otherwise returns a new pane created by splitting this pane bottomward."],"code":"  findOrCreateBottommostSibling () {\r\n    const bottommostSibling = this.findBottommostSibling()\r\n    if (bottommostSibling === this) {\r\n      return this.splitDown()\r\n    } else {\r\n      return bottommostSibling\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.splitDown","start_line":1092,"end_line":1094,"comment":[" Public: Creates a new pane below the receiver.",""," * `params` (optional) {Object} with the following keys:","   * `items` (optional) {Array} of items to add to the new pane.","   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane",""," Returns the new {Pane}."],"params":["params"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"findRightmostSibling","line":1163,"func_location":"Pane.findOrCreateRightmostSibling","func_start_line":1162,"func_end_line":1169,"args":[],"comment":[" If the parent is a horizontal axis, returns its last child if it is a pane;"," otherwise returns a new pane created by splitting this pane rightward."],"code":"  findOrCreateRightmostSibling () {\r\n    const rightmostSibling = this.findRightmostSibling()\r\n    if (rightmostSibling === this) {\r\n      return this.splitRight()\r\n    } else {\r\n      return rightmostSibling\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.findRightmostSibling","start_line":1147,"end_line":1158,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"splitRight","line":1165,"func_location":"Pane.findOrCreateRightmostSibling","func_start_line":1162,"func_end_line":1169,"args":[],"comment":[" If the parent is a horizontal axis, returns its last child if it is a pane;"," otherwise returns a new pane created by splitting this pane rightward."],"code":"  findOrCreateRightmostSibling () {\r\n    const rightmostSibling = this.findRightmostSibling()\r\n    if (rightmostSibling === this) {\r\n      return this.splitRight()\r\n    } else {\r\n      return rightmostSibling\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.splitRight","start_line":1070,"end_line":1072,"comment":[" Public: Create a new pane to the right of this pane.",""," * `params` (optional) {Object} with the following keys:","   * `items` (optional) {Array} of items to add to the new pane.","   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane",""," Returns the new {Pane}."],"params":["params"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"getPackageManager","line":1072,"func_location":"AtomApplication.findPackageWithName","func_start_line":1071,"func_end_line":1075,"args":[],"code":"  findPackageWithName (packageName, devMode) {\r\n    return this.getPackageManager(devMode).getAvailablePackageMetadata().find(({name}) =>\r\n      name === packageName\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.getPackageManager","start_line":1094,"end_line":1106,"comment":[],"params":["devMode"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"measure","line":111,"func_location":"Package.finishLoading","func_start_line":110,"func_end_line":120},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.measure","start_line":80,"end_line":85,"comment":[],"params":["key","fn"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"flattenMenuItems","line":73,"func_location":"ApplicationMenu.flattenMenuItems","func_start_line":67,"func_end_line":76,"args":[null],"comment":[" Flattens the given menu and submenu items into an single Array.",""," menu - A complete menu configuration object for atom-shell's menu API.",""," Returns an Array of native menu items."],"code":"  flattenMenuItems (menu) {\r\n    const object = menu.items || {}\r\n    let items = []\r\n    for (let index in object) {\r\n      const item = object[index]\r\n      items.push(item)\r\n      if (item.submenu) items = items.concat(this.flattenMenuItems(item.submenu))\r\n    }\r\n    return items\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"ApplicationMenu.flattenMenuItems","start_line":67,"end_line":76,"comment":[" Flattens the given menu and submenu items into an single Array.",""," menu - A complete menu configuration object for atom-shell's menu API.",""," Returns an Array of native menu items."],"params":["menu"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"flattenMenuTemplate","line":87,"func_location":"ApplicationMenu.flattenMenuTemplate","func_start_line":83,"func_end_line":90,"args":[null],"comment":[" Flattens the given menu template into an single Array.",""," template - An object describing the menu item.",""," Returns an Array of native menu items."],"code":"  flattenMenuTemplate (template) {\r\n    let items = []\r\n    for (let item of template) {\r\n      items.push(item)\r\n      if (item.submenu) items = items.concat(this.flattenMenuTemplate(item.submenu))\r\n    }\r\n    return items\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"ApplicationMenu.flattenMenuTemplate","start_line":83,"end_line":90,"comment":[" Flattens the given menu template into an single Array.",""," template - An object describing the menu item.",""," Returns an Array of native menu items."],"params":["template"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"setScrollTopRow","line":2020,"func_location":"TextEditorComponent.flushPendingLogicalScrollPosition","func_start_line":2017,"func_end_line":2033,"args":[".pendingScrollTopRow",{"type":"boolean"}],"code":"  flushPendingLogicalScrollPosition () {\r\n    let changedScrollTop = false\r\n    if (this.pendingScrollTopRow > 0) {\r\n      changedScrollTop = this.setScrollTopRow(this.pendingScrollTopRow, false)\r\n      this.pendingScrollTopRow = null\r\n    }\r\n\r\n    let changedScrollLeft = false\r\n    if (this.pendingScrollLeftColumn > 0) {\r\n      changedScrollLeft = this.setScrollLeftColumn(this.pendingScrollLeftColumn, false)\r\n      this.pendingScrollLeftColumn = null\r\n    }\r\n\r\n    if (changedScrollTop || changedScrollLeft) {\r\n      this.updateSync()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.setScrollTopRow","start_line":2853,"end_line":2864,"comment":[],"params":["scrollTopRow","scheduleUpdate"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"setScrollLeftColumn","line":2026,"func_location":"TextEditorComponent.flushPendingLogicalScrollPosition","func_start_line":2017,"func_end_line":2033,"args":[".pendingScrollLeftColumn",{"type":"boolean"}],"code":"  flushPendingLogicalScrollPosition () {\r\n    let changedScrollTop = false\r\n    if (this.pendingScrollTopRow > 0) {\r\n      changedScrollTop = this.setScrollTopRow(this.pendingScrollTopRow, false)\r\n      this.pendingScrollTopRow = null\r\n    }\r\n\r\n    let changedScrollLeft = false\r\n    if (this.pendingScrollLeftColumn > 0) {\r\n      changedScrollLeft = this.setScrollLeftColumn(this.pendingScrollLeftColumn, false)\r\n      this.pendingScrollLeftColumn = null\r\n    }\r\n\r\n    if (changedScrollTop || changedScrollLeft) {\r\n      this.updateSync()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.setScrollLeftColumn","start_line":2874,"end_line":2885,"comment":[],"params":["scrollLeftColumn","scheduleUpdate"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateSync","line":2031,"func_location":"TextEditorComponent.flushPendingLogicalScrollPosition","func_start_line":2017,"func_end_line":2033,"args":[],"code":"  flushPendingLogicalScrollPosition () {\r\n    let changedScrollTop = false\r\n    if (this.pendingScrollTopRow > 0) {\r\n      changedScrollTop = this.setScrollTopRow(this.pendingScrollTopRow, false)\r\n      this.pendingScrollTopRow = null\r\n    }\r\n\r\n    let changedScrollLeft = false\r\n    if (this.pendingScrollLeftColumn > 0) {\r\n      changedScrollLeft = this.setScrollLeftColumn(this.pendingScrollLeftColumn, false)\r\n      this.pendingScrollLeftColumn = null\r\n    }\r\n\r\n    if (changedScrollTop || changedScrollLeft) {\r\n      this.updateSync()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateSync","start_line":221,"end_line":289,"comment":[],"params":["useScheduler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"activate","line":397,"func_location":"Pane.focus","func_start_line":395,"func_end_line":398,"args":[],"comment":[" Called by the view layer to indicate that the pane has gained focus."],"code":"  focus () {\r\n    this.focused = true\r\n    return this.activate()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.activate","start_line":1012,"end_line":1016,"comment":[" Public: Makes this pane the *active* pane, causing it to gain focus."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"getAllWindows","line":749,"func_location":"AtomApplication.focusedWindow","func_start_line":748,"func_end_line":750,"args":[null],"comment":[" Public: Returns the currently focused {AtomWindow} or undefined if none."],"code":"  focusedWindow () {\r\n    return this.getAllWindows().find(window => window.isFocused())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.getAllWindows","start_line":321,"end_line":323,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"focusPaneViewInDirection","line":226,"func_location":"WorkspaceElement.focusPaneViewAbove","func_start_line":226,"func_end_line":226,"args":[{"type":"string"}],"code":"  focusPaneViewAbove () { this.focusPaneViewInDirection('above') }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.focusPaneViewInDirection","start_line":234,"end_line":238,"comment":[],"params":["direction","pane"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"focusPaneViewInDirection","line":228,"func_location":"WorkspaceElement.focusPaneViewBelow","func_start_line":228,"func_end_line":228,"args":[{"type":"string"}],"code":"  focusPaneViewBelow () { this.focusPaneViewInDirection('below') }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.focusPaneViewInDirection","start_line":234,"end_line":238,"comment":[],"params":["direction","pane"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"nearestVisiblePaneInDirection","line":236,"func_location":"WorkspaceElement.focusPaneViewInDirection","func_start_line":234,"func_end_line":238,"args":["direction","activePane"],"code":"  focusPaneViewInDirection (direction, pane) {\r\n    const activePane = this.model.getActivePane()\r\n    const paneToFocus = this.nearestVisiblePaneInDirection(direction, activePane)\r\n    paneToFocus && paneToFocus.focus()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.nearestVisiblePaneInDirection","start_line":268,"end_line":300,"comment":[],"params":["direction","pane"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"focusPaneViewInDirection","line":230,"func_location":"WorkspaceElement.focusPaneViewOnLeft","func_start_line":230,"func_end_line":230,"args":[{"type":"string"}],"code":"  focusPaneViewOnLeft () { this.focusPaneViewInDirection('left') }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.focusPaneViewInDirection","start_line":234,"end_line":238,"comment":[],"params":["direction","pane"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"focusPaneViewInDirection","line":232,"func_location":"WorkspaceElement.focusPaneViewOnRight","func_start_line":232,"func_end_line":232,"args":[{"type":"string"}],"code":"  focusPaneViewOnRight () { this.focusPaneViewInDirection('right') }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.focusPaneViewInDirection","start_line":234,"end_line":238,"comment":[],"params":["direction","pane"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"regexForPattern","line":710,"func_location":"TextMateLanguageMode.foldEndRegexForScopeDescriptor","func_start_line":709,"func_end_line":711,"args":[null],"code":"  foldEndRegexForScopeDescriptor (scope) {\r\n    return this.regexForPattern(this.config.get('editor.foldEndPattern', {scope}))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.regexForPattern","start_line":713,"end_line":720,"comment":[],"params":["pattern"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/scope-descriptor.js","name":"constructor","line":26,"func_location":"ScopeDescriptor.fromObject","func_start_line":22,"func_end_line":28},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/scope-descriptor.js","name":"ScopeDescriptor.constructor","start_line":38,"end_line":40,"comment":["\r\n  Section: Construction and Destruction\r\n  "," Public: Create a {ScopeDescriptor} object.",""," * `object` {Object}","   * `scopes` {Array} of {String}s"],"params":[["scopes"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"getRawScopedValue","line":597,"func_location":"Config.get","func_start_line":585,"func_end_line":602,"args":["scope","keyPath","options"],"comment":["\r\n  Section: Managing Settings\r\n  "," Essential: Retrieves the setting for the given key.",""," ### Examples",""," You might want to know what themes are enabled, so check `core.themes`",""," ```coffee"," atom.config.get('core.themes')"," ```",""," With scope descriptors you can get settings within a specific editor"," scope. For example, you might want to know `editor.tabLength` for ruby"," files.",""," ```coffee"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," ```",""," This setting in ruby files might be different than the global tabLength setting",""," ```coffee"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," ```",""," You can get the language scope descriptor via"," {TextEditor::getRootScopeDescriptor}. This will get the setting specifically"," for the editor's language.",""," ```coffee"," atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2"," ```",""," Additionally, you can get the setting at the specific cursor position.",""," ```coffee"," scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()"," atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2"," ```",""," * `keyPath` The {String} name of the key to retrieve."," * `options` (optional) {Object}","   * `sources` (optional) {Array} of {String} source names. If provided, only","     values that were associated with these sources during {::set} will be used.","   * `excludeSources` (optional) {Array} of {String} source names. If provided,","     values that  were associated with these sources during {::set} will not","     be used.","   * `scope` (optional) {ScopeDescriptor} describing a path from","     the root of the syntax tree to a token. Get one by calling","     {editor.getLastCursor().getScopeDescriptor()}","     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)","     for more information.",""," Returns the value from Atom's default settings, the user's configuration"," file in the type specified by the configuration schema."],"code":"  get (...args) {\r\n    let keyPath, options, scope\r\n    if (args.length > 1) {\r\n      if ((typeof args[0] === 'string') || (args[0] == null)) {\r\n        [keyPath, options] = args;\r\n        ({scope} = options)\r\n      }\r\n    } else {\r\n      [keyPath] = args\r\n    }\r\n\r\n    if (scope != null) {\r\n      const value = this.getRawScopedValue(scope, keyPath, options)\r\n      return value != null ? value : this.getRawValue(keyPath, options)\r\n    } else {\r\n      return this.getRawValue(keyPath, options)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.getRawScopedValue","start_line":1244,"end_line":1262,"comment":[],"params":["scopeDescriptor","keyPath","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"getRawValue","line":598,"func_location":"Config.get","func_start_line":585,"func_end_line":602,"args":["keyPath","options"],"comment":["\r\n  Section: Managing Settings\r\n  "," Essential: Retrieves the setting for the given key.",""," ### Examples",""," You might want to know what themes are enabled, so check `core.themes`",""," ```coffee"," atom.config.get('core.themes')"," ```",""," With scope descriptors you can get settings within a specific editor"," scope. For example, you might want to know `editor.tabLength` for ruby"," files.",""," ```coffee"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," ```",""," This setting in ruby files might be different than the global tabLength setting",""," ```coffee"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," ```",""," You can get the language scope descriptor via"," {TextEditor::getRootScopeDescriptor}. This will get the setting specifically"," for the editor's language.",""," ```coffee"," atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2"," ```",""," Additionally, you can get the setting at the specific cursor position.",""," ```coffee"," scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()"," atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2"," ```",""," * `keyPath` The {String} name of the key to retrieve."," * `options` (optional) {Object}","   * `sources` (optional) {Array} of {String} source names. If provided, only","     values that were associated with these sources during {::set} will be used.","   * `excludeSources` (optional) {Array} of {String} source names. If provided,","     values that  were associated with these sources during {::set} will not","     be used.","   * `scope` (optional) {ScopeDescriptor} describing a path from","     the root of the syntax tree to a token. Get one by calling","     {editor.getLastCursor().getScopeDescriptor()}","     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)","     for more information.",""," Returns the value from Atom's default settings, the user's configuration"," file in the type specified by the configuration schema."],"code":"  get (...args) {\r\n    let keyPath, options, scope\r\n    if (args.length > 1) {\r\n      if ((typeof args[0] === 'string') || (args[0] == null)) {\r\n        [keyPath, options] = args;\r\n        ({scope} = options)\r\n      }\r\n    } else {\r\n      [keyPath] = args\r\n    }\r\n\r\n    if (scope != null) {\r\n      const value = this.getRawScopedValue(scope, keyPath, options)\r\n      return value != null ? value : this.getRawValue(keyPath, options)\r\n    } else {\r\n      return this.getRawValue(keyPath, options)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.getRawValue","start_line":994,"end_line":1018,"comment":[],"params":["keyPath","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"getRawValue","line":600,"func_location":"Config.get","func_start_line":585,"func_end_line":602,"args":["keyPath","options"],"comment":["\r\n  Section: Managing Settings\r\n  "," Essential: Retrieves the setting for the given key.",""," ### Examples",""," You might want to know what themes are enabled, so check `core.themes`",""," ```coffee"," atom.config.get('core.themes')"," ```",""," With scope descriptors you can get settings within a specific editor"," scope. For example, you might want to know `editor.tabLength` for ruby"," files.",""," ```coffee"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," ```",""," This setting in ruby files might be different than the global tabLength setting",""," ```coffee"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," ```",""," You can get the language scope descriptor via"," {TextEditor::getRootScopeDescriptor}. This will get the setting specifically"," for the editor's language.",""," ```coffee"," atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2"," ```",""," Additionally, you can get the setting at the specific cursor position.",""," ```coffee"," scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()"," atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2"," ```",""," * `keyPath` The {String} name of the key to retrieve."," * `options` (optional) {Object}","   * `sources` (optional) {Array} of {String} source names. If provided, only","     values that were associated with these sources during {::set} will be used.","   * `excludeSources` (optional) {Array} of {String} source names. If provided,","     values that  were associated with these sources during {::set} will not","     be used.","   * `scope` (optional) {ScopeDescriptor} describing a path from","     the root of the syntax tree to a token. Get one by calling","     {editor.getLastCursor().getScopeDescriptor()}","     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)","     for more information.",""," Returns the value from Atom's default settings, the user's configuration"," file in the type specified by the configuration schema."],"code":"  get (...args) {\r\n    let keyPath, options, scope\r\n    if (args.length > 1) {\r\n      if ((typeof args[0] === 'string') || (args[0] == null)) {\r\n        [keyPath, options] = args;\r\n        ({scope} = options)\r\n      }\r\n    } else {\r\n      [keyPath] = args\r\n    }\r\n\r\n    if (scope != null) {\r\n      const value = this.getRawScopedValue(scope, keyPath, options)\r\n      return value != null ? value : this.getRawValue(keyPath, options)\r\n    } else {\r\n      return this.getRawValue(keyPath, options)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.getRawValue","start_line":994,"end_line":1018,"comment":[],"params":["keyPath","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"rangeForNode","line":21,"func_location":"get","func_start_line":20,"func_end_line":22,"args":[null],"code":"        get () {\r\n          return rangeForNode(this)\r\n        }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"rangeForNode","start_line":1190,"end_line":1192,"comment":[],"params":["node"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/file-system-blob-store.js","name":"has","line":73,"func_location":"FileSystemBlobStore.get","func_start_line":72,"func_end_line":77,"args":["key"],"code":"  get (key) {\r\n    if (this.has(key)) {\r\n      this.usedKeys.add(key)\r\n      return this.getFromMemory(key) || this.getFromStorage(key)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/file-system-blob-store.js","name":"FileSystemBlobStore.has","start_line":68,"end_line":70,"comment":[],"params":["key"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getActivePaneContainer","line":1443,"func_location":"Workspace.getActivePane","func_start_line":1442,"func_end_line":1444,"args":[],"comment":[" Extended: Get the active {Pane}.",""," Returns a {Pane}."],"code":"  getActivePane () {\r\n    return this.getActivePaneContainer().getActivePane()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getActivePaneContainer","start_line":1424,"end_line":1426,"comment":["\r\n  Section: Panes\r\n  "," Extended: Get the most recently focused pane container.",""," Returns a {Dock} or the {WorkspaceCenter}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"getActivePane","line":163,"func_location":"PaneContainer.getActivePaneItem","func_start_line":162,"func_end_line":164,"args":[],"code":"  getActivePaneItem () {\r\n    return this.getActivePane().getActiveItem()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.getActivePane","start_line":158,"end_line":160,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getActivePaneContainer","line":1358,"func_location":"Workspace.getActivePaneItem","func_start_line":1357,"func_end_line":1359,"args":[],"comment":[" Essential: Get the active {Pane}'s active item.",""," Returns an pane item {Object}."],"code":"  getActivePaneItem () {\r\n    return this.getActivePaneContainer().getActivePaneItem()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getActivePaneContainer","start_line":1424,"end_line":1426,"comment":["\r\n  Section: Panes\r\n  "," Extended: Get the most recently focused pane container.",""," Returns a {Dock} or the {WorkspaceCenter}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js","name":"getActivePaneItem","line":279,"func_location":"WorkspaceCenter.getActiveTextEditor","func_start_line":278,"func_end_line":281,"args":[],"comment":[" Essential: Get the active item if it is an {TextEditor}.",""," Returns an {TextEditor} or `undefined` if the current active item is not an"," {TextEditor}."],"code":"  getActiveTextEditor () {\r\n    const activeItem = this.getActivePaneItem()\r\n    if (activeItem instanceof TextEditor) { return activeItem }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js","name":"WorkspaceCenter.getActivePaneItem","start_line":263,"end_line":265,"comment":[" Essential: Get the active {Pane}'s active item.",""," Returns an pane item {Object}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getCenter","line":1373,"func_location":"Workspace.getActiveTextEditor","func_start_line":1372,"func_end_line":1375,"args":[],"comment":[" Essential: Get the workspace center's active item if it is a {TextEditor}.",""," Returns a {TextEditor} or `undefined` if the workspace center's current"," active item is not a {TextEditor}."],"code":"  getActiveTextEditor () {\r\n    const activeItem = this.getCenter().getActivePaneItem()\r\n    if (activeItem instanceof TextEditor) { return activeItem }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getCenter","start_line":1599,"end_line":1601,"comment":["\r\n  Section: Pane Locations\r\n  "," Essential: Get the {WorkspaceCenter} at the center of the editor window."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"getActivePaneItem","line":660,"func_location":"Dock.getActiveTextEditor","func_start_line":657,"func_end_line":662,"args":[],"comment":[" Deprecated: Get the active item if it is a {TextEditor}.",""," Returns a {TextEditor} or `undefined` if the current active item is not a"," {TextEditor}."],"code":"  getActiveTextEditor () {\r\n    Grim.deprecate('Text editors are not allowed in docks. Use atom.workspace.getActiveTextEditor() instead.')\r\n\r\n    const activeItem = this.getActivePaneItem()\r\n    if (activeItem instanceof TextEditor) { return activeItem }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.getActivePaneItem","start_line":649,"end_line":651,"comment":[" Essential: Get the active {Pane}'s active item.",""," Returns an pane item {Object}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"getActiveThemes","line":88,"func_location":"ThemeManager.getActiveThemeNames","func_start_line":87,"func_end_line":89,"args":[null],"comment":["\r\n  Section: Accessing Active Themes\r\n  "," Public: Returns an {Array} of {String}s of all the active theme names."],"code":"  getActiveThemeNames () {\r\n    return this.getActiveThemes().map((theme) => theme.name)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.getActiveThemes","start_line":92,"end_line":94,"comment":[" Public: Returns an {Array} of all the active themes."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getRepo","line":255,"func_location":"GitRepository.getAheadBehindCount","func_start_line":254,"func_end_line":256,"args":["reference"],"comment":[" Public: Returns the number of commits behind the current branch is from the"," its upstream remote branch.",""," * `reference` The {String} branch reference name."," * `path`      The {String} path in the repository to get this information for,","   only needed if the repository contains submodules."],"code":"  getAheadBehindCount (reference, path) {\r\n    return this.getRepo(path).getAheadBehindCount(reference)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getRepo","start_line":524,"end_line":530,"comment":[" Returns the corresponding {Repository}"],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"getLegacyScopeDescriptorForNewScopeDescriptor","line":625,"func_location":"Config.getAll","func_start_line":613,"func_end_line":643,"args":["scopeDescriptor"],"comment":[" Extended: Get all of the values for the given key-path, along with their"," associated scope selector.",""," * `keyPath` The {String} name of the key to retrieve"," * `options` (optional) {Object} see the `options` argument to {::get}",""," Returns an {Array} of {Object}s with the following keys:","  * `scopeDescriptor` The {ScopeDescriptor} with which the value is associated","  * `value` The value for the key-path"],"code":"  getAll (keyPath, options) {\r\n    let globalValue, result, scope\r\n    if (options != null) { ({scope} = options) }\r\n\r\n    if (scope != null) {\r\n      let legacyScopeDescriptor\r\n      const scopeDescriptor = ScopeDescriptor.fromObject(scope)\r\n      result = this.scopedSettingsStore.getAll(\r\n          scopeDescriptor.getScopeChain(),\r\n          keyPath,\r\n          options\r\n        )\r\n      legacyScopeDescriptor = this.getLegacyScopeDescriptorForNewScopeDescriptor(scopeDescriptor)\r\n      if (legacyScopeDescriptor) {\r\n        result.push(...Array.from(this.scopedSettingsStore.getAll(\r\n           legacyScopeDescriptor.getScopeChain(),\r\n           keyPath,\r\n           options\r\n         ) || []))\r\n      }\r\n    } else {\r\n      result = []\r\n    }\r\n\r\n    globalValue = this.getRawValue(keyPath, options)\r\n    if (globalValue) {\r\n      result.push({scopeSelector: '*', value: globalValue})\r\n    }\r\n\r\n    return result\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.getLegacyScopeDescriptorForNewScopeDescriptor","start_line":825,"end_line":827,"comment":[],"params":["scopeDescriptor"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"getRawValue","line":637,"func_location":"Config.getAll","func_start_line":613,"func_end_line":643,"args":["keyPath","options"],"comment":[" Extended: Get all of the values for the given key-path, along with their"," associated scope selector.",""," * `keyPath` The {String} name of the key to retrieve"," * `options` (optional) {Object} see the `options` argument to {::get}",""," Returns an {Array} of {Object}s with the following keys:","  * `scopeDescriptor` The {ScopeDescriptor} with which the value is associated","  * `value` The value for the key-path"],"code":"  getAll (keyPath, options) {\r\n    let globalValue, result, scope\r\n    if (options != null) { ({scope} = options) }\r\n\r\n    if (scope != null) {\r\n      let legacyScopeDescriptor\r\n      const scopeDescriptor = ScopeDescriptor.fromObject(scope)\r\n      result = this.scopedSettingsStore.getAll(\r\n          scopeDescriptor.getScopeChain(),\r\n          keyPath,\r\n          options\r\n        )\r\n      legacyScopeDescriptor = this.getLegacyScopeDescriptorForNewScopeDescriptor(scopeDescriptor)\r\n      if (legacyScopeDescriptor) {\r\n        result.push(...Array.from(this.scopedSettingsStore.getAll(\r\n           legacyScopeDescriptor.getScopeChain(),\r\n           keyPath,\r\n           options\r\n         ) || []))\r\n      }\r\n    } else {\r\n      result = []\r\n    }\r\n\r\n    globalValue = this.getRawValue(keyPath, options)\r\n    if (globalValue) {\r\n      result.push({scopeSelector: '*', value: globalValue})\r\n    }\r\n\r\n    return result\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.getRawValue","start_line":994,"end_line":1018,"comment":[],"params":["keyPath","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"getApproximateRightmostScreenPosition","line":1296,"func_location":"TextEditor.getApproximateLongestScreenRow","func_start_line":1296,"func_end_line":1296,"args":[],"code":"  getApproximateLongestScreenRow () { return this.getApproximateRightmostScreenPosition().row }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.getApproximateRightmostScreenPosition","start_line":1290,"end_line":1290,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"getAvailablePackages","line":374,"func_location":"PackageManager.getAvailablePackageMetadata","func_start_line":372,"func_end_line":380,"args":[],"comment":[" Public: Returns an {Array} of {String}s of all the available package metadata."],"code":"  getAvailablePackageMetadata () {\r\n    const packages = []\r\n    for (const pack of this.getAvailablePackages()) {\r\n      const loadedPackage = this.getLoadedPackage(pack.name)\r\n      const metadata = loadedPackage != null ? loadedPackage.metadata : this.loadPackageMetadata(pack, true)\r\n      packages.push(metadata)\r\n    }\r\n    return packages\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.getAvailablePackages","start_line":382,"end_line":414,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"getLoadedPackage","line":375,"func_location":"PackageManager.getAvailablePackageMetadata","func_start_line":372,"func_end_line":380,"args":["pack.name"],"comment":[" Public: Returns an {Array} of {String}s of all the available package metadata."],"code":"  getAvailablePackageMetadata () {\r\n    const packages = []\r\n    for (const pack of this.getAvailablePackages()) {\r\n      const loadedPackage = this.getLoadedPackage(pack.name)\r\n      const metadata = loadedPackage != null ? loadedPackage.metadata : this.loadPackageMetadata(pack, true)\r\n      packages.push(metadata)\r\n    }\r\n    return packages\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.getLoadedPackage","start_line":339,"end_line":341,"comment":[" Public: Get the loaded {Package} with the given name.",""," * `name` - The {String} package name.",""," Returns a {Package} or undefined."],"params":["name"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"loadPackageMetadata","line":376,"func_location":"PackageManager.getAvailablePackageMetadata","func_start_line":372,"func_end_line":380,"args":["pack",{"type":"boolean"}],"comment":[" Public: Returns an {Array} of {String}s of all the available package metadata."],"code":"  getAvailablePackageMetadata () {\r\n    const packages = []\r\n    for (const pack of this.getAvailablePackages()) {\r\n      const loadedPackage = this.getLoadedPackage(pack.name)\r\n      const metadata = loadedPackage != null ? loadedPackage.metadata : this.loadPackageMetadata(pack, true)\r\n      packages.push(metadata)\r\n    }\r\n    return packages\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.loadPackageMetadata","start_line":839,"end_line":882,"comment":[],"params":["packagePathOrAvailablePackage","ignoreErrors"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"getAvailablePackages","line":368,"func_location":"PackageManager.getAvailablePackageNames","func_start_line":367,"func_end_line":369,"args":[null],"comment":[" Public: Returns an {Array} of {String}s of all the available package names."],"code":"  getAvailablePackageNames () {\r\n    return this.getAvailablePackages().map(a => a.name)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.getAvailablePackages","start_line":382,"end_line":414,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"getAvailablePackages","line":363,"func_location":"PackageManager.getAvailablePackagePaths","func_start_line":362,"func_end_line":364,"args":[null],"comment":["\r\n  Section: Accessing available packages\r\n  "," Public: Returns an {Array} of {String}s of all the available package paths."],"code":"  getAvailablePackagePaths () {\r\n    return this.getAvailablePackages().map(a => a.path)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.getAvailablePackages","start_line":382,"end_line":414,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":145,"func_location":"TextEditorElement.getBaseCharacterWidth","func_start_line":144,"func_end_line":146,"args":[],"comment":[" Extended: get the width of an `x` character displayed in this element.",""," Returns a {Number} of pixels."],"code":"  getBaseCharacterWidth () {\r\n    return this.getComponent().getBaseCharacterWidth()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferPosition","line":529,"func_location":"Cursor.getBeginningOfCurrentWordBufferPosition","func_start_line":527,"func_end_line":547,"args":[],"comment":[" Public: Retrieves the buffer position of where the current word starts.",""," * `options` (optional) An {Object} with the following keys:","   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"","     (default: {::wordRegExp}).","   * `includeNonWordCharacters` A {Boolean} indicating whether to include","     non-word characters in the default word regex.","     Has no effect if wordRegex is set.","   * `allowPrevious` A {Boolean} indicating whether the beginning of the","     previous word can be returned.",""," Returns a {Range}."],"code":"  getBeginningOfCurrentWordBufferPosition (options = {}) {\r\n    const allowPrevious = options.allowPrevious !== false\r\n    const position = this.getBufferPosition()\r\n\r\n    const scanRange = allowPrevious\r\n      ? new Range(new Point(position.row - 1, 0), position)\r\n      : new Range(new Point(position.row, 0), position)\r\n\r\n    const ranges = this.editor.buffer.findAllInRangeSync(\r\n      options.wordRegex || this.wordRegExp(options),\r\n      scanRange\r\n    )\r\n\r\n    let result\r\n    for (let range of ranges) {\r\n      if (position.isLessThanOrEqual(range.start)) break\r\n      if (allowPrevious || position.isLessThanOrEqual(range.end)) result = Point.fromObject(range.start)\r\n    }\r\n\r\n    return result || (allowPrevious ? new Point(0, 0) : position)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferPosition","start_line":91,"end_line":93,"comment":[" Public: Returns the current buffer position as an Array."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"wordRegExp","line":536,"func_location":"Cursor.getBeginningOfCurrentWordBufferPosition","func_start_line":527,"func_end_line":547,"args":["options"],"comment":[" Public: Retrieves the buffer position of where the current word starts.",""," * `options` (optional) An {Object} with the following keys:","   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"","     (default: {::wordRegExp}).","   * `includeNonWordCharacters` A {Boolean} indicating whether to include","     non-word characters in the default word regex.","     Has no effect if wordRegex is set.","   * `allowPrevious` A {Boolean} indicating whether the beginning of the","     previous word can be returned.",""," Returns a {Range}."],"code":"  getBeginningOfCurrentWordBufferPosition (options = {}) {\r\n    const allowPrevious = options.allowPrevious !== false\r\n    const position = this.getBufferPosition()\r\n\r\n    const scanRange = allowPrevious\r\n      ? new Range(new Point(position.row - 1, 0), position)\r\n      : new Range(new Point(position.row, 0), position)\r\n\r\n    const ranges = this.editor.buffer.findAllInRangeSync(\r\n      options.wordRegex || this.wordRegExp(options),\r\n      scanRange\r\n    )\r\n\r\n    let result\r\n    for (let range of ranges) {\r\n      if (position.isLessThanOrEqual(range.start)) break\r\n      if (allowPrevious || position.isLessThanOrEqual(range.end)) result = Point.fromObject(range.start)\r\n    }\r\n\r\n    return result || (allowPrevious ? new Point(0, 0) : position)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.wordRegExp","start_line":674,"end_line":681,"comment":[" Public: Get the RegExp used by the cursor to determine what a \"word\" is.",""," * `options` (optional) {Object} with the following keys:","   * `includeNonWordCharacters` A {Boolean} indicating whether to include","     non-word characters in the regex. (default: true)",""," Returns a {RegExp}."],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferPosition","line":741,"func_location":"Cursor.getBeginningOfNextParagraphBufferPosition","func_start_line":740,"func_end_line":753,"args":[],"code":"  getBeginningOfNextParagraphBufferPosition () {\r\n    const start = this.getBufferPosition()\r\n    const eof = this.editor.getEofBufferPosition()\r\n    const scanRange = [start, eof]\r\n\r\n    const {row, column} = eof\r\n    let position = new Point(row, column - 1)\r\n\r\n    this.editor.scanInBufferRange(EmptyLineRegExp, scanRange, ({range, stop}) => {\r\n      position = range.start.traverse(Point(1, 0))\r\n      if (!position.isEqual(start)) stop()\r\n    })\r\n    return position\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferPosition","start_line":91,"end_line":93,"comment":[" Public: Returns the current buffer position as an Array."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferPosition","line":588,"func_location":"Cursor.getBeginningOfNextWordBufferPosition","func_start_line":587,"func_end_line":599,"args":[],"comment":[" Public: Retrieves the buffer position of where the next word starts.",""," * `options` (optional) {Object}","   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"","     (default: {::wordRegExp}).",""," Returns a {Range}"],"code":"  getBeginningOfNextWordBufferPosition (options = {}) {\r\n    const currentBufferPosition = this.getBufferPosition()\r\n    const start = this.isInsideWord(options) ? this.getEndOfCurrentWordBufferPosition(options) : currentBufferPosition\r\n    const scanRange = [start, this.editor.getEofBufferPosition()]\r\n\r\n    let beginningOfNextWordPosition\r\n    this.editor.scanInBufferRange(options.wordRegex || this.wordRegExp(), scanRange, ({range, stop}) => {\r\n      beginningOfNextWordPosition = range.start\r\n      stop()\r\n    })\r\n\r\n    return beginningOfNextWordPosition || currentBufferPosition\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferPosition","start_line":91,"end_line":93,"comment":[" Public: Returns the current buffer position as an Array."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"isInsideWord","line":589,"func_location":"Cursor.getBeginningOfNextWordBufferPosition","func_start_line":587,"func_end_line":599,"args":["options"],"comment":[" Public: Retrieves the buffer position of where the next word starts.",""," * `options` (optional) {Object}","   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"","     (default: {::wordRegExp}).",""," Returns a {Range}"],"code":"  getBeginningOfNextWordBufferPosition (options = {}) {\r\n    const currentBufferPosition = this.getBufferPosition()\r\n    const start = this.isInsideWord(options) ? this.getEndOfCurrentWordBufferPosition(options) : currentBufferPosition\r\n    const scanRange = [start, this.editor.getEofBufferPosition()]\r\n\r\n    let beginningOfNextWordPosition\r\n    this.editor.scanInBufferRange(options.wordRegex || this.wordRegExp(), scanRange, ({range, stop}) => {\r\n      beginningOfNextWordPosition = range.start\r\n      stop()\r\n    })\r\n\r\n    return beginningOfNextWordPosition || currentBufferPosition\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.isInsideWord","start_line":178,"end_line":183,"comment":[" Public: Returns whether this cursor is between a word's start and end.",""," * `options` (optional) {Object}","   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"","     (default: {::wordRegExp}).",""," Returns a {Boolean}"],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getEndOfCurrentWordBufferPosition","line":589,"func_location":"Cursor.getBeginningOfNextWordBufferPosition","func_start_line":587,"func_end_line":599,"args":["options"],"comment":[" Public: Retrieves the buffer position of where the next word starts.",""," * `options` (optional) {Object}","   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"","     (default: {::wordRegExp}).",""," Returns a {Range}"],"code":"  getBeginningOfNextWordBufferPosition (options = {}) {\r\n    const currentBufferPosition = this.getBufferPosition()\r\n    const start = this.isInsideWord(options) ? this.getEndOfCurrentWordBufferPosition(options) : currentBufferPosition\r\n    const scanRange = [start, this.editor.getEofBufferPosition()]\r\n\r\n    let beginningOfNextWordPosition\r\n    this.editor.scanInBufferRange(options.wordRegex || this.wordRegExp(), scanRange, ({range, stop}) => {\r\n      beginningOfNextWordPosition = range.start\r\n      stop()\r\n    })\r\n\r\n    return beginningOfNextWordPosition || currentBufferPosition\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getEndOfCurrentWordBufferPosition","start_line":559,"end_line":578,"comment":[" Public: Retrieves the buffer position of where the current word ends.",""," * `options` (optional) {Object} with the following keys:","   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"","      (default: {::wordRegExp})","   * `includeNonWordCharacters` A Boolean indicating whether to include","     non-word characters in the default word regex. Has no effect if","     wordRegex is set.",""," Returns a {Range}."],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"wordRegExp","line":593,"func_location":"Cursor.getBeginningOfNextWordBufferPosition","func_start_line":587,"func_end_line":599,"args":[],"comment":[" Public: Retrieves the buffer position of where the next word starts.",""," * `options` (optional) {Object}","   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"","     (default: {::wordRegExp}).",""," Returns a {Range}"],"code":"  getBeginningOfNextWordBufferPosition (options = {}) {\r\n    const currentBufferPosition = this.getBufferPosition()\r\n    const start = this.isInsideWord(options) ? this.getEndOfCurrentWordBufferPosition(options) : currentBufferPosition\r\n    const scanRange = [start, this.editor.getEofBufferPosition()]\r\n\r\n    let beginningOfNextWordPosition\r\n    this.editor.scanInBufferRange(options.wordRegex || this.wordRegExp(), scanRange, ({range, stop}) => {\r\n      beginningOfNextWordPosition = range.start\r\n      stop()\r\n    })\r\n\r\n    return beginningOfNextWordPosition || currentBufferPosition\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.wordRegExp","start_line":674,"end_line":681,"comment":[" Public: Get the RegExp used by the cursor to determine what a \"word\" is.",""," * `options` (optional) {Object} with the following keys:","   * `includeNonWordCharacters` A {Boolean} indicating whether to include","     non-word characters in the regex. (default: true)",""," Returns a {RegExp}."],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferPosition","line":756,"func_location":"Cursor.getBeginningOfPreviousParagraphBufferPosition","func_start_line":755,"func_end_line":766,"args":[],"code":"  getBeginningOfPreviousParagraphBufferPosition () {\r\n    const start = this.getBufferPosition()\r\n\r\n    const {row, column} = start\r\n    const scanRange = [[row - 1, column], [0, 0]]\r\n    let position = new Point(0, 0)\r\n    this.editor.backwardsScanInBufferRange(EmptyLineRegExp, scanRange, ({range, stop}) => {\r\n      position = range.start.traverse(Point(1, 0))\r\n      if (!position.isEqual(start)) stop()\r\n    })\r\n    return position\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferPosition","start_line":91,"end_line":93,"comment":[" Public: Returns the current buffer position as an Array."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getPanels","line":1649,"func_location":"Workspace.getBottomPanels","func_start_line":1648,"func_end_line":1650,"args":[{"type":"string"}],"comment":["\r\n  Section: Panels\r\n\r\n  Panels are used to display UI related to an editor window. They are placed at one of the four\r\n  edges of the window: left, right, top or bottom. If there are multiple panels on the same window\r\n  edge they are stacked in order of priority: higher priority is closer to the center, lower\r\n  priority towards the edge.\r\n\r\n  *Note:* If your panel changes its size throughout its lifetime, consider giving it a higher\r\n  priority, allowing fixed size panels to be closer to the edge. This allows control targets to\r\n  remain more static for easier targeting by users that employ mice or trackpads. (See\r\n  [atom/atom#4834](https://github.com/atom/atom/issues/4834) for discussion.)\r\n  "," Essential: Get an {Array} of all the panel items at the bottom of the editor window."],"code":"  getBottomPanels () {\r\n    return this.getPanels('bottom')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getPanels","start_line":1812,"end_line":1814,"comment":[],"params":["location"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferPosition","line":112,"func_location":"Cursor.getBufferColumn","func_start_line":111,"func_end_line":113,"args":[],"comment":[" Public: Returns the cursor's current buffer column."],"code":"  getBufferColumn () {\r\n    return this.getBufferPosition().column\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferPosition","start_line":91,"end_line":93,"comment":[" Public: Returns the current buffer position as an Array."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferPosition","line":107,"func_location":"Cursor.getBufferRow","func_start_line":106,"func_end_line":108,"args":[],"comment":[" Public: Retrieves the cursor's current buffer row."],"code":"  getBufferRow () {\r\n    return this.getBufferPosition().row\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferPosition","start_line":91,"end_line":93,"comment":[" Public: Returns the current buffer position as an Array."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"getBufferRange","line":111,"func_location":"Selection.getBufferRowRange","func_start_line":110,"func_end_line":116,"args":[],"comment":[" Public: Returns the starting and ending buffer rows the selection is"," highlighting.",""," Returns an {Array} of two {Number}s: the starting row, and the ending row."],"code":"  getBufferRowRange () {\r\n    const range = this.getBufferRange()\r\n    const start = range.start.row\r\n    let end = range.end.row\r\n    if (range.end.column === 0) end = Math.max(start, end - 1)\r\n    return [start, end]\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.getBufferRange","start_line":79,"end_line":81,"comment":[" Public: Returns the buffer {Range} for the selection."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"getBuildFailureOutputStorageKey","line":1016,"func_location":"Package.getBuildFailureOutput","func_start_line":1015,"func_end_line":1017,"args":[null],"comment":[" Extended: If a previous rebuild failed, get the contents of stderr.",""," Returns a {String} or null if no previous build failure occurred."],"code":"  getBuildFailureOutput () {\r\n    return global.localStorage.getItem(this.getBuildFailureOutputStorageKey())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.getBuildFailureOutputStorageKey","start_line":1032,"end_line":1034,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"relativize","line":398,"func_location":"GitRepository.getCachedPathStatus","func_start_line":397,"func_end_line":399,"args":["path"],"comment":[" Public: Get the cached status for the given path.",""," * `path` A {String} path in the repository, relative or absolute.",""," Returns a status {Number} or null if the path is not in the cache."],"code":"  getCachedPathStatus (path) {\r\n    return this.statuses[this.relativize(path)]\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.relativize","start_line":208,"end_line":210,"comment":[" Public: Makes a path relative to the repository's working directory."],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getRepo","line":268,"func_location":"GitRepository.getCachedUpstreamAheadBehindCount","func_start_line":267,"func_end_line":269,"args":["path"],"comment":[" Public: Get the cached ahead/behind commit counts for the current branch's"," upstream branch.",""," * `path` An optional {String} path in the repository to get this information","   for, only needed if the repository has submodules.",""," Returns an {Object} with the following keys:","   * `ahead`  The {Number} of commits ahead.","   * `behind` The {Number} of commits behind."],"code":"  getCachedUpstreamAheadBehindCount (path) {\r\n    return this.getRepo(path).upstream || this.upstream\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getRepo","start_line":524,"end_line":530,"comment":[" Returns the corresponding {Repository}"],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/babel.js","name":"createVersionAndOptionsDigest","line":32,"func_location":"exports.getCachePath","func_start_line":29,"func_end_line":42,"args":[{"type":"string"},{"type":"string"},null],"code":"exports.getCachePath = function (sourceCode) {\r\n  if (babelVersionDirectory == null) {\r\n    var babelVersion = require('babel-core/package.json').version\r\n    babelVersionDirectory = path.join('js', 'babel', createVersionAndOptionsDigest(babelVersion, defaultOptions))\r\n  }\r\n\r\n  return path.join(\r\n    babelVersionDirectory,\r\n    crypto\r\n      .createHash('sha1')\r\n      .update(sourceCode, 'utf8')\r\n      .digest('hex') + '.js'\r\n  )\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/babel.js","name":"createVersionAndOptionsDigest","start_line":64,"end_line":73,"comment":[],"params":["version","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js","name":"getTranspilerPath","line":113,"func_location":"PackageTranspilationRegistry.getCachePath","func_start_line":112,"func_end_line":131,"args":["spec"],"code":"  getCachePath (sourceCode, filePath, spec) {\r\n    const transpilerPath = this.getTranspilerPath(spec)\r\n    const transpilerSource = spec._transpilerSource || fs.readFileSync(transpilerPath, 'utf8')\r\n    spec._transpilerSource = transpilerSource\r\n    const transpiler = this.getTranspiler(spec)\r\n\r\n    let hash = crypto\r\n      .createHash('sha1')\r\n      .update(JSON.stringify(spec.options || {}))\r\n      .update(transpilerSource, 'utf8')\r\n      .update(sourceCode, 'utf8')\r\n\r\n    if (transpiler && transpiler.getCacheKeyData) {\r\n      const meta = this.getMetadata(spec)\r\n      const additionalCacheData = transpiler.getCacheKeyData(sourceCode, filePath, spec.options || {}, meta)\r\n      hash.update(additionalCacheData, 'utf8')\r\n    }\r\n\r\n    return path.join('package-transpile', spec._config.name, hash.digest('hex'))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js","name":"PackageTranspilationRegistry.getTranspilerPath","start_line":160,"end_line":166,"comment":[],"params":["spec"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js","name":"getTranspiler","line":116,"func_location":"PackageTranspilationRegistry.getCachePath","func_start_line":112,"func_end_line":131,"args":["spec"],"code":"  getCachePath (sourceCode, filePath, spec) {\r\n    const transpilerPath = this.getTranspilerPath(spec)\r\n    const transpilerSource = spec._transpilerSource || fs.readFileSync(transpilerPath, 'utf8')\r\n    spec._transpilerSource = transpilerSource\r\n    const transpiler = this.getTranspiler(spec)\r\n\r\n    let hash = crypto\r\n      .createHash('sha1')\r\n      .update(JSON.stringify(spec.options || {}))\r\n      .update(transpilerSource, 'utf8')\r\n      .update(sourceCode, 'utf8')\r\n\r\n    if (transpiler && transpiler.getCacheKeyData) {\r\n      const meta = this.getMetadata(spec)\r\n      const additionalCacheData = transpiler.getCacheKeyData(sourceCode, filePath, spec.options || {}, meta)\r\n      hash.update(additionalCacheData, 'utf8')\r\n    }\r\n\r\n    return path.join('package-transpile', spec._config.name, hash.digest('hex'))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js","name":"PackageTranspilationRegistry.getTranspiler","start_line":168,"end_line":175,"comment":[],"params":["spec"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js","name":"getMetadata","line":125,"func_location":"PackageTranspilationRegistry.getCachePath","func_start_line":112,"func_end_line":131,"args":["spec"],"code":"  getCachePath (sourceCode, filePath, spec) {\r\n    const transpilerPath = this.getTranspilerPath(spec)\r\n    const transpilerSource = spec._transpilerSource || fs.readFileSync(transpilerPath, 'utf8')\r\n    spec._transpilerSource = transpilerSource\r\n    const transpiler = this.getTranspiler(spec)\r\n\r\n    let hash = crypto\r\n      .createHash('sha1')\r\n      .update(JSON.stringify(spec.options || {}))\r\n      .update(transpilerSource, 'utf8')\r\n      .update(sourceCode, 'utf8')\r\n\r\n    if (transpiler && transpiler.getCacheKeyData) {\r\n      const meta = this.getMetadata(spec)\r\n      const additionalCacheData = transpiler.getCacheKeyData(sourceCode, filePath, spec.options || {}, meta)\r\n      hash.update(additionalCacheData, 'utf8')\r\n    }\r\n\r\n    return path.join('package-transpile', spec._config.name, hash.digest('hex'))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js","name":"PackageTranspilationRegistry.getMetadata","start_line":152,"end_line":158,"comment":[],"params":["spec"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/typescript.js","name":"createVersionAndOptionsDigest","line":23,"func_location":"exports.getCachePath","func_start_line":20,"func_end_line":33,"args":[{"type":"string"},null],"code":"exports.getCachePath = function (sourceCode) {\r\n  if (typescriptVersionDir == null) {\r\n    var version = require('typescript-simple/package.json').version\r\n    typescriptVersionDir = path.join('ts', createVersionAndOptionsDigest(version, defaultOptions))\r\n  }\r\n\r\n  return path.join(\r\n    typescriptVersionDir,\r\n    crypto\r\n      .createHash('sha1')\r\n      .update(sourceCode, 'utf8')\r\n      .digest('hex') + '.js'\r\n  )\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/typescript.js","name":"createVersionAndOptionsDigest","start_line":48,"end_line":57,"comment":[],"params":["version","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"last","line":838,"func_location":"HighlightIterator.getCloseScopeIds","func_start_line":837,"func_end_line":839,"args":[],"code":"  getCloseScopeIds () {\r\n    return last(this.iterators).getCloseScopeIds()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"last","start_line":1206,"end_line":1208,"comment":[],"params":["array"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"updateModelFromAttributes","line":284,"func_location":"TextEditorElement.getComponent","func_start_line":276,"func_end_line":288,"args":[],"code":"  getComponent () {\r\n    if (!this.component) {\r\n      this.component = new TextEditorComponent({\r\n        element: this,\r\n        mini: this.hasAttribute('mini'),\r\n        updatedSynchronously: this.updatedSynchronously,\r\n        readOnly: this.hasAttribute('readonly')\r\n      })\r\n      this.updateModelFromAttributes()\r\n    }\r\n\r\n    return this.component\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.updateModelFromAttributes","start_line":89,"end_line":96,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getRepo","line":277,"func_location":"GitRepository.getConfigValue","func_start_line":276,"func_end_line":278,"args":["key"],"comment":[" Public: Returns the git configuration value specified by the key.",""," * `key`  The {String} key for the configuration to lookup."," * `path` An optional {String} path in the repository to get this information","   for, only needed if the repository has submodules."],"code":"  getConfigValue (key, path) {\r\n    return this.getRepo(path).getConfigValue(key)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getRepo","start_line":524,"end_line":530,"comment":[" Returns the corresponding {Repository}"],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelPositionAfterBlocksForRow","line":2685,"func_location":"TextEditorComponent.getContentHeight","func_start_line":2684,"func_end_line":2686,"args":[null],"code":"  getContentHeight () {\r\n    return this.pixelPositionAfterBlocksForRow(this.props.model.getApproximateScreenLineCount())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelPositionAfterBlocksForRow","start_line":2364,"end_line":2366,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getLongestLineWidth","line":2689,"func_location":"TextEditorComponent.getContentWidth","func_start_line":2688,"func_end_line":2690,"args":[null],"code":"  getContentWidth () {\r\n    return Math.ceil(this.getLongestLineWidth() + this.getBaseCharacterWidth())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getLongestLineWidth","start_line":2608,"end_line":2610,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getBaseCharacterWidth","line":2689,"func_location":"TextEditorComponent.getContentWidth","func_start_line":2688,"func_end_line":2690,"args":[null],"code":"  getContentWidth () {\r\n    return Math.ceil(this.getLongestLineWidth() + this.getBaseCharacterWidth())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getBaseCharacterWidth","start_line":2604,"end_line":2606,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferRow","line":118,"func_location":"Cursor.getCurrentBufferLine","func_start_line":117,"func_end_line":119,"args":[null],"comment":[" Public: Returns the cursor's current buffer row of text excluding its line"," ending."],"code":"  getCurrentBufferLine () {\r\n    return this.editor.lineTextForBufferRow(this.getBufferRow())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferRow","start_line":106,"end_line":108,"comment":[" Public: Retrieves the cursor's current buffer row."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferRow","line":624,"func_location":"Cursor.getCurrentLineBufferRange","func_start_line":623,"func_end_line":625,"args":[null,"options"],"comment":[" Public: Returns the buffer Range for the current line.",""," * `options` (optional) {Object}","   * `includeNewline` A {Boolean} which controls whether the Range should","     include the newline."],"code":"  getCurrentLineBufferRange (options) {\r\n    return this.editor.bufferRangeForBufferRow(this.getBufferRow(), options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferRow","start_line":106,"end_line":108,"comment":[" Public: Retrieves the cursor's current buffer row."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferRow","line":633,"func_location":"Cursor.getCurrentParagraphBufferRange","func_start_line":632,"func_end_line":634,"args":[null],"comment":[" Public: Retrieves the range for the current paragraph.",""," A paragraph is defined as a block of text surrounded by empty lines or comments.",""," Returns a {Range}."],"code":"  getCurrentParagraphBufferRange () {\r\n    return this.editor.rowRangeForParagraphAtBufferRow(this.getBufferRow())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferRow","start_line":106,"end_line":108,"comment":[" Public: Retrieves the cursor's current buffer row."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferPosition","line":607,"func_location":"Cursor.getCurrentWordBufferRange","func_start_line":606,"func_end_line":616,"args":[],"comment":[" Public: Returns the buffer Range occupied by the word located under the cursor.",""," * `options` (optional) {Object}","   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"","     (default: {::wordRegExp})."],"code":"  getCurrentWordBufferRange (options = {}) {\r\n    const position = this.getBufferPosition()\r\n    const ranges = this.editor.buffer.findAllInRangeSync(\r\n      options.wordRegex || this.wordRegExp(options),\r\n      new Range(new Point(position.row, 0), new Point(position.row, Infinity))\r\n    )\r\n    const range = ranges.find(range =>\r\n      range.end.column >= position.column && range.start.column <= position.column\r\n    )\r\n    return range ? Range.fromObject(range) : new Range(position, position)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferPosition","start_line":91,"end_line":93,"comment":[" Public: Returns the current buffer position as an Array."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"wordRegExp","line":609,"func_location":"Cursor.getCurrentWordBufferRange","func_start_line":606,"func_end_line":616,"args":["options"],"comment":[" Public: Returns the buffer Range occupied by the word located under the cursor.",""," * `options` (optional) {Object}","   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"","     (default: {::wordRegExp})."],"code":"  getCurrentWordBufferRange (options = {}) {\r\n    const position = this.getBufferPosition()\r\n    const ranges = this.editor.buffer.findAllInRangeSync(\r\n      options.wordRegex || this.wordRegExp(options),\r\n      new Range(new Point(position.row, 0), new Point(position.row, Infinity))\r\n    )\r\n    const range = ranges.find(range =>\r\n      range.end.column >= position.column && range.start.column <= position.column\r\n    )\r\n    return range ? Range.fromObject(range) : new Range(position, position)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.wordRegExp","start_line":674,"end_line":681,"comment":[" Public: Get the RegExp used by the cursor to determine what a \"word\" is.",""," * `options` (optional) {Object} with the following keys:","   * `includeNonWordCharacters` A {Boolean} indicating whether to include","     non-word characters in the regex. (default: true)",""," Returns a {RegExp}."],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBeginningOfCurrentWordBufferPosition","line":638,"func_location":"Cursor.getCurrentWordPrefix","func_start_line":637,"func_end_line":639,"args":[null],"comment":[" Public: Returns the characters preceding the cursor in the current word."],"code":"  getCurrentWordPrefix () {\r\n    return this.editor.getTextInBufferRange([this.getBeginningOfCurrentWordBufferPosition(), this.getBufferPosition()])\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBeginningOfCurrentWordBufferPosition","start_line":527,"end_line":547,"comment":[" Public: Retrieves the buffer position of where the current word starts.",""," * `options` (optional) An {Object} with the following keys:","   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"","     (default: {::wordRegExp}).","   * `includeNonWordCharacters` A {Boolean} indicating whether to include","     non-word characters in the default word regex.","     Has no effect if wordRegex is set.","   * `allowPrevious` A {Boolean} indicating whether the beginning of the","     previous word can be returned.",""," Returns a {Range}."],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferPosition","line":638,"func_location":"Cursor.getCurrentWordPrefix","func_start_line":637,"func_end_line":639,"args":[null],"comment":[" Public: Returns the characters preceding the cursor in the current word."],"code":"  getCurrentWordPrefix () {\r\n    return this.editor.getTextInBufferRange([this.getBeginningOfCurrentWordBufferPosition(), this.getBufferPosition()])\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferPosition","start_line":91,"end_line":93,"comment":[" Public: Returns the current buffer position as an Array."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":138,"func_location":"TextEditorElement.getDefaultCharacterWidth","func_start_line":137,"func_end_line":139,"args":[],"comment":[" Deprecated: get the width of an `x` character displayed in this element.",""," Returns a {Number} of pixels."],"code":"  getDefaultCharacterWidth () {\r\n    return this.getComponent().getBaseCharacterWidth()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"getLoadSettings","line":728,"func_location":"AtomEnvironment.getDefaultWindowDimensions","func_start_line":727,"func_end_line":745,"args":[],"code":"  getDefaultWindowDimensions () {\r\n    const {windowDimensions} = this.getLoadSettings()\r\n    if (windowDimensions) return windowDimensions\r\n\r\n    let dimensions\r\n    try {\r\n      dimensions = JSON.parse(localStorage.getItem('defaultWindowDimensions'))\r\n    } catch (error) {\r\n      console.warn('Error parsing default window dimensions', error)\r\n      localStorage.removeItem('defaultWindowDimensions')\r\n    }\r\n\r\n    if (dimensions && this.isValidDimensions(dimensions)) {\r\n      return dimensions\r\n    } else {\r\n      const {width, height} = this.applicationDelegate.getPrimaryDisplayWorkAreaSize()\r\n      return {x: 0, y: 0, width: Math.min(1024, width), height}\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.getLoadSettings","start_line":525,"end_line":527,"comment":[" Public: Get the load settings for the current window.",""," Returns an {Object} containing all the load setting key/value pairs."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"isValidDimensions","line":739,"func_location":"AtomEnvironment.getDefaultWindowDimensions","func_start_line":727,"func_end_line":745,"args":["dimensions"],"code":"  getDefaultWindowDimensions () {\r\n    const {windowDimensions} = this.getLoadSettings()\r\n    if (windowDimensions) return windowDimensions\r\n\r\n    let dimensions\r\n    try {\r\n      dimensions = JSON.parse(localStorage.getItem('defaultWindowDimensions'))\r\n    } catch (error) {\r\n      console.warn('Error parsing default window dimensions', error)\r\n      localStorage.removeItem('defaultWindowDimensions')\r\n    }\r\n\r\n    if (dimensions && this.isValidDimensions(dimensions)) {\r\n      return dimensions\r\n    } else {\r\n      const {width, height} = this.applicationDelegate.getPrimaryDisplayWorkAreaSize()\r\n      return {x: 0, y: 0, width: Math.min(1024, width), height}\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.isValidDimensions","start_line":716,"end_line":718,"comment":[" Returns true if the dimensions are useable, false if they should be ignored."," Work around for https://github.com/atom/atom-shell/issues/473"],"params":[["x","y","width","height"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip.js","name":"Tooltip","line":509,"func_location":"Tooltip.prototype.getDelegateComponent","func_start_line":506,"func_end_line":513,"args":[],"code":"Tooltip.prototype.getDelegateComponent = function (element) {\r\n  var component = tooltipComponentsByElement.get(element)\r\n  if (!component) {\r\n    component = new Tooltip(element, this.getDelegateOptions(), this.viewRegistry)\r\n    tooltipComponentsByElement.set(element, component)\r\n  }\r\n  return component\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip.js","name":"Tooltip","start_line":12,"end_line":22,"comment":[],"params":["element","options","viewRegistry"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getRepo","line":432,"func_location":"GitRepository.getDiffStats","func_start_line":431,"func_end_line":434,"args":["path"],"comment":["\r\n  Section: Retrieving Diffs\r\n  "," Public: Retrieves the number of lines added and removed to a path.",""," This compares the working directory contents of the path to the `HEAD`"," version.",""," * `path` The {String} path to check.",""," Returns an {Object} with the following keys:","   * `added` The {Number} of added lines.","   * `deleted` The {Number} of deleted lines."],"code":"  getDiffStats (path) {\r\n    const repo = this.getRepo(path)\r\n    return repo.getDiffStats(repo.relativize(path))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getRepo","start_line":524,"end_line":530,"comment":[" Returns the corresponding {Repository}"],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"focusedWindow","line":764,"func_location":"AtomApplication.getDimensionsForNewWindow","func_start_line":763,"func_end_line":773,"args":[],"comment":[" Get the dimensions for opening a new window by cascading as appropriate to"," the platform."],"code":"  getDimensionsForNewWindow () {\r\n    const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n    if (!window || window.isMaximized()) return\r\n    const dimensions = window.getDimensions()\r\n    if (dimensions) {\r\n      const offset = this.getWindowOffsetForCurrentPlatform()\r\n      dimensions.x += offset\r\n      dimensions.y += offset\r\n      return dimensions\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.focusedWindow","start_line":748,"end_line":750,"comment":[" Public: Returns the currently focused {AtomWindow} or undefined if none."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"getLastFocusedWindow","line":764,"func_location":"AtomApplication.getDimensionsForNewWindow","func_start_line":763,"func_end_line":773,"args":[],"comment":[" Get the dimensions for opening a new window by cascading as appropriate to"," the platform."],"code":"  getDimensionsForNewWindow () {\r\n    const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n    if (!window || window.isMaximized()) return\r\n    const dimensions = window.getDimensions()\r\n    if (dimensions) {\r\n      const offset = this.getWindowOffsetForCurrentPlatform()\r\n      dimensions.x += offset\r\n      dimensions.y += offset\r\n      return dimensions\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.getLastFocusedWindow","start_line":325,"end_line":327,"comment":[],"params":["predicate"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"getWindowOffsetForCurrentPlatform","line":768,"func_location":"AtomApplication.getDimensionsForNewWindow","func_start_line":763,"func_end_line":773,"args":[],"comment":[" Get the dimensions for opening a new window by cascading as appropriate to"," the platform."],"code":"  getDimensionsForNewWindow () {\r\n    const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n    if (!window || window.isMaximized()) return\r\n    const dimensions = window.getDimensions()\r\n    if (dimensions) {\r\n      const offset = this.getWindowOffsetForCurrentPlatform()\r\n      dimensions.x += offset\r\n      dimensions.y += offset\r\n      return dimensions\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.getWindowOffsetForCurrentPlatform","start_line":753,"end_line":759,"comment":[" Get the platform-specific window offset for new windows."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"getPath","line":1146,"func_location":"TextEditor.getDirectoryPath","func_start_line":1145,"func_end_line":1148,"args":[],"code":"  getDirectoryPath () {\r\n    const fullPath = this.getPath()\r\n    if (fullPath) return path.dirname(fullPath)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.getPath","start_line":1136,"end_line":1138,"comment":[" Essential: Returns the {String} path of this editor's text buffer."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"relativize","line":359,"func_location":"GitRepository.getDirectoryStatus","func_start_line":358,"func_end_line":366,"args":["directoryPath"],"comment":[" Public: Get the status of a directory in the repository's working directory.",""," * `path` The {String} path to check.",""," Returns a {Number} representing the status. This value can be passed to"," {::isStatusModified} or {::isStatusNew} to get more information."],"code":"  getDirectoryStatus (directoryPath) {\r\n    directoryPath = `${this.relativize(directoryPath)}/`\r\n    let directoryStatus = 0\r\n    for (let statusPath in this.statuses) {\r\n      const status = this.statuses[statusPath]\r\n      if (statusPath.startsWith(directoryPath)) directoryStatus |= status\r\n    }\r\n    return directoryStatus\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.relativize","start_line":208,"end_line":210,"comment":[" Public: Makes a path relative to the repository's working directory."],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferPosition","line":561,"func_location":"Cursor.getEndOfCurrentWordBufferPosition","func_start_line":559,"func_end_line":578,"args":[],"comment":[" Public: Retrieves the buffer position of where the current word ends.",""," * `options` (optional) {Object} with the following keys:","   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"","      (default: {::wordRegExp})","   * `includeNonWordCharacters` A Boolean indicating whether to include","     non-word characters in the default word regex. Has no effect if","     wordRegex is set.",""," Returns a {Range}."],"code":"  getEndOfCurrentWordBufferPosition (options = {}) {\r\n    const allowNext = options.allowNext !== false\r\n    const position = this.getBufferPosition()\r\n\r\n    const scanRange = allowNext\r\n      ? new Range(position, new Point(position.row + 2, 0))\r\n      : new Range(position, new Point(position.row, Infinity))\r\n\r\n    const ranges = this.editor.buffer.findAllInRangeSync(\r\n      options.wordRegex || this.wordRegExp(options),\r\n      scanRange\r\n    )\r\n\r\n    for (let range of ranges) {\r\n      if (position.isLessThan(range.start) && !allowNext) break\r\n      if (position.isLessThan(range.end)) return Point.fromObject(range.end)\r\n    }\r\n\r\n    return allowNext ? this.editor.getEofBufferPosition() : position\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferPosition","start_line":91,"end_line":93,"comment":[" Public: Returns the current buffer position as an Array."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"wordRegExp","line":568,"func_location":"Cursor.getEndOfCurrentWordBufferPosition","func_start_line":559,"func_end_line":578,"args":["options"],"comment":[" Public: Retrieves the buffer position of where the current word ends.",""," * `options` (optional) {Object} with the following keys:","   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"","      (default: {::wordRegExp})","   * `includeNonWordCharacters` A Boolean indicating whether to include","     non-word characters in the default word regex. Has no effect if","     wordRegex is set.",""," Returns a {Range}."],"code":"  getEndOfCurrentWordBufferPosition (options = {}) {\r\n    const allowNext = options.allowNext !== false\r\n    const position = this.getBufferPosition()\r\n\r\n    const scanRange = allowNext\r\n      ? new Range(position, new Point(position.row + 2, 0))\r\n      : new Range(position, new Point(position.row, Infinity))\r\n\r\n    const ranges = this.editor.buffer.findAllInRangeSync(\r\n      options.wordRegex || this.wordRegExp(options),\r\n      scanRange\r\n    )\r\n\r\n    for (let range of ranges) {\r\n      if (position.isLessThan(range.start) && !allowNext) break\r\n      if (position.isLessThan(range.end)) return Point.fromObject(range.end)\r\n    }\r\n\r\n    return allowNext ? this.editor.getEofBufferPosition() : position\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.wordRegExp","start_line":674,"end_line":681,"comment":[" Public: Get the RegExp used by the cursor to determine what a \"word\" is.",""," * `options` (optional) {Object} with the following keys:","   * `includeNonWordCharacters` A {Boolean} indicating whether to include","     non-word characters in the regex. (default: true)",""," Returns a {RegExp}."],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"getPath","line":1141,"func_location":"TextEditor.getFileName","func_start_line":1140,"func_end_line":1143,"args":[],"code":"  getFileName () {\r\n    const fullPath = this.getPath()\r\n    if (fullPath) return path.basename(fullPath)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.getPath","start_line":1136,"end_line":1138,"comment":[" Essential: Returns the {String} path of this editor's text buffer."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollLeft","line":2788,"func_location":"TextEditorComponent.getFirstVisibleColumn","func_start_line":2787,"func_end_line":2789,"args":[null],"code":"  getFirstVisibleColumn () {\r\n    return Math.floor(this.getScrollLeft() / this.getBaseCharacterWidth())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollLeft","start_line":2823,"end_line":2825,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getBaseCharacterWidth","line":2788,"func_location":"TextEditorComponent.getFirstVisibleColumn","func_start_line":2787,"func_end_line":2789,"args":[null],"code":"  getFirstVisibleColumn () {\r\n    return Math.floor(this.getScrollLeft() / this.getBaseCharacterWidth())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getBaseCharacterWidth","start_line":2604,"end_line":2606,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"rowForPixelPosition","line":2757,"func_location":"TextEditorComponent.getFirstVisibleRow","func_start_line":2755,"func_end_line":2761,"args":[null],"code":"  getFirstVisibleRow () {\r\n    if (this.derivedDimensionsCache.firstVisibleRow == null) {\r\n      this.derivedDimensionsCache.firstVisibleRow = this.rowForPixelPosition(this.getScrollTop())\r\n    }\r\n\r\n    return this.derivedDimensionsCache.firstVisibleRow\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.rowForPixelPosition","start_line":2346,"end_line":2348,"comment":[],"params":["pixelPosition"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollTop","line":2757,"func_location":"TextEditorComponent.getFirstVisibleRow","func_start_line":2755,"func_end_line":2761,"args":[null],"code":"  getFirstVisibleRow () {\r\n    if (this.derivedDimensionsCache.firstVisibleRow == null) {\r\n      this.derivedDimensionsCache.firstVisibleRow = this.rowForPixelPosition(this.getScrollTop())\r\n    }\r\n\r\n    return this.derivedDimensionsCache.firstVisibleRow\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollTop","start_line":2791,"end_line":2794,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getModel","line":343,"func_location":"TextEditorElement.getFirstVisibleScreenColumn","func_start_line":342,"func_end_line":344,"args":[],"code":"  getFirstVisibleScreenColumn () {\r\n    return this.getModel().getFirstVisibleScreenColumn()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getModel","start_line":80,"end_line":82,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getModel","line":315,"func_location":"TextEditorElement.getFirstVisibleScreenRow","func_start_line":314,"func_end_line":316,"args":[],"code":"  getFirstVisibleScreenRow () {\r\n    return this.getModel().getFirstVisibleScreenRow()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getModel","start_line":80,"end_line":82,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"endRowForFoldAtRow","line":606,"func_location":"TextMateLanguageMode.getFoldableRangeContainingPoint","func_start_line":604,"func_end_line":619,"args":["point.row","tabLength"],"code":"  getFoldableRangeContainingPoint (point, tabLength) {\r\n    if (point.column >= this.buffer.lineLengthForRow(point.row)) {\r\n      const endRow = this.endRowForFoldAtRow(point.row, tabLength)\r\n      if (endRow != null) {\r\n        return Range(Point(point.row, Infinity), Point(endRow, Infinity))\r\n      }\r\n    }\r\n\r\n    for (let row = point.row - 1; row >= 0; row--) {\r\n      const endRow = this.endRowForFoldAtRow(row, tabLength)\r\n      if (endRow != null && endRow >= point.row) {\r\n        return Range(Point(row, Infinity), Point(endRow, Infinity))\r\n      }\r\n    }\r\n    return null\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.endRowForFoldAtRow","start_line":653,"end_line":659,"comment":[],"params":["row","tabLength","existenceOnly"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"endRowForFoldAtRow","line":613,"func_location":"TextMateLanguageMode.getFoldableRangeContainingPoint","func_start_line":604,"func_end_line":619,"args":["row","tabLength"],"code":"  getFoldableRangeContainingPoint (point, tabLength) {\r\n    if (point.column >= this.buffer.lineLengthForRow(point.row)) {\r\n      const endRow = this.endRowForFoldAtRow(point.row, tabLength)\r\n      if (endRow != null) {\r\n        return Range(Point(point.row, Infinity), Point(endRow, Infinity))\r\n      }\r\n    }\r\n\r\n    for (let row = point.row - 1; row >= 0; row--) {\r\n      const endRow = this.endRowForFoldAtRow(row, tabLength)\r\n      if (endRow != null && endRow >= point.row) {\r\n        return Range(Point(row, Infinity), Point(endRow, Infinity))\r\n      }\r\n    }\r\n    return null\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.endRowForFoldAtRow","start_line":653,"end_line":659,"comment":[],"params":["row","tabLength","existenceOnly"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"_forEachTreeWithRange","line":283,"func_location":"TreeSitterLanguageMode.getFoldableRangeContainingPoint","func_start_line":279,"func_end_line":301},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"TreeSitterLanguageMode._forEachTreeWithRange","start_line":303,"end_line":316,"comment":[],"params":["range","callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"hasMatchingFoldSpec","line":325,"func_location":"TreeSitterLanguageMode.getFoldableRangeForNode","func_start_line":318,"func_end_line":377,"args":["foldSpec.matchers","node"],"code":"  getFoldableRangeForNode (node, grammar, existenceOnly) {\r\n    const {children} = node\r\n    const childCount = children.length\r\n\r\n    for (var i = 0, {length} = grammar.folds; i < length; i++) {\r\n      const foldSpec = grammar.folds[i]\r\n\r\n      if (foldSpec.matchers && !hasMatchingFoldSpec(foldSpec.matchers, node)) continue\r\n\r\n      let foldStart\r\n      const startEntry = foldSpec.start\r\n      if (startEntry) {\r\n        let foldStartNode\r\n        if (startEntry.index != null) {\r\n          foldStartNode = children[startEntry.index]\r\n          if (!foldStartNode || startEntry.matchers && !hasMatchingFoldSpec(startEntry.matchers, foldStartNode)) continue\r\n        } else {\r\n          foldStartNode = children.find(child => hasMatchingFoldSpec(startEntry.matchers, child))\r\n          if (!foldStartNode) continue\r\n        }\r\n        foldStart = new Point(foldStartNode.endPosition.row, Infinity)\r\n      } else {\r\n        foldStart = new Point(node.startPosition.row, Infinity)\r\n      }\r\n\r\n      let foldEnd\r\n      const endEntry = foldSpec.end\r\n      if (endEntry) {\r\n        let foldEndNode\r\n        if (endEntry.index != null) {\r\n          const index = endEntry.index < 0 ? childCount + endEntry.index : endEntry.index\r\n          foldEndNode = children[index]\r\n          if (!foldEndNode || (endEntry.type && endEntry.type !== foldEndNode.type)) continue\r\n        } else {\r\n          foldEndNode = children.find(child => hasMatchingFoldSpec(endEntry.matchers, child))\r\n          if (!foldEndNode) continue\r\n        }\r\n\r\n        if (foldEndNode.startPosition.row <= foldStart.row) continue\r\n\r\n        foldEnd = foldEndNode.startPosition\r\n        if (this.buffer.findInRangeSync(\r\n          WORD_REGEX, new Range(foldEnd, new Point(foldEnd.row, Infinity))\r\n        )) {\r\n          foldEnd = new Point(foldEnd.row - 1, Infinity)\r\n        }\r\n      } else {\r\n        const {endPosition} = node\r\n        if (endPosition.column === 0) {\r\n          foldEnd = Point(endPosition.row - 1, Infinity)\r\n        } else if (childCount > 0) {\r\n          foldEnd = endPosition\r\n        } else {\r\n          foldEnd = Point(endPosition.row, 0)\r\n        }\r\n      }\r\n\r\n      return existenceOnly ? true : new Range(foldStart, foldEnd)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"hasMatchingFoldSpec","start_line":1210,"end_line":1212,"comment":[],"params":["specs","node"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"hasMatchingFoldSpec","line":333,"func_location":"TreeSitterLanguageMode.getFoldableRangeForNode","func_start_line":318,"func_end_line":377,"args":["startEntry.matchers","foldStartNode"],"code":"  getFoldableRangeForNode (node, grammar, existenceOnly) {\r\n    const {children} = node\r\n    const childCount = children.length\r\n\r\n    for (var i = 0, {length} = grammar.folds; i < length; i++) {\r\n      const foldSpec = grammar.folds[i]\r\n\r\n      if (foldSpec.matchers && !hasMatchingFoldSpec(foldSpec.matchers, node)) continue\r\n\r\n      let foldStart\r\n      const startEntry = foldSpec.start\r\n      if (startEntry) {\r\n        let foldStartNode\r\n        if (startEntry.index != null) {\r\n          foldStartNode = children[startEntry.index]\r\n          if (!foldStartNode || startEntry.matchers && !hasMatchingFoldSpec(startEntry.matchers, foldStartNode)) continue\r\n        } else {\r\n          foldStartNode = children.find(child => hasMatchingFoldSpec(startEntry.matchers, child))\r\n          if (!foldStartNode) continue\r\n        }\r\n        foldStart = new Point(foldStartNode.endPosition.row, Infinity)\r\n      } else {\r\n        foldStart = new Point(node.startPosition.row, Infinity)\r\n      }\r\n\r\n      let foldEnd\r\n      const endEntry = foldSpec.end\r\n      if (endEntry) {\r\n        let foldEndNode\r\n        if (endEntry.index != null) {\r\n          const index = endEntry.index < 0 ? childCount + endEntry.index : endEntry.index\r\n          foldEndNode = children[index]\r\n          if (!foldEndNode || (endEntry.type && endEntry.type !== foldEndNode.type)) continue\r\n        } else {\r\n          foldEndNode = children.find(child => hasMatchingFoldSpec(endEntry.matchers, child))\r\n          if (!foldEndNode) continue\r\n        }\r\n\r\n        if (foldEndNode.startPosition.row <= foldStart.row) continue\r\n\r\n        foldEnd = foldEndNode.startPosition\r\n        if (this.buffer.findInRangeSync(\r\n          WORD_REGEX, new Range(foldEnd, new Point(foldEnd.row, Infinity))\r\n        )) {\r\n          foldEnd = new Point(foldEnd.row - 1, Infinity)\r\n        }\r\n      } else {\r\n        const {endPosition} = node\r\n        if (endPosition.column === 0) {\r\n          foldEnd = Point(endPosition.row - 1, Infinity)\r\n        } else if (childCount > 0) {\r\n          foldEnd = endPosition\r\n        } else {\r\n          foldEnd = Point(endPosition.row, 0)\r\n        }\r\n      }\r\n\r\n      return existenceOnly ? true : new Range(foldStart, foldEnd)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"hasMatchingFoldSpec","start_line":1210,"end_line":1212,"comment":[],"params":["specs","node"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"endRowForFoldAtRow","line":644,"func_location":"TextMateLanguageMode.getFoldableRanges","func_start_line":639,"func_end_line":651,"args":["row","tabLength"],"code":"  getFoldableRanges (tabLength) {\r\n    const result = []\r\n    let row = 0\r\n    const lineCount = this.buffer.getLineCount()\r\n    while (row < lineCount) {\r\n      const endRow = this.endRowForFoldAtRow(row, tabLength)\r\n      if (endRow != null) {\r\n        result.push(Range(Point(row, Infinity), Point(endRow, Infinity)))\r\n      }\r\n      row++\r\n    }\r\n    return result\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.endRowForFoldAtRow","start_line":653,"end_line":659,"comment":[],"params":["row","tabLength","existenceOnly"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"getFoldableRangesAtIndentLevel","line":227,"func_location":"TreeSitterLanguageMode.getFoldableRanges","func_start_line":226,"func_end_line":228,"args":[{"type":"object"}],"code":"  getFoldableRanges () {\r\n    return this.getFoldableRangesAtIndentLevel(null)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"TreeSitterLanguageMode.getFoldableRangesAtIndentLevel","start_line":234,"end_line":277,"comment":["*\r\n   * TODO: Make this method generate folds for nested languages (currently,\r\n   * folds are only generated for the root language layer).\r\n   "],"params":["goalLevel"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"indentLevelForLine","line":626,"func_location":"TextMateLanguageMode.getFoldableRangesAtIndentLevel","func_start_line":621,"func_end_line":637,"args":[null,"tabLength"],"code":"  getFoldableRangesAtIndentLevel (indentLevel, tabLength) {\r\n    const result = []\r\n    let row = 0\r\n    const lineCount = this.buffer.getLineCount()\r\n    while (row < lineCount) {\r\n      if (this.indentLevelForLine(this.buffer.lineForRow(row), tabLength) === indentLevel) {\r\n        const endRow = this.endRowForFoldAtRow(row, tabLength)\r\n        if (endRow != null) {\r\n          result.push(Range(Point(row, Infinity), Point(endRow, Infinity)))\r\n          row = endRow + 1\r\n          continue\r\n        }\r\n      }\r\n      row++\r\n    }\r\n    return result\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.indentLevelForLine","start_line":492,"end_line":505,"comment":[],"params":["line","tabLength"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"endRowForFoldAtRow","line":627,"func_location":"TextMateLanguageMode.getFoldableRangesAtIndentLevel","func_start_line":621,"func_end_line":637,"args":["row","tabLength"],"code":"  getFoldableRangesAtIndentLevel (indentLevel, tabLength) {\r\n    const result = []\r\n    let row = 0\r\n    const lineCount = this.buffer.getLineCount()\r\n    while (row < lineCount) {\r\n      if (this.indentLevelForLine(this.buffer.lineForRow(row), tabLength) === indentLevel) {\r\n        const endRow = this.endRowForFoldAtRow(row, tabLength)\r\n        if (endRow != null) {\r\n          result.push(Range(Point(row, Infinity), Point(endRow, Infinity)))\r\n          row = endRow + 1\r\n          continue\r\n        }\r\n      }\r\n      row++\r\n    }\r\n    return result\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.endRowForFoldAtRow","start_line":653,"end_line":659,"comment":[],"params":["row","tabLength","existenceOnly"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"getFoldableRangeForNode","line":240,"func_location":"TreeSitterLanguageMode.getFoldableRangesAtIndentLevel","func_start_line":234,"func_end_line":277,"args":["node",".grammar"],"comment":["*\r\n   * TODO: Make this method generate folds for nested languages (currently,\r\n   * folds are only generated for the root language layer).\r\n   "],"code":"  getFoldableRangesAtIndentLevel (goalLevel) {\r\n    let result = []\r\n    let stack = [{node: this.tree.rootNode, level: 0}]\r\n    while (stack.length > 0) {\r\n      const {node, level} = stack.pop()\r\n\r\n      const range = this.getFoldableRangeForNode(node, this.grammar)\r\n      if (range) {\r\n        if (goalLevel == null || level === goalLevel) {\r\n          let updatedExistingRange = false\r\n          for (let i = 0, {length} = result; i < length; i++) {\r\n            if (result[i].start.row === range.start.row &&\r\n                result[i].end.row === range.end.row) {\r\n              result[i] = range\r\n              updatedExistingRange = true\r\n              break\r\n            }\r\n          }\r\n          if (!updatedExistingRange) result.push(range)\r\n        }\r\n      }\r\n\r\n      const parentStartRow = node.startPosition.row\r\n      const parentEndRow = node.endPosition.row\r\n      for (let children = node.namedChildren, i = 0, {length} = children; i < length; i++) {\r\n        const child = children[i]\r\n        const {startPosition: childStart, endPosition: childEnd} = child\r\n        if (childEnd.row > childStart.row) {\r\n          if (childStart.row === parentStartRow && childEnd.row === parentEndRow) {\r\n            stack.push({node: child, level: level})\r\n          } else {\r\n            const childLevel = range && range.containsPoint(childStart) && range.containsPoint(childEnd)\r\n              ? level + 1\r\n              : level\r\n            if (childLevel <= goalLevel || goalLevel == null) {\r\n              stack.push({node: child, level: childLevel})\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return result.sort((a, b) => a.start.row - b.start.row)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"TreeSitterLanguageMode.getFoldableRangeForNode","start_line":318,"end_line":377,"comment":[],"params":["node","grammar","existenceOnly"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getPanels","line":1754,"func_location":"Workspace.getFooterPanels","func_start_line":1753,"func_end_line":1755,"args":[{"type":"string"}],"comment":[" Essential: Get an {Array} of all the panel items in the footer."],"code":"  getFooterPanels () {\r\n    return this.getPanels('footer')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getPanels","start_line":1812,"end_line":1814,"comment":[],"params":["location"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"getGrammarPathScore","line":213,"func_location":"GrammarRegistry.getGrammarScore","func_start_line":206,"func_end_line":242,"args":["grammar","filePath"],"comment":[" Extended: Returns a {Number} representing how well the grammar matches the"," `filePath` and `contents`."],"code":"  getGrammarScore (grammar, filePath, contents) {\r\n    if (contents == null && fs.isFileSync(filePath)) {\r\n      contents = fs.readFileSync(filePath, 'utf8')\r\n    }\r\n\r\n    // Initially identify matching grammars based on the filename and the first\r\n    // line of the file.\r\n    let score = this.getGrammarPathScore(grammar, filePath)\r\n    if (this.grammarMatchesPrefix(grammar, contents)) score += 0.5\r\n\r\n    // If multiple grammars match by one of the above criteria, break ties.\r\n    if (score > 0) {\r\n      // Prefer either TextMate or Tree-sitter grammars based on the user's settings.\r\n      if (grammar instanceof TreeSitterGrammar) {\r\n        if (this.shouldUseTreeSitterParser(grammar.scopeName)) {\r\n          score += 0.1\r\n        } else {\r\n          return -Infinity\r\n        }\r\n      }\r\n\r\n      // Prefer grammars with matching content regexes. Prefer a grammar with no content regex\r\n      // over one with a non-matching content regex.\r\n      if (grammar.contentRegex) {\r\n        if (grammar.contentRegex.test(contents)) {\r\n          score += 0.05\r\n        } else {\r\n          score -= 0.05\r\n        }\r\n      }\r\n\r\n      // Prefer grammars that the user has manually installed over bundled grammars.\r\n      if (!grammar.bundledPackage) score += 0.01\r\n    }\r\n\r\n    return score\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.getGrammarPathScore","start_line":244,"end_line":274,"comment":[],"params":["grammar","filePath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"grammarMatchesPrefix","line":214,"func_location":"GrammarRegistry.getGrammarScore","func_start_line":206,"func_end_line":242,"args":["grammar","contents"],"comment":[" Extended: Returns a {Number} representing how well the grammar matches the"," `filePath` and `contents`."],"code":"  getGrammarScore (grammar, filePath, contents) {\r\n    if (contents == null && fs.isFileSync(filePath)) {\r\n      contents = fs.readFileSync(filePath, 'utf8')\r\n    }\r\n\r\n    // Initially identify matching grammars based on the filename and the first\r\n    // line of the file.\r\n    let score = this.getGrammarPathScore(grammar, filePath)\r\n    if (this.grammarMatchesPrefix(grammar, contents)) score += 0.5\r\n\r\n    // If multiple grammars match by one of the above criteria, break ties.\r\n    if (score > 0) {\r\n      // Prefer either TextMate or Tree-sitter grammars based on the user's settings.\r\n      if (grammar instanceof TreeSitterGrammar) {\r\n        if (this.shouldUseTreeSitterParser(grammar.scopeName)) {\r\n          score += 0.1\r\n        } else {\r\n          return -Infinity\r\n        }\r\n      }\r\n\r\n      // Prefer grammars with matching content regexes. Prefer a grammar with no content regex\r\n      // over one with a non-matching content regex.\r\n      if (grammar.contentRegex) {\r\n        if (grammar.contentRegex.test(contents)) {\r\n          score += 0.05\r\n        } else {\r\n          score -= 0.05\r\n        }\r\n      }\r\n\r\n      // Prefer grammars that the user has manually installed over bundled grammars.\r\n      if (!grammar.bundledPackage) score += 0.01\r\n    }\r\n\r\n    return score\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.grammarMatchesPrefix","start_line":276,"end_line":303,"comment":[],"params":["grammar","contents"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"shouldUseTreeSitterParser","line":220,"func_location":"GrammarRegistry.getGrammarScore","func_start_line":206,"func_end_line":242,"args":["grammar.scopeName"],"comment":[" Extended: Returns a {Number} representing how well the grammar matches the"," `filePath` and `contents`."],"code":"  getGrammarScore (grammar, filePath, contents) {\r\n    if (contents == null && fs.isFileSync(filePath)) {\r\n      contents = fs.readFileSync(filePath, 'utf8')\r\n    }\r\n\r\n    // Initially identify matching grammars based on the filename and the first\r\n    // line of the file.\r\n    let score = this.getGrammarPathScore(grammar, filePath)\r\n    if (this.grammarMatchesPrefix(grammar, contents)) score += 0.5\r\n\r\n    // If multiple grammars match by one of the above criteria, break ties.\r\n    if (score > 0) {\r\n      // Prefer either TextMate or Tree-sitter grammars based on the user's settings.\r\n      if (grammar instanceof TreeSitterGrammar) {\r\n        if (this.shouldUseTreeSitterParser(grammar.scopeName)) {\r\n          score += 0.1\r\n        } else {\r\n          return -Infinity\r\n        }\r\n      }\r\n\r\n      // Prefer grammars with matching content regexes. Prefer a grammar with no content regex\r\n      // over one with a non-matching content regex.\r\n      if (grammar.contentRegex) {\r\n        if (grammar.contentRegex.test(contents)) {\r\n          score += 0.05\r\n        } else {\r\n          score -= 0.05\r\n        }\r\n      }\r\n\r\n      // Prefer grammars that the user has manually installed over bundled grammars.\r\n      if (!grammar.bundledPackage) score += 0.01\r\n    }\r\n\r\n    return score\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.shouldUseTreeSitterParser","start_line":579,"end_line":584,"comment":[],"params":["languageId"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getPanels","line":1733,"func_location":"Workspace.getHeaderPanels","func_start_line":1732,"func_end_line":1734,"args":[{"type":"string"}],"comment":[" Essential: Get an {Array} of all the panel items in the header."],"code":"  getHeaderPanels () {\r\n    return this.getPanels('header')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getPanels","start_line":1812,"end_line":1814,"comment":[],"params":["location"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":123,"func_location":"TextEditorElement.getHeight","func_start_line":122,"func_end_line":124,"args":[],"code":"  getHeight () {\r\n    return this.getComponent().getScrollContainerHeight()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js","name":"getDecorations","line":67,"func_location":"DecorationManager.getHighlightDecorations","func_start_line":66,"func_end_line":68,"args":[null],"code":"  getHighlightDecorations (propertyFilter) {\r\n    return this.getDecorations(propertyFilter).filter(decoration => decoration.isType('highlight'))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js","name":"DecorationManager.getDecorations","start_line":40,"end_line":56,"comment":[],"params":["propertyFilter"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollContainerClientWidth","line":2110,"func_location":"TextEditorComponent.getHorizontalAutoscrollMargin","func_start_line":2108,"func_end_line":2117,"args":[],"code":"  getHorizontalAutoscrollMargin () {\r\n    const maxMarginInBaseCharacters = Math.floor(\r\n      (this.getScrollContainerClientWidth() / this.getBaseCharacterWidth() - 1) / 2\r\n    )\r\n    const marginInBaseCharacters = Math.min(\r\n      this.props.model.horizontalScrollMargin,\r\n      maxMarginInBaseCharacters\r\n    )\r\n    return marginInBaseCharacters * this.getBaseCharacterWidth()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollContainerClientWidth","start_line":2636,"end_line":2638,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getBaseCharacterWidth","line":2110,"func_location":"TextEditorComponent.getHorizontalAutoscrollMargin","func_start_line":2108,"func_end_line":2117,"args":[],"code":"  getHorizontalAutoscrollMargin () {\r\n    const maxMarginInBaseCharacters = Math.floor(\r\n      (this.getScrollContainerClientWidth() / this.getBaseCharacterWidth() - 1) / 2\r\n    )\r\n    const marginInBaseCharacters = Math.min(\r\n      this.props.model.horizontalScrollMargin,\r\n      maxMarginInBaseCharacters\r\n    )\r\n    return marginInBaseCharacters * this.getBaseCharacterWidth()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getBaseCharacterWidth","start_line":2604,"end_line":2606,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getBaseCharacterWidth","line":2116,"func_location":"TextEditorComponent.getHorizontalAutoscrollMargin","func_start_line":2108,"func_end_line":2117,"args":[],"code":"  getHorizontalAutoscrollMargin () {\r\n    const maxMarginInBaseCharacters = Math.floor(\r\n      (this.getScrollContainerClientWidth() / this.getBaseCharacterWidth() - 1) / 2\r\n    )\r\n    const marginInBaseCharacters = Math.min(\r\n      this.props.model.horizontalScrollMargin,\r\n      maxMarginInBaseCharacters\r\n    )\r\n    return marginInBaseCharacters * this.getBaseCharacterWidth()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getBaseCharacterWidth","start_line":2604,"end_line":2606,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":165,"func_location":"TextEditorElement.getHorizontalScrollbarHeight","func_start_line":164,"func_end_line":166,"args":[],"code":"  getHorizontalScrollbarHeight () {\r\n    return this.getComponent().getHorizontalScrollbarHeight()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"getActiveThemes","line":383,"func_location":"ThemeManager.getImportPaths","func_start_line":381,"func_end_line":402,"args":[],"code":"  getImportPaths () {\r\n    let themePaths\r\n    const activeThemes = this.getActiveThemes()\r\n    if (activeThemes.length > 0) {\r\n      themePaths = (activeThemes.filter((theme) => theme).map((theme) => theme.getStylesheetsPath()))\r\n    } else {\r\n      themePaths = []\r\n      for (const themeName of this.getEnabledThemeNames()) {\r\n        const themePath = this.packageManager.resolvePackagePath(themeName)\r\n        if (themePath) {\r\n          const deprecatedPath = path.join(themePath, 'stylesheets')\r\n          if (fs.isDirectorySync(deprecatedPath)) {\r\n            themePaths.push(deprecatedPath)\r\n          } else {\r\n            themePaths.push(path.join(themePath, 'styles'))\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return themePaths.filter(themePath => fs.isDirectorySync(themePath))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.getActiveThemes","start_line":92,"end_line":94,"comment":[" Public: Returns an {Array} of all the active themes."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"getEnabledThemeNames","line":388,"func_location":"ThemeManager.getImportPaths","func_start_line":381,"func_end_line":402,"args":[],"code":"  getImportPaths () {\r\n    let themePaths\r\n    const activeThemes = this.getActiveThemes()\r\n    if (activeThemes.length > 0) {\r\n      themePaths = (activeThemes.filter((theme) => theme).map((theme) => theme.getStylesheetsPath()))\r\n    } else {\r\n      themePaths = []\r\n      for (const themeName of this.getEnabledThemeNames()) {\r\n        const themePath = this.packageManager.resolvePackagePath(themeName)\r\n        if (themePath) {\r\n          const deprecatedPath = path.join(themePath, 'stylesheets')\r\n          if (fs.isDirectorySync(deprecatedPath)) {\r\n            themePaths.push(deprecatedPath)\r\n          } else {\r\n            themePaths.push(path.join(themePath, 'styles'))\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return themePaths.filter(themePath => fs.isDirectorySync(themePath))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.getEnabledThemeNames","start_line":117,"end_line":152,"comment":[" Public: Get the enabled theme names from the config.",""," Returns an array of theme names in the order that they should be activated."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"getIncompatibleNativeModulesStorageKey","line":1054,"func_location":"Package.getIncompatibleNativeModules","func_start_line":1051,"func_end_line":1083,"args":[null],"comment":[" Get the incompatible native modules that this package depends on."," This recurses through all dependencies and requires all modules that"," contain a `.node` file.",""," This information is cached in local storage on a per package/version basis"," to minimize the impact on startup time."],"code":"  getIncompatibleNativeModules () {\r\n    if (!this.packageManager.devMode) {\r\n      try {\r\n        const arrayAsString = global.localStorage.getItem(this.getIncompatibleNativeModulesStorageKey())\r\n        if (arrayAsString) return JSON.parse(arrayAsString)\r\n      } catch (error1) {}\r\n    }\r\n\r\n    const incompatibleNativeModules = []\r\n    for (let nativeModulePath of this.getNativeModuleDependencyPaths()) {\r\n      try {\r\n        require(nativeModulePath)\r\n      } catch (error) {\r\n        let version\r\n        try {\r\n          ({version} = require(`${nativeModulePath}/package.json`))\r\n        } catch (error2) {}\r\n        incompatibleNativeModules.push({\r\n          path: nativeModulePath,\r\n          name: path.basename(nativeModulePath),\r\n          version,\r\n          error: error.message\r\n        })\r\n      }\r\n    }\r\n\r\n    global.localStorage.setItem(\r\n      this.getIncompatibleNativeModulesStorageKey(),\r\n      JSON.stringify(incompatibleNativeModules)\r\n    )\r\n\r\n    return incompatibleNativeModules\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.getIncompatibleNativeModulesStorageKey","start_line":1036,"end_line":1039,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"getNativeModuleDependencyPaths","line":1060,"func_location":"Package.getIncompatibleNativeModules","func_start_line":1051,"func_end_line":1083,"args":[],"comment":[" Get the incompatible native modules that this package depends on."," This recurses through all dependencies and requires all modules that"," contain a `.node` file.",""," This information is cached in local storage on a per package/version basis"," to minimize the impact on startup time."],"code":"  getIncompatibleNativeModules () {\r\n    if (!this.packageManager.devMode) {\r\n      try {\r\n        const arrayAsString = global.localStorage.getItem(this.getIncompatibleNativeModulesStorageKey())\r\n        if (arrayAsString) return JSON.parse(arrayAsString)\r\n      } catch (error1) {}\r\n    }\r\n\r\n    const incompatibleNativeModules = []\r\n    for (let nativeModulePath of this.getNativeModuleDependencyPaths()) {\r\n      try {\r\n        require(nativeModulePath)\r\n      } catch (error) {\r\n        let version\r\n        try {\r\n          ({version} = require(`${nativeModulePath}/package.json`))\r\n        } catch (error2) {}\r\n        incompatibleNativeModules.push({\r\n          path: nativeModulePath,\r\n          name: path.basename(nativeModulePath),\r\n          version,\r\n          error: error.message\r\n        })\r\n      }\r\n    }\r\n\r\n    global.localStorage.setItem(\r\n      this.getIncompatibleNativeModulesStorageKey(),\r\n      JSON.stringify(incompatibleNativeModules)\r\n    )\r\n\r\n    return incompatibleNativeModules\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.getNativeModuleDependencyPaths","start_line":937,"end_line":963,"comment":[" Get an array of all the native modules that this package depends on.",""," First try to get this information from"," @metadata._atomModuleCache.extensions. If @metadata._atomModuleCache doesn't"," exist, recurse through all dependencies."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"getIncompatibleNativeModulesStorageKey","line":1078,"func_location":"Package.getIncompatibleNativeModules","func_start_line":1051,"func_end_line":1083,"args":[],"comment":[" Get the incompatible native modules that this package depends on."," This recurses through all dependencies and requires all modules that"," contain a `.node` file.",""," This information is cached in local storage on a per package/version basis"," to minimize the impact on startup time."],"code":"  getIncompatibleNativeModules () {\r\n    if (!this.packageManager.devMode) {\r\n      try {\r\n        const arrayAsString = global.localStorage.getItem(this.getIncompatibleNativeModulesStorageKey())\r\n        if (arrayAsString) return JSON.parse(arrayAsString)\r\n      } catch (error1) {}\r\n    }\r\n\r\n    const incompatibleNativeModules = []\r\n    for (let nativeModulePath of this.getNativeModuleDependencyPaths()) {\r\n      try {\r\n        require(nativeModulePath)\r\n      } catch (error) {\r\n        let version\r\n        try {\r\n          ({version} = require(`${nativeModulePath}/package.json`))\r\n        } catch (error2) {}\r\n        incompatibleNativeModules.push({\r\n          path: nativeModulePath,\r\n          name: path.basename(nativeModulePath),\r\n          version,\r\n          error: error.message\r\n        })\r\n      }\r\n    }\r\n\r\n    global.localStorage.setItem(\r\n      this.getIncompatibleNativeModulesStorageKey(),\r\n      JSON.stringify(incompatibleNativeModules)\r\n    )\r\n\r\n    return incompatibleNativeModules\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.getIncompatibleNativeModulesStorageKey","start_line":1036,"end_line":1039,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferColumn","line":188,"func_location":"Cursor.getIndentLevel","func_start_line":186,"func_end_line":192,"args":[],"comment":[" Public: Returns the indentation level of the current line."],"code":"  getIndentLevel () {\r\n    if (this.editor.getSoftTabs()) {\r\n      return this.getBufferColumn() / this.editor.getTabLength()\r\n    } else {\r\n      return this.getBufferColumn()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferColumn","start_line":111,"end_line":113,"comment":[" Public: Returns the cursor's current buffer column."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferColumn","line":190,"func_location":"Cursor.getIndentLevel","func_start_line":186,"func_end_line":192,"args":[],"comment":[" Public: Returns the indentation level of the current line."],"code":"  getIndentLevel () {\r\n    if (this.editor.getSoftTabs()) {\r\n      return this.getBufferColumn() / this.editor.getTabLength()\r\n    } else {\r\n      return this.getBufferColumn()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferColumn","start_line":111,"end_line":113,"comment":[" Public: Returns the cursor's current buffer column."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"getPreferredSize","line":412,"func_location":"Dock.getInitialSize","func_start_line":407,"func_end_line":414,"args":["activePaneItem",".location"],"code":"  getInitialSize () {\r\n    // The item may not have been activated yet. If that's the case, just use the first item.\r\n    const activePaneItem = this.paneContainer.getActivePaneItem() || this.paneContainer.getPaneItems()[0]\r\n    // If there are items, we should have an explicit width; if not, we shouldn't.\r\n    return activePaneItem\r\n      ? getPreferredSize(activePaneItem, this.location) || DEFAULT_INITIAL_SIZE\r\n      : null\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"getPreferredSize","start_line":825,"end_line":837,"comment":[],"params":["item","location"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip-manager.js","name":"humanizeKeystrokes","line":201,"func_location":"getKeystroke","func_start_line":199,"func_end_line":203,"args":["bindings..keystrokes"],"code":"function getKeystroke (bindings) {\r\n  if (bindings && bindings.length) {\r\n    return `<span class=\"keystroke\">${humanizeKeystrokes(bindings[0].keystrokes)}</span>`\r\n  }\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip-manager.js","name":"humanizeKeystrokes","start_line":193,"end_line":197,"comment":[],"params":["keystroke"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"getScreenLineCount","line":1227,"func_location":"TextEditor.getLastScreenRow","func_start_line":1227,"func_end_line":1227,"args":[],"comment":[" Essential: Returns a {Number} representing the last zero-indexed screen row"," number of the editor."],"code":"  getLastScreenRow () { return this.getScreenLineCount() - 1 }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.getScreenLineCount","start_line":1217,"end_line":1217,"comment":[" Essential: Returns a {Number} representing the number of screen lines in the"," editor. This accounts for folds."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"rowForPixelPosition","line":2767,"func_location":"TextEditorComponent.getLastVisibleRow","func_start_line":2763,"func_end_line":2772,"args":[null],"code":"  getLastVisibleRow () {\r\n    if (this.derivedDimensionsCache.lastVisibleRow == null) {\r\n      this.derivedDimensionsCache.lastVisibleRow = Math.min(\r\n        this.props.model.getApproximateScreenLineCount() - 1,\r\n        this.rowForPixelPosition(this.getScrollBottom())\r\n      )\r\n    }\r\n\r\n    return this.derivedDimensionsCache.lastVisibleRow\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.rowForPixelPosition","start_line":2346,"end_line":2348,"comment":[],"params":["pixelPosition"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollBottom","line":2767,"func_location":"TextEditorComponent.getLastVisibleRow","func_start_line":2763,"func_end_line":2772,"args":[null],"code":"  getLastVisibleRow () {\r\n    if (this.derivedDimensionsCache.lastVisibleRow == null) {\r\n      this.derivedDimensionsCache.lastVisibleRow = Math.min(\r\n        this.props.model.getApproximateScreenLineCount() - 1,\r\n        this.rowForPixelPosition(this.getScrollBottom())\r\n      )\r\n    }\r\n\r\n    return this.derivedDimensionsCache.lastVisibleRow\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollBottom","start_line":2815,"end_line":2817,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getModel","line":319,"func_location":"TextEditorElement.getLastVisibleScreenRow","func_start_line":318,"func_end_line":320,"args":[],"code":"  getLastVisibleScreenRow () {\r\n    return this.getModel().getLastVisibleScreenRow()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getModel","start_line":80,"end_line":82,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getPanels","line":1670,"func_location":"Workspace.getLeftPanels","func_start_line":1669,"func_end_line":1671,"args":[{"type":"string"}],"comment":[" Essential: Get an {Array} of all the panel items to the left of the editor window."],"code":"  getLeftPanels () {\r\n    return this.getPanels('left')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getPanels","start_line":1812,"end_line":1814,"comment":[],"params":["location"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js","name":"getDecorations","line":59,"func_location":"DecorationManager.getLineDecorations","func_start_line":58,"func_end_line":60,"args":[null],"code":"  getLineDecorations (propertyFilter) {\r\n    return this.getDecorations(propertyFilter).filter(decoration => decoration.isType('line'))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js","name":"DecorationManager.getDecorations","start_line":40,"end_line":56,"comment":[],"params":["propertyFilter"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getRepo","line":451,"func_location":"GitRepository.getLineDiffs","func_start_line":447,"func_end_line":453,"args":["path"],"comment":[" Public: Retrieves the line diffs comparing the `HEAD` version of the given"," path and the given text.",""," * `path` The {String} path relative to the repository."," * `text` The {String} to compare against the `HEAD` contents",""," Returns an {Array} of hunk {Object}s with the following keys:","   * `oldStart` The line {Number} of the old hunk.","   * `newStart` The line {Number} of the new hunk.","   * `oldLines` The {Number} of lines in the old hunk.","   * `newLines` The {Number} of lines in the new hunk"],"code":"  getLineDiffs (path, text) {\r\n    // Ignore eol of line differences on windows so that files checked in as\r\n    // LF don't report every line modified when the text contains CRLF endings.\r\n    const options = {ignoreEolWhitespace: process.platform === 'win32'}\r\n    const repo = this.getRepo(path)\r\n    return repo.getLineDiffs(repo.relativize(path), text, options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getRepo","start_line":524,"end_line":530,"comment":[" Returns the corresponding {Repository}"],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js","name":"getDecorations","line":63,"func_location":"DecorationManager.getLineNumberDecorations","func_start_line":62,"func_end_line":64,"args":[null],"code":"  getLineNumberDecorations (propertyFilter) {\r\n    return this.getDecorations(propertyFilter).filter(decoration => decoration.isType('line-number'))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js","name":"DecorationManager.getDecorations","start_line":40,"end_line":56,"comment":[],"params":["propertyFilter"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"getLoadedPackages","line":331,"func_location":"PackageManager.getLoadedPackagesForTypes","func_start_line":330,"func_end_line":332,"args":[null],"comment":[" Get packages for a certain package type",""," * `types` an {Array} of {String}s like ['atom', 'textmate']."],"code":"  getLoadedPackagesForTypes (types) {\r\n    return this.getLoadedPackages().filter(p => types.includes(p.getType()))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.getLoadedPackages","start_line":323,"end_line":325,"comment":["\r\n  Section: Accessing loaded packages\r\n  "," Public: Get an {Array} of all the loaded {Package}s"],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"getLoadedThemes","line":74,"func_location":"ThemeManager.getLoadedThemeNames","func_start_line":73,"func_end_line":75,"args":[null],"comment":["\r\n  Section: Accessing Loaded Themes\r\n  "," Public: Returns an {Array} of {String}s of all the loaded theme names."],"code":"  getLoadedThemeNames () {\r\n    return this.getLoadedThemes().map((theme) => theme.name)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.getLoadedThemes","start_line":78,"end_line":80,"comment":[" Public: Returns an {Array} of all the loaded themes."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"getRightmostScreenPosition","line":1294,"func_location":"TextEditor.getLongestScreenRow","func_start_line":1294,"func_end_line":1294,"args":[],"code":"  getLongestScreenRow () { return this.getRightmostScreenPosition().row }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.getRightmostScreenPosition","start_line":1288,"end_line":1288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"getPath","line":1105,"func_location":"TextEditor.getLongTitle","func_start_line":1104,"func_end_line":1133,"args":[],"comment":[" Essential: Get unique title for display in other parts of the UI, such as"," the window title.",""," If the editor's buffer is unsaved, its title is \"untitled\""," If the editor's buffer is saved, its unique title is formatted as one"," of the following,"," * \"<filename>\" when it is the only editing buffer with this file name."," * \"<filename>  <unique-dir-prefix>\" when other buffers have this file name.",""," Returns a {String}"],"code":"  getLongTitle () {\r\n    if (this.getPath()) {\r\n      const fileName = this.getFileName()\r\n\r\n      let myPathSegments\r\n      const openEditorPathSegmentsWithSameFilename = []\r\n      for (const textEditor of atom.workspace.getTextEditors()) {\r\n        if (textEditor.getFileName() === fileName) {\r\n          const pathSegments = fs.tildify(textEditor.getDirectoryPath()).split(path.sep)\r\n          openEditorPathSegmentsWithSameFilename.push(pathSegments)\r\n          if (textEditor === this) myPathSegments = pathSegments\r\n        }\r\n      }\r\n\r\n      if (!myPathSegments || openEditorPathSegmentsWithSameFilename.length === 1) return fileName\r\n\r\n      let commonPathSegmentCount\r\n      for (let i = 0, {length} = myPathSegments; i < length; i++) {\r\n        const myPathSegment = myPathSegments[i]\r\n        if (openEditorPathSegmentsWithSameFilename.some(segments => (segments.length === i + 1) || (segments[i] !== myPathSegment))) {\r\n          commonPathSegmentCount = i\r\n          break\r\n        }\r\n      }\r\n\r\n      return `${fileName} \\u2014 ${path.join(...myPathSegments.slice(commonPathSegmentCount))}`\r\n    } else {\r\n      return 'untitled'\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.getPath","start_line":1136,"end_line":1138,"comment":[" Essential: Returns the {String} path of this editor's text buffer."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"getFileName","line":1106,"func_location":"TextEditor.getLongTitle","func_start_line":1104,"func_end_line":1133,"args":[],"comment":[" Essential: Get unique title for display in other parts of the UI, such as"," the window title.",""," If the editor's buffer is unsaved, its title is \"untitled\""," If the editor's buffer is saved, its unique title is formatted as one"," of the following,"," * \"<filename>\" when it is the only editing buffer with this file name."," * \"<filename>  <unique-dir-prefix>\" when other buffers have this file name.",""," Returns a {String}"],"code":"  getLongTitle () {\r\n    if (this.getPath()) {\r\n      const fileName = this.getFileName()\r\n\r\n      let myPathSegments\r\n      const openEditorPathSegmentsWithSameFilename = []\r\n      for (const textEditor of atom.workspace.getTextEditors()) {\r\n        if (textEditor.getFileName() === fileName) {\r\n          const pathSegments = fs.tildify(textEditor.getDirectoryPath()).split(path.sep)\r\n          openEditorPathSegmentsWithSameFilename.push(pathSegments)\r\n          if (textEditor === this) myPathSegments = pathSegments\r\n        }\r\n      }\r\n\r\n      if (!myPathSegments || openEditorPathSegmentsWithSameFilename.length === 1) return fileName\r\n\r\n      let commonPathSegmentCount\r\n      for (let i = 0, {length} = myPathSegments; i < length; i++) {\r\n        const myPathSegment = myPathSegments[i]\r\n        if (openEditorPathSegmentsWithSameFilename.some(segments => (segments.length === i + 1) || (segments[i] !== myPathSegment))) {\r\n          commonPathSegmentCount = i\r\n          break\r\n        }\r\n      }\r\n\r\n      return `${fileName} \\u2014 ${path.join(...myPathSegments.slice(commonPathSegmentCount))}`\r\n    } else {\r\n      return 'untitled'\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.getFileName","start_line":1140,"end_line":1143,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"getRightmostScreenPosition","line":1292,"func_location":"TextEditor.getMaxScreenLineLength","func_start_line":1292,"func_end_line":1292,"args":[],"code":"  getMaxScreenLineLength () { return this.getRightmostScreenPosition().column }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.getRightmostScreenPosition","start_line":1288,"end_line":1288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollWidth","line":2842,"func_location":"TextEditorComponent.getMaxScrollLeft","func_start_line":2841,"func_end_line":2843,"args":[null],"code":"  getMaxScrollLeft () {\r\n    return Math.round(Math.max(0, this.getScrollWidth() - this.getScrollContainerClientWidth()))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollWidth","start_line":2672,"end_line":2682,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollContainerClientWidth","line":2842,"func_location":"TextEditorComponent.getMaxScrollLeft","func_start_line":2841,"func_end_line":2843,"args":[null],"code":"  getMaxScrollLeft () {\r\n    return Math.round(Math.max(0, this.getScrollWidth() - this.getScrollContainerClientWidth()))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollContainerClientWidth","start_line":2636,"end_line":2638,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollHeight","line":2812,"func_location":"TextEditorComponent.getMaxScrollTop","func_start_line":2811,"func_end_line":2813,"args":[null],"code":"  getMaxScrollTop () {\r\n    return Math.round(Math.max(0, this.getScrollHeight() - this.getScrollContainerClientHeight()))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollHeight","start_line":2659,"end_line":2670,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollContainerClientHeight","line":2812,"func_location":"TextEditorComponent.getMaxScrollTop","func_start_line":2811,"func_end_line":2813,"args":[null],"code":"  getMaxScrollTop () {\r\n    return Math.round(Math.max(0, this.getScrollHeight() - this.getScrollContainerClientHeight()))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollContainerClientHeight","start_line":2640,"end_line":2642,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":149,"func_location":"TextEditorElement.getMaxScrollTop","func_start_line":148,"func_end_line":150,"args":[],"code":"  getMaxScrollTop () {\r\n    return this.getComponent().getMaxScrollTop()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getPanels","line":1775,"func_location":"Workspace.getModalPanels","func_start_line":1774,"func_end_line":1776,"args":[{"type":"string"}],"comment":[" Essential: Get an {Array} of all the modal panel items"],"code":"  getModalPanels () {\r\n    return this.getPanels('modal')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getPanels","start_line":1812,"end_line":1814,"comment":[],"params":["location"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":81,"func_location":"TextEditorElement.getModel","func_start_line":80,"func_end_line":82,"args":[],"code":"  getModel () {\r\n    return this.getComponent().props.model\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":77,"func_location":"TextEditorElement.getNextUpdatePromise","func_start_line":76,"func_end_line":78,"args":[],"comment":[" Extended: Get a promise that resolves the next time the element's DOM"," is updated in any way.",""," This can be useful when you've made a change to the model and need to"," be sure this change has been flushed to the DOM.",""," Returns a {Promise}."],"code":"  getNextUpdatePromise () {\r\n    return this.getComponent().getNextUpdatePromise()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferPosition","line":494,"func_location":"Cursor.getNextWordBoundaryBufferPosition","func_start_line":493,"func_end_line":513,"args":[],"comment":[" Public: Returns buffer position of the next word boundary. It might be on"," the current word, or the previous word.",""," * `options` (optional) {Object} with the following keys:","   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"","      (default: {::wordRegExp})"],"code":"  getNextWordBoundaryBufferPosition (options = {}) {\r\n    const currentBufferPosition = this.getBufferPosition()\r\n    const scanRange = Range(currentBufferPosition, this.editor.getEofBufferPosition())\r\n\r\n    const range = this.editor.buffer.findInRangeSync(\r\n      options.wordRegex || this.wordRegExp(),\r\n      scanRange\r\n    )\r\n\r\n    if (range) {\r\n      if (range.start.row > currentBufferPosition.row) {\r\n        return Point(range.start.row, 0)\r\n      } else if (currentBufferPosition.isLessThan(range.start)) {\r\n        return Point.fromObject(range.start)\r\n      } else {\r\n        return Point.fromObject(range.end)\r\n      }\r\n    } else {\r\n      return currentBufferPosition\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferPosition","start_line":91,"end_line":93,"comment":[" Public: Returns the current buffer position as an Array."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"wordRegExp","line":498,"func_location":"Cursor.getNextWordBoundaryBufferPosition","func_start_line":493,"func_end_line":513,"args":[],"comment":[" Public: Returns buffer position of the next word boundary. It might be on"," the current word, or the previous word.",""," * `options` (optional) {Object} with the following keys:","   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"","      (default: {::wordRegExp})"],"code":"  getNextWordBoundaryBufferPosition (options = {}) {\r\n    const currentBufferPosition = this.getBufferPosition()\r\n    const scanRange = Range(currentBufferPosition, this.editor.getEofBufferPosition())\r\n\r\n    const range = this.editor.buffer.findInRangeSync(\r\n      options.wordRegex || this.wordRegExp(),\r\n      scanRange\r\n    )\r\n\r\n    if (range) {\r\n      if (range.start.row > currentBufferPosition.row) {\r\n        return Point(range.start.row, 0)\r\n      } else if (currentBufferPosition.isLessThan(range.start)) {\r\n        return Point.fromObject(range.start)\r\n      } else {\r\n        return Point.fromObject(range.end)\r\n      }\r\n    } else {\r\n      return currentBufferPosition\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.wordRegExp","start_line":674,"end_line":681,"comment":[" Public: Get the RegExp used by the cursor to determine what a \"word\" is.",""," * `options` (optional) {Object} with the following keys:","   * `includeNonWordCharacters` A {Boolean} indicating whether to include","     non-word characters in the regex. (default: true)",""," Returns a {RegExp}."],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferPosition","line":717,"func_location":"Cursor.getNonWordCharacters","func_start_line":716,"func_end_line":718,"args":[null],"comment":["\r\n  Section: Private\r\n  "],"code":"  getNonWordCharacters () {\r\n    return this.editor.getNonWordCharacters(this.getBufferPosition())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferPosition","start_line":91,"end_line":93,"comment":[" Public: Returns the current buffer position as an Array."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"scopeDescriptorForPosition","line":64,"func_location":"TextMateLanguageMode.getNonWordCharacters","func_start_line":63,"func_end_line":66,"args":["position"],"code":"  getNonWordCharacters (position) {\r\n    const scope = this.scopeDescriptorForPosition(position)\r\n    return this.config.get('editor.nonWordCharacters', {scope})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.scopeDescriptorForPosition","start_line":507,"end_line":526,"comment":[],"params":["position"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"last","line":842,"func_location":"HighlightIterator.getOpenScopeIds","func_start_line":841,"func_end_line":843,"args":[],"code":"  getOpenScopeIds () {\r\n    return last(this.iterators).getOpenScopeIds()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"last","start_line":1206,"end_line":1208,"comment":[],"params":["array"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip.js","name":"extend","line":131,"func_location":"Tooltip.prototype.getOptions","func_start_line":130,"func_end_line":141,"args":[null,null,"options"],"code":"Tooltip.prototype.getOptions = function (options) {\r\n  options = extend({}, this.getDefaults(), options)\r\n\r\n  if (options.delay && typeof options.delay === 'number') {\r\n    options.delay = {\r\n      show: options.delay,\r\n      hide: options.delay\r\n    }\r\n  }\r\n\r\n  return options\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip.js","name":"extend","start_line":550,"end_line":561,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getConfigValue","line":285,"func_location":"GitRepository.getOriginURL","func_start_line":284,"func_end_line":286,"args":[{"type":"string"},"path"],"comment":[" Public: Returns the origin url of the repository.",""," * `path` (optional) {String} path in the repository to get this information","   for, only needed if the repository has submodules."],"code":"  getOriginURL (path) {\r\n    return this.getConfigValue('remote.origin.url', path)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getConfigValue","start_line":276,"end_line":278,"comment":[" Public: Returns the git configuration value specified by the key.",""," * `key`  The {String} key for the configuration to lookup."," * `path` An optional {String} path in the repository to get this information","   for, only needed if the repository has submodules."],"params":["key","path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getTextEditors","line":396,"func_location":"Workspace.getPackageNamesWithActiveGrammars","func_start_line":383,"func_end_line":408,"args":[],"code":"  getPackageNamesWithActiveGrammars () {\r\n    const packageNames = []\r\n    const addGrammar = ({includedGrammarScopes, packageName} = {}) => {\r\n      if (!packageName) { return }\r\n      // Prevent cycles\r\n      if (packageNames.indexOf(packageName) !== -1) { return }\r\n\r\n      packageNames.push(packageName)\r\n      for (let scopeName of includedGrammarScopes != null ? includedGrammarScopes : []) {\r\n        addGrammar(this.grammarRegistry.grammarForScopeName(scopeName))\r\n      }\r\n    }\r\n\r\n    const editors = this.getTextEditors()\r\n    for (let editor of editors) { addGrammar(editor.getGrammar()) }\r\n\r\n    if (editors.length > 0) {\r\n      for (let grammar of this.grammarRegistry.getGrammars()) {\r\n        if (grammar.injectionSelector) {\r\n          addGrammar(grammar)\r\n        }\r\n      }\r\n    }\r\n\r\n    return _.uniq(packageNames)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getTextEditors","start_line":1364,"end_line":1366,"comment":[" Essential: Get all text editors in the workspace.",""," Returns an {Array} of {TextEditor}s."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"getRoot","line":155,"func_location":"PaneContainer.getPaneItems","func_start_line":154,"func_end_line":156,"args":[],"code":"  getPaneItems () {\r\n    return this.getRoot().getItems()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.getRoot","start_line":129,"end_line":129,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getPaneContainers","line":1351,"func_location":"Workspace.getPaneItems","func_start_line":1350,"func_end_line":1352,"args":[null],"comment":["\r\n  Section: Pane Items\r\n  "," Essential: Get all pane items in the workspace.",""," Returns an {Array} of items."],"code":"  getPaneItems () {\r\n    return _.flatten(this.getPaneContainers().map(container => container.getPaneItems()))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getPaneContainers","start_line":1618,"end_line":1625,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"getRoot","line":148,"func_location":"PaneContainer.getPanes","func_start_line":146,"func_end_line":152,"args":[],"code":"  getPanes () {\r\n    if (this.alive) {\r\n      return this.getRoot().getPanes()\r\n    } else {\r\n      return []\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.getRoot","start_line":129,"end_line":129,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getPaneContainers","line":1432,"func_location":"Workspace.getPanes","func_start_line":1431,"func_end_line":1433,"args":[null],"comment":[" Extended: Get all panes in the workspace.",""," Returns an {Array} of {Pane}s."],"code":"  getPanes () {\r\n    return _.flatten(this.getPaneContainers().map(container => container.getPanes()))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getPaneContainers","start_line":1618,"end_line":1625,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getRepo","line":188,"func_location":"GitRepository.getPath","func_start_line":186,"func_end_line":191,"args":[null],"comment":[" Public: Returns the {String} path of the repository."],"code":"  getPath () {\r\n    if (this.path == null) {\r\n      this.path = fs.absolute(this.getRepo().getPath())\r\n    }\r\n    return this.path\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getRepo","start_line":524,"end_line":530,"comment":[" Returns the corresponding {Repository}"],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getRepo","line":375,"func_location":"GitRepository.getPathStatus","func_start_line":374,"func_end_line":390,"args":["path"],"comment":[" Public: Get the status of a single path in the repository.",""," * `path` A {String} repository-relative path.",""," Returns a {Number} representing the status. This value can be passed to"," {::isStatusModified} or {::isStatusNew} to get more information."],"code":"  getPathStatus (path) {\r\n    const repo = this.getRepo(path)\r\n    const relativePath = this.relativize(path)\r\n    const currentPathStatus = this.statuses[relativePath] || 0\r\n    let pathStatus = repo.getStatus(repo.relativize(path)) || 0\r\n    if (repo.isStatusIgnored(pathStatus)) pathStatus = 0\r\n    if (pathStatus > 0) {\r\n      this.statuses[relativePath] = pathStatus\r\n    } else {\r\n      delete this.statuses[relativePath]\r\n    }\r\n    if (currentPathStatus !== pathStatus) {\r\n      this.emitter.emit('did-change-status', {path, pathStatus})\r\n    }\r\n\r\n    return pathStatus\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getRepo","start_line":524,"end_line":530,"comment":[" Returns the corresponding {Repository}"],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"relativize","line":376,"func_location":"GitRepository.getPathStatus","func_start_line":374,"func_end_line":390,"args":["path"],"comment":[" Public: Get the status of a single path in the repository.",""," * `path` A {String} repository-relative path.",""," Returns a {Number} representing the status. This value can be passed to"," {::isStatusModified} or {::isStatusNew} to get more information."],"code":"  getPathStatus (path) {\r\n    const repo = this.getRepo(path)\r\n    const relativePath = this.relativize(path)\r\n    const currentPathStatus = this.statuses[relativePath] || 0\r\n    let pathStatus = repo.getStatus(repo.relativize(path)) || 0\r\n    if (repo.isStatusIgnored(pathStatus)) pathStatus = 0\r\n    if (pathStatus > 0) {\r\n      this.statuses[relativePath] = pathStatus\r\n    } else {\r\n      delete this.statuses[relativePath]\r\n    }\r\n    if (currentPathStatus !== pathStatus) {\r\n      this.emitter.emit('did-change-status', {path, pathStatus})\r\n    }\r\n\r\n    return pathStatus\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.relativize","start_line":208,"end_line":210,"comment":[" Public: Makes a path relative to the repository's working directory."],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"last","line":834,"func_location":"HighlightIterator.getPosition","func_start_line":833,"func_end_line":835,"args":[],"code":"  getPosition () {\r\n    return last(this.iterators).getPosition()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"last","start_line":1206,"end_line":1208,"comment":[],"params":["array"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferPosition","line":464,"func_location":"Cursor.getPreviousWordBoundaryBufferPosition","func_start_line":463,"func_end_line":485,"args":[],"comment":["\r\n  Section: Local Positions and Ranges\r\n  "," Public: Returns buffer position of previous word boundary. It might be on"," the current word, or the previous word.",""," * `options` (optional) {Object} with the following keys:","   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"","      (default: {::wordRegExp})"],"code":"  getPreviousWordBoundaryBufferPosition (options = {}) {\r\n    const currentBufferPosition = this.getBufferPosition()\r\n    const previousNonBlankRow = this.editor.buffer.previousNonBlankRow(currentBufferPosition.row)\r\n    const scanRange = Range(Point(previousNonBlankRow || 0, 0), currentBufferPosition)\r\n\r\n    const ranges = this.editor.buffer.findAllInRangeSync(\r\n      options.wordRegex || this.wordRegExp(),\r\n      scanRange\r\n    )\r\n\r\n    const range = ranges[ranges.length - 1]\r\n    if (range) {\r\n      if (range.start.row < currentBufferPosition.row && currentBufferPosition.column > 0) {\r\n        return Point(currentBufferPosition.row, 0)\r\n      } else if (currentBufferPosition.isGreaterThan(range.end)) {\r\n        return Point.fromObject(range.end)\r\n      } else {\r\n        return Point.fromObject(range.start)\r\n      }\r\n    } else {\r\n      return currentBufferPosition\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferPosition","start_line":91,"end_line":93,"comment":[" Public: Returns the current buffer position as an Array."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"wordRegExp","line":469,"func_location":"Cursor.getPreviousWordBoundaryBufferPosition","func_start_line":463,"func_end_line":485,"args":[],"comment":["\r\n  Section: Local Positions and Ranges\r\n  "," Public: Returns buffer position of previous word boundary. It might be on"," the current word, or the previous word.",""," * `options` (optional) {Object} with the following keys:","   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"","      (default: {::wordRegExp})"],"code":"  getPreviousWordBoundaryBufferPosition (options = {}) {\r\n    const currentBufferPosition = this.getBufferPosition()\r\n    const previousNonBlankRow = this.editor.buffer.previousNonBlankRow(currentBufferPosition.row)\r\n    const scanRange = Range(Point(previousNonBlankRow || 0, 0), currentBufferPosition)\r\n\r\n    const ranges = this.editor.buffer.findAllInRangeSync(\r\n      options.wordRegex || this.wordRegExp(),\r\n      scanRange\r\n    )\r\n\r\n    const range = ranges[ranges.length - 1]\r\n    if (range) {\r\n      if (range.start.row < currentBufferPosition.row && currentBufferPosition.column > 0) {\r\n        return Point(currentBufferPosition.row, 0)\r\n      } else if (currentBufferPosition.isGreaterThan(range.end)) {\r\n        return Point.fromObject(range.end)\r\n      } else {\r\n        return Point.fromObject(range.start)\r\n      }\r\n    } else {\r\n      return currentBufferPosition\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.wordRegExp","start_line":674,"end_line":681,"comment":[" Public: Get the RegExp used by the cursor to determine what a \"word\" is.",""," * `options` (optional) {Object} with the following keys:","   * `includeNonWordCharacters` A {Boolean} indicating whether to include","     non-word characters in the regex. (default: true)",""," Returns a {RegExp}."],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"arrayEquivalent","line":85,"func_location":"HistoryManager.getProject","func_start_line":83,"func_end_line":91,"args":["paths",".projects.i.paths"],"code":"  getProject (paths) {\r\n    for (var i = 0; i < this.projects.length; i++) {\r\n      if (arrayEquivalent(paths, this.projects[i].paths)) {\r\n        return this.projects[i]\r\n      }\r\n    }\r\n\r\n    return null\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"arrayEquivalent","start_line":109,"end_line":115,"comment":[],"params":["a","b"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"getSyntaxNodeContainingRange","line":412,"func_location":"TreeSitterLanguageMode.getRangeForSyntaxNodeContainingRange","func_start_line":411,"func_end_line":414,"args":["range","where"],"code":"  getRangeForSyntaxNodeContainingRange (range, where) {\r\n    const node = this.getSyntaxNodeContainingRange(range, where)\r\n    return node && node.range\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"TreeSitterLanguageMode.getSyntaxNodeContainingRange","start_line":383,"end_line":385,"comment":["\r\n  Section - Syntax Tree APIs\r\n  "],"params":["range","where"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"_pushRange","line":1120,"func_location":"NodeRangeSet.getRanges","func_start_line":1109,"func_end_line":1142},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"NodeRangeSet._pushRange","start_line":1144,"end_line":1160,"comment":[],"params":["previousRanges","newRanges","newRange"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"_pushRange","line":1132,"func_location":"NodeRangeSet.getRanges","func_start_line":1109,"func_end_line":1142},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"NodeRangeSet._pushRange","start_line":1144,"end_line":1160,"comment":[],"params":["previousRanges","newRanges","newRange"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"getLegacyScopeDescriptorForNewScopeDescriptor","line":1252,"func_location":"Config.getRawScopedValue","func_start_line":1244,"func_end_line":1262,"args":["scopeDescriptor"],"code":"  getRawScopedValue (scopeDescriptor, keyPath, options) {\r\n    scopeDescriptor = ScopeDescriptor.fromObject(scopeDescriptor)\r\n    const result = this.scopedSettingsStore.getPropertyValue(\r\n      scopeDescriptor.getScopeChain(),\r\n      keyPath,\r\n      options\r\n    )\r\n\r\n    const legacyScopeDescriptor = this.getLegacyScopeDescriptorForNewScopeDescriptor(scopeDescriptor)\r\n    if (result != null) {\r\n      return result\r\n    } else if (legacyScopeDescriptor) {\r\n      return this.scopedSettingsStore.getPropertyValue(\r\n        legacyScopeDescriptor.getScopeChain(),\r\n        keyPath,\r\n        options\r\n      )\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.getLegacyScopeDescriptorForNewScopeDescriptor","start_line":825,"end_line":827,"comment":[],"params":["scopeDescriptor"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"deepClone","line":1010,"func_location":"Config.getRawValue","func_start_line":994,"func_end_line":1018,"args":["value"],"code":"  getRawValue (keyPath, options = {}) {\r\n    let value\r\n    if (!options.excludeSources || !options.excludeSources.includes(this.mainSource)) {\r\n      value = getValueAtKeyPath(this.settings, keyPath)\r\n      if (this.projectFile != null) {\r\n        const projectValue = getValueAtKeyPath(this.projectSettings, keyPath)\r\n        value = (projectValue === undefined) ? value : projectValue\r\n      }\r\n    }\r\n\r\n    let defaultValue\r\n    if (!options.sources || options.sources.length === 0) {\r\n      defaultValue = getValueAtKeyPath(this.defaultSettings, keyPath)\r\n    }\r\n\r\n    if (value != null) {\r\n      value = this.deepClone(value)\r\n      if (isPlainObject(value) && isPlainObject(defaultValue)) {\r\n        this.deepDefaults(value, defaultValue)\r\n      }\r\n      return value\r\n    } else {\r\n      return this.deepClone(defaultValue)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.deepClone","start_line":1092,"end_line":1102,"comment":[],"params":["object"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"deepDefaults","line":1012,"func_location":"Config.getRawValue","func_start_line":994,"func_end_line":1018,"args":["value","defaultValue"],"code":"  getRawValue (keyPath, options = {}) {\r\n    let value\r\n    if (!options.excludeSources || !options.excludeSources.includes(this.mainSource)) {\r\n      value = getValueAtKeyPath(this.settings, keyPath)\r\n      if (this.projectFile != null) {\r\n        const projectValue = getValueAtKeyPath(this.projectSettings, keyPath)\r\n        value = (projectValue === undefined) ? value : projectValue\r\n      }\r\n    }\r\n\r\n    let defaultValue\r\n    if (!options.sources || options.sources.length === 0) {\r\n      defaultValue = getValueAtKeyPath(this.defaultSettings, keyPath)\r\n    }\r\n\r\n    if (value != null) {\r\n      value = this.deepClone(value)\r\n      if (isPlainObject(value) && isPlainObject(defaultValue)) {\r\n        this.deepDefaults(value, defaultValue)\r\n      }\r\n      return value\r\n    } else {\r\n      return this.deepClone(defaultValue)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.deepDefaults","start_line":1104,"end_line":1120,"comment":[],"params":["target"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"deepClone","line":1016,"func_location":"Config.getRawValue","func_start_line":994,"func_end_line":1018,"args":["defaultValue"],"code":"  getRawValue (keyPath, options = {}) {\r\n    let value\r\n    if (!options.excludeSources || !options.excludeSources.includes(this.mainSource)) {\r\n      value = getValueAtKeyPath(this.settings, keyPath)\r\n      if (this.projectFile != null) {\r\n        const projectValue = getValueAtKeyPath(this.projectSettings, keyPath)\r\n        value = (projectValue === undefined) ? value : projectValue\r\n      }\r\n    }\r\n\r\n    let defaultValue\r\n    if (!options.sources || options.sources.length === 0) {\r\n      defaultValue = getValueAtKeyPath(this.defaultSettings, keyPath)\r\n    }\r\n\r\n    if (value != null) {\r\n      value = this.deepClone(value)\r\n      if (isPlainObject(value) && isPlainObject(defaultValue)) {\r\n        this.deepDefaults(value, defaultValue)\r\n      }\r\n      return value\r\n    } else {\r\n      return this.deepClone(defaultValue)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.deepClone","start_line":1092,"end_line":1102,"comment":[],"params":["object"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getRepo","line":309,"func_location":"GitRepository.getReferences","func_start_line":308,"func_end_line":310,"args":[],"comment":[" Public: Gets all the local and remote references.",""," * `path` An optional {String} path in the repository to get this information","   for, only needed if the repository has submodules.",""," Returns an {Object} with the following keys:","  * `heads`   An {Array} of head reference names.","  * `remotes` An {Array} of remote reference names.","  * `tags`    An {Array} of tag reference names."],"code":"  getReferences (path) {\r\n    return this.getRepo(path).getReferences()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getRepo","start_line":524,"end_line":530,"comment":[" Returns the corresponding {Repository}"],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getRepo","line":318,"func_location":"GitRepository.getReferenceTarget","func_start_line":317,"func_end_line":319,"args":["reference"],"comment":[" Public: Returns the current {String} SHA for the given reference.",""," * `reference` The {String} reference to get the target of."," * `path` An optional {String} path in the repo to get the reference target","   for. Only needed if the repository contains submodules."],"code":"  getReferenceTarget (reference, path) {\r\n    return this.getRepo(path).getReferenceTarget(reference)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getRepo","start_line":524,"end_line":530,"comment":[" Returns the corresponding {Repository}"],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"getVersion","line":496,"func_location":"AtomEnvironment.getReleaseChannel","func_start_line":493,"func_end_line":504,"args":[{"type":"object"}],"comment":[" Public: Gets the release channel of the Atom application.",""," Returns the release channel as a {String}. Will return a specific release channel"," name like 'beta' or 'nightly' if one is found in the Atom version or 'stable'"," otherwise."],"code":"  getReleaseChannel () {\r\n    // This matches stable, dev (with or without commit hash) and any other\r\n    // release channel following the pattern '1.00.0-channel0'\r\n    const match = this.getVersion().match(/\\d+\\.\\d+\\.\\d+(-([a-z]+)(\\d+|-\\w{4,})?)?$/)\r\n    if (!match) {\r\n      return 'unrecognized'\r\n    } else if (match[2]) {\r\n      return match[2]\r\n    }\r\n\r\n    return 'stable'\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.getVersion","start_line":483,"end_line":486,"comment":[" Public: Get the version of the Atom application.",""," Returns the version text {String}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedStartRow","line":2732,"func_location":"TextEditorComponent.getRenderedEndRow","func_start_line":2728,"func_end_line":2737,"args":[],"code":"  getRenderedEndRow () {\r\n    if (this.derivedDimensionsCache.renderedEndRow == null) {\r\n      this.derivedDimensionsCache.renderedEndRow = Math.min(\r\n        this.props.model.getApproximateScreenLineCount(),\r\n        this.getRenderedStartRow() + this.getVisibleTileCount() * this.getRowsPerTile()\r\n      )\r\n    }\r\n\r\n    return this.derivedDimensionsCache.renderedEndRow\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedStartRow","start_line":2720,"end_line":2726,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getVisibleTileCount","line":2732,"func_location":"TextEditorComponent.getRenderedEndRow","func_start_line":2728,"func_end_line":2737,"args":[],"code":"  getRenderedEndRow () {\r\n    if (this.derivedDimensionsCache.renderedEndRow == null) {\r\n      this.derivedDimensionsCache.renderedEndRow = Math.min(\r\n        this.props.model.getApproximateScreenLineCount(),\r\n        this.getRenderedStartRow() + this.getVisibleTileCount() * this.getRowsPerTile()\r\n      )\r\n    }\r\n\r\n    return this.derivedDimensionsCache.renderedEndRow\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getVisibleTileCount","start_line":2779,"end_line":2785,"comment":[" We may render more tiles than needed if some contain block decorations,"," but keeping this calculation simple ensures the number of tiles remains"," fixed for a given editor height, which eliminates situations where a"," tile is repeatedly added and removed during scrolling in certain"," combinations of editor height and line height."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRowsPerTile","line":2732,"func_location":"TextEditorComponent.getRenderedEndRow","func_start_line":2728,"func_end_line":2737,"args":[],"code":"  getRenderedEndRow () {\r\n    if (this.derivedDimensionsCache.renderedEndRow == null) {\r\n      this.derivedDimensionsCache.renderedEndRow = Math.min(\r\n        this.props.model.getApproximateScreenLineCount(),\r\n        this.getRenderedStartRow() + this.getVisibleTileCount() * this.getRowsPerTile()\r\n      )\r\n    }\r\n\r\n    return this.derivedDimensionsCache.renderedEndRow\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRowsPerTile","start_line":2712,"end_line":2714,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedEndRow","line":2741,"func_location":"TextEditorComponent.getRenderedRowCount","func_start_line":2739,"func_end_line":2745,"args":[{"type":"number"},null],"code":"  getRenderedRowCount () {\r\n    if (this.derivedDimensionsCache.renderedRowCount == null) {\r\n      this.derivedDimensionsCache.renderedRowCount = Math.max(0, this.getRenderedEndRow() - this.getRenderedStartRow())\r\n    }\r\n\r\n    return this.derivedDimensionsCache.renderedRowCount\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedEndRow","start_line":2728,"end_line":2737,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedStartRow","line":2741,"func_location":"TextEditorComponent.getRenderedRowCount","func_start_line":2739,"func_end_line":2745,"args":[{"type":"number"},null],"code":"  getRenderedRowCount () {\r\n    if (this.derivedDimensionsCache.renderedRowCount == null) {\r\n      this.derivedDimensionsCache.renderedRowCount = Math.max(0, this.getRenderedEndRow() - this.getRenderedStartRow())\r\n    }\r\n\r\n    return this.derivedDimensionsCache.renderedRowCount\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedStartRow","start_line":2720,"end_line":2726,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"tileStartRowForRow","line":2722,"func_location":"TextEditorComponent.getRenderedStartRow","func_start_line":2720,"func_end_line":2726,"args":[null],"code":"  getRenderedStartRow () {\r\n    if (this.derivedDimensionsCache.renderedStartRow == null) {\r\n      this.derivedDimensionsCache.renderedStartRow = this.tileStartRowForRow(this.getFirstVisibleRow())\r\n    }\r\n\r\n    return this.derivedDimensionsCache.renderedStartRow\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.tileStartRowForRow","start_line":2716,"end_line":2718,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getFirstVisibleRow","line":2722,"func_location":"TextEditorComponent.getRenderedStartRow","func_start_line":2720,"func_end_line":2726,"args":[null],"code":"  getRenderedStartRow () {\r\n    if (this.derivedDimensionsCache.renderedStartRow == null) {\r\n      this.derivedDimensionsCache.renderedStartRow = this.tileStartRowForRow(this.getFirstVisibleRow())\r\n    }\r\n\r\n    return this.derivedDimensionsCache.renderedStartRow\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getFirstVisibleRow","start_line":2755,"end_line":2761,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedRowCount","line":2749,"func_location":"TextEditorComponent.getRenderedTileCount","func_start_line":2747,"func_end_line":2753,"args":[null],"code":"  getRenderedTileCount () {\r\n    if (this.derivedDimensionsCache.renderedTileCount == null) {\r\n      this.derivedDimensionsCache.renderedTileCount = Math.ceil(this.getRenderedRowCount() / this.getRowsPerTile())\r\n    }\r\n\r\n    return this.derivedDimensionsCache.renderedTileCount\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedRowCount","start_line":2739,"end_line":2745,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRowsPerTile","line":2749,"func_location":"TextEditorComponent.getRenderedTileCount","func_start_line":2747,"func_end_line":2753,"args":[null],"code":"  getRenderedTileCount () {\r\n    if (this.derivedDimensionsCache.renderedTileCount == null) {\r\n      this.derivedDimensionsCache.renderedTileCount = Math.ceil(this.getRenderedRowCount() / this.getRowsPerTile())\r\n    }\r\n\r\n    return this.derivedDimensionsCache.renderedTileCount\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRowsPerTile","start_line":2712,"end_line":2714,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getPanels","line":1691,"func_location":"Workspace.getRightPanels","func_start_line":1690,"func_end_line":1692,"args":[{"type":"string"}],"comment":[" Essential: Get an {Array} of all the panel items to the right of the editor window."],"code":"  getRightPanels () {\r\n    return this.getPanels('right')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getPanels","start_line":1812,"end_line":1814,"comment":[],"params":["location"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferPosition","line":198,"func_location":"Cursor.getScopeDescriptor","func_start_line":197,"func_end_line":199,"args":[null],"comment":[" Public: Retrieves the scope descriptor for the cursor's current position.",""," Returns a {ScopeDescriptor}"],"code":"  getScopeDescriptor () {\r\n    return this.editor.scopeDescriptorForBufferPosition(this.getBufferPosition())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferPosition","start_line":91,"end_line":93,"comment":[" Public: Returns the current buffer position as an Array."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getScreenPosition","line":102,"func_location":"Cursor.getScreenColumn","func_start_line":101,"func_end_line":103,"args":[],"comment":[" Public: Returns the cursor's current screen column."],"code":"  getScreenColumn () {\r\n    return this.getScreenPosition().column\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getScreenPosition","start_line":73,"end_line":75,"comment":[" Public: Returns the screen position of the cursor as a {Point}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getScreenPosition","line":731,"func_location":"Cursor.getScreenRange","func_start_line":730,"func_end_line":733,"args":[],"code":"  getScreenRange () {\r\n    const {row, column} = this.getScreenPosition()\r\n    return new Range(new Point(row, column), new Point(row, column + 1))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getScreenPosition","start_line":73,"end_line":75,"comment":[" Public: Returns the screen position of the cursor as a {Point}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getScreenPosition","line":97,"func_location":"Cursor.getScreenRow","func_start_line":96,"func_end_line":98,"args":[],"comment":[" Public: Returns the cursor's current screen row."],"code":"  getScreenRow () {\r\n    return this.getScreenPosition().row\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getScreenPosition","start_line":73,"end_line":75,"comment":[" Public: Returns the screen position of the cursor as a {Point}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollTop","line":2816,"func_location":"TextEditorComponent.getScrollBottom","func_start_line":2815,"func_end_line":2817,"args":[],"code":"  getScrollBottom () {\r\n    return this.getScrollTop() + this.getScrollContainerClientHeight()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollTop","start_line":2791,"end_line":2794,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollContainerClientHeight","line":2816,"func_location":"TextEditorComponent.getScrollBottom","func_start_line":2815,"func_end_line":2817,"args":[],"code":"  getScrollBottom () {\r\n    return this.getScrollTop() + this.getScrollContainerClientHeight()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollContainerClientHeight","start_line":2640,"end_line":2642,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":179,"func_location":"TextEditorElement.getScrollBottom","func_start_line":178,"func_end_line":180,"args":[],"code":"  getScrollBottom () {\r\n    return this.getComponent().getScrollBottom()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollContainerHeight","line":2641,"func_location":"TextEditorComponent.getScrollContainerClientHeight","func_start_line":2640,"func_end_line":2642,"args":[],"code":"  getScrollContainerClientHeight () {\r\n    return this.getScrollContainerHeight() - this.getHorizontalScrollbarHeight()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollContainerHeight","start_line":2628,"end_line":2634,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getHorizontalScrollbarHeight","line":2641,"func_location":"TextEditorComponent.getScrollContainerClientHeight","func_start_line":2640,"func_end_line":2642,"args":[],"code":"  getScrollContainerClientHeight () {\r\n    return this.getScrollContainerHeight() - this.getHorizontalScrollbarHeight()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getHorizontalScrollbarHeight","start_line":2708,"end_line":2710,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollContainerWidth","line":2637,"func_location":"TextEditorComponent.getScrollContainerClientWidth","func_start_line":2636,"func_end_line":2638,"args":[],"code":"  getScrollContainerClientWidth () {\r\n    return this.getScrollContainerWidth() - this.getVerticalScrollbarWidth()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollContainerWidth","start_line":2620,"end_line":2626,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getVerticalScrollbarWidth","line":2637,"func_location":"TextEditorComponent.getScrollContainerClientWidth","func_start_line":2636,"func_end_line":2638,"args":[],"code":"  getScrollContainerClientWidth () {\r\n    return this.getScrollContainerWidth() - this.getVerticalScrollbarWidth()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getVerticalScrollbarWidth","start_line":2704,"end_line":2706,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollContainerClientWidth","line":2693,"func_location":"TextEditorComponent.getScrollContainerClientWidthInBaseCharacters","func_start_line":2692,"func_end_line":2694,"args":[null],"code":"  getScrollContainerClientWidthInBaseCharacters () {\r\n    return Math.floor(this.getScrollContainerClientWidth() / this.getBaseCharacterWidth())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollContainerClientWidth","start_line":2636,"end_line":2638,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getBaseCharacterWidth","line":2693,"func_location":"TextEditorComponent.getScrollContainerClientWidthInBaseCharacters","func_start_line":2692,"func_end_line":2694,"args":[null],"code":"  getScrollContainerClientWidthInBaseCharacters () {\r\n    return Math.floor(this.getScrollContainerClientWidth() / this.getBaseCharacterWidth())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getBaseCharacterWidth","start_line":2604,"end_line":2606,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollHeight","line":2630,"func_location":"TextEditorComponent.getScrollContainerHeight","func_start_line":2628,"func_end_line":2634,"args":[],"code":"  getScrollContainerHeight () {\r\n    if (this.props.model.getAutoHeight()) {\r\n      return this.getScrollHeight() + this.getHorizontalScrollbarHeight()\r\n    } else {\r\n      return this.getClientContainerHeight()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollHeight","start_line":2659,"end_line":2670,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getHorizontalScrollbarHeight","line":2630,"func_location":"TextEditorComponent.getScrollContainerHeight","func_start_line":2628,"func_end_line":2634,"args":[],"code":"  getScrollContainerHeight () {\r\n    if (this.props.model.getAutoHeight()) {\r\n      return this.getScrollHeight() + this.getHorizontalScrollbarHeight()\r\n    } else {\r\n      return this.getClientContainerHeight()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getHorizontalScrollbarHeight","start_line":2708,"end_line":2710,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getClientContainerHeight","line":2632,"func_location":"TextEditorComponent.getScrollContainerHeight","func_start_line":2628,"func_end_line":2634,"args":[],"code":"  getScrollContainerHeight () {\r\n    if (this.props.model.getAutoHeight()) {\r\n      return this.getScrollHeight() + this.getHorizontalScrollbarHeight()\r\n    } else {\r\n      return this.getClientContainerHeight()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getClientContainerHeight","start_line":2612,"end_line":2614,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollWidth","line":2622,"func_location":"TextEditorComponent.getScrollContainerWidth","func_start_line":2620,"func_end_line":2626,"args":[],"code":"  getScrollContainerWidth () {\r\n    if (this.props.model.getAutoWidth()) {\r\n      return this.getScrollWidth()\r\n    } else {\r\n      return this.getClientContainerWidth() - this.getGutterContainerWidth()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollWidth","start_line":2672,"end_line":2682,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getClientContainerWidth","line":2624,"func_location":"TextEditorComponent.getScrollContainerWidth","func_start_line":2620,"func_end_line":2626,"args":[],"code":"  getScrollContainerWidth () {\r\n    if (this.props.model.getAutoWidth()) {\r\n      return this.getScrollWidth()\r\n    } else {\r\n      return this.getClientContainerWidth() - this.getGutterContainerWidth()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getClientContainerWidth","start_line":2616,"end_line":2618,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getGutterContainerWidth","line":2624,"func_location":"TextEditorComponent.getScrollContainerWidth","func_start_line":2620,"func_end_line":2626,"args":[],"code":"  getScrollContainerWidth () {\r\n    if (this.props.model.getAutoWidth()) {\r\n      return this.getScrollWidth()\r\n    } else {\r\n      return this.getClientContainerWidth() - this.getGutterContainerWidth()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getGutterContainerWidth","start_line":2696,"end_line":2698,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getContentHeight","line":2661,"func_location":"TextEditorComponent.getScrollHeight","func_start_line":2659,"func_end_line":2670,"args":[],"code":"  getScrollHeight () {\r\n    if (this.props.model.getScrollPastEnd()) {\r\n      return this.getContentHeight() + Math.max(\r\n        3 * this.getLineHeight(),\r\n        this.getScrollContainerClientHeight() - (3 * this.getLineHeight())\r\n      )\r\n    } else if (this.props.model.getAutoHeight()) {\r\n      return this.getContentHeight()\r\n    } else {\r\n      return Math.max(this.getContentHeight(), this.getScrollContainerClientHeight())\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getContentHeight","start_line":2684,"end_line":2686,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getLineHeight","line":2662,"func_location":"TextEditorComponent.getScrollHeight","func_start_line":2659,"func_end_line":2670,"args":[],"code":"  getScrollHeight () {\r\n    if (this.props.model.getScrollPastEnd()) {\r\n      return this.getContentHeight() + Math.max(\r\n        3 * this.getLineHeight(),\r\n        this.getScrollContainerClientHeight() - (3 * this.getLineHeight())\r\n      )\r\n    } else if (this.props.model.getAutoHeight()) {\r\n      return this.getContentHeight()\r\n    } else {\r\n      return Math.max(this.getContentHeight(), this.getScrollContainerClientHeight())\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getLineHeight","start_line":2600,"end_line":2602,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollContainerClientHeight","line":2663,"func_location":"TextEditorComponent.getScrollHeight","func_start_line":2659,"func_end_line":2670,"args":[],"code":"  getScrollHeight () {\r\n    if (this.props.model.getScrollPastEnd()) {\r\n      return this.getContentHeight() + Math.max(\r\n        3 * this.getLineHeight(),\r\n        this.getScrollContainerClientHeight() - (3 * this.getLineHeight())\r\n      )\r\n    } else if (this.props.model.getAutoHeight()) {\r\n      return this.getContentHeight()\r\n    } else {\r\n      return Math.max(this.getContentHeight(), this.getScrollContainerClientHeight())\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollContainerClientHeight","start_line":2640,"end_line":2642,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getLineHeight","line":2663,"func_location":"TextEditorComponent.getScrollHeight","func_start_line":2659,"func_end_line":2670,"args":[],"code":"  getScrollHeight () {\r\n    if (this.props.model.getScrollPastEnd()) {\r\n      return this.getContentHeight() + Math.max(\r\n        3 * this.getLineHeight(),\r\n        this.getScrollContainerClientHeight() - (3 * this.getLineHeight())\r\n      )\r\n    } else if (this.props.model.getAutoHeight()) {\r\n      return this.getContentHeight()\r\n    } else {\r\n      return Math.max(this.getContentHeight(), this.getScrollContainerClientHeight())\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getLineHeight","start_line":2600,"end_line":2602,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getContentHeight","line":2666,"func_location":"TextEditorComponent.getScrollHeight","func_start_line":2659,"func_end_line":2670,"args":[],"code":"  getScrollHeight () {\r\n    if (this.props.model.getScrollPastEnd()) {\r\n      return this.getContentHeight() + Math.max(\r\n        3 * this.getLineHeight(),\r\n        this.getScrollContainerClientHeight() - (3 * this.getLineHeight())\r\n      )\r\n    } else if (this.props.model.getAutoHeight()) {\r\n      return this.getContentHeight()\r\n    } else {\r\n      return Math.max(this.getContentHeight(), this.getScrollContainerClientHeight())\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getContentHeight","start_line":2684,"end_line":2686,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getContentHeight","line":2668,"func_location":"TextEditorComponent.getScrollHeight","func_start_line":2659,"func_end_line":2670,"args":[null,null],"code":"  getScrollHeight () {\r\n    if (this.props.model.getScrollPastEnd()) {\r\n      return this.getContentHeight() + Math.max(\r\n        3 * this.getLineHeight(),\r\n        this.getScrollContainerClientHeight() - (3 * this.getLineHeight())\r\n      )\r\n    } else if (this.props.model.getAutoHeight()) {\r\n      return this.getContentHeight()\r\n    } else {\r\n      return Math.max(this.getContentHeight(), this.getScrollContainerClientHeight())\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getContentHeight","start_line":2684,"end_line":2686,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollContainerClientHeight","line":2668,"func_location":"TextEditorComponent.getScrollHeight","func_start_line":2659,"func_end_line":2670,"args":[null,null],"code":"  getScrollHeight () {\r\n    if (this.props.model.getScrollPastEnd()) {\r\n      return this.getContentHeight() + Math.max(\r\n        3 * this.getLineHeight(),\r\n        this.getScrollContainerClientHeight() - (3 * this.getLineHeight())\r\n      )\r\n    } else if (this.props.model.getAutoHeight()) {\r\n      return this.getContentHeight()\r\n    } else {\r\n      return Math.max(this.getContentHeight(), this.getScrollContainerClientHeight())\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollContainerClientHeight","start_line":2640,"end_line":2642,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":153,"func_location":"TextEditorElement.getScrollHeight","func_start_line":152,"func_end_line":154,"args":[],"code":"  getScrollHeight () {\r\n    return this.getComponent().getScrollHeight()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":187,"func_location":"TextEditorElement.getScrollLeft","func_start_line":186,"func_end_line":188,"args":[],"code":"  getScrollLeft () {\r\n    return this.getComponent().getScrollLeft()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getLongestLineWidth","line":2888,"func_location":"TextEditorComponent.getScrollLeftColumn","func_start_line":2887,"func_end_line":2893,"args":[],"code":"  getScrollLeftColumn () {\r\n    if (this.hasInitialMeasurements && this.getLongestLineWidth() != null) {\r\n      return Math.round(this.getScrollLeft() / this.getBaseCharacterWidth())\r\n    } else {\r\n      return this.pendingScrollLeftColumn || 0\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getLongestLineWidth","start_line":2608,"end_line":2610,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollLeft","line":2889,"func_location":"TextEditorComponent.getScrollLeftColumn","func_start_line":2887,"func_end_line":2893,"args":[null],"code":"  getScrollLeftColumn () {\r\n    if (this.hasInitialMeasurements && this.getLongestLineWidth() != null) {\r\n      return Math.round(this.getScrollLeft() / this.getBaseCharacterWidth())\r\n    } else {\r\n      return this.pendingScrollLeftColumn || 0\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollLeft","start_line":2823,"end_line":2825,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getBaseCharacterWidth","line":2889,"func_location":"TextEditorComponent.getScrollLeftColumn","func_start_line":2887,"func_end_line":2893,"args":[null],"code":"  getScrollLeftColumn () {\r\n    if (this.hasInitialMeasurements && this.getLongestLineWidth() != null) {\r\n      return Math.round(this.getScrollLeft() / this.getBaseCharacterWidth())\r\n    } else {\r\n      return this.pendingScrollLeftColumn || 0\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getBaseCharacterWidth","start_line":2604,"end_line":2606,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollLeft","line":2846,"func_location":"TextEditorComponent.getScrollRight","func_start_line":2845,"func_end_line":2847,"args":[],"code":"  getScrollRight () {\r\n    return this.getScrollLeft() + this.getScrollContainerClientWidth()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollLeft","start_line":2823,"end_line":2825,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollContainerClientWidth","line":2846,"func_location":"TextEditorComponent.getScrollRight","func_start_line":2845,"func_end_line":2847,"args":[],"code":"  getScrollRight () {\r\n    return this.getScrollLeft() + this.getScrollContainerClientWidth()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollContainerClientWidth","start_line":2636,"end_line":2638,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":197,"func_location":"TextEditorElement.getScrollRight","func_start_line":196,"func_end_line":198,"args":[],"code":"  getScrollRight () {\r\n    return this.getComponent().getScrollRight()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getMaxScrollTop","line":2792,"func_location":"TextEditorComponent.getScrollTop","func_start_line":2791,"func_end_line":2794,"args":[null,".scrollTop"],"code":"  getScrollTop () {\r\n    this.scrollTop = Math.min(this.getMaxScrollTop(), this.scrollTop)\r\n    return this.scrollTop\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getMaxScrollTop","start_line":2811,"end_line":2813,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":169,"func_location":"TextEditorElement.getScrollTop","func_start_line":168,"func_end_line":170,"args":[],"code":"  getScrollTop () {\r\n    return this.getComponent().getScrollTop()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"rowForPixelPosition","line":2868,"func_location":"TextEditorComponent.getScrollTopRow","func_start_line":2866,"func_end_line":2872,"args":[null],"code":"  getScrollTopRow () {\r\n    if (this.hasInitialMeasurements) {\r\n      return this.rowForPixelPosition(this.getScrollTop())\r\n    } else {\r\n      return this.pendingScrollTopRow || 0\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.rowForPixelPosition","start_line":2346,"end_line":2348,"comment":[],"params":["pixelPosition"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollTop","line":2868,"func_location":"TextEditorComponent.getScrollTopRow","func_start_line":2866,"func_end_line":2872,"args":[null],"code":"  getScrollTopRow () {\r\n    if (this.hasInitialMeasurements) {\r\n      return this.rowForPixelPosition(this.getScrollTop())\r\n    } else {\r\n      return this.pendingScrollTopRow || 0\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollTop","start_line":2791,"end_line":2794,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollContainerClientWidth","line":2676,"func_location":"TextEditorComponent.getScrollWidth","func_start_line":2672,"func_end_line":2682,"args":[],"code":"  getScrollWidth () {\r\n    const {model} = this.props\r\n\r\n    if (model.isSoftWrapped()) {\r\n      return this.getScrollContainerClientWidth()\r\n    } else if (model.getAutoWidth()) {\r\n      return this.getContentWidth()\r\n    } else {\r\n      return Math.max(this.getContentWidth(), this.getScrollContainerClientWidth())\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollContainerClientWidth","start_line":2636,"end_line":2638,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getContentWidth","line":2678,"func_location":"TextEditorComponent.getScrollWidth","func_start_line":2672,"func_end_line":2682,"args":[],"code":"  getScrollWidth () {\r\n    const {model} = this.props\r\n\r\n    if (model.isSoftWrapped()) {\r\n      return this.getScrollContainerClientWidth()\r\n    } else if (model.getAutoWidth()) {\r\n      return this.getContentWidth()\r\n    } else {\r\n      return Math.max(this.getContentWidth(), this.getScrollContainerClientWidth())\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getContentWidth","start_line":2688,"end_line":2690,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getContentWidth","line":2680,"func_location":"TextEditorComponent.getScrollWidth","func_start_line":2672,"func_end_line":2682,"args":[null,null],"code":"  getScrollWidth () {\r\n    const {model} = this.props\r\n\r\n    if (model.isSoftWrapped()) {\r\n      return this.getScrollContainerClientWidth()\r\n    } else if (model.getAutoWidth()) {\r\n      return this.getContentWidth()\r\n    } else {\r\n      return Math.max(this.getContentWidth(), this.getScrollContainerClientWidth())\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getContentWidth","start_line":2688,"end_line":2690,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollContainerClientWidth","line":2680,"func_location":"TextEditorComponent.getScrollWidth","func_start_line":2672,"func_end_line":2682,"args":[null,null],"code":"  getScrollWidth () {\r\n    const {model} = this.props\r\n\r\n    if (model.isSoftWrapped()) {\r\n      return this.getScrollContainerClientWidth()\r\n    } else if (model.getAutoWidth()) {\r\n      return this.getContentWidth()\r\n    } else {\r\n      return Math.max(this.getContentWidth(), this.getScrollContainerClientWidth())\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollContainerClientWidth","start_line":2636,"end_line":2638,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":157,"func_location":"TextEditorElement.getScrollWidth","func_start_line":156,"func_end_line":158,"args":[],"code":"  getScrollWidth () {\r\n    return this.getComponent().getScrollWidth()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getRepo","line":228,"func_location":"GitRepository.getShortHead","func_start_line":227,"func_end_line":229,"args":[],"comment":[" Public: Retrieves a shortened version of the HEAD reference value.",""," This removes the leading segments of `refs/heads`, `refs/tags`, or"," `refs/remotes`.  It also shortens the SHA-1 of a detached `HEAD` to 7"," characters.",""," * `path` An optional {String} path in the repository to get this information","   for, only needed if the repository contains submodules.",""," Returns a {String}."],"code":"  getShortHead (path) {\r\n    return this.getRepo(path).getShortHead()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getRepo","start_line":524,"end_line":530,"comment":[" Returns the corresponding {Repository}"],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"getWidthOrHeight","line":740,"func_location":"DockResizeHandle.getSize","func_start_line":738,"func_end_line":743,"args":[],"code":"  getSize () {\r\n    if (!this.size) {\r\n      this.size = this.element.getBoundingClientRect()[getWidthOrHeight(this.props.location)]\r\n    }\r\n    return this.size\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"getWidthOrHeight","start_line":821,"end_line":823,"comment":[],"params":["location"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"getStylesheetsPath","line":551,"func_location":"Package.getStylesheetPaths","func_start_line":543,"func_end_line":562,"args":[],"code":"  getStylesheetPaths () {\r\n    if (this.bundledPackage &&\r\n        this.packageManager.packagesCache[this.name] &&\r\n        this.packageManager.packagesCache[this.name].styleSheetPaths) {\r\n      const {styleSheetPaths} = this.packageManager.packagesCache[this.name]\r\n      return styleSheetPaths.map(styleSheetPath => path.join(this.path, styleSheetPath))\r\n    } else {\r\n      let indexStylesheet\r\n      const stylesheetDirPath = this.getStylesheetsPath()\r\n      if (this.metadata.mainStyleSheet) {\r\n        return [fs.resolve(this.path, this.metadata.mainStyleSheet)]\r\n      } else if (this.metadata.styleSheets) {\r\n        return this.metadata.styleSheets.map(name => fs.resolve(stylesheetDirPath, name, ['css', 'less', '']))\r\n      } else if ((indexStylesheet = fs.resolve(this.path, 'index', ['css', 'less']))) {\r\n        return [indexStylesheet]\r\n      } else {\r\n        return fs.listSync(stylesheetDirPath, ['css', 'less'])\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.getStylesheetsPath","start_line":539,"end_line":541,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"_forEachTreeWithRange","line":394,"func_location":"TreeSitterLanguageMode.getSyntaxNodeAndGrammarContainingRange","func_start_line":387,"func_end_line":409},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"TreeSitterLanguageMode._forEachTreeWithRange","start_line":303,"end_line":316,"comment":[],"params":["range","callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"getSyntaxNodeContainingRange","line":417,"func_location":"TreeSitterLanguageMode.getSyntaxNodeAtPosition","func_start_line":416,"func_end_line":418,"args":[null,"where"],"code":"  getSyntaxNodeAtPosition (position, where) {\r\n    return this.getSyntaxNodeContainingRange(new Range(position, position), where)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"TreeSitterLanguageMode.getSyntaxNodeContainingRange","start_line":383,"end_line":385,"comment":["\r\n  Section - Syntax Tree APIs\r\n  "],"params":["range","where"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"getSyntaxNodeAndGrammarContainingRange","line":384,"func_location":"TreeSitterLanguageMode.getSyntaxNodeContainingRange","func_start_line":383,"func_end_line":385,"args":["range","where"],"comment":["\r\n  Section - Syntax Tree APIs\r\n  "],"code":"  getSyntaxNodeContainingRange (range, where = _ => true) {\r\n    return this.getSyntaxNodeAndGrammarContainingRange(range, where).node\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"TreeSitterLanguageMode.getSyntaxNodeAndGrammarContainingRange","start_line":387,"end_line":409,"comment":[],"params":["range","where"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferPosition","line":205,"func_location":"Cursor.getSyntaxTreeScopeDescriptor","func_start_line":204,"func_end_line":206,"args":[null],"comment":[" Public: Retrieves the syntax tree scope descriptor for the cursor's current position.",""," Returns a {ScopeDescriptor}"],"code":"  getSyntaxTreeScopeDescriptor () {\r\n    return this.editor.syntaxTreeScopeDescriptorForBufferPosition(this.getBufferPosition())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferPosition","start_line":91,"end_line":93,"comment":[" Public: Returns the current buffer position as an Array."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"getBufferRange","line":158,"func_location":"Selection.getText","func_start_line":157,"func_end_line":159,"args":[null],"comment":[" Public: Returns the text in the selection."],"code":"  getText () {\r\n    return this.editor.buffer.getTextInRange(this.getBufferRange())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.getBufferRange","start_line":79,"end_line":81,"comment":[" Public: Returns the buffer {Range} for the selection."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js","name":"getPaneItems","line":271,"func_location":"WorkspaceCenter.getTextEditors","func_start_line":270,"func_end_line":272,"args":[null],"comment":[" Essential: Get all text editors in the workspace center.",""," Returns an {Array} of {TextEditor}s."],"code":"  getTextEditors () {\r\n    return this.getPaneItems().filter(item => item instanceof TextEditor)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js","name":"WorkspaceCenter.getPaneItems","start_line":256,"end_line":258,"comment":["\r\n  Section: Pane Items\r\n  "," Essential: Get all pane items in the workspace center.",""," Returns an {Array} of items."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getPaneItems","line":1365,"func_location":"Workspace.getTextEditors","func_start_line":1364,"func_end_line":1366,"args":[null],"comment":[" Essential: Get all text editors in the workspace.",""," Returns an {Array} of {TextEditor}s."],"code":"  getTextEditors () {\r\n    return this.getPaneItems().filter(item => item instanceof TextEditor)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getPaneItems","start_line":1350,"end_line":1352,"comment":["\r\n  Section: Pane Items\r\n  "," Essential: Get all pane items in the workspace.",""," Returns an {Array} of items."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"getFileName","line":1091,"func_location":"TextEditor.getTitle","func_start_line":1090,"func_end_line":1092,"args":[],"comment":["\r\n  Section: File Details\r\n  "," Essential: Get the editor's title for display in other parts of the"," UI such as the tabs.",""," If the editor's buffer is saved, its title is the file name. If it is"," unsaved, its title is \"untitled\".",""," Returns a {String}."],"code":"  getTitle () {\r\n    return this.getFileName() || 'untitled'\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.getFileName","start_line":1140,"end_line":1143,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getPanels","line":1712,"func_location":"Workspace.getTopPanels","func_start_line":1711,"func_end_line":1713,"args":[{"type":"string"}],"comment":[" Essential: Get an {Array} of all the panel items at the top of the editor window."],"code":"  getTopPanels () {\r\n    return this.getPanels('top')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getPanels","start_line":1812,"end_line":1814,"comment":[],"params":["location"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js","name":"getTranspilerPath","line":169,"func_location":"PackageTranspilationRegistry.getTranspiler","func_start_line":168,"func_end_line":175,"args":["spec"],"code":"  getTranspiler (spec) {\r\n    const transpilerPath = this.getTranspilerPath(spec)\r\n    if (transpilerPath) {\r\n      const transpiler = require(transpilerPath)\r\n      this.transpilerPaths[transpilerPath] = true\r\n      return transpiler\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js","name":"PackageTranspilationRegistry.getTranspilerPath","start_line":160,"end_line":166,"comment":[],"params":["spec"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getRepo","line":296,"func_location":"GitRepository.getUpstreamBranch","func_start_line":295,"func_end_line":297,"args":[],"comment":[" Public: Returns the upstream branch for the current HEAD, or null if there"," is no upstream branch for the current HEAD.",""," * `path` An optional {String} path in the repo to get this information for,","   only needed if the repository contains submodules.",""," Returns a {String} branch name such as `refs/remotes/origin/master`."],"code":"  getUpstreamBranch (path) {\r\n    return this.getRepo(path).getUpstreamBranch()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getRepo","start_line":524,"end_line":530,"comment":[" Returns the corresponding {Repository}"],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"getConfigDirPath","line":1294,"func_location":"AtomEnvironment.getUserInitScriptPath","func_start_line":1293,"func_end_line":1296,"args":[null,{"type":"string"},null],"code":"  getUserInitScriptPath () {\r\n    const initScriptPath = fs.resolve(this.getConfigDirPath(), 'init', ['js', 'coffee'])\r\n    return initScriptPath || path.join(this.getConfigDirPath(), 'init.coffee')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.getConfigDirPath","start_line":1288,"end_line":1291,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"getConfigDirPath","line":1295,"func_location":"AtomEnvironment.getUserInitScriptPath","func_start_line":1293,"func_end_line":1296,"args":[null,{"type":"string"}],"code":"  getUserInitScriptPath () {\r\n    const initScriptPath = fs.resolve(this.getConfigDirPath(), 'init', ['js', 'coffee'])\r\n    return initScriptPath || path.join(this.getConfigDirPath(), 'init.coffee')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.getConfigDirPath","start_line":1288,"end_line":1291,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"getLoadSettings","line":484,"func_location":"AtomEnvironment.getVersion","func_start_line":483,"func_end_line":486,"args":[],"comment":[" Public: Get the version of the Atom application.",""," Returns the version text {String}."],"code":"  getVersion () {\r\n    if (this.appVersion == null) this.appVersion = this.getLoadSettings().appVersion\r\n    return this.appVersion\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.getLoadSettings","start_line":525,"end_line":527,"comment":[" Public: Get the load settings for the current window.",""," Returns an {Object} containing all the load setting key/value pairs."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollContainerClientHeight","line":2099,"func_location":"TextEditorComponent.getVerticalAutoscrollMargin","func_start_line":2097,"func_end_line":2106,"args":[],"code":"  getVerticalAutoscrollMargin () {\r\n    const maxMarginInLines = Math.floor(\r\n      (this.getScrollContainerClientHeight() / this.getLineHeight() - 1) / 2\r\n    )\r\n    const marginInLines = Math.min(\r\n      this.props.model.verticalScrollMargin,\r\n      maxMarginInLines\r\n    )\r\n    return marginInLines * this.getLineHeight()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollContainerClientHeight","start_line":2640,"end_line":2642,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getLineHeight","line":2099,"func_location":"TextEditorComponent.getVerticalAutoscrollMargin","func_start_line":2097,"func_end_line":2106,"args":[],"code":"  getVerticalAutoscrollMargin () {\r\n    const maxMarginInLines = Math.floor(\r\n      (this.getScrollContainerClientHeight() / this.getLineHeight() - 1) / 2\r\n    )\r\n    const marginInLines = Math.min(\r\n      this.props.model.verticalScrollMargin,\r\n      maxMarginInLines\r\n    )\r\n    return marginInLines * this.getLineHeight()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getLineHeight","start_line":2600,"end_line":2602,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getLineHeight","line":2105,"func_location":"TextEditorComponent.getVerticalAutoscrollMargin","func_start_line":2097,"func_end_line":2106,"args":[],"code":"  getVerticalAutoscrollMargin () {\r\n    const maxMarginInLines = Math.floor(\r\n      (this.getScrollContainerClientHeight() / this.getLineHeight() - 1) / 2\r\n    )\r\n    const marginInLines = Math.min(\r\n      this.props.model.verticalScrollMargin,\r\n      maxMarginInLines\r\n    )\r\n    return marginInLines * this.getLineHeight()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getLineHeight","start_line":2600,"end_line":2602,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":161,"func_location":"TextEditorElement.getVerticalScrollbarWidth","func_start_line":160,"func_end_line":162,"args":[],"code":"  getVerticalScrollbarWidth () {\r\n    return this.getComponent().getVerticalScrollbarWidth()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/view-registry.js","name":"createView","line":127,"func_location":"ViewRegistry.getView","func_start_line":122,"func_end_line":131,"args":["object"],"comment":[" Essential: Get the view associated with an object in the workspace.",""," If you're just *using* the workspace, you shouldn't need to access the view"," layer, but view layer access may be necessary if you want to perform DOM"," manipulation that isn't supported via the model API.",""," ## View Resolution Algorithm",""," The view associated with the object is resolved using the following"," sequence","","  1. Is the object an instance of `HTMLElement`? If true, return the object.","  2. Does the object have a method named `getElement` that returns an","     instance of `HTMLElement`? If true, return that value.","  3. Does the object have a property named `element` with a value which is","     an instance of `HTMLElement`? If true, return the property value.","  4. Is the object a jQuery object, indicated by the presence of a `jquery`","     property? If true, return the root DOM element (i.e. `object[0]`).","  5. Has a view provider been registered for the object? If true, use the","     provider to create a view associated with the object, and return the","     view.",""," If no associated view is returned by the sequence an error is thrown.",""," Returns a DOM element."],"code":"  getView (object) {\r\n    if (object == null) { return }\r\n\r\n    let view = this.views.get(object)\r\n    if (!view) {\r\n      view = this.createView(object)\r\n      this.views.set(object, view)\r\n    }\r\n    return view\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/view-registry.js","name":"ViewRegistry.createView","start_line":133,"end_line":185,"comment":[],"params":["object"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getCenter","line":1628,"func_location":"Workspace.getVisiblePaneContainers","func_start_line":1627,"func_end_line":1631,"args":[],"code":"  getVisiblePaneContainers () {\r\n    const center = this.getCenter()\r\n    return atom.workspace.getPaneContainers()\r\n      .filter(container => container === center || container.isVisible())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getCenter","start_line":1599,"end_line":1601,"comment":["\r\n  Section: Pane Locations\r\n  "," Essential: Get the {WorkspaceCenter} at the center of the editor window."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getVisiblePaneContainers","line":1436,"func_location":"Workspace.getVisiblePanes","func_start_line":1435,"func_end_line":1437,"args":[null],"code":"  getVisiblePanes () {\r\n    return _.flatten(this.getVisiblePaneContainers().map(container => container.getPanes()))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getVisiblePaneContainers","start_line":1627,"end_line":1631,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getModel","line":323,"func_location":"TextEditorElement.getVisibleRowRange","func_start_line":322,"func_end_line":324,"args":[],"code":"  getVisibleRowRange () {\r\n    return this.getModel().getVisibleRowRange()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getModel","start_line":80,"end_line":82,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollContainerHeight","line":2781,"func_location":"TextEditorComponent.getVisibleTileCount","func_start_line":2779,"func_end_line":2785,"args":[],"comment":[" We may render more tiles than needed if some contain block decorations,"," but keeping this calculation simple ensures the number of tiles remains"," fixed for a given editor height, which eliminates situations where a"," tile is repeatedly added and removed during scrolling in certain"," combinations of editor height and line height."],"code":"  getVisibleTileCount () {\r\n    if (this.derivedDimensionsCache.visibleTileCount == null) {\r\n      const editorHeightInTiles = this.getScrollContainerHeight() / this.getLineHeight() / this.getRowsPerTile()\r\n      this.derivedDimensionsCache.visibleTileCount = Math.ceil(editorHeightInTiles) + 1\r\n    }\r\n    return this.derivedDimensionsCache.visibleTileCount\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollContainerHeight","start_line":2628,"end_line":2634,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getLineHeight","line":2781,"func_location":"TextEditorComponent.getVisibleTileCount","func_start_line":2779,"func_end_line":2785,"args":[],"comment":[" We may render more tiles than needed if some contain block decorations,"," but keeping this calculation simple ensures the number of tiles remains"," fixed for a given editor height, which eliminates situations where a"," tile is repeatedly added and removed during scrolling in certain"," combinations of editor height and line height."],"code":"  getVisibleTileCount () {\r\n    if (this.derivedDimensionsCache.visibleTileCount == null) {\r\n      const editorHeightInTiles = this.getScrollContainerHeight() / this.getLineHeight() / this.getRowsPerTile()\r\n      this.derivedDimensionsCache.visibleTileCount = Math.ceil(editorHeightInTiles) + 1\r\n    }\r\n    return this.derivedDimensionsCache.visibleTileCount\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getLineHeight","start_line":2600,"end_line":2602,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRowsPerTile","line":2781,"func_location":"TextEditorComponent.getVisibleTileCount","func_start_line":2779,"func_end_line":2785,"args":[],"comment":[" We may render more tiles than needed if some contain block decorations,"," but keeping this calculation simple ensures the number of tiles remains"," fixed for a given editor height, which eliminates situations where a"," tile is repeatedly added and removed during scrolling in certain"," combinations of editor height and line height."],"code":"  getVisibleTileCount () {\r\n    if (this.derivedDimensionsCache.visibleTileCount == null) {\r\n      const editorHeightInTiles = this.getScrollContainerHeight() / this.getLineHeight() / this.getRowsPerTile()\r\n      this.derivedDimensionsCache.visibleTileCount = Math.ceil(editorHeightInTiles) + 1\r\n    }\r\n    return this.derivedDimensionsCache.visibleTileCount\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRowsPerTile","start_line":2712,"end_line":2714,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":115,"func_location":"TextEditorElement.getWidth","func_start_line":114,"func_end_line":116,"args":[],"code":"  getWidth () {\r\n    return this.getComponent().getScrollContainerWidth()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"getCurrentWindow","line":683,"func_location":"AtomEnvironment.getWindowDimensions","func_start_line":682,"func_end_line":688,"args":[],"comment":[" Get the dimensions of this window.",""," Returns an {Object} with the following keys:","   * `x`      The window's x-position {Number}.","   * `y`      The window's y-position {Number}.","   * `width`  The window's width {Number}.","   * `height` The window's height {Number}."],"code":"  getWindowDimensions () {\r\n    const browserWindow = this.getCurrentWindow()\r\n    const [x, y] = browserWindow.getPosition()\r\n    const [width, height] = browserWindow.getSize()\r\n    const maximized = browserWindow.isMaximized()\r\n    return {x, y, width, height, maximized}\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.getCurrentWindow","start_line":596,"end_line":598,"comment":[" Extended: Get the current window"],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getRepo","line":195,"func_location":"GitRepository.getWorkingDirectory","func_start_line":194,"func_end_line":196,"args":[],"comment":[" Public: Returns the {String} working directory path of the repository."],"code":"  getWorkingDirectory () {\r\n    return this.getRepo().getWorkingDirectory()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getRepo","start_line":524,"end_line":530,"comment":[" Returns the corresponding {Repository}"],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"shouldUseTreeSitterParser","line":315,"func_location":"GrammarRegistry.grammarForId","func_start_line":313,"func_end_line":326,"args":["languageId"],"code":"  grammarForId (languageId) {\r\n    if (!languageId) return null\r\n    if (this.shouldUseTreeSitterParser(languageId)) {\r\n      return (\r\n        this.treeSitterGrammarsById[languageId] ||\r\n        this.textmateRegistry.grammarForScopeName(languageId)\r\n      )\r\n    } else {\r\n      return (\r\n        this.textmateRegistry.grammarForScopeName(languageId) ||\r\n        this.treeSitterGrammarsById[languageId]\r\n      )\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.shouldUseTreeSitterParser","start_line":579,"end_line":584,"comment":[],"params":["languageId"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"grammarForId","line":453,"func_location":"GrammarRegistry.grammarForScopeName","func_start_line":452,"func_end_line":454,"args":["scopeName"],"code":"  grammarForScopeName (scopeName) {\r\n    return this.grammarForId(scopeName)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.grammarForId","start_line":313,"end_line":326,"comment":[],"params":["languageId"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"getAssignedLanguageId","line":336,"func_location":"GrammarRegistry.grammarOverrideForPath","func_start_line":333,"func_end_line":337,"args":["buffer"],"comment":[" Deprecated: Get the grammar override for the given file path.",""," * `filePath` A {String} file path.",""," Returns a {String} such as `\"source.js\"`."],"code":"  grammarOverrideForPath (filePath) {\r\n    Grim.deprecate('Use buffer.getLanguageMode().getLanguageId() instead')\r\n    const buffer = atom.project.findBufferForPath(filePath)\r\n    if (buffer) return this.getAssignedLanguageId(buffer)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.getAssignedLanguageId","start_line":149,"end_line":151,"comment":[" Extended: Get the `languageId` that has been explicitly assigned to"," to the given buffer, if any.",""," Returns a {String} id of the language"],"params":["buffer"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"checkCleanupDockHoverEvents","line":175,"func_location":"WorkspaceElement.handleCenterEnter","func_start_line":171,"func_end_line":176,"args":[],"code":"  handleCenterEnter (event) {\r\n    // Just re-entering the center isn't enough to hide the dock toggle buttons, since they poke\r\n    // into the center and we want to give an affordance.\r\n    this.cursorInCenter = true\r\n    this.checkCleanupDockHoverEvents()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.checkCleanupDockHoverEvents","start_line":204,"end_line":208,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"updateHoveredDock","line":182,"func_location":"WorkspaceElement.handleCenterLeave","func_start_line":178,"func_end_line":184,"args":[null],"code":"  handleCenterLeave (event) {\r\n    // If the cursor leaves the center, we start listening to determine whether one of the docs is\r\n    // being hovered.\r\n    this.cursorInCenter = false\r\n    this.updateHoveredDock({x: event.pageX, y: event.pageY})\r\n    window.addEventListener('dragend', this.handleDockDragEnd)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.updateHoveredDock","start_line":194,"end_line":202,"comment":[],"params":["mousePosition"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"setState","line":253,"func_location":"Dock.handleDidAddPaneItem","func_start_line":251,"func_end_line":255,"args":[null],"code":"  handleDidAddPaneItem () {\r\n    if (this.state.size == null) {\r\n      this.setState({size: this.getInitialSize()})\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.setState","start_line":144,"end_line":177,"comment":[],"params":["newState"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"getInitialSize","line":253,"func_location":"Dock.handleDidAddPaneItem","func_start_line":251,"func_end_line":255,"args":[null],"code":"  handleDidAddPaneItem () {\r\n    if (this.state.size == null) {\r\n      this.setState({size: this.getInitialSize()})\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.getInitialSize","start_line":407,"end_line":414,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"setState","line":260,"func_location":"Dock.handleDidRemovePaneItem","func_start_line":257,"func_end_line":262,"args":[null],"code":"  handleDidRemovePaneItem () {\r\n    // Hide the dock if you remove the last item.\r\n    if (this.paneContainer.getPaneItems().length === 0) {\r\n      this.setState({visible: false, hovered: false, size: null})\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.setState","start_line":144,"end_line":177,"comment":[],"params":["newState"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"updateHoveredDock","line":191,"func_location":"WorkspaceElement.handleDockDragEnd","func_start_line":190,"func_end_line":192,"args":[null],"code":"  handleDockDragEnd (event) {\r\n    this.updateHoveredDock({x: event.pageX, y: event.pageY})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.updateHoveredDock","start_line":194,"end_line":202,"comment":[],"params":["mousePosition"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"pointWithinHoverArea","line":312,"func_location":"Dock.handleDrag","func_start_line":311,"func_end_line":315,"args":[null,{"type":"boolean"}],"code":"  handleDrag (event) {\r\n    if (!this.pointWithinHoverArea({x: event.pageX, y: event.pageY}, true)) {\r\n      this.draggedOut()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.pointWithinHoverArea","start_line":333,"end_line":405,"comment":[" Determine whether the cursor is within the dock hover area. This isn't as simple as just using"," mouseenter/leave because we want to be a little more forgiving. For example, if the cursor is"," over the footer, we want to show the bottom dock's toggle button. Also note that our criteria"," for detecting entry are different than detecting exit but, in order for us to avoid jitter, the"," area considered when detecting exit MUST fully encompass the area considered when detecting"," entry."],"params":["point","detectingExit"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"draggedOut","line":313,"func_location":"Dock.handleDrag","func_start_line":311,"func_end_line":315,"args":[],"code":"  handleDrag (event) {\r\n    if (!this.pointWithinHoverArea({x: event.pageX, y: event.pageY}, true)) {\r\n      this.draggedOut()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.draggedOut","start_line":321,"end_line":325,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"dragEnded","line":158,"func_location":"WorkspaceElement.handleDragEnd","func_start_line":157,"func_end_line":159,"args":[],"code":"  handleDragEnd (event) {\r\n    this.dragEnded()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.dragEnded","start_line":165,"end_line":169,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"draggedOut","line":318,"func_location":"Dock.handleDragEnd","func_start_line":317,"func_end_line":319,"args":[],"code":"  handleDragEnd () {\r\n    this.draggedOut()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.draggedOut","start_line":321,"end_line":325,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"isTab","line":149,"func_location":"WorkspaceElement.handleDragStart","func_start_line":148,"func_end_line":155,"args":["event.target"],"code":"  handleDragStart (event) {\r\n    if (!isTab(event.target)) return\r\n    const {item} = event.target\r\n    if (!item) return\r\n    this.model.setDraggingItem(item)\r\n    window.addEventListener('dragend', this.handleDragEnd, true)\r\n    window.addEventListener('drop', this.handleDrop, true)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"isTab","start_line":351,"end_line":358,"comment":[],"params":["element"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"dragEnded","line":162,"func_location":"WorkspaceElement.handleDrop","func_start_line":161,"func_end_line":163,"args":[],"code":"  handleDrop (event) {\r\n    this.dragEnded()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.dragEnded","start_line":165,"end_line":169,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"updateHoveredDock","line":187,"func_location":"WorkspaceElement.handleEdgesMouseMove","func_start_line":186,"func_end_line":188,"args":[null],"code":"  handleEdgesMouseMove (event) {\r\n    this.updateHoveredDock({x: event.pageX, y: event.pageY})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.updateHoveredDock","start_line":194,"end_line":202,"comment":[],"params":["mousePosition"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"setupContextMenu","line":221,"func_location":"AtomWindow.handleEvents","func_start_line":167,"func_end_line":225,"args":[],"code":"  handleEvents () {\r\n    this.browserWindow.on('close', async event => {\r\n      if (!this.atomApplication.quitting && !this.unloading) {\r\n        event.preventDefault()\r\n        this.unloading = true\r\n        this.atomApplication.saveCurrentWindowOptions(false)\r\n        if (await this.prepareToUnload()) this.close()\r\n      }\r\n    })\r\n\r\n    this.browserWindow.on('closed', () => {\r\n      this.fileRecoveryService.didCloseWindow(this)\r\n      this.atomApplication.removeWindow(this)\r\n      this.resolveClosedPromise()\r\n    })\r\n\r\n    this.browserWindow.on('unresponsive', () => {\r\n      if (this.isSpec) return\r\n      dialog.showMessageBox(this.browserWindow, {\r\n        type: 'warning',\r\n        buttons: ['Force Close', 'Keep Waiting'],\r\n        cancelId: 1, // Canceling should be the least destructive action\r\n        message: 'Editor is not responding',\r\n        detail:\r\n          'The editor is not responding. Would you like to force close it or just keep waiting?'\r\n      }, response => { if (response === 0) this.browserWindow.destroy() })\r\n    })\r\n\r\n    this.browserWindow.webContents.on('crashed', async () => {\r\n      if (this.headless) {\r\n        console.log('Renderer process crashed, exiting')\r\n        this.atomApplication.exit(100)\r\n        return\r\n      }\r\n\r\n      await this.fileRecoveryService.didCrashWindow(this)\r\n      dialog.showMessageBox(this.browserWindow, {\r\n        type: 'warning',\r\n        buttons: ['Close Window', 'Reload', 'Keep It Open'],\r\n        cancelId: 2, // Canceling should be the least destructive action\r\n        message: 'The editor has crashed',\r\n        detail: 'Please report this issue to https://github.com/atom/atom'\r\n      }, response => {\r\n        switch (response) {\r\n          case 0: return this.browserWindow.destroy()\r\n          case 1: return this.browserWindow.reload()\r\n        }\r\n      })\r\n    })\r\n\r\n    this.browserWindow.webContents.on('will-navigate', (event, url) => {\r\n      if (url !== this.browserWindow.webContents.getURL()) event.preventDefault()\r\n    })\r\n\r\n    this.setupContextMenu()\r\n\r\n    // Spec window's web view should always have focus\r\n    if (this.isSpec) this.browserWindow.on('blur', () => this.browserWindow.focusOnWebView())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"AtomWindow.setupContextMenu","start_line":144,"end_line":150,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"bufferStream","line":269,"func_location":"BufferedProcess.handleEvents","func_start_line":252,"func_end_line":295},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"BufferedProcess.bufferStream","start_line":134,"end_line":157,"comment":["\r\n  Section: Helper Methods\r\n  "," Helper method to pass data line by line.",""," * `stream` The Stream to read from."," * `onLines` The callback to call with each line of data."," * `onDone` The callback to call when the stream has closed."],"params":["stream","onLines","onDone"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"bufferStream","line":277,"func_location":"BufferedProcess.handleEvents","func_start_line":252,"func_end_line":295},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"BufferedProcess.bufferStream","start_line":134,"end_line":157,"comment":["\r\n  Section: Helper Methods\r\n  "," Helper method to pass data line by line.",""," * `stream` The Stream to read from."," * `onLines` The callback to call with each line of data."," * `onDone` The callback to call when the stream has closed."],"params":["stream","onLines","onDone"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"openPathOnEvent","line":412,"func_location":"AtomApplication.handleEvents","func_start_line":364,"func_end_line":634,"args":[{"type":"string"},{"type":"string"}],"comment":[" Registers basic application commands, non-idempotent."],"code":"  handleEvents () {\r\n    const getLoadSettings = () => {\r\n      const window = this.focusedWindow()\r\n      return {devMode: window && window.devMode, safeMode: window && window.safeMode}\r\n    }\r\n\r\n    this.on('application:quit', () => app.quit())\r\n    this.on('application:new-window', () => this.openPath(getLoadSettings()))\r\n    this.on('application:new-file', () => (this.focusedWindow() || this).openPath())\r\n    this.on('application:open-dev', () => this.promptForPathToOpen('all', {devMode: true}))\r\n    this.on('application:open-safe', () => this.promptForPathToOpen('all', {safeMode: true}))\r\n    this.on('application:inspect', ({x, y, atomWindow}) => {\r\n      if (!atomWindow) atomWindow = this.focusedWindow()\r\n      if (atomWindow) atomWindow.browserWindow.inspectElement(x, y)\r\n    })\r\n\r\n    this.on('application:open-documentation', () => shell.openExternal('http://flight-manual.atom.io'))\r\n    this.on('application:open-discussions', () => shell.openExternal('https://discuss.atom.io'))\r\n    this.on('application:open-faq', () => shell.openExternal('https://atom.io/faq'))\r\n    this.on('application:open-terms-of-use', () => shell.openExternal('https://atom.io/terms'))\r\n    this.on('application:report-issue', () => shell.openExternal('https://github.com/atom/atom/blob/master/CONTRIBUTING.md#reporting-bugs'))\r\n    this.on('application:search-issues', () => shell.openExternal('https://github.com/search?q=+is%3Aissue+user%3Aatom'))\r\n\r\n    this.on('application:install-update', () => {\r\n      this.quitting = true\r\n      this.autoUpdateManager.install()\r\n    })\r\n\r\n    this.on('application:check-for-update', () => this.autoUpdateManager.check())\r\n\r\n    if (process.platform === 'darwin') {\r\n      this.on('application:bring-all-windows-to-front', () => Menu.sendActionToFirstResponder('arrangeInFront:'))\r\n      this.on('application:hide', () => Menu.sendActionToFirstResponder('hide:'))\r\n      this.on('application:hide-other-applications', () => Menu.sendActionToFirstResponder('hideOtherApplications:'))\r\n      this.on('application:minimize', () => Menu.sendActionToFirstResponder('performMiniaturize:'))\r\n      this.on('application:unhide-all-applications', () => Menu.sendActionToFirstResponder('unhideAllApplications:'))\r\n      this.on('application:zoom', () => Menu.sendActionToFirstResponder('zoom:'))\r\n    } else {\r\n      this.on('application:minimize', () => {\r\n        const window = this.focusedWindow()\r\n        if (window) window.minimize()\r\n      })\r\n      this.on('application:zoom', function () {\r\n        const window = this.focusedWindow()\r\n        if (window) window.maximize()\r\n      })\r\n    }\r\n\r\n    this.openPathOnEvent('application:about', 'atom://about')\r\n    this.openPathOnEvent('application:show-settings', 'atom://config')\r\n    this.openPathOnEvent('application:open-your-config', 'atom://.atom/config')\r\n    this.openPathOnEvent('application:open-your-init-script', 'atom://.atom/init-script')\r\n    this.openPathOnEvent('application:open-your-keymap', 'atom://.atom/keymap')\r\n    this.openPathOnEvent('application:open-your-snippets', 'atom://.atom/snippets')\r\n    this.openPathOnEvent('application:open-your-stylesheet', 'atom://.atom/stylesheet')\r\n    this.openPathOnEvent('application:open-license', path.join(process.resourcesPath, 'LICENSE.md'))\r\n\r\n    this.configFile.onDidChange(settings => {\r\n      for (let window of this.getAllWindows()) {\r\n        window.didChangeUserSettings(settings)\r\n      }\r\n      this.config.resetUserSettings(settings)\r\n    })\r\n\r\n    this.configFile.onDidError(message => {\r\n      const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n      if (window) window.didFailToReadUserSettings(message)\r\n    })\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'before-quit', async event => {\r\n      let resolveBeforeQuitPromise\r\n      this.lastBeforeQuitPromise = new Promise(resolve => { resolveBeforeQuitPromise = resolve })\r\n\r\n      if (!this.quitting) {\r\n        this.quitting = true\r\n        event.preventDefault()\r\n        const windowUnloadPromises = this.getAllWindows().map(async window => {\r\n          const unloaded = await window.prepareToUnload()\r\n          if (unloaded) {\r\n            window.close()\r\n            await window.closedPromise\r\n          }\r\n          return unloaded\r\n        })\r\n        const windowUnloadedResults = await Promise.all(windowUnloadPromises)\r\n        if (windowUnloadedResults.every(Boolean)) {\r\n          app.quit()\r\n        } else {\r\n          this.quitting = false\r\n        }\r\n      }\r\n\r\n      resolveBeforeQuitPromise()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'will-quit', () => {\r\n      this.killAllProcesses()\r\n      this.deleteSocketFile()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-file', (event, pathToOpen) => {\r\n      event.preventDefault()\r\n      this.openPath({pathToOpen})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-url', (event, urlToOpen) => {\r\n      event.preventDefault()\r\n      this.openUrl({urlToOpen, devMode: this.devMode, safeMode: this.safeMode})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'activate', (event, hasVisibleWindows) => {\r\n      if (hasVisibleWindows) return\r\n      if (event) event.preventDefault()\r\n      this.emit('application:new-window')\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'restart-application', () => {\r\n      this.restart()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'resolve-proxy', (event, requestId, url) => {\r\n      event.sender.session.resolveProxy(url, proxy => {\r\n        if (!event.sender.isDestroyed()) event.sender.send('did-resolve-proxy', requestId, proxy)\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-history-manager', event => {\r\n      for (let atomWindow of this.getAllWindows()) {\r\n        const {webContents} = atomWindow.browserWindow\r\n        if (webContents !== event.sender) webContents.send('did-change-history-manager')\r\n      }\r\n    }))\r\n\r\n    // A request from the associated render process to open a new render process.\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open', (event, options) => {\r\n      const window = this.atomWindowForEvent(event)\r\n      if (options) {\r\n        if (typeof options.pathsToOpen === 'string') {\r\n          options.pathsToOpen = [options.pathsToOpen]\r\n        }\r\n\r\n        if (options.pathsToOpen && options.pathsToOpen.length > 0) {\r\n          options.window = window\r\n          this.openPaths(options)\r\n        } else {\r\n          this.addWindow(new AtomWindow(this, this.fileRecoveryService, options))\r\n        }\r\n      } else {\r\n        this.promptForPathToOpen('all', {window})\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'update-application-menu', (event, template, menu) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      if (this.applicationMenu) this.applicationMenu.update(window, template, menu)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-package-specs', (event, packageSpecPath, options = {}) => {\r\n      this.runTests(Object.assign({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [packageSpecPath],\r\n        headless: false\r\n      }, options))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-benchmarks', (event, benchmarksPath) => {\r\n      this.runBenchmarks({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [benchmarksPath],\r\n        headless: false,\r\n        test: false\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'command', (event, command) => {\r\n      this.emit(command)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open-command', (event, command, defaultPath) => {\r\n      switch (command) {\r\n        case 'application:open':\r\n          return this.promptForPathToOpen('all', getLoadSettings(), defaultPath)\r\n        case 'application:open-file':\r\n          return this.promptForPathToOpen('file', getLoadSettings(), defaultPath)\r\n        case 'application:open-folder':\r\n          return this.promptForPathToOpen('folder', getLoadSettings(), defaultPath)\r\n        default:\r\n          return console.log(`Invalid open-command received: ${command}`)\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'window-command', (event, command, ...args) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      return window.emit(command, ...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('window-method', (browserWindow, method, ...args) => {\r\n      const window = this.atomWindowForBrowserWindow(browserWindow)\r\n      if (window) window[method](...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'pick-folder', (event, responseChannel) => {\r\n      this.promptForPath('folder', paths => event.sender.send(responseChannel, paths))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-size', (window, width, height) => {\r\n      window.setSize(width, height)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-position', (window, x, y) => {\r\n      window.setPosition(x, y)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-user-settings', (window, settings, filePath) => {\r\n      if (!this.quitting) {\r\n        return ConfigFile.at(filePath || this.configFilePath).update(JSON.parse(settings))\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('center-window', window => window.center()))\r\n    this.disposable.add(ipcHelpers.respondTo('focus-window', window => window.focus()))\r\n    this.disposable.add(ipcHelpers.respondTo('show-window', window => window.show()))\r\n    this.disposable.add(ipcHelpers.respondTo('hide-window', window => window.hide()))\r\n    this.disposable.add(ipcHelpers.respondTo('get-temporary-window-state', window => window.temporaryState))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-temporary-window-state', (win, state) => {\r\n      win.temporaryState = state\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-text-to-selection-clipboard', (event, text) =>\r\n      clipboard.writeText(text, 'selection')\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stdout', (event, output) =>\r\n      process.stdout.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stderr', (event, output) =>\r\n      process.stderr.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'add-recent-document', (event, filename) =>\r\n      app.addRecentDocument(filename)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'execute-javascript-in-dev-tools', (event, code) =>\r\n      event.sender.devToolsWebContents && event.sender.devToolsWebContents.executeJavaScript(code)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-state', event => {\r\n      event.returnValue = this.autoUpdateManager.getState()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-error', event => {\r\n      event.returnValue = this.autoUpdateManager.getErrorMessage()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('will-save-path', (window, path) =>\r\n      this.fileRecoveryService.willSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('did-save-path', (window, path) =>\r\n      this.fileRecoveryService.didSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-paths', () =>\r\n      this.saveCurrentWindowOptions(false)\r\n    ))\r\n\r\n    this.disposable.add(this.disableZoomOnDisplayChange())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.openPathOnEvent","start_line":720,"end_line":729,"comment":[" Public: Open the given path in the focused window when the event is"," triggered.",""," A new window will be created if there is no currently focused window.",""," eventName - The event to listen for."," pathToOpen - The path to open when the event is triggered."],"params":["eventName","pathToOpen"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"openPathOnEvent","line":413,"func_location":"AtomApplication.handleEvents","func_start_line":364,"func_end_line":634,"args":[{"type":"string"},{"type":"string"}],"comment":[" Registers basic application commands, non-idempotent."],"code":"  handleEvents () {\r\n    const getLoadSettings = () => {\r\n      const window = this.focusedWindow()\r\n      return {devMode: window && window.devMode, safeMode: window && window.safeMode}\r\n    }\r\n\r\n    this.on('application:quit', () => app.quit())\r\n    this.on('application:new-window', () => this.openPath(getLoadSettings()))\r\n    this.on('application:new-file', () => (this.focusedWindow() || this).openPath())\r\n    this.on('application:open-dev', () => this.promptForPathToOpen('all', {devMode: true}))\r\n    this.on('application:open-safe', () => this.promptForPathToOpen('all', {safeMode: true}))\r\n    this.on('application:inspect', ({x, y, atomWindow}) => {\r\n      if (!atomWindow) atomWindow = this.focusedWindow()\r\n      if (atomWindow) atomWindow.browserWindow.inspectElement(x, y)\r\n    })\r\n\r\n    this.on('application:open-documentation', () => shell.openExternal('http://flight-manual.atom.io'))\r\n    this.on('application:open-discussions', () => shell.openExternal('https://discuss.atom.io'))\r\n    this.on('application:open-faq', () => shell.openExternal('https://atom.io/faq'))\r\n    this.on('application:open-terms-of-use', () => shell.openExternal('https://atom.io/terms'))\r\n    this.on('application:report-issue', () => shell.openExternal('https://github.com/atom/atom/blob/master/CONTRIBUTING.md#reporting-bugs'))\r\n    this.on('application:search-issues', () => shell.openExternal('https://github.com/search?q=+is%3Aissue+user%3Aatom'))\r\n\r\n    this.on('application:install-update', () => {\r\n      this.quitting = true\r\n      this.autoUpdateManager.install()\r\n    })\r\n\r\n    this.on('application:check-for-update', () => this.autoUpdateManager.check())\r\n\r\n    if (process.platform === 'darwin') {\r\n      this.on('application:bring-all-windows-to-front', () => Menu.sendActionToFirstResponder('arrangeInFront:'))\r\n      this.on('application:hide', () => Menu.sendActionToFirstResponder('hide:'))\r\n      this.on('application:hide-other-applications', () => Menu.sendActionToFirstResponder('hideOtherApplications:'))\r\n      this.on('application:minimize', () => Menu.sendActionToFirstResponder('performMiniaturize:'))\r\n      this.on('application:unhide-all-applications', () => Menu.sendActionToFirstResponder('unhideAllApplications:'))\r\n      this.on('application:zoom', () => Menu.sendActionToFirstResponder('zoom:'))\r\n    } else {\r\n      this.on('application:minimize', () => {\r\n        const window = this.focusedWindow()\r\n        if (window) window.minimize()\r\n      })\r\n      this.on('application:zoom', function () {\r\n        const window = this.focusedWindow()\r\n        if (window) window.maximize()\r\n      })\r\n    }\r\n\r\n    this.openPathOnEvent('application:about', 'atom://about')\r\n    this.openPathOnEvent('application:show-settings', 'atom://config')\r\n    this.openPathOnEvent('application:open-your-config', 'atom://.atom/config')\r\n    this.openPathOnEvent('application:open-your-init-script', 'atom://.atom/init-script')\r\n    this.openPathOnEvent('application:open-your-keymap', 'atom://.atom/keymap')\r\n    this.openPathOnEvent('application:open-your-snippets', 'atom://.atom/snippets')\r\n    this.openPathOnEvent('application:open-your-stylesheet', 'atom://.atom/stylesheet')\r\n    this.openPathOnEvent('application:open-license', path.join(process.resourcesPath, 'LICENSE.md'))\r\n\r\n    this.configFile.onDidChange(settings => {\r\n      for (let window of this.getAllWindows()) {\r\n        window.didChangeUserSettings(settings)\r\n      }\r\n      this.config.resetUserSettings(settings)\r\n    })\r\n\r\n    this.configFile.onDidError(message => {\r\n      const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n      if (window) window.didFailToReadUserSettings(message)\r\n    })\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'before-quit', async event => {\r\n      let resolveBeforeQuitPromise\r\n      this.lastBeforeQuitPromise = new Promise(resolve => { resolveBeforeQuitPromise = resolve })\r\n\r\n      if (!this.quitting) {\r\n        this.quitting = true\r\n        event.preventDefault()\r\n        const windowUnloadPromises = this.getAllWindows().map(async window => {\r\n          const unloaded = await window.prepareToUnload()\r\n          if (unloaded) {\r\n            window.close()\r\n            await window.closedPromise\r\n          }\r\n          return unloaded\r\n        })\r\n        const windowUnloadedResults = await Promise.all(windowUnloadPromises)\r\n        if (windowUnloadedResults.every(Boolean)) {\r\n          app.quit()\r\n        } else {\r\n          this.quitting = false\r\n        }\r\n      }\r\n\r\n      resolveBeforeQuitPromise()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'will-quit', () => {\r\n      this.killAllProcesses()\r\n      this.deleteSocketFile()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-file', (event, pathToOpen) => {\r\n      event.preventDefault()\r\n      this.openPath({pathToOpen})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-url', (event, urlToOpen) => {\r\n      event.preventDefault()\r\n      this.openUrl({urlToOpen, devMode: this.devMode, safeMode: this.safeMode})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'activate', (event, hasVisibleWindows) => {\r\n      if (hasVisibleWindows) return\r\n      if (event) event.preventDefault()\r\n      this.emit('application:new-window')\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'restart-application', () => {\r\n      this.restart()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'resolve-proxy', (event, requestId, url) => {\r\n      event.sender.session.resolveProxy(url, proxy => {\r\n        if (!event.sender.isDestroyed()) event.sender.send('did-resolve-proxy', requestId, proxy)\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-history-manager', event => {\r\n      for (let atomWindow of this.getAllWindows()) {\r\n        const {webContents} = atomWindow.browserWindow\r\n        if (webContents !== event.sender) webContents.send('did-change-history-manager')\r\n      }\r\n    }))\r\n\r\n    // A request from the associated render process to open a new render process.\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open', (event, options) => {\r\n      const window = this.atomWindowForEvent(event)\r\n      if (options) {\r\n        if (typeof options.pathsToOpen === 'string') {\r\n          options.pathsToOpen = [options.pathsToOpen]\r\n        }\r\n\r\n        if (options.pathsToOpen && options.pathsToOpen.length > 0) {\r\n          options.window = window\r\n          this.openPaths(options)\r\n        } else {\r\n          this.addWindow(new AtomWindow(this, this.fileRecoveryService, options))\r\n        }\r\n      } else {\r\n        this.promptForPathToOpen('all', {window})\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'update-application-menu', (event, template, menu) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      if (this.applicationMenu) this.applicationMenu.update(window, template, menu)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-package-specs', (event, packageSpecPath, options = {}) => {\r\n      this.runTests(Object.assign({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [packageSpecPath],\r\n        headless: false\r\n      }, options))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-benchmarks', (event, benchmarksPath) => {\r\n      this.runBenchmarks({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [benchmarksPath],\r\n        headless: false,\r\n        test: false\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'command', (event, command) => {\r\n      this.emit(command)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open-command', (event, command, defaultPath) => {\r\n      switch (command) {\r\n        case 'application:open':\r\n          return this.promptForPathToOpen('all', getLoadSettings(), defaultPath)\r\n        case 'application:open-file':\r\n          return this.promptForPathToOpen('file', getLoadSettings(), defaultPath)\r\n        case 'application:open-folder':\r\n          return this.promptForPathToOpen('folder', getLoadSettings(), defaultPath)\r\n        default:\r\n          return console.log(`Invalid open-command received: ${command}`)\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'window-command', (event, command, ...args) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      return window.emit(command, ...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('window-method', (browserWindow, method, ...args) => {\r\n      const window = this.atomWindowForBrowserWindow(browserWindow)\r\n      if (window) window[method](...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'pick-folder', (event, responseChannel) => {\r\n      this.promptForPath('folder', paths => event.sender.send(responseChannel, paths))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-size', (window, width, height) => {\r\n      window.setSize(width, height)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-position', (window, x, y) => {\r\n      window.setPosition(x, y)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-user-settings', (window, settings, filePath) => {\r\n      if (!this.quitting) {\r\n        return ConfigFile.at(filePath || this.configFilePath).update(JSON.parse(settings))\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('center-window', window => window.center()))\r\n    this.disposable.add(ipcHelpers.respondTo('focus-window', window => window.focus()))\r\n    this.disposable.add(ipcHelpers.respondTo('show-window', window => window.show()))\r\n    this.disposable.add(ipcHelpers.respondTo('hide-window', window => window.hide()))\r\n    this.disposable.add(ipcHelpers.respondTo('get-temporary-window-state', window => window.temporaryState))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-temporary-window-state', (win, state) => {\r\n      win.temporaryState = state\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-text-to-selection-clipboard', (event, text) =>\r\n      clipboard.writeText(text, 'selection')\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stdout', (event, output) =>\r\n      process.stdout.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stderr', (event, output) =>\r\n      process.stderr.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'add-recent-document', (event, filename) =>\r\n      app.addRecentDocument(filename)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'execute-javascript-in-dev-tools', (event, code) =>\r\n      event.sender.devToolsWebContents && event.sender.devToolsWebContents.executeJavaScript(code)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-state', event => {\r\n      event.returnValue = this.autoUpdateManager.getState()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-error', event => {\r\n      event.returnValue = this.autoUpdateManager.getErrorMessage()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('will-save-path', (window, path) =>\r\n      this.fileRecoveryService.willSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('did-save-path', (window, path) =>\r\n      this.fileRecoveryService.didSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-paths', () =>\r\n      this.saveCurrentWindowOptions(false)\r\n    ))\r\n\r\n    this.disposable.add(this.disableZoomOnDisplayChange())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.openPathOnEvent","start_line":720,"end_line":729,"comment":[" Public: Open the given path in the focused window when the event is"," triggered.",""," A new window will be created if there is no currently focused window.",""," eventName - The event to listen for."," pathToOpen - The path to open when the event is triggered."],"params":["eventName","pathToOpen"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"openPathOnEvent","line":414,"func_location":"AtomApplication.handleEvents","func_start_line":364,"func_end_line":634,"args":[{"type":"string"},{"type":"string"}],"comment":[" Registers basic application commands, non-idempotent."],"code":"  handleEvents () {\r\n    const getLoadSettings = () => {\r\n      const window = this.focusedWindow()\r\n      return {devMode: window && window.devMode, safeMode: window && window.safeMode}\r\n    }\r\n\r\n    this.on('application:quit', () => app.quit())\r\n    this.on('application:new-window', () => this.openPath(getLoadSettings()))\r\n    this.on('application:new-file', () => (this.focusedWindow() || this).openPath())\r\n    this.on('application:open-dev', () => this.promptForPathToOpen('all', {devMode: true}))\r\n    this.on('application:open-safe', () => this.promptForPathToOpen('all', {safeMode: true}))\r\n    this.on('application:inspect', ({x, y, atomWindow}) => {\r\n      if (!atomWindow) atomWindow = this.focusedWindow()\r\n      if (atomWindow) atomWindow.browserWindow.inspectElement(x, y)\r\n    })\r\n\r\n    this.on('application:open-documentation', () => shell.openExternal('http://flight-manual.atom.io'))\r\n    this.on('application:open-discussions', () => shell.openExternal('https://discuss.atom.io'))\r\n    this.on('application:open-faq', () => shell.openExternal('https://atom.io/faq'))\r\n    this.on('application:open-terms-of-use', () => shell.openExternal('https://atom.io/terms'))\r\n    this.on('application:report-issue', () => shell.openExternal('https://github.com/atom/atom/blob/master/CONTRIBUTING.md#reporting-bugs'))\r\n    this.on('application:search-issues', () => shell.openExternal('https://github.com/search?q=+is%3Aissue+user%3Aatom'))\r\n\r\n    this.on('application:install-update', () => {\r\n      this.quitting = true\r\n      this.autoUpdateManager.install()\r\n    })\r\n\r\n    this.on('application:check-for-update', () => this.autoUpdateManager.check())\r\n\r\n    if (process.platform === 'darwin') {\r\n      this.on('application:bring-all-windows-to-front', () => Menu.sendActionToFirstResponder('arrangeInFront:'))\r\n      this.on('application:hide', () => Menu.sendActionToFirstResponder('hide:'))\r\n      this.on('application:hide-other-applications', () => Menu.sendActionToFirstResponder('hideOtherApplications:'))\r\n      this.on('application:minimize', () => Menu.sendActionToFirstResponder('performMiniaturize:'))\r\n      this.on('application:unhide-all-applications', () => Menu.sendActionToFirstResponder('unhideAllApplications:'))\r\n      this.on('application:zoom', () => Menu.sendActionToFirstResponder('zoom:'))\r\n    } else {\r\n      this.on('application:minimize', () => {\r\n        const window = this.focusedWindow()\r\n        if (window) window.minimize()\r\n      })\r\n      this.on('application:zoom', function () {\r\n        const window = this.focusedWindow()\r\n        if (window) window.maximize()\r\n      })\r\n    }\r\n\r\n    this.openPathOnEvent('application:about', 'atom://about')\r\n    this.openPathOnEvent('application:show-settings', 'atom://config')\r\n    this.openPathOnEvent('application:open-your-config', 'atom://.atom/config')\r\n    this.openPathOnEvent('application:open-your-init-script', 'atom://.atom/init-script')\r\n    this.openPathOnEvent('application:open-your-keymap', 'atom://.atom/keymap')\r\n    this.openPathOnEvent('application:open-your-snippets', 'atom://.atom/snippets')\r\n    this.openPathOnEvent('application:open-your-stylesheet', 'atom://.atom/stylesheet')\r\n    this.openPathOnEvent('application:open-license', path.join(process.resourcesPath, 'LICENSE.md'))\r\n\r\n    this.configFile.onDidChange(settings => {\r\n      for (let window of this.getAllWindows()) {\r\n        window.didChangeUserSettings(settings)\r\n      }\r\n      this.config.resetUserSettings(settings)\r\n    })\r\n\r\n    this.configFile.onDidError(message => {\r\n      const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n      if (window) window.didFailToReadUserSettings(message)\r\n    })\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'before-quit', async event => {\r\n      let resolveBeforeQuitPromise\r\n      this.lastBeforeQuitPromise = new Promise(resolve => { resolveBeforeQuitPromise = resolve })\r\n\r\n      if (!this.quitting) {\r\n        this.quitting = true\r\n        event.preventDefault()\r\n        const windowUnloadPromises = this.getAllWindows().map(async window => {\r\n          const unloaded = await window.prepareToUnload()\r\n          if (unloaded) {\r\n            window.close()\r\n            await window.closedPromise\r\n          }\r\n          return unloaded\r\n        })\r\n        const windowUnloadedResults = await Promise.all(windowUnloadPromises)\r\n        if (windowUnloadedResults.every(Boolean)) {\r\n          app.quit()\r\n        } else {\r\n          this.quitting = false\r\n        }\r\n      }\r\n\r\n      resolveBeforeQuitPromise()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'will-quit', () => {\r\n      this.killAllProcesses()\r\n      this.deleteSocketFile()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-file', (event, pathToOpen) => {\r\n      event.preventDefault()\r\n      this.openPath({pathToOpen})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-url', (event, urlToOpen) => {\r\n      event.preventDefault()\r\n      this.openUrl({urlToOpen, devMode: this.devMode, safeMode: this.safeMode})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'activate', (event, hasVisibleWindows) => {\r\n      if (hasVisibleWindows) return\r\n      if (event) event.preventDefault()\r\n      this.emit('application:new-window')\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'restart-application', () => {\r\n      this.restart()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'resolve-proxy', (event, requestId, url) => {\r\n      event.sender.session.resolveProxy(url, proxy => {\r\n        if (!event.sender.isDestroyed()) event.sender.send('did-resolve-proxy', requestId, proxy)\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-history-manager', event => {\r\n      for (let atomWindow of this.getAllWindows()) {\r\n        const {webContents} = atomWindow.browserWindow\r\n        if (webContents !== event.sender) webContents.send('did-change-history-manager')\r\n      }\r\n    }))\r\n\r\n    // A request from the associated render process to open a new render process.\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open', (event, options) => {\r\n      const window = this.atomWindowForEvent(event)\r\n      if (options) {\r\n        if (typeof options.pathsToOpen === 'string') {\r\n          options.pathsToOpen = [options.pathsToOpen]\r\n        }\r\n\r\n        if (options.pathsToOpen && options.pathsToOpen.length > 0) {\r\n          options.window = window\r\n          this.openPaths(options)\r\n        } else {\r\n          this.addWindow(new AtomWindow(this, this.fileRecoveryService, options))\r\n        }\r\n      } else {\r\n        this.promptForPathToOpen('all', {window})\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'update-application-menu', (event, template, menu) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      if (this.applicationMenu) this.applicationMenu.update(window, template, menu)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-package-specs', (event, packageSpecPath, options = {}) => {\r\n      this.runTests(Object.assign({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [packageSpecPath],\r\n        headless: false\r\n      }, options))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-benchmarks', (event, benchmarksPath) => {\r\n      this.runBenchmarks({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [benchmarksPath],\r\n        headless: false,\r\n        test: false\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'command', (event, command) => {\r\n      this.emit(command)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open-command', (event, command, defaultPath) => {\r\n      switch (command) {\r\n        case 'application:open':\r\n          return this.promptForPathToOpen('all', getLoadSettings(), defaultPath)\r\n        case 'application:open-file':\r\n          return this.promptForPathToOpen('file', getLoadSettings(), defaultPath)\r\n        case 'application:open-folder':\r\n          return this.promptForPathToOpen('folder', getLoadSettings(), defaultPath)\r\n        default:\r\n          return console.log(`Invalid open-command received: ${command}`)\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'window-command', (event, command, ...args) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      return window.emit(command, ...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('window-method', (browserWindow, method, ...args) => {\r\n      const window = this.atomWindowForBrowserWindow(browserWindow)\r\n      if (window) window[method](...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'pick-folder', (event, responseChannel) => {\r\n      this.promptForPath('folder', paths => event.sender.send(responseChannel, paths))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-size', (window, width, height) => {\r\n      window.setSize(width, height)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-position', (window, x, y) => {\r\n      window.setPosition(x, y)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-user-settings', (window, settings, filePath) => {\r\n      if (!this.quitting) {\r\n        return ConfigFile.at(filePath || this.configFilePath).update(JSON.parse(settings))\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('center-window', window => window.center()))\r\n    this.disposable.add(ipcHelpers.respondTo('focus-window', window => window.focus()))\r\n    this.disposable.add(ipcHelpers.respondTo('show-window', window => window.show()))\r\n    this.disposable.add(ipcHelpers.respondTo('hide-window', window => window.hide()))\r\n    this.disposable.add(ipcHelpers.respondTo('get-temporary-window-state', window => window.temporaryState))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-temporary-window-state', (win, state) => {\r\n      win.temporaryState = state\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-text-to-selection-clipboard', (event, text) =>\r\n      clipboard.writeText(text, 'selection')\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stdout', (event, output) =>\r\n      process.stdout.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stderr', (event, output) =>\r\n      process.stderr.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'add-recent-document', (event, filename) =>\r\n      app.addRecentDocument(filename)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'execute-javascript-in-dev-tools', (event, code) =>\r\n      event.sender.devToolsWebContents && event.sender.devToolsWebContents.executeJavaScript(code)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-state', event => {\r\n      event.returnValue = this.autoUpdateManager.getState()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-error', event => {\r\n      event.returnValue = this.autoUpdateManager.getErrorMessage()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('will-save-path', (window, path) =>\r\n      this.fileRecoveryService.willSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('did-save-path', (window, path) =>\r\n      this.fileRecoveryService.didSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-paths', () =>\r\n      this.saveCurrentWindowOptions(false)\r\n    ))\r\n\r\n    this.disposable.add(this.disableZoomOnDisplayChange())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.openPathOnEvent","start_line":720,"end_line":729,"comment":[" Public: Open the given path in the focused window when the event is"," triggered.",""," A new window will be created if there is no currently focused window.",""," eventName - The event to listen for."," pathToOpen - The path to open when the event is triggered."],"params":["eventName","pathToOpen"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"openPathOnEvent","line":415,"func_location":"AtomApplication.handleEvents","func_start_line":364,"func_end_line":634,"args":[{"type":"string"},{"type":"string"}],"comment":[" Registers basic application commands, non-idempotent."],"code":"  handleEvents () {\r\n    const getLoadSettings = () => {\r\n      const window = this.focusedWindow()\r\n      return {devMode: window && window.devMode, safeMode: window && window.safeMode}\r\n    }\r\n\r\n    this.on('application:quit', () => app.quit())\r\n    this.on('application:new-window', () => this.openPath(getLoadSettings()))\r\n    this.on('application:new-file', () => (this.focusedWindow() || this).openPath())\r\n    this.on('application:open-dev', () => this.promptForPathToOpen('all', {devMode: true}))\r\n    this.on('application:open-safe', () => this.promptForPathToOpen('all', {safeMode: true}))\r\n    this.on('application:inspect', ({x, y, atomWindow}) => {\r\n      if (!atomWindow) atomWindow = this.focusedWindow()\r\n      if (atomWindow) atomWindow.browserWindow.inspectElement(x, y)\r\n    })\r\n\r\n    this.on('application:open-documentation', () => shell.openExternal('http://flight-manual.atom.io'))\r\n    this.on('application:open-discussions', () => shell.openExternal('https://discuss.atom.io'))\r\n    this.on('application:open-faq', () => shell.openExternal('https://atom.io/faq'))\r\n    this.on('application:open-terms-of-use', () => shell.openExternal('https://atom.io/terms'))\r\n    this.on('application:report-issue', () => shell.openExternal('https://github.com/atom/atom/blob/master/CONTRIBUTING.md#reporting-bugs'))\r\n    this.on('application:search-issues', () => shell.openExternal('https://github.com/search?q=+is%3Aissue+user%3Aatom'))\r\n\r\n    this.on('application:install-update', () => {\r\n      this.quitting = true\r\n      this.autoUpdateManager.install()\r\n    })\r\n\r\n    this.on('application:check-for-update', () => this.autoUpdateManager.check())\r\n\r\n    if (process.platform === 'darwin') {\r\n      this.on('application:bring-all-windows-to-front', () => Menu.sendActionToFirstResponder('arrangeInFront:'))\r\n      this.on('application:hide', () => Menu.sendActionToFirstResponder('hide:'))\r\n      this.on('application:hide-other-applications', () => Menu.sendActionToFirstResponder('hideOtherApplications:'))\r\n      this.on('application:minimize', () => Menu.sendActionToFirstResponder('performMiniaturize:'))\r\n      this.on('application:unhide-all-applications', () => Menu.sendActionToFirstResponder('unhideAllApplications:'))\r\n      this.on('application:zoom', () => Menu.sendActionToFirstResponder('zoom:'))\r\n    } else {\r\n      this.on('application:minimize', () => {\r\n        const window = this.focusedWindow()\r\n        if (window) window.minimize()\r\n      })\r\n      this.on('application:zoom', function () {\r\n        const window = this.focusedWindow()\r\n        if (window) window.maximize()\r\n      })\r\n    }\r\n\r\n    this.openPathOnEvent('application:about', 'atom://about')\r\n    this.openPathOnEvent('application:show-settings', 'atom://config')\r\n    this.openPathOnEvent('application:open-your-config', 'atom://.atom/config')\r\n    this.openPathOnEvent('application:open-your-init-script', 'atom://.atom/init-script')\r\n    this.openPathOnEvent('application:open-your-keymap', 'atom://.atom/keymap')\r\n    this.openPathOnEvent('application:open-your-snippets', 'atom://.atom/snippets')\r\n    this.openPathOnEvent('application:open-your-stylesheet', 'atom://.atom/stylesheet')\r\n    this.openPathOnEvent('application:open-license', path.join(process.resourcesPath, 'LICENSE.md'))\r\n\r\n    this.configFile.onDidChange(settings => {\r\n      for (let window of this.getAllWindows()) {\r\n        window.didChangeUserSettings(settings)\r\n      }\r\n      this.config.resetUserSettings(settings)\r\n    })\r\n\r\n    this.configFile.onDidError(message => {\r\n      const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n      if (window) window.didFailToReadUserSettings(message)\r\n    })\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'before-quit', async event => {\r\n      let resolveBeforeQuitPromise\r\n      this.lastBeforeQuitPromise = new Promise(resolve => { resolveBeforeQuitPromise = resolve })\r\n\r\n      if (!this.quitting) {\r\n        this.quitting = true\r\n        event.preventDefault()\r\n        const windowUnloadPromises = this.getAllWindows().map(async window => {\r\n          const unloaded = await window.prepareToUnload()\r\n          if (unloaded) {\r\n            window.close()\r\n            await window.closedPromise\r\n          }\r\n          return unloaded\r\n        })\r\n        const windowUnloadedResults = await Promise.all(windowUnloadPromises)\r\n        if (windowUnloadedResults.every(Boolean)) {\r\n          app.quit()\r\n        } else {\r\n          this.quitting = false\r\n        }\r\n      }\r\n\r\n      resolveBeforeQuitPromise()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'will-quit', () => {\r\n      this.killAllProcesses()\r\n      this.deleteSocketFile()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-file', (event, pathToOpen) => {\r\n      event.preventDefault()\r\n      this.openPath({pathToOpen})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-url', (event, urlToOpen) => {\r\n      event.preventDefault()\r\n      this.openUrl({urlToOpen, devMode: this.devMode, safeMode: this.safeMode})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'activate', (event, hasVisibleWindows) => {\r\n      if (hasVisibleWindows) return\r\n      if (event) event.preventDefault()\r\n      this.emit('application:new-window')\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'restart-application', () => {\r\n      this.restart()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'resolve-proxy', (event, requestId, url) => {\r\n      event.sender.session.resolveProxy(url, proxy => {\r\n        if (!event.sender.isDestroyed()) event.sender.send('did-resolve-proxy', requestId, proxy)\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-history-manager', event => {\r\n      for (let atomWindow of this.getAllWindows()) {\r\n        const {webContents} = atomWindow.browserWindow\r\n        if (webContents !== event.sender) webContents.send('did-change-history-manager')\r\n      }\r\n    }))\r\n\r\n    // A request from the associated render process to open a new render process.\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open', (event, options) => {\r\n      const window = this.atomWindowForEvent(event)\r\n      if (options) {\r\n        if (typeof options.pathsToOpen === 'string') {\r\n          options.pathsToOpen = [options.pathsToOpen]\r\n        }\r\n\r\n        if (options.pathsToOpen && options.pathsToOpen.length > 0) {\r\n          options.window = window\r\n          this.openPaths(options)\r\n        } else {\r\n          this.addWindow(new AtomWindow(this, this.fileRecoveryService, options))\r\n        }\r\n      } else {\r\n        this.promptForPathToOpen('all', {window})\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'update-application-menu', (event, template, menu) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      if (this.applicationMenu) this.applicationMenu.update(window, template, menu)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-package-specs', (event, packageSpecPath, options = {}) => {\r\n      this.runTests(Object.assign({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [packageSpecPath],\r\n        headless: false\r\n      }, options))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-benchmarks', (event, benchmarksPath) => {\r\n      this.runBenchmarks({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [benchmarksPath],\r\n        headless: false,\r\n        test: false\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'command', (event, command) => {\r\n      this.emit(command)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open-command', (event, command, defaultPath) => {\r\n      switch (command) {\r\n        case 'application:open':\r\n          return this.promptForPathToOpen('all', getLoadSettings(), defaultPath)\r\n        case 'application:open-file':\r\n          return this.promptForPathToOpen('file', getLoadSettings(), defaultPath)\r\n        case 'application:open-folder':\r\n          return this.promptForPathToOpen('folder', getLoadSettings(), defaultPath)\r\n        default:\r\n          return console.log(`Invalid open-command received: ${command}`)\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'window-command', (event, command, ...args) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      return window.emit(command, ...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('window-method', (browserWindow, method, ...args) => {\r\n      const window = this.atomWindowForBrowserWindow(browserWindow)\r\n      if (window) window[method](...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'pick-folder', (event, responseChannel) => {\r\n      this.promptForPath('folder', paths => event.sender.send(responseChannel, paths))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-size', (window, width, height) => {\r\n      window.setSize(width, height)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-position', (window, x, y) => {\r\n      window.setPosition(x, y)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-user-settings', (window, settings, filePath) => {\r\n      if (!this.quitting) {\r\n        return ConfigFile.at(filePath || this.configFilePath).update(JSON.parse(settings))\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('center-window', window => window.center()))\r\n    this.disposable.add(ipcHelpers.respondTo('focus-window', window => window.focus()))\r\n    this.disposable.add(ipcHelpers.respondTo('show-window', window => window.show()))\r\n    this.disposable.add(ipcHelpers.respondTo('hide-window', window => window.hide()))\r\n    this.disposable.add(ipcHelpers.respondTo('get-temporary-window-state', window => window.temporaryState))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-temporary-window-state', (win, state) => {\r\n      win.temporaryState = state\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-text-to-selection-clipboard', (event, text) =>\r\n      clipboard.writeText(text, 'selection')\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stdout', (event, output) =>\r\n      process.stdout.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stderr', (event, output) =>\r\n      process.stderr.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'add-recent-document', (event, filename) =>\r\n      app.addRecentDocument(filename)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'execute-javascript-in-dev-tools', (event, code) =>\r\n      event.sender.devToolsWebContents && event.sender.devToolsWebContents.executeJavaScript(code)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-state', event => {\r\n      event.returnValue = this.autoUpdateManager.getState()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-error', event => {\r\n      event.returnValue = this.autoUpdateManager.getErrorMessage()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('will-save-path', (window, path) =>\r\n      this.fileRecoveryService.willSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('did-save-path', (window, path) =>\r\n      this.fileRecoveryService.didSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-paths', () =>\r\n      this.saveCurrentWindowOptions(false)\r\n    ))\r\n\r\n    this.disposable.add(this.disableZoomOnDisplayChange())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.openPathOnEvent","start_line":720,"end_line":729,"comment":[" Public: Open the given path in the focused window when the event is"," triggered.",""," A new window will be created if there is no currently focused window.",""," eventName - The event to listen for."," pathToOpen - The path to open when the event is triggered."],"params":["eventName","pathToOpen"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"openPathOnEvent","line":416,"func_location":"AtomApplication.handleEvents","func_start_line":364,"func_end_line":634,"args":[{"type":"string"},{"type":"string"}],"comment":[" Registers basic application commands, non-idempotent."],"code":"  handleEvents () {\r\n    const getLoadSettings = () => {\r\n      const window = this.focusedWindow()\r\n      return {devMode: window && window.devMode, safeMode: window && window.safeMode}\r\n    }\r\n\r\n    this.on('application:quit', () => app.quit())\r\n    this.on('application:new-window', () => this.openPath(getLoadSettings()))\r\n    this.on('application:new-file', () => (this.focusedWindow() || this).openPath())\r\n    this.on('application:open-dev', () => this.promptForPathToOpen('all', {devMode: true}))\r\n    this.on('application:open-safe', () => this.promptForPathToOpen('all', {safeMode: true}))\r\n    this.on('application:inspect', ({x, y, atomWindow}) => {\r\n      if (!atomWindow) atomWindow = this.focusedWindow()\r\n      if (atomWindow) atomWindow.browserWindow.inspectElement(x, y)\r\n    })\r\n\r\n    this.on('application:open-documentation', () => shell.openExternal('http://flight-manual.atom.io'))\r\n    this.on('application:open-discussions', () => shell.openExternal('https://discuss.atom.io'))\r\n    this.on('application:open-faq', () => shell.openExternal('https://atom.io/faq'))\r\n    this.on('application:open-terms-of-use', () => shell.openExternal('https://atom.io/terms'))\r\n    this.on('application:report-issue', () => shell.openExternal('https://github.com/atom/atom/blob/master/CONTRIBUTING.md#reporting-bugs'))\r\n    this.on('application:search-issues', () => shell.openExternal('https://github.com/search?q=+is%3Aissue+user%3Aatom'))\r\n\r\n    this.on('application:install-update', () => {\r\n      this.quitting = true\r\n      this.autoUpdateManager.install()\r\n    })\r\n\r\n    this.on('application:check-for-update', () => this.autoUpdateManager.check())\r\n\r\n    if (process.platform === 'darwin') {\r\n      this.on('application:bring-all-windows-to-front', () => Menu.sendActionToFirstResponder('arrangeInFront:'))\r\n      this.on('application:hide', () => Menu.sendActionToFirstResponder('hide:'))\r\n      this.on('application:hide-other-applications', () => Menu.sendActionToFirstResponder('hideOtherApplications:'))\r\n      this.on('application:minimize', () => Menu.sendActionToFirstResponder('performMiniaturize:'))\r\n      this.on('application:unhide-all-applications', () => Menu.sendActionToFirstResponder('unhideAllApplications:'))\r\n      this.on('application:zoom', () => Menu.sendActionToFirstResponder('zoom:'))\r\n    } else {\r\n      this.on('application:minimize', () => {\r\n        const window = this.focusedWindow()\r\n        if (window) window.minimize()\r\n      })\r\n      this.on('application:zoom', function () {\r\n        const window = this.focusedWindow()\r\n        if (window) window.maximize()\r\n      })\r\n    }\r\n\r\n    this.openPathOnEvent('application:about', 'atom://about')\r\n    this.openPathOnEvent('application:show-settings', 'atom://config')\r\n    this.openPathOnEvent('application:open-your-config', 'atom://.atom/config')\r\n    this.openPathOnEvent('application:open-your-init-script', 'atom://.atom/init-script')\r\n    this.openPathOnEvent('application:open-your-keymap', 'atom://.atom/keymap')\r\n    this.openPathOnEvent('application:open-your-snippets', 'atom://.atom/snippets')\r\n    this.openPathOnEvent('application:open-your-stylesheet', 'atom://.atom/stylesheet')\r\n    this.openPathOnEvent('application:open-license', path.join(process.resourcesPath, 'LICENSE.md'))\r\n\r\n    this.configFile.onDidChange(settings => {\r\n      for (let window of this.getAllWindows()) {\r\n        window.didChangeUserSettings(settings)\r\n      }\r\n      this.config.resetUserSettings(settings)\r\n    })\r\n\r\n    this.configFile.onDidError(message => {\r\n      const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n      if (window) window.didFailToReadUserSettings(message)\r\n    })\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'before-quit', async event => {\r\n      let resolveBeforeQuitPromise\r\n      this.lastBeforeQuitPromise = new Promise(resolve => { resolveBeforeQuitPromise = resolve })\r\n\r\n      if (!this.quitting) {\r\n        this.quitting = true\r\n        event.preventDefault()\r\n        const windowUnloadPromises = this.getAllWindows().map(async window => {\r\n          const unloaded = await window.prepareToUnload()\r\n          if (unloaded) {\r\n            window.close()\r\n            await window.closedPromise\r\n          }\r\n          return unloaded\r\n        })\r\n        const windowUnloadedResults = await Promise.all(windowUnloadPromises)\r\n        if (windowUnloadedResults.every(Boolean)) {\r\n          app.quit()\r\n        } else {\r\n          this.quitting = false\r\n        }\r\n      }\r\n\r\n      resolveBeforeQuitPromise()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'will-quit', () => {\r\n      this.killAllProcesses()\r\n      this.deleteSocketFile()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-file', (event, pathToOpen) => {\r\n      event.preventDefault()\r\n      this.openPath({pathToOpen})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-url', (event, urlToOpen) => {\r\n      event.preventDefault()\r\n      this.openUrl({urlToOpen, devMode: this.devMode, safeMode: this.safeMode})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'activate', (event, hasVisibleWindows) => {\r\n      if (hasVisibleWindows) return\r\n      if (event) event.preventDefault()\r\n      this.emit('application:new-window')\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'restart-application', () => {\r\n      this.restart()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'resolve-proxy', (event, requestId, url) => {\r\n      event.sender.session.resolveProxy(url, proxy => {\r\n        if (!event.sender.isDestroyed()) event.sender.send('did-resolve-proxy', requestId, proxy)\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-history-manager', event => {\r\n      for (let atomWindow of this.getAllWindows()) {\r\n        const {webContents} = atomWindow.browserWindow\r\n        if (webContents !== event.sender) webContents.send('did-change-history-manager')\r\n      }\r\n    }))\r\n\r\n    // A request from the associated render process to open a new render process.\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open', (event, options) => {\r\n      const window = this.atomWindowForEvent(event)\r\n      if (options) {\r\n        if (typeof options.pathsToOpen === 'string') {\r\n          options.pathsToOpen = [options.pathsToOpen]\r\n        }\r\n\r\n        if (options.pathsToOpen && options.pathsToOpen.length > 0) {\r\n          options.window = window\r\n          this.openPaths(options)\r\n        } else {\r\n          this.addWindow(new AtomWindow(this, this.fileRecoveryService, options))\r\n        }\r\n      } else {\r\n        this.promptForPathToOpen('all', {window})\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'update-application-menu', (event, template, menu) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      if (this.applicationMenu) this.applicationMenu.update(window, template, menu)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-package-specs', (event, packageSpecPath, options = {}) => {\r\n      this.runTests(Object.assign({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [packageSpecPath],\r\n        headless: false\r\n      }, options))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-benchmarks', (event, benchmarksPath) => {\r\n      this.runBenchmarks({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [benchmarksPath],\r\n        headless: false,\r\n        test: false\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'command', (event, command) => {\r\n      this.emit(command)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open-command', (event, command, defaultPath) => {\r\n      switch (command) {\r\n        case 'application:open':\r\n          return this.promptForPathToOpen('all', getLoadSettings(), defaultPath)\r\n        case 'application:open-file':\r\n          return this.promptForPathToOpen('file', getLoadSettings(), defaultPath)\r\n        case 'application:open-folder':\r\n          return this.promptForPathToOpen('folder', getLoadSettings(), defaultPath)\r\n        default:\r\n          return console.log(`Invalid open-command received: ${command}`)\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'window-command', (event, command, ...args) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      return window.emit(command, ...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('window-method', (browserWindow, method, ...args) => {\r\n      const window = this.atomWindowForBrowserWindow(browserWindow)\r\n      if (window) window[method](...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'pick-folder', (event, responseChannel) => {\r\n      this.promptForPath('folder', paths => event.sender.send(responseChannel, paths))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-size', (window, width, height) => {\r\n      window.setSize(width, height)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-position', (window, x, y) => {\r\n      window.setPosition(x, y)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-user-settings', (window, settings, filePath) => {\r\n      if (!this.quitting) {\r\n        return ConfigFile.at(filePath || this.configFilePath).update(JSON.parse(settings))\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('center-window', window => window.center()))\r\n    this.disposable.add(ipcHelpers.respondTo('focus-window', window => window.focus()))\r\n    this.disposable.add(ipcHelpers.respondTo('show-window', window => window.show()))\r\n    this.disposable.add(ipcHelpers.respondTo('hide-window', window => window.hide()))\r\n    this.disposable.add(ipcHelpers.respondTo('get-temporary-window-state', window => window.temporaryState))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-temporary-window-state', (win, state) => {\r\n      win.temporaryState = state\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-text-to-selection-clipboard', (event, text) =>\r\n      clipboard.writeText(text, 'selection')\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stdout', (event, output) =>\r\n      process.stdout.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stderr', (event, output) =>\r\n      process.stderr.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'add-recent-document', (event, filename) =>\r\n      app.addRecentDocument(filename)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'execute-javascript-in-dev-tools', (event, code) =>\r\n      event.sender.devToolsWebContents && event.sender.devToolsWebContents.executeJavaScript(code)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-state', event => {\r\n      event.returnValue = this.autoUpdateManager.getState()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-error', event => {\r\n      event.returnValue = this.autoUpdateManager.getErrorMessage()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('will-save-path', (window, path) =>\r\n      this.fileRecoveryService.willSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('did-save-path', (window, path) =>\r\n      this.fileRecoveryService.didSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-paths', () =>\r\n      this.saveCurrentWindowOptions(false)\r\n    ))\r\n\r\n    this.disposable.add(this.disableZoomOnDisplayChange())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.openPathOnEvent","start_line":720,"end_line":729,"comment":[" Public: Open the given path in the focused window when the event is"," triggered.",""," A new window will be created if there is no currently focused window.",""," eventName - The event to listen for."," pathToOpen - The path to open when the event is triggered."],"params":["eventName","pathToOpen"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"openPathOnEvent","line":417,"func_location":"AtomApplication.handleEvents","func_start_line":364,"func_end_line":634,"args":[{"type":"string"},{"type":"string"}],"comment":[" Registers basic application commands, non-idempotent."],"code":"  handleEvents () {\r\n    const getLoadSettings = () => {\r\n      const window = this.focusedWindow()\r\n      return {devMode: window && window.devMode, safeMode: window && window.safeMode}\r\n    }\r\n\r\n    this.on('application:quit', () => app.quit())\r\n    this.on('application:new-window', () => this.openPath(getLoadSettings()))\r\n    this.on('application:new-file', () => (this.focusedWindow() || this).openPath())\r\n    this.on('application:open-dev', () => this.promptForPathToOpen('all', {devMode: true}))\r\n    this.on('application:open-safe', () => this.promptForPathToOpen('all', {safeMode: true}))\r\n    this.on('application:inspect', ({x, y, atomWindow}) => {\r\n      if (!atomWindow) atomWindow = this.focusedWindow()\r\n      if (atomWindow) atomWindow.browserWindow.inspectElement(x, y)\r\n    })\r\n\r\n    this.on('application:open-documentation', () => shell.openExternal('http://flight-manual.atom.io'))\r\n    this.on('application:open-discussions', () => shell.openExternal('https://discuss.atom.io'))\r\n    this.on('application:open-faq', () => shell.openExternal('https://atom.io/faq'))\r\n    this.on('application:open-terms-of-use', () => shell.openExternal('https://atom.io/terms'))\r\n    this.on('application:report-issue', () => shell.openExternal('https://github.com/atom/atom/blob/master/CONTRIBUTING.md#reporting-bugs'))\r\n    this.on('application:search-issues', () => shell.openExternal('https://github.com/search?q=+is%3Aissue+user%3Aatom'))\r\n\r\n    this.on('application:install-update', () => {\r\n      this.quitting = true\r\n      this.autoUpdateManager.install()\r\n    })\r\n\r\n    this.on('application:check-for-update', () => this.autoUpdateManager.check())\r\n\r\n    if (process.platform === 'darwin') {\r\n      this.on('application:bring-all-windows-to-front', () => Menu.sendActionToFirstResponder('arrangeInFront:'))\r\n      this.on('application:hide', () => Menu.sendActionToFirstResponder('hide:'))\r\n      this.on('application:hide-other-applications', () => Menu.sendActionToFirstResponder('hideOtherApplications:'))\r\n      this.on('application:minimize', () => Menu.sendActionToFirstResponder('performMiniaturize:'))\r\n      this.on('application:unhide-all-applications', () => Menu.sendActionToFirstResponder('unhideAllApplications:'))\r\n      this.on('application:zoom', () => Menu.sendActionToFirstResponder('zoom:'))\r\n    } else {\r\n      this.on('application:minimize', () => {\r\n        const window = this.focusedWindow()\r\n        if (window) window.minimize()\r\n      })\r\n      this.on('application:zoom', function () {\r\n        const window = this.focusedWindow()\r\n        if (window) window.maximize()\r\n      })\r\n    }\r\n\r\n    this.openPathOnEvent('application:about', 'atom://about')\r\n    this.openPathOnEvent('application:show-settings', 'atom://config')\r\n    this.openPathOnEvent('application:open-your-config', 'atom://.atom/config')\r\n    this.openPathOnEvent('application:open-your-init-script', 'atom://.atom/init-script')\r\n    this.openPathOnEvent('application:open-your-keymap', 'atom://.atom/keymap')\r\n    this.openPathOnEvent('application:open-your-snippets', 'atom://.atom/snippets')\r\n    this.openPathOnEvent('application:open-your-stylesheet', 'atom://.atom/stylesheet')\r\n    this.openPathOnEvent('application:open-license', path.join(process.resourcesPath, 'LICENSE.md'))\r\n\r\n    this.configFile.onDidChange(settings => {\r\n      for (let window of this.getAllWindows()) {\r\n        window.didChangeUserSettings(settings)\r\n      }\r\n      this.config.resetUserSettings(settings)\r\n    })\r\n\r\n    this.configFile.onDidError(message => {\r\n      const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n      if (window) window.didFailToReadUserSettings(message)\r\n    })\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'before-quit', async event => {\r\n      let resolveBeforeQuitPromise\r\n      this.lastBeforeQuitPromise = new Promise(resolve => { resolveBeforeQuitPromise = resolve })\r\n\r\n      if (!this.quitting) {\r\n        this.quitting = true\r\n        event.preventDefault()\r\n        const windowUnloadPromises = this.getAllWindows().map(async window => {\r\n          const unloaded = await window.prepareToUnload()\r\n          if (unloaded) {\r\n            window.close()\r\n            await window.closedPromise\r\n          }\r\n          return unloaded\r\n        })\r\n        const windowUnloadedResults = await Promise.all(windowUnloadPromises)\r\n        if (windowUnloadedResults.every(Boolean)) {\r\n          app.quit()\r\n        } else {\r\n          this.quitting = false\r\n        }\r\n      }\r\n\r\n      resolveBeforeQuitPromise()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'will-quit', () => {\r\n      this.killAllProcesses()\r\n      this.deleteSocketFile()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-file', (event, pathToOpen) => {\r\n      event.preventDefault()\r\n      this.openPath({pathToOpen})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-url', (event, urlToOpen) => {\r\n      event.preventDefault()\r\n      this.openUrl({urlToOpen, devMode: this.devMode, safeMode: this.safeMode})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'activate', (event, hasVisibleWindows) => {\r\n      if (hasVisibleWindows) return\r\n      if (event) event.preventDefault()\r\n      this.emit('application:new-window')\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'restart-application', () => {\r\n      this.restart()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'resolve-proxy', (event, requestId, url) => {\r\n      event.sender.session.resolveProxy(url, proxy => {\r\n        if (!event.sender.isDestroyed()) event.sender.send('did-resolve-proxy', requestId, proxy)\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-history-manager', event => {\r\n      for (let atomWindow of this.getAllWindows()) {\r\n        const {webContents} = atomWindow.browserWindow\r\n        if (webContents !== event.sender) webContents.send('did-change-history-manager')\r\n      }\r\n    }))\r\n\r\n    // A request from the associated render process to open a new render process.\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open', (event, options) => {\r\n      const window = this.atomWindowForEvent(event)\r\n      if (options) {\r\n        if (typeof options.pathsToOpen === 'string') {\r\n          options.pathsToOpen = [options.pathsToOpen]\r\n        }\r\n\r\n        if (options.pathsToOpen && options.pathsToOpen.length > 0) {\r\n          options.window = window\r\n          this.openPaths(options)\r\n        } else {\r\n          this.addWindow(new AtomWindow(this, this.fileRecoveryService, options))\r\n        }\r\n      } else {\r\n        this.promptForPathToOpen('all', {window})\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'update-application-menu', (event, template, menu) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      if (this.applicationMenu) this.applicationMenu.update(window, template, menu)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-package-specs', (event, packageSpecPath, options = {}) => {\r\n      this.runTests(Object.assign({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [packageSpecPath],\r\n        headless: false\r\n      }, options))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-benchmarks', (event, benchmarksPath) => {\r\n      this.runBenchmarks({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [benchmarksPath],\r\n        headless: false,\r\n        test: false\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'command', (event, command) => {\r\n      this.emit(command)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open-command', (event, command, defaultPath) => {\r\n      switch (command) {\r\n        case 'application:open':\r\n          return this.promptForPathToOpen('all', getLoadSettings(), defaultPath)\r\n        case 'application:open-file':\r\n          return this.promptForPathToOpen('file', getLoadSettings(), defaultPath)\r\n        case 'application:open-folder':\r\n          return this.promptForPathToOpen('folder', getLoadSettings(), defaultPath)\r\n        default:\r\n          return console.log(`Invalid open-command received: ${command}`)\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'window-command', (event, command, ...args) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      return window.emit(command, ...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('window-method', (browserWindow, method, ...args) => {\r\n      const window = this.atomWindowForBrowserWindow(browserWindow)\r\n      if (window) window[method](...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'pick-folder', (event, responseChannel) => {\r\n      this.promptForPath('folder', paths => event.sender.send(responseChannel, paths))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-size', (window, width, height) => {\r\n      window.setSize(width, height)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-position', (window, x, y) => {\r\n      window.setPosition(x, y)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-user-settings', (window, settings, filePath) => {\r\n      if (!this.quitting) {\r\n        return ConfigFile.at(filePath || this.configFilePath).update(JSON.parse(settings))\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('center-window', window => window.center()))\r\n    this.disposable.add(ipcHelpers.respondTo('focus-window', window => window.focus()))\r\n    this.disposable.add(ipcHelpers.respondTo('show-window', window => window.show()))\r\n    this.disposable.add(ipcHelpers.respondTo('hide-window', window => window.hide()))\r\n    this.disposable.add(ipcHelpers.respondTo('get-temporary-window-state', window => window.temporaryState))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-temporary-window-state', (win, state) => {\r\n      win.temporaryState = state\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-text-to-selection-clipboard', (event, text) =>\r\n      clipboard.writeText(text, 'selection')\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stdout', (event, output) =>\r\n      process.stdout.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stderr', (event, output) =>\r\n      process.stderr.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'add-recent-document', (event, filename) =>\r\n      app.addRecentDocument(filename)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'execute-javascript-in-dev-tools', (event, code) =>\r\n      event.sender.devToolsWebContents && event.sender.devToolsWebContents.executeJavaScript(code)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-state', event => {\r\n      event.returnValue = this.autoUpdateManager.getState()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-error', event => {\r\n      event.returnValue = this.autoUpdateManager.getErrorMessage()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('will-save-path', (window, path) =>\r\n      this.fileRecoveryService.willSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('did-save-path', (window, path) =>\r\n      this.fileRecoveryService.didSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-paths', () =>\r\n      this.saveCurrentWindowOptions(false)\r\n    ))\r\n\r\n    this.disposable.add(this.disableZoomOnDisplayChange())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.openPathOnEvent","start_line":720,"end_line":729,"comment":[" Public: Open the given path in the focused window when the event is"," triggered.",""," A new window will be created if there is no currently focused window.",""," eventName - The event to listen for."," pathToOpen - The path to open when the event is triggered."],"params":["eventName","pathToOpen"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"openPathOnEvent","line":418,"func_location":"AtomApplication.handleEvents","func_start_line":364,"func_end_line":634,"args":[{"type":"string"},{"type":"string"}],"comment":[" Registers basic application commands, non-idempotent."],"code":"  handleEvents () {\r\n    const getLoadSettings = () => {\r\n      const window = this.focusedWindow()\r\n      return {devMode: window && window.devMode, safeMode: window && window.safeMode}\r\n    }\r\n\r\n    this.on('application:quit', () => app.quit())\r\n    this.on('application:new-window', () => this.openPath(getLoadSettings()))\r\n    this.on('application:new-file', () => (this.focusedWindow() || this).openPath())\r\n    this.on('application:open-dev', () => this.promptForPathToOpen('all', {devMode: true}))\r\n    this.on('application:open-safe', () => this.promptForPathToOpen('all', {safeMode: true}))\r\n    this.on('application:inspect', ({x, y, atomWindow}) => {\r\n      if (!atomWindow) atomWindow = this.focusedWindow()\r\n      if (atomWindow) atomWindow.browserWindow.inspectElement(x, y)\r\n    })\r\n\r\n    this.on('application:open-documentation', () => shell.openExternal('http://flight-manual.atom.io'))\r\n    this.on('application:open-discussions', () => shell.openExternal('https://discuss.atom.io'))\r\n    this.on('application:open-faq', () => shell.openExternal('https://atom.io/faq'))\r\n    this.on('application:open-terms-of-use', () => shell.openExternal('https://atom.io/terms'))\r\n    this.on('application:report-issue', () => shell.openExternal('https://github.com/atom/atom/blob/master/CONTRIBUTING.md#reporting-bugs'))\r\n    this.on('application:search-issues', () => shell.openExternal('https://github.com/search?q=+is%3Aissue+user%3Aatom'))\r\n\r\n    this.on('application:install-update', () => {\r\n      this.quitting = true\r\n      this.autoUpdateManager.install()\r\n    })\r\n\r\n    this.on('application:check-for-update', () => this.autoUpdateManager.check())\r\n\r\n    if (process.platform === 'darwin') {\r\n      this.on('application:bring-all-windows-to-front', () => Menu.sendActionToFirstResponder('arrangeInFront:'))\r\n      this.on('application:hide', () => Menu.sendActionToFirstResponder('hide:'))\r\n      this.on('application:hide-other-applications', () => Menu.sendActionToFirstResponder('hideOtherApplications:'))\r\n      this.on('application:minimize', () => Menu.sendActionToFirstResponder('performMiniaturize:'))\r\n      this.on('application:unhide-all-applications', () => Menu.sendActionToFirstResponder('unhideAllApplications:'))\r\n      this.on('application:zoom', () => Menu.sendActionToFirstResponder('zoom:'))\r\n    } else {\r\n      this.on('application:minimize', () => {\r\n        const window = this.focusedWindow()\r\n        if (window) window.minimize()\r\n      })\r\n      this.on('application:zoom', function () {\r\n        const window = this.focusedWindow()\r\n        if (window) window.maximize()\r\n      })\r\n    }\r\n\r\n    this.openPathOnEvent('application:about', 'atom://about')\r\n    this.openPathOnEvent('application:show-settings', 'atom://config')\r\n    this.openPathOnEvent('application:open-your-config', 'atom://.atom/config')\r\n    this.openPathOnEvent('application:open-your-init-script', 'atom://.atom/init-script')\r\n    this.openPathOnEvent('application:open-your-keymap', 'atom://.atom/keymap')\r\n    this.openPathOnEvent('application:open-your-snippets', 'atom://.atom/snippets')\r\n    this.openPathOnEvent('application:open-your-stylesheet', 'atom://.atom/stylesheet')\r\n    this.openPathOnEvent('application:open-license', path.join(process.resourcesPath, 'LICENSE.md'))\r\n\r\n    this.configFile.onDidChange(settings => {\r\n      for (let window of this.getAllWindows()) {\r\n        window.didChangeUserSettings(settings)\r\n      }\r\n      this.config.resetUserSettings(settings)\r\n    })\r\n\r\n    this.configFile.onDidError(message => {\r\n      const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n      if (window) window.didFailToReadUserSettings(message)\r\n    })\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'before-quit', async event => {\r\n      let resolveBeforeQuitPromise\r\n      this.lastBeforeQuitPromise = new Promise(resolve => { resolveBeforeQuitPromise = resolve })\r\n\r\n      if (!this.quitting) {\r\n        this.quitting = true\r\n        event.preventDefault()\r\n        const windowUnloadPromises = this.getAllWindows().map(async window => {\r\n          const unloaded = await window.prepareToUnload()\r\n          if (unloaded) {\r\n            window.close()\r\n            await window.closedPromise\r\n          }\r\n          return unloaded\r\n        })\r\n        const windowUnloadedResults = await Promise.all(windowUnloadPromises)\r\n        if (windowUnloadedResults.every(Boolean)) {\r\n          app.quit()\r\n        } else {\r\n          this.quitting = false\r\n        }\r\n      }\r\n\r\n      resolveBeforeQuitPromise()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'will-quit', () => {\r\n      this.killAllProcesses()\r\n      this.deleteSocketFile()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-file', (event, pathToOpen) => {\r\n      event.preventDefault()\r\n      this.openPath({pathToOpen})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-url', (event, urlToOpen) => {\r\n      event.preventDefault()\r\n      this.openUrl({urlToOpen, devMode: this.devMode, safeMode: this.safeMode})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'activate', (event, hasVisibleWindows) => {\r\n      if (hasVisibleWindows) return\r\n      if (event) event.preventDefault()\r\n      this.emit('application:new-window')\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'restart-application', () => {\r\n      this.restart()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'resolve-proxy', (event, requestId, url) => {\r\n      event.sender.session.resolveProxy(url, proxy => {\r\n        if (!event.sender.isDestroyed()) event.sender.send('did-resolve-proxy', requestId, proxy)\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-history-manager', event => {\r\n      for (let atomWindow of this.getAllWindows()) {\r\n        const {webContents} = atomWindow.browserWindow\r\n        if (webContents !== event.sender) webContents.send('did-change-history-manager')\r\n      }\r\n    }))\r\n\r\n    // A request from the associated render process to open a new render process.\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open', (event, options) => {\r\n      const window = this.atomWindowForEvent(event)\r\n      if (options) {\r\n        if (typeof options.pathsToOpen === 'string') {\r\n          options.pathsToOpen = [options.pathsToOpen]\r\n        }\r\n\r\n        if (options.pathsToOpen && options.pathsToOpen.length > 0) {\r\n          options.window = window\r\n          this.openPaths(options)\r\n        } else {\r\n          this.addWindow(new AtomWindow(this, this.fileRecoveryService, options))\r\n        }\r\n      } else {\r\n        this.promptForPathToOpen('all', {window})\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'update-application-menu', (event, template, menu) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      if (this.applicationMenu) this.applicationMenu.update(window, template, menu)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-package-specs', (event, packageSpecPath, options = {}) => {\r\n      this.runTests(Object.assign({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [packageSpecPath],\r\n        headless: false\r\n      }, options))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-benchmarks', (event, benchmarksPath) => {\r\n      this.runBenchmarks({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [benchmarksPath],\r\n        headless: false,\r\n        test: false\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'command', (event, command) => {\r\n      this.emit(command)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open-command', (event, command, defaultPath) => {\r\n      switch (command) {\r\n        case 'application:open':\r\n          return this.promptForPathToOpen('all', getLoadSettings(), defaultPath)\r\n        case 'application:open-file':\r\n          return this.promptForPathToOpen('file', getLoadSettings(), defaultPath)\r\n        case 'application:open-folder':\r\n          return this.promptForPathToOpen('folder', getLoadSettings(), defaultPath)\r\n        default:\r\n          return console.log(`Invalid open-command received: ${command}`)\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'window-command', (event, command, ...args) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      return window.emit(command, ...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('window-method', (browserWindow, method, ...args) => {\r\n      const window = this.atomWindowForBrowserWindow(browserWindow)\r\n      if (window) window[method](...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'pick-folder', (event, responseChannel) => {\r\n      this.promptForPath('folder', paths => event.sender.send(responseChannel, paths))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-size', (window, width, height) => {\r\n      window.setSize(width, height)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-position', (window, x, y) => {\r\n      window.setPosition(x, y)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-user-settings', (window, settings, filePath) => {\r\n      if (!this.quitting) {\r\n        return ConfigFile.at(filePath || this.configFilePath).update(JSON.parse(settings))\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('center-window', window => window.center()))\r\n    this.disposable.add(ipcHelpers.respondTo('focus-window', window => window.focus()))\r\n    this.disposable.add(ipcHelpers.respondTo('show-window', window => window.show()))\r\n    this.disposable.add(ipcHelpers.respondTo('hide-window', window => window.hide()))\r\n    this.disposable.add(ipcHelpers.respondTo('get-temporary-window-state', window => window.temporaryState))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-temporary-window-state', (win, state) => {\r\n      win.temporaryState = state\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-text-to-selection-clipboard', (event, text) =>\r\n      clipboard.writeText(text, 'selection')\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stdout', (event, output) =>\r\n      process.stdout.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stderr', (event, output) =>\r\n      process.stderr.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'add-recent-document', (event, filename) =>\r\n      app.addRecentDocument(filename)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'execute-javascript-in-dev-tools', (event, code) =>\r\n      event.sender.devToolsWebContents && event.sender.devToolsWebContents.executeJavaScript(code)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-state', event => {\r\n      event.returnValue = this.autoUpdateManager.getState()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-error', event => {\r\n      event.returnValue = this.autoUpdateManager.getErrorMessage()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('will-save-path', (window, path) =>\r\n      this.fileRecoveryService.willSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('did-save-path', (window, path) =>\r\n      this.fileRecoveryService.didSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-paths', () =>\r\n      this.saveCurrentWindowOptions(false)\r\n    ))\r\n\r\n    this.disposable.add(this.disableZoomOnDisplayChange())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.openPathOnEvent","start_line":720,"end_line":729,"comment":[" Public: Open the given path in the focused window when the event is"," triggered.",""," A new window will be created if there is no currently focused window.",""," eventName - The event to listen for."," pathToOpen - The path to open when the event is triggered."],"params":["eventName","pathToOpen"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"openPathOnEvent","line":419,"func_location":"AtomApplication.handleEvents","func_start_line":364,"func_end_line":634,"args":[{"type":"string"},null],"comment":[" Registers basic application commands, non-idempotent."],"code":"  handleEvents () {\r\n    const getLoadSettings = () => {\r\n      const window = this.focusedWindow()\r\n      return {devMode: window && window.devMode, safeMode: window && window.safeMode}\r\n    }\r\n\r\n    this.on('application:quit', () => app.quit())\r\n    this.on('application:new-window', () => this.openPath(getLoadSettings()))\r\n    this.on('application:new-file', () => (this.focusedWindow() || this).openPath())\r\n    this.on('application:open-dev', () => this.promptForPathToOpen('all', {devMode: true}))\r\n    this.on('application:open-safe', () => this.promptForPathToOpen('all', {safeMode: true}))\r\n    this.on('application:inspect', ({x, y, atomWindow}) => {\r\n      if (!atomWindow) atomWindow = this.focusedWindow()\r\n      if (atomWindow) atomWindow.browserWindow.inspectElement(x, y)\r\n    })\r\n\r\n    this.on('application:open-documentation', () => shell.openExternal('http://flight-manual.atom.io'))\r\n    this.on('application:open-discussions', () => shell.openExternal('https://discuss.atom.io'))\r\n    this.on('application:open-faq', () => shell.openExternal('https://atom.io/faq'))\r\n    this.on('application:open-terms-of-use', () => shell.openExternal('https://atom.io/terms'))\r\n    this.on('application:report-issue', () => shell.openExternal('https://github.com/atom/atom/blob/master/CONTRIBUTING.md#reporting-bugs'))\r\n    this.on('application:search-issues', () => shell.openExternal('https://github.com/search?q=+is%3Aissue+user%3Aatom'))\r\n\r\n    this.on('application:install-update', () => {\r\n      this.quitting = true\r\n      this.autoUpdateManager.install()\r\n    })\r\n\r\n    this.on('application:check-for-update', () => this.autoUpdateManager.check())\r\n\r\n    if (process.platform === 'darwin') {\r\n      this.on('application:bring-all-windows-to-front', () => Menu.sendActionToFirstResponder('arrangeInFront:'))\r\n      this.on('application:hide', () => Menu.sendActionToFirstResponder('hide:'))\r\n      this.on('application:hide-other-applications', () => Menu.sendActionToFirstResponder('hideOtherApplications:'))\r\n      this.on('application:minimize', () => Menu.sendActionToFirstResponder('performMiniaturize:'))\r\n      this.on('application:unhide-all-applications', () => Menu.sendActionToFirstResponder('unhideAllApplications:'))\r\n      this.on('application:zoom', () => Menu.sendActionToFirstResponder('zoom:'))\r\n    } else {\r\n      this.on('application:minimize', () => {\r\n        const window = this.focusedWindow()\r\n        if (window) window.minimize()\r\n      })\r\n      this.on('application:zoom', function () {\r\n        const window = this.focusedWindow()\r\n        if (window) window.maximize()\r\n      })\r\n    }\r\n\r\n    this.openPathOnEvent('application:about', 'atom://about')\r\n    this.openPathOnEvent('application:show-settings', 'atom://config')\r\n    this.openPathOnEvent('application:open-your-config', 'atom://.atom/config')\r\n    this.openPathOnEvent('application:open-your-init-script', 'atom://.atom/init-script')\r\n    this.openPathOnEvent('application:open-your-keymap', 'atom://.atom/keymap')\r\n    this.openPathOnEvent('application:open-your-snippets', 'atom://.atom/snippets')\r\n    this.openPathOnEvent('application:open-your-stylesheet', 'atom://.atom/stylesheet')\r\n    this.openPathOnEvent('application:open-license', path.join(process.resourcesPath, 'LICENSE.md'))\r\n\r\n    this.configFile.onDidChange(settings => {\r\n      for (let window of this.getAllWindows()) {\r\n        window.didChangeUserSettings(settings)\r\n      }\r\n      this.config.resetUserSettings(settings)\r\n    })\r\n\r\n    this.configFile.onDidError(message => {\r\n      const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n      if (window) window.didFailToReadUserSettings(message)\r\n    })\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'before-quit', async event => {\r\n      let resolveBeforeQuitPromise\r\n      this.lastBeforeQuitPromise = new Promise(resolve => { resolveBeforeQuitPromise = resolve })\r\n\r\n      if (!this.quitting) {\r\n        this.quitting = true\r\n        event.preventDefault()\r\n        const windowUnloadPromises = this.getAllWindows().map(async window => {\r\n          const unloaded = await window.prepareToUnload()\r\n          if (unloaded) {\r\n            window.close()\r\n            await window.closedPromise\r\n          }\r\n          return unloaded\r\n        })\r\n        const windowUnloadedResults = await Promise.all(windowUnloadPromises)\r\n        if (windowUnloadedResults.every(Boolean)) {\r\n          app.quit()\r\n        } else {\r\n          this.quitting = false\r\n        }\r\n      }\r\n\r\n      resolveBeforeQuitPromise()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'will-quit', () => {\r\n      this.killAllProcesses()\r\n      this.deleteSocketFile()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-file', (event, pathToOpen) => {\r\n      event.preventDefault()\r\n      this.openPath({pathToOpen})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-url', (event, urlToOpen) => {\r\n      event.preventDefault()\r\n      this.openUrl({urlToOpen, devMode: this.devMode, safeMode: this.safeMode})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'activate', (event, hasVisibleWindows) => {\r\n      if (hasVisibleWindows) return\r\n      if (event) event.preventDefault()\r\n      this.emit('application:new-window')\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'restart-application', () => {\r\n      this.restart()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'resolve-proxy', (event, requestId, url) => {\r\n      event.sender.session.resolveProxy(url, proxy => {\r\n        if (!event.sender.isDestroyed()) event.sender.send('did-resolve-proxy', requestId, proxy)\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-history-manager', event => {\r\n      for (let atomWindow of this.getAllWindows()) {\r\n        const {webContents} = atomWindow.browserWindow\r\n        if (webContents !== event.sender) webContents.send('did-change-history-manager')\r\n      }\r\n    }))\r\n\r\n    // A request from the associated render process to open a new render process.\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open', (event, options) => {\r\n      const window = this.atomWindowForEvent(event)\r\n      if (options) {\r\n        if (typeof options.pathsToOpen === 'string') {\r\n          options.pathsToOpen = [options.pathsToOpen]\r\n        }\r\n\r\n        if (options.pathsToOpen && options.pathsToOpen.length > 0) {\r\n          options.window = window\r\n          this.openPaths(options)\r\n        } else {\r\n          this.addWindow(new AtomWindow(this, this.fileRecoveryService, options))\r\n        }\r\n      } else {\r\n        this.promptForPathToOpen('all', {window})\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'update-application-menu', (event, template, menu) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      if (this.applicationMenu) this.applicationMenu.update(window, template, menu)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-package-specs', (event, packageSpecPath, options = {}) => {\r\n      this.runTests(Object.assign({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [packageSpecPath],\r\n        headless: false\r\n      }, options))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-benchmarks', (event, benchmarksPath) => {\r\n      this.runBenchmarks({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [benchmarksPath],\r\n        headless: false,\r\n        test: false\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'command', (event, command) => {\r\n      this.emit(command)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open-command', (event, command, defaultPath) => {\r\n      switch (command) {\r\n        case 'application:open':\r\n          return this.promptForPathToOpen('all', getLoadSettings(), defaultPath)\r\n        case 'application:open-file':\r\n          return this.promptForPathToOpen('file', getLoadSettings(), defaultPath)\r\n        case 'application:open-folder':\r\n          return this.promptForPathToOpen('folder', getLoadSettings(), defaultPath)\r\n        default:\r\n          return console.log(`Invalid open-command received: ${command}`)\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'window-command', (event, command, ...args) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      return window.emit(command, ...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('window-method', (browserWindow, method, ...args) => {\r\n      const window = this.atomWindowForBrowserWindow(browserWindow)\r\n      if (window) window[method](...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'pick-folder', (event, responseChannel) => {\r\n      this.promptForPath('folder', paths => event.sender.send(responseChannel, paths))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-size', (window, width, height) => {\r\n      window.setSize(width, height)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-position', (window, x, y) => {\r\n      window.setPosition(x, y)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-user-settings', (window, settings, filePath) => {\r\n      if (!this.quitting) {\r\n        return ConfigFile.at(filePath || this.configFilePath).update(JSON.parse(settings))\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('center-window', window => window.center()))\r\n    this.disposable.add(ipcHelpers.respondTo('focus-window', window => window.focus()))\r\n    this.disposable.add(ipcHelpers.respondTo('show-window', window => window.show()))\r\n    this.disposable.add(ipcHelpers.respondTo('hide-window', window => window.hide()))\r\n    this.disposable.add(ipcHelpers.respondTo('get-temporary-window-state', window => window.temporaryState))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-temporary-window-state', (win, state) => {\r\n      win.temporaryState = state\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-text-to-selection-clipboard', (event, text) =>\r\n      clipboard.writeText(text, 'selection')\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stdout', (event, output) =>\r\n      process.stdout.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stderr', (event, output) =>\r\n      process.stderr.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'add-recent-document', (event, filename) =>\r\n      app.addRecentDocument(filename)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'execute-javascript-in-dev-tools', (event, code) =>\r\n      event.sender.devToolsWebContents && event.sender.devToolsWebContents.executeJavaScript(code)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-state', event => {\r\n      event.returnValue = this.autoUpdateManager.getState()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-error', event => {\r\n      event.returnValue = this.autoUpdateManager.getErrorMessage()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('will-save-path', (window, path) =>\r\n      this.fileRecoveryService.willSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('did-save-path', (window, path) =>\r\n      this.fileRecoveryService.didSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-paths', () =>\r\n      this.saveCurrentWindowOptions(false)\r\n    ))\r\n\r\n    this.disposable.add(this.disableZoomOnDisplayChange())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.openPathOnEvent","start_line":720,"end_line":729,"comment":[" Public: Open the given path in the focused window when the event is"," triggered.",""," A new window will be created if there is no currently focused window.",""," eventName - The event to listen for."," pathToOpen - The path to open when the event is triggered."],"params":["eventName","pathToOpen"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"disableZoomOnDisplayChange","line":633,"func_location":"AtomApplication.handleEvents","func_start_line":364,"func_end_line":634,"args":[null],"comment":[" Registers basic application commands, non-idempotent."],"code":"  handleEvents () {\r\n    const getLoadSettings = () => {\r\n      const window = this.focusedWindow()\r\n      return {devMode: window && window.devMode, safeMode: window && window.safeMode}\r\n    }\r\n\r\n    this.on('application:quit', () => app.quit())\r\n    this.on('application:new-window', () => this.openPath(getLoadSettings()))\r\n    this.on('application:new-file', () => (this.focusedWindow() || this).openPath())\r\n    this.on('application:open-dev', () => this.promptForPathToOpen('all', {devMode: true}))\r\n    this.on('application:open-safe', () => this.promptForPathToOpen('all', {safeMode: true}))\r\n    this.on('application:inspect', ({x, y, atomWindow}) => {\r\n      if (!atomWindow) atomWindow = this.focusedWindow()\r\n      if (atomWindow) atomWindow.browserWindow.inspectElement(x, y)\r\n    })\r\n\r\n    this.on('application:open-documentation', () => shell.openExternal('http://flight-manual.atom.io'))\r\n    this.on('application:open-discussions', () => shell.openExternal('https://discuss.atom.io'))\r\n    this.on('application:open-faq', () => shell.openExternal('https://atom.io/faq'))\r\n    this.on('application:open-terms-of-use', () => shell.openExternal('https://atom.io/terms'))\r\n    this.on('application:report-issue', () => shell.openExternal('https://github.com/atom/atom/blob/master/CONTRIBUTING.md#reporting-bugs'))\r\n    this.on('application:search-issues', () => shell.openExternal('https://github.com/search?q=+is%3Aissue+user%3Aatom'))\r\n\r\n    this.on('application:install-update', () => {\r\n      this.quitting = true\r\n      this.autoUpdateManager.install()\r\n    })\r\n\r\n    this.on('application:check-for-update', () => this.autoUpdateManager.check())\r\n\r\n    if (process.platform === 'darwin') {\r\n      this.on('application:bring-all-windows-to-front', () => Menu.sendActionToFirstResponder('arrangeInFront:'))\r\n      this.on('application:hide', () => Menu.sendActionToFirstResponder('hide:'))\r\n      this.on('application:hide-other-applications', () => Menu.sendActionToFirstResponder('hideOtherApplications:'))\r\n      this.on('application:minimize', () => Menu.sendActionToFirstResponder('performMiniaturize:'))\r\n      this.on('application:unhide-all-applications', () => Menu.sendActionToFirstResponder('unhideAllApplications:'))\r\n      this.on('application:zoom', () => Menu.sendActionToFirstResponder('zoom:'))\r\n    } else {\r\n      this.on('application:minimize', () => {\r\n        const window = this.focusedWindow()\r\n        if (window) window.minimize()\r\n      })\r\n      this.on('application:zoom', function () {\r\n        const window = this.focusedWindow()\r\n        if (window) window.maximize()\r\n      })\r\n    }\r\n\r\n    this.openPathOnEvent('application:about', 'atom://about')\r\n    this.openPathOnEvent('application:show-settings', 'atom://config')\r\n    this.openPathOnEvent('application:open-your-config', 'atom://.atom/config')\r\n    this.openPathOnEvent('application:open-your-init-script', 'atom://.atom/init-script')\r\n    this.openPathOnEvent('application:open-your-keymap', 'atom://.atom/keymap')\r\n    this.openPathOnEvent('application:open-your-snippets', 'atom://.atom/snippets')\r\n    this.openPathOnEvent('application:open-your-stylesheet', 'atom://.atom/stylesheet')\r\n    this.openPathOnEvent('application:open-license', path.join(process.resourcesPath, 'LICENSE.md'))\r\n\r\n    this.configFile.onDidChange(settings => {\r\n      for (let window of this.getAllWindows()) {\r\n        window.didChangeUserSettings(settings)\r\n      }\r\n      this.config.resetUserSettings(settings)\r\n    })\r\n\r\n    this.configFile.onDidError(message => {\r\n      const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n      if (window) window.didFailToReadUserSettings(message)\r\n    })\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'before-quit', async event => {\r\n      let resolveBeforeQuitPromise\r\n      this.lastBeforeQuitPromise = new Promise(resolve => { resolveBeforeQuitPromise = resolve })\r\n\r\n      if (!this.quitting) {\r\n        this.quitting = true\r\n        event.preventDefault()\r\n        const windowUnloadPromises = this.getAllWindows().map(async window => {\r\n          const unloaded = await window.prepareToUnload()\r\n          if (unloaded) {\r\n            window.close()\r\n            await window.closedPromise\r\n          }\r\n          return unloaded\r\n        })\r\n        const windowUnloadedResults = await Promise.all(windowUnloadPromises)\r\n        if (windowUnloadedResults.every(Boolean)) {\r\n          app.quit()\r\n        } else {\r\n          this.quitting = false\r\n        }\r\n      }\r\n\r\n      resolveBeforeQuitPromise()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'will-quit', () => {\r\n      this.killAllProcesses()\r\n      this.deleteSocketFile()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-file', (event, pathToOpen) => {\r\n      event.preventDefault()\r\n      this.openPath({pathToOpen})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-url', (event, urlToOpen) => {\r\n      event.preventDefault()\r\n      this.openUrl({urlToOpen, devMode: this.devMode, safeMode: this.safeMode})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'activate', (event, hasVisibleWindows) => {\r\n      if (hasVisibleWindows) return\r\n      if (event) event.preventDefault()\r\n      this.emit('application:new-window')\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'restart-application', () => {\r\n      this.restart()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'resolve-proxy', (event, requestId, url) => {\r\n      event.sender.session.resolveProxy(url, proxy => {\r\n        if (!event.sender.isDestroyed()) event.sender.send('did-resolve-proxy', requestId, proxy)\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-history-manager', event => {\r\n      for (let atomWindow of this.getAllWindows()) {\r\n        const {webContents} = atomWindow.browserWindow\r\n        if (webContents !== event.sender) webContents.send('did-change-history-manager')\r\n      }\r\n    }))\r\n\r\n    // A request from the associated render process to open a new render process.\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open', (event, options) => {\r\n      const window = this.atomWindowForEvent(event)\r\n      if (options) {\r\n        if (typeof options.pathsToOpen === 'string') {\r\n          options.pathsToOpen = [options.pathsToOpen]\r\n        }\r\n\r\n        if (options.pathsToOpen && options.pathsToOpen.length > 0) {\r\n          options.window = window\r\n          this.openPaths(options)\r\n        } else {\r\n          this.addWindow(new AtomWindow(this, this.fileRecoveryService, options))\r\n        }\r\n      } else {\r\n        this.promptForPathToOpen('all', {window})\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'update-application-menu', (event, template, menu) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      if (this.applicationMenu) this.applicationMenu.update(window, template, menu)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-package-specs', (event, packageSpecPath, options = {}) => {\r\n      this.runTests(Object.assign({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [packageSpecPath],\r\n        headless: false\r\n      }, options))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-benchmarks', (event, benchmarksPath) => {\r\n      this.runBenchmarks({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [benchmarksPath],\r\n        headless: false,\r\n        test: false\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'command', (event, command) => {\r\n      this.emit(command)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open-command', (event, command, defaultPath) => {\r\n      switch (command) {\r\n        case 'application:open':\r\n          return this.promptForPathToOpen('all', getLoadSettings(), defaultPath)\r\n        case 'application:open-file':\r\n          return this.promptForPathToOpen('file', getLoadSettings(), defaultPath)\r\n        case 'application:open-folder':\r\n          return this.promptForPathToOpen('folder', getLoadSettings(), defaultPath)\r\n        default:\r\n          return console.log(`Invalid open-command received: ${command}`)\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'window-command', (event, command, ...args) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      return window.emit(command, ...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('window-method', (browserWindow, method, ...args) => {\r\n      const window = this.atomWindowForBrowserWindow(browserWindow)\r\n      if (window) window[method](...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'pick-folder', (event, responseChannel) => {\r\n      this.promptForPath('folder', paths => event.sender.send(responseChannel, paths))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-size', (window, width, height) => {\r\n      window.setSize(width, height)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-position', (window, x, y) => {\r\n      window.setPosition(x, y)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-user-settings', (window, settings, filePath) => {\r\n      if (!this.quitting) {\r\n        return ConfigFile.at(filePath || this.configFilePath).update(JSON.parse(settings))\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('center-window', window => window.center()))\r\n    this.disposable.add(ipcHelpers.respondTo('focus-window', window => window.focus()))\r\n    this.disposable.add(ipcHelpers.respondTo('show-window', window => window.show()))\r\n    this.disposable.add(ipcHelpers.respondTo('hide-window', window => window.hide()))\r\n    this.disposable.add(ipcHelpers.respondTo('get-temporary-window-state', window => window.temporaryState))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-temporary-window-state', (win, state) => {\r\n      win.temporaryState = state\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-text-to-selection-clipboard', (event, text) =>\r\n      clipboard.writeText(text, 'selection')\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stdout', (event, output) =>\r\n      process.stdout.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stderr', (event, output) =>\r\n      process.stderr.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'add-recent-document', (event, filename) =>\r\n      app.addRecentDocument(filename)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'execute-javascript-in-dev-tools', (event, code) =>\r\n      event.sender.devToolsWebContents && event.sender.devToolsWebContents.executeJavaScript(code)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-state', event => {\r\n      event.returnValue = this.autoUpdateManager.getState()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-error', event => {\r\n      event.returnValue = this.autoUpdateManager.getErrorMessage()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('will-save-path', (window, path) =>\r\n      this.fileRecoveryService.willSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('did-save-path', (window, path) =>\r\n      this.fileRecoveryService.didSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-paths', () =>\r\n      this.saveCurrentWindowOptions(false)\r\n    ))\r\n\r\n    this.disposable.add(this.disableZoomOnDisplayChange())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.disableZoomOnDisplayChange","start_line":1372,"end_line":1386,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js","name":"eachTabIndexedElement","line":140,"func_location":"WindowEventHandler.handleFocusNext","func_start_line":133,"func_end_line":157},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js","name":"WindowEventHandler.eachTabIndexedElement","start_line":125,"end_line":131,"comment":[],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js","name":"eachTabIndexedElement","line":166,"func_location":"WindowEventHandler.handleFocusPrevious","func_start_line":159,"func_end_line":183},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js","name":"WindowEventHandler.eachTabIndexedElement","start_line":125,"end_line":131,"comment":[],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"handleMouseUp","line":280,"func_location":"Dock.handleMouseMove","func_start_line":278,"func_end_line":297,"args":["event"],"code":"  handleMouseMove (event) {\r\n    if (event.buttons === 0) { // We missed the mouseup event. For some reason it happens on Windows\r\n      this.handleMouseUp(event)\r\n      return\r\n    }\r\n\r\n    let size = 0\r\n    switch (this.location) {\r\n      case 'left':\r\n        size = event.pageX - this.element.getBoundingClientRect().left\r\n        break\r\n      case 'bottom':\r\n        size = this.element.getBoundingClientRect().bottom - event.pageY\r\n        break\r\n      case 'right':\r\n        size = this.element.getBoundingClientRect().right - event.pageX\r\n        break\r\n    }\r\n    this.setState({size})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.handleMouseUp","start_line":299,"end_line":303,"comment":[],"params":["event"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"setState","line":296,"func_location":"Dock.handleMouseMove","func_start_line":278,"func_end_line":297,"args":[null],"code":"  handleMouseMove (event) {\r\n    if (event.buttons === 0) { // We missed the mouseup event. For some reason it happens on Windows\r\n      this.handleMouseUp(event)\r\n      return\r\n    }\r\n\r\n    let size = 0\r\n    switch (this.location) {\r\n      case 'left':\r\n        size = event.pageX - this.element.getBoundingClientRect().left\r\n        break\r\n      case 'bottom':\r\n        size = this.element.getBoundingClientRect().bottom - event.pageY\r\n        break\r\n      case 'right':\r\n        size = this.element.getBoundingClientRect().right - event.pageX\r\n        break\r\n    }\r\n    this.setState({size})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.setState","start_line":144,"end_line":177,"comment":[],"params":["newState"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"setState","line":302,"func_location":"Dock.handleMouseUp","func_start_line":299,"func_end_line":303,"args":[null],"code":"  handleMouseUp (event) {\r\n    window.removeEventListener('mousemove', this.handleMouseMove)\r\n    window.removeEventListener('mouseup', this.handleMouseUp)\r\n    this.setState({resizing: false})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.setState","start_line":144,"end_line":177,"comment":[],"params":["newState"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"setState","line":267,"func_location":"Dock.handleResizeHandleDragStart","func_start_line":264,"func_end_line":268,"args":[null],"code":"  handleResizeHandleDragStart () {\r\n    window.addEventListener('mousemove', this.handleMouseMove)\r\n    window.addEventListener('mouseup', this.handleMouseUp)\r\n    this.setState({resizing: true})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.setState","start_line":144,"end_line":177,"comment":[],"params":["newState"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"getActivePaneItem","line":271,"func_location":"Dock.handleResizeToFit","func_start_line":270,"func_end_line":276,"args":[],"code":"  handleResizeToFit () {\r\n    const item = this.getActivePaneItem()\r\n    if (item) {\r\n      const size = getPreferredSize(item, this.getLocation())\r\n      if (size != null) this.setState({size})\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.getActivePaneItem","start_line":649,"end_line":651,"comment":[" Essential: Get the active {Pane}'s active item.",""," Returns an pane item {Object}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"getPreferredSize","line":273,"func_location":"Dock.handleResizeToFit","func_start_line":270,"func_end_line":276,"args":["item",null],"code":"  handleResizeToFit () {\r\n    const item = this.getActivePaneItem()\r\n    if (item) {\r\n      const size = getPreferredSize(item, this.getLocation())\r\n      if (size != null) this.setState({size})\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"getPreferredSize","start_line":825,"end_line":837,"comment":[],"params":["item","location"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"getLocation","line":273,"func_location":"Dock.handleResizeToFit","func_start_line":270,"func_end_line":276,"args":["item",null],"code":"  handleResizeToFit () {\r\n    const item = this.getActivePaneItem()\r\n    if (item) {\r\n      const size = getPreferredSize(item, this.getLocation())\r\n      if (size != null) this.setState({size})\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.getLocation","start_line":90,"end_line":92,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"setState","line":274,"func_location":"Dock.handleResizeToFit","func_start_line":270,"func_end_line":276,"args":[null],"code":"  handleResizeToFit () {\r\n    const item = this.getActivePaneItem()\r\n    if (item) {\r\n      const size = getPreferredSize(item, this.getLocation())\r\n      if (size != null) this.setState({size})\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.setState","start_line":144,"end_line":177,"comment":[],"params":["newState"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"isSpecWindow","line":363,"func_location":"AtomWindow.handlesAtomCommands","func_start_line":362,"func_end_line":364,"args":[],"code":"  handlesAtomCommands () {\r\n    return !this.isSpecWindow() && this.isWebViewFocused()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"AtomWindow.isSpecWindow","start_line":382,"end_line":384,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"isWebViewFocused","line":363,"func_location":"AtomWindow.handlesAtomCommands","func_start_line":362,"func_end_line":364,"args":[],"code":"  handlesAtomCommands () {\r\n    return !this.isSpecWindow() && this.isWebViewFocused()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"AtomWindow.isWebViewFocused","start_line":378,"end_line":380,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getMessageForErrorCode","line":1228,"func_location":"Pane.handleSaveError","func_start_line":1221,"func_end_line":1244,"args":["error.code"],"code":"  handleSaveError (error, item) {\r\n    const itemPath = error.path || (typeof item.getPath === 'function' && item.getPath())\r\n    const addWarningWithPath = (message, options) => {\r\n      if (itemPath) message = `${message} '${itemPath}'`\r\n      this.notificationManager.addWarning(message, options)\r\n    }\r\n\r\n    const customMessage = this.getMessageForErrorCode(error.code)\r\n    if (customMessage != null) {\r\n      addWarningWithPath(`Unable to save file: ${customMessage}`)\r\n    } else if (error.code === 'EISDIR' || (error.message && error.message.endsWith('is a directory'))) {\r\n      return this.notificationManager.addWarning(`Unable to save file: ${error.message}`)\r\n    } else if (['EPERM', 'EBUSY', 'UNKNOWN', 'EEXIST', 'ELOOP', 'EAGAIN'].includes(error.code)) {\r\n      addWarningWithPath('Unable to save file', {detail: error.message})\r\n    } else {\r\n      const errorMatch = /ENOTDIR, not a directory '([^']+)'/.exec(error.message)\r\n      if (errorMatch) {\r\n        const fileName = errorMatch[1]\r\n        this.notificationManager.addWarning(`Unable to save file: A directory in the path '${fileName}' could not be written to`)\r\n      } else {\r\n        throw error\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getMessageForErrorCode","start_line":1246,"end_line":1259,"comment":[],"params":["errorCode"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"setState","line":306,"func_location":"Dock.handleToggleButtonDragEnter","func_start_line":305,"func_end_line":309,"args":[null],"code":"  handleToggleButtonDragEnter () {\r\n    this.setState({showDropTarget: true})\r\n    window.addEventListener('drag', this.handleDrag)\r\n    window.addEventListener('dragend', this.handleDragEnd)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.setState","start_line":144,"end_line":177,"comment":[],"params":["newState"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"activate","line":420,"func_location":"Package.handleURI","func_start_line":419,"func_end_line":424,"args":[],"code":"  handleURI (methodName, args) {\r\n    this.activate().then(() => {\r\n      if (this.mainModule[methodName]) this.mainModule[methodName].apply(this.mainModule, args)\r\n    })\r\n    if (!this.mainActivated) this.activateNow()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.activate","start_line":189,"end_line":210,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"activateNow","line":423,"func_location":"Package.handleURI","func_start_line":419,"func_end_line":424,"args":[],"code":"  handleURI (methodName, args) {\r\n    this.activate().then(() => {\r\n      if (this.mainModule[methodName]) this.mainModule[methodName].apply(this.mainModule, args)\r\n    })\r\n    if (!this.mainActivated) this.activateNow()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.activateNow","start_line":212,"end_line":236,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"getActivationCommands","line":815,"func_location":"Package.hasActivationCommands","func_start_line":814,"func_end_line":821,"args":[],"code":"  hasActivationCommands () {\r\n    const object = this.getActivationCommands()\r\n    for (let selector in object) {\r\n      const commands = object[selector]\r\n      if (commands.length > 0) return true\r\n    }\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.getActivationCommands","start_line":870,"end_line":888,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"getActivationHooks","line":810,"func_location":"Package.hasActivationHooks","func_start_line":809,"func_end_line":812,"args":[],"code":"  hasActivationHooks () {\r\n    const hooks = this.getActivationHooks()\r\n    return hooks && hooks.length > 0\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.getActivationHooks","start_line":901,"end_line":917,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"loadPackageMetadata","line":433,"func_location":"PackageManager.hasAtomEngine","func_start_line":432,"func_end_line":435,"args":["packagePath",{"type":"boolean"}],"code":"  hasAtomEngine (packagePath) {\r\n    const metadata = this.loadPackageMetadata(packagePath, true)\r\n    return metadata != null && metadata.engines != null && metadata.engines.atom != null\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.loadPackageMetadata","start_line":839,"end_line":882,"comment":[],"params":["packagePathOrAvailablePackage","ignoreErrors"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getReferenceTarget","line":214,"func_location":"GitRepository.hasBranch","func_start_line":213,"func_end_line":215,"args":[null],"comment":[" Public: Returns true if the given branch exists."],"code":"  hasBranch (branch) {\r\n    return this.getReferenceTarget(`refs/heads/${branch}`) != null\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getReferenceTarget","start_line":317,"end_line":319,"comment":[" Public: Returns the current {String} SHA for the given reference.",""," * `reference` The {String} reference to get the target of."," * `path` An optional {String} path in the repo to get the reference target","   for. Only needed if the repository contains submodules."],"params":["reference","path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"getURIHandler","line":824,"func_location":"Package.hasDeferredURIHandler","func_start_line":823,"func_end_line":826,"args":[],"code":"  hasDeferredURIHandler () {\r\n    const handler = this.getURIHandler()\r\n    return handler && handler.deferActivation !== false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.getURIHandler","start_line":919,"end_line":921,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":215,"func_location":"TextEditorElement.hasFocus","func_start_line":214,"func_end_line":216,"args":[],"code":"  hasFocus () {\r\n    return this.getComponent().focused\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferPosition","line":211,"func_location":"Cursor.hasPrecedingCharactersOnLine","func_start_line":210,"func_end_line":220,"args":[],"comment":[" Public: Returns true if this cursor has no non-whitespace characters before"," its current position."],"code":"  hasPrecedingCharactersOnLine () {\r\n    const bufferPosition = this.getBufferPosition()\r\n    const line = this.editor.lineTextForBufferRow(bufferPosition.row)\r\n    const firstCharacterColumn = line.search(/\\S/)\r\n\r\n    if (firstCharacterColumn === -1) {\r\n      return false\r\n    } else {\r\n      return bufferPosition.column > firstCharacterColumn\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferPosition","start_line":91,"end_line":93,"comment":[" Public: Returns the current buffer position as an Array."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelPositionAfterBlocksForRow","line":2355,"func_location":"TextEditorComponent.heightForBlockDecorationsAfterRow","func_start_line":2354,"func_end_line":2358,"args":["row"],"code":"  heightForBlockDecorationsAfterRow (row) {\r\n    const currentRowBottom = this.pixelPositionAfterBlocksForRow(row) + this.getLineHeight()\r\n    const nextRowTop = this.pixelPositionBeforeBlocksForRow(row + 1)\r\n    return nextRowTop - currentRowBottom\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelPositionAfterBlocksForRow","start_line":2364,"end_line":2366,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getLineHeight","line":2355,"func_location":"TextEditorComponent.heightForBlockDecorationsAfterRow","func_start_line":2354,"func_end_line":2358,"args":["row"],"code":"  heightForBlockDecorationsAfterRow (row) {\r\n    const currentRowBottom = this.pixelPositionAfterBlocksForRow(row) + this.getLineHeight()\r\n    const nextRowTop = this.pixelPositionBeforeBlocksForRow(row + 1)\r\n    return nextRowTop - currentRowBottom\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getLineHeight","start_line":2600,"end_line":2602,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelPositionBeforeBlocksForRow","line":2356,"func_location":"TextEditorComponent.heightForBlockDecorationsAfterRow","func_start_line":2354,"func_end_line":2358,"args":[null],"code":"  heightForBlockDecorationsAfterRow (row) {\r\n    const currentRowBottom = this.pixelPositionAfterBlocksForRow(row) + this.getLineHeight()\r\n    const nextRowTop = this.pixelPositionBeforeBlocksForRow(row + 1)\r\n    return nextRowTop - currentRowBottom\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelPositionBeforeBlocksForRow","start_line":2360,"end_line":2362,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelPositionAfterBlocksForRow","line":2351,"func_location":"TextEditorComponent.heightForBlockDecorationsBeforeRow","func_start_line":2350,"func_end_line":2352,"args":["row"],"code":"  heightForBlockDecorationsBeforeRow (row) {\r\n    return this.pixelPositionAfterBlocksForRow(row) - this.pixelPositionBeforeBlocksForRow(row)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelPositionAfterBlocksForRow","start_line":2364,"end_line":2366,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelPositionBeforeBlocksForRow","line":2351,"func_location":"TextEditorComponent.heightForBlockDecorationsBeforeRow","func_start_line":2350,"func_end_line":2352,"args":["row"],"code":"  heightForBlockDecorationsBeforeRow (row) {\r\n    return this.pixelPositionAfterBlocksForRow(row) - this.pixelPositionBeforeBlocksForRow(row)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelPositionBeforeBlocksForRow","start_line":2360,"end_line":2362,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getPaneContainers","line":1091,"func_location":"Workspace.hide","func_start_line":1087,"func_end_line":1116,"args":[],"comment":[" Essential: Search the workspace for items matching the given URI and hide them.",""," * `itemOrURI` The item to hide or a {String} containing the URI","   of the item to hide.",""," Returns a {Boolean} indicating whether any items were found (and hidden)."],"code":"  hide (itemOrURI) {\r\n    let foundItems = false\r\n\r\n    // If any visible item has the given URI, hide it\r\n    for (const container of this.getPaneContainers()) {\r\n      const isCenter = container === this.getCenter()\r\n      if (isCenter || container.isVisible()) {\r\n        for (const pane of container.getPanes()) {\r\n          const activeItem = pane.getActiveItem()\r\n          const foundItem = (\r\n            activeItem != null && (\r\n              activeItem === itemOrURI ||\r\n              typeof activeItem.getURI === 'function' && activeItem.getURI() === itemOrURI\r\n            )\r\n          )\r\n          if (foundItem) {\r\n            foundItems = true\r\n            // We can't really hide the center so we just destroy the item.\r\n            if (isCenter) {\r\n              pane.destroyItem(activeItem)\r\n            } else {\r\n              container.hide()\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return foundItems\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getPaneContainers","start_line":1618,"end_line":1625,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getCenter","line":1092,"func_location":"Workspace.hide","func_start_line":1087,"func_end_line":1116,"args":[],"comment":[" Essential: Search the workspace for items matching the given URI and hide them.",""," * `itemOrURI` The item to hide or a {String} containing the URI","   of the item to hide.",""," Returns a {Boolean} indicating whether any items were found (and hidden)."],"code":"  hide (itemOrURI) {\r\n    let foundItems = false\r\n\r\n    // If any visible item has the given URI, hide it\r\n    for (const container of this.getPaneContainers()) {\r\n      const isCenter = container === this.getCenter()\r\n      if (isCenter || container.isVisible()) {\r\n        for (const pane of container.getPanes()) {\r\n          const activeItem = pane.getActiveItem()\r\n          const foundItem = (\r\n            activeItem != null && (\r\n              activeItem === itemOrURI ||\r\n              typeof activeItem.getURI === 'function' && activeItem.getURI() === itemOrURI\r\n            )\r\n          )\r\n          if (foundItem) {\r\n            foundItems = true\r\n            // We can't really hide the center so we just destroy the item.\r\n            if (isCenter) {\r\n              pane.destroyItem(activeItem)\r\n            } else {\r\n              container.hide()\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return foundItems\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getCenter","start_line":1599,"end_line":1601,"comment":["\r\n  Section: Pane Locations\r\n  "," Essential: Get the {WorkspaceCenter} at the center of the editor window."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"setState","line":126,"func_location":"Dock.hide","func_start_line":125,"func_end_line":127,"args":[null],"comment":[" Extended: Hide the dock and activate the {WorkspaceCenter} if the dock was"," was previously focused."],"code":"  hide () {\r\n    this.setState({visible: false})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.setState","start_line":144,"end_line":177,"comment":[],"params":["newState"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"regexForPattern","line":698,"func_location":"TextMateLanguageMode.increaseIndentRegexForScopeDescriptor","func_start_line":697,"func_end_line":699,"args":[null],"code":"  increaseIndentRegexForScopeDescriptor (scope) {\r\n    return this.regexForPattern(this.config.get('editor.increaseIndentPattern', {scope}))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.regexForPattern","start_line":713,"end_line":720,"comment":[],"params":["pattern"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getContainer","line":159,"func_location":"Pane.increaseSize","func_start_line":158,"func_end_line":162,"args":[],"code":"  increaseSize () {\r\n    if (this.getContainer().getPanes().length > 1) {\r\n      this.setFlexScale(this.getFlexScale() * 1.1)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getContainer","start_line":128,"end_line":128,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"setFlexScale","line":160,"func_location":"Pane.increaseSize","func_start_line":158,"func_end_line":162,"args":[null],"code":"  increaseSize () {\r\n    if (this.getContainer().getPanes().length > 1) {\r\n      this.setFlexScale(this.getFlexScale() * 1.1)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.setFlexScale","start_line":150,"end_line":154,"comment":[],"params":["flexScale"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getFlexScale","line":160,"func_location":"Pane.increaseSize","func_start_line":158,"func_end_line":162,"args":[null],"code":"  increaseSize () {\r\n    if (this.getContainer().getPanes().length > 1) {\r\n      this.setFlexScale(this.getFlexScale() * 1.1)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getFlexScale","start_line":156,"end_line":156,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"getLoadSettings","line":457,"func_location":"AtomEnvironment.inDevMode","func_start_line":456,"func_end_line":459,"args":[],"comment":["\r\n  Section: Atom Details\r\n  "," Public: Returns a {Boolean} that is `true` if the current window is in development mode."],"code":"  inDevMode () {\r\n    if (this.devMode == null) this.devMode = this.getLoadSettings().devMode\r\n    return this.devMode\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.getLoadSettings","start_line":525,"end_line":527,"comment":[" Public: Get the load settings for the current window.",""," Returns an {Object} containing all the load setting key/value pairs."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip.js","name":"extend","line":104,"func_location":"Tooltip.prototype.init","func_start_line":44,"func_end_line":106,"args":[null,".options",null],"code":"Tooltip.prototype.init = function (element, options) {\r\n  this.enabled = true\r\n  this.element = element\r\n  this.options = this.getOptions(options)\r\n  this.disposables = new EventKit.CompositeDisposable()\r\n  this.mutationObserver = new MutationObserver(this.handleMutations.bind(this))\r\n\r\n  if (this.options.viewport) {\r\n    if (typeof this.options.viewport === 'function') {\r\n      this.viewport = this.options.viewport.call(this, this.element)\r\n    } else {\r\n      this.viewport = document.querySelector(this.options.viewport.selector || this.options.viewport)\r\n    }\r\n  }\r\n  this.inState = {click: false, hover: false, focus: false}\r\n\r\n  if (this.element instanceof document.constructor && !this.options.selector) {\r\n    throw new Error('`selector` option must be specified when initializing tooltip on the window.document object!')\r\n  }\r\n\r\n  var triggers = this.options.trigger.split(' ')\r\n\r\n  for (var i = triggers.length; i--;) {\r\n    var trigger = triggers[i]\r\n\r\n    if (trigger === 'click') {\r\n      this.disposables.add(listen(this.element, 'click', this.options.selector, this.toggle.bind(this)))\r\n      this.hideOnClickOutsideOfTooltip = (event) => {\r\n        const tooltipElement = this.getTooltipElement()\r\n        if (tooltipElement === event.target) return\r\n        if (tooltipElement.contains(event.target)) return\r\n        if (this.element === event.target) return\r\n        if (this.element.contains(event.target)) return\r\n        this.hide()\r\n      }\r\n    } else if (trigger === 'manual') {\r\n      this.show()\r\n    } else {\r\n      var eventIn, eventOut\r\n\r\n      if (trigger === 'hover') {\r\n        this.hideOnKeydownOutsideOfTooltip = () => this.hide()\r\n        if (this.options.selector) {\r\n          eventIn = 'mouseover'\r\n          eventOut = 'mouseout'\r\n        } else {\r\n          eventIn = 'mouseenter'\r\n          eventOut = 'mouseleave'\r\n        }\r\n      } else {\r\n        eventIn = 'focusin'\r\n        eventOut = 'focusout'\r\n      }\r\n\r\n      this.disposables.add(listen(this.element, eventIn, this.options.selector, this.enter.bind(this)))\r\n      this.disposables.add(listen(this.element, eventOut, this.options.selector, this.leave.bind(this)))\r\n    }\r\n  }\r\n\r\n  this.options.selector\r\n    ? (this._options = extend({}, this.options, { trigger: 'manual', selector: '' }))\r\n    : this.fixTitle()\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip.js","name":"extend","start_line":550,"end_line":561,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"scheduleUpdateCheck","line":79,"func_location":"AutoUpdateManager.initialize","func_start_line":27,"func_end_line":90,"args":[{"type":"string"}],"code":"  initialize () {\r\n    if (process.platform === 'win32') {\r\n      const archSuffix = process.arch === 'ia32' ? '' : `-${process.arch}`\r\n      this.feedUrl = `https://atom.io/api/updates${archSuffix}?version=${this.version}`\r\n      autoUpdater = require('./auto-updater-win32')\r\n    } else {\r\n      this.feedUrl = `https://atom.io/api/updates?version=${this.version}`;\r\n      ({autoUpdater} = require('electron'))\r\n    }\r\n\r\n    autoUpdater.on('error', (event, message) => {\r\n      this.setState(ErrorState, message)\r\n      this.emitWindowEvent('update-error')\r\n      console.error(`Error Downloading Update: ${message}`)\r\n    })\r\n\r\n    autoUpdater.setFeedURL(this.feedUrl)\r\n\r\n    autoUpdater.on('checking-for-update', () => {\r\n      this.setState(CheckingState)\r\n      this.emitWindowEvent('checking-for-update')\r\n    })\r\n\r\n    autoUpdater.on('update-not-available', () => {\r\n      this.setState(NoUpdateAvailableState)\r\n      this.emitWindowEvent('update-not-available')\r\n    })\r\n\r\n    autoUpdater.on('update-available', () => {\r\n      this.setState(DownloadingState)\r\n      // We use sendMessage to send an event called 'update-available' in 'update-downloaded'\r\n      // once the update download is complete. This mismatch between the electron\r\n      // autoUpdater events is unfortunate but in the interest of not changing the\r\n      // one existing event handled by applicationDelegate\r\n      this.emitWindowEvent('did-begin-downloading-update')\r\n      this.emit('did-begin-download')\r\n    })\r\n\r\n    autoUpdater.on('update-downloaded', (event, releaseNotes, releaseVersion) => {\r\n      this.releaseVersion = releaseVersion\r\n      this.setState(UpdateAvailableState)\r\n      this.emitUpdateAvailableEvent()\r\n    })\r\n\r\n    this.config.onDidChange('core.automaticallyUpdate', ({newValue}) => {\r\n      if (newValue) {\r\n        this.scheduleUpdateCheck()\r\n      } else {\r\n        this.cancelScheduledUpdateCheck()\r\n      }\r\n    })\r\n\r\n    if (this.config.get('core.automaticallyUpdate')) this.scheduleUpdateCheck()\r\n\r\n    switch (process.platform) {\r\n      case 'win32':\r\n        if (!autoUpdater.supportsUpdates()) {\r\n          this.setState(UnsupportedState)\r\n        }\r\n        break\r\n      case 'linux':\r\n        this.setState(UnsupportedState)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"AutoUpdateManager.scheduleUpdateCheck","start_line":118,"end_line":127,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"setState","line":84,"func_location":"AutoUpdateManager.initialize","func_start_line":27,"func_end_line":90,"args":["UnsupportedState"],"code":"  initialize () {\r\n    if (process.platform === 'win32') {\r\n      const archSuffix = process.arch === 'ia32' ? '' : `-${process.arch}`\r\n      this.feedUrl = `https://atom.io/api/updates${archSuffix}?version=${this.version}`\r\n      autoUpdater = require('./auto-updater-win32')\r\n    } else {\r\n      this.feedUrl = `https://atom.io/api/updates?version=${this.version}`;\r\n      ({autoUpdater} = require('electron'))\r\n    }\r\n\r\n    autoUpdater.on('error', (event, message) => {\r\n      this.setState(ErrorState, message)\r\n      this.emitWindowEvent('update-error')\r\n      console.error(`Error Downloading Update: ${message}`)\r\n    })\r\n\r\n    autoUpdater.setFeedURL(this.feedUrl)\r\n\r\n    autoUpdater.on('checking-for-update', () => {\r\n      this.setState(CheckingState)\r\n      this.emitWindowEvent('checking-for-update')\r\n    })\r\n\r\n    autoUpdater.on('update-not-available', () => {\r\n      this.setState(NoUpdateAvailableState)\r\n      this.emitWindowEvent('update-not-available')\r\n    })\r\n\r\n    autoUpdater.on('update-available', () => {\r\n      this.setState(DownloadingState)\r\n      // We use sendMessage to send an event called 'update-available' in 'update-downloaded'\r\n      // once the update download is complete. This mismatch between the electron\r\n      // autoUpdater events is unfortunate but in the interest of not changing the\r\n      // one existing event handled by applicationDelegate\r\n      this.emitWindowEvent('did-begin-downloading-update')\r\n      this.emit('did-begin-download')\r\n    })\r\n\r\n    autoUpdater.on('update-downloaded', (event, releaseNotes, releaseVersion) => {\r\n      this.releaseVersion = releaseVersion\r\n      this.setState(UpdateAvailableState)\r\n      this.emitUpdateAvailableEvent()\r\n    })\r\n\r\n    this.config.onDidChange('core.automaticallyUpdate', ({newValue}) => {\r\n      if (newValue) {\r\n        this.scheduleUpdateCheck()\r\n      } else {\r\n        this.cancelScheduledUpdateCheck()\r\n      }\r\n    })\r\n\r\n    if (this.config.get('core.automaticallyUpdate')) this.scheduleUpdateCheck()\r\n\r\n    switch (process.platform) {\r\n      case 'win32':\r\n        if (!autoUpdater.supportsUpdates()) {\r\n          this.setState(UnsupportedState)\r\n        }\r\n        break\r\n      case 'linux':\r\n        this.setState(UnsupportedState)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"AutoUpdateManager.setState","start_line":103,"end_line":108,"comment":[],"params":["state","errorMessage"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"setState","line":88,"func_location":"AutoUpdateManager.initialize","func_start_line":27,"func_end_line":90,"args":["UnsupportedState"],"code":"  initialize () {\r\n    if (process.platform === 'win32') {\r\n      const archSuffix = process.arch === 'ia32' ? '' : `-${process.arch}`\r\n      this.feedUrl = `https://atom.io/api/updates${archSuffix}?version=${this.version}`\r\n      autoUpdater = require('./auto-updater-win32')\r\n    } else {\r\n      this.feedUrl = `https://atom.io/api/updates?version=${this.version}`;\r\n      ({autoUpdater} = require('electron'))\r\n    }\r\n\r\n    autoUpdater.on('error', (event, message) => {\r\n      this.setState(ErrorState, message)\r\n      this.emitWindowEvent('update-error')\r\n      console.error(`Error Downloading Update: ${message}`)\r\n    })\r\n\r\n    autoUpdater.setFeedURL(this.feedUrl)\r\n\r\n    autoUpdater.on('checking-for-update', () => {\r\n      this.setState(CheckingState)\r\n      this.emitWindowEvent('checking-for-update')\r\n    })\r\n\r\n    autoUpdater.on('update-not-available', () => {\r\n      this.setState(NoUpdateAvailableState)\r\n      this.emitWindowEvent('update-not-available')\r\n    })\r\n\r\n    autoUpdater.on('update-available', () => {\r\n      this.setState(DownloadingState)\r\n      // We use sendMessage to send an event called 'update-available' in 'update-downloaded'\r\n      // once the update download is complete. This mismatch between the electron\r\n      // autoUpdater events is unfortunate but in the interest of not changing the\r\n      // one existing event handled by applicationDelegate\r\n      this.emitWindowEvent('did-begin-downloading-update')\r\n      this.emit('did-begin-download')\r\n    })\r\n\r\n    autoUpdater.on('update-downloaded', (event, releaseNotes, releaseVersion) => {\r\n      this.releaseVersion = releaseVersion\r\n      this.setState(UpdateAvailableState)\r\n      this.emitUpdateAvailableEvent()\r\n    })\r\n\r\n    this.config.onDidChange('core.automaticallyUpdate', ({newValue}) => {\r\n      if (newValue) {\r\n        this.scheduleUpdateCheck()\r\n      } else {\r\n        this.cancelScheduledUpdateCheck()\r\n      }\r\n    })\r\n\r\n    if (this.config.get('core.automaticallyUpdate')) this.scheduleUpdateCheck()\r\n\r\n    switch (process.platform) {\r\n      case 'win32':\r\n        if (!autoUpdater.supportsUpdates()) {\r\n          this.setState(UnsupportedState)\r\n        }\r\n        break\r\n      case 'linux':\r\n        this.setState(UnsupportedState)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js","name":"AutoUpdateManager.setState","start_line":103,"end_line":108,"comment":[],"params":["state","errorMessage"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"initializeContent","line":103,"func_location":"WorkspaceElement.initialize","func_start_line":67,"func_end_line":140,"args":[],"code":"  initialize (model, {config, project, styleManager, viewRegistry}) {\r\n    this.handleCenterEnter = this.handleCenterEnter.bind(this)\r\n    this.handleCenterLeave = this.handleCenterLeave.bind(this)\r\n    this.handleEdgesMouseMove = _.throttle(this.handleEdgesMouseMove.bind(this), 100)\r\n    this.handleDockDragEnd = this.handleDockDragEnd.bind(this)\r\n    this.handleDragStart = this.handleDragStart.bind(this)\r\n    this.handleDragEnd = this.handleDragEnd.bind(this)\r\n    this.handleDrop = this.handleDrop.bind(this)\r\n\r\n    this.model = model\r\n    this.viewRegistry = viewRegistry\r\n    this.project = project\r\n    this.config = config\r\n    this.styleManager = styleManager\r\n    if (this.viewRegistry == null) { throw new Error('Must pass a viewRegistry parameter when initializing WorkspaceElements') }\r\n    if (this.project == null) { throw new Error('Must pass a project parameter when initializing WorkspaceElements') }\r\n    if (this.config == null) { throw new Error('Must pass a config parameter when initializing WorkspaceElements') }\r\n    if (this.styleManager == null) { throw new Error('Must pass a styleManager parameter when initializing WorkspaceElements') }\r\n\r\n    this.subscriptions = new CompositeDisposable(\r\n      new Disposable(() => {\r\n        this.paneContainer.removeEventListener('mouseenter', this.handleCenterEnter)\r\n        this.paneContainer.removeEventListener('mouseleave', this.handleCenterLeave)\r\n        window.removeEventListener('mousemove', this.handleEdgesMouseMove)\r\n        window.removeEventListener('dragend', this.handleDockDragEnd)\r\n        window.removeEventListener('dragstart', this.handleDragStart)\r\n        window.removeEventListener('dragend', this.handleDragEnd, true)\r\n        window.removeEventListener('drop', this.handleDrop, true)\r\n      }),\r\n      ...[this.model.getLeftDock(), this.model.getRightDock(), this.model.getBottomDock()]\r\n        .map(dock => dock.onDidChangeHovered(hovered => {\r\n          if (hovered) this.hoveredDock = dock\r\n          else if (dock === this.hoveredDock) this.hoveredDock = null\r\n          this.checkCleanupDockHoverEvents()\r\n        }))\r\n    )\r\n    this.initializeContent()\r\n    this.observeScrollbarStyle()\r\n    this.observeTextEditorFontConfig()\r\n\r\n    this.paneContainer = this.model.getCenter().paneContainer.getElement()\r\n    this.verticalAxis.appendChild(this.paneContainer)\r\n    this.addEventListener('focus', this.handleFocus.bind(this))\r\n\r\n    this.addEventListener('mousewheel', this.handleMousewheel.bind(this), true)\r\n    window.addEventListener('dragstart', this.handleDragStart)\r\n    window.addEventListener('mousemove', this.handleEdgesMouseMove)\r\n\r\n    this.panelContainers = {\r\n      top: this.model.panelContainers.top.getElement(),\r\n      left: this.model.panelContainers.left.getElement(),\r\n      right: this.model.panelContainers.right.getElement(),\r\n      bottom: this.model.panelContainers.bottom.getElement(),\r\n      header: this.model.panelContainers.header.getElement(),\r\n      footer: this.model.panelContainers.footer.getElement(),\r\n      modal: this.model.panelContainers.modal.getElement()\r\n    }\r\n\r\n    this.horizontalAxis.insertBefore(this.panelContainers.left, this.verticalAxis)\r\n    this.horizontalAxis.appendChild(this.panelContainers.right)\r\n\r\n    this.verticalAxis.insertBefore(this.panelContainers.top, this.paneContainer)\r\n    this.verticalAxis.appendChild(this.panelContainers.bottom)\r\n\r\n    this.insertBefore(this.panelContainers.header, this.horizontalAxis)\r\n    this.appendChild(this.panelContainers.footer)\r\n\r\n    this.appendChild(this.panelContainers.modal)\r\n\r\n    this.paneContainer.addEventListener('mouseenter', this.handleCenterEnter)\r\n    this.paneContainer.addEventListener('mouseleave', this.handleCenterLeave)\r\n\r\n    return this\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.initializeContent","start_line":22,"end_line":34,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"observeScrollbarStyle","line":104,"func_location":"WorkspaceElement.initialize","func_start_line":67,"func_end_line":140,"args":[],"code":"  initialize (model, {config, project, styleManager, viewRegistry}) {\r\n    this.handleCenterEnter = this.handleCenterEnter.bind(this)\r\n    this.handleCenterLeave = this.handleCenterLeave.bind(this)\r\n    this.handleEdgesMouseMove = _.throttle(this.handleEdgesMouseMove.bind(this), 100)\r\n    this.handleDockDragEnd = this.handleDockDragEnd.bind(this)\r\n    this.handleDragStart = this.handleDragStart.bind(this)\r\n    this.handleDragEnd = this.handleDragEnd.bind(this)\r\n    this.handleDrop = this.handleDrop.bind(this)\r\n\r\n    this.model = model\r\n    this.viewRegistry = viewRegistry\r\n    this.project = project\r\n    this.config = config\r\n    this.styleManager = styleManager\r\n    if (this.viewRegistry == null) { throw new Error('Must pass a viewRegistry parameter when initializing WorkspaceElements') }\r\n    if (this.project == null) { throw new Error('Must pass a project parameter when initializing WorkspaceElements') }\r\n    if (this.config == null) { throw new Error('Must pass a config parameter when initializing WorkspaceElements') }\r\n    if (this.styleManager == null) { throw new Error('Must pass a styleManager parameter when initializing WorkspaceElements') }\r\n\r\n    this.subscriptions = new CompositeDisposable(\r\n      new Disposable(() => {\r\n        this.paneContainer.removeEventListener('mouseenter', this.handleCenterEnter)\r\n        this.paneContainer.removeEventListener('mouseleave', this.handleCenterLeave)\r\n        window.removeEventListener('mousemove', this.handleEdgesMouseMove)\r\n        window.removeEventListener('dragend', this.handleDockDragEnd)\r\n        window.removeEventListener('dragstart', this.handleDragStart)\r\n        window.removeEventListener('dragend', this.handleDragEnd, true)\r\n        window.removeEventListener('drop', this.handleDrop, true)\r\n      }),\r\n      ...[this.model.getLeftDock(), this.model.getRightDock(), this.model.getBottomDock()]\r\n        .map(dock => dock.onDidChangeHovered(hovered => {\r\n          if (hovered) this.hoveredDock = dock\r\n          else if (dock === this.hoveredDock) this.hoveredDock = null\r\n          this.checkCleanupDockHoverEvents()\r\n        }))\r\n    )\r\n    this.initializeContent()\r\n    this.observeScrollbarStyle()\r\n    this.observeTextEditorFontConfig()\r\n\r\n    this.paneContainer = this.model.getCenter().paneContainer.getElement()\r\n    this.verticalAxis.appendChild(this.paneContainer)\r\n    this.addEventListener('focus', this.handleFocus.bind(this))\r\n\r\n    this.addEventListener('mousewheel', this.handleMousewheel.bind(this), true)\r\n    window.addEventListener('dragstart', this.handleDragStart)\r\n    window.addEventListener('mousemove', this.handleEdgesMouseMove)\r\n\r\n    this.panelContainers = {\r\n      top: this.model.panelContainers.top.getElement(),\r\n      left: this.model.panelContainers.left.getElement(),\r\n      right: this.model.panelContainers.right.getElement(),\r\n      bottom: this.model.panelContainers.bottom.getElement(),\r\n      header: this.model.panelContainers.header.getElement(),\r\n      footer: this.model.panelContainers.footer.getElement(),\r\n      modal: this.model.panelContainers.modal.getElement()\r\n    }\r\n\r\n    this.horizontalAxis.insertBefore(this.panelContainers.left, this.verticalAxis)\r\n    this.horizontalAxis.appendChild(this.panelContainers.right)\r\n\r\n    this.verticalAxis.insertBefore(this.panelContainers.top, this.paneContainer)\r\n    this.verticalAxis.appendChild(this.panelContainers.bottom)\r\n\r\n    this.insertBefore(this.panelContainers.header, this.horizontalAxis)\r\n    this.appendChild(this.panelContainers.footer)\r\n\r\n    this.appendChild(this.panelContainers.modal)\r\n\r\n    this.paneContainer.addEventListener('mouseenter', this.handleCenterEnter)\r\n    this.paneContainer.addEventListener('mouseleave', this.handleCenterLeave)\r\n\r\n    return this\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.observeScrollbarStyle","start_line":36,"end_line":49,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"observeTextEditorFontConfig","line":105,"func_location":"WorkspaceElement.initialize","func_start_line":67,"func_end_line":140,"args":[],"code":"  initialize (model, {config, project, styleManager, viewRegistry}) {\r\n    this.handleCenterEnter = this.handleCenterEnter.bind(this)\r\n    this.handleCenterLeave = this.handleCenterLeave.bind(this)\r\n    this.handleEdgesMouseMove = _.throttle(this.handleEdgesMouseMove.bind(this), 100)\r\n    this.handleDockDragEnd = this.handleDockDragEnd.bind(this)\r\n    this.handleDragStart = this.handleDragStart.bind(this)\r\n    this.handleDragEnd = this.handleDragEnd.bind(this)\r\n    this.handleDrop = this.handleDrop.bind(this)\r\n\r\n    this.model = model\r\n    this.viewRegistry = viewRegistry\r\n    this.project = project\r\n    this.config = config\r\n    this.styleManager = styleManager\r\n    if (this.viewRegistry == null) { throw new Error('Must pass a viewRegistry parameter when initializing WorkspaceElements') }\r\n    if (this.project == null) { throw new Error('Must pass a project parameter when initializing WorkspaceElements') }\r\n    if (this.config == null) { throw new Error('Must pass a config parameter when initializing WorkspaceElements') }\r\n    if (this.styleManager == null) { throw new Error('Must pass a styleManager parameter when initializing WorkspaceElements') }\r\n\r\n    this.subscriptions = new CompositeDisposable(\r\n      new Disposable(() => {\r\n        this.paneContainer.removeEventListener('mouseenter', this.handleCenterEnter)\r\n        this.paneContainer.removeEventListener('mouseleave', this.handleCenterLeave)\r\n        window.removeEventListener('mousemove', this.handleEdgesMouseMove)\r\n        window.removeEventListener('dragend', this.handleDockDragEnd)\r\n        window.removeEventListener('dragstart', this.handleDragStart)\r\n        window.removeEventListener('dragend', this.handleDragEnd, true)\r\n        window.removeEventListener('drop', this.handleDrop, true)\r\n      }),\r\n      ...[this.model.getLeftDock(), this.model.getRightDock(), this.model.getBottomDock()]\r\n        .map(dock => dock.onDidChangeHovered(hovered => {\r\n          if (hovered) this.hoveredDock = dock\r\n          else if (dock === this.hoveredDock) this.hoveredDock = null\r\n          this.checkCleanupDockHoverEvents()\r\n        }))\r\n    )\r\n    this.initializeContent()\r\n    this.observeScrollbarStyle()\r\n    this.observeTextEditorFontConfig()\r\n\r\n    this.paneContainer = this.model.getCenter().paneContainer.getElement()\r\n    this.verticalAxis.appendChild(this.paneContainer)\r\n    this.addEventListener('focus', this.handleFocus.bind(this))\r\n\r\n    this.addEventListener('mousewheel', this.handleMousewheel.bind(this), true)\r\n    window.addEventListener('dragstart', this.handleDragStart)\r\n    window.addEventListener('mousemove', this.handleEdgesMouseMove)\r\n\r\n    this.panelContainers = {\r\n      top: this.model.panelContainers.top.getElement(),\r\n      left: this.model.panelContainers.left.getElement(),\r\n      right: this.model.panelContainers.right.getElement(),\r\n      bottom: this.model.panelContainers.bottom.getElement(),\r\n      header: this.model.panelContainers.header.getElement(),\r\n      footer: this.model.panelContainers.footer.getElement(),\r\n      modal: this.model.panelContainers.modal.getElement()\r\n    }\r\n\r\n    this.horizontalAxis.insertBefore(this.panelContainers.left, this.verticalAxis)\r\n    this.horizontalAxis.appendChild(this.panelContainers.right)\r\n\r\n    this.verticalAxis.insertBefore(this.panelContainers.top, this.paneContainer)\r\n    this.verticalAxis.appendChild(this.panelContainers.bottom)\r\n\r\n    this.insertBefore(this.panelContainers.header, this.horizontalAxis)\r\n    this.appendChild(this.panelContainers.footer)\r\n\r\n    this.appendChild(this.panelContainers.modal)\r\n\r\n    this.paneContainer.addEventListener('mouseenter', this.handleCenterEnter)\r\n    this.paneContainer.addEventListener('mouseleave', this.handleCenterLeave)\r\n\r\n    return this\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.observeTextEditorFontConfig","start_line":51,"end_line":56,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js","name":"isSupported","line":25,"func_location":"ProtocolHandlerInstaller.initialize","func_start_line":24,"func_end_line":52,"args":[],"code":"  initialize (config, notifications) {\r\n    if (!this.isSupported()) {\r\n      return\r\n    }\r\n\r\n    const behaviorWhenNotProtocolClient = config.get(SETTING)\r\n    switch (behaviorWhenNotProtocolClient) {\r\n      case PROMPT:\r\n        if (!this.isDefaultProtocolClient()) {\r\n          this.promptToBecomeProtocolClient(config, notifications)\r\n        }\r\n        break\r\n      case ALWAYS:\r\n        if (!this.isDefaultProtocolClient()) {\r\n          this.setAsDefaultProtocolClient()\r\n        }\r\n        break\r\n      case NEVER:\r\n        if (process.platform === 'win32') {\r\n          // Only win32 supports deregistration\r\n          const Registry = require('winreg')\r\n          const commandKey = new Registry({hive: 'HKCR', key: `\\\\atom`})\r\n          commandKey.destroy((_err, _val) => { /* no op */ })\r\n        }\r\n        break\r\n      default:\r\n        // Do nothing\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js","name":"ProtocolHandlerInstaller.isSupported","start_line":10,"end_line":12,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js","name":"isDefaultProtocolClient","line":32,"func_location":"ProtocolHandlerInstaller.initialize","func_start_line":24,"func_end_line":52,"args":[],"code":"  initialize (config, notifications) {\r\n    if (!this.isSupported()) {\r\n      return\r\n    }\r\n\r\n    const behaviorWhenNotProtocolClient = config.get(SETTING)\r\n    switch (behaviorWhenNotProtocolClient) {\r\n      case PROMPT:\r\n        if (!this.isDefaultProtocolClient()) {\r\n          this.promptToBecomeProtocolClient(config, notifications)\r\n        }\r\n        break\r\n      case ALWAYS:\r\n        if (!this.isDefaultProtocolClient()) {\r\n          this.setAsDefaultProtocolClient()\r\n        }\r\n        break\r\n      case NEVER:\r\n        if (process.platform === 'win32') {\r\n          // Only win32 supports deregistration\r\n          const Registry = require('winreg')\r\n          const commandKey = new Registry({hive: 'HKCR', key: `\\\\atom`})\r\n          commandKey.destroy((_err, _val) => { /* no op */ })\r\n        }\r\n        break\r\n      default:\r\n        // Do nothing\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js","name":"ProtocolHandlerInstaller.isDefaultProtocolClient","start_line":14,"end_line":16,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js","name":"promptToBecomeProtocolClient","line":33,"func_location":"ProtocolHandlerInstaller.initialize","func_start_line":24,"func_end_line":52,"args":["config","notifications"],"code":"  initialize (config, notifications) {\r\n    if (!this.isSupported()) {\r\n      return\r\n    }\r\n\r\n    const behaviorWhenNotProtocolClient = config.get(SETTING)\r\n    switch (behaviorWhenNotProtocolClient) {\r\n      case PROMPT:\r\n        if (!this.isDefaultProtocolClient()) {\r\n          this.promptToBecomeProtocolClient(config, notifications)\r\n        }\r\n        break\r\n      case ALWAYS:\r\n        if (!this.isDefaultProtocolClient()) {\r\n          this.setAsDefaultProtocolClient()\r\n        }\r\n        break\r\n      case NEVER:\r\n        if (process.platform === 'win32') {\r\n          // Only win32 supports deregistration\r\n          const Registry = require('winreg')\r\n          const commandKey = new Registry({hive: 'HKCR', key: `\\\\atom`})\r\n          commandKey.destroy((_err, _val) => { /* no op */ })\r\n        }\r\n        break\r\n      default:\r\n        // Do nothing\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js","name":"ProtocolHandlerInstaller.promptToBecomeProtocolClient","start_line":54,"end_line":100,"comment":[" Do nothing"],"params":["config","notifications"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js","name":"isDefaultProtocolClient","line":37,"func_location":"ProtocolHandlerInstaller.initialize","func_start_line":24,"func_end_line":52,"args":[],"code":"  initialize (config, notifications) {\r\n    if (!this.isSupported()) {\r\n      return\r\n    }\r\n\r\n    const behaviorWhenNotProtocolClient = config.get(SETTING)\r\n    switch (behaviorWhenNotProtocolClient) {\r\n      case PROMPT:\r\n        if (!this.isDefaultProtocolClient()) {\r\n          this.promptToBecomeProtocolClient(config, notifications)\r\n        }\r\n        break\r\n      case ALWAYS:\r\n        if (!this.isDefaultProtocolClient()) {\r\n          this.setAsDefaultProtocolClient()\r\n        }\r\n        break\r\n      case NEVER:\r\n        if (process.platform === 'win32') {\r\n          // Only win32 supports deregistration\r\n          const Registry = require('winreg')\r\n          const commandKey = new Registry({hive: 'HKCR', key: `\\\\atom`})\r\n          commandKey.destroy((_err, _val) => { /* no op */ })\r\n        }\r\n        break\r\n      default:\r\n        // Do nothing\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js","name":"ProtocolHandlerInstaller.isDefaultProtocolClient","start_line":14,"end_line":16,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js","name":"setAsDefaultProtocolClient","line":38,"func_location":"ProtocolHandlerInstaller.initialize","func_start_line":24,"func_end_line":52,"args":[],"code":"  initialize (config, notifications) {\r\n    if (!this.isSupported()) {\r\n      return\r\n    }\r\n\r\n    const behaviorWhenNotProtocolClient = config.get(SETTING)\r\n    switch (behaviorWhenNotProtocolClient) {\r\n      case PROMPT:\r\n        if (!this.isDefaultProtocolClient()) {\r\n          this.promptToBecomeProtocolClient(config, notifications)\r\n        }\r\n        break\r\n      case ALWAYS:\r\n        if (!this.isDefaultProtocolClient()) {\r\n          this.setAsDefaultProtocolClient()\r\n        }\r\n        break\r\n      case NEVER:\r\n        if (process.platform === 'win32') {\r\n          // Only win32 supports deregistration\r\n          const Registry = require('winreg')\r\n          const commandKey = new Registry({hive: 'HKCR', key: `\\\\atom`})\r\n          commandKey.destroy((_err, _val) => { /* no op */ })\r\n        }\r\n        break\r\n      default:\r\n        // Do nothing\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js","name":"ProtocolHandlerInstaller.setAsDefaultProtocolClient","start_line":18,"end_line":22,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"getLoadSettings","line":212,"func_location":"AtomEnvironment.initialize","func_start_line":201,"func_end_line":274,"args":[],"code":"  initialize (params = {}) {\r\n    // This will force TextEditorElement to register the custom element, so that\r\n    // using `document.createElement('atom-text-editor')` works if it's called\r\n    // before opening a buffer.\r\n    require('./text-editor-element')\r\n\r\n    this.window = params.window\r\n    this.document = params.document\r\n    this.blobStore = params.blobStore\r\n    this.configDirPath = params.configDirPath\r\n\r\n    const {devMode, safeMode, resourcePath, userSettings, projectSpecification} = this.getLoadSettings()\r\n\r\n    ConfigSchema.projectHome = {\r\n      type: 'string',\r\n      default: path.join(fs.getHomeDirectory(), 'github'),\r\n      description: 'The directory where projects are assumed to be located. Packages created using the Package Generator will be stored here by default.'\r\n    }\r\n\r\n    this.config.initialize({\r\n      mainSource: this.enablePersistence && path.join(this.configDirPath, 'config.cson'),\r\n      projectHomeSchema: ConfigSchema.projectHome\r\n    })\r\n    this.config.resetUserSettings(userSettings)\r\n\r\n    if (projectSpecification != null && projectSpecification.config != null) {\r\n      this.project.replace(projectSpecification)\r\n    }\r\n\r\n    this.menu.initialize({resourcePath})\r\n    this.contextMenu.initialize({resourcePath, devMode})\r\n\r\n    this.keymaps.configDirPath = this.configDirPath\r\n    this.keymaps.resourcePath = resourcePath\r\n    this.keymaps.devMode = devMode\r\n    if (!this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.commands.attach(this.window)\r\n\r\n    this.styles.initialize({configDirPath: this.configDirPath})\r\n    this.packages.initialize({devMode, configDirPath: this.configDirPath, resourcePath, safeMode})\r\n    this.themes.initialize({configDirPath: this.configDirPath, resourcePath, safeMode, devMode})\r\n\r\n    this.commandInstaller.initialize(this.getVersion())\r\n    this.uriHandlerRegistry.registerHostHandler('core', CoreURIHandlers.create(this))\r\n    this.autoUpdater.initialize()\r\n\r\n    this.protocolHandlerInstaller.initialize(this.config, this.notifications)\r\n\r\n    this.themes.loadBaseStylesheets()\r\n    this.initialStyleElements = this.styles.getSnapshot()\r\n    if (params.onlyLoadBaseStyleSheets) this.themes.initialLoadComplete = true\r\n    this.setBodyPlatformClass()\r\n\r\n    this.stylesElement = this.styles.buildStylesElement()\r\n    this.document.head.appendChild(this.stylesElement)\r\n\r\n    this.keymaps.subscribeToFileReadFailure()\r\n\r\n    this.installUncaughtErrorHandler()\r\n    this.attachSaveStateListeners()\r\n    this.windowEventHandler.initialize(this.window, this.document)\r\n\r\n    const didChangeStyles = this.didChangeStyles.bind(this)\r\n    this.disposables.add(this.styles.onDidAddStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidUpdateStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidRemoveStyleElement(didChangeStyles))\r\n\r\n    this.observeAutoHideMenuBar()\r\n\r\n    this.disposables.add(this.applicationDelegate.onDidChangeHistoryManager(() => this.history.loadState()))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.getLoadSettings","start_line":525,"end_line":527,"comment":[" Public: Get the load settings for the current window.",""," Returns an {Object} containing all the load setting key/value pairs."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"getVersion","line":246,"func_location":"AtomEnvironment.initialize","func_start_line":201,"func_end_line":274,"args":[null],"code":"  initialize (params = {}) {\r\n    // This will force TextEditorElement to register the custom element, so that\r\n    // using `document.createElement('atom-text-editor')` works if it's called\r\n    // before opening a buffer.\r\n    require('./text-editor-element')\r\n\r\n    this.window = params.window\r\n    this.document = params.document\r\n    this.blobStore = params.blobStore\r\n    this.configDirPath = params.configDirPath\r\n\r\n    const {devMode, safeMode, resourcePath, userSettings, projectSpecification} = this.getLoadSettings()\r\n\r\n    ConfigSchema.projectHome = {\r\n      type: 'string',\r\n      default: path.join(fs.getHomeDirectory(), 'github'),\r\n      description: 'The directory where projects are assumed to be located. Packages created using the Package Generator will be stored here by default.'\r\n    }\r\n\r\n    this.config.initialize({\r\n      mainSource: this.enablePersistence && path.join(this.configDirPath, 'config.cson'),\r\n      projectHomeSchema: ConfigSchema.projectHome\r\n    })\r\n    this.config.resetUserSettings(userSettings)\r\n\r\n    if (projectSpecification != null && projectSpecification.config != null) {\r\n      this.project.replace(projectSpecification)\r\n    }\r\n\r\n    this.menu.initialize({resourcePath})\r\n    this.contextMenu.initialize({resourcePath, devMode})\r\n\r\n    this.keymaps.configDirPath = this.configDirPath\r\n    this.keymaps.resourcePath = resourcePath\r\n    this.keymaps.devMode = devMode\r\n    if (!this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.commands.attach(this.window)\r\n\r\n    this.styles.initialize({configDirPath: this.configDirPath})\r\n    this.packages.initialize({devMode, configDirPath: this.configDirPath, resourcePath, safeMode})\r\n    this.themes.initialize({configDirPath: this.configDirPath, resourcePath, safeMode, devMode})\r\n\r\n    this.commandInstaller.initialize(this.getVersion())\r\n    this.uriHandlerRegistry.registerHostHandler('core', CoreURIHandlers.create(this))\r\n    this.autoUpdater.initialize()\r\n\r\n    this.protocolHandlerInstaller.initialize(this.config, this.notifications)\r\n\r\n    this.themes.loadBaseStylesheets()\r\n    this.initialStyleElements = this.styles.getSnapshot()\r\n    if (params.onlyLoadBaseStyleSheets) this.themes.initialLoadComplete = true\r\n    this.setBodyPlatformClass()\r\n\r\n    this.stylesElement = this.styles.buildStylesElement()\r\n    this.document.head.appendChild(this.stylesElement)\r\n\r\n    this.keymaps.subscribeToFileReadFailure()\r\n\r\n    this.installUncaughtErrorHandler()\r\n    this.attachSaveStateListeners()\r\n    this.windowEventHandler.initialize(this.window, this.document)\r\n\r\n    const didChangeStyles = this.didChangeStyles.bind(this)\r\n    this.disposables.add(this.styles.onDidAddStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidUpdateStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidRemoveStyleElement(didChangeStyles))\r\n\r\n    this.observeAutoHideMenuBar()\r\n\r\n    this.disposables.add(this.applicationDelegate.onDidChangeHistoryManager(() => this.history.loadState()))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.getVersion","start_line":483,"end_line":486,"comment":[" Public: Get the version of the Atom application.",""," Returns the version text {String}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"setBodyPlatformClass","line":255,"func_location":"AtomEnvironment.initialize","func_start_line":201,"func_end_line":274,"args":[],"code":"  initialize (params = {}) {\r\n    // This will force TextEditorElement to register the custom element, so that\r\n    // using `document.createElement('atom-text-editor')` works if it's called\r\n    // before opening a buffer.\r\n    require('./text-editor-element')\r\n\r\n    this.window = params.window\r\n    this.document = params.document\r\n    this.blobStore = params.blobStore\r\n    this.configDirPath = params.configDirPath\r\n\r\n    const {devMode, safeMode, resourcePath, userSettings, projectSpecification} = this.getLoadSettings()\r\n\r\n    ConfigSchema.projectHome = {\r\n      type: 'string',\r\n      default: path.join(fs.getHomeDirectory(), 'github'),\r\n      description: 'The directory where projects are assumed to be located. Packages created using the Package Generator will be stored here by default.'\r\n    }\r\n\r\n    this.config.initialize({\r\n      mainSource: this.enablePersistence && path.join(this.configDirPath, 'config.cson'),\r\n      projectHomeSchema: ConfigSchema.projectHome\r\n    })\r\n    this.config.resetUserSettings(userSettings)\r\n\r\n    if (projectSpecification != null && projectSpecification.config != null) {\r\n      this.project.replace(projectSpecification)\r\n    }\r\n\r\n    this.menu.initialize({resourcePath})\r\n    this.contextMenu.initialize({resourcePath, devMode})\r\n\r\n    this.keymaps.configDirPath = this.configDirPath\r\n    this.keymaps.resourcePath = resourcePath\r\n    this.keymaps.devMode = devMode\r\n    if (!this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.commands.attach(this.window)\r\n\r\n    this.styles.initialize({configDirPath: this.configDirPath})\r\n    this.packages.initialize({devMode, configDirPath: this.configDirPath, resourcePath, safeMode})\r\n    this.themes.initialize({configDirPath: this.configDirPath, resourcePath, safeMode, devMode})\r\n\r\n    this.commandInstaller.initialize(this.getVersion())\r\n    this.uriHandlerRegistry.registerHostHandler('core', CoreURIHandlers.create(this))\r\n    this.autoUpdater.initialize()\r\n\r\n    this.protocolHandlerInstaller.initialize(this.config, this.notifications)\r\n\r\n    this.themes.loadBaseStylesheets()\r\n    this.initialStyleElements = this.styles.getSnapshot()\r\n    if (params.onlyLoadBaseStyleSheets) this.themes.initialLoadComplete = true\r\n    this.setBodyPlatformClass()\r\n\r\n    this.stylesElement = this.styles.buildStylesElement()\r\n    this.document.head.appendChild(this.stylesElement)\r\n\r\n    this.keymaps.subscribeToFileReadFailure()\r\n\r\n    this.installUncaughtErrorHandler()\r\n    this.attachSaveStateListeners()\r\n    this.windowEventHandler.initialize(this.window, this.document)\r\n\r\n    const didChangeStyles = this.didChangeStyles.bind(this)\r\n    this.disposables.add(this.styles.onDidAddStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidUpdateStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidRemoveStyleElement(didChangeStyles))\r\n\r\n    this.observeAutoHideMenuBar()\r\n\r\n    this.disposables.add(this.applicationDelegate.onDidChangeHistoryManager(() => this.history.loadState()))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.setBodyPlatformClass","start_line":1326,"end_line":1328,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"installUncaughtErrorHandler","line":262,"func_location":"AtomEnvironment.initialize","func_start_line":201,"func_end_line":274,"args":[],"code":"  initialize (params = {}) {\r\n    // This will force TextEditorElement to register the custom element, so that\r\n    // using `document.createElement('atom-text-editor')` works if it's called\r\n    // before opening a buffer.\r\n    require('./text-editor-element')\r\n\r\n    this.window = params.window\r\n    this.document = params.document\r\n    this.blobStore = params.blobStore\r\n    this.configDirPath = params.configDirPath\r\n\r\n    const {devMode, safeMode, resourcePath, userSettings, projectSpecification} = this.getLoadSettings()\r\n\r\n    ConfigSchema.projectHome = {\r\n      type: 'string',\r\n      default: path.join(fs.getHomeDirectory(), 'github'),\r\n      description: 'The directory where projects are assumed to be located. Packages created using the Package Generator will be stored here by default.'\r\n    }\r\n\r\n    this.config.initialize({\r\n      mainSource: this.enablePersistence && path.join(this.configDirPath, 'config.cson'),\r\n      projectHomeSchema: ConfigSchema.projectHome\r\n    })\r\n    this.config.resetUserSettings(userSettings)\r\n\r\n    if (projectSpecification != null && projectSpecification.config != null) {\r\n      this.project.replace(projectSpecification)\r\n    }\r\n\r\n    this.menu.initialize({resourcePath})\r\n    this.contextMenu.initialize({resourcePath, devMode})\r\n\r\n    this.keymaps.configDirPath = this.configDirPath\r\n    this.keymaps.resourcePath = resourcePath\r\n    this.keymaps.devMode = devMode\r\n    if (!this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.commands.attach(this.window)\r\n\r\n    this.styles.initialize({configDirPath: this.configDirPath})\r\n    this.packages.initialize({devMode, configDirPath: this.configDirPath, resourcePath, safeMode})\r\n    this.themes.initialize({configDirPath: this.configDirPath, resourcePath, safeMode, devMode})\r\n\r\n    this.commandInstaller.initialize(this.getVersion())\r\n    this.uriHandlerRegistry.registerHostHandler('core', CoreURIHandlers.create(this))\r\n    this.autoUpdater.initialize()\r\n\r\n    this.protocolHandlerInstaller.initialize(this.config, this.notifications)\r\n\r\n    this.themes.loadBaseStylesheets()\r\n    this.initialStyleElements = this.styles.getSnapshot()\r\n    if (params.onlyLoadBaseStyleSheets) this.themes.initialLoadComplete = true\r\n    this.setBodyPlatformClass()\r\n\r\n    this.stylesElement = this.styles.buildStylesElement()\r\n    this.document.head.appendChild(this.stylesElement)\r\n\r\n    this.keymaps.subscribeToFileReadFailure()\r\n\r\n    this.installUncaughtErrorHandler()\r\n    this.attachSaveStateListeners()\r\n    this.windowEventHandler.initialize(this.window, this.document)\r\n\r\n    const didChangeStyles = this.didChangeStyles.bind(this)\r\n    this.disposables.add(this.styles.onDidAddStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidUpdateStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidRemoveStyleElement(didChangeStyles))\r\n\r\n    this.observeAutoHideMenuBar()\r\n\r\n    this.disposables.add(this.applicationDelegate.onDidChangeHistoryManager(() => this.history.loadState()))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.installUncaughtErrorHandler","start_line":922,"end_line":945,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"attachSaveStateListeners","line":263,"func_location":"AtomEnvironment.initialize","func_start_line":201,"func_end_line":274,"args":[],"code":"  initialize (params = {}) {\r\n    // This will force TextEditorElement to register the custom element, so that\r\n    // using `document.createElement('atom-text-editor')` works if it's called\r\n    // before opening a buffer.\r\n    require('./text-editor-element')\r\n\r\n    this.window = params.window\r\n    this.document = params.document\r\n    this.blobStore = params.blobStore\r\n    this.configDirPath = params.configDirPath\r\n\r\n    const {devMode, safeMode, resourcePath, userSettings, projectSpecification} = this.getLoadSettings()\r\n\r\n    ConfigSchema.projectHome = {\r\n      type: 'string',\r\n      default: path.join(fs.getHomeDirectory(), 'github'),\r\n      description: 'The directory where projects are assumed to be located. Packages created using the Package Generator will be stored here by default.'\r\n    }\r\n\r\n    this.config.initialize({\r\n      mainSource: this.enablePersistence && path.join(this.configDirPath, 'config.cson'),\r\n      projectHomeSchema: ConfigSchema.projectHome\r\n    })\r\n    this.config.resetUserSettings(userSettings)\r\n\r\n    if (projectSpecification != null && projectSpecification.config != null) {\r\n      this.project.replace(projectSpecification)\r\n    }\r\n\r\n    this.menu.initialize({resourcePath})\r\n    this.contextMenu.initialize({resourcePath, devMode})\r\n\r\n    this.keymaps.configDirPath = this.configDirPath\r\n    this.keymaps.resourcePath = resourcePath\r\n    this.keymaps.devMode = devMode\r\n    if (!this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.commands.attach(this.window)\r\n\r\n    this.styles.initialize({configDirPath: this.configDirPath})\r\n    this.packages.initialize({devMode, configDirPath: this.configDirPath, resourcePath, safeMode})\r\n    this.themes.initialize({configDirPath: this.configDirPath, resourcePath, safeMode, devMode})\r\n\r\n    this.commandInstaller.initialize(this.getVersion())\r\n    this.uriHandlerRegistry.registerHostHandler('core', CoreURIHandlers.create(this))\r\n    this.autoUpdater.initialize()\r\n\r\n    this.protocolHandlerInstaller.initialize(this.config, this.notifications)\r\n\r\n    this.themes.loadBaseStylesheets()\r\n    this.initialStyleElements = this.styles.getSnapshot()\r\n    if (params.onlyLoadBaseStyleSheets) this.themes.initialLoadComplete = true\r\n    this.setBodyPlatformClass()\r\n\r\n    this.stylesElement = this.styles.buildStylesElement()\r\n    this.document.head.appendChild(this.stylesElement)\r\n\r\n    this.keymaps.subscribeToFileReadFailure()\r\n\r\n    this.installUncaughtErrorHandler()\r\n    this.attachSaveStateListeners()\r\n    this.windowEventHandler.initialize(this.window, this.document)\r\n\r\n    const didChangeStyles = this.didChangeStyles.bind(this)\r\n    this.disposables.add(this.styles.onDidAddStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidUpdateStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidRemoveStyleElement(didChangeStyles))\r\n\r\n    this.observeAutoHideMenuBar()\r\n\r\n    this.disposables.add(this.applicationDelegate.onDidChangeHistoryManager(() => this.history.loadState()))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.attachSaveStateListeners","start_line":280,"end_line":292,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"observeAutoHideMenuBar","line":271,"func_location":"AtomEnvironment.initialize","func_start_line":201,"func_end_line":274,"args":[],"code":"  initialize (params = {}) {\r\n    // This will force TextEditorElement to register the custom element, so that\r\n    // using `document.createElement('atom-text-editor')` works if it's called\r\n    // before opening a buffer.\r\n    require('./text-editor-element')\r\n\r\n    this.window = params.window\r\n    this.document = params.document\r\n    this.blobStore = params.blobStore\r\n    this.configDirPath = params.configDirPath\r\n\r\n    const {devMode, safeMode, resourcePath, userSettings, projectSpecification} = this.getLoadSettings()\r\n\r\n    ConfigSchema.projectHome = {\r\n      type: 'string',\r\n      default: path.join(fs.getHomeDirectory(), 'github'),\r\n      description: 'The directory where projects are assumed to be located. Packages created using the Package Generator will be stored here by default.'\r\n    }\r\n\r\n    this.config.initialize({\r\n      mainSource: this.enablePersistence && path.join(this.configDirPath, 'config.cson'),\r\n      projectHomeSchema: ConfigSchema.projectHome\r\n    })\r\n    this.config.resetUserSettings(userSettings)\r\n\r\n    if (projectSpecification != null && projectSpecification.config != null) {\r\n      this.project.replace(projectSpecification)\r\n    }\r\n\r\n    this.menu.initialize({resourcePath})\r\n    this.contextMenu.initialize({resourcePath, devMode})\r\n\r\n    this.keymaps.configDirPath = this.configDirPath\r\n    this.keymaps.resourcePath = resourcePath\r\n    this.keymaps.devMode = devMode\r\n    if (!this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.commands.attach(this.window)\r\n\r\n    this.styles.initialize({configDirPath: this.configDirPath})\r\n    this.packages.initialize({devMode, configDirPath: this.configDirPath, resourcePath, safeMode})\r\n    this.themes.initialize({configDirPath: this.configDirPath, resourcePath, safeMode, devMode})\r\n\r\n    this.commandInstaller.initialize(this.getVersion())\r\n    this.uriHandlerRegistry.registerHostHandler('core', CoreURIHandlers.create(this))\r\n    this.autoUpdater.initialize()\r\n\r\n    this.protocolHandlerInstaller.initialize(this.config, this.notifications)\r\n\r\n    this.themes.loadBaseStylesheets()\r\n    this.initialStyleElements = this.styles.getSnapshot()\r\n    if (params.onlyLoadBaseStyleSheets) this.themes.initialLoadComplete = true\r\n    this.setBodyPlatformClass()\r\n\r\n    this.stylesElement = this.styles.buildStylesElement()\r\n    this.document.head.appendChild(this.stylesElement)\r\n\r\n    this.keymaps.subscribeToFileReadFailure()\r\n\r\n    this.installUncaughtErrorHandler()\r\n    this.attachSaveStateListeners()\r\n    this.windowEventHandler.initialize(this.window, this.document)\r\n\r\n    const didChangeStyles = this.didChangeStyles.bind(this)\r\n    this.disposables.add(this.styles.onDidAddStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidUpdateStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidRemoveStyleElement(didChangeStyles))\r\n\r\n    this.observeAutoHideMenuBar()\r\n\r\n    this.disposables.add(this.applicationDelegate.onDidChangeHistoryManager(() => this.history.loadState()))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.observeAutoHideMenuBar","start_line":328,"end_line":333,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"listenForArgumentsFromNewProcess","line":155,"func_location":"AtomApplication.initialize","func_start_line":142,"func_end_line":161,"args":[],"comment":[" This stuff was previously done in the constructor, but we want to be able to construct this object"," for testing purposes without booting up the world. As you add tests, feel free to move instantiation"," of these various sub-objects into the constructor, but you'll need to remove the side-effects they"," perform during their construction, adding an initialize method that you call here."],"code":"  async initialize (options) {\r\n    global.atomApplication = this\r\n\r\n    // DEPRECATED: This can be removed at some point (added in 1.13)\r\n    // It converts `useCustomTitleBar: true` to `titleBar: \"custom\"`\r\n    if (process.platform === 'darwin' && this.config.get('core.useCustomTitleBar')) {\r\n      this.config.unset('core.useCustomTitleBar')\r\n      this.config.set('core.titleBar', 'custom')\r\n    }\r\n\r\n    this.applicationMenu = new ApplicationMenu(this.version, this.autoUpdateManager)\r\n    this.atomProtocolHandler = new AtomProtocolHandler(this.resourcePath, this.safeMode)\r\n\r\n    this.listenForArgumentsFromNewProcess()\r\n    this.setupDockMenu()\r\n\r\n    const result = await this.launch(options)\r\n    this.autoUpdateManager.initialize()\r\n    return result\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.listenForArgumentsFromNewProcess","start_line":334,"end_line":346,"comment":[" Creates server to listen for additional atom application launches.",""," You can run the atom command multiple times, but after the first launch"," the other launches will just pass their information to this server and then"," close immediately."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"setupDockMenu","line":156,"func_location":"AtomApplication.initialize","func_start_line":142,"func_end_line":161,"args":[],"comment":[" This stuff was previously done in the constructor, but we want to be able to construct this object"," for testing purposes without booting up the world. As you add tests, feel free to move instantiation"," of these various sub-objects into the constructor, but you'll need to remove the side-effects they"," perform during their construction, adding an initialize method that you call here."],"code":"  async initialize (options) {\r\n    global.atomApplication = this\r\n\r\n    // DEPRECATED: This can be removed at some point (added in 1.13)\r\n    // It converts `useCustomTitleBar: true` to `titleBar: \"custom\"`\r\n    if (process.platform === 'darwin' && this.config.get('core.useCustomTitleBar')) {\r\n      this.config.unset('core.useCustomTitleBar')\r\n      this.config.set('core.titleBar', 'custom')\r\n    }\r\n\r\n    this.applicationMenu = new ApplicationMenu(this.version, this.autoUpdateManager)\r\n    this.atomProtocolHandler = new AtomProtocolHandler(this.resourcePath, this.safeMode)\r\n\r\n    this.listenForArgumentsFromNewProcess()\r\n    this.setupDockMenu()\r\n\r\n    const result = await this.launch(options)\r\n    this.autoUpdateManager.initialize()\r\n    return result\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.setupDockMenu","start_line":636,"end_line":642,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"launch","line":158,"func_location":"AtomApplication.initialize","func_start_line":142,"func_end_line":161,"args":["options"],"comment":[" This stuff was previously done in the constructor, but we want to be able to construct this object"," for testing purposes without booting up the world. As you add tests, feel free to move instantiation"," of these various sub-objects into the constructor, but you'll need to remove the side-effects they"," perform during their construction, adding an initialize method that you call here."],"code":"  async initialize (options) {\r\n    global.atomApplication = this\r\n\r\n    // DEPRECATED: This can be removed at some point (added in 1.13)\r\n    // It converts `useCustomTitleBar: true` to `titleBar: \"custom\"`\r\n    if (process.platform === 'darwin' && this.config.get('core.useCustomTitleBar')) {\r\n      this.config.unset('core.useCustomTitleBar')\r\n      this.config.set('core.titleBar', 'custom')\r\n    }\r\n\r\n    this.applicationMenu = new ApplicationMenu(this.version, this.autoUpdateManager)\r\n    this.atomProtocolHandler = new AtomProtocolHandler(this.resourcePath, this.safeMode)\r\n\r\n    this.listenForArgumentsFromNewProcess()\r\n    this.setupDockMenu()\r\n\r\n    const result = await this.launch(options)\r\n    this.autoUpdateManager.initialize()\r\n    return result\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.launch","start_line":172,"end_line":205,"comment":[],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js","name":"addEventListener","line":52,"func_location":"WindowEventHandler.initialize","func_start_line":31,"func_end_line":67,"args":[".window",{"type":"string"},".handleWindowBeforeunload"],"code":"  initialize (window, document) {\r\n    this.window = window\r\n    this.document = document\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.window, {\r\n      'window:toggle-full-screen': this.handleWindowToggleFullScreen,\r\n      'window:close': this.handleWindowClose,\r\n      'window:reload': this.handleWindowReload,\r\n      'window:toggle-dev-tools': this.handleWindowToggleDevTools\r\n    }))\r\n\r\n    if (['win32', 'linux'].includes(process.platform)) {\r\n      this.subscriptions.add(this.atomEnvironment.commands.add(this.window,\r\n        {'window:toggle-menu-bar': this.handleWindowToggleMenuBar})\r\n      )\r\n    }\r\n\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.document, {\r\n      'core:focus-next': this.handleFocusNext,\r\n      'core:focus-previous': this.handleFocusPrevious\r\n    }))\r\n\r\n    this.addEventListener(this.window, 'beforeunload', this.handleWindowBeforeunload)\r\n    this.addEventListener(this.window, 'focus', this.handleWindowFocus)\r\n    this.addEventListener(this.window, 'blur', this.handleWindowBlur)\r\n    this.addEventListener(this.window, 'resize', this.handleWindowResize)\r\n\r\n    this.addEventListener(this.document, 'keyup', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'keydown', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'drop', this.handleDocumentDrop)\r\n    this.addEventListener(this.document, 'dragover', this.handleDocumentDragover)\r\n    this.addEventListener(this.document, 'contextmenu', this.handleDocumentContextmenu)\r\n    this.subscriptions.add(listen(this.document, 'click', 'a', this.handleLinkClick))\r\n    this.subscriptions.add(listen(this.document, 'submit', 'form', this.handleFormSubmit))\r\n\r\n    this.subscriptions.add(this.applicationDelegate.onDidEnterFullScreen(this.handleEnterFullScreen))\r\n    this.subscriptions.add(this.applicationDelegate.onDidLeaveFullScreen(this.handleLeaveFullScreen))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js","name":"WindowEventHandler.addEventListener","start_line":102,"end_line":107,"comment":[],"params":["target","eventName","handler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js","name":"addEventListener","line":53,"func_location":"WindowEventHandler.initialize","func_start_line":31,"func_end_line":67,"args":[".window",{"type":"string"},".handleWindowFocus"],"code":"  initialize (window, document) {\r\n    this.window = window\r\n    this.document = document\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.window, {\r\n      'window:toggle-full-screen': this.handleWindowToggleFullScreen,\r\n      'window:close': this.handleWindowClose,\r\n      'window:reload': this.handleWindowReload,\r\n      'window:toggle-dev-tools': this.handleWindowToggleDevTools\r\n    }))\r\n\r\n    if (['win32', 'linux'].includes(process.platform)) {\r\n      this.subscriptions.add(this.atomEnvironment.commands.add(this.window,\r\n        {'window:toggle-menu-bar': this.handleWindowToggleMenuBar})\r\n      )\r\n    }\r\n\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.document, {\r\n      'core:focus-next': this.handleFocusNext,\r\n      'core:focus-previous': this.handleFocusPrevious\r\n    }))\r\n\r\n    this.addEventListener(this.window, 'beforeunload', this.handleWindowBeforeunload)\r\n    this.addEventListener(this.window, 'focus', this.handleWindowFocus)\r\n    this.addEventListener(this.window, 'blur', this.handleWindowBlur)\r\n    this.addEventListener(this.window, 'resize', this.handleWindowResize)\r\n\r\n    this.addEventListener(this.document, 'keyup', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'keydown', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'drop', this.handleDocumentDrop)\r\n    this.addEventListener(this.document, 'dragover', this.handleDocumentDragover)\r\n    this.addEventListener(this.document, 'contextmenu', this.handleDocumentContextmenu)\r\n    this.subscriptions.add(listen(this.document, 'click', 'a', this.handleLinkClick))\r\n    this.subscriptions.add(listen(this.document, 'submit', 'form', this.handleFormSubmit))\r\n\r\n    this.subscriptions.add(this.applicationDelegate.onDidEnterFullScreen(this.handleEnterFullScreen))\r\n    this.subscriptions.add(this.applicationDelegate.onDidLeaveFullScreen(this.handleLeaveFullScreen))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js","name":"WindowEventHandler.addEventListener","start_line":102,"end_line":107,"comment":[],"params":["target","eventName","handler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js","name":"addEventListener","line":54,"func_location":"WindowEventHandler.initialize","func_start_line":31,"func_end_line":67,"args":[".window",{"type":"string"},".handleWindowBlur"],"code":"  initialize (window, document) {\r\n    this.window = window\r\n    this.document = document\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.window, {\r\n      'window:toggle-full-screen': this.handleWindowToggleFullScreen,\r\n      'window:close': this.handleWindowClose,\r\n      'window:reload': this.handleWindowReload,\r\n      'window:toggle-dev-tools': this.handleWindowToggleDevTools\r\n    }))\r\n\r\n    if (['win32', 'linux'].includes(process.platform)) {\r\n      this.subscriptions.add(this.atomEnvironment.commands.add(this.window,\r\n        {'window:toggle-menu-bar': this.handleWindowToggleMenuBar})\r\n      )\r\n    }\r\n\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.document, {\r\n      'core:focus-next': this.handleFocusNext,\r\n      'core:focus-previous': this.handleFocusPrevious\r\n    }))\r\n\r\n    this.addEventListener(this.window, 'beforeunload', this.handleWindowBeforeunload)\r\n    this.addEventListener(this.window, 'focus', this.handleWindowFocus)\r\n    this.addEventListener(this.window, 'blur', this.handleWindowBlur)\r\n    this.addEventListener(this.window, 'resize', this.handleWindowResize)\r\n\r\n    this.addEventListener(this.document, 'keyup', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'keydown', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'drop', this.handleDocumentDrop)\r\n    this.addEventListener(this.document, 'dragover', this.handleDocumentDragover)\r\n    this.addEventListener(this.document, 'contextmenu', this.handleDocumentContextmenu)\r\n    this.subscriptions.add(listen(this.document, 'click', 'a', this.handleLinkClick))\r\n    this.subscriptions.add(listen(this.document, 'submit', 'form', this.handleFormSubmit))\r\n\r\n    this.subscriptions.add(this.applicationDelegate.onDidEnterFullScreen(this.handleEnterFullScreen))\r\n    this.subscriptions.add(this.applicationDelegate.onDidLeaveFullScreen(this.handleLeaveFullScreen))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js","name":"WindowEventHandler.addEventListener","start_line":102,"end_line":107,"comment":[],"params":["target","eventName","handler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js","name":"addEventListener","line":55,"func_location":"WindowEventHandler.initialize","func_start_line":31,"func_end_line":67,"args":[".window",{"type":"string"},".handleWindowResize"],"code":"  initialize (window, document) {\r\n    this.window = window\r\n    this.document = document\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.window, {\r\n      'window:toggle-full-screen': this.handleWindowToggleFullScreen,\r\n      'window:close': this.handleWindowClose,\r\n      'window:reload': this.handleWindowReload,\r\n      'window:toggle-dev-tools': this.handleWindowToggleDevTools\r\n    }))\r\n\r\n    if (['win32', 'linux'].includes(process.platform)) {\r\n      this.subscriptions.add(this.atomEnvironment.commands.add(this.window,\r\n        {'window:toggle-menu-bar': this.handleWindowToggleMenuBar})\r\n      )\r\n    }\r\n\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.document, {\r\n      'core:focus-next': this.handleFocusNext,\r\n      'core:focus-previous': this.handleFocusPrevious\r\n    }))\r\n\r\n    this.addEventListener(this.window, 'beforeunload', this.handleWindowBeforeunload)\r\n    this.addEventListener(this.window, 'focus', this.handleWindowFocus)\r\n    this.addEventListener(this.window, 'blur', this.handleWindowBlur)\r\n    this.addEventListener(this.window, 'resize', this.handleWindowResize)\r\n\r\n    this.addEventListener(this.document, 'keyup', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'keydown', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'drop', this.handleDocumentDrop)\r\n    this.addEventListener(this.document, 'dragover', this.handleDocumentDragover)\r\n    this.addEventListener(this.document, 'contextmenu', this.handleDocumentContextmenu)\r\n    this.subscriptions.add(listen(this.document, 'click', 'a', this.handleLinkClick))\r\n    this.subscriptions.add(listen(this.document, 'submit', 'form', this.handleFormSubmit))\r\n\r\n    this.subscriptions.add(this.applicationDelegate.onDidEnterFullScreen(this.handleEnterFullScreen))\r\n    this.subscriptions.add(this.applicationDelegate.onDidLeaveFullScreen(this.handleLeaveFullScreen))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js","name":"WindowEventHandler.addEventListener","start_line":102,"end_line":107,"comment":[],"params":["target","eventName","handler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js","name":"addEventListener","line":57,"func_location":"WindowEventHandler.initialize","func_start_line":31,"func_end_line":67,"args":[".document",{"type":"string"},".handleDocumentKeyEvent"],"code":"  initialize (window, document) {\r\n    this.window = window\r\n    this.document = document\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.window, {\r\n      'window:toggle-full-screen': this.handleWindowToggleFullScreen,\r\n      'window:close': this.handleWindowClose,\r\n      'window:reload': this.handleWindowReload,\r\n      'window:toggle-dev-tools': this.handleWindowToggleDevTools\r\n    }))\r\n\r\n    if (['win32', 'linux'].includes(process.platform)) {\r\n      this.subscriptions.add(this.atomEnvironment.commands.add(this.window,\r\n        {'window:toggle-menu-bar': this.handleWindowToggleMenuBar})\r\n      )\r\n    }\r\n\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.document, {\r\n      'core:focus-next': this.handleFocusNext,\r\n      'core:focus-previous': this.handleFocusPrevious\r\n    }))\r\n\r\n    this.addEventListener(this.window, 'beforeunload', this.handleWindowBeforeunload)\r\n    this.addEventListener(this.window, 'focus', this.handleWindowFocus)\r\n    this.addEventListener(this.window, 'blur', this.handleWindowBlur)\r\n    this.addEventListener(this.window, 'resize', this.handleWindowResize)\r\n\r\n    this.addEventListener(this.document, 'keyup', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'keydown', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'drop', this.handleDocumentDrop)\r\n    this.addEventListener(this.document, 'dragover', this.handleDocumentDragover)\r\n    this.addEventListener(this.document, 'contextmenu', this.handleDocumentContextmenu)\r\n    this.subscriptions.add(listen(this.document, 'click', 'a', this.handleLinkClick))\r\n    this.subscriptions.add(listen(this.document, 'submit', 'form', this.handleFormSubmit))\r\n\r\n    this.subscriptions.add(this.applicationDelegate.onDidEnterFullScreen(this.handleEnterFullScreen))\r\n    this.subscriptions.add(this.applicationDelegate.onDidLeaveFullScreen(this.handleLeaveFullScreen))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js","name":"WindowEventHandler.addEventListener","start_line":102,"end_line":107,"comment":[],"params":["target","eventName","handler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js","name":"addEventListener","line":58,"func_location":"WindowEventHandler.initialize","func_start_line":31,"func_end_line":67,"args":[".document",{"type":"string"},".handleDocumentKeyEvent"],"code":"  initialize (window, document) {\r\n    this.window = window\r\n    this.document = document\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.window, {\r\n      'window:toggle-full-screen': this.handleWindowToggleFullScreen,\r\n      'window:close': this.handleWindowClose,\r\n      'window:reload': this.handleWindowReload,\r\n      'window:toggle-dev-tools': this.handleWindowToggleDevTools\r\n    }))\r\n\r\n    if (['win32', 'linux'].includes(process.platform)) {\r\n      this.subscriptions.add(this.atomEnvironment.commands.add(this.window,\r\n        {'window:toggle-menu-bar': this.handleWindowToggleMenuBar})\r\n      )\r\n    }\r\n\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.document, {\r\n      'core:focus-next': this.handleFocusNext,\r\n      'core:focus-previous': this.handleFocusPrevious\r\n    }))\r\n\r\n    this.addEventListener(this.window, 'beforeunload', this.handleWindowBeforeunload)\r\n    this.addEventListener(this.window, 'focus', this.handleWindowFocus)\r\n    this.addEventListener(this.window, 'blur', this.handleWindowBlur)\r\n    this.addEventListener(this.window, 'resize', this.handleWindowResize)\r\n\r\n    this.addEventListener(this.document, 'keyup', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'keydown', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'drop', this.handleDocumentDrop)\r\n    this.addEventListener(this.document, 'dragover', this.handleDocumentDragover)\r\n    this.addEventListener(this.document, 'contextmenu', this.handleDocumentContextmenu)\r\n    this.subscriptions.add(listen(this.document, 'click', 'a', this.handleLinkClick))\r\n    this.subscriptions.add(listen(this.document, 'submit', 'form', this.handleFormSubmit))\r\n\r\n    this.subscriptions.add(this.applicationDelegate.onDidEnterFullScreen(this.handleEnterFullScreen))\r\n    this.subscriptions.add(this.applicationDelegate.onDidLeaveFullScreen(this.handleLeaveFullScreen))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js","name":"WindowEventHandler.addEventListener","start_line":102,"end_line":107,"comment":[],"params":["target","eventName","handler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js","name":"addEventListener","line":59,"func_location":"WindowEventHandler.initialize","func_start_line":31,"func_end_line":67,"args":[".document",{"type":"string"},".handleDocumentDrop"],"code":"  initialize (window, document) {\r\n    this.window = window\r\n    this.document = document\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.window, {\r\n      'window:toggle-full-screen': this.handleWindowToggleFullScreen,\r\n      'window:close': this.handleWindowClose,\r\n      'window:reload': this.handleWindowReload,\r\n      'window:toggle-dev-tools': this.handleWindowToggleDevTools\r\n    }))\r\n\r\n    if (['win32', 'linux'].includes(process.platform)) {\r\n      this.subscriptions.add(this.atomEnvironment.commands.add(this.window,\r\n        {'window:toggle-menu-bar': this.handleWindowToggleMenuBar})\r\n      )\r\n    }\r\n\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.document, {\r\n      'core:focus-next': this.handleFocusNext,\r\n      'core:focus-previous': this.handleFocusPrevious\r\n    }))\r\n\r\n    this.addEventListener(this.window, 'beforeunload', this.handleWindowBeforeunload)\r\n    this.addEventListener(this.window, 'focus', this.handleWindowFocus)\r\n    this.addEventListener(this.window, 'blur', this.handleWindowBlur)\r\n    this.addEventListener(this.window, 'resize', this.handleWindowResize)\r\n\r\n    this.addEventListener(this.document, 'keyup', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'keydown', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'drop', this.handleDocumentDrop)\r\n    this.addEventListener(this.document, 'dragover', this.handleDocumentDragover)\r\n    this.addEventListener(this.document, 'contextmenu', this.handleDocumentContextmenu)\r\n    this.subscriptions.add(listen(this.document, 'click', 'a', this.handleLinkClick))\r\n    this.subscriptions.add(listen(this.document, 'submit', 'form', this.handleFormSubmit))\r\n\r\n    this.subscriptions.add(this.applicationDelegate.onDidEnterFullScreen(this.handleEnterFullScreen))\r\n    this.subscriptions.add(this.applicationDelegate.onDidLeaveFullScreen(this.handleLeaveFullScreen))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js","name":"WindowEventHandler.addEventListener","start_line":102,"end_line":107,"comment":[],"params":["target","eventName","handler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js","name":"addEventListener","line":60,"func_location":"WindowEventHandler.initialize","func_start_line":31,"func_end_line":67,"args":[".document",{"type":"string"},".handleDocumentDragover"],"code":"  initialize (window, document) {\r\n    this.window = window\r\n    this.document = document\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.window, {\r\n      'window:toggle-full-screen': this.handleWindowToggleFullScreen,\r\n      'window:close': this.handleWindowClose,\r\n      'window:reload': this.handleWindowReload,\r\n      'window:toggle-dev-tools': this.handleWindowToggleDevTools\r\n    }))\r\n\r\n    if (['win32', 'linux'].includes(process.platform)) {\r\n      this.subscriptions.add(this.atomEnvironment.commands.add(this.window,\r\n        {'window:toggle-menu-bar': this.handleWindowToggleMenuBar})\r\n      )\r\n    }\r\n\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.document, {\r\n      'core:focus-next': this.handleFocusNext,\r\n      'core:focus-previous': this.handleFocusPrevious\r\n    }))\r\n\r\n    this.addEventListener(this.window, 'beforeunload', this.handleWindowBeforeunload)\r\n    this.addEventListener(this.window, 'focus', this.handleWindowFocus)\r\n    this.addEventListener(this.window, 'blur', this.handleWindowBlur)\r\n    this.addEventListener(this.window, 'resize', this.handleWindowResize)\r\n\r\n    this.addEventListener(this.document, 'keyup', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'keydown', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'drop', this.handleDocumentDrop)\r\n    this.addEventListener(this.document, 'dragover', this.handleDocumentDragover)\r\n    this.addEventListener(this.document, 'contextmenu', this.handleDocumentContextmenu)\r\n    this.subscriptions.add(listen(this.document, 'click', 'a', this.handleLinkClick))\r\n    this.subscriptions.add(listen(this.document, 'submit', 'form', this.handleFormSubmit))\r\n\r\n    this.subscriptions.add(this.applicationDelegate.onDidEnterFullScreen(this.handleEnterFullScreen))\r\n    this.subscriptions.add(this.applicationDelegate.onDidLeaveFullScreen(this.handleLeaveFullScreen))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js","name":"WindowEventHandler.addEventListener","start_line":102,"end_line":107,"comment":[],"params":["target","eventName","handler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js","name":"addEventListener","line":61,"func_location":"WindowEventHandler.initialize","func_start_line":31,"func_end_line":67,"args":[".document",{"type":"string"},".handleDocumentContextmenu"],"code":"  initialize (window, document) {\r\n    this.window = window\r\n    this.document = document\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.window, {\r\n      'window:toggle-full-screen': this.handleWindowToggleFullScreen,\r\n      'window:close': this.handleWindowClose,\r\n      'window:reload': this.handleWindowReload,\r\n      'window:toggle-dev-tools': this.handleWindowToggleDevTools\r\n    }))\r\n\r\n    if (['win32', 'linux'].includes(process.platform)) {\r\n      this.subscriptions.add(this.atomEnvironment.commands.add(this.window,\r\n        {'window:toggle-menu-bar': this.handleWindowToggleMenuBar})\r\n      )\r\n    }\r\n\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.document, {\r\n      'core:focus-next': this.handleFocusNext,\r\n      'core:focus-previous': this.handleFocusPrevious\r\n    }))\r\n\r\n    this.addEventListener(this.window, 'beforeunload', this.handleWindowBeforeunload)\r\n    this.addEventListener(this.window, 'focus', this.handleWindowFocus)\r\n    this.addEventListener(this.window, 'blur', this.handleWindowBlur)\r\n    this.addEventListener(this.window, 'resize', this.handleWindowResize)\r\n\r\n    this.addEventListener(this.document, 'keyup', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'keydown', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'drop', this.handleDocumentDrop)\r\n    this.addEventListener(this.document, 'dragover', this.handleDocumentDragover)\r\n    this.addEventListener(this.document, 'contextmenu', this.handleDocumentContextmenu)\r\n    this.subscriptions.add(listen(this.document, 'click', 'a', this.handleLinkClick))\r\n    this.subscriptions.add(listen(this.document, 'submit', 'form', this.handleFormSubmit))\r\n\r\n    this.subscriptions.add(this.applicationDelegate.onDidEnterFullScreen(this.handleEnterFullScreen))\r\n    this.subscriptions.add(this.applicationDelegate.onDidLeaveFullScreen(this.handleLeaveFullScreen))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js","name":"WindowEventHandler.addEventListener","start_line":102,"end_line":107,"comment":[],"params":["target","eventName","handler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"measure","line":172,"func_location":"Package.initializeIfNeeded","func_start_line":170,"func_end_line":187},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.measure","start_line":80,"end_line":85,"comment":[],"params":["key","fn"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"getLoadSettings","line":463,"func_location":"AtomEnvironment.inSafeMode","func_start_line":462,"func_end_line":465,"args":[],"comment":[" Public: Returns a {Boolean} that is `true` if the current window is in safe mode."],"code":"  inSafeMode () {\r\n    if (this.safeMode == null) this.safeMode = this.getLoadSettings().safeMode\r\n    return this.safeMode\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.getLoadSettings","start_line":525,"end_line":527,"comment":[" Public: Get the load settings for the current window.",""," Returns an {Object} containing all the load setting key/value pairs."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js","name":"addChild","line":170,"func_location":"PaneAxis.insertChildAfter","func_start_line":168,"func_end_line":171,"args":["newChild",null],"code":"  insertChildAfter (currentChild, newChild) {\r\n    const index = this.children.indexOf(currentChild)\r\n    return this.addChild(newChild, index + 1)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js","name":"PaneAxis.addChild","start_line":117,"end_line":123,"comment":[],"params":["child","index"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js","name":"addChild","line":165,"func_location":"PaneAxis.insertChildBefore","func_start_line":163,"func_end_line":166,"args":["newChild","index"],"code":"  insertChildBefore (currentChild, newChild) {\r\n    const index = this.children.indexOf(currentChild)\r\n    return this.addChild(newChild, index)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js","name":"PaneAxis.addChild","start_line":117,"end_line":123,"comment":[],"params":["child","index"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"insertText","line":1396,"func_location":"TextEditor.insertNewline","func_start_line":1395,"func_end_line":1397,"args":[{"type":"string"},"options"],"comment":[" Essential: For each selection, replace the selected text with a newline.",""," * `options` (optional) {Object}","   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)"],"code":"  insertNewline (options = {}) {\r\n    return this.insertText('\\n', options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.insertText","start_line":1367,"end_line":1389,"comment":[" Essential: For each selection, replace the selected text with the given text.",""," * `text` A {String} representing the text to insert."," * `options` (optional) See {Selection::insertText}.",""," Returns a {Range} when the text has been inserted. Returns a {Boolean} `false` when the text has not been inserted."],"params":["text","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"ensureWritable","line":452,"func_location":"Selection.insertText","func_start_line":451,"func_end_line":513,"args":[{"type":"string"},"options"],"comment":["\r\n  Section: Modifying the selected text\r\n  "," Public: Replaces text at the current selection.",""," * `text` A {String} representing the text to add"," * `options` (optional) {Object} with keys:","   * `select` If `true`, selects the newly added text.","   * `autoIndent` If `true`, indents all inserted text appropriately.","   * `autoIndentNewline` If `true`, indent newline appropriately.","   * `autoDecreaseIndent` If `true`, decreases indent level appropriately","     (for example, when a closing bracket is inserted).","   * `preserveTrailingLineIndentation` By default, when pasting multiple","   lines, Atom attempts to preserve the relative indent level between the","   first line and trailing lines, even if the indent level of the first","   line has changed from the copied text. If this option is `true`, this","   behavior is suppressed.","     level between the first lines and the trailing lines.","   * `normalizeLineEndings` (optional) {Boolean} (default: true)","   * `undo` *Deprecated* If `skip`, skips the undo stack for this operation. This property is deprecated. Call groupLastChanges() on the {TextBuffer} afterward instead.","   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)"],"code":"  insertText (text, options = {}) {\r\n    if (!this.ensureWritable('insertText', options)) return\r\n\r\n    let desiredIndentLevel, indentAdjustment\r\n    const oldBufferRange = this.getBufferRange()\r\n    const wasReversed = this.isReversed()\r\n    this.clear(options)\r\n\r\n    let autoIndentFirstLine = false\r\n    const precedingText = this.editor.getTextInRange([[oldBufferRange.start.row, 0], oldBufferRange.start])\r\n    const remainingLines = text.split('\\n')\r\n    const firstInsertedLine = remainingLines.shift()\r\n\r\n    if (options.indentBasis != null && !options.preserveTrailingLineIndentation) {\r\n      indentAdjustment = this.editor.indentLevelForLine(precedingText) - options.indentBasis\r\n      this.adjustIndent(remainingLines, indentAdjustment)\r\n    }\r\n\r\n    const textIsAutoIndentable = (text === '\\n') || (text === '\\r\\n') || NonWhitespaceRegExp.test(text)\r\n    if (options.autoIndent && textIsAutoIndentable && !NonWhitespaceRegExp.test(precedingText) && (remainingLines.length > 0)) {\r\n      autoIndentFirstLine = true\r\n      const firstLine = precedingText + firstInsertedLine\r\n      const languageMode = this.editor.buffer.getLanguageMode()\r\n      desiredIndentLevel = (\r\n        languageMode.suggestedIndentForLineAtBufferRow &&\r\n        languageMode.suggestedIndentForLineAtBufferRow(\r\n          oldBufferRange.start.row,\r\n          firstLine,\r\n          this.editor.getTabLength()\r\n        )\r\n      )\r\n      if (desiredIndentLevel != null) {\r\n        indentAdjustment = desiredIndentLevel - this.editor.indentLevelForLine(firstLine)\r\n        this.adjustIndent(remainingLines, indentAdjustment)\r\n      }\r\n    }\r\n\r\n    text = firstInsertedLine\r\n    if (remainingLines.length > 0) text += `\\n${remainingLines.join('\\n')}`\r\n\r\n    const newBufferRange = this.editor.buffer.setTextInRange(oldBufferRange, text, pick(options, 'undo', 'normalizeLineEndings'))\r\n\r\n    if (options.select) {\r\n      this.setBufferRange(newBufferRange, {reversed: wasReversed})\r\n    } else {\r\n      if (wasReversed) this.cursor.setBufferPosition(newBufferRange.end)\r\n    }\r\n\r\n    if (autoIndentFirstLine) {\r\n      this.editor.setIndentationForBufferRow(oldBufferRange.start.row, desiredIndentLevel)\r\n    }\r\n\r\n    if (options.autoIndentNewline && (text === '\\n')) {\r\n      this.editor.autoIndentBufferRow(newBufferRange.end.row, {preserveLeadingWhitespace: true, skipBlankLines: false})\r\n    } else if (options.autoDecreaseIndent && NonWhitespaceRegExp.test(text)) {\r\n      this.editor.autoDecreaseIndentForBufferRow(newBufferRange.start.row)\r\n    }\r\n\r\n    const autoscroll = options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.autoscroll()\r\n\r\n    return newBufferRange\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.ensureWritable","start_line":412,"end_line":427,"comment":[" Private: Ensure that the {TextEditor} is not marked read-only before allowing a buffer modification to occur. if"," the editor is read-only, require an explicit opt-in option to proceed (`bypassReadOnly`) or throw an Error."],"params":["methodName","opts"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"getBufferRange","line":455,"func_location":"Selection.insertText","func_start_line":451,"func_end_line":513,"args":[],"comment":["\r\n  Section: Modifying the selected text\r\n  "," Public: Replaces text at the current selection.",""," * `text` A {String} representing the text to add"," * `options` (optional) {Object} with keys:","   * `select` If `true`, selects the newly added text.","   * `autoIndent` If `true`, indents all inserted text appropriately.","   * `autoIndentNewline` If `true`, indent newline appropriately.","   * `autoDecreaseIndent` If `true`, decreases indent level appropriately","     (for example, when a closing bracket is inserted).","   * `preserveTrailingLineIndentation` By default, when pasting multiple","   lines, Atom attempts to preserve the relative indent level between the","   first line and trailing lines, even if the indent level of the first","   line has changed from the copied text. If this option is `true`, this","   behavior is suppressed.","     level between the first lines and the trailing lines.","   * `normalizeLineEndings` (optional) {Boolean} (default: true)","   * `undo` *Deprecated* If `skip`, skips the undo stack for this operation. This property is deprecated. Call groupLastChanges() on the {TextBuffer} afterward instead.","   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)"],"code":"  insertText (text, options = {}) {\r\n    if (!this.ensureWritable('insertText', options)) return\r\n\r\n    let desiredIndentLevel, indentAdjustment\r\n    const oldBufferRange = this.getBufferRange()\r\n    const wasReversed = this.isReversed()\r\n    this.clear(options)\r\n\r\n    let autoIndentFirstLine = false\r\n    const precedingText = this.editor.getTextInRange([[oldBufferRange.start.row, 0], oldBufferRange.start])\r\n    const remainingLines = text.split('\\n')\r\n    const firstInsertedLine = remainingLines.shift()\r\n\r\n    if (options.indentBasis != null && !options.preserveTrailingLineIndentation) {\r\n      indentAdjustment = this.editor.indentLevelForLine(precedingText) - options.indentBasis\r\n      this.adjustIndent(remainingLines, indentAdjustment)\r\n    }\r\n\r\n    const textIsAutoIndentable = (text === '\\n') || (text === '\\r\\n') || NonWhitespaceRegExp.test(text)\r\n    if (options.autoIndent && textIsAutoIndentable && !NonWhitespaceRegExp.test(precedingText) && (remainingLines.length > 0)) {\r\n      autoIndentFirstLine = true\r\n      const firstLine = precedingText + firstInsertedLine\r\n      const languageMode = this.editor.buffer.getLanguageMode()\r\n      desiredIndentLevel = (\r\n        languageMode.suggestedIndentForLineAtBufferRow &&\r\n        languageMode.suggestedIndentForLineAtBufferRow(\r\n          oldBufferRange.start.row,\r\n          firstLine,\r\n          this.editor.getTabLength()\r\n        )\r\n      )\r\n      if (desiredIndentLevel != null) {\r\n        indentAdjustment = desiredIndentLevel - this.editor.indentLevelForLine(firstLine)\r\n        this.adjustIndent(remainingLines, indentAdjustment)\r\n      }\r\n    }\r\n\r\n    text = firstInsertedLine\r\n    if (remainingLines.length > 0) text += `\\n${remainingLines.join('\\n')}`\r\n\r\n    const newBufferRange = this.editor.buffer.setTextInRange(oldBufferRange, text, pick(options, 'undo', 'normalizeLineEndings'))\r\n\r\n    if (options.select) {\r\n      this.setBufferRange(newBufferRange, {reversed: wasReversed})\r\n    } else {\r\n      if (wasReversed) this.cursor.setBufferPosition(newBufferRange.end)\r\n    }\r\n\r\n    if (autoIndentFirstLine) {\r\n      this.editor.setIndentationForBufferRow(oldBufferRange.start.row, desiredIndentLevel)\r\n    }\r\n\r\n    if (options.autoIndentNewline && (text === '\\n')) {\r\n      this.editor.autoIndentBufferRow(newBufferRange.end.row, {preserveLeadingWhitespace: true, skipBlankLines: false})\r\n    } else if (options.autoDecreaseIndent && NonWhitespaceRegExp.test(text)) {\r\n      this.editor.autoDecreaseIndentForBufferRow(newBufferRange.start.row)\r\n    }\r\n\r\n    const autoscroll = options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.autoscroll()\r\n\r\n    return newBufferRange\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.getBufferRange","start_line":79,"end_line":81,"comment":[" Public: Returns the buffer {Range} for the selection."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"isReversed","line":456,"func_location":"Selection.insertText","func_start_line":451,"func_end_line":513,"args":[],"comment":["\r\n  Section: Modifying the selected text\r\n  "," Public: Replaces text at the current selection.",""," * `text` A {String} representing the text to add"," * `options` (optional) {Object} with keys:","   * `select` If `true`, selects the newly added text.","   * `autoIndent` If `true`, indents all inserted text appropriately.","   * `autoIndentNewline` If `true`, indent newline appropriately.","   * `autoDecreaseIndent` If `true`, decreases indent level appropriately","     (for example, when a closing bracket is inserted).","   * `preserveTrailingLineIndentation` By default, when pasting multiple","   lines, Atom attempts to preserve the relative indent level between the","   first line and trailing lines, even if the indent level of the first","   line has changed from the copied text. If this option is `true`, this","   behavior is suppressed.","     level between the first lines and the trailing lines.","   * `normalizeLineEndings` (optional) {Boolean} (default: true)","   * `undo` *Deprecated* If `skip`, skips the undo stack for this operation. This property is deprecated. Call groupLastChanges() on the {TextBuffer} afterward instead.","   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)"],"code":"  insertText (text, options = {}) {\r\n    if (!this.ensureWritable('insertText', options)) return\r\n\r\n    let desiredIndentLevel, indentAdjustment\r\n    const oldBufferRange = this.getBufferRange()\r\n    const wasReversed = this.isReversed()\r\n    this.clear(options)\r\n\r\n    let autoIndentFirstLine = false\r\n    const precedingText = this.editor.getTextInRange([[oldBufferRange.start.row, 0], oldBufferRange.start])\r\n    const remainingLines = text.split('\\n')\r\n    const firstInsertedLine = remainingLines.shift()\r\n\r\n    if (options.indentBasis != null && !options.preserveTrailingLineIndentation) {\r\n      indentAdjustment = this.editor.indentLevelForLine(precedingText) - options.indentBasis\r\n      this.adjustIndent(remainingLines, indentAdjustment)\r\n    }\r\n\r\n    const textIsAutoIndentable = (text === '\\n') || (text === '\\r\\n') || NonWhitespaceRegExp.test(text)\r\n    if (options.autoIndent && textIsAutoIndentable && !NonWhitespaceRegExp.test(precedingText) && (remainingLines.length > 0)) {\r\n      autoIndentFirstLine = true\r\n      const firstLine = precedingText + firstInsertedLine\r\n      const languageMode = this.editor.buffer.getLanguageMode()\r\n      desiredIndentLevel = (\r\n        languageMode.suggestedIndentForLineAtBufferRow &&\r\n        languageMode.suggestedIndentForLineAtBufferRow(\r\n          oldBufferRange.start.row,\r\n          firstLine,\r\n          this.editor.getTabLength()\r\n        )\r\n      )\r\n      if (desiredIndentLevel != null) {\r\n        indentAdjustment = desiredIndentLevel - this.editor.indentLevelForLine(firstLine)\r\n        this.adjustIndent(remainingLines, indentAdjustment)\r\n      }\r\n    }\r\n\r\n    text = firstInsertedLine\r\n    if (remainingLines.length > 0) text += `\\n${remainingLines.join('\\n')}`\r\n\r\n    const newBufferRange = this.editor.buffer.setTextInRange(oldBufferRange, text, pick(options, 'undo', 'normalizeLineEndings'))\r\n\r\n    if (options.select) {\r\n      this.setBufferRange(newBufferRange, {reversed: wasReversed})\r\n    } else {\r\n      if (wasReversed) this.cursor.setBufferPosition(newBufferRange.end)\r\n    }\r\n\r\n    if (autoIndentFirstLine) {\r\n      this.editor.setIndentationForBufferRow(oldBufferRange.start.row, desiredIndentLevel)\r\n    }\r\n\r\n    if (options.autoIndentNewline && (text === '\\n')) {\r\n      this.editor.autoIndentBufferRow(newBufferRange.end.row, {preserveLeadingWhitespace: true, skipBlankLines: false})\r\n    } else if (options.autoDecreaseIndent && NonWhitespaceRegExp.test(text)) {\r\n      this.editor.autoDecreaseIndentForBufferRow(newBufferRange.start.row)\r\n    }\r\n\r\n    const autoscroll = options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.autoscroll()\r\n\r\n    return newBufferRange\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.isReversed","start_line":147,"end_line":149,"comment":[" Public: Determines if the ending position of a marker is greater than the"," starting position.",""," This can happen when, for example, you highlight text \"up\" in a {TextBuffer}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"clear","line":457,"func_location":"Selection.insertText","func_start_line":451,"func_end_line":513,"args":["options"],"comment":["\r\n  Section: Modifying the selected text\r\n  "," Public: Replaces text at the current selection.",""," * `text` A {String} representing the text to add"," * `options` (optional) {Object} with keys:","   * `select` If `true`, selects the newly added text.","   * `autoIndent` If `true`, indents all inserted text appropriately.","   * `autoIndentNewline` If `true`, indent newline appropriately.","   * `autoDecreaseIndent` If `true`, decreases indent level appropriately","     (for example, when a closing bracket is inserted).","   * `preserveTrailingLineIndentation` By default, when pasting multiple","   lines, Atom attempts to preserve the relative indent level between the","   first line and trailing lines, even if the indent level of the first","   line has changed from the copied text. If this option is `true`, this","   behavior is suppressed.","     level between the first lines and the trailing lines.","   * `normalizeLineEndings` (optional) {Boolean} (default: true)","   * `undo` *Deprecated* If `skip`, skips the undo stack for this operation. This property is deprecated. Call groupLastChanges() on the {TextBuffer} afterward instead.","   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)"],"code":"  insertText (text, options = {}) {\r\n    if (!this.ensureWritable('insertText', options)) return\r\n\r\n    let desiredIndentLevel, indentAdjustment\r\n    const oldBufferRange = this.getBufferRange()\r\n    const wasReversed = this.isReversed()\r\n    this.clear(options)\r\n\r\n    let autoIndentFirstLine = false\r\n    const precedingText = this.editor.getTextInRange([[oldBufferRange.start.row, 0], oldBufferRange.start])\r\n    const remainingLines = text.split('\\n')\r\n    const firstInsertedLine = remainingLines.shift()\r\n\r\n    if (options.indentBasis != null && !options.preserveTrailingLineIndentation) {\r\n      indentAdjustment = this.editor.indentLevelForLine(precedingText) - options.indentBasis\r\n      this.adjustIndent(remainingLines, indentAdjustment)\r\n    }\r\n\r\n    const textIsAutoIndentable = (text === '\\n') || (text === '\\r\\n') || NonWhitespaceRegExp.test(text)\r\n    if (options.autoIndent && textIsAutoIndentable && !NonWhitespaceRegExp.test(precedingText) && (remainingLines.length > 0)) {\r\n      autoIndentFirstLine = true\r\n      const firstLine = precedingText + firstInsertedLine\r\n      const languageMode = this.editor.buffer.getLanguageMode()\r\n      desiredIndentLevel = (\r\n        languageMode.suggestedIndentForLineAtBufferRow &&\r\n        languageMode.suggestedIndentForLineAtBufferRow(\r\n          oldBufferRange.start.row,\r\n          firstLine,\r\n          this.editor.getTabLength()\r\n        )\r\n      )\r\n      if (desiredIndentLevel != null) {\r\n        indentAdjustment = desiredIndentLevel - this.editor.indentLevelForLine(firstLine)\r\n        this.adjustIndent(remainingLines, indentAdjustment)\r\n      }\r\n    }\r\n\r\n    text = firstInsertedLine\r\n    if (remainingLines.length > 0) text += `\\n${remainingLines.join('\\n')}`\r\n\r\n    const newBufferRange = this.editor.buffer.setTextInRange(oldBufferRange, text, pick(options, 'undo', 'normalizeLineEndings'))\r\n\r\n    if (options.select) {\r\n      this.setBufferRange(newBufferRange, {reversed: wasReversed})\r\n    } else {\r\n      if (wasReversed) this.cursor.setBufferPosition(newBufferRange.end)\r\n    }\r\n\r\n    if (autoIndentFirstLine) {\r\n      this.editor.setIndentationForBufferRow(oldBufferRange.start.row, desiredIndentLevel)\r\n    }\r\n\r\n    if (options.autoIndentNewline && (text === '\\n')) {\r\n      this.editor.autoIndentBufferRow(newBufferRange.end.row, {preserveLeadingWhitespace: true, skipBlankLines: false})\r\n    } else if (options.autoDecreaseIndent && NonWhitespaceRegExp.test(text)) {\r\n      this.editor.autoDecreaseIndentForBufferRow(newBufferRange.start.row)\r\n    }\r\n\r\n    const autoscroll = options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.autoscroll()\r\n\r\n    return newBufferRange\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.clear","start_line":197,"end_line":205,"comment":["\r\n  Section: Modifying the selected range\r\n  "," Public: Clears the selection, moving the marker to the head.",""," * `options` (optional) {Object} with the following keys:","   * `autoscroll` {Boolean} indicating whether to autoscroll to the new","     range. Defaults to `true` if this is the most recently added selection,","     `false` otherwise."],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"setBufferRange","line":494,"func_location":"Selection.insertText","func_start_line":451,"func_end_line":513,"args":["newBufferRange",null],"comment":["\r\n  Section: Modifying the selected text\r\n  "," Public: Replaces text at the current selection.",""," * `text` A {String} representing the text to add"," * `options` (optional) {Object} with keys:","   * `select` If `true`, selects the newly added text.","   * `autoIndent` If `true`, indents all inserted text appropriately.","   * `autoIndentNewline` If `true`, indent newline appropriately.","   * `autoDecreaseIndent` If `true`, decreases indent level appropriately","     (for example, when a closing bracket is inserted).","   * `preserveTrailingLineIndentation` By default, when pasting multiple","   lines, Atom attempts to preserve the relative indent level between the","   first line and trailing lines, even if the indent level of the first","   line has changed from the copied text. If this option is `true`, this","   behavior is suppressed.","     level between the first lines and the trailing lines.","   * `normalizeLineEndings` (optional) {Boolean} (default: true)","   * `undo` *Deprecated* If `skip`, skips the undo stack for this operation. This property is deprecated. Call groupLastChanges() on the {TextBuffer} afterward instead.","   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)"],"code":"  insertText (text, options = {}) {\r\n    if (!this.ensureWritable('insertText', options)) return\r\n\r\n    let desiredIndentLevel, indentAdjustment\r\n    const oldBufferRange = this.getBufferRange()\r\n    const wasReversed = this.isReversed()\r\n    this.clear(options)\r\n\r\n    let autoIndentFirstLine = false\r\n    const precedingText = this.editor.getTextInRange([[oldBufferRange.start.row, 0], oldBufferRange.start])\r\n    const remainingLines = text.split('\\n')\r\n    const firstInsertedLine = remainingLines.shift()\r\n\r\n    if (options.indentBasis != null && !options.preserveTrailingLineIndentation) {\r\n      indentAdjustment = this.editor.indentLevelForLine(precedingText) - options.indentBasis\r\n      this.adjustIndent(remainingLines, indentAdjustment)\r\n    }\r\n\r\n    const textIsAutoIndentable = (text === '\\n') || (text === '\\r\\n') || NonWhitespaceRegExp.test(text)\r\n    if (options.autoIndent && textIsAutoIndentable && !NonWhitespaceRegExp.test(precedingText) && (remainingLines.length > 0)) {\r\n      autoIndentFirstLine = true\r\n      const firstLine = precedingText + firstInsertedLine\r\n      const languageMode = this.editor.buffer.getLanguageMode()\r\n      desiredIndentLevel = (\r\n        languageMode.suggestedIndentForLineAtBufferRow &&\r\n        languageMode.suggestedIndentForLineAtBufferRow(\r\n          oldBufferRange.start.row,\r\n          firstLine,\r\n          this.editor.getTabLength()\r\n        )\r\n      )\r\n      if (desiredIndentLevel != null) {\r\n        indentAdjustment = desiredIndentLevel - this.editor.indentLevelForLine(firstLine)\r\n        this.adjustIndent(remainingLines, indentAdjustment)\r\n      }\r\n    }\r\n\r\n    text = firstInsertedLine\r\n    if (remainingLines.length > 0) text += `\\n${remainingLines.join('\\n')}`\r\n\r\n    const newBufferRange = this.editor.buffer.setTextInRange(oldBufferRange, text, pick(options, 'undo', 'normalizeLineEndings'))\r\n\r\n    if (options.select) {\r\n      this.setBufferRange(newBufferRange, {reversed: wasReversed})\r\n    } else {\r\n      if (wasReversed) this.cursor.setBufferPosition(newBufferRange.end)\r\n    }\r\n\r\n    if (autoIndentFirstLine) {\r\n      this.editor.setIndentationForBufferRow(oldBufferRange.start.row, desiredIndentLevel)\r\n    }\r\n\r\n    if (options.autoIndentNewline && (text === '\\n')) {\r\n      this.editor.autoIndentBufferRow(newBufferRange.end.row, {preserveLeadingWhitespace: true, skipBlankLines: false})\r\n    } else if (options.autoDecreaseIndent && NonWhitespaceRegExp.test(text)) {\r\n      this.editor.autoDecreaseIndentForBufferRow(newBufferRange.start.row)\r\n    }\r\n\r\n    const autoscroll = options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.autoscroll()\r\n\r\n    return newBufferRange\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.setBufferRange","start_line":92,"end_line":104,"comment":[" Public: Modifies the buffer {Range} for the selection.",""," * `bufferRange` The new {Range} to select."," * `options` (optional) {Object} with the keys:","   * `preserveFolds` if `true`, the fold settings are preserved after the","     selection moves.","   * `autoscroll` {Boolean} indicating whether to autoscroll to the new","     range. Defaults to `true` if this is the most recently added selection,","     `false` otherwise."],"params":["bufferRange","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"isLastSelection","line":509,"func_location":"Selection.insertText","func_start_line":451,"func_end_line":513,"args":[],"comment":["\r\n  Section: Modifying the selected text\r\n  "," Public: Replaces text at the current selection.",""," * `text` A {String} representing the text to add"," * `options` (optional) {Object} with keys:","   * `select` If `true`, selects the newly added text.","   * `autoIndent` If `true`, indents all inserted text appropriately.","   * `autoIndentNewline` If `true`, indent newline appropriately.","   * `autoDecreaseIndent` If `true`, decreases indent level appropriately","     (for example, when a closing bracket is inserted).","   * `preserveTrailingLineIndentation` By default, when pasting multiple","   lines, Atom attempts to preserve the relative indent level between the","   first line and trailing lines, even if the indent level of the first","   line has changed from the copied text. If this option is `true`, this","   behavior is suppressed.","     level between the first lines and the trailing lines.","   * `normalizeLineEndings` (optional) {Boolean} (default: true)","   * `undo` *Deprecated* If `skip`, skips the undo stack for this operation. This property is deprecated. Call groupLastChanges() on the {TextBuffer} afterward instead.","   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)"],"code":"  insertText (text, options = {}) {\r\n    if (!this.ensureWritable('insertText', options)) return\r\n\r\n    let desiredIndentLevel, indentAdjustment\r\n    const oldBufferRange = this.getBufferRange()\r\n    const wasReversed = this.isReversed()\r\n    this.clear(options)\r\n\r\n    let autoIndentFirstLine = false\r\n    const precedingText = this.editor.getTextInRange([[oldBufferRange.start.row, 0], oldBufferRange.start])\r\n    const remainingLines = text.split('\\n')\r\n    const firstInsertedLine = remainingLines.shift()\r\n\r\n    if (options.indentBasis != null && !options.preserveTrailingLineIndentation) {\r\n      indentAdjustment = this.editor.indentLevelForLine(precedingText) - options.indentBasis\r\n      this.adjustIndent(remainingLines, indentAdjustment)\r\n    }\r\n\r\n    const textIsAutoIndentable = (text === '\\n') || (text === '\\r\\n') || NonWhitespaceRegExp.test(text)\r\n    if (options.autoIndent && textIsAutoIndentable && !NonWhitespaceRegExp.test(precedingText) && (remainingLines.length > 0)) {\r\n      autoIndentFirstLine = true\r\n      const firstLine = precedingText + firstInsertedLine\r\n      const languageMode = this.editor.buffer.getLanguageMode()\r\n      desiredIndentLevel = (\r\n        languageMode.suggestedIndentForLineAtBufferRow &&\r\n        languageMode.suggestedIndentForLineAtBufferRow(\r\n          oldBufferRange.start.row,\r\n          firstLine,\r\n          this.editor.getTabLength()\r\n        )\r\n      )\r\n      if (desiredIndentLevel != null) {\r\n        indentAdjustment = desiredIndentLevel - this.editor.indentLevelForLine(firstLine)\r\n        this.adjustIndent(remainingLines, indentAdjustment)\r\n      }\r\n    }\r\n\r\n    text = firstInsertedLine\r\n    if (remainingLines.length > 0) text += `\\n${remainingLines.join('\\n')}`\r\n\r\n    const newBufferRange = this.editor.buffer.setTextInRange(oldBufferRange, text, pick(options, 'undo', 'normalizeLineEndings'))\r\n\r\n    if (options.select) {\r\n      this.setBufferRange(newBufferRange, {reversed: wasReversed})\r\n    } else {\r\n      if (wasReversed) this.cursor.setBufferPosition(newBufferRange.end)\r\n    }\r\n\r\n    if (autoIndentFirstLine) {\r\n      this.editor.setIndentationForBufferRow(oldBufferRange.start.row, desiredIndentLevel)\r\n    }\r\n\r\n    if (options.autoIndentNewline && (text === '\\n')) {\r\n      this.editor.autoIndentBufferRow(newBufferRange.end.row, {preserveLeadingWhitespace: true, skipBlankLines: false})\r\n    } else if (options.autoDecreaseIndent && NonWhitespaceRegExp.test(text)) {\r\n      this.editor.autoDecreaseIndentForBufferRow(newBufferRange.start.row)\r\n    }\r\n\r\n    const autoscroll = options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.autoscroll()\r\n\r\n    return newBufferRange\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.isLastSelection","start_line":29,"end_line":31,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"getLoadSettings","line":469,"func_location":"AtomEnvironment.inSpecMode","func_start_line":468,"func_end_line":471,"args":[],"comment":[" Public: Returns a {Boolean} that is `true` if the current window is running specs."],"code":"  inSpecMode () {\r\n    if (this.specMode == null) this.specMode = this.getLoadSettings().isSpec\r\n    return this.specMode\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.getLoadSettings","start_line":525,"end_line":527,"comment":[" Public: Get the load settings for the current window.",""," Returns an {Object} containing all the load setting key/value pairs."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/native-compile-cache.js","name":"savePreviousModuleCompile","line":25,"func_location":"NativeCompileCache.install","func_start_line":24,"func_end_line":27,"args":[],"code":"  install () {\r\n    this.savePreviousModuleCompile()\r\n    this.overrideModuleCompile()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/native-compile-cache.js","name":"NativeCompileCache.savePreviousModuleCompile","start_line":33,"end_line":35,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/native-compile-cache.js","name":"overrideModuleCompile","line":26,"func_location":"NativeCompileCache.install","func_start_line":24,"func_end_line":27,"args":[],"code":"  install () {\r\n    this.savePreviousModuleCompile()\r\n    this.overrideModuleCompile()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/native-compile-cache.js","name":"NativeCompileCache.overrideModuleCompile","start_line":37,"end_line":89,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js","name":"installCommand","line":66,"func_location":"CommandInstaller.installApmCommand","func_start_line":65,"func_end_line":72},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js","name":"CommandInstaller.installCommand","start_line":74,"end_line":91,"comment":[],"params":["commandPath","commandName","askForPrivilege","callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js","name":"getResourcesDirectory","line":67,"func_location":"CommandInstaller.installApmCommand","func_start_line":65,"func_end_line":72,"args":[null,{"type":"string"},{"type":"string"},{"type":"string"},{"type":"string"},{"type":"string"}],"code":"  installApmCommand (askForPrivilege, callback) {\r\n    this.installCommand(\r\n      path.join(this.getResourcesDirectory(), 'app', 'apm', 'node_modules', '.bin', 'apm'),\r\n      this.getCommandNameForChannel('apm'),\r\n      askForPrivilege,\r\n      callback\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js","name":"CommandInstaller.getResourcesDirectory","start_line":18,"end_line":20,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js","name":"getCommandNameForChannel","line":68,"func_location":"CommandInstaller.installApmCommand","func_start_line":65,"func_end_line":72,"args":[{"type":"string"}],"code":"  installApmCommand (askForPrivilege, callback) {\r\n    this.installCommand(\r\n      path.join(this.getResourcesDirectory(), 'app', 'apm', 'node_modules', '.bin', 'apm'),\r\n      this.getCommandNameForChannel('apm'),\r\n      askForPrivilege,\r\n      callback\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js","name":"CommandInstaller.getCommandNameForChannel","start_line":42,"end_line":54,"comment":[],"params":["commandName"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js","name":"installCommand","line":57,"func_location":"CommandInstaller.installAtomCommand","func_start_line":56,"func_end_line":63},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js","name":"CommandInstaller.installCommand","start_line":74,"end_line":91,"comment":[],"params":["commandPath","commandName","askForPrivilege","callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js","name":"getResourcesDirectory","line":58,"func_location":"CommandInstaller.installAtomCommand","func_start_line":56,"func_end_line":63,"args":[null,{"type":"string"},{"type":"string"}],"code":"  installAtomCommand (askForPrivilege, callback) {\r\n    this.installCommand(\r\n      path.join(this.getResourcesDirectory(), 'app', 'atom.sh'),\r\n      this.getCommandNameForChannel('atom'),\r\n      askForPrivilege,\r\n      callback\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js","name":"CommandInstaller.getResourcesDirectory","start_line":18,"end_line":20,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js","name":"getCommandNameForChannel","line":59,"func_location":"CommandInstaller.installAtomCommand","func_start_line":56,"func_end_line":63,"args":[{"type":"string"}],"code":"  installAtomCommand (askForPrivilege, callback) {\r\n    this.installCommand(\r\n      path.join(this.getResourcesDirectory(), 'app', 'atom.sh'),\r\n      this.getCommandNameForChannel('atom'),\r\n      askForPrivilege,\r\n      callback\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js","name":"CommandInstaller.getCommandNameForChannel","start_line":42,"end_line":54,"comment":[],"params":["commandName"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js","name":"getInstallDirectory","line":77,"func_location":"CommandInstaller.installCommand","func_start_line":74,"func_end_line":91,"args":[null,"commandName"],"code":"  installCommand (commandPath, commandName, askForPrivilege, callback) {\r\n    if (process.platform !== 'darwin') return callback()\r\n\r\n    const destinationPath = path.join(this.getInstallDirectory(), commandName)\r\n\r\n    fs.readlink(destinationPath, (error, realpath) => {\r\n      if (error && error.code !== 'ENOENT') return callback(error)\r\n      if (realpath === commandPath) return callback(null, commandName)\r\n      this.createSymlink(fs, commandPath, destinationPath, error => {\r\n        if (error && error.code === 'EACCES' && askForPrivilege) {\r\n          const fsAdmin = require('fs-admin')\r\n          this.createSymlink(fsAdmin, commandPath, destinationPath, (error) => { callback(error, commandName) })\r\n        } else {\r\n          callback(error)\r\n        }\r\n      })\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js","name":"CommandInstaller.getInstallDirectory","start_line":14,"end_line":16,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js","name":"installAtomCommand","line":30,"func_location":"CommandInstaller.installShellCommandsInteractively","func_start_line":22,"func_end_line":40},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js","name":"CommandInstaller.installAtomCommand","start_line":56,"end_line":63,"comment":[],"params":["askForPrivilege","callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"getBufferRange","line":167,"func_location":"Selection.intersectsBufferRange","func_start_line":166,"func_end_line":168,"args":["bufferRange"],"comment":[" Public: Identifies if a selection intersects with a given buffer range.",""," * `bufferRange` A {Range} to check against.",""," Returns a {Boolean}"],"code":"  intersectsBufferRange (bufferRange) {\r\n    return this.getBufferRange().intersectsWith(bufferRange)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.getBufferRange","start_line":79,"end_line":81,"comment":[" Public: Returns the buffer {Range} for the selection."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"getScreenRange","line":175,"func_location":"Selection.intersectsScreenRow","func_start_line":174,"func_end_line":176,"args":["screenRow"],"code":"  intersectsScreenRow (screenRow) {\r\n    return this.getScreenRange().intersectsRow(screenRow)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.getScreenRange","start_line":66,"end_line":68,"comment":["\r\n  Section: Managing the selection range\r\n  "," Public: Returns the screen {Range} for the selection."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"getScreenRange","line":171,"func_location":"Selection.intersectsScreenRowRange","func_start_line":170,"func_end_line":172,"args":["startRow","endRow"],"code":"  intersectsScreenRowRange (startRow, endRow) {\r\n    return this.getScreenRange().intersectsRowRange(startRow, endRow)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.getScreenRange","start_line":66,"end_line":68,"comment":["\r\n  Section: Managing the selection range\r\n  "," Public: Returns the screen {Range} for the selection."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getFirstVisibleScreenRow","line":328,"func_location":"TextEditorElement.intersectsVisibleRowRange","func_start_line":326,"func_end_line":331,"args":[],"code":"  intersectsVisibleRowRange (startRow, endRow) {\r\n    return !(\r\n      endRow <= this.getFirstVisibleScreenRow() ||\r\n      this.getLastVisibleScreenRow() <= startRow\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getFirstVisibleScreenRow","start_line":314,"end_line":316,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getLastVisibleScreenRow","line":329,"func_location":"TextEditorElement.intersectsVisibleRowRange","func_start_line":326,"func_end_line":331,"args":[],"code":"  intersectsVisibleRowRange (startRow, endRow) {\r\n    return !(\r\n      endRow <= this.getFirstVisibleScreenRow() ||\r\n      this.getLastVisibleScreenRow() <= startRow\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getLastVisibleScreenRow","start_line":318,"end_line":320,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"getBufferRange","line":184,"func_location":"Selection.intersectsWith","func_start_line":183,"func_end_line":185,"args":[null,"exclusive"],"comment":[" Public: Identifies if a selection intersects with another selection.",""," * `otherSelection` A {Selection} to check against.",""," Returns a {Boolean}"],"code":"  intersectsWith (otherSelection, exclusive) {\r\n    return this.getBufferRange().intersectsWith(otherSelection.getBufferRange(), exclusive)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.getBufferRange","start_line":79,"end_line":81,"comment":[" Public: Returns the buffer {Range} for the selection."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"scheduleUpdate","line":2577,"func_location":"TextEditorComponent.invalidateBlockDecorationDimensions","func_start_line":2575,"func_end_line":2578,"args":[],"code":"  invalidateBlockDecorationDimensions (decoration) {\r\n    this.blockDecorationsToMeasure.add(decoration)\r\n    this.scheduleUpdate()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.scheduleUpdate","start_line":204,"end_line":219,"comment":[],"params":["nextUpdateOnlyBlinksCursors"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":307,"func_location":"TextEditorElement.invalidateBlockDecorationDimensions","func_start_line":306,"func_end_line":308,"args":[null],"comment":[" Experimental: Invalidate the passed block {Decoration}'s dimensions,"," forcing them to be recalculated and the surrounding content to be adjusted"," on the next animation frame.",""," * {blockDecoration} A {Decoration} representing the block decoration you"," want to update the dimensions of."],"code":"  invalidateBlockDecorationDimensions () {\r\n    this.getComponent().invalidateBlockDecorationDimensions(...arguments)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"tokenizeInBackground","line":339,"func_location":"TextMateLanguageMode.invalidateRow","func_start_line":336,"func_end_line":340,"args":[],"code":"  invalidateRow (row) {\r\n    this.invalidRows.push(row)\r\n    this.invalidRows.sort((a, b) => a - b)\r\n    this.tokenizeInBackground()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.tokenizeInBackground","start_line":272,"end_line":280,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferPosition","line":123,"func_location":"Cursor.isAtBeginningOfLine","func_start_line":122,"func_end_line":124,"args":[],"comment":[" Public: Returns whether the cursor is at the start of a line."],"code":"  isAtBeginningOfLine () {\r\n    return this.getBufferPosition().column === 0\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferPosition","start_line":91,"end_line":93,"comment":[" Public: Returns the current buffer position as an Array."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferPosition","line":128,"func_location":"Cursor.isAtEndOfLine","func_start_line":127,"func_end_line":129,"args":[".end"],"comment":[" Public: Returns whether the cursor is on the line return character."],"code":"  isAtEndOfLine () {\r\n    return this.getBufferPosition().isEqual(this.getCurrentLineBufferRange().end)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferPosition","start_line":91,"end_line":93,"comment":[" Public: Returns the current buffer position as an Array."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getCurrentLineBufferRange","line":128,"func_location":"Cursor.isAtEndOfLine","func_start_line":127,"func_end_line":129,"args":[".end"],"comment":[" Public: Returns whether the cursor is on the line return character."],"code":"  isAtEndOfLine () {\r\n    return this.getBufferPosition().isEqual(this.getCurrentLineBufferRange().end)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getCurrentLineBufferRange","start_line":623,"end_line":625,"comment":[" Public: Returns the buffer Range for the current line.",""," * `options` (optional) {Object}","   * `includeNewline` A {Boolean} which controls whether the Range should","     include the newline."],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"isAtBeginningOfLine","line":160,"func_location":"Cursor.isBetweenWordAndNonWord","func_start_line":159,"func_end_line":169,"args":[],"comment":[" Public: Returns whether the cursor is currently between a word and non-word"," character. The non-word characters are defined by the"," `editor.nonWordCharacters` config value.",""," This method returns false if the character before or after the cursor is"," whitespace.",""," Returns a Boolean."],"code":"  isBetweenWordAndNonWord () {\r\n    if (this.isAtBeginningOfLine() || this.isAtEndOfLine()) return false\r\n\r\n    const {row, column} = this.getBufferPosition()\r\n    const range = [[row, column - 1], [row, column + 1]]\r\n    const text = this.editor.getTextInBufferRange(range)\r\n    if (/\\s/.test(text[0]) || /\\s/.test(text[1])) return false\r\n\r\n    const nonWordCharacters = this.getNonWordCharacters()\r\n    return nonWordCharacters.includes(text[0]) !== nonWordCharacters.includes(text[1])\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.isAtBeginningOfLine","start_line":122,"end_line":124,"comment":[" Public: Returns whether the cursor is at the start of a line."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"isAtEndOfLine","line":160,"func_location":"Cursor.isBetweenWordAndNonWord","func_start_line":159,"func_end_line":169,"args":[],"comment":[" Public: Returns whether the cursor is currently between a word and non-word"," character. The non-word characters are defined by the"," `editor.nonWordCharacters` config value.",""," This method returns false if the character before or after the cursor is"," whitespace.",""," Returns a Boolean."],"code":"  isBetweenWordAndNonWord () {\r\n    if (this.isAtBeginningOfLine() || this.isAtEndOfLine()) return false\r\n\r\n    const {row, column} = this.getBufferPosition()\r\n    const range = [[row, column - 1], [row, column + 1]]\r\n    const text = this.editor.getTextInBufferRange(range)\r\n    if (/\\s/.test(text[0]) || /\\s/.test(text[1])) return false\r\n\r\n    const nonWordCharacters = this.getNonWordCharacters()\r\n    return nonWordCharacters.includes(text[0]) !== nonWordCharacters.includes(text[1])\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.isAtEndOfLine","start_line":127,"end_line":129,"comment":[" Public: Returns whether the cursor is on the line return character."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferPosition","line":162,"func_location":"Cursor.isBetweenWordAndNonWord","func_start_line":159,"func_end_line":169,"args":[],"comment":[" Public: Returns whether the cursor is currently between a word and non-word"," character. The non-word characters are defined by the"," `editor.nonWordCharacters` config value.",""," This method returns false if the character before or after the cursor is"," whitespace.",""," Returns a Boolean."],"code":"  isBetweenWordAndNonWord () {\r\n    if (this.isAtBeginningOfLine() || this.isAtEndOfLine()) return false\r\n\r\n    const {row, column} = this.getBufferPosition()\r\n    const range = [[row, column - 1], [row, column + 1]]\r\n    const text = this.editor.getTextInBufferRange(range)\r\n    if (/\\s/.test(text[0]) || /\\s/.test(text[1])) return false\r\n\r\n    const nonWordCharacters = this.getNonWordCharacters()\r\n    return nonWordCharacters.includes(text[0]) !== nonWordCharacters.includes(text[1])\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferPosition","start_line":91,"end_line":93,"comment":[" Public: Returns the current buffer position as an Array."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getNonWordCharacters","line":167,"func_location":"Cursor.isBetweenWordAndNonWord","func_start_line":159,"func_end_line":169,"args":[],"comment":[" Public: Returns whether the cursor is currently between a word and non-word"," character. The non-word characters are defined by the"," `editor.nonWordCharacters` config value.",""," This method returns false if the character before or after the cursor is"," whitespace.",""," Returns a Boolean."],"code":"  isBetweenWordAndNonWord () {\r\n    if (this.isAtBeginningOfLine() || this.isAtEndOfLine()) return false\r\n\r\n    const {row, column} = this.getBufferPosition()\r\n    const range = [[row, column - 1], [row, column + 1]]\r\n    const text = this.editor.getTextInBufferRange(range)\r\n    if (/\\s/.test(text[0]) || /\\s/.test(text[1])) return false\r\n\r\n    const nonWordCharacters = this.getNonWordCharacters()\r\n    return nonWordCharacters.includes(text[0]) !== nonWordCharacters.includes(text[1])\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getNonWordCharacters","start_line":716,"end_line":718,"comment":["\r\n  Section: Private\r\n  "],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"getPackageDependencies","line":221,"func_location":"PackageManager.isBundledPackage","func_start_line":220,"func_end_line":222,"args":["name"],"comment":[" Public: Is the package with the given name bundled with Atom?",""," * `name` - The {String} package name.",""," Returns a {Boolean}."],"code":"  isBundledPackage (name) {\r\n    return this.getPackageDependencies().hasOwnProperty(name)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.getPackageDependencies","start_line":428,"end_line":430,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"getMainModulePath","line":979,"func_location":"Package.isCompatible","func_start_line":975,"func_end_line":989,"args":[],"comment":["\r\n  Section: Native Module Compatibility\r\n  "," Extended: Are all native modules depended on by this package correctly"," compiled against the current version of Atom?",""," Incompatible packages cannot be activated.",""," Returns a {Boolean}, true if compatible, false if incompatible."],"code":"  isCompatible () {\r\n    if (this.compatible == null) {\r\n      if (this.preloadedPackage) {\r\n        this.compatible = true\r\n      } else if (this.getMainModulePath()) {\r\n        this.incompatibleModules = this.getIncompatibleNativeModules()\r\n        this.compatible =\r\n          this.incompatibleModules.length === 0 &&\r\n          this.getBuildFailureOutput() == null\r\n      } else {\r\n        this.compatible = true\r\n      }\r\n    }\r\n    return this.compatible\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.getMainModulePath","start_line":786,"end_line":803,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"getIncompatibleNativeModules","line":980,"func_location":"Package.isCompatible","func_start_line":975,"func_end_line":989,"args":[],"comment":["\r\n  Section: Native Module Compatibility\r\n  "," Extended: Are all native modules depended on by this package correctly"," compiled against the current version of Atom?",""," Incompatible packages cannot be activated.",""," Returns a {Boolean}, true if compatible, false if incompatible."],"code":"  isCompatible () {\r\n    if (this.compatible == null) {\r\n      if (this.preloadedPackage) {\r\n        this.compatible = true\r\n      } else if (this.getMainModulePath()) {\r\n        this.incompatibleModules = this.getIncompatibleNativeModules()\r\n        this.compatible =\r\n          this.incompatibleModules.length === 0 &&\r\n          this.getBuildFailureOutput() == null\r\n      } else {\r\n        this.compatible = true\r\n      }\r\n    }\r\n    return this.compatible\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.getIncompatibleNativeModules","start_line":1051,"end_line":1083,"comment":[" Get the incompatible native modules that this package depends on."," This recurses through all dependencies and requires all modules that"," contain a `.node` file.",""," This information is cached in local storage on a per package/version basis"," to minimize the impact on startup time."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"getBuildFailureOutput","line":983,"func_location":"Package.isCompatible","func_start_line":975,"func_end_line":989,"args":[],"comment":["\r\n  Section: Native Module Compatibility\r\n  "," Extended: Are all native modules depended on by this package correctly"," compiled against the current version of Atom?",""," Incompatible packages cannot be activated.",""," Returns a {Boolean}, true if compatible, false if incompatible."],"code":"  isCompatible () {\r\n    if (this.compatible == null) {\r\n      if (this.preloadedPackage) {\r\n        this.compatible = true\r\n      } else if (this.getMainModulePath()) {\r\n        this.incompatibleModules = this.getIncompatibleNativeModules()\r\n        this.compatible =\r\n          this.incompatibleModules.length === 0 &&\r\n          this.getBuildFailureOutput() == null\r\n      } else {\r\n        this.compatible = true\r\n      }\r\n    }\r\n    return this.compatible\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.getBuildFailureOutput","start_line":1015,"end_line":1017,"comment":[" Extended: If a previous rebuild failed, get the contents of stderr.",""," Returns a {String} or null if no previous build failure occurred."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"isAlive","line":41,"func_location":"PaneContainer.isDestroyed","func_start_line":41,"func_end_line":41,"args":[],"code":"  isDestroyed () { return !this.isAlive() }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.isAlive","start_line":39,"end_line":39,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"isAlive","line":1046,"func_location":"Pane.isDestroyed","func_start_line":1046,"func_end_line":1046,"args":[],"comment":[" Public: Determine whether this pane has been destroyed.",""," Returns a {Boolean}."],"code":"  isDestroyed () { return !this.isAlive() }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.isAlive","start_line":1041,"end_line":1041,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"getBufferRange","line":140,"func_location":"Selection.isEmpty","func_start_line":139,"func_end_line":141,"args":[],"comment":["\r\n  Section: Info about the selection\r\n  "," Public: Determines if the selection contains anything."],"code":"  isEmpty () {\r\n    return this.getBufferRange().isEmpty()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.getBufferRange","start_line":79,"end_line":81,"comment":[" Public: Returns the buffer {Range} for the selection."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js","name":"getMessage","line":78,"func_location":"Notification.isEqual","func_start_line":77,"func_end_line":81,"args":[],"code":"  isEqual (other) {\r\n    return (this.getMessage() === other.getMessage()) &&\r\n      (this.getType() === other.getType()) &&\r\n      (this.getDetail() === other.getDetail())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js","name":"Notification.getMessage","start_line":65,"end_line":67,"comment":[" Public: Returns the {String} message."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js","name":"getType","line":79,"func_location":"Notification.isEqual","func_start_line":77,"func_end_line":81,"args":[],"code":"  isEqual (other) {\r\n    return (this.getMessage() === other.getMessage()) &&\r\n      (this.getType() === other.getType()) &&\r\n      (this.getDetail() === other.getDetail())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js","name":"Notification.getType","start_line":60,"end_line":62,"comment":["\r\n  Section: Methods\r\n  "," Public: Returns the {String} type."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js","name":"getDetail","line":80,"func_location":"Notification.isEqual","func_start_line":77,"func_end_line":81,"args":[],"code":"  isEqual (other) {\r\n    return (this.getMessage() === other.getMessage()) &&\r\n      (this.getType() === other.getType()) &&\r\n      (this.getDetail() === other.getDetail())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js","name":"Notification.getDetail","start_line":73,"end_line":75,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js","name":"parse","line":101,"func_location":"Color.isEqual","func_start_line":95,"func_end_line":109,"args":["color"],"code":"  isEqual (color) {\r\n    if (this === color) {\r\n      return true\r\n    }\r\n\r\n    if (!(color instanceof Color)) {\r\n      color = Color.parse(color)\r\n    }\r\n\r\n    if (color == null) {\r\n      return false\r\n    }\r\n\r\n    return color.red === this.red && color.blue === this.blue && color.green === this.green && color.alpha === this.alpha\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js","name":"Color.parse","start_line":14,"end_line":36,"comment":[" Essential: Parse a {String} or {Object} into a {Color}.",""," * `value` A {String} such as `'white'`, `#ff00ff`, or","   `'rgba(255, 15, 60, .75)'` or an {Object} with `red`, `green`, `blue`,","   and `alpha` properties.",""," Returns a {Color} or `null` if it cannot be parsed."],"params":["value"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"getLoadSettings","line":476,"func_location":"AtomEnvironment.isFirstLoad","func_start_line":475,"func_end_line":478,"args":[],"comment":[" Returns a {Boolean} indicating whether this the first time the window's been"," loaded."],"code":"  isFirstLoad () {\r\n    if (this.firstLoad == null) this.firstLoad = this.getLoadSettings().firstLoad\r\n    return this.firstLoad\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.getLoadSettings","start_line":525,"end_line":527,"comment":[" Public: Get the load settings for the current window.",""," Returns an {Object} containing all the load setting key/value pairs."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"endRowForFoldAtRow","line":381,"func_location":"TextMateLanguageMode.isFoldableAtRow","func_start_line":380,"func_end_line":382,"args":["row",{"type":"number"},{"type":"boolean"}],"code":"  isFoldableAtRow (row) {\r\n    return this.endRowForFoldAtRow(row, 1, true) != null\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.endRowForFoldAtRow","start_line":653,"end_line":659,"comment":[],"params":["row","tabLength","existenceOnly"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"getFoldableRangeContainingPoint","line":221,"func_location":"TreeSitterLanguageMode.isFoldableAtRow","func_start_line":219,"func_end_line":224,"args":[null,{"type":"number"},{"type":"boolean"}],"comment":["\r\n  Section - Folding\r\n  "],"code":"  isFoldableAtRow (row) {\r\n    if (this.isFoldableCache[row] != null) return this.isFoldableCache[row]\r\n    const result = this.getFoldableRangeContainingPoint(Point(row, Infinity), 0, true) != null\r\n    this.isFoldableCache[row] = result\r\n    return result\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"TreeSitterLanguageMode.getFoldableRangeContainingPoint","start_line":279,"end_line":301,"comment":[],"params":["point","tabLength","existenceOnly"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferPosition","line":179,"func_location":"Cursor.isInsideWord","func_start_line":178,"func_end_line":183,"args":[],"comment":[" Public: Returns whether this cursor is between a word's start and end.",""," * `options` (optional) {Object}","   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"","     (default: {::wordRegExp}).",""," Returns a {Boolean}"],"code":"  isInsideWord (options) {\r\n    const {row, column} = this.getBufferPosition()\r\n    const range = [[row, column], [row, Infinity]]\r\n    const text = this.editor.getTextInBufferRange(range)\r\n    return text.search((options && options.wordRegex) || this.wordRegExp()) === 0\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferPosition","start_line":91,"end_line":93,"comment":[" Public: Returns the current buffer position as an Array."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"wordRegExp","line":182,"func_location":"Cursor.isInsideWord","func_start_line":178,"func_end_line":183,"args":[null],"comment":[" Public: Returns whether this cursor is between a word's start and end.",""," * `options` (optional) {Object}","   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"","     (default: {::wordRegExp}).",""," Returns a {Boolean}"],"code":"  isInsideWord (options) {\r\n    const {row, column} = this.getBufferPosition()\r\n    const range = [[row, column], [row, Infinity]]\r\n    const text = this.editor.getTextInBufferRange(range)\r\n    return text.search((options && options.wordRegex) || this.wordRegExp()) === 0\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.wordRegExp","start_line":674,"end_line":681,"comment":[" Public: Get the RegExp used by the cursor to determine what a \"word\" is.",""," * `options` (optional) {Object} with the following keys:","   * `includeNonWordCharacters` A {Boolean} indicating whether to include","     non-word characters in the regex. (default: true)",""," Returns a {RegExp}."],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getContainer","line":146,"func_location":"Pane.isItemAllowed","func_start_line":142,"func_end_line":148,"args":[null],"comment":[" Private: Determine whether the given item is allowed to exist in this pane.",""," * `item` the Item",""," Returns a {Boolean}."],"code":"  isItemAllowed (item) {\r\n    if (typeof item.getAllowedLocations !== 'function') {\r\n      return true\r\n    } else {\r\n      return item.getAllowedLocations().includes(this.getContainer().getLocation())\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getContainer","start_line":128,"end_line":128,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"getActivePackage","line":310,"func_location":"PackageManager.isPackageActive","func_start_line":309,"func_end_line":311,"args":["name"],"comment":[" Public: Is the {Package} with the given name active?",""," * `name` - The {String} package name.",""," Returns a {Boolean}."],"code":"  isPackageActive (name) {\r\n    return (this.getActivePackage(name) != null)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.getActivePackage","start_line":300,"end_line":302,"comment":[" Public: Get the active {Package} with the given name.",""," * `name` - The {String} package name.",""," Returns a {Package} or undefined."],"params":["name"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"getLoadedPackage","line":349,"func_location":"PackageManager.isPackageLoaded","func_start_line":348,"func_end_line":350,"args":["name"],"comment":[" Public: Is the package with the given name loaded?",""," * `name` - The {String} package name.",""," Returns a {Boolean}."],"code":"  isPackageLoaded (name) {\r\n    return this.getLoadedPackage(name) != null\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.getLoadedPackage","start_line":339,"end_line":341,"comment":[" Public: Get the loaded {Package} with the given name.",""," * `name` - The {String} package name.",""," Returns a {Package} or undefined."],"params":["name"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getRepo","line":349,"func_location":"GitRepository.isPathIgnored","func_start_line":348,"func_end_line":350,"args":[null],"comment":[" Public: Is the given path ignored?",""," * `path` The {String} path to check.",""," Returns a {Boolean} that's true if the `path` is ignored."],"code":"  isPathIgnored (path) {\r\n    return this.getRepo().isIgnored(this.relativize(path))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getRepo","start_line":524,"end_line":530,"comment":[" Returns the corresponding {Repository}"],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"relativize","line":349,"func_location":"GitRepository.isPathIgnored","func_start_line":348,"func_end_line":350,"args":[null],"comment":[" Public: Is the given path ignored?",""," * `path` The {String} path to check.",""," Returns a {Boolean} that's true if the `path` is ignored."],"code":"  isPathIgnored (path) {\r\n    return this.getRepo().isIgnored(this.relativize(path))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.relativize","start_line":208,"end_line":210,"comment":[" Public: Makes a path relative to the repository's working directory."],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"isStatusModified","line":331,"func_location":"GitRepository.isPathModified","func_start_line":330,"func_end_line":332,"args":[null],"comment":["\r\n  Section: Reading Status\r\n  "," Public: Returns true if the given path is modified.",""," * `path` The {String} path to check.",""," Returns a {Boolean} that's true if the `path` is modified."],"code":"  isPathModified (path) {\r\n    return this.isStatusModified(this.getPathStatus(path))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.isStatusModified","start_line":406,"end_line":406,"comment":[" Public: Returns true if the given status indicates modification.",""," * `status` A {Number} representing the status.",""," Returns a {Boolean} that's true if the `status` indicates modification."],"params":["status"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getPathStatus","line":331,"func_location":"GitRepository.isPathModified","func_start_line":330,"func_end_line":332,"args":[null],"comment":["\r\n  Section: Reading Status\r\n  "," Public: Returns true if the given path is modified.",""," * `path` The {String} path to check.",""," Returns a {Boolean} that's true if the `path` is modified."],"code":"  isPathModified (path) {\r\n    return this.isStatusModified(this.getPathStatus(path))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getPathStatus","start_line":374,"end_line":390,"comment":[" Public: Get the status of a single path in the repository.",""," * `path` A {String} repository-relative path.",""," Returns a {Number} representing the status. This value can be passed to"," {::isStatusModified} or {::isStatusNew} to get more information."],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"findBufferForPath","line":627,"func_location":"Project.isPathModified","func_start_line":626,"func_end_line":629,"args":[null],"comment":[" Is the buffer for the given path modified?"],"code":"  isPathModified (filePath) {\r\n    const bufferForPath = this.findBufferForPath(this.resolvePath(filePath))\r\n    return bufferForPath && bufferForPath.isModified()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.findBufferForPath","start_line":631,"end_line":633,"comment":[],"params":["filePath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"resolvePath","line":627,"func_location":"Project.isPathModified","func_start_line":626,"func_end_line":629,"args":[null],"comment":[" Is the buffer for the given path modified?"],"code":"  isPathModified (filePath) {\r\n    const bufferForPath = this.findBufferForPath(this.resolvePath(filePath))\r\n    return bufferForPath && bufferForPath.isModified()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.resolvePath","start_line":514,"end_line":530,"comment":[],"params":["uri"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"isStatusNew","line":340,"func_location":"GitRepository.isPathNew","func_start_line":339,"func_end_line":341,"args":[null],"comment":[" Public: Returns true if the given path is new.",""," * `path` The {String} path to check.",""," Returns a {Boolean} that's true if the `path` is new."],"code":"  isPathNew (path) {\r\n    return this.isStatusNew(this.getPathStatus(path))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.isStatusNew","start_line":413,"end_line":415,"comment":[" Public: Returns true if the given status indicates a new path.",""," * `status` A {Number} representing the status.",""," Returns a {Boolean} that's true if the `status` indicates a new path."],"params":["status"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getPathStatus","line":340,"func_location":"GitRepository.isPathNew","func_start_line":339,"func_end_line":341,"args":[null],"comment":[" Public: Returns true if the given path is new.",""," * `path` The {String} path to check.",""," Returns a {Boolean} that's true if the `path` is new."],"code":"  isPathNew (path) {\r\n    return this.isStatusNew(this.getPathStatus(path))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getPathStatus","start_line":374,"end_line":390,"comment":[" Public: Get the status of a single path in the repository.",""," * `path` A {String} repository-relative path.",""," Returns a {Number} representing the status. This value can be passed to"," {::isStatusModified} or {::isStatusNew} to get more information."],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getWorkingDirectory","line":202,"func_location":"GitRepository.isProjectAtRoot","func_start_line":200,"func_end_line":205,"args":[null],"comment":[" Public: Returns true if at the root, false if in a subfolder of the"," repository."],"code":"  isProjectAtRoot () {\r\n    if (this.projectAtRoot == null) {\r\n      this.projectAtRoot = this.project && this.project.relativize(this.getWorkingDirectory()) === ''\r\n    }\r\n    return this.projectAtRoot\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getWorkingDirectory","start_line":194,"end_line":196,"comment":[" Public: Returns the {String} working directory path of the repository."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"getReleaseChannel","line":508,"func_location":"AtomEnvironment.isReleasedVersion","func_start_line":507,"func_end_line":509,"args":[{"type":"object"}],"comment":[" Public: Returns a {Boolean} that is `true` if the current version is an official release."],"code":"  isReleasedVersion () {\r\n    return this.getReleaseChannel().match(/stable|beta|nightly/) != null\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.getReleaseChannel","start_line":493,"end_line":504,"comment":[" Public: Gets the release channel of the Atom application.",""," Returns the release channel as a {String}. Will return a specific release channel"," name like 'beta' or 'nightly' if one is found in the Atom version or 'stable'"," otherwise."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"firstNonWhitespaceRange","line":169,"func_location":"TreeSitterLanguageMode.isRowCommented","func_start_line":168,"func_end_line":175,"args":["row"],"code":"  isRowCommented (row) {\r\n    const range = this.firstNonWhitespaceRange(row)\r\n    if (range) {\r\n      const firstNode = this.getSyntaxNodeContainingRange(range)\r\n      if (firstNode) return firstNode.type.includes('comment')\r\n    }\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"TreeSitterLanguageMode.firstNonWhitespaceRange","start_line":526,"end_line":528,"comment":["\r\n  Section - Private\r\n  "],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"getSyntaxNodeContainingRange","line":171,"func_location":"TreeSitterLanguageMode.isRowCommented","func_start_line":168,"func_end_line":175,"args":["range"],"code":"  isRowCommented (row) {\r\n    const range = this.firstNonWhitespaceRange(row)\r\n    if (range) {\r\n      const firstNode = this.getSyntaxNodeContainingRange(range)\r\n      if (firstNode) return firstNode.type.includes('comment')\r\n    }\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"TreeSitterLanguageMode.getSyntaxNodeContainingRange","start_line":383,"end_line":385,"comment":["\r\n  Section - Syntax Tree APIs\r\n  "],"params":["range","where"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"getScreenRange","line":153,"func_location":"Selection.isSingleScreenLine","func_start_line":152,"func_end_line":154,"args":[],"comment":[" Public: Returns whether the selection is a single line or not."],"code":"  isSingleScreenLine () {\r\n    return this.getScreenRange().isSingleLine()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.getScreenRange","start_line":66,"end_line":68,"comment":["\r\n  Section: Managing the selection range\r\n  "," Public: Returns the screen {Range} for the selection."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getRepo","line":406,"func_location":"GitRepository.isStatusModified","func_start_line":406,"func_end_line":406,"args":["status"],"comment":[" Public: Returns true if the given status indicates modification.",""," * `status` A {Number} representing the status.",""," Returns a {Boolean} that's true if the `status` indicates modification."],"code":"  isStatusModified (status) { return this.getRepo().isStatusModified(status) }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getRepo","start_line":524,"end_line":530,"comment":[" Returns the corresponding {Repository}"],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getRepo","line":414,"func_location":"GitRepository.isStatusNew","func_start_line":413,"func_end_line":415,"args":["status"],"comment":[" Public: Returns true if the given status indicates a new path.",""," * `status` A {Number} representing the status.",""," Returns a {Boolean} that's true if the `status` indicates a new path."],"code":"  isStatusNew (status) {\r\n    return this.getRepo().isStatusNew(status)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getRepo","start_line":524,"end_line":530,"comment":[" Returns the corresponding {Repository}"],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getRepo","line":239,"func_location":"GitRepository.isSubmodule","func_start_line":236,"func_end_line":246,"args":["filePath"],"comment":[" Public: Is the given path a submodule in the repository?",""," * `path` The {String} path to check.",""," Returns a {Boolean}."],"code":"  isSubmodule (filePath) {\r\n    if (!filePath) return false\r\n\r\n    const repo = this.getRepo(filePath)\r\n    if (repo.isSubmodule(repo.relativize(filePath))) {\r\n      return true\r\n    } else {\r\n      // Check if the filePath is a working directory in a repo that isn't the root.\r\n      return repo !== this.getRepo() && repo.relativize(path.join(filePath, 'dir')) === 'dir'\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getRepo","start_line":524,"end_line":530,"comment":[" Returns the corresponding {Repository}"],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getRepo","line":244,"func_location":"GitRepository.isSubmodule","func_start_line":236,"func_end_line":246,"args":[],"comment":[" Public: Is the given path a submodule in the repository?",""," * `path` The {String} path to check.",""," Returns a {Boolean}."],"code":"  isSubmodule (filePath) {\r\n    if (!filePath) return false\r\n\r\n    const repo = this.getRepo(filePath)\r\n    if (repo.isSubmodule(repo.relativize(filePath))) {\r\n      return true\r\n    } else {\r\n      // Check if the filePath is a working directory in a repo that isn't the root.\r\n      return repo !== this.getRepo() && repo.relativize(path.join(filePath, 'dir')) === 'dir'\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getRepo","start_line":524,"end_line":530,"comment":[" Returns the corresponding {Repository}"],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferPosition","line":146,"func_location":"Cursor.isSurroundedByWhitespace","func_start_line":145,"func_end_line":149,"args":[],"comment":[" Public: Identifies if the cursor is surrounded by whitespace.",""," \"Surrounded\" here means that the character directly before and after the"," cursor are both whitespace.",""," Returns a {Boolean}."],"code":"  isSurroundedByWhitespace () {\r\n    const {row, column} = this.getBufferPosition()\r\n    const range = [[row, column - 1], [row, column + 1]]\r\n    return /^\\s+$/.test(this.editor.getTextInBufferRange(range))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferPosition","start_line":91,"end_line":93,"comment":[" Public: Returns the current buffer position as an Array."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration.js","name":"isType","line":143,"func_location":"Decoration.isType","func_start_line":142,"func_end_line":144,"args":[".properties","type"],"comment":[" Public: Check if this decoration is of type `type`",""," * `type` {String} type like `'line-number'`, `'line'`, etc. `type` can also","   be an {Array} of {String}s, where it will return true if the decoration's","   type matches any in the array.",""," Returns {Boolean}"],"code":"  isType (type) {\r\n    return Decoration.isType(this.properties, type)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration.js","name":"Decoration.isType","start_line":49,"end_line":68,"comment":[" Private: Check if the `decorationProperties.type` matches `type`",""," * `decorationProperties` {Object} eg. `{type: 'line-number', class: 'my-new-class'}`"," * `type` {String} type like `'line-number'`, `'line'`, etc. `type` can also","   be an {Array} of {String}s, where it will return true if the decoration's","   type matches any in the array.",""," Returns {Boolean}"," Note: 'line-number' is a special subtype of the 'gutter' type. I.e., a"," 'line-number' is a 'gutter', but a 'gutter' is not a 'line-number'."],"params":["decorationProperties","type"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"killOnWindows","line":238,"func_location":"BufferedProcess.kill","func_start_line":233,"func_end_line":242,"args":[],"comment":[" Public: Terminate the process."],"code":"  kill () {\r\n    if (this.killed) return\r\n\r\n    this.killed = true\r\n    if (process.platform === 'win32') {\r\n      this.killOnWindows()\r\n    } else {\r\n      this.killProcess()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"BufferedProcess.killOnWindows","start_line":163,"end_line":205,"comment":[" Kill all child processes of the spawned cmd.exe process on Windows.",""," This is required since killing the cmd.exe does not terminate child"," processes."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"killProcess","line":240,"func_location":"BufferedProcess.kill","func_start_line":233,"func_end_line":242,"args":[],"comment":[" Public: Terminate the process."],"code":"  kill () {\r\n    if (this.killed) return\r\n\r\n    this.killed = true\r\n    if (process.platform === 'win32') {\r\n      this.killOnWindows()\r\n    } else {\r\n      this.killProcess()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"BufferedProcess.killProcess","start_line":207,"end_line":210,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"killProcessesForWindow","line":930,"func_location":"AtomApplication.killAllProcesses","func_start_line":928,"func_end_line":932,"args":["window"],"comment":[" Kill all processes associated with opened windows."],"code":"  killAllProcesses () {\r\n    for (let window of this.waitSessionsByWindow.keys()) {\r\n      this.killProcessesForWindow(window)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.killProcessesForWindow","start_line":934,"end_line":941,"comment":[],"params":["window"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"killProcess","line":181,"func_location":"BufferedProcess.killOnWindows","func_start_line":163,"func_end_line":205,"args":[],"comment":[" Kill all child processes of the spawned cmd.exe process on Windows.",""," This is required since killing the cmd.exe does not terminate child"," processes."],"code":"  killOnWindows () {\r\n    if (!this.process) return\r\n\r\n    const parentPid = this.process.pid\r\n    const cmd = 'wmic'\r\n    const args = [\r\n      'process',\r\n      'where',\r\n      `(ParentProcessId=${parentPid})`,\r\n      'get',\r\n      'processid'\r\n    ]\r\n\r\n    let wmicProcess\r\n\r\n    try {\r\n      wmicProcess = ChildProcess.spawn(cmd, args)\r\n    } catch (spawnError) {\r\n      this.killProcess()\r\n      return\r\n    }\r\n\r\n    wmicProcess.on('error', () => {}) // ignore errors\r\n\r\n    let output = ''\r\n    wmicProcess.stdout.on('data', (data) => {\r\n      output += data\r\n    })\r\n    wmicProcess.stdout.on('close', () => {\r\n      for (let pid of output.split(/\\s+/)) {\r\n        if (!/^\\d{1,10}$/.test(pid)) continue\r\n        pid = parseInt(pid, 10)\r\n\r\n        if (!pid || pid === parentPid) continue\r\n\r\n        try {\r\n          process.kill(pid)\r\n        } catch (error) {}\r\n      }\r\n\r\n      this.killProcess()\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"BufferedProcess.killProcess","start_line":207,"end_line":210,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"killProcess","line":938,"func_location":"AtomApplication.killProcessesForWindow","func_start_line":934,"func_end_line":941,"args":["session.pid"],"code":"  killProcessesForWindow (window) {\r\n    const sessions = this.waitSessionsByWindow.get(window)\r\n    if (!sessions) return\r\n    for (const session of sessions) {\r\n      this.killProcess(session.pid)\r\n    }\r\n    this.waitSessionsByWindow.delete(window)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.killProcess","start_line":957,"end_line":966,"comment":[" Kill the process with the given pid."],"params":["pid"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"loadPreviousWindowOptions","line":195,"func_location":"AtomApplication.launch","func_start_line":172,"func_end_line":205,"args":[],"code":"  async launch (options) {\r\n    if (!this.configFilePromise) {\r\n      this.configFilePromise = this.configFile.watch()\r\n      this.disposable.add(await this.configFilePromise)\r\n      this.config.onDidChange('core.titleBar', () => this.promptForRestart())\r\n      this.config.onDidChange('core.colorProfile', () => this.promptForRestart())\r\n    }\r\n\r\n    const optionsForWindowsToOpen = []\r\n\r\n    let shouldReopenPreviousWindows = false\r\n\r\n    if (options.test || options.benchmark || options.benchmarkTest) {\r\n      optionsForWindowsToOpen.push(options)\r\n    } else if ((options.pathsToOpen && options.pathsToOpen.length > 0) ||\r\n               (options.urlsToOpen && options.urlsToOpen.length > 0)) {\r\n      optionsForWindowsToOpen.push(options)\r\n      shouldReopenPreviousWindows = this.config.get('core.restorePreviousWindowsOnStart') === 'always'\r\n    } else {\r\n      shouldReopenPreviousWindows = this.config.get('core.restorePreviousWindowsOnStart') !== 'no'\r\n    }\r\n\r\n    if (shouldReopenPreviousWindows) {\r\n      for (const previousOptions of await this.loadPreviousWindowOptions()) {\r\n        optionsForWindowsToOpen.push(Object.assign({}, options, previousOptions))\r\n      }\r\n    }\r\n\r\n    if (optionsForWindowsToOpen.length === 0) {\r\n      optionsForWindowsToOpen.push(options)\r\n    }\r\n\r\n    return optionsForWindowsToOpen.map(options => this.openWithOptions(options))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.loadPreviousWindowOptions","start_line":983,"end_line":996,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"screenLineForScreenRow","line":1240,"func_location":"TextEditor.lineTextForScreenRow","func_start_line":1239,"func_end_line":1242,"args":["screenRow"],"comment":[" Essential: Returns a {String} representing the contents of the line at the"," given screen row.",""," * `screenRow` A {Number} representing a zero-indexed screen row."],"code":"  lineTextForScreenRow (screenRow) {\r\n    const screenLine = this.screenLineForScreenRow(screenRow)\r\n    if (screenLine) return screenLine.lineText\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.screenLineForScreenRow","start_line":1272,"end_line":1274,"comment":[],"params":["screenRow"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"deleteSocketFile","line":337,"func_location":"AtomApplication.listenForArgumentsFromNewProcess","func_start_line":334,"func_end_line":346,"args":[],"comment":[" Creates server to listen for additional atom application launches.",""," You can run the atom command multiple times, but after the first launch"," the other launches will just pass their information to this server and then"," close immediately."],"code":"  listenForArgumentsFromNewProcess () {\r\n    if (!this.socketPath) return\r\n\r\n    this.deleteSocketFile()\r\n    const server = net.createServer(connection => {\r\n      let data = ''\r\n      connection.on('data', chunk => { data += chunk })\r\n      connection.on('end', () => this.openWithOptions(JSON.parse(data)))\r\n    })\r\n\r\n    server.listen(this.socketPath)\r\n    server.on('error', error => console.error('Application server failed', error))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.deleteSocketFile","start_line":348,"end_line":361,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"measure","line":123,"func_location":"Package.load","func_start_line":122,"func_end_line":144},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.measure","start_line":80,"end_line":85,"comment":[],"params":["key","fn"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/file-system-blob-store.js","name":"reset","line":40,"func_location":"FileSystemBlobStore.load","func_start_line":28,"func_end_line":42,"args":[],"code":"  load () {\r\n    if (!fs.existsSync(this.blobMapFilename)) {\r\n      return\r\n    }\r\n    if (!fs.existsSync(this.blobFilename)) {\r\n      return\r\n    }\r\n\r\n    try {\r\n      this.storedBlob = fs.readFileSync(this.blobFilename)\r\n      this.storedBlobMap = JSON.parse(fs.readFileSync(this.blobMapFilename))\r\n    } catch (e) {\r\n      this.reset()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/file-system-blob-store.js","name":"FileSystemBlobStore.reset","start_line":21,"end_line":26,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"getLoadedPackage","line":582,"func_location":"PackageManager.loadAvailablePackage","func_start_line":571,"func_end_line":635,"args":["availablePackage.name"],"code":"  loadAvailablePackage (availablePackage, disabledPackageNames) {\r\n    const preloadedPackage = this.preloadedPackages[availablePackage.name]\r\n\r\n    if (disabledPackageNames != null && disabledPackageNames.has(availablePackage.name)) {\r\n      if (preloadedPackage != null) {\r\n        preloadedPackage.deactivate()\r\n        delete preloadedPackage[availablePackage.name]\r\n      }\r\n      return null\r\n    }\r\n\r\n    const loadedPackage = this.getLoadedPackage(availablePackage.name)\r\n    if (loadedPackage != null) {\r\n      return loadedPackage\r\n    }\r\n\r\n    if (preloadedPackage != null) {\r\n      if (availablePackage.isBundled) {\r\n        preloadedPackage.finishLoading()\r\n        this.loadedPackages[availablePackage.name] = preloadedPackage\r\n        return preloadedPackage\r\n      } else {\r\n        preloadedPackage.deactivate()\r\n        delete preloadedPackage[availablePackage.name]\r\n      }\r\n    }\r\n\r\n    let metadata\r\n    try {\r\n      metadata = this.loadPackageMetadata(availablePackage) || {}\r\n    } catch (error) {\r\n      this.handleMetadataError(error, availablePackage.path)\r\n      return null\r\n    }\r\n\r\n    if (!availablePackage.isBundled && this.isDeprecatedPackage(metadata.name, metadata.version)) {\r\n      console.warn(`Could not load ${metadata.name}@${metadata.version} because it uses deprecated APIs that have been removed.`)\r\n      return null\r\n    }\r\n\r\n    const options = {\r\n      path: availablePackage.path,\r\n      name: availablePackage.name,\r\n      metadata,\r\n      bundledPackage: availablePackage.isBundled,\r\n      packageManager: this,\r\n      config: this.config,\r\n      styleManager: this.styleManager,\r\n      commandRegistry: this.commandRegistry,\r\n      keymapManager: this.keymapManager,\r\n      notificationManager: this.notificationManager,\r\n      grammarRegistry: this.grammarRegistry,\r\n      themeManager: this.themeManager,\r\n      menuManager: this.menuManager,\r\n      contextMenuManager: this.contextMenuManager,\r\n      deserializerManager: this.deserializerManager,\r\n      viewRegistry: this.viewRegistry\r\n    }\r\n\r\n    const pack = metadata.theme ? new ThemePackage(options) : new Package(options)\r\n    pack.load()\r\n    this.loadedPackages[pack.name] = pack\r\n    this.emitter.emit('did-load-package', pack)\r\n    return pack\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.getLoadedPackage","start_line":339,"end_line":341,"comment":[" Public: Get the loaded {Package} with the given name.",""," * `name` - The {String} package name.",""," Returns a {Package} or undefined."],"params":["name"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"loadPackageMetadata","line":600,"func_location":"PackageManager.loadAvailablePackage","func_start_line":571,"func_end_line":635,"args":["availablePackage"],"code":"  loadAvailablePackage (availablePackage, disabledPackageNames) {\r\n    const preloadedPackage = this.preloadedPackages[availablePackage.name]\r\n\r\n    if (disabledPackageNames != null && disabledPackageNames.has(availablePackage.name)) {\r\n      if (preloadedPackage != null) {\r\n        preloadedPackage.deactivate()\r\n        delete preloadedPackage[availablePackage.name]\r\n      }\r\n      return null\r\n    }\r\n\r\n    const loadedPackage = this.getLoadedPackage(availablePackage.name)\r\n    if (loadedPackage != null) {\r\n      return loadedPackage\r\n    }\r\n\r\n    if (preloadedPackage != null) {\r\n      if (availablePackage.isBundled) {\r\n        preloadedPackage.finishLoading()\r\n        this.loadedPackages[availablePackage.name] = preloadedPackage\r\n        return preloadedPackage\r\n      } else {\r\n        preloadedPackage.deactivate()\r\n        delete preloadedPackage[availablePackage.name]\r\n      }\r\n    }\r\n\r\n    let metadata\r\n    try {\r\n      metadata = this.loadPackageMetadata(availablePackage) || {}\r\n    } catch (error) {\r\n      this.handleMetadataError(error, availablePackage.path)\r\n      return null\r\n    }\r\n\r\n    if (!availablePackage.isBundled && this.isDeprecatedPackage(metadata.name, metadata.version)) {\r\n      console.warn(`Could not load ${metadata.name}@${metadata.version} because it uses deprecated APIs that have been removed.`)\r\n      return null\r\n    }\r\n\r\n    const options = {\r\n      path: availablePackage.path,\r\n      name: availablePackage.name,\r\n      metadata,\r\n      bundledPackage: availablePackage.isBundled,\r\n      packageManager: this,\r\n      config: this.config,\r\n      styleManager: this.styleManager,\r\n      commandRegistry: this.commandRegistry,\r\n      keymapManager: this.keymapManager,\r\n      notificationManager: this.notificationManager,\r\n      grammarRegistry: this.grammarRegistry,\r\n      themeManager: this.themeManager,\r\n      menuManager: this.menuManager,\r\n      contextMenuManager: this.contextMenuManager,\r\n      deserializerManager: this.deserializerManager,\r\n      viewRegistry: this.viewRegistry\r\n    }\r\n\r\n    const pack = metadata.theme ? new ThemePackage(options) : new Package(options)\r\n    pack.load()\r\n    this.loadedPackages[pack.name] = pack\r\n    this.emitter.emit('did-load-package', pack)\r\n    return pack\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.loadPackageMetadata","start_line":839,"end_line":882,"comment":[],"params":["packagePathOrAvailablePackage","ignoreErrors"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"handleMetadataError","line":602,"func_location":"PackageManager.loadAvailablePackage","func_start_line":571,"func_end_line":635,"args":["error","availablePackage.path"],"code":"  loadAvailablePackage (availablePackage, disabledPackageNames) {\r\n    const preloadedPackage = this.preloadedPackages[availablePackage.name]\r\n\r\n    if (disabledPackageNames != null && disabledPackageNames.has(availablePackage.name)) {\r\n      if (preloadedPackage != null) {\r\n        preloadedPackage.deactivate()\r\n        delete preloadedPackage[availablePackage.name]\r\n      }\r\n      return null\r\n    }\r\n\r\n    const loadedPackage = this.getLoadedPackage(availablePackage.name)\r\n    if (loadedPackage != null) {\r\n      return loadedPackage\r\n    }\r\n\r\n    if (preloadedPackage != null) {\r\n      if (availablePackage.isBundled) {\r\n        preloadedPackage.finishLoading()\r\n        this.loadedPackages[availablePackage.name] = preloadedPackage\r\n        return preloadedPackage\r\n      } else {\r\n        preloadedPackage.deactivate()\r\n        delete preloadedPackage[availablePackage.name]\r\n      }\r\n    }\r\n\r\n    let metadata\r\n    try {\r\n      metadata = this.loadPackageMetadata(availablePackage) || {}\r\n    } catch (error) {\r\n      this.handleMetadataError(error, availablePackage.path)\r\n      return null\r\n    }\r\n\r\n    if (!availablePackage.isBundled && this.isDeprecatedPackage(metadata.name, metadata.version)) {\r\n      console.warn(`Could not load ${metadata.name}@${metadata.version} because it uses deprecated APIs that have been removed.`)\r\n      return null\r\n    }\r\n\r\n    const options = {\r\n      path: availablePackage.path,\r\n      name: availablePackage.name,\r\n      metadata,\r\n      bundledPackage: availablePackage.isBundled,\r\n      packageManager: this,\r\n      config: this.config,\r\n      styleManager: this.styleManager,\r\n      commandRegistry: this.commandRegistry,\r\n      keymapManager: this.keymapManager,\r\n      notificationManager: this.notificationManager,\r\n      grammarRegistry: this.grammarRegistry,\r\n      themeManager: this.themeManager,\r\n      menuManager: this.menuManager,\r\n      contextMenuManager: this.contextMenuManager,\r\n      deserializerManager: this.deserializerManager,\r\n      viewRegistry: this.viewRegistry\r\n    }\r\n\r\n    const pack = metadata.theme ? new ThemePackage(options) : new Package(options)\r\n    pack.load()\r\n    this.loadedPackages[pack.name] = pack\r\n    this.emitter.emit('did-load-package', pack)\r\n    return pack\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.handleMetadataError","start_line":799,"end_line":805,"comment":[],"params":["error","packagePath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"isDeprecatedPackage","line":606,"func_location":"PackageManager.loadAvailablePackage","func_start_line":571,"func_end_line":635,"args":["metadata.name","metadata.version"],"code":"  loadAvailablePackage (availablePackage, disabledPackageNames) {\r\n    const preloadedPackage = this.preloadedPackages[availablePackage.name]\r\n\r\n    if (disabledPackageNames != null && disabledPackageNames.has(availablePackage.name)) {\r\n      if (preloadedPackage != null) {\r\n        preloadedPackage.deactivate()\r\n        delete preloadedPackage[availablePackage.name]\r\n      }\r\n      return null\r\n    }\r\n\r\n    const loadedPackage = this.getLoadedPackage(availablePackage.name)\r\n    if (loadedPackage != null) {\r\n      return loadedPackage\r\n    }\r\n\r\n    if (preloadedPackage != null) {\r\n      if (availablePackage.isBundled) {\r\n        preloadedPackage.finishLoading()\r\n        this.loadedPackages[availablePackage.name] = preloadedPackage\r\n        return preloadedPackage\r\n      } else {\r\n        preloadedPackage.deactivate()\r\n        delete preloadedPackage[availablePackage.name]\r\n      }\r\n    }\r\n\r\n    let metadata\r\n    try {\r\n      metadata = this.loadPackageMetadata(availablePackage) || {}\r\n    } catch (error) {\r\n      this.handleMetadataError(error, availablePackage.path)\r\n      return null\r\n    }\r\n\r\n    if (!availablePackage.isBundled && this.isDeprecatedPackage(metadata.name, metadata.version)) {\r\n      console.warn(`Could not load ${metadata.name}@${metadata.version} because it uses deprecated APIs that have been removed.`)\r\n      return null\r\n    }\r\n\r\n    const options = {\r\n      path: availablePackage.path,\r\n      name: availablePackage.name,\r\n      metadata,\r\n      bundledPackage: availablePackage.isBundled,\r\n      packageManager: this,\r\n      config: this.config,\r\n      styleManager: this.styleManager,\r\n      commandRegistry: this.commandRegistry,\r\n      keymapManager: this.keymapManager,\r\n      notificationManager: this.notificationManager,\r\n      grammarRegistry: this.grammarRegistry,\r\n      themeManager: this.themeManager,\r\n      menuManager: this.menuManager,\r\n      contextMenuManager: this.contextMenuManager,\r\n      deserializerManager: this.deserializerManager,\r\n      viewRegistry: this.viewRegistry\r\n    }\r\n\r\n    const pack = metadata.theme ? new ThemePackage(options) : new Package(options)\r\n    pack.load()\r\n    this.loadedPackages[pack.name] = pack\r\n    this.emitter.emit('did-load-package', pack)\r\n    return pack\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.isDeprecatedPackage","start_line":224,"end_line":239,"comment":[],"params":["name","version"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"reloadBaseStylesheets","line":221,"func_location":"ThemeManager.loadBaseStylesheets","func_start_line":220,"func_end_line":222,"args":[],"code":"  loadBaseStylesheets () {\r\n    this.reloadBaseStylesheets()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.reloadBaseStylesheets","start_line":224,"end_line":226,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js","name":"loadDependencies","line":81,"func_location":"loadDependencies","func_start_line":52,"func_end_line":84,"args":["childPath","rootPath","rootMetadata","moduleCache"],"code":"function loadDependencies (modulePath, rootPath, rootMetadata, moduleCache) {\r\n  const fs = require('fs-plus')\r\n\r\n  for (let childPath of fs.listSync(path.join(modulePath, 'node_modules'))) {\r\n    if (path.basename(childPath) === '.bin') continue\r\n    if (rootPath === modulePath && (rootMetadata.packageDependencies && rootMetadata.packageDependencies.hasOwnProperty(path.basename(childPath)))) {\r\n      continue\r\n    }\r\n\r\n    const childMetadataPath = path.join(childPath, 'package.json')\r\n    if (!fs.isFileSync(childMetadataPath)) continue\r\n\r\n    const childMetadata = JSON.parse(fs.readFileSync(childMetadataPath))\r\n    if (childMetadata && childMetadata.version) {\r\n      var mainPath\r\n      try {\r\n        mainPath = require.resolve(childPath)\r\n      } catch (error) {\r\n        mainPath = null\r\n      }\r\n\r\n      if (mainPath) {\r\n        moduleCache.dependencies.push({\r\n          name: childMetadata.name,\r\n          version: childMetadata.version,\r\n          path: path.relative(rootPath, mainPath)\r\n        })\r\n      }\r\n\r\n      loadDependencies(childPath, rootPath, rootMetadata, moduleCache)\r\n    }\r\n  }\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js","name":"loadDependencies","start_line":52,"end_line":84,"comment":[],"params":["modulePath","rootPath","rootMetadata","moduleCache"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js","name":"loadFolderCompatibility","line":124,"func_location":"loadFolderCompatibility","func_start_line":86,"func_end_line":126,"args":["childPath","rootPath","rootMetadata","moduleCache"],"code":"function loadFolderCompatibility (modulePath, rootPath, rootMetadata, moduleCache) {\r\n  const fs = require('fs-plus')\r\n\r\n  const metadataPath = path.join(modulePath, 'package.json')\r\n  if (!fs.isFileSync(metadataPath)) return\r\n\r\n  const metadata = JSON.parse(fs.readFileSync(metadataPath))\r\n  const dependencies = metadata.dependencies || {}\r\n\r\n  for (let name in dependencies) {\r\n    if (!semver.validRange(dependencies[name])) {\r\n      delete dependencies[name]\r\n    }\r\n  }\r\n\r\n  const onDirectory = childPath => path.basename(childPath) !== 'node_modules'\r\n\r\n  const extensions = ['.js', '.coffee', '.json', '.node']\r\n  let paths = {}\r\n  function onFile (childPath) {\r\n    const needle = path.extname(childPath)\r\n    if (extensions.includes(needle)) {\r\n      const relativePath = path.relative(rootPath, path.dirname(childPath))\r\n      paths[relativePath] = true\r\n    }\r\n  }\r\n  fs.traverseTreeSync(modulePath, onFile, onDirectory)\r\n\r\n  paths = Object.keys(paths)\r\n  if (paths.length > 0 && Object.keys(dependencies).length > 0) {\r\n    moduleCache.folders.push({paths, dependencies})\r\n  }\r\n\r\n  for (let childPath of fs.listSync(path.join(modulePath, 'node_modules'))) {\r\n    if (path.basename(childPath) === '.bin') continue\r\n    if (rootPath === modulePath && (rootMetadata.packageDependencies && rootMetadata.packageDependencies.hasOwnProperty(path.basename(childPath)))) {\r\n      continue\r\n    }\r\n    loadFolderCompatibility(childPath, rootPath, rootMetadata, moduleCache)\r\n  }\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js","name":"loadFolderCompatibility","start_line":86,"end_line":126,"comment":[],"params":["modulePath","rootPath","rootMetadata","moduleCache"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"readGrammar","line":491,"func_location":"GrammarRegistry.loadGrammar","func_start_line":490,"func_end_line":496},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.readGrammar","start_line":517,"end_line":527,"comment":[" Extended: Read a grammar asynchronously but don't add it to the registry.",""," * `grammarPath` A {String} absolute file path to a grammar file."," * `callback` A {Function} to call when read with the following arguments:","   * `error` An {Error}, may be null.","   * `grammar` A {Grammar} or null if an error occured.",""," Returns undefined."],"params":["grammarPath","callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"readGrammarSync","line":504,"func_location":"GrammarRegistry.loadGrammarSync","func_start_line":503,"func_end_line":507,"args":["grammarPath"],"comment":[" Extended: Read a grammar synchronously and add it to this registry.",""," * `grammarPath` A {String} absolute file path to a grammar file.",""," Returns a {Grammar}."],"code":"  loadGrammarSync (grammarPath) {\r\n    const grammar = this.readGrammarSync(grammarPath)\r\n    this.addGrammar(grammar)\r\n    return grammar\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.readGrammarSync","start_line":534,"end_line":536,"comment":[" Extended: Read a grammar synchronously but don't add it to the registry.",""," * `grammarPath` A {String} absolute file path to a grammar file.",""," Returns a {Grammar}."],"params":["grammarPath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"addGrammar","line":505,"func_location":"GrammarRegistry.loadGrammarSync","func_start_line":503,"func_end_line":507,"args":["grammar"],"comment":[" Extended: Read a grammar synchronously and add it to this registry.",""," * `grammarPath` A {String} absolute file path to a grammar file.",""," Returns a {Grammar}."],"code":"  loadGrammarSync (grammarPath) {\r\n    const grammar = this.readGrammarSync(grammarPath)\r\n    this.addGrammar(grammar)\r\n    return grammar\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.addGrammar","start_line":456,"end_line":470,"comment":[],"params":["grammar"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"getKeymapPaths","line":446,"func_location":"Package.loadKeymaps","func_start_line":438,"func_end_line":451,"args":[],"code":"  loadKeymaps () {\r\n    if (this.bundledPackage && this.packageManager.packagesCache[this.name]) {\r\n      this.keymaps = []\r\n      for (const keymapPath in this.packageManager.packagesCache[this.name].keymaps) {\r\n        const keymapObject = this.packageManager.packagesCache[this.name].keymaps[keymapPath]\r\n        this.keymaps.push([`core:${keymapPath}`, keymapObject])\r\n      }\r\n    } else {\r\n      this.keymaps = this.getKeymapPaths().map((keymapPath) => [\r\n        keymapPath,\r\n        CSON.readFileSync(keymapPath, {allowDuplicateKeys: false}) || {}\r\n      ])\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.getKeymapPaths","start_line":468,"end_line":475,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"getImportPaths","line":255,"func_location":"ThemeManager.loadLessStylesheet","func_start_line":249,"func_end_line":298,"args":[],"code":"  loadLessStylesheet (lessStylesheetPath, importFallbackVariables = false) {\r\n    if (this.lessCache == null) {\r\n      this.lessCache = new LessCompileCache({\r\n        resourcePath: this.resourcePath,\r\n        lessSourcesByRelativeFilePath: this.lessSourcesByRelativeFilePath,\r\n        importedFilePathsByRelativeImportPath: this.importedFilePathsByRelativeImportPath,\r\n        importPaths: this.getImportPaths()\r\n      })\r\n    }\r\n\r\n    try {\r\n      if (importFallbackVariables) {\r\n        const baseVarImports = `\\\r\n@import \"variables/ui-variables\";\r\n@import \"variables/syntax-variables\";\\\r\n`\r\n        const relativeFilePath = path.relative(this.resourcePath, lessStylesheetPath)\r\n        const lessSource = this.lessSourcesByRelativeFilePath[relativeFilePath]\r\n\r\n        let content, digest\r\n        if (lessSource != null) {\r\n          ({ content } = lessSource);\r\n          ({ digest } = lessSource)\r\n        } else {\r\n          content = baseVarImports + '\\n' + fs.readFileSync(lessStylesheetPath, 'utf8')\r\n          digest = null\r\n        }\r\n\r\n        return this.lessCache.cssForFile(lessStylesheetPath, content, digest)\r\n      } else {\r\n        return this.lessCache.read(lessStylesheetPath)\r\n      }\r\n    } catch (error) {\r\n      let detail, message\r\n      error.less = true\r\n      if (error.line != null) {\r\n        // Adjust line numbers for import fallbacks\r\n        if (importFallbackVariables) { error.line -= 2 }\r\n\r\n        message = `Error compiling Less stylesheet: \\`${lessStylesheetPath}\\``\r\n        detail = `Line number: ${error.line}\\n${error.message}`\r\n      } else {\r\n        message = `Error loading Less stylesheet: \\`${lessStylesheetPath}\\``\r\n        detail = error.message\r\n      }\r\n\r\n      this.notificationManager.addError(message, {detail, dismissable: true})\r\n      throw error\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.getImportPaths","start_line":381,"end_line":402,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"getMenuPaths","line":461,"func_location":"Package.loadMenus","func_start_line":453,"func_end_line":466,"args":[],"code":"  loadMenus () {\r\n    if (this.bundledPackage && this.packageManager.packagesCache[this.name]) {\r\n      this.menus = []\r\n      for (const menuPath in this.packageManager.packagesCache[this.name].menus) {\r\n        const menuObject = this.packageManager.packagesCache[this.name].menus[menuPath]\r\n        this.menus.push([`core:${menuPath}`, menuObject])\r\n      }\r\n    } else {\r\n      this.menus = this.getMenuPaths().map((menuPath) => [\r\n        menuPath,\r\n        CSON.readFileSync(menuPath) || {}\r\n      ])\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.getMenuPaths","start_line":477,"end_line":484,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"getLoadedPackage","line":556,"func_location":"PackageManager.loadPackage","func_start_line":551,"func_end_line":569,"args":["nameOrPath"],"code":"  loadPackage (nameOrPath) {\r\n    if (path.basename(nameOrPath)[0].match(/^\\./)) { // primarily to skip .git folder\r\n      return null\r\n    }\r\n\r\n    const pack = this.getLoadedPackage(nameOrPath)\r\n    if (pack) {\r\n      return pack\r\n    }\r\n\r\n    const packagePath = this.resolvePackagePath(nameOrPath)\r\n    if (packagePath) {\r\n      const name = path.basename(nameOrPath)\r\n      return this.loadAvailablePackage({name, path: packagePath, isBundled: this.isBundledPackagePath(packagePath)})\r\n    }\r\n\r\n    console.warn(`Could not resolve '${nameOrPath}' to a package path`)\r\n    return null\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.getLoadedPackage","start_line":339,"end_line":341,"comment":[" Public: Get the loaded {Package} with the given name.",""," * `name` - The {String} package name.",""," Returns a {Package} or undefined."],"params":["name"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"resolvePackagePath","line":561,"func_location":"PackageManager.loadPackage","func_start_line":551,"func_end_line":569,"args":["nameOrPath"],"code":"  loadPackage (nameOrPath) {\r\n    if (path.basename(nameOrPath)[0].match(/^\\./)) { // primarily to skip .git folder\r\n      return null\r\n    }\r\n\r\n    const pack = this.getLoadedPackage(nameOrPath)\r\n    if (pack) {\r\n      return pack\r\n    }\r\n\r\n    const packagePath = this.resolvePackagePath(nameOrPath)\r\n    if (packagePath) {\r\n      const name = path.basename(nameOrPath)\r\n      return this.loadAvailablePackage({name, path: packagePath, isBundled: this.isBundledPackagePath(packagePath)})\r\n    }\r\n\r\n    console.warn(`Could not resolve '${nameOrPath}' to a package path`)\r\n    return null\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.resolvePackagePath","start_line":197,"end_line":213,"comment":["\r\n  Section: General package data\r\n  "," Public: Resolve the given package name to a path on disk.",""," * `name` - The {String} package name.",""," Return a {String} folder path or undefined if it could not be resolved."],"params":["name"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"loadAvailablePackage","line":564,"func_location":"PackageManager.loadPackage","func_start_line":551,"func_end_line":569,"args":[null],"code":"  loadPackage (nameOrPath) {\r\n    if (path.basename(nameOrPath)[0].match(/^\\./)) { // primarily to skip .git folder\r\n      return null\r\n    }\r\n\r\n    const pack = this.getLoadedPackage(nameOrPath)\r\n    if (pack) {\r\n      return pack\r\n    }\r\n\r\n    const packagePath = this.resolvePackagePath(nameOrPath)\r\n    if (packagePath) {\r\n      const name = path.basename(nameOrPath)\r\n      return this.loadAvailablePackage({name, path: packagePath, isBundled: this.isBundledPackagePath(packagePath)})\r\n    }\r\n\r\n    console.warn(`Could not resolve '${nameOrPath}' to a package path`)\r\n    return null\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.loadAvailablePackage","start_line":571,"end_line":635,"comment":[],"params":["availablePackage","disabledPackageNames"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"isBundledPackagePath","line":564,"func_location":"PackageManager.loadPackage","func_start_line":551,"func_end_line":569,"args":[null],"code":"  loadPackage (nameOrPath) {\r\n    if (path.basename(nameOrPath)[0].match(/^\\./)) { // primarily to skip .git folder\r\n      return null\r\n    }\r\n\r\n    const pack = this.getLoadedPackage(nameOrPath)\r\n    if (pack) {\r\n      return pack\r\n    }\r\n\r\n    const packagePath = this.resolvePackagePath(nameOrPath)\r\n    if (packagePath) {\r\n      const name = path.basename(nameOrPath)\r\n      return this.loadAvailablePackage({name, path: packagePath, isBundled: this.isBundledPackagePath(packagePath)})\r\n    }\r\n\r\n    console.warn(`Could not resolve '${nameOrPath}' to a package path`)\r\n    return null\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.isBundledPackagePath","start_line":827,"end_line":837,"comment":[],"params":["packagePath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"isBundledPackagePath","line":849,"func_location":"PackageManager.loadPackageMetadata","func_start_line":839,"func_end_line":882,"args":["packagePath"],"code":"  loadPackageMetadata (packagePathOrAvailablePackage, ignoreErrors = false) {\r\n    let isBundled, packageName, packagePath\r\n    if (typeof packagePathOrAvailablePackage === 'object') {\r\n      const availablePackage = packagePathOrAvailablePackage\r\n      packageName = availablePackage.name\r\n      packagePath = availablePackage.path\r\n      isBundled = availablePackage.isBundled\r\n    } else {\r\n      packagePath = packagePathOrAvailablePackage\r\n      packageName = path.basename(packagePath)\r\n      isBundled = this.isBundledPackagePath(packagePath)\r\n    }\r\n\r\n    let metadata\r\n    if (isBundled && this.packagesCache[packageName] != null) {\r\n      metadata = this.packagesCache[packageName].metadata\r\n    }\r\n\r\n    if (metadata == null) {\r\n      const metadataPath = CSON.resolve(path.join(packagePath, 'package'))\r\n      if (metadataPath) {\r\n        try {\r\n          metadata = CSON.readFileSync(metadataPath)\r\n          this.normalizePackageMetadata(metadata)\r\n        } catch (error) {\r\n          if (!ignoreErrors) { throw error }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (metadata == null) {\r\n      metadata = {}\r\n    }\r\n\r\n    if (typeof metadata.name !== 'string' || metadata.name.length <= 0) {\r\n      metadata.name = packageName\r\n    }\r\n\r\n    if (metadata.repository && metadata.repository.type === 'git' && typeof metadata.repository.url === 'string') {\r\n      metadata.repository.url = metadata.repository.url.replace(/(^git\\+)|(\\.git$)/g, '')\r\n    }\r\n\r\n    return metadata\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.isBundledPackagePath","start_line":827,"end_line":837,"comment":[],"params":["packagePath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"normalizePackageMetadata","line":862,"func_location":"PackageManager.loadPackageMetadata","func_start_line":839,"func_end_line":882,"args":["metadata"],"code":"  loadPackageMetadata (packagePathOrAvailablePackage, ignoreErrors = false) {\r\n    let isBundled, packageName, packagePath\r\n    if (typeof packagePathOrAvailablePackage === 'object') {\r\n      const availablePackage = packagePathOrAvailablePackage\r\n      packageName = availablePackage.name\r\n      packagePath = availablePackage.path\r\n      isBundled = availablePackage.isBundled\r\n    } else {\r\n      packagePath = packagePathOrAvailablePackage\r\n      packageName = path.basename(packagePath)\r\n      isBundled = this.isBundledPackagePath(packagePath)\r\n    }\r\n\r\n    let metadata\r\n    if (isBundled && this.packagesCache[packageName] != null) {\r\n      metadata = this.packagesCache[packageName].metadata\r\n    }\r\n\r\n    if (metadata == null) {\r\n      const metadataPath = CSON.resolve(path.join(packagePath, 'package'))\r\n      if (metadataPath) {\r\n        try {\r\n          metadata = CSON.readFileSync(metadataPath)\r\n          this.normalizePackageMetadata(metadata)\r\n        } catch (error) {\r\n          if (!ignoreErrors) { throw error }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (metadata == null) {\r\n      metadata = {}\r\n    }\r\n\r\n    if (typeof metadata.name !== 'string' || metadata.name.length <= 0) {\r\n      metadata.name = packageName\r\n    }\r\n\r\n    if (metadata.repository && metadata.repository.type === 'git' && typeof metadata.repository.url === 'string') {\r\n      metadata.repository.url = metadata.repository.url.replace(/(^git\\+)|(\\.git$)/g, '')\r\n    }\r\n\r\n    return metadata\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.normalizePackageMetadata","start_line":884,"end_line":889,"comment":[],"params":["metadata"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"didChangeProjects","line":97,"func_location":"HistoryManager.loadState","func_start_line":93,"func_end_line":101,"args":[null],"code":"  async loadState () {\r\n    const history = await this.stateStore.load('history-manager')\r\n    if (history && history.projects) {\r\n      this.projects = history.projects.filter(p => Array.isArray(p.paths) && p.paths.length > 0).map(p => new HistoryProject(p.paths, new Date(p.lastOpened)))\r\n      this.didChangeProjects({reloaded: true})\r\n    } else {\r\n      this.projects = []\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"HistoryManager.didChangeProjects","start_line":51,"end_line":53,"comment":[],"params":["args"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"getStateKey","line":1212,"func_location":"AtomEnvironment.loadState","func_start_line":1210,"func_end_line":1221,"args":[".initialPaths"],"code":"  loadState (stateKey) {\r\n    if (this.enablePersistence) {\r\n      if (!stateKey) stateKey = this.getStateKey(this.getLoadSettings().initialPaths)\r\n      if (stateKey) {\r\n        return this.stateStore.load(stateKey)\r\n      } else {\r\n        return this.applicationDelegate.getTemporaryWindowState()\r\n      }\r\n    } else {\r\n      return Promise.resolve(null)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.getStateKey","start_line":1279,"end_line":1286,"comment":[],"params":["paths"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"getLoadSettings","line":1212,"func_location":"AtomEnvironment.loadState","func_start_line":1210,"func_end_line":1221,"args":[".initialPaths"],"code":"  loadState (stateKey) {\r\n    if (this.enablePersistence) {\r\n      if (!stateKey) stateKey = this.getStateKey(this.getLoadSettings().initialPaths)\r\n      if (stateKey) {\r\n        return this.stateStore.load(stateKey)\r\n      } else {\r\n        return this.applicationDelegate.getTemporaryWindowState()\r\n      }\r\n    } else {\r\n      return Promise.resolve(null)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.getLoadSettings","start_line":525,"end_line":527,"comment":[" Public: Get the load settings for the current window.",""," Returns an {Object} containing all the load setting key/value pairs."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"loadLessStylesheet","line":243,"func_location":"ThemeManager.loadStylesheet","func_start_line":241,"func_end_line":247,"args":["stylesheetPath","importFallbackVariables"],"code":"  loadStylesheet (stylesheetPath, importFallbackVariables) {\r\n    if (path.extname(stylesheetPath) === '.less') {\r\n      return this.loadLessStylesheet(stylesheetPath, importFallbackVariables)\r\n    } else {\r\n      return fs.readFileSync(stylesheetPath, 'utf8')\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.loadLessStylesheet","start_line":249,"end_line":298,"comment":[],"params":["lessStylesheetPath","importFallbackVariables"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"getStylesheetPaths","line":487,"func_location":"Package.loadStylesheets","func_start_line":486,"func_end_line":490,"args":[],"code":"  loadStylesheets () {\r\n    this.stylesheets = this.getStylesheetPaths().map(stylesheetPath =>\r\n      [stylesheetPath, this.themeManager.loadStylesheet(stylesheetPath, true)]\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.getStylesheetPaths","start_line":543,"end_line":562,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"unwatchUserStylesheet","line":186,"func_location":"ThemeManager.loadUserStylesheet","func_start_line":185,"func_end_line":218,"args":[],"code":"  loadUserStylesheet () {\r\n    this.unwatchUserStylesheet()\r\n\r\n    const userStylesheetPath = this.styleManager.getUserStyleSheetPath()\r\n    if (!fs.isFileSync(userStylesheetPath)) { return }\r\n\r\n    try {\r\n      this.userStylesheetFile = new File(userStylesheetPath)\r\n      this.userStylesheetSubscriptions = new CompositeDisposable()\r\n      const reloadStylesheet = () => this.loadUserStylesheet()\r\n      this.userStylesheetSubscriptions.add(this.userStylesheetFile.onDidChange(reloadStylesheet))\r\n      this.userStylesheetSubscriptions.add(this.userStylesheetFile.onDidRename(reloadStylesheet))\r\n      this.userStylesheetSubscriptions.add(this.userStylesheetFile.onDidDelete(reloadStylesheet))\r\n    } catch (error) {\r\n      const message = `\\\r\nUnable to watch path: \\`${path.basename(userStylesheetPath)}\\`. Make sure\r\nyou have permissions to \\`${userStylesheetPath}\\`.\r\n\r\nOn linux there are currently problems with watch sizes. See\r\n[this document][watches] for more info.\r\n[watches]:https://github.com/atom/atom/blob/master/docs/build-instructions/linux.md#typeerror-unable-to-watch-path\\\r\n`\r\n      this.notificationManager.addError(message, {dismissable: true})\r\n    }\r\n\r\n    let userStylesheetContents\r\n    try {\r\n      userStylesheetContents = this.loadStylesheet(userStylesheetPath, true)\r\n    } catch (error) {\r\n      return\r\n    }\r\n\r\n    this.userStyleSheetDisposable = this.styleManager.addStyleSheet(userStylesheetContents, {sourcePath: userStylesheetPath, priority: 2})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.unwatchUserStylesheet","start_line":177,"end_line":183,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"loadStylesheet","line":212,"func_location":"ThemeManager.loadUserStylesheet","func_start_line":185,"func_end_line":218,"args":["userStylesheetPath",{"type":"boolean"}],"code":"  loadUserStylesheet () {\r\n    this.unwatchUserStylesheet()\r\n\r\n    const userStylesheetPath = this.styleManager.getUserStyleSheetPath()\r\n    if (!fs.isFileSync(userStylesheetPath)) { return }\r\n\r\n    try {\r\n      this.userStylesheetFile = new File(userStylesheetPath)\r\n      this.userStylesheetSubscriptions = new CompositeDisposable()\r\n      const reloadStylesheet = () => this.loadUserStylesheet()\r\n      this.userStylesheetSubscriptions.add(this.userStylesheetFile.onDidChange(reloadStylesheet))\r\n      this.userStylesheetSubscriptions.add(this.userStylesheetFile.onDidRename(reloadStylesheet))\r\n      this.userStylesheetSubscriptions.add(this.userStylesheetFile.onDidDelete(reloadStylesheet))\r\n    } catch (error) {\r\n      const message = `\\\r\nUnable to watch path: \\`${path.basename(userStylesheetPath)}\\`. Make sure\r\nyou have permissions to \\`${userStylesheetPath}\\`.\r\n\r\nOn linux there are currently problems with watch sizes. See\r\n[this document][watches] for more info.\r\n[watches]:https://github.com/atom/atom/blob/master/docs/build-instructions/linux.md#typeerror-unable-to-watch-path\\\r\n`\r\n      this.notificationManager.addError(message, {dismissable: true})\r\n    }\r\n\r\n    let userStylesheetContents\r\n    try {\r\n      userStylesheetContents = this.loadStylesheet(userStylesheetPath, true)\r\n    } catch (error) {\r\n      return\r\n    }\r\n\r\n    this.userStyleSheetDisposable = this.styleManager.addStyleSheet(userStylesheetContents, {sourcePath: userStylesheetPath, priority: 2})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.loadStylesheet","start_line":241,"end_line":247,"comment":[],"params":["stylesheetPath","importFallbackVariables"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"lineTextForScreenRow","line":1246,"func_location":"TextEditor.logScreenLines","func_start_line":1244,"func_end_line":1249,"args":["row"],"code":"  logScreenLines (start = 0, end = this.getLastScreenRow()) {\r\n    for (let row = start; row <= end; row++) {\r\n      const line = this.lineTextForScreenRow(row)\r\n      console.log(row, this.bufferRowForScreenRow(row), line, line.length)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.lineTextForScreenRow","start_line":1239,"end_line":1242,"comment":[" Essential: Returns a {String} representing the contents of the line at the"," given screen row.",""," * `screenRow` A {Number} representing a zero-indexed screen row."],"params":["screenRow"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"bufferRowForScreenRow","line":1247,"func_location":"TextEditor.logScreenLines","func_start_line":1244,"func_end_line":1249,"args":["row",null,"line","line.length"],"code":"  logScreenLines (start = 0, end = this.getLastScreenRow()) {\r\n    for (let row = start; row <= end; row++) {\r\n      const line = this.lineTextForScreenRow(row)\r\n      console.log(row, this.bufferRowForScreenRow(row), line, line.length)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.bufferRowForScreenRow","start_line":1276,"end_line":1278,"comment":[],"params":["screenRow"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"last","line":846,"func_location":"HighlightIterator.logState","func_start_line":845,"func_end_line":859,"args":[".iterators"],"code":"  logState () {\r\n    const iterator = last(this.iterators)\r\n    if (iterator.treeCursor) {\r\n      console.log(\r\n        iterator.getPosition(),\r\n        iterator.treeCursor.nodeType,\r\n        new Range(\r\n          iterator.languageLayer.tree.rootNode.startPosition,\r\n          iterator.languageLayer.tree.rootNode.endPosition\r\n        ).toString()\r\n      )\r\n      console.log('close', iterator.closeTags.map(id => this.languageMode.grammar.scopeNameForScopeId(id)))\r\n      console.log('open', iterator.openTags.map(id => this.languageMode.grammar.scopeNameForScopeId(id)))\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"last","start_line":1206,"end_line":1208,"comment":[],"params":["array"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js","name":"updateAndMonitorEditorSettings","line":151,"func_location":"TextEditorRegistry.maintainConfig","func_start_line":145,"func_end_line":177,"args":["editor"],"comment":[" Keep a {TextEditor}'s configuration in sync with Atom's settings.",""," * `editor` The editor whose configuration will be maintained.",""," Returns a {Disposable} that can be used to stop updating the editor's"," configuration."],"code":"  maintainConfig (editor) {\r\n    if (this.editorsWithMaintainedConfig.has(editor)) {\r\n      return new Disposable(noop)\r\n    }\r\n    this.editorsWithMaintainedConfig.add(editor)\r\n\r\n    this.updateAndMonitorEditorSettings(editor)\r\n    const languageChangeSubscription = editor.buffer.onDidChangeLanguageMode((newLanguageMode, oldLanguageMode) => {\r\n      this.updateAndMonitorEditorSettings(editor, oldLanguageMode)\r\n    })\r\n    this.subscriptions.add(languageChangeSubscription)\r\n\r\n    const updateTabTypes = () => {\r\n      const configOptions = {scope: editor.getRootScopeDescriptor()}\r\n      editor.setSoftTabs(shouldEditorUseSoftTabs(\r\n        editor,\r\n        this.config.get('editor.tabType', configOptions),\r\n        this.config.get('editor.softTabs', configOptions)\r\n      ))\r\n    }\r\n\r\n    updateTabTypes()\r\n    const tokenizeSubscription = editor.onDidTokenize(updateTabTypes)\r\n    this.subscriptions.add(tokenizeSubscription)\r\n\r\n    return new Disposable(() => {\r\n      this.editorsWithMaintainedConfig.delete(editor)\r\n      tokenizeSubscription.dispose()\r\n      languageChangeSubscription.dispose()\r\n      this.subscriptions.remove(languageChangeSubscription)\r\n      this.subscriptions.remove(tokenizeSubscription)\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js","name":"TextEditorRegistry.updateAndMonitorEditorSettings","start_line":218,"end_line":222,"comment":[],"params":["editor","oldLanguageMode"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"assignLanguageMode","line":85,"func_location":"GrammarRegistry.maintainLanguageMode","func_start_line":80,"func_end_line":114,"args":["buffer","languageOverride"],"comment":[" Extended: set a {TextBuffer}'s language mode based on its path and content,"," and continue to update its language mode as grammars are added or updated, or"," the buffer's file path changes.",""," * `buffer` The {TextBuffer} whose language mode will be maintained.",""," Returns a {Disposable} that can be used to stop updating the buffer's"," language mode."],"code":"  maintainLanguageMode (buffer) {\r\n    this.grammarScoresByBuffer.set(buffer, null)\r\n\r\n    const languageOverride = this.languageOverridesByBufferId.get(buffer.id)\r\n    if (languageOverride) {\r\n      this.assignLanguageMode(buffer, languageOverride)\r\n    } else {\r\n      this.autoAssignLanguageMode(buffer)\r\n    }\r\n\r\n    const pathChangeSubscription = buffer.onDidChangePath(() => {\r\n      this.grammarScoresByBuffer.delete(buffer)\r\n      if (!this.languageOverridesByBufferId.has(buffer.id)) {\r\n        this.autoAssignLanguageMode(buffer)\r\n      }\r\n    })\r\n\r\n    const destroySubscription = buffer.onDidDestroy(() => {\r\n      this.grammarScoresByBuffer.delete(buffer)\r\n      this.languageOverridesByBufferId.delete(buffer.id)\r\n      this.subscriptions.remove(destroySubscription)\r\n      this.subscriptions.remove(pathChangeSubscription)\r\n    })\r\n\r\n    this.subscriptions.add(pathChangeSubscription, destroySubscription)\r\n\r\n    return new Disposable(() => {\r\n      destroySubscription.dispose()\r\n      pathChangeSubscription.dispose()\r\n      this.subscriptions.remove(pathChangeSubscription)\r\n      this.subscriptions.remove(destroySubscription)\r\n      this.grammarScoresByBuffer.delete(buffer)\r\n      this.languageOverridesByBufferId.delete(buffer.id)\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.assignLanguageMode","start_line":124,"end_line":143,"comment":[" Extended: Force a {TextBuffer} to use a different grammar than the"," one that would otherwise be selected for it.",""," * `buffer` The {TextBuffer} whose grammar will be set."," * `languageId` The {String} id of the desired language.",""," Returns a {Boolean} that indicates whether the language was successfully"," found."],"params":["buffer","languageId"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"autoAssignLanguageMode","line":87,"func_location":"GrammarRegistry.maintainLanguageMode","func_start_line":80,"func_end_line":114,"args":["buffer"],"comment":[" Extended: set a {TextBuffer}'s language mode based on its path and content,"," and continue to update its language mode as grammars are added or updated, or"," the buffer's file path changes.",""," * `buffer` The {TextBuffer} whose language mode will be maintained.",""," Returns a {Disposable} that can be used to stop updating the buffer's"," language mode."],"code":"  maintainLanguageMode (buffer) {\r\n    this.grammarScoresByBuffer.set(buffer, null)\r\n\r\n    const languageOverride = this.languageOverridesByBufferId.get(buffer.id)\r\n    if (languageOverride) {\r\n      this.assignLanguageMode(buffer, languageOverride)\r\n    } else {\r\n      this.autoAssignLanguageMode(buffer)\r\n    }\r\n\r\n    const pathChangeSubscription = buffer.onDidChangePath(() => {\r\n      this.grammarScoresByBuffer.delete(buffer)\r\n      if (!this.languageOverridesByBufferId.has(buffer.id)) {\r\n        this.autoAssignLanguageMode(buffer)\r\n      }\r\n    })\r\n\r\n    const destroySubscription = buffer.onDidDestroy(() => {\r\n      this.grammarScoresByBuffer.delete(buffer)\r\n      this.languageOverridesByBufferId.delete(buffer.id)\r\n      this.subscriptions.remove(destroySubscription)\r\n      this.subscriptions.remove(pathChangeSubscription)\r\n    })\r\n\r\n    this.subscriptions.add(pathChangeSubscription, destroySubscription)\r\n\r\n    return new Disposable(() => {\r\n      destroySubscription.dispose()\r\n      pathChangeSubscription.dispose()\r\n      this.subscriptions.remove(pathChangeSubscription)\r\n      this.subscriptions.remove(destroySubscription)\r\n      this.grammarScoresByBuffer.delete(buffer)\r\n      this.languageOverridesByBufferId.delete(buffer.id)\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.autoAssignLanguageMode","start_line":158,"end_line":168,"comment":[" Extended: Remove any language mode override that has been set for the"," given {TextBuffer}. This will assign to the buffer the best language"," mode available.",""," * `buffer` The {TextBuffer}."],"params":["buffer"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"makeValueConformToSchema","line":1167,"func_location":"Config.makeValueConformToSchema","func_start_line":1164,"func_end_line":1178,"args":["keyPath","value"],"code":"  makeValueConformToSchema (keyPath, value, options) {\r\n    if (options != null ? options.suppressException : undefined) {\r\n      try {\r\n        return this.makeValueConformToSchema(keyPath, value)\r\n      } catch (e) {\r\n        return undefined\r\n      }\r\n    } else {\r\n      let schema\r\n      if ((schema = this.getSchema(keyPath)) == null) {\r\n        if (schema === false) { throw new Error(`Illegal key path ${keyPath}`) }\r\n      }\r\n      return this.constructor.executeSchemaEnforcers(keyPath, value, schema)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.makeValueConformToSchema","start_line":1164,"end_line":1178,"comment":[],"params":["keyPath","value","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"getSchema","line":1173,"func_location":"Config.makeValueConformToSchema","func_start_line":1164,"func_end_line":1178,"args":["keyPath"],"code":"  makeValueConformToSchema (keyPath, value, options) {\r\n    if (options != null ? options.suppressException : undefined) {\r\n      try {\r\n        return this.makeValueConformToSchema(keyPath, value)\r\n      } catch (e) {\r\n        return undefined\r\n      }\r\n    } else {\r\n      let schema\r\n      if ((schema = this.getSchema(keyPath)) == null) {\r\n        if (schema === false) { throw new Error(`Illegal key path ${keyPath}`) }\r\n      }\r\n      return this.constructor.executeSchemaEnforcers(keyPath, value, schema)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.getSchema","start_line":783,"end_line":805,"comment":[" Extended: Retrieve the schema for a specific key path. The schema will tell"," you what type the keyPath expects, and other metadata about the config"," option.",""," * `keyPath` The {String} name of the key.",""," Returns an {Object} eg. `{type: 'integer', default: 23, minimum: 1}`."," Returns `null` when the keyPath has no schema specified, but is accessible"," from the root schema."],"params":["keyPath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selectors.js","name":"parse","line":24,"func_location":"matcherForSelector","func_start_line":23,"func_end_line":29,"args":["selector"],"comment":[" Essential: Return a matcher function for a selector.",""," * selector, a {String} selector"," Returns {(scope: String) -> Boolean}, a matcher function returning"," true iff the scope matches the selector."],"code":"function matcherForSelector (selector) {\r\n  const parts = parse(selector)\r\n  if (typeof parts === 'function') return parts\r\n  return selector\r\n    ? scope => isSubset(parts, parse(scope))\r\n    : always\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selectors.js","name":"parse","start_line":10,"end_line":14,"comment":[" Private: Parse a selector into parts.","          If already parsed, returns the selector unmodified.",""," * `selector` a {String|Array<String>} specifying what to match"," Returns selector parts, an {Array<String>}."],"params":["selector"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateSyncBeforeMeasuringContent","line":307,"func_location":"TextEditorComponent.measureBlockDecorations","func_start_line":291,"func_end_line":362,"args":[],"code":"  measureBlockDecorations () {\r\n    if (this.remeasureAllBlockDecorations) {\r\n      this.remeasureAllBlockDecorations = false\r\n\r\n      const decorations = this.props.model.getDecorations()\r\n      for (var i = 0; i < decorations.length; i++) {\r\n        const decoration = decorations[i]\r\n        const marker = decoration.getMarker()\r\n        if (marker.isValid() && decoration.getProperties().type === 'block') {\r\n          this.blockDecorationsToMeasure.add(decoration)\r\n        }\r\n      }\r\n\r\n      // Update the width of the line tiles to ensure block decorations are\r\n      // measured with the most recent width.\r\n      if (this.blockDecorationsToMeasure.size > 0) {\r\n        this.updateSyncBeforeMeasuringContent()\r\n      }\r\n    }\r\n\r\n    if (this.blockDecorationsToMeasure.size > 0) {\r\n      const {blockDecorationMeasurementArea} = this.refs\r\n      const sentinelElements = new Set()\r\n\r\n      blockDecorationMeasurementArea.appendChild(document.createElement('div'))\r\n      this.blockDecorationsToMeasure.forEach((decoration) => {\r\n        const {item} = decoration.getProperties()\r\n        const decorationElement = TextEditor.viewForItem(item)\r\n        if (document.contains(decorationElement)) {\r\n          const parentElement = decorationElement.parentElement\r\n\r\n          if (!decorationElement.previousSibling) {\r\n            const sentinelElement = this.blockDecorationSentinel.cloneNode()\r\n            parentElement.insertBefore(sentinelElement, decorationElement)\r\n            sentinelElements.add(sentinelElement)\r\n          }\r\n\r\n          if (!decorationElement.nextSibling) {\r\n            const sentinelElement = this.blockDecorationSentinel.cloneNode()\r\n            parentElement.appendChild(sentinelElement)\r\n            sentinelElements.add(sentinelElement)\r\n          }\r\n\r\n          this.didMeasureVisibleBlockDecoration = true\r\n        } else {\r\n          blockDecorationMeasurementArea.appendChild(this.blockDecorationSentinel.cloneNode())\r\n          blockDecorationMeasurementArea.appendChild(decorationElement)\r\n          blockDecorationMeasurementArea.appendChild(this.blockDecorationSentinel.cloneNode())\r\n        }\r\n      })\r\n\r\n      if (this.resizeBlockDecorationMeasurementsArea) {\r\n        this.resizeBlockDecorationMeasurementsArea = false\r\n        this.refs.blockDecorationMeasurementArea.style.width = this.getScrollWidth() + 'px'\r\n      }\r\n\r\n      this.blockDecorationsToMeasure.forEach((decoration) => {\r\n        const {item} = decoration.getProperties()\r\n        const decorationElement = TextEditor.viewForItem(item)\r\n        const {previousSibling, nextSibling} = decorationElement\r\n        const height = nextSibling.getBoundingClientRect().top - previousSibling.getBoundingClientRect().bottom\r\n        this.heightsByBlockDecoration.set(decoration, height)\r\n        this.lineTopIndex.resizeBlock(decoration, height)\r\n      })\r\n\r\n      sentinelElements.forEach((sentinelElement) => sentinelElement.remove())\r\n      while (blockDecorationMeasurementArea.firstChild) {\r\n        blockDecorationMeasurementArea.firstChild.remove()\r\n      }\r\n      this.blockDecorationsToMeasure.clear()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateSyncBeforeMeasuringContent","start_line":364,"end_line":387,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollWidth","line":344,"func_location":"TextEditorComponent.measureBlockDecorations","func_start_line":291,"func_end_line":362,"args":[],"code":"  measureBlockDecorations () {\r\n    if (this.remeasureAllBlockDecorations) {\r\n      this.remeasureAllBlockDecorations = false\r\n\r\n      const decorations = this.props.model.getDecorations()\r\n      for (var i = 0; i < decorations.length; i++) {\r\n        const decoration = decorations[i]\r\n        const marker = decoration.getMarker()\r\n        if (marker.isValid() && decoration.getProperties().type === 'block') {\r\n          this.blockDecorationsToMeasure.add(decoration)\r\n        }\r\n      }\r\n\r\n      // Update the width of the line tiles to ensure block decorations are\r\n      // measured with the most recent width.\r\n      if (this.blockDecorationsToMeasure.size > 0) {\r\n        this.updateSyncBeforeMeasuringContent()\r\n      }\r\n    }\r\n\r\n    if (this.blockDecorationsToMeasure.size > 0) {\r\n      const {blockDecorationMeasurementArea} = this.refs\r\n      const sentinelElements = new Set()\r\n\r\n      blockDecorationMeasurementArea.appendChild(document.createElement('div'))\r\n      this.blockDecorationsToMeasure.forEach((decoration) => {\r\n        const {item} = decoration.getProperties()\r\n        const decorationElement = TextEditor.viewForItem(item)\r\n        if (document.contains(decorationElement)) {\r\n          const parentElement = decorationElement.parentElement\r\n\r\n          if (!decorationElement.previousSibling) {\r\n            const sentinelElement = this.blockDecorationSentinel.cloneNode()\r\n            parentElement.insertBefore(sentinelElement, decorationElement)\r\n            sentinelElements.add(sentinelElement)\r\n          }\r\n\r\n          if (!decorationElement.nextSibling) {\r\n            const sentinelElement = this.blockDecorationSentinel.cloneNode()\r\n            parentElement.appendChild(sentinelElement)\r\n            sentinelElements.add(sentinelElement)\r\n          }\r\n\r\n          this.didMeasureVisibleBlockDecoration = true\r\n        } else {\r\n          blockDecorationMeasurementArea.appendChild(this.blockDecorationSentinel.cloneNode())\r\n          blockDecorationMeasurementArea.appendChild(decorationElement)\r\n          blockDecorationMeasurementArea.appendChild(this.blockDecorationSentinel.cloneNode())\r\n        }\r\n      })\r\n\r\n      if (this.resizeBlockDecorationMeasurementsArea) {\r\n        this.resizeBlockDecorationMeasurementsArea = false\r\n        this.refs.blockDecorationMeasurementArea.style.width = this.getScrollWidth() + 'px'\r\n      }\r\n\r\n      this.blockDecorationsToMeasure.forEach((decoration) => {\r\n        const {item} = decoration.getProperties()\r\n        const decorationElement = TextEditor.viewForItem(item)\r\n        const {previousSibling, nextSibling} = decorationElement\r\n        const height = nextSibling.getBoundingClientRect().top - previousSibling.getBoundingClientRect().bottom\r\n        this.heightsByBlockDecoration.set(decoration, height)\r\n        this.lineTopIndex.resizeBlock(decoration, height)\r\n      })\r\n\r\n      sentinelElements.forEach((sentinelElement) => sentinelElement.remove())\r\n      while (blockDecorationMeasurementArea.firstChild) {\r\n        blockDecorationMeasurementArea.firstChild.remove()\r\n      }\r\n      this.blockDecorationsToMeasure.clear()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollWidth","start_line":2672,"end_line":2682,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"measureGutterDimensions","line":392,"func_location":"TextEditorComponent.measureContentDuringUpdateSync","func_start_line":389,"func_end_line":424,"args":[],"code":"  measureContentDuringUpdateSync () {\r\n    let gutterDimensionsChanged = false\r\n    if (this.remeasureGutterDimensions) {\r\n      gutterDimensionsChanged = this.measureGutterDimensions()\r\n      this.remeasureGutterDimensions = false\r\n    }\r\n    const wasHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    this.measureLongestLineWidth()\r\n    this.measureHorizontalPositions()\r\n    this.updateAbsolutePositionedDecorations()\r\n\r\n    const isHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    if (this.pendingAutoscroll) {\r\n      this.derivedDimensionsCache = {}\r\n      const {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollHorizontally(screenRange, options)\r\n\r\n      if (!wasHorizontalScrollbarVisible && isHorizontalScrollbarVisible) {\r\n        this.autoscrollVertically(screenRange, options)\r\n      }\r\n      this.pendingAutoscroll = null\r\n    }\r\n\r\n    this.linesToMeasure.clear()\r\n    this.measuredContent = true\r\n\r\n    return gutterDimensionsChanged || wasHorizontalScrollbarVisible !== isHorizontalScrollbarVisible\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.measureGutterDimensions","start_line":2175,"end_line":2199,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"canScrollHorizontally","line":396,"func_location":"TextEditorComponent.measureContentDuringUpdateSync","func_start_line":389,"func_end_line":424,"args":[],"code":"  measureContentDuringUpdateSync () {\r\n    let gutterDimensionsChanged = false\r\n    if (this.remeasureGutterDimensions) {\r\n      gutterDimensionsChanged = this.measureGutterDimensions()\r\n      this.remeasureGutterDimensions = false\r\n    }\r\n    const wasHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    this.measureLongestLineWidth()\r\n    this.measureHorizontalPositions()\r\n    this.updateAbsolutePositionedDecorations()\r\n\r\n    const isHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    if (this.pendingAutoscroll) {\r\n      this.derivedDimensionsCache = {}\r\n      const {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollHorizontally(screenRange, options)\r\n\r\n      if (!wasHorizontalScrollbarVisible && isHorizontalScrollbarVisible) {\r\n        this.autoscrollVertically(screenRange, options)\r\n      }\r\n      this.pendingAutoscroll = null\r\n    }\r\n\r\n    this.linesToMeasure.clear()\r\n    this.measuredContent = true\r\n\r\n    return gutterDimensionsChanged || wasHorizontalScrollbarVisible !== isHorizontalScrollbarVisible\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.canScrollHorizontally","start_line":2651,"end_line":2657,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getHorizontalScrollbarHeight","line":397,"func_location":"TextEditorComponent.measureContentDuringUpdateSync","func_start_line":389,"func_end_line":424,"args":[],"code":"  measureContentDuringUpdateSync () {\r\n    let gutterDimensionsChanged = false\r\n    if (this.remeasureGutterDimensions) {\r\n      gutterDimensionsChanged = this.measureGutterDimensions()\r\n      this.remeasureGutterDimensions = false\r\n    }\r\n    const wasHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    this.measureLongestLineWidth()\r\n    this.measureHorizontalPositions()\r\n    this.updateAbsolutePositionedDecorations()\r\n\r\n    const isHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    if (this.pendingAutoscroll) {\r\n      this.derivedDimensionsCache = {}\r\n      const {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollHorizontally(screenRange, options)\r\n\r\n      if (!wasHorizontalScrollbarVisible && isHorizontalScrollbarVisible) {\r\n        this.autoscrollVertically(screenRange, options)\r\n      }\r\n      this.pendingAutoscroll = null\r\n    }\r\n\r\n    this.linesToMeasure.clear()\r\n    this.measuredContent = true\r\n\r\n    return gutterDimensionsChanged || wasHorizontalScrollbarVisible !== isHorizontalScrollbarVisible\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getHorizontalScrollbarHeight","start_line":2708,"end_line":2710,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"measureLongestLineWidth","line":400,"func_location":"TextEditorComponent.measureContentDuringUpdateSync","func_start_line":389,"func_end_line":424,"args":[],"code":"  measureContentDuringUpdateSync () {\r\n    let gutterDimensionsChanged = false\r\n    if (this.remeasureGutterDimensions) {\r\n      gutterDimensionsChanged = this.measureGutterDimensions()\r\n      this.remeasureGutterDimensions = false\r\n    }\r\n    const wasHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    this.measureLongestLineWidth()\r\n    this.measureHorizontalPositions()\r\n    this.updateAbsolutePositionedDecorations()\r\n\r\n    const isHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    if (this.pendingAutoscroll) {\r\n      this.derivedDimensionsCache = {}\r\n      const {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollHorizontally(screenRange, options)\r\n\r\n      if (!wasHorizontalScrollbarVisible && isHorizontalScrollbarVisible) {\r\n        this.autoscrollVertically(screenRange, options)\r\n      }\r\n      this.pendingAutoscroll = null\r\n    }\r\n\r\n    this.linesToMeasure.clear()\r\n    this.measuredContent = true\r\n\r\n    return gutterDimensionsChanged || wasHorizontalScrollbarVisible !== isHorizontalScrollbarVisible\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.measureLongestLineWidth","start_line":2231,"end_line":2237,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"measureHorizontalPositions","line":401,"func_location":"TextEditorComponent.measureContentDuringUpdateSync","func_start_line":389,"func_end_line":424,"args":[],"code":"  measureContentDuringUpdateSync () {\r\n    let gutterDimensionsChanged = false\r\n    if (this.remeasureGutterDimensions) {\r\n      gutterDimensionsChanged = this.measureGutterDimensions()\r\n      this.remeasureGutterDimensions = false\r\n    }\r\n    const wasHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    this.measureLongestLineWidth()\r\n    this.measureHorizontalPositions()\r\n    this.updateAbsolutePositionedDecorations()\r\n\r\n    const isHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    if (this.pendingAutoscroll) {\r\n      this.derivedDimensionsCache = {}\r\n      const {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollHorizontally(screenRange, options)\r\n\r\n      if (!wasHorizontalScrollbarVisible && isHorizontalScrollbarVisible) {\r\n        this.autoscrollVertically(screenRange, options)\r\n      }\r\n      this.pendingAutoscroll = null\r\n    }\r\n\r\n    this.linesToMeasure.clear()\r\n    this.measuredContent = true\r\n\r\n    return gutterDimensionsChanged || wasHorizontalScrollbarVisible !== isHorizontalScrollbarVisible\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.measureHorizontalPositions","start_line":2259,"end_line":2292,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateAbsolutePositionedDecorations","line":402,"func_location":"TextEditorComponent.measureContentDuringUpdateSync","func_start_line":389,"func_end_line":424,"args":[],"code":"  measureContentDuringUpdateSync () {\r\n    let gutterDimensionsChanged = false\r\n    if (this.remeasureGutterDimensions) {\r\n      gutterDimensionsChanged = this.measureGutterDimensions()\r\n      this.remeasureGutterDimensions = false\r\n    }\r\n    const wasHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    this.measureLongestLineWidth()\r\n    this.measureHorizontalPositions()\r\n    this.updateAbsolutePositionedDecorations()\r\n\r\n    const isHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    if (this.pendingAutoscroll) {\r\n      this.derivedDimensionsCache = {}\r\n      const {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollHorizontally(screenRange, options)\r\n\r\n      if (!wasHorizontalScrollbarVisible && isHorizontalScrollbarVisible) {\r\n        this.autoscrollVertically(screenRange, options)\r\n      }\r\n      this.pendingAutoscroll = null\r\n    }\r\n\r\n    this.linesToMeasure.clear()\r\n    this.measuredContent = true\r\n\r\n    return gutterDimensionsChanged || wasHorizontalScrollbarVisible !== isHorizontalScrollbarVisible\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateAbsolutePositionedDecorations","start_line":1321,"end_line":1325,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"canScrollHorizontally","line":405,"func_location":"TextEditorComponent.measureContentDuringUpdateSync","func_start_line":389,"func_end_line":424,"args":[],"code":"  measureContentDuringUpdateSync () {\r\n    let gutterDimensionsChanged = false\r\n    if (this.remeasureGutterDimensions) {\r\n      gutterDimensionsChanged = this.measureGutterDimensions()\r\n      this.remeasureGutterDimensions = false\r\n    }\r\n    const wasHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    this.measureLongestLineWidth()\r\n    this.measureHorizontalPositions()\r\n    this.updateAbsolutePositionedDecorations()\r\n\r\n    const isHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    if (this.pendingAutoscroll) {\r\n      this.derivedDimensionsCache = {}\r\n      const {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollHorizontally(screenRange, options)\r\n\r\n      if (!wasHorizontalScrollbarVisible && isHorizontalScrollbarVisible) {\r\n        this.autoscrollVertically(screenRange, options)\r\n      }\r\n      this.pendingAutoscroll = null\r\n    }\r\n\r\n    this.linesToMeasure.clear()\r\n    this.measuredContent = true\r\n\r\n    return gutterDimensionsChanged || wasHorizontalScrollbarVisible !== isHorizontalScrollbarVisible\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.canScrollHorizontally","start_line":2651,"end_line":2657,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getHorizontalScrollbarHeight","line":406,"func_location":"TextEditorComponent.measureContentDuringUpdateSync","func_start_line":389,"func_end_line":424,"args":[],"code":"  measureContentDuringUpdateSync () {\r\n    let gutterDimensionsChanged = false\r\n    if (this.remeasureGutterDimensions) {\r\n      gutterDimensionsChanged = this.measureGutterDimensions()\r\n      this.remeasureGutterDimensions = false\r\n    }\r\n    const wasHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    this.measureLongestLineWidth()\r\n    this.measureHorizontalPositions()\r\n    this.updateAbsolutePositionedDecorations()\r\n\r\n    const isHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    if (this.pendingAutoscroll) {\r\n      this.derivedDimensionsCache = {}\r\n      const {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollHorizontally(screenRange, options)\r\n\r\n      if (!wasHorizontalScrollbarVisible && isHorizontalScrollbarVisible) {\r\n        this.autoscrollVertically(screenRange, options)\r\n      }\r\n      this.pendingAutoscroll = null\r\n    }\r\n\r\n    this.linesToMeasure.clear()\r\n    this.measuredContent = true\r\n\r\n    return gutterDimensionsChanged || wasHorizontalScrollbarVisible !== isHorizontalScrollbarVisible\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getHorizontalScrollbarHeight","start_line":2708,"end_line":2710,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"autoscrollHorizontally","line":412,"func_location":"TextEditorComponent.measureContentDuringUpdateSync","func_start_line":389,"func_end_line":424,"args":["screenRange","options"],"code":"  measureContentDuringUpdateSync () {\r\n    let gutterDimensionsChanged = false\r\n    if (this.remeasureGutterDimensions) {\r\n      gutterDimensionsChanged = this.measureGutterDimensions()\r\n      this.remeasureGutterDimensions = false\r\n    }\r\n    const wasHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    this.measureLongestLineWidth()\r\n    this.measureHorizontalPositions()\r\n    this.updateAbsolutePositionedDecorations()\r\n\r\n    const isHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    if (this.pendingAutoscroll) {\r\n      this.derivedDimensionsCache = {}\r\n      const {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollHorizontally(screenRange, options)\r\n\r\n      if (!wasHorizontalScrollbarVisible && isHorizontalScrollbarVisible) {\r\n        this.autoscrollVertically(screenRange, options)\r\n      }\r\n      this.pendingAutoscroll = null\r\n    }\r\n\r\n    this.linesToMeasure.clear()\r\n    this.measuredContent = true\r\n\r\n    return gutterDimensionsChanged || wasHorizontalScrollbarVisible !== isHorizontalScrollbarVisible\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.autoscrollHorizontally","start_line":2071,"end_line":2095,"comment":[],"params":["screenRange","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"autoscrollVertically","line":415,"func_location":"TextEditorComponent.measureContentDuringUpdateSync","func_start_line":389,"func_end_line":424,"args":["screenRange","options"],"code":"  measureContentDuringUpdateSync () {\r\n    let gutterDimensionsChanged = false\r\n    if (this.remeasureGutterDimensions) {\r\n      gutterDimensionsChanged = this.measureGutterDimensions()\r\n      this.remeasureGutterDimensions = false\r\n    }\r\n    const wasHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    this.measureLongestLineWidth()\r\n    this.measureHorizontalPositions()\r\n    this.updateAbsolutePositionedDecorations()\r\n\r\n    const isHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    if (this.pendingAutoscroll) {\r\n      this.derivedDimensionsCache = {}\r\n      const {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollHorizontally(screenRange, options)\r\n\r\n      if (!wasHorizontalScrollbarVisible && isHorizontalScrollbarVisible) {\r\n        this.autoscrollVertically(screenRange, options)\r\n      }\r\n      this.pendingAutoscroll = null\r\n    }\r\n\r\n    this.linesToMeasure.clear()\r\n    this.measuredContent = true\r\n\r\n    return gutterDimensionsChanged || wasHorizontalScrollbarVisible !== isHorizontalScrollbarVisible\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.autoscrollVertically","start_line":2035,"end_line":2069,"comment":[],"params":["screenRange","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"measureCharacterDimensions","line":2150,"func_location":"TextEditorComponent.measureDimensions","func_start_line":2149,"func_end_line":2156,"args":[],"comment":[" This method exists because it existed in the previous implementation and some"," package tests relied on it"],"code":"  measureDimensions () {\r\n    this.measureCharacterDimensions()\r\n    this.measureGutterDimensions()\r\n    this.measureClientContainerHeight()\r\n    this.measureClientContainerWidth()\r\n    this.measureScrollbarDimensions()\r\n    this.hasInitialMeasurements = true\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.measureCharacterDimensions","start_line":2158,"end_line":2173,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"measureGutterDimensions","line":2151,"func_location":"TextEditorComponent.measureDimensions","func_start_line":2149,"func_end_line":2156,"args":[],"comment":[" This method exists because it existed in the previous implementation and some"," package tests relied on it"],"code":"  measureDimensions () {\r\n    this.measureCharacterDimensions()\r\n    this.measureGutterDimensions()\r\n    this.measureClientContainerHeight()\r\n    this.measureClientContainerWidth()\r\n    this.measureScrollbarDimensions()\r\n    this.hasInitialMeasurements = true\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.measureGutterDimensions","start_line":2175,"end_line":2199,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"measureClientContainerHeight","line":2152,"func_location":"TextEditorComponent.measureDimensions","func_start_line":2149,"func_end_line":2156,"args":[],"comment":[" This method exists because it existed in the previous implementation and some"," package tests relied on it"],"code":"  measureDimensions () {\r\n    this.measureCharacterDimensions()\r\n    this.measureGutterDimensions()\r\n    this.measureClientContainerHeight()\r\n    this.measureClientContainerWidth()\r\n    this.measureScrollbarDimensions()\r\n    this.hasInitialMeasurements = true\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.measureClientContainerHeight","start_line":2201,"end_line":2209,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"measureClientContainerWidth","line":2153,"func_location":"TextEditorComponent.measureDimensions","func_start_line":2149,"func_end_line":2156,"args":[],"comment":[" This method exists because it existed in the previous implementation and some"," package tests relied on it"],"code":"  measureDimensions () {\r\n    this.measureCharacterDimensions()\r\n    this.measureGutterDimensions()\r\n    this.measureClientContainerHeight()\r\n    this.measureClientContainerWidth()\r\n    this.measureScrollbarDimensions()\r\n    this.hasInitialMeasurements = true\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.measureClientContainerWidth","start_line":2211,"end_line":2219,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"measureScrollbarDimensions","line":2154,"func_location":"TextEditorComponent.measureDimensions","func_start_line":2149,"func_end_line":2156,"args":[],"comment":[" This method exists because it existed in the previous implementation and some"," package tests relied on it"],"code":"  measureDimensions () {\r\n    this.measureCharacterDimensions()\r\n    this.measureGutterDimensions()\r\n    this.measureClientContainerHeight()\r\n    this.measureClientContainerWidth()\r\n    this.measureScrollbarDimensions()\r\n    this.hasInitialMeasurements = true\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.measureScrollbarDimensions","start_line":2221,"end_line":2229,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":107,"func_location":"TextEditorElement.measureDimensions","func_start_line":106,"func_end_line":108,"args":[],"code":"  measureDimensions () {\r\n    this.getComponent().measureDimensions()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"clientRectForRange","line":2316,"func_location":"TextEditorComponent.measureHorizontalPositionsOnLine","func_start_line":2294,"func_end_line":2344,"args":["textNode",{"type":"number"},{"type":"number"}],"code":"  measureHorizontalPositionsOnLine (lineNode, textNodes, columnsToMeasure, positions) {\r\n    let lineNodeClientLeft = -1\r\n    let textNodeStartColumn = 0\r\n    let textNodesIndex = 0\r\n    let lastTextNodeRight = null\r\n\r\n    columnLoop: // eslint-disable-line no-labels\r\n    for (let columnsIndex = 0; columnsIndex < columnsToMeasure.length; columnsIndex++) {\r\n      const nextColumnToMeasure = columnsToMeasure[columnsIndex]\r\n      while (textNodesIndex < textNodes.length) {\r\n        if (nextColumnToMeasure === 0) {\r\n          positions.set(0, 0)\r\n          continue columnLoop // eslint-disable-line no-labels\r\n        }\r\n\r\n        if (positions.has(nextColumnToMeasure)) continue columnLoop // eslint-disable-line no-labels\r\n        const textNode = textNodes[textNodesIndex]\r\n        const textNodeEndColumn = textNodeStartColumn + textNode.textContent.length\r\n\r\n        if (nextColumnToMeasure < textNodeEndColumn) {\r\n          let clientPixelPosition\r\n          if (nextColumnToMeasure === textNodeStartColumn) {\r\n            clientPixelPosition = clientRectForRange(textNode, 0, 1).left\r\n          } else {\r\n            clientPixelPosition = clientRectForRange(textNode, 0, nextColumnToMeasure - textNodeStartColumn).right\r\n          }\r\n\r\n          if (lineNodeClientLeft === -1) {\r\n            lineNodeClientLeft = lineNode.getBoundingClientRect().left\r\n          }\r\n\r\n          positions.set(nextColumnToMeasure, Math.round(clientPixelPosition - lineNodeClientLeft))\r\n          continue columnLoop // eslint-disable-line no-labels\r\n        } else {\r\n          textNodesIndex++\r\n          textNodeStartColumn = textNodeEndColumn\r\n        }\r\n      }\r\n\r\n      if (lastTextNodeRight == null) {\r\n        const lastTextNode = textNodes[textNodes.length - 1]\r\n        lastTextNodeRight = clientRectForRange(lastTextNode, 0, lastTextNode.textContent.length).right\r\n      }\r\n\r\n      if (lineNodeClientLeft === -1) {\r\n        lineNodeClientLeft = lineNode.getBoundingClientRect().left\r\n      }\r\n\r\n      positions.set(nextColumnToMeasure, Math.round(lastTextNodeRight - lineNodeClientLeft))\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"clientRectForRange","start_line":4335,"end_line":4340,"comment":[],"params":["textNode","startIndex","endIndex"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"clientRectForRange","line":2318,"func_location":"TextEditorComponent.measureHorizontalPositionsOnLine","func_start_line":2294,"func_end_line":2344,"args":["textNode",{"type":"number"},null],"code":"  measureHorizontalPositionsOnLine (lineNode, textNodes, columnsToMeasure, positions) {\r\n    let lineNodeClientLeft = -1\r\n    let textNodeStartColumn = 0\r\n    let textNodesIndex = 0\r\n    let lastTextNodeRight = null\r\n\r\n    columnLoop: // eslint-disable-line no-labels\r\n    for (let columnsIndex = 0; columnsIndex < columnsToMeasure.length; columnsIndex++) {\r\n      const nextColumnToMeasure = columnsToMeasure[columnsIndex]\r\n      while (textNodesIndex < textNodes.length) {\r\n        if (nextColumnToMeasure === 0) {\r\n          positions.set(0, 0)\r\n          continue columnLoop // eslint-disable-line no-labels\r\n        }\r\n\r\n        if (positions.has(nextColumnToMeasure)) continue columnLoop // eslint-disable-line no-labels\r\n        const textNode = textNodes[textNodesIndex]\r\n        const textNodeEndColumn = textNodeStartColumn + textNode.textContent.length\r\n\r\n        if (nextColumnToMeasure < textNodeEndColumn) {\r\n          let clientPixelPosition\r\n          if (nextColumnToMeasure === textNodeStartColumn) {\r\n            clientPixelPosition = clientRectForRange(textNode, 0, 1).left\r\n          } else {\r\n            clientPixelPosition = clientRectForRange(textNode, 0, nextColumnToMeasure - textNodeStartColumn).right\r\n          }\r\n\r\n          if (lineNodeClientLeft === -1) {\r\n            lineNodeClientLeft = lineNode.getBoundingClientRect().left\r\n          }\r\n\r\n          positions.set(nextColumnToMeasure, Math.round(clientPixelPosition - lineNodeClientLeft))\r\n          continue columnLoop // eslint-disable-line no-labels\r\n        } else {\r\n          textNodesIndex++\r\n          textNodeStartColumn = textNodeEndColumn\r\n        }\r\n      }\r\n\r\n      if (lastTextNodeRight == null) {\r\n        const lastTextNode = textNodes[textNodes.length - 1]\r\n        lastTextNodeRight = clientRectForRange(lastTextNode, 0, lastTextNode.textContent.length).right\r\n      }\r\n\r\n      if (lineNodeClientLeft === -1) {\r\n        lineNodeClientLeft = lineNode.getBoundingClientRect().left\r\n      }\r\n\r\n      positions.set(nextColumnToMeasure, Math.round(lastTextNodeRight - lineNodeClientLeft))\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"clientRectForRange","start_line":4335,"end_line":4340,"comment":[],"params":["textNode","startIndex","endIndex"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"clientRectForRange","line":2335,"func_location":"TextEditorComponent.measureHorizontalPositionsOnLine","func_start_line":2294,"func_end_line":2344,"args":["lastTextNode",{"type":"number"},"lastTextNode.textContent.length"],"code":"  measureHorizontalPositionsOnLine (lineNode, textNodes, columnsToMeasure, positions) {\r\n    let lineNodeClientLeft = -1\r\n    let textNodeStartColumn = 0\r\n    let textNodesIndex = 0\r\n    let lastTextNodeRight = null\r\n\r\n    columnLoop: // eslint-disable-line no-labels\r\n    for (let columnsIndex = 0; columnsIndex < columnsToMeasure.length; columnsIndex++) {\r\n      const nextColumnToMeasure = columnsToMeasure[columnsIndex]\r\n      while (textNodesIndex < textNodes.length) {\r\n        if (nextColumnToMeasure === 0) {\r\n          positions.set(0, 0)\r\n          continue columnLoop // eslint-disable-line no-labels\r\n        }\r\n\r\n        if (positions.has(nextColumnToMeasure)) continue columnLoop // eslint-disable-line no-labels\r\n        const textNode = textNodes[textNodesIndex]\r\n        const textNodeEndColumn = textNodeStartColumn + textNode.textContent.length\r\n\r\n        if (nextColumnToMeasure < textNodeEndColumn) {\r\n          let clientPixelPosition\r\n          if (nextColumnToMeasure === textNodeStartColumn) {\r\n            clientPixelPosition = clientRectForRange(textNode, 0, 1).left\r\n          } else {\r\n            clientPixelPosition = clientRectForRange(textNode, 0, nextColumnToMeasure - textNodeStartColumn).right\r\n          }\r\n\r\n          if (lineNodeClientLeft === -1) {\r\n            lineNodeClientLeft = lineNode.getBoundingClientRect().left\r\n          }\r\n\r\n          positions.set(nextColumnToMeasure, Math.round(clientPixelPosition - lineNodeClientLeft))\r\n          continue columnLoop // eslint-disable-line no-labels\r\n        } else {\r\n          textNodesIndex++\r\n          textNodeStartColumn = textNodeEndColumn\r\n        }\r\n      }\r\n\r\n      if (lastTextNodeRight == null) {\r\n        const lastTextNode = textNodes[textNodes.length - 1]\r\n        lastTextNodeRight = clientRectForRange(lastTextNode, 0, lastTextNode.textContent.length).right\r\n      }\r\n\r\n      if (lineNodeClientLeft === -1) {\r\n        lineNodeClientLeft = lineNode.getBoundingClientRect().left\r\n      }\r\n\r\n      positions.set(nextColumnToMeasure, Math.round(lastTextNodeRight - lineNodeClientLeft))\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"clientRectForRange","start_line":4335,"end_line":4340,"comment":[],"params":["textNode","startIndex","endIndex"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js","name":"cloneMenuItem","line":15,"func_location":"merge","func_start_line":14,"func_end_line":32,"args":["item"],"code":"function merge (menu, item, itemSpecificity = Infinity) {\r\n  item = cloneMenuItem(item)\r\n  ItemSpecificities.set(item, itemSpecificity)\r\n  const matchingItemIndex = findMatchingItemIndex(menu, item)\r\n\r\n  if (matchingItemIndex === -1) {\r\n    addItemToMenu(item, menu)\r\n    return\r\n  }\r\n\r\n  const matchingItem = menu[matchingItemIndex]\r\n  if (item.submenu != null) {\r\n    for (let submenuItem of item.submenu) {\r\n      merge(matchingItem.submenu, submenuItem, itemSpecificity)\r\n    }\r\n  } else if (itemSpecificity && itemSpecificity >= ItemSpecificities.get(matchingItem)) {\r\n    menu[matchingItemIndex] = item\r\n  }\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js","name":"cloneMenuItem","start_line":75,"end_line":96,"comment":[],"params":["item"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js","name":"findMatchingItemIndex","line":17,"func_location":"merge","func_start_line":14,"func_end_line":32,"args":["menu","item"],"code":"function merge (menu, item, itemSpecificity = Infinity) {\r\n  item = cloneMenuItem(item)\r\n  ItemSpecificities.set(item, itemSpecificity)\r\n  const matchingItemIndex = findMatchingItemIndex(menu, item)\r\n\r\n  if (matchingItemIndex === -1) {\r\n    addItemToMenu(item, menu)\r\n    return\r\n  }\r\n\r\n  const matchingItem = menu[matchingItemIndex]\r\n  if (item.submenu != null) {\r\n    for (let submenuItem of item.submenu) {\r\n      merge(matchingItem.submenu, submenuItem, itemSpecificity)\r\n    }\r\n  } else if (itemSpecificity && itemSpecificity >= ItemSpecificities.get(matchingItem)) {\r\n    menu[matchingItemIndex] = item\r\n  }\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js","name":"findMatchingItemIndex","start_line":52,"end_line":66,"comment":[],"params":["menu",["type","label","submenu"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js","name":"addItemToMenu","line":20,"func_location":"merge","func_start_line":14,"func_end_line":32,"args":["item","menu"],"code":"function merge (menu, item, itemSpecificity = Infinity) {\r\n  item = cloneMenuItem(item)\r\n  ItemSpecificities.set(item, itemSpecificity)\r\n  const matchingItemIndex = findMatchingItemIndex(menu, item)\r\n\r\n  if (matchingItemIndex === -1) {\r\n    addItemToMenu(item, menu)\r\n    return\r\n  }\r\n\r\n  const matchingItem = menu[matchingItemIndex]\r\n  if (item.submenu != null) {\r\n    for (let submenuItem of item.submenu) {\r\n      merge(matchingItem.submenu, submenuItem, itemSpecificity)\r\n    }\r\n  } else if (itemSpecificity && itemSpecificity >= ItemSpecificities.get(matchingItem)) {\r\n    menu[matchingItemIndex] = item\r\n  }\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js","name":"addItemToMenu","start_line":6,"end_line":12,"comment":[" Add an item to a menu, ensuring separators are not duplicated."],"params":["item","menu"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js","name":"merge","line":27,"func_location":"merge","func_start_line":14,"func_end_line":32,"args":["matchingItem.submenu","submenuItem","itemSpecificity"],"code":"function merge (menu, item, itemSpecificity = Infinity) {\r\n  item = cloneMenuItem(item)\r\n  ItemSpecificities.set(item, itemSpecificity)\r\n  const matchingItemIndex = findMatchingItemIndex(menu, item)\r\n\r\n  if (matchingItemIndex === -1) {\r\n    addItemToMenu(item, menu)\r\n    return\r\n  }\r\n\r\n  const matchingItem = menu[matchingItemIndex]\r\n  if (item.submenu != null) {\r\n    for (let submenuItem of item.submenu) {\r\n      merge(matchingItem.submenu, submenuItem, itemSpecificity)\r\n    }\r\n  } else if (itemSpecificity && itemSpecificity >= ItemSpecificities.get(matchingItem)) {\r\n    menu[matchingItemIndex] = item\r\n  }\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js","name":"merge","start_line":14,"end_line":32,"comment":[],"params":["menu","item","itemSpecificity"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js","name":"attemptToMergeAGroup","line":98,"func_location":"mergeGroups","func_start_line":95,"func_end_line":101,"args":["groups"],"comment":[" Merge groups based on before/after positions"," Mutates both the array of groups, and the individual group arrays."],"code":"function mergeGroups (groups) {\r\n  let mergedAGroup = true\r\n  while (mergedAGroup) {\r\n    mergedAGroup = attemptToMergeAGroup(groups)\r\n  }\r\n  return groups\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js","name":"attemptToMergeAGroup","start_line":71,"end_line":91,"comment":[],"params":["groups"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js","name":"mergeTable","line":159,"func_location":"mergeTable","func_start_line":154,"func_end_line":174,"args":["table.indices.key","defaultTable.indices.key"],"code":"function mergeTable (table, defaultTable, mergeIndices = true) {\r\n  if (mergeIndices && defaultTable.indices) {\r\n    if (!table.indices) table.indices = {}\r\n    for (let key in defaultTable.indices) {\r\n      if (!table.indices[key]) table.indices[key] = {}\r\n      mergeTable(table.indices[key], defaultTable.indices[key])\r\n    }\r\n  }\r\n\r\n  if (defaultTable.parents) {\r\n    if (!table.parents) table.parents = {}\r\n    for (let key in defaultTable.parents) {\r\n      if (!table.parents[key]) table.parents[key] = {}\r\n      mergeTable(table.parents[key], defaultTable.parents[key])\r\n    }\r\n  }\r\n\r\n  if (defaultTable.result != null && table.result == null) {\r\n    table.result = defaultTable.result\r\n  }\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js","name":"mergeTable","start_line":154,"end_line":174,"comment":[],"params":["table","defaultTable","mergeIndices"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js","name":"mergeTable","line":167,"func_location":"mergeTable","func_start_line":154,"func_end_line":174,"args":["table.parents.key","defaultTable.parents.key"],"code":"function mergeTable (table, defaultTable, mergeIndices = true) {\r\n  if (mergeIndices && defaultTable.indices) {\r\n    if (!table.indices) table.indices = {}\r\n    for (let key in defaultTable.indices) {\r\n      if (!table.indices[key]) table.indices[key] = {}\r\n      mergeTable(table.indices[key], defaultTable.indices[key])\r\n    }\r\n  }\r\n\r\n  if (defaultTable.parents) {\r\n    if (!table.parents) table.parents = {}\r\n    for (let key in defaultTable.parents) {\r\n      if (!table.parents[key]) table.parents[key] = {}\r\n      mergeTable(table.parents[key], defaultTable.parents[key])\r\n    }\r\n  }\r\n\r\n  if (defaultTable.result != null && table.result == null) {\r\n    table.result = defaultTable.result\r\n  }\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js","name":"mergeTable","start_line":154,"end_line":174,"comment":[],"params":["table","defaultTable","mergeIndices"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"nearestVisiblePaneInDirection","line":258,"func_location":"WorkspaceElement.moveActiveItemToNearestPaneInDirection","func_start_line":256,"func_end_line":266,"args":["direction","activePane"],"code":"  moveActiveItemToNearestPaneInDirection (direction, params) {\r\n    const activePane = this.model.getActivePane()\r\n    const nearestPaneView = this.nearestVisiblePaneInDirection(direction, activePane)\r\n    if (nearestPaneView == null) { return }\r\n    if (params && params.keepOriginal) {\r\n      activePane.getContainer().copyActiveItemToPane(nearestPaneView.getModel())\r\n    } else {\r\n      activePane.getContainer().moveActiveItemToPane(nearestPaneView.getModel())\r\n    }\r\n    nearestPaneView.focus()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.nearestVisiblePaneInDirection","start_line":268,"end_line":300,"comment":[],"params":["direction","pane"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"moveActiveItemToNearestPaneInDirection","line":241,"func_location":"WorkspaceElement.moveActiveItemToPaneAbove","func_start_line":240,"func_end_line":242,"args":[{"type":"string"},"params"],"code":"  moveActiveItemToPaneAbove (params) {\r\n    this.moveActiveItemToNearestPaneInDirection('above', params)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.moveActiveItemToNearestPaneInDirection","start_line":256,"end_line":266,"comment":[],"params":["direction","params"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"moveActiveItemToNearestPaneInDirection","line":245,"func_location":"WorkspaceElement.moveActiveItemToPaneBelow","func_start_line":244,"func_end_line":246,"args":[{"type":"string"},"params"],"code":"  moveActiveItemToPaneBelow (params) {\r\n    this.moveActiveItemToNearestPaneInDirection('below', params)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.moveActiveItemToNearestPaneInDirection","start_line":256,"end_line":266,"comment":[],"params":["direction","params"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"moveActiveItemToNearestPaneInDirection","line":249,"func_location":"WorkspaceElement.moveActiveItemToPaneOnLeft","func_start_line":248,"func_end_line":250,"args":[{"type":"string"},"params"],"code":"  moveActiveItemToPaneOnLeft (params) {\r\n    this.moveActiveItemToNearestPaneInDirection('left', params)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.moveActiveItemToNearestPaneInDirection","start_line":256,"end_line":266,"comment":[],"params":["direction","params"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"moveActiveItemToNearestPaneInDirection","line":253,"func_location":"WorkspaceElement.moveActiveItemToPaneOnRight","func_start_line":252,"func_end_line":254,"args":[{"type":"string"},"params"],"code":"  moveActiveItemToPaneOnRight (params) {\r\n    this.moveActiveItemToNearestPaneInDirection('right', params)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.moveActiveItemToNearestPaneInDirection","start_line":256,"end_line":266,"comment":[],"params":["direction","params"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"addItemToStack","line":508,"func_location":"Pane.moveActiveItemToTopOfStack","func_start_line":506,"func_end_line":510,"args":[".activeItem"],"comment":[" Moves the active item to the end of the itemStack once the ctrl key is lifted"],"code":"  moveActiveItemToTopOfStack () {\r\n    delete this.itemStackIndex\r\n    this.addItemToStack(this.activeItem)\r\n    this.emitter.emit('done-choosing-mru-item')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.addItemToStack","start_line":459,"end_line":464,"comment":[" Add item (or move item) to the end of the itemStack"],"params":["newItem"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getScreenPosition","line":267,"func_location":"Cursor.moveDown","func_start_line":261,"func_end_line":273,"args":[],"comment":[" Public: Moves the cursor down one screen row.",""," * `rowCount` (optional) {Number} number of rows to move (default: 1)"," * `options` (optional) {Object} with the following keys:","   * `moveToEndOfSelection` if true, move to the left of the selection if a","     selection exists."],"code":"  moveDown (rowCount = 1, {moveToEndOfSelection} = {}) {\r\n    let row, column\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      ({row, column} = range.end)\r\n    } else {\r\n      ({row, column} = this.getScreenPosition())\r\n    }\r\n\r\n    if (this.goalColumn != null) column = this.goalColumn\r\n    this.setScreenPosition({row: row + rowCount, column}, {skipSoftWrapIndentation: true})\r\n    this.goalColumn = column\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getScreenPosition","start_line":73,"end_line":75,"comment":[" Public: Returns the screen position of the cursor as a {Point}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"setScreenPosition","line":271,"func_location":"Cursor.moveDown","func_start_line":261,"func_end_line":273,"args":[null,null],"comment":[" Public: Moves the cursor down one screen row.",""," * `rowCount` (optional) {Number} number of rows to move (default: 1)"," * `options` (optional) {Object} with the following keys:","   * `moveToEndOfSelection` if true, move to the left of the selection if a","     selection exists."],"code":"  moveDown (rowCount = 1, {moveToEndOfSelection} = {}) {\r\n    let row, column\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      ({row, column} = range.end)\r\n    } else {\r\n      ({row, column} = this.getScreenPosition())\r\n    }\r\n\r\n    if (this.goalColumn != null) column = this.goalColumn\r\n    this.setScreenPosition({row: row + rowCount, column}, {skipSoftWrapIndentation: true})\r\n    this.goalColumn = column\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.setScreenPosition","start_line":66,"end_line":70,"comment":["\r\n  Section: Managing Cursor Position\r\n  "," Public: Moves a cursor to a given screen position.",""," * `screenPosition` {Array} of two numbers: the screen row, and the screen column."," * `options` (optional) {Object} with the following keys:","   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever","     the cursor moves to."],"params":["screenPosition","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getActiveItemIndex","line":545,"func_location":"Pane.moveItemLeft","func_start_line":544,"func_end_line":548,"args":[],"comment":[" Public: Move the active tab to the left"],"code":"  moveItemLeft () {\r\n    const index = this.getActiveItemIndex()\r\n    const leftItemIndex = index - 1\r\n    if (leftItemIndex >= 0) return this.moveItem(this.getActiveItem(), leftItemIndex)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getActiveItemIndex","start_line":553,"end_line":555,"comment":[" Public: Get the index of the active item.",""," Returns a {Number}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"moveItem","line":547,"func_location":"Pane.moveItemLeft","func_start_line":544,"func_end_line":548,"args":[null,"leftItemIndex"],"comment":[" Public: Move the active tab to the left"],"code":"  moveItemLeft () {\r\n    const index = this.getActiveItemIndex()\r\n    const leftItemIndex = index - 1\r\n    if (leftItemIndex >= 0) return this.moveItem(this.getActiveItem(), leftItemIndex)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.moveItem","start_line":720,"end_line":725,"comment":[" Public: Move the given item to the given index.",""," * `item` The item to move."," * `index` {Number} indicating the index to which to move the item."],"params":["item","newIndex"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getActiveItem","line":547,"func_location":"Pane.moveItemLeft","func_start_line":544,"func_end_line":548,"args":[null,"leftItemIndex"],"comment":[" Public: Move the active tab to the left"],"code":"  moveItemLeft () {\r\n    const index = this.getActiveItemIndex()\r\n    const leftItemIndex = index - 1\r\n    if (leftItemIndex >= 0) return this.moveItem(this.getActiveItem(), leftItemIndex)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getActiveItem","start_line":432,"end_line":432,"comment":[" Public: Get the active pane item in this pane.",""," Returns a pane item."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getActiveItemIndex","line":538,"func_location":"Pane.moveItemRight","func_start_line":537,"func_end_line":541,"args":[],"comment":[" Public: Move the active tab to the right."],"code":"  moveItemRight () {\r\n    const index = this.getActiveItemIndex()\r\n    const rightItemIndex = index + 1\r\n    if (rightItemIndex <= this.items.length - 1) this.moveItem(this.getActiveItem(), rightItemIndex)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getActiveItemIndex","start_line":553,"end_line":555,"comment":[" Public: Get the index of the active item.",""," Returns a {Number}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"moveItem","line":540,"func_location":"Pane.moveItemRight","func_start_line":537,"func_end_line":541,"args":[null,"rightItemIndex"],"comment":[" Public: Move the active tab to the right."],"code":"  moveItemRight () {\r\n    const index = this.getActiveItemIndex()\r\n    const rightItemIndex = index + 1\r\n    if (rightItemIndex <= this.items.length - 1) this.moveItem(this.getActiveItem(), rightItemIndex)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.moveItem","start_line":720,"end_line":725,"comment":[" Public: Move the given item to the given index.",""," * `item` The item to move."," * `index` {Number} indicating the index to which to move the item."],"params":["item","newIndex"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getActiveItem","line":540,"func_location":"Pane.moveItemRight","func_start_line":537,"func_end_line":541,"args":[null,"rightItemIndex"],"comment":[" Public: Move the active tab to the right."],"code":"  moveItemRight () {\r\n    const index = this.getActiveItemIndex()\r\n    const rightItemIndex = index + 1\r\n    if (rightItemIndex <= this.items.length - 1) this.moveItem(this.getActiveItem(), rightItemIndex)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getActiveItem","start_line":432,"end_line":432,"comment":[" Public: Get the active pane item in this pane.",""," Returns a pane item."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"removeItem","line":734,"func_location":"Pane.moveItemToPane","func_start_line":733,"func_end_line":736,"args":["item",{"type":"boolean"}],"comment":[" Public: Move the given item to the given index on another pane.",""," * `item` The item to move."," * `pane` {Pane} to which to move the item."," * `index` {Number} indicating the index to which to move the item in the","   given pane."],"code":"  moveItemToPane (item, pane, index) {\r\n    this.removeItem(item, true)\r\n    return pane.addItem(item, {index, moved: true})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.removeItem","start_line":684,"end_line":705,"comment":[],"params":["item","moved"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"setScreenPosition","line":284,"func_location":"Cursor.moveLeft","func_start_line":281,"func_end_line":297,"args":["range.start"],"comment":[" Public: Moves the cursor left one screen column.",""," * `columnCount` (optional) {Number} number of columns to move (default: 1)"," * `options` (optional) {Object} with the following keys:","   * `moveToEndOfSelection` if true, move to the left of the selection if a","     selection exists."],"code":"  moveLeft (columnCount = 1, {moveToEndOfSelection} = {}) {\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      this.setScreenPosition(range.start)\r\n    } else {\r\n      let {row, column} = this.getScreenPosition()\r\n\r\n      while (columnCount > column && row > 0) {\r\n        columnCount -= column\r\n        column = this.editor.lineLengthForScreenRow(--row)\r\n        columnCount-- // subtract 1 for the row move\r\n      }\r\n\r\n      column = column - columnCount\r\n      this.setScreenPosition({row, column}, {clipDirection: 'backward'})\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.setScreenPosition","start_line":66,"end_line":70,"comment":["\r\n  Section: Managing Cursor Position\r\n  "," Public: Moves a cursor to a given screen position.",""," * `screenPosition` {Array} of two numbers: the screen row, and the screen column."," * `options` (optional) {Object} with the following keys:","   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever","     the cursor moves to."],"params":["screenPosition","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getScreenPosition","line":286,"func_location":"Cursor.moveLeft","func_start_line":281,"func_end_line":297,"args":[],"comment":[" Public: Moves the cursor left one screen column.",""," * `columnCount` (optional) {Number} number of columns to move (default: 1)"," * `options` (optional) {Object} with the following keys:","   * `moveToEndOfSelection` if true, move to the left of the selection if a","     selection exists."],"code":"  moveLeft (columnCount = 1, {moveToEndOfSelection} = {}) {\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      this.setScreenPosition(range.start)\r\n    } else {\r\n      let {row, column} = this.getScreenPosition()\r\n\r\n      while (columnCount > column && row > 0) {\r\n        columnCount -= column\r\n        column = this.editor.lineLengthForScreenRow(--row)\r\n        columnCount-- // subtract 1 for the row move\r\n      }\r\n\r\n      column = column - columnCount\r\n      this.setScreenPosition({row, column}, {clipDirection: 'backward'})\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getScreenPosition","start_line":73,"end_line":75,"comment":[" Public: Returns the screen position of the cursor as a {Point}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"setScreenPosition","line":295,"func_location":"Cursor.moveLeft","func_start_line":281,"func_end_line":297,"args":[null,null],"comment":[" Public: Moves the cursor left one screen column.",""," * `columnCount` (optional) {Number} number of columns to move (default: 1)"," * `options` (optional) {Object} with the following keys:","   * `moveToEndOfSelection` if true, move to the left of the selection if a","     selection exists."],"code":"  moveLeft (columnCount = 1, {moveToEndOfSelection} = {}) {\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      this.setScreenPosition(range.start)\r\n    } else {\r\n      let {row, column} = this.getScreenPosition()\r\n\r\n      while (columnCount > column && row > 0) {\r\n        columnCount -= column\r\n        column = this.editor.lineLengthForScreenRow(--row)\r\n        columnCount-- // subtract 1 for the row move\r\n      }\r\n\r\n      column = column - columnCount\r\n      this.setScreenPosition({row, column}, {clipDirection: 'backward'})\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.setScreenPosition","start_line":66,"end_line":70,"comment":["\r\n  Section: Managing Cursor Position\r\n  "," Public: Moves a cursor to a given screen position.",""," * `screenPosition` {Array} of two numbers: the screen row, and the screen column."," * `options` (optional) {Object} with the following keys:","   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever","     the cursor moves to."],"params":["screenPosition","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"setScreenPosition","line":308,"func_location":"Cursor.moveRight","func_start_line":305,"func_end_line":327,"args":["range.end"],"comment":[" Public: Moves the cursor right one screen column.",""," * `columnCount` (optional) {Number} number of columns to move (default: 1)"," * `options` (optional) {Object} with the following keys:","   * `moveToEndOfSelection` if true, move to the right of the selection if a","     selection exists."],"code":"  moveRight (columnCount = 1, {moveToEndOfSelection} = {}) {\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      this.setScreenPosition(range.end)\r\n    } else {\r\n      let {row, column} = this.getScreenPosition()\r\n      const maxLines = this.editor.getScreenLineCount()\r\n      let rowLength = this.editor.lineLengthForScreenRow(row)\r\n      let columnsRemainingInLine = rowLength - column\r\n\r\n      while (columnCount > columnsRemainingInLine && row < maxLines - 1) {\r\n        columnCount -= columnsRemainingInLine\r\n        columnCount-- // subtract 1 for the row move\r\n\r\n        column = 0\r\n        rowLength = this.editor.lineLengthForScreenRow(++row)\r\n        columnsRemainingInLine = rowLength\r\n      }\r\n\r\n      column = column + columnCount\r\n      this.setScreenPosition({row, column}, {clipDirection: 'forward'})\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.setScreenPosition","start_line":66,"end_line":70,"comment":["\r\n  Section: Managing Cursor Position\r\n  "," Public: Moves a cursor to a given screen position.",""," * `screenPosition` {Array} of two numbers: the screen row, and the screen column."," * `options` (optional) {Object} with the following keys:","   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever","     the cursor moves to."],"params":["screenPosition","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getScreenPosition","line":310,"func_location":"Cursor.moveRight","func_start_line":305,"func_end_line":327,"args":[],"comment":[" Public: Moves the cursor right one screen column.",""," * `columnCount` (optional) {Number} number of columns to move (default: 1)"," * `options` (optional) {Object} with the following keys:","   * `moveToEndOfSelection` if true, move to the right of the selection if a","     selection exists."],"code":"  moveRight (columnCount = 1, {moveToEndOfSelection} = {}) {\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      this.setScreenPosition(range.end)\r\n    } else {\r\n      let {row, column} = this.getScreenPosition()\r\n      const maxLines = this.editor.getScreenLineCount()\r\n      let rowLength = this.editor.lineLengthForScreenRow(row)\r\n      let columnsRemainingInLine = rowLength - column\r\n\r\n      while (columnCount > columnsRemainingInLine && row < maxLines - 1) {\r\n        columnCount -= columnsRemainingInLine\r\n        columnCount-- // subtract 1 for the row move\r\n\r\n        column = 0\r\n        rowLength = this.editor.lineLengthForScreenRow(++row)\r\n        columnsRemainingInLine = rowLength\r\n      }\r\n\r\n      column = column + columnCount\r\n      this.setScreenPosition({row, column}, {clipDirection: 'forward'})\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getScreenPosition","start_line":73,"end_line":75,"comment":[" Public: Returns the screen position of the cursor as a {Point}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"setScreenPosition","line":325,"func_location":"Cursor.moveRight","func_start_line":305,"func_end_line":327,"args":[null,null],"comment":[" Public: Moves the cursor right one screen column.",""," * `columnCount` (optional) {Number} number of columns to move (default: 1)"," * `options` (optional) {Object} with the following keys:","   * `moveToEndOfSelection` if true, move to the right of the selection if a","     selection exists."],"code":"  moveRight (columnCount = 1, {moveToEndOfSelection} = {}) {\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      this.setScreenPosition(range.end)\r\n    } else {\r\n      let {row, column} = this.getScreenPosition()\r\n      const maxLines = this.editor.getScreenLineCount()\r\n      let rowLength = this.editor.lineLengthForScreenRow(row)\r\n      let columnsRemainingInLine = rowLength - column\r\n\r\n      while (columnCount > columnsRemainingInLine && row < maxLines - 1) {\r\n        columnCount -= columnsRemainingInLine\r\n        columnCount-- // subtract 1 for the row move\r\n\r\n        column = 0\r\n        rowLength = this.editor.lineLengthForScreenRow(++row)\r\n        columnsRemainingInLine = rowLength\r\n      }\r\n\r\n      column = column + columnCount\r\n      this.setScreenPosition({row, column}, {clipDirection: 'forward'})\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.setScreenPosition","start_line":66,"end_line":70,"comment":["\r\n  Section: Managing Cursor Position\r\n  "," Public: Moves a cursor to a given screen position.",""," * `screenPosition` {Array} of two numbers: the screen row, and the screen column."," * `options` (optional) {Object} with the following keys:","   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever","     the cursor moves to."],"params":["screenPosition","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"setBufferPosition","line":348,"func_location":"Cursor.moveToBeginningOfLine","func_start_line":347,"func_end_line":349,"args":[null],"comment":[" Public: Moves the cursor to the beginning of the buffer line."],"code":"  moveToBeginningOfLine () {\r\n    this.setBufferPosition([this.getBufferRow(), 0])\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.setBufferPosition","start_line":84,"end_line":88,"comment":[" Public: Moves a cursor to a given buffer position.",""," * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column."," * `options` (optional) {Object} with the following keys:","   * `autoscroll` {Boolean} indicating whether to autoscroll to the new","     position. Defaults to `true` if this is the most recently added cursor,","     `false` otherwise."],"params":["bufferPosition","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferRow","line":348,"func_location":"Cursor.moveToBeginningOfLine","func_start_line":347,"func_end_line":349,"args":[null],"comment":[" Public: Moves the cursor to the beginning of the buffer line."],"code":"  moveToBeginningOfLine () {\r\n    this.setBufferPosition([this.getBufferRow(), 0])\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferRow","start_line":106,"end_line":108,"comment":[" Public: Retrieves the cursor's current buffer row."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBeginningOfNextParagraphBufferPosition","line":443,"func_location":"Cursor.moveToBeginningOfNextParagraph","func_start_line":442,"func_end_line":445,"args":[],"comment":[" Public: Moves the cursor to the beginning of the next paragraph"],"code":"  moveToBeginningOfNextParagraph () {\r\n    const position = this.getBeginningOfNextParagraphBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBeginningOfNextParagraphBufferPosition","start_line":740,"end_line":753,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"setBufferPosition","line":444,"func_location":"Cursor.moveToBeginningOfNextParagraph","func_start_line":442,"func_end_line":445,"args":["position"],"comment":[" Public: Moves the cursor to the beginning of the next paragraph"],"code":"  moveToBeginningOfNextParagraph () {\r\n    const position = this.getBeginningOfNextParagraphBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.setBufferPosition","start_line":84,"end_line":88,"comment":[" Public: Moves a cursor to a given buffer position.",""," * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column."," * `options` (optional) {Object} with the following keys:","   * `autoscroll` {Boolean} indicating whether to autoscroll to the new","     position. Defaults to `true` if this is the most recently added cursor,","     `false` otherwise."],"params":["bufferPosition","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBeginningOfNextWordBufferPosition","line":398,"func_location":"Cursor.moveToBeginningOfNextWord","func_start_line":397,"func_end_line":400,"args":[],"comment":[" Public: Moves the cursor to the beginning of the next word."],"code":"  moveToBeginningOfNextWord () {\r\n    const position = this.getBeginningOfNextWordBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBeginningOfNextWordBufferPosition","start_line":587,"end_line":599,"comment":[" Public: Retrieves the buffer position of where the next word starts.",""," * `options` (optional) {Object}","   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"","     (default: {::wordRegExp}).",""," Returns a {Range}"],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"setBufferPosition","line":399,"func_location":"Cursor.moveToBeginningOfNextWord","func_start_line":397,"func_end_line":400,"args":["position"],"comment":[" Public: Moves the cursor to the beginning of the next word."],"code":"  moveToBeginningOfNextWord () {\r\n    const position = this.getBeginningOfNextWordBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.setBufferPosition","start_line":84,"end_line":88,"comment":[" Public: Moves a cursor to a given buffer position.",""," * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column."," * `options` (optional) {Object} with the following keys:","   * `autoscroll` {Boolean} indicating whether to autoscroll to the new","     position. Defaults to `true` if this is the most recently added cursor,","     `false` otherwise."],"params":["bufferPosition","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBeginningOfPreviousParagraphBufferPosition","line":449,"func_location":"Cursor.moveToBeginningOfPreviousParagraph","func_start_line":448,"func_end_line":451,"args":[],"comment":[" Public: Moves the cursor to the beginning of the previous paragraph"],"code":"  moveToBeginningOfPreviousParagraph () {\r\n    const position = this.getBeginningOfPreviousParagraphBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBeginningOfPreviousParagraphBufferPosition","start_line":755,"end_line":766,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"setBufferPosition","line":450,"func_location":"Cursor.moveToBeginningOfPreviousParagraph","func_start_line":448,"func_end_line":451,"args":["position"],"comment":[" Public: Moves the cursor to the beginning of the previous paragraph"],"code":"  moveToBeginningOfPreviousParagraph () {\r\n    const position = this.getBeginningOfPreviousParagraphBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.setBufferPosition","start_line":84,"end_line":88,"comment":[" Public: Moves a cursor to a given buffer position.",""," * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column."," * `options` (optional) {Object} with the following keys:","   * `autoscroll` {Boolean} indicating whether to autoscroll to the new","     position. Defaults to `true` if this is the most recently added cursor,","     `false` otherwise."],"params":["bufferPosition","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"setScreenPosition","line":343,"func_location":"Cursor.moveToBeginningOfScreenLine","func_start_line":342,"func_end_line":344,"args":[null],"comment":[" Public: Moves the cursor to the beginning of the line."],"code":"  moveToBeginningOfScreenLine () {\r\n    this.setScreenPosition([this.getScreenRow(), 0])\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.setScreenPosition","start_line":66,"end_line":70,"comment":["\r\n  Section: Managing Cursor Position\r\n  "," Public: Moves a cursor to a given screen position.",""," * `screenPosition` {Array} of two numbers: the screen row, and the screen column."," * `options` (optional) {Object} with the following keys:","   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever","     the cursor moves to."],"params":["screenPosition","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getScreenRow","line":343,"func_location":"Cursor.moveToBeginningOfScreenLine","func_start_line":342,"func_end_line":344,"args":[null],"comment":[" Public: Moves the cursor to the beginning of the line."],"code":"  moveToBeginningOfScreenLine () {\r\n    this.setScreenPosition([this.getScreenRow(), 0])\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getScreenRow","start_line":96,"end_line":98,"comment":[" Public: Returns the cursor's current screen row."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"setBufferPosition","line":387,"func_location":"Cursor.moveToBeginningOfWord","func_start_line":386,"func_end_line":388,"args":[null],"comment":[" Public: Moves the cursor to the beginning of the word."],"code":"  moveToBeginningOfWord () {\r\n    this.setBufferPosition(this.getBeginningOfCurrentWordBufferPosition())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.setBufferPosition","start_line":84,"end_line":88,"comment":[" Public: Moves a cursor to a given buffer position.",""," * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column."," * `options` (optional) {Object} with the following keys:","   * `autoscroll` {Boolean} indicating whether to autoscroll to the new","     position. Defaults to `true` if this is the most recently added cursor,","     `false` otherwise."],"params":["bufferPosition","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBeginningOfCurrentWordBufferPosition","line":387,"func_location":"Cursor.moveToBeginningOfWord","func_start_line":386,"func_end_line":388,"args":[null],"comment":[" Public: Moves the cursor to the beginning of the word."],"code":"  moveToBeginningOfWord () {\r\n    this.setBufferPosition(this.getBeginningOfCurrentWordBufferPosition())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBeginningOfCurrentWordBufferPosition","start_line":527,"end_line":547,"comment":[" Public: Retrieves the buffer position of where the current word starts.",""," * `options` (optional) An {Object} with the following keys:","   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"","     (default: {::wordRegExp}).","   * `includeNonWordCharacters` A {Boolean} indicating whether to include","     non-word characters in the default word regex.","     Has no effect if wordRegex is set.","   * `allowPrevious` A {Boolean} indicating whether the beginning of the","     previous word can be returned.",""," Returns a {Range}."],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"setBufferPosition","line":337,"func_location":"Cursor.moveToBottom","func_start_line":335,"func_end_line":339,"args":[null],"comment":[" Public: Moves the cursor to the bottom of the buffer."],"code":"  moveToBottom () {\r\n    const column = this.goalColumn\r\n    this.setBufferPosition(this.editor.getEofBufferPosition())\r\n    this.goalColumn = column\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.setBufferPosition","start_line":84,"end_line":88,"comment":[" Public: Moves a cursor to a given buffer position.",""," * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column."," * `options` (optional) {Object} with the following keys:","   * `autoscroll` {Boolean} indicating whether to autoscroll to the new","     position. Defaults to `true` if this is the most recently added cursor,","     `false` otherwise."],"params":["bufferPosition","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"setBufferPosition","line":382,"func_location":"Cursor.moveToEndOfLine","func_start_line":381,"func_end_line":383,"args":[null],"comment":[" Public: Moves the cursor to the end of the buffer line."],"code":"  moveToEndOfLine () {\r\n    this.setBufferPosition([this.getBufferRow(), Infinity])\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.setBufferPosition","start_line":84,"end_line":88,"comment":[" Public: Moves a cursor to a given buffer position.",""," * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column."," * `options` (optional) {Object} with the following keys:","   * `autoscroll` {Boolean} indicating whether to autoscroll to the new","     position. Defaults to `true` if this is the most recently added cursor,","     `false` otherwise."],"params":["bufferPosition","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferRow","line":382,"func_location":"Cursor.moveToEndOfLine","func_start_line":381,"func_end_line":383,"args":[null],"comment":[" Public: Moves the cursor to the end of the buffer line."],"code":"  moveToEndOfLine () {\r\n    this.setBufferPosition([this.getBufferRow(), Infinity])\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferRow","start_line":106,"end_line":108,"comment":[" Public: Retrieves the cursor's current buffer row."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"setScreenPosition","line":377,"func_location":"Cursor.moveToEndOfScreenLine","func_start_line":376,"func_end_line":378,"args":[null],"comment":[" Public: Moves the cursor to the end of the line."],"code":"  moveToEndOfScreenLine () {\r\n    this.setScreenPosition([this.getScreenRow(), Infinity])\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.setScreenPosition","start_line":66,"end_line":70,"comment":["\r\n  Section: Managing Cursor Position\r\n  "," Public: Moves a cursor to a given screen position.",""," * `screenPosition` {Array} of two numbers: the screen row, and the screen column."," * `options` (optional) {Object} with the following keys:","   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever","     the cursor moves to."],"params":["screenPosition","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getScreenRow","line":377,"func_location":"Cursor.moveToEndOfScreenLine","func_start_line":376,"func_end_line":378,"args":[null],"comment":[" Public: Moves the cursor to the end of the line."],"code":"  moveToEndOfScreenLine () {\r\n    this.setScreenPosition([this.getScreenRow(), Infinity])\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getScreenRow","start_line":96,"end_line":98,"comment":[" Public: Returns the cursor's current screen row."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getEndOfCurrentWordBufferPosition","line":392,"func_location":"Cursor.moveToEndOfWord","func_start_line":391,"func_end_line":394,"args":[],"comment":[" Public: Moves the cursor to the end of the word."],"code":"  moveToEndOfWord () {\r\n    const position = this.getEndOfCurrentWordBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getEndOfCurrentWordBufferPosition","start_line":559,"end_line":578,"comment":[" Public: Retrieves the buffer position of where the current word ends.",""," * `options` (optional) {Object} with the following keys:","   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"","      (default: {::wordRegExp})","   * `includeNonWordCharacters` A Boolean indicating whether to include","     non-word characters in the default word regex. Has no effect if","     wordRegex is set.",""," Returns a {Range}."],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"setBufferPosition","line":393,"func_location":"Cursor.moveToEndOfWord","func_start_line":391,"func_end_line":394,"args":["position"],"comment":[" Public: Moves the cursor to the end of the word."],"code":"  moveToEndOfWord () {\r\n    const position = this.getEndOfCurrentWordBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.setBufferPosition","start_line":84,"end_line":88,"comment":[" Public: Moves a cursor to a given buffer position.",""," * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column."," * `options` (optional) {Object} with the following keys:","   * `autoscroll` {Boolean} indicating whether to autoscroll to the new","     position. Defaults to `true` if this is the most recently added cursor,","     `false` otherwise."],"params":["bufferPosition","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getScreenRow","line":355,"func_location":"Cursor.moveToFirstCharacterOfLine","func_start_line":353,"func_end_line":373,"args":[],"comment":[" Public: Moves the cursor to the beginning of the first character in the"," line."],"code":"  moveToFirstCharacterOfLine () {\r\n    let targetBufferColumn\r\n    const screenRow = this.getScreenRow()\r\n    const screenLineStart = this.editor.clipScreenPosition([screenRow, 0], {skipSoftWrapIndentation: true})\r\n    const screenLineEnd = [screenRow, Infinity]\r\n    const screenLineBufferRange = this.editor.bufferRangeForScreenRange([screenLineStart, screenLineEnd])\r\n\r\n    let firstCharacterColumn = null\r\n    this.editor.scanInBufferRange(/\\S/, screenLineBufferRange, ({range, stop}) => {\r\n      firstCharacterColumn = range.start.column\r\n      stop()\r\n    })\r\n\r\n    if (firstCharacterColumn != null && firstCharacterColumn !== this.getBufferColumn()) {\r\n      targetBufferColumn = firstCharacterColumn\r\n    } else {\r\n      targetBufferColumn = screenLineBufferRange.start.column\r\n    }\r\n\r\n    this.setBufferPosition([screenLineBufferRange.start.row, targetBufferColumn])\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getScreenRow","start_line":96,"end_line":98,"comment":[" Public: Returns the cursor's current screen row."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferColumn","line":366,"func_location":"Cursor.moveToFirstCharacterOfLine","func_start_line":353,"func_end_line":373,"args":[],"comment":[" Public: Moves the cursor to the beginning of the first character in the"," line."],"code":"  moveToFirstCharacterOfLine () {\r\n    let targetBufferColumn\r\n    const screenRow = this.getScreenRow()\r\n    const screenLineStart = this.editor.clipScreenPosition([screenRow, 0], {skipSoftWrapIndentation: true})\r\n    const screenLineEnd = [screenRow, Infinity]\r\n    const screenLineBufferRange = this.editor.bufferRangeForScreenRange([screenLineStart, screenLineEnd])\r\n\r\n    let firstCharacterColumn = null\r\n    this.editor.scanInBufferRange(/\\S/, screenLineBufferRange, ({range, stop}) => {\r\n      firstCharacterColumn = range.start.column\r\n      stop()\r\n    })\r\n\r\n    if (firstCharacterColumn != null && firstCharacterColumn !== this.getBufferColumn()) {\r\n      targetBufferColumn = firstCharacterColumn\r\n    } else {\r\n      targetBufferColumn = screenLineBufferRange.start.column\r\n    }\r\n\r\n    this.setBufferPosition([screenLineBufferRange.start.row, targetBufferColumn])\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferColumn","start_line":111,"end_line":113,"comment":[" Public: Returns the cursor's current buffer column."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"setBufferPosition","line":372,"func_location":"Cursor.moveToFirstCharacterOfLine","func_start_line":353,"func_end_line":373,"args":[null],"comment":[" Public: Moves the cursor to the beginning of the first character in the"," line."],"code":"  moveToFirstCharacterOfLine () {\r\n    let targetBufferColumn\r\n    const screenRow = this.getScreenRow()\r\n    const screenLineStart = this.editor.clipScreenPosition([screenRow, 0], {skipSoftWrapIndentation: true})\r\n    const screenLineEnd = [screenRow, Infinity]\r\n    const screenLineBufferRange = this.editor.bufferRangeForScreenRange([screenLineStart, screenLineEnd])\r\n\r\n    let firstCharacterColumn = null\r\n    this.editor.scanInBufferRange(/\\S/, screenLineBufferRange, ({range, stop}) => {\r\n      firstCharacterColumn = range.start.column\r\n      stop()\r\n    })\r\n\r\n    if (firstCharacterColumn != null && firstCharacterColumn !== this.getBufferColumn()) {\r\n      targetBufferColumn = firstCharacterColumn\r\n    } else {\r\n      targetBufferColumn = screenLineBufferRange.start.column\r\n    }\r\n\r\n    this.setBufferPosition([screenLineBufferRange.start.row, targetBufferColumn])\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.setBufferPosition","start_line":84,"end_line":88,"comment":[" Public: Moves a cursor to a given buffer position.",""," * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column."," * `options` (optional) {Object} with the following keys:","   * `autoscroll` {Boolean} indicating whether to autoscroll to the new","     position. Defaults to `true` if this is the most recently added cursor,","     `false` otherwise."],"params":["bufferPosition","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"subwordRegExp","line":423,"func_location":"Cursor.moveToNextSubwordBoundary","func_start_line":422,"func_end_line":426,"args":[],"comment":[" Public: Moves the cursor to the next subword boundary."],"code":"  moveToNextSubwordBoundary () {\r\n    const options = {wordRegex: this.subwordRegExp()}\r\n    const position = this.getNextWordBoundaryBufferPosition(options)\r\n    if (position) this.setBufferPosition(position)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.subwordRegExp","start_line":690,"end_line":710,"comment":[" Public: Get the RegExp used by the cursor to determine what a \"subword\" is.",""," * `options` (optional) {Object} with the following keys:","   * `backwards` A {Boolean} indicating whether to look forwards or backwards","     for the next subword. (default: false)",""," Returns a {RegExp}."],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getNextWordBoundaryBufferPosition","line":424,"func_location":"Cursor.moveToNextSubwordBoundary","func_start_line":422,"func_end_line":426,"args":["options"],"comment":[" Public: Moves the cursor to the next subword boundary."],"code":"  moveToNextSubwordBoundary () {\r\n    const options = {wordRegex: this.subwordRegExp()}\r\n    const position = this.getNextWordBoundaryBufferPosition(options)\r\n    if (position) this.setBufferPosition(position)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getNextWordBoundaryBufferPosition","start_line":493,"end_line":513,"comment":[" Public: Returns buffer position of the next word boundary. It might be on"," the current word, or the previous word.",""," * `options` (optional) {Object} with the following keys:","   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"","      (default: {::wordRegExp})"],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"setBufferPosition","line":425,"func_location":"Cursor.moveToNextSubwordBoundary","func_start_line":422,"func_end_line":426,"args":["position"],"comment":[" Public: Moves the cursor to the next subword boundary."],"code":"  moveToNextSubwordBoundary () {\r\n    const options = {wordRegex: this.subwordRegExp()}\r\n    const position = this.getNextWordBoundaryBufferPosition(options)\r\n    if (position) this.setBufferPosition(position)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.setBufferPosition","start_line":84,"end_line":88,"comment":[" Public: Moves a cursor to a given buffer position.",""," * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column."," * `options` (optional) {Object} with the following keys:","   * `autoscroll` {Boolean} indicating whether to autoscroll to the new","     position. Defaults to `true` if this is the most recently added cursor,","     `false` otherwise."],"params":["bufferPosition","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getNextWordBoundaryBufferPosition","line":410,"func_location":"Cursor.moveToNextWordBoundary","func_start_line":409,"func_end_line":412,"args":[],"comment":[" Public: Moves the cursor to the next word boundary."],"code":"  moveToNextWordBoundary () {\r\n    const position = this.getNextWordBoundaryBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getNextWordBoundaryBufferPosition","start_line":493,"end_line":513,"comment":[" Public: Returns buffer position of the next word boundary. It might be on"," the current word, or the previous word.",""," * `options` (optional) {Object} with the following keys:","   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"","      (default: {::wordRegExp})"],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"setBufferPosition","line":411,"func_location":"Cursor.moveToNextWordBoundary","func_start_line":409,"func_end_line":412,"args":["position"],"comment":[" Public: Moves the cursor to the next word boundary."],"code":"  moveToNextWordBoundary () {\r\n    const position = this.getNextWordBoundaryBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.setBufferPosition","start_line":84,"end_line":88,"comment":[" Public: Moves a cursor to a given buffer position.",""," * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column."," * `options` (optional) {Object} with the following keys:","   * `autoscroll` {Boolean} indicating whether to autoscroll to the new","     position. Defaults to `true` if this is the most recently added cursor,","     `false` otherwise."],"params":["bufferPosition","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"subwordRegExp","line":416,"func_location":"Cursor.moveToPreviousSubwordBoundary","func_start_line":415,"func_end_line":419,"args":[null],"comment":[" Public: Moves the cursor to the previous subword boundary."],"code":"  moveToPreviousSubwordBoundary () {\r\n    const options = {wordRegex: this.subwordRegExp({backwards: true})}\r\n    const position = this.getPreviousWordBoundaryBufferPosition(options)\r\n    if (position) this.setBufferPosition(position)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.subwordRegExp","start_line":690,"end_line":710,"comment":[" Public: Get the RegExp used by the cursor to determine what a \"subword\" is.",""," * `options` (optional) {Object} with the following keys:","   * `backwards` A {Boolean} indicating whether to look forwards or backwards","     for the next subword. (default: false)",""," Returns a {RegExp}."],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getPreviousWordBoundaryBufferPosition","line":417,"func_location":"Cursor.moveToPreviousSubwordBoundary","func_start_line":415,"func_end_line":419,"args":["options"],"comment":[" Public: Moves the cursor to the previous subword boundary."],"code":"  moveToPreviousSubwordBoundary () {\r\n    const options = {wordRegex: this.subwordRegExp({backwards: true})}\r\n    const position = this.getPreviousWordBoundaryBufferPosition(options)\r\n    if (position) this.setBufferPosition(position)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getPreviousWordBoundaryBufferPosition","start_line":463,"end_line":485,"comment":["\r\n  Section: Local Positions and Ranges\r\n  "," Public: Returns buffer position of previous word boundary. It might be on"," the current word, or the previous word.",""," * `options` (optional) {Object} with the following keys:","   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"","      (default: {::wordRegExp})"],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"setBufferPosition","line":418,"func_location":"Cursor.moveToPreviousSubwordBoundary","func_start_line":415,"func_end_line":419,"args":["position"],"comment":[" Public: Moves the cursor to the previous subword boundary."],"code":"  moveToPreviousSubwordBoundary () {\r\n    const options = {wordRegex: this.subwordRegExp({backwards: true})}\r\n    const position = this.getPreviousWordBoundaryBufferPosition(options)\r\n    if (position) this.setBufferPosition(position)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.setBufferPosition","start_line":84,"end_line":88,"comment":[" Public: Moves a cursor to a given buffer position.",""," * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column."," * `options` (optional) {Object} with the following keys:","   * `autoscroll` {Boolean} indicating whether to autoscroll to the new","     position. Defaults to `true` if this is the most recently added cursor,","     `false` otherwise."],"params":["bufferPosition","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getPreviousWordBoundaryBufferPosition","line":404,"func_location":"Cursor.moveToPreviousWordBoundary","func_start_line":403,"func_end_line":406,"args":[],"comment":[" Public: Moves the cursor to the previous word boundary."],"code":"  moveToPreviousWordBoundary () {\r\n    const position = this.getPreviousWordBoundaryBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getPreviousWordBoundaryBufferPosition","start_line":463,"end_line":485,"comment":["\r\n  Section: Local Positions and Ranges\r\n  "," Public: Returns buffer position of previous word boundary. It might be on"," the current word, or the previous word.",""," * `options` (optional) {Object} with the following keys:","   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"","      (default: {::wordRegExp})"],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"setBufferPosition","line":405,"func_location":"Cursor.moveToPreviousWordBoundary","func_start_line":403,"func_end_line":406,"args":["position"],"comment":[" Public: Moves the cursor to the previous word boundary."],"code":"  moveToPreviousWordBoundary () {\r\n    const position = this.getPreviousWordBoundaryBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.setBufferPosition","start_line":84,"end_line":88,"comment":[" Public: Moves a cursor to a given buffer position.",""," * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column."," * `options` (optional) {Object} with the following keys:","   * `autoscroll` {Boolean} indicating whether to autoscroll to the new","     position. Defaults to `true` if this is the most recently added cursor,","     `false` otherwise."],"params":["bufferPosition","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"isAtTagBoundary","line":804,"func_location":"TextMateHighlightIterator.moveToSuccessor","func_start_line":799,"func_end_line":836,"args":[],"code":"  moveToSuccessor () {\r\n    this.openScopeIds = []\r\n    this.closeScopeIds = []\r\n    while (true) {\r\n      if (this.tagIndex === this.currentLineTags.length) {\r\n        if (this.isAtTagBoundary()) {\r\n          break\r\n        } else if (!this.moveToNextLine()) {\r\n          return false\r\n        }\r\n      } else {\r\n        const tag = this.currentLineTags[this.tagIndex]\r\n        if (tag >= 0) {\r\n          if (this.isAtTagBoundary()) {\r\n            break\r\n          } else {\r\n            this.position = Point(this.position.row, Math.min(\r\n              this.currentLineLength,\r\n              this.position.column + this.currentLineTags[this.tagIndex]\r\n            ))\r\n          }\r\n        } else {\r\n          const scopeId = fromFirstMateScopeId(tag)\r\n          if ((tag & 1) === 0) {\r\n            if (this.openScopeIds.length > 0) {\r\n              break\r\n            } else {\r\n              this.closeScopeIds.push(scopeId)\r\n            }\r\n          } else {\r\n            this.openScopeIds.push(scopeId)\r\n          }\r\n        }\r\n        this.tagIndex++\r\n      }\r\n    }\r\n    return true\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateHighlightIterator.isAtTagBoundary","start_line":863,"end_line":865,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"moveToNextLine","line":806,"func_location":"TextMateHighlightIterator.moveToSuccessor","func_start_line":799,"func_end_line":836,"args":[],"code":"  moveToSuccessor () {\r\n    this.openScopeIds = []\r\n    this.closeScopeIds = []\r\n    while (true) {\r\n      if (this.tagIndex === this.currentLineTags.length) {\r\n        if (this.isAtTagBoundary()) {\r\n          break\r\n        } else if (!this.moveToNextLine()) {\r\n          return false\r\n        }\r\n      } else {\r\n        const tag = this.currentLineTags[this.tagIndex]\r\n        if (tag >= 0) {\r\n          if (this.isAtTagBoundary()) {\r\n            break\r\n          } else {\r\n            this.position = Point(this.position.row, Math.min(\r\n              this.currentLineLength,\r\n              this.position.column + this.currentLineTags[this.tagIndex]\r\n            ))\r\n          }\r\n        } else {\r\n          const scopeId = fromFirstMateScopeId(tag)\r\n          if ((tag & 1) === 0) {\r\n            if (this.openScopeIds.length > 0) {\r\n              break\r\n            } else {\r\n              this.closeScopeIds.push(scopeId)\r\n            }\r\n          } else {\r\n            this.openScopeIds.push(scopeId)\r\n          }\r\n        }\r\n        this.tagIndex++\r\n      }\r\n    }\r\n    return true\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateHighlightIterator.moveToNextLine","start_line":850,"end_line":861,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"isAtTagBoundary","line":812,"func_location":"TextMateHighlightIterator.moveToSuccessor","func_start_line":799,"func_end_line":836,"args":[],"code":"  moveToSuccessor () {\r\n    this.openScopeIds = []\r\n    this.closeScopeIds = []\r\n    while (true) {\r\n      if (this.tagIndex === this.currentLineTags.length) {\r\n        if (this.isAtTagBoundary()) {\r\n          break\r\n        } else if (!this.moveToNextLine()) {\r\n          return false\r\n        }\r\n      } else {\r\n        const tag = this.currentLineTags[this.tagIndex]\r\n        if (tag >= 0) {\r\n          if (this.isAtTagBoundary()) {\r\n            break\r\n          } else {\r\n            this.position = Point(this.position.row, Math.min(\r\n              this.currentLineLength,\r\n              this.position.column + this.currentLineTags[this.tagIndex]\r\n            ))\r\n          }\r\n        } else {\r\n          const scopeId = fromFirstMateScopeId(tag)\r\n          if ((tag & 1) === 0) {\r\n            if (this.openScopeIds.length > 0) {\r\n              break\r\n            } else {\r\n              this.closeScopeIds.push(scopeId)\r\n            }\r\n          } else {\r\n            this.openScopeIds.push(scopeId)\r\n          }\r\n        }\r\n        this.tagIndex++\r\n      }\r\n    }\r\n    return true\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateHighlightIterator.isAtTagBoundary","start_line":863,"end_line":865,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"_moveRight","line":948,"func_location":"LayerHighlightIterator.moveToSuccessor","func_start_line":942,"func_end_line":965,"args":[],"code":"  moveToSuccessor () {\r\n    this.closeTags.length = 0\r\n    this.openTags.length = 0\r\n\r\n    while (!this.done && !this.closeTags.length && !this.openTags.length) {\r\n      if (this.atEnd) {\r\n        if (this._moveRight()) {\r\n          const scopeId = this._currentScopeId()\r\n          if (scopeId) this.openTags.push(scopeId)\r\n          this.atEnd = false\r\n          this._moveDown()\r\n        } else if (this._moveUp(true)) {\r\n          this.atEnd = true\r\n        } else {\r\n          this.done = true\r\n        }\r\n      } else if (!this._moveDown()) {\r\n        const scopeId = this._currentScopeId()\r\n        if (scopeId) this.closeTags.push(scopeId)\r\n        this.atEnd = true\r\n        this._moveUp(false)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"LayerHighlightIterator._moveRight","start_line":1042,"end_line":1050,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"_currentScopeId","line":949,"func_location":"LayerHighlightIterator.moveToSuccessor","func_start_line":942,"func_end_line":965,"args":[],"code":"  moveToSuccessor () {\r\n    this.closeTags.length = 0\r\n    this.openTags.length = 0\r\n\r\n    while (!this.done && !this.closeTags.length && !this.openTags.length) {\r\n      if (this.atEnd) {\r\n        if (this._moveRight()) {\r\n          const scopeId = this._currentScopeId()\r\n          if (scopeId) this.openTags.push(scopeId)\r\n          this.atEnd = false\r\n          this._moveDown()\r\n        } else if (this._moveUp(true)) {\r\n          this.atEnd = true\r\n        } else {\r\n          this.done = true\r\n        }\r\n      } else if (!this._moveDown()) {\r\n        const scopeId = this._currentScopeId()\r\n        if (scopeId) this.closeTags.push(scopeId)\r\n        this.atEnd = true\r\n        this._moveUp(false)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"LayerHighlightIterator._currentScopeId","start_line":1052,"end_line":1062,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"_moveDown","line":952,"func_location":"LayerHighlightIterator.moveToSuccessor","func_start_line":942,"func_end_line":965,"args":[],"code":"  moveToSuccessor () {\r\n    this.closeTags.length = 0\r\n    this.openTags.length = 0\r\n\r\n    while (!this.done && !this.closeTags.length && !this.openTags.length) {\r\n      if (this.atEnd) {\r\n        if (this._moveRight()) {\r\n          const scopeId = this._currentScopeId()\r\n          if (scopeId) this.openTags.push(scopeId)\r\n          this.atEnd = false\r\n          this._moveDown()\r\n        } else if (this._moveUp(true)) {\r\n          this.atEnd = true\r\n        } else {\r\n          this.done = true\r\n        }\r\n      } else if (!this._moveDown()) {\r\n        const scopeId = this._currentScopeId()\r\n        if (scopeId) this.closeTags.push(scopeId)\r\n        this.atEnd = true\r\n        this._moveUp(false)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"LayerHighlightIterator._moveDown","start_line":1016,"end_line":1040,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"_moveUp","line":953,"func_location":"LayerHighlightIterator.moveToSuccessor","func_start_line":942,"func_end_line":965,"args":[{"type":"boolean"}],"code":"  moveToSuccessor () {\r\n    this.closeTags.length = 0\r\n    this.openTags.length = 0\r\n\r\n    while (!this.done && !this.closeTags.length && !this.openTags.length) {\r\n      if (this.atEnd) {\r\n        if (this._moveRight()) {\r\n          const scopeId = this._currentScopeId()\r\n          if (scopeId) this.openTags.push(scopeId)\r\n          this.atEnd = false\r\n          this._moveDown()\r\n        } else if (this._moveUp(true)) {\r\n          this.atEnd = true\r\n        } else {\r\n          this.done = true\r\n        }\r\n      } else if (!this._moveDown()) {\r\n        const scopeId = this._currentScopeId()\r\n        if (scopeId) this.closeTags.push(scopeId)\r\n        this.atEnd = true\r\n        this._moveUp(false)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"LayerHighlightIterator._moveUp","start_line":996,"end_line":1014,"comment":[" Private methods"],"params":["atLastChild"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"_moveDown","line":958,"func_location":"LayerHighlightIterator.moveToSuccessor","func_start_line":942,"func_end_line":965,"args":[],"code":"  moveToSuccessor () {\r\n    this.closeTags.length = 0\r\n    this.openTags.length = 0\r\n\r\n    while (!this.done && !this.closeTags.length && !this.openTags.length) {\r\n      if (this.atEnd) {\r\n        if (this._moveRight()) {\r\n          const scopeId = this._currentScopeId()\r\n          if (scopeId) this.openTags.push(scopeId)\r\n          this.atEnd = false\r\n          this._moveDown()\r\n        } else if (this._moveUp(true)) {\r\n          this.atEnd = true\r\n        } else {\r\n          this.done = true\r\n        }\r\n      } else if (!this._moveDown()) {\r\n        const scopeId = this._currentScopeId()\r\n        if (scopeId) this.closeTags.push(scopeId)\r\n        this.atEnd = true\r\n        this._moveUp(false)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"LayerHighlightIterator._moveDown","start_line":1016,"end_line":1040,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"_currentScopeId","line":959,"func_location":"LayerHighlightIterator.moveToSuccessor","func_start_line":942,"func_end_line":965,"args":[],"code":"  moveToSuccessor () {\r\n    this.closeTags.length = 0\r\n    this.openTags.length = 0\r\n\r\n    while (!this.done && !this.closeTags.length && !this.openTags.length) {\r\n      if (this.atEnd) {\r\n        if (this._moveRight()) {\r\n          const scopeId = this._currentScopeId()\r\n          if (scopeId) this.openTags.push(scopeId)\r\n          this.atEnd = false\r\n          this._moveDown()\r\n        } else if (this._moveUp(true)) {\r\n          this.atEnd = true\r\n        } else {\r\n          this.done = true\r\n        }\r\n      } else if (!this._moveDown()) {\r\n        const scopeId = this._currentScopeId()\r\n        if (scopeId) this.closeTags.push(scopeId)\r\n        this.atEnd = true\r\n        this._moveUp(false)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"LayerHighlightIterator._currentScopeId","start_line":1052,"end_line":1062,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"_moveUp","line":962,"func_location":"LayerHighlightIterator.moveToSuccessor","func_start_line":942,"func_end_line":965,"args":[{"type":"boolean"}],"code":"  moveToSuccessor () {\r\n    this.closeTags.length = 0\r\n    this.openTags.length = 0\r\n\r\n    while (!this.done && !this.closeTags.length && !this.openTags.length) {\r\n      if (this.atEnd) {\r\n        if (this._moveRight()) {\r\n          const scopeId = this._currentScopeId()\r\n          if (scopeId) this.openTags.push(scopeId)\r\n          this.atEnd = false\r\n          this._moveDown()\r\n        } else if (this._moveUp(true)) {\r\n          this.atEnd = true\r\n        } else {\r\n          this.done = true\r\n        }\r\n      } else if (!this._moveDown()) {\r\n        const scopeId = this._currentScopeId()\r\n        if (scopeId) this.closeTags.push(scopeId)\r\n        this.atEnd = true\r\n        this._moveUp(false)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"LayerHighlightIterator._moveUp","start_line":996,"end_line":1014,"comment":[" Private methods"],"params":["atLastChild"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"setBufferPosition","line":331,"func_location":"Cursor.moveToTop","func_start_line":330,"func_end_line":332,"args":[null],"comment":[" Public: Moves the cursor to the top of the buffer."],"code":"  moveToTop () {\r\n    this.setBufferPosition([0, 0])\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.setBufferPosition","start_line":84,"end_line":88,"comment":[" Public: Moves a cursor to a given buffer position.",""," * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column."," * `options` (optional) {Object} with the following keys:","   * `autoscroll` {Boolean} indicating whether to autoscroll to the new","     position. Defaults to `true` if this is the most recently added cursor,","     `false` otherwise."],"params":["bufferPosition","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getScreenPosition","line":247,"func_location":"Cursor.moveUp","func_start_line":241,"func_end_line":253,"args":[],"comment":["\r\n  Section: Moving the Cursor\r\n  "," Public: Moves the cursor up one screen row.",""," * `rowCount` (optional) {Number} number of rows to move (default: 1)"," * `options` (optional) {Object} with the following keys:","   * `moveToEndOfSelection` if true, move to the left of the selection if a","     selection exists."],"code":"  moveUp (rowCount = 1, {moveToEndOfSelection} = {}) {\r\n    let row, column\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      ({row, column} = range.start)\r\n    } else {\r\n      ({row, column} = this.getScreenPosition())\r\n    }\r\n\r\n    if (this.goalColumn != null) column = this.goalColumn\r\n    this.setScreenPosition({row: row - rowCount, column}, {skipSoftWrapIndentation: true})\r\n    this.goalColumn = column\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getScreenPosition","start_line":73,"end_line":75,"comment":[" Public: Returns the screen position of the cursor as a {Point}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"setScreenPosition","line":251,"func_location":"Cursor.moveUp","func_start_line":241,"func_end_line":253,"args":[null,null],"comment":["\r\n  Section: Moving the Cursor\r\n  "," Public: Moves the cursor up one screen row.",""," * `rowCount` (optional) {Number} number of rows to move (default: 1)"," * `options` (optional) {Object} with the following keys:","   * `moveToEndOfSelection` if true, move to the left of the selection if a","     selection exists."],"code":"  moveUp (rowCount = 1, {moveToEndOfSelection} = {}) {\r\n    let row, column\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      ({row, column} = range.start)\r\n    } else {\r\n      ({row, column} = this.getScreenPosition())\r\n    }\r\n\r\n    if (this.goalColumn != null) column = this.goalColumn\r\n    this.setScreenPosition({row: row - rowCount, column}, {skipSoftWrapIndentation: true})\r\n    this.goalColumn = column\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.setScreenPosition","start_line":66,"end_line":70,"comment":["\r\n  Section: Managing Cursor Position\r\n  "," Public: Moves a cursor to a given screen position.",""," * `screenPosition` {Array} of two numbers: the screen row, and the screen column."," * `options` (optional) {Object} with the following keys:","   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever","     the cursor moves to."],"params":["screenPosition","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"boundingBoxForPaneView","line":276,"func_location":"WorkspaceElement.nearestVisiblePaneInDirection","func_start_line":268,"func_end_line":300,"args":["paneView"],"code":"  nearestVisiblePaneInDirection (direction, pane) {\r\n    const distance = function (pointA, pointB) {\r\n      const x = pointB.x - pointA.x\r\n      const y = pointB.y - pointA.y\r\n      return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))\r\n    }\r\n\r\n    const paneView = pane.getElement()\r\n    const box = this.boundingBoxForPaneView(paneView)\r\n\r\n    const paneViews = atom.workspace.getVisiblePanes()\r\n      .map(otherPane => otherPane.getElement())\r\n      .filter(otherPaneView => {\r\n        const otherBox = this.boundingBoxForPaneView(otherPaneView)\r\n        switch (direction) {\r\n          case 'left': return otherBox.right.x <= box.left.x\r\n          case 'right': return otherBox.left.x >= box.right.x\r\n          case 'above': return otherBox.bottom.y <= box.top.y\r\n          case 'below': return otherBox.top.y >= box.bottom.y\r\n        }\r\n      }).sort((paneViewA, paneViewB) => {\r\n        const boxA = this.boundingBoxForPaneView(paneViewA)\r\n        const boxB = this.boundingBoxForPaneView(paneViewB)\r\n        switch (direction) {\r\n          case 'left': return distance(box.left, boxA.right) - distance(box.left, boxB.right)\r\n          case 'right': return distance(box.right, boxA.left) - distance(box.right, boxB.left)\r\n          case 'above': return distance(box.top, boxA.bottom) - distance(box.top, boxB.bottom)\r\n          case 'below': return distance(box.bottom, boxA.top) - distance(box.bottom, boxB.top)\r\n        }\r\n      })\r\n\r\n    return paneViews[0]\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.boundingBoxForPaneView","start_line":302,"end_line":311,"comment":[],"params":["paneView"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js","name":"matcherForSpec","line":151,"func_location":"normalizeFoldSpecification","func_start_line":146,"func_end_line":157,"args":["spec.type"],"code":"function normalizeFoldSpecification (spec) {\r\n  if (spec.type) {\r\n    if (Array.isArray(spec.type)) {\r\n      spec.matchers = spec.type.map(matcherForSpec)\r\n    } else {\r\n      spec.matchers = [matcherForSpec(spec.type)]\r\n    }\r\n  }\r\n\r\n  if (spec.start) normalizeFoldSpecification(spec.start)\r\n  if (spec.end) normalizeFoldSpecification(spec.end)\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js","name":"matcherForSpec","start_line":128,"end_line":144,"comment":[],"params":["spec"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js","name":"normalizeFoldSpecification","line":155,"func_location":"normalizeFoldSpecification","func_start_line":146,"func_end_line":157,"args":["spec.start"],"code":"function normalizeFoldSpecification (spec) {\r\n  if (spec.type) {\r\n    if (Array.isArray(spec.type)) {\r\n      spec.matchers = spec.type.map(matcherForSpec)\r\n    } else {\r\n      spec.matchers = [matcherForSpec(spec.type)]\r\n    }\r\n  }\r\n\r\n  if (spec.start) normalizeFoldSpecification(spec.start)\r\n  if (spec.end) normalizeFoldSpecification(spec.end)\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js","name":"normalizeFoldSpecification","start_line":146,"end_line":157,"comment":[],"params":["spec"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js","name":"normalizeFoldSpecification","line":156,"func_location":"normalizeFoldSpecification","func_start_line":146,"func_end_line":157,"args":["spec.end"],"code":"function normalizeFoldSpecification (spec) {\r\n  if (spec.type) {\r\n    if (Array.isArray(spec.type)) {\r\n      spec.matchers = spec.type.map(matcherForSpec)\r\n    } else {\r\n      spec.matchers = [matcherForSpec(spec.type)]\r\n    }\r\n  }\r\n\r\n  if (spec.start) normalizeFoldSpecification(spec.start)\r\n  if (spec.end) normalizeFoldSpecification(spec.end)\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js","name":"normalizeFoldSpecification","start_line":146,"end_line":157,"comment":[],"params":["spec"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"observeScopedKeyPath","line":483,"func_location":"Config.observe","func_start_line":470,"func_end_line":487,"args":["scopeDescriptor","keyPath","callback"],"comment":["\r\n  Section: Config Subscription\r\n  "," Essential: Add a listener for changes to a given key path. This is different"," than {::onDidChange} in that it will immediately call your callback with the"," current value of the config entry.",""," ### Examples",""," You might want to be notified when the themes change. We'll watch"," `core.themes` for changes",""," ```coffee"," atom.config.observe 'core.themes', (value) ->","   # do stuff with value"," ```",""," * `keyPath` {String} name of the key to observe"," * `options` (optional) {Object}","   * `scope` (optional) {ScopeDescriptor} describing a path from","     the root of the syntax tree to a token. Get one by calling","     {editor.getLastCursor().getScopeDescriptor()}. See {::get} for examples.","     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)","     for more information."," * `callback` {Function} to call when the value of the key changes.","   * `value` the new value of the key",""," Returns a {Disposable} with the following keys on which you can call"," `.dispose()` to unsubscribe."],"code":"  observe (...args) {\r\n    let callback, keyPath, options, scopeDescriptor\r\n    if (args.length === 2) {\r\n      [keyPath, callback] = args\r\n    } else if ((args.length === 3) && (_.isString(args[0]) && _.isObject(args[1]))) {\r\n      [keyPath, options, callback] = args\r\n      scopeDescriptor = options.scope\r\n    } else {\r\n      console.error('An unsupported form of Config::observe is being used. See https://atom.io/docs/api/latest/Config for details')\r\n      return\r\n    }\r\n\r\n    if (scopeDescriptor != null) {\r\n      return this.observeScopedKeyPath(scopeDescriptor, keyPath, callback)\r\n    } else {\r\n      return this.observeKeyPath(keyPath, options != null ? options : {}, callback)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.observeScopedKeyPath","start_line":1264,"end_line":1267,"comment":[],"params":["scope","keyPath","callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"observeKeyPath","line":485,"func_location":"Config.observe","func_start_line":470,"func_end_line":487,"args":["keyPath",null,"callback"],"comment":["\r\n  Section: Config Subscription\r\n  "," Essential: Add a listener for changes to a given key path. This is different"," than {::onDidChange} in that it will immediately call your callback with the"," current value of the config entry.",""," ### Examples",""," You might want to be notified when the themes change. We'll watch"," `core.themes` for changes",""," ```coffee"," atom.config.observe 'core.themes', (value) ->","   # do stuff with value"," ```",""," * `keyPath` {String} name of the key to observe"," * `options` (optional) {Object}","   * `scope` (optional) {ScopeDescriptor} describing a path from","     the root of the syntax tree to a token. Get one by calling","     {editor.getLastCursor().getScopeDescriptor()}. See {::get} for examples.","     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)","     for more information."," * `callback` {Function} to call when the value of the key changes.","   * `value` the new value of the key",""," Returns a {Disposable} with the following keys on which you can call"," `.dispose()` to unsubscribe."],"code":"  observe (...args) {\r\n    let callback, keyPath, options, scopeDescriptor\r\n    if (args.length === 2) {\r\n      [keyPath, callback] = args\r\n    } else if ((args.length === 3) && (_.isString(args[0]) && _.isObject(args[1]))) {\r\n      [keyPath, options, callback] = args\r\n      scopeDescriptor = options.scope\r\n    } else {\r\n      console.error('An unsupported form of Config::observe is being used. See https://atom.io/docs/api/latest/Config for details')\r\n      return\r\n    }\r\n\r\n    if (scopeDescriptor != null) {\r\n      return this.observeScopedKeyPath(scopeDescriptor, keyPath, callback)\r\n    } else {\r\n      return this.observeKeyPath(keyPath, options != null ? options : {}, callback)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.observeKeyPath","start_line":1041,"end_line":1044,"comment":[],"params":["keyPath","options","callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"isActive","line":256,"func_location":"Pane.observeActive","func_start_line":255,"func_end_line":258,"args":[null],"comment":[" Public: Invoke the given callback with the current and future values of the"," {::isActive} property.",""," * `callback` {Function} to be called with the current and future values of","   the {::isActive} property.","   * `active` {Boolean} indicating whether the pane is active.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  observeActive (callback) {\r\n    callback(this.isActive())\r\n    return this.onDidChangeActive(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.isActive","start_line":1007,"end_line":1009,"comment":["\r\n  Section: Lifecycle\r\n  "," Public: Determine whether the pane is active.",""," Returns a {Boolean}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"onDidChangeActive","line":257,"func_location":"Pane.observeActive","func_start_line":255,"func_end_line":258,"args":["callback"],"comment":[" Public: Invoke the given callback with the current and future values of the"," {::isActive} property.",""," * `callback` {Function} to be called with the current and future values of","   the {::isActive} property.","   * `active` {Boolean} indicating whether the pane is active.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  observeActive (callback) {\r\n    callback(this.isActive())\r\n    return this.onDidChangeActive(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.onDidChangeActive","start_line":240,"end_line":245,"comment":[" Public: Invoke the given callback when the value of the {::isActive}"," property changes.",""," * `callback` {Function} to be called when the value of the {::isActive}","   property changes.","   * `active` {Boolean} indicating whether the pane is active.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getActiveItem","line":377,"func_location":"Pane.observeActiveItem","func_start_line":376,"func_end_line":379,"args":[null],"comment":[" Public: Invoke the given callback with the current and future values of"," {::getActiveItem}.",""," * `callback` {Function} to be called with the current and future active","   items.","   * `activeItem` The current active item.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  observeActiveItem (callback) {\r\n    callback(this.getActiveItem())\r\n    return this.onDidChangeActiveItem(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getActiveItem","start_line":432,"end_line":432,"comment":[" Public: Get the active pane item in this pane.",""," Returns a pane item."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"onDidChangeActiveItem","line":378,"func_location":"Pane.observeActiveItem","func_start_line":376,"func_end_line":379,"args":["callback"],"comment":[" Public: Invoke the given callback with the current and future values of"," {::getActiveItem}.",""," * `callback` {Function} to be called with the current and future active","   items.","   * `activeItem` The current active item.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  observeActiveItem (callback) {\r\n    callback(this.getActiveItem())\r\n    return this.onDidChangeActiveItem(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.onDidChangeActiveItem","start_line":328,"end_line":330,"comment":[" Public: Invoke the given callback when the value of {::getActiveItem}"," changes.",""," * `callback` {Function} to be called with when the active item changes.","   * `activeItem` The current active item.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"getActivePane","line":95,"func_location":"PaneContainer.observeActivePane","func_start_line":94,"func_end_line":97,"args":[null],"code":"  observeActivePane (fn) {\r\n    fn(this.getActivePane())\r\n    return this.onDidChangeActivePane(fn)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.getActivePane","start_line":158,"end_line":160,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"onDidChangeActivePane","line":96,"func_location":"PaneContainer.observeActivePane","func_start_line":94,"func_end_line":97,"args":["fn"],"code":"  observeActivePane (fn) {\r\n    fn(this.getActivePane())\r\n    return this.onDidChangeActivePane(fn)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.onDidChangeActivePane","start_line":86,"end_line":88,"comment":[],"params":["fn"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getActivePane","line":813,"func_location":"Workspace.observeActivePane","func_start_line":812,"func_end_line":815,"args":[null],"comment":[" Extended: Invoke the given callback with the current active pane and when"," the active pane changes.",""," * `callback` {Function} to be called with the current and future active#","   panes.","   * `pane` A {Pane} that is the current return value of {::getActivePane}.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  observeActivePane (callback) {\r\n    callback(this.getActivePane())\r\n    return this.onDidChangeActivePane(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getActivePane","start_line":1442,"end_line":1444,"comment":[" Extended: Get the active {Pane}.",""," Returns a {Pane}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"onDidChangeActivePane","line":814,"func_location":"Workspace.observeActivePane","func_start_line":812,"func_end_line":815,"args":["callback"],"comment":[" Extended: Invoke the given callback with the current active pane and when"," the active pane changes.",""," * `callback` {Function} to be called with the current and future active#","   panes.","   * `pane` A {Pane} that is the current return value of {::getActivePane}.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  observeActivePane (callback) {\r\n    callback(this.getActivePane())\r\n    return this.onDidChangeActivePane(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.onDidChangeActivePane","start_line":800,"end_line":802,"comment":[" Extended: Invoke the given callback when the active pane changes.",""," * `callback` {Function} to be called when the active pane changes.","   * `pane` A {Pane} that is the current return value of {::getActivePane}.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"getActivePaneItem","line":117,"func_location":"PaneContainer.observeActivePaneItem","func_start_line":116,"func_end_line":119,"args":[null],"code":"  observeActivePaneItem (fn) {\r\n    fn(this.getActivePaneItem())\r\n    return this.onDidChangeActivePaneItem(fn)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.getActivePaneItem","start_line":162,"end_line":164,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"onDidChangeActivePaneItem","line":118,"func_location":"PaneContainer.observeActivePaneItem","func_start_line":116,"func_end_line":119,"args":["fn"],"code":"  observeActivePaneItem (fn) {\r\n    fn(this.getActivePaneItem())\r\n    return this.onDidChangeActivePaneItem(fn)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.onDidChangeActivePaneItem","start_line":108,"end_line":110,"comment":[],"params":["fn"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getActivePaneItem","line":704,"func_location":"Workspace.observeActivePaneItem","func_start_line":703,"func_end_line":706,"args":[null],"comment":[" Essential: Invoke the given callback with the current active pane item and"," with all future active pane items in the workspace.",""," * `callback` {Function} to be called when the active pane item changes.","   * `item` The current active pane item.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  observeActivePaneItem (callback) {\r\n    callback(this.getActivePaneItem())\r\n    return this.onDidChangeActivePaneItem(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getActivePaneItem","start_line":1357,"end_line":1359,"comment":[" Essential: Get the active {Pane}'s active item.",""," Returns an pane item {Object}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"onDidChangeActivePaneItem","line":705,"func_location":"Workspace.observeActivePaneItem","func_start_line":703,"func_end_line":706,"args":["callback"],"comment":[" Essential: Invoke the given callback with the current active pane item and"," with all future active pane items in the workspace.",""," * `callback` {Function} to be called when the active pane item changes.","   * `item` The current active pane item.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  observeActivePaneItem (callback) {\r\n    callback(this.getActivePaneItem())\r\n    return this.onDidChangeActivePaneItem(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.onDidChangeActivePaneItem","start_line":662,"end_line":664,"comment":[" Essential: Invoke the given callback when the active pane item changes.",""," Because observers are invoked synchronously, it's important not to perform"," any expensive operations via this method. Consider"," {::onDidStopChangingActivePaneItem} to delay operations until after changes"," stop occurring.",""," * `callback` {Function} to be called when the active pane item changes.","   * `item` The active pane item.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getActiveTextEditor","line":718,"func_location":"Workspace.observeActiveTextEditor","func_start_line":717,"func_end_line":721,"args":[null],"comment":[" Essential: Invoke the given callback with the current active text editor"," (if any), with all future active text editors, and when there is no longer"," an active text editor.",""," * `callback` {Function} to be called when the active text editor changes.","   * `editor` The active {TextEditor} or undefined if there is not an","      active text editor.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  observeActiveTextEditor (callback) {\r\n    callback(this.getActiveTextEditor())\r\n\r\n    return this.onDidChangeActiveTextEditor(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getActiveTextEditor","start_line":1372,"end_line":1375,"comment":[" Essential: Get the workspace center's active item if it is a {TextEditor}.",""," Returns a {TextEditor} or `undefined` if the workspace center's current"," active item is not a {TextEditor}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"onDidChangeActiveTextEditor","line":720,"func_location":"Workspace.observeActiveTextEditor","func_start_line":717,"func_end_line":721,"args":["callback"],"comment":[" Essential: Invoke the given callback with the current active text editor"," (if any), with all future active text editors, and when there is no longer"," an active text editor.",""," * `callback` {Function} to be called when the active text editor changes.","   * `editor` The active {TextEditor} or undefined if there is not an","      active text editor.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  observeActiveTextEditor (callback) {\r\n    callback(this.getActiveTextEditor())\r\n\r\n    return this.onDidChangeActiveTextEditor(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.onDidChangeActiveTextEditor","start_line":692,"end_line":694,"comment":[" Essential: Invoke the given callback when a text editor becomes the active"," text editor and when there is no longer an active text editor.",""," * `callback` {Function} to be called when the active text editor changes.","   * `editor` The active {TextEditor} or undefined if there is no longer an","      active text editor.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"setAutoHideMenuBar","line":332,"func_location":"AtomEnvironment.observeAutoHideMenuBar","func_start_line":328,"func_end_line":333,"args":[{"type":"string"}],"code":"  observeAutoHideMenuBar () {\r\n    this.disposables.add(this.config.onDidChange('core.autoHideMenuBar', ({newValue}) => {\r\n      this.setAutoHideMenuBar(newValue)\r\n    }))\r\n    if (this.config.get('core.autoHideMenuBar')) this.setAutoHideMenuBar(true)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.setAutoHideMenuBar","start_line":1330,"end_line":1333,"comment":[],"params":["autoHide"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"addBlockDecoration","line":2504,"func_location":"TextEditorComponent.observeBlockDecorations","func_start_line":2500,"func_end_line":2506,"args":["decorations.i"],"code":"  observeBlockDecorations () {\r\n    const {model} = this.props\r\n    const decorations = model.getDecorations({type: 'block'})\r\n    for (let i = 0; i < decorations.length; i++) {\r\n      this.addBlockDecoration(decorations[i])\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.addBlockDecoration","start_line":2508,"end_line":2560,"comment":[],"params":["decoration","subscribeToChanges"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"getBuffers","line":191,"func_location":"Project.observeBuffers","func_start_line":190,"func_end_line":193,"args":[],"comment":[" Public: Invoke the given callback with all current and future text"," buffers in the project.",""," * `callback` {Function} to be called with current and future text buffers.","   * `buffer` A {TextBuffer} item.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  observeBuffers (callback) {\r\n    for (let buffer of this.getBuffers()) { callback(buffer) }\r\n    return this.onDidAddBuffer(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.getBuffers","start_line":621,"end_line":623,"comment":[" Retrieves all the {TextBuffer}s in the project; that is, the"," buffers for all open files.",""," Returns an {Array} of {TextBuffer}s."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"onDidAddBuffer","line":192,"func_location":"Project.observeBuffers","func_start_line":190,"func_end_line":193,"args":["callback"],"comment":[" Public: Invoke the given callback with all current and future text"," buffers in the project.",""," * `callback` {Function} to be called with current and future text buffers.","   * `buffer` A {TextBuffer} item.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  observeBuffers (callback) {\r\n    for (let buffer of this.getBuffers()) { callback(buffer) }\r\n    return this.onDidAddBuffer(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.onDidAddBuffer","start_line":179,"end_line":181,"comment":[" Public: Invoke the given callback when a text buffer is added to the"," project.",""," * `callback` {Function} to be called when a text buffer is added.","   * `buffer` A {TextBuffer} item.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"onDidAddCursor","line":836,"func_location":"TextEditor.observeCursors","func_start_line":834,"func_end_line":837,"args":["callback"],"comment":[" Extended: Calls your `callback` when a {Cursor} is added to the editor."," Immediately calls your callback for each existing cursor.",""," * `callback` {Function}","   * `cursor` {Cursor} that was added",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  observeCursors (callback) {\r\n    this.getCursors().forEach(callback)\r\n    return this.onDidAddCursor(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.onDidAddCursor","start_line":845,"end_line":847,"comment":[" Extended: Calls your `callback` when a {Cursor} is added to the editor.",""," * `callback` {Function}","   * `cursor` {Cursor} that was added",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js","name":"getDecorations","line":21,"func_location":"DecorationManager.observeDecorations","func_start_line":20,"func_end_line":26,"args":[],"code":"  observeDecorations (callback) {\r\n    const decorations = this.getDecorations()\r\n    for (let i = 0; i < decorations.length; i++) {\r\n      callback(decorations[i])\r\n    }\r\n    return this.onDidAddDecoration(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js","name":"DecorationManager.getDecorations","start_line":40,"end_line":56,"comment":[],"params":["propertyFilter"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js","name":"onDidAddDecoration","line":25,"func_location":"DecorationManager.observeDecorations","func_start_line":20,"func_end_line":26,"args":["callback"],"code":"  observeDecorations (callback) {\r\n    const decorations = this.getDecorations()\r\n    for (let i = 0; i < decorations.length; i++) {\r\n      callback(decorations[i])\r\n    }\r\n    return this.onDidAddDecoration(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js","name":"DecorationManager.onDidAddDecoration","start_line":28,"end_line":30,"comment":[],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js","name":"onDidChangeFlexScale","line":114,"func_location":"PaneAxis.observeFlexScale","func_start_line":112,"func_end_line":115,"args":["fn"],"code":"  observeFlexScale (fn) {\r\n    fn(this.flexScale)\r\n    return this.onDidChangeFlexScale(fn)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js","name":"PaneAxis.onDidChangeFlexScale","start_line":108,"end_line":110,"comment":[],"params":["fn"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"onDidChangeFlexScale","line":199,"func_location":"Pane.observeFlexScale","func_start_line":197,"func_end_line":200,"args":["callback"],"comment":[" Public: Invoke the given callback with the current and future values of"," {::getFlexScale}.",""," * `callback` {Function} to be called with the current and future values of","   the {::getFlexScale} property.","   * `flexScale` {Number} representing the panes `flex-grow`; ability for a","     flex item to grow if necessary.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  observeFlexScale (callback) {\r\n    callback(this.flexScale)\r\n    return this.onDidChangeFlexScale(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.onDidChangeFlexScale","start_line":184,"end_line":186,"comment":["\r\n  Section: Event Subscription\r\n  "," Public: Invoke the given callback when the pane resizes",""," The callback will be invoked when pane's flexScale property changes."," Use {::getFlexScale} to get the current value.",""," * `callback` {Function} to be called when the pane is resized","   * `flexScale` {Number} representing the panes `flex-grow`; ability for a","     flex item to grow if necessary.",""," Returns a {Disposable} on which '.dispose()' can be called to unsubscribe."],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"onDidChangeGrammar","line":749,"func_location":"TextEditor.observeGrammar","func_start_line":747,"func_end_line":750,"args":["callback"],"comment":[" Extended: Calls your `callback` when the grammar that interprets and"," colorizes the text has been changed. Immediately calls your callback with"," the current grammar.",""," * `callback` {Function}","   * `grammar` {Grammar}",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  observeGrammar (callback) {\r\n    callback(this.getGrammar())\r\n    return this.onDidChangeGrammar(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.onDidChangeGrammar","start_line":759,"end_line":763,"comment":[" Extended: Calls your `callback` when the grammar that interprets and"," colorizes the text has been changed.",""," * `callback` {Function}","   * `grammar` {Grammar}",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/gutter-container.js","name":"getGutters","line":67,"func_location":"GutterContainer.observeGutters","func_start_line":66,"func_end_line":69,"args":[],"code":"  observeGutters (callback) {\r\n    for (let gutter of this.getGutters()) { callback(gutter) }\r\n    return this.onDidAddGutter(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/gutter-container.js","name":"GutterContainer.getGutters","start_line":55,"end_line":57,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/gutter-container.js","name":"onDidAddGutter","line":68,"func_location":"GutterContainer.observeGutters","func_start_line":66,"func_end_line":69,"args":["callback"],"code":"  observeGutters (callback) {\r\n    for (let gutter of this.getGutters()) { callback(gutter) }\r\n    return this.onDidAddGutter(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/gutter-container.js","name":"GutterContainer.onDidAddGutter","start_line":71,"end_line":73,"comment":[],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getItems","line":315,"func_location":"Pane.observeItems","func_start_line":314,"func_end_line":319,"args":[],"comment":[" Public: Invoke the given callback with all current and future items.",""," * `callback` {Function} to be called with current and future items.","   * `item` An item that is present in {::getItems} at the time of","     subscription or that is added at some later time.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  observeItems (callback) {\r\n    for (let item of this.getItems()) {\r\n      callback(item)\r\n    }\r\n    return this.onDidAddItem(({item}) => callback(item))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getItems","start_line":425,"end_line":427,"comment":["\r\n  Section: Items\r\n  "," Public: Get the items in this pane.",""," Returns an {Array} of items."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"onDidAddItem","line":318,"func_location":"Pane.observeItems","func_start_line":314,"func_end_line":319,"args":[null],"comment":[" Public: Invoke the given callback with all current and future items.",""," * `callback` {Function} to be called with current and future items.","   * `item` An item that is present in {::getItems} at the time of","     subscription or that is added at some later time.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  observeItems (callback) {\r\n    for (let item of this.getItems()) {\r\n      callback(item)\r\n    }\r\n    return this.onDidAddItem(({item}) => callback(item))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.onDidAddItem","start_line":268,"end_line":270,"comment":[" Public: Invoke the given callback when an item is added to the pane.",""," * `callback` {Function} to be called with when items are added.","   * `event` {Object} with the following keys:","     * `item` The added pane item.","     * `index` {Number} indicating where the item is located.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"get","line":1042,"func_location":"Config.observeKeyPath","func_start_line":1041,"func_end_line":1044,"args":[null],"code":"  observeKeyPath (keyPath, options, callback) {\r\n    callback(this.get(keyPath))\r\n    return this.onDidChangeKeyPath(keyPath, event => callback(event.newValue))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.get","start_line":585,"end_line":602,"comment":["\r\n  Section: Managing Settings\r\n  "," Essential: Retrieves the setting for the given key.",""," ### Examples",""," You might want to know what themes are enabled, so check `core.themes`",""," ```coffee"," atom.config.get('core.themes')"," ```",""," With scope descriptors you can get settings within a specific editor"," scope. For example, you might want to know `editor.tabLength` for ruby"," files.",""," ```coffee"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," ```",""," This setting in ruby files might be different than the global tabLength setting",""," ```coffee"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," ```",""," You can get the language scope descriptor via"," {TextEditor::getRootScopeDescriptor}. This will get the setting specifically"," for the editor's language.",""," ```coffee"," atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2"," ```",""," Additionally, you can get the setting at the specific cursor position.",""," ```coffee"," scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()"," atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2"," ```",""," * `keyPath` The {String} name of the key to retrieve."," * `options` (optional) {Object}","   * `sources` (optional) {Array} of {String} source names. If provided, only","     values that were associated with these sources during {::set} will be used.","   * `excludeSources` (optional) {Array} of {String} source names. If provided,","     values that  were associated with these sources during {::set} will not","     be used.","   * `scope` (optional) {ScopeDescriptor} describing a path from","     the root of the syntax tree to a token. Get one by calling","     {editor.getLastCursor().getScopeDescriptor()}","     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)","     for more information.",""," Returns the value from Atom's default settings, the user's configuration"," file in the type specified by the configuration schema."],"params":["args"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"onDidChangeKeyPath","line":1043,"func_location":"Config.observeKeyPath","func_start_line":1041,"func_end_line":1044,"args":["keyPath",null],"code":"  observeKeyPath (keyPath, options, callback) {\r\n    callback(this.get(keyPath))\r\n    return this.onDidChangeKeyPath(keyPath, event => callback(event.newValue))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.onDidChangeKeyPath","start_line":1046,"end_line":1056,"comment":[],"params":["keyPath","callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"getPaneItems","line":104,"func_location":"PaneContainer.observePaneItems","func_start_line":103,"func_end_line":106,"args":[],"code":"  observePaneItems (fn) {\r\n    for (let item of this.getPaneItems()) { fn(item) }\r\n    return this.onDidAddPaneItem(({item}) => fn(item))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.getPaneItems","start_line":154,"end_line":156,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"onDidAddPaneItem","line":105,"func_location":"PaneContainer.observePaneItems","func_start_line":103,"func_end_line":106,"args":[null],"code":"  observePaneItems (fn) {\r\n    for (let item of this.getPaneItems()) { fn(item) }\r\n    return this.onDidAddPaneItem(({item}) => fn(item))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.onDidAddPaneItem","start_line":99,"end_line":101,"comment":[],"params":["fn"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getPaneContainers","line":647,"func_location":"Workspace.observePaneItems","func_start_line":645,"func_end_line":649,"args":[null],"comment":[" Essential: Invoke the given callback with all current and future panes items"," in the workspace.",""," * `callback` {Function} to be called with current and future pane items.","   * `item` An item that is present in {::getPaneItems} at the time of","      subscription or that is added at some later time.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  observePaneItems (callback) {\r\n    return new CompositeDisposable(\r\n      ...this.getPaneContainers().map(container => container.observePaneItems(callback))\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getPaneContainers","start_line":1618,"end_line":1625,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"getPanes","line":74,"func_location":"PaneContainer.observePanes","func_start_line":73,"func_end_line":76,"args":[],"code":"  observePanes (fn) {\r\n    for (let pane of this.getPanes()) { fn(pane) }\r\n    return this.onDidAddPane(({pane}) => fn(pane))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.getPanes","start_line":146,"end_line":152,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"onDidAddPane","line":75,"func_location":"PaneContainer.observePanes","func_start_line":73,"func_end_line":76,"args":[null],"code":"  observePanes (fn) {\r\n    for (let pane of this.getPanes()) { fn(pane) }\r\n    return this.onDidAddPane(({pane}) => fn(pane))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.onDidAddPane","start_line":69,"end_line":71,"comment":[],"params":["fn"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getPaneContainers","line":790,"func_location":"Workspace.observePanes","func_start_line":788,"func_end_line":792,"args":[null],"comment":[" Extended: Invoke the given callback with all current and future panes in the"," workspace.",""," * `callback` {Function} to be called with current and future panes.","   * `pane` A {Pane} that is present in {::getPanes} at the time of","      subscription or that is added at some later time.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  observePanes (callback) {\r\n    return new CompositeDisposable(\r\n      ...this.getPaneContainers().map(container => container.observePanes(callback))\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getPaneContainers","start_line":1618,"end_line":1625,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"onDidAddRepository","line":254,"func_location":"Project.observeRepositories","func_start_line":247,"func_end_line":255,"args":["callback"],"comment":[" Public: Invoke the given callback with all current and future"," repositories in the project.",""," * `callback` {Function} to be called with current and future","    repositories.","   * `repository` A {GitRepository} that is present at the time of","     subscription or that is added at some later time.",""," Returns a {Disposable} on which `.dispose()` can be called to"," unsubscribe."],"code":"  observeRepositories (callback) {\r\n    for (const repo of this.repositories) {\r\n      if (repo != null) {\r\n        callback(repo)\r\n      }\r\n    }\r\n\r\n    return this.onDidAddRepository(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.onDidAddRepository","start_line":265,"end_line":267,"comment":[" Public: Invoke the given callback when a repository is added to the"," project.",""," * `callback` {Function} to be called when a repository is added.","   * `repository` A {GitRepository}.",""," Returns a {Disposable} on which `.dispose()` can be called to"," unsubscribe."],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"getRoot","line":65,"func_location":"PaneContainer.observeRoot","func_start_line":64,"func_end_line":67,"args":[null],"code":"  observeRoot (fn) {\r\n    fn(this.getRoot())\r\n    return this.onDidChangeRoot(fn)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.getRoot","start_line":129,"end_line":129,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"onDidChangeRoot","line":66,"func_location":"PaneContainer.observeRoot","func_start_line":64,"func_end_line":67,"args":["fn"],"code":"  observeRoot (fn) {\r\n    fn(this.getRoot())\r\n    return this.onDidChangeRoot(fn)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.onDidChangeRoot","start_line":60,"end_line":62,"comment":[],"params":["fn"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"get","line":1265,"func_location":"Config.observeScopedKeyPath","func_start_line":1264,"func_end_line":1267,"args":[null],"code":"  observeScopedKeyPath (scope, keyPath, callback) {\r\n    callback(this.get(keyPath, {scope}))\r\n    return this.onDidChangeScopedKeyPath(scope, keyPath, event => callback(event.newValue))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.get","start_line":585,"end_line":602,"comment":["\r\n  Section: Managing Settings\r\n  "," Essential: Retrieves the setting for the given key.",""," ### Examples",""," You might want to know what themes are enabled, so check `core.themes`",""," ```coffee"," atom.config.get('core.themes')"," ```",""," With scope descriptors you can get settings within a specific editor"," scope. For example, you might want to know `editor.tabLength` for ruby"," files.",""," ```coffee"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," ```",""," This setting in ruby files might be different than the global tabLength setting",""," ```coffee"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," ```",""," You can get the language scope descriptor via"," {TextEditor::getRootScopeDescriptor}. This will get the setting specifically"," for the editor's language.",""," ```coffee"," atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2"," ```",""," Additionally, you can get the setting at the specific cursor position.",""," ```coffee"," scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()"," atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2"," ```",""," * `keyPath` The {String} name of the key to retrieve."," * `options` (optional) {Object}","   * `sources` (optional) {Array} of {String} source names. If provided, only","     values that were associated with these sources during {::set} will be used.","   * `excludeSources` (optional) {Array} of {String} source names. If provided,","     values that  were associated with these sources during {::set} will not","     be used.","   * `scope` (optional) {ScopeDescriptor} describing a path from","     the root of the syntax tree to a token. Get one by calling","     {editor.getLastCursor().getScopeDescriptor()}","     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)","     for more information.",""," Returns the value from Atom's default settings, the user's configuration"," file in the type specified by the configuration schema."],"params":["args"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"onDidChangeScopedKeyPath","line":1266,"func_location":"Config.observeScopedKeyPath","func_start_line":1264,"func_end_line":1267,"args":["scope","keyPath",null],"code":"  observeScopedKeyPath (scope, keyPath, callback) {\r\n    callback(this.get(keyPath, {scope}))\r\n    return this.onDidChangeScopedKeyPath(scope, keyPath, event => callback(event.newValue))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.onDidChangeScopedKeyPath","start_line":1269,"end_line":1279,"comment":[],"params":["scope","keyPath","callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"onDidAddSelection","line":868,"func_location":"TextEditor.observeSelections","func_start_line":866,"func_end_line":869,"args":["callback"],"comment":[" Extended: Calls your `callback` when a {Selection} is added to the editor."," Immediately calls your callback for each existing selection.",""," * `callback` {Function}","   * `selection` {Selection} that was added",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  observeSelections (callback) {\r\n    this.getSelections().forEach(callback)\r\n    return this.onDidAddSelection(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.onDidAddSelection","start_line":877,"end_line":879,"comment":[" Extended: Calls your `callback` when a {Selection} is added to the editor.",""," * `callback` {Function}","   * `selection` {Selection} that was added",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js","name":"getStyleElements","line":50,"func_location":"StyleManager.observeStyleElements","func_start_line":49,"func_end_line":55,"args":[],"comment":["\r\n  Section: Event Subscription\r\n  "," Extended: Invoke `callback` for all current and future style elements.",""," * `callback` {Function} that is called with style elements.","   * `styleElement` An `HTMLStyleElement` instance. The `.sheet` property","     will be null because this element isn't attached to the DOM. If you want","     to attach this element to the DOM, be sure to clone it first by calling","     `.cloneNode(true)` on it. The style element will also have the following","     non-standard properties:","     * `sourcePath` A {String} containing the path from which the style","       element was loaded.","     * `context` A {String} indicating the target context of the style","       element.",""," Returns a {Disposable} on which `.dispose()` can be called to cancel the"," subscription."],"code":"  observeStyleElements (callback) {\r\n    for (let styleElement of this.getStyleElements()) {\r\n      callback(styleElement)\r\n    }\r\n\r\n    return this.onDidAddStyleElement(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js","name":"StyleManager.getStyleElements","start_line":113,"end_line":115,"comment":["\r\n  Section: Reading Style Elements\r\n  "," Extended: Get all loaded style elements."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js","name":"onDidAddStyleElement","line":54,"func_location":"StyleManager.observeStyleElements","func_start_line":49,"func_end_line":55,"args":["callback"],"comment":["\r\n  Section: Event Subscription\r\n  "," Extended: Invoke `callback` for all current and future style elements.",""," * `callback` {Function} that is called with style elements.","   * `styleElement` An `HTMLStyleElement` instance. The `.sheet` property","     will be null because this element isn't attached to the DOM. If you want","     to attach this element to the DOM, be sure to clone it first by calling","     `.cloneNode(true)` on it. The style element will also have the following","     non-standard properties:","     * `sourcePath` A {String} containing the path from which the style","       element was loaded.","     * `context` A {String} indicating the target context of the style","       element.",""," Returns a {Disposable} on which `.dispose()` can be called to cancel the"," subscription."],"code":"  observeStyleElements (callback) {\r\n    for (let styleElement of this.getStyleElements()) {\r\n      callback(styleElement)\r\n    }\r\n\r\n    return this.onDidAddStyleElement(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js","name":"StyleManager.onDidAddStyleElement","start_line":72,"end_line":74,"comment":[" Extended: Invoke `callback` when a style element is added.",""," * `callback` {Function} that is called with style elements.","   * `styleElement` An `HTMLStyleElement` instance. The `.sheet` property","     will be null because this element isn't attached to the DOM. If you want","     to attach this element to the DOM, be sure to clone it first by calling","     `.cloneNode(true)` on it. The style element will also have the following","     non-standard properties:","     * `sourcePath` A {String} containing the path from which the style","       element was loaded.","     * `context` A {String} indicating the target context of the style","       element.",""," Returns a {Disposable} on which `.dispose()` can be called to cancel the"," subscription."],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"updateGlobalTextEditorStyleSheet","line":52,"func_location":"WorkspaceElement.observeTextEditorFontConfig","func_start_line":51,"func_end_line":56,"args":[],"code":"  observeTextEditorFontConfig () {\r\n    this.updateGlobalTextEditorStyleSheet()\r\n    this.subscriptions.add(this.config.onDidChange('editor.fontSize', this.updateGlobalTextEditorStyleSheet.bind(this)))\r\n    this.subscriptions.add(this.config.onDidChange('editor.fontFamily', this.updateGlobalTextEditorStyleSheet.bind(this)))\r\n    this.subscriptions.add(this.config.onDidChange('editor.lineHeight', this.updateGlobalTextEditorStyleSheet.bind(this)))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js","name":"WorkspaceElement.updateGlobalTextEditorStyleSheet","start_line":58,"end_line":65,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js","name":"getTextEditors","line":59,"func_location":"WorkspaceCenter.observeTextEditors","func_start_line":58,"func_end_line":61,"args":[],"comment":["\r\n  Section: Event Subscription\r\n  "," Essential: Invoke the given callback with all current and future text"," editors in the workspace center.",""," * `callback` {Function} to be called with current and future text editors.","   * `editor` An {TextEditor} that is present in {::getTextEditors} at the time","     of subscription or that is added at some later time.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  observeTextEditors (callback) {\r\n    for (let textEditor of this.getTextEditors()) { callback(textEditor) }\r\n    return this.onDidAddTextEditor(({textEditor}) => callback(textEditor))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js","name":"WorkspaceCenter.getTextEditors","start_line":270,"end_line":272,"comment":[" Essential: Get all text editors in the workspace center.",""," Returns an {Array} of {TextEditor}s."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js","name":"onDidAddTextEditor","line":60,"func_location":"WorkspaceCenter.observeTextEditors","func_start_line":58,"func_end_line":61,"args":[null],"comment":["\r\n  Section: Event Subscription\r\n  "," Essential: Invoke the given callback with all current and future text"," editors in the workspace center.",""," * `callback` {Function} to be called with current and future text editors.","   * `editor` An {TextEditor} that is present in {::getTextEditors} at the time","     of subscription or that is added at some later time.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  observeTextEditors (callback) {\r\n    for (let textEditor of this.getTextEditors()) { callback(textEditor) }\r\n    return this.onDidAddTextEditor(({textEditor}) => callback(textEditor))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js","name":"WorkspaceCenter.onDidAddTextEditor","start_line":241,"end_line":247,"comment":[" Extended: Invoke the given callback when a text editor is added to the"," workspace center.",""," * `callback` {Function} to be called when panes are added.","   * `event` {Object} with the following keys:","     * `textEditor` {TextEditor} that was added.","     * `pane` {Pane} containing the added text editor.","     * `index` {Number} indicating the index of the added text editor in its","        pane.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getTextEditors","line":633,"func_location":"Workspace.observeTextEditors","func_start_line":632,"func_end_line":635,"args":[],"comment":[" Essential: Invoke the given callback with all current and future text"," editors in the workspace.",""," * `callback` {Function} to be called with current and future text editors.","   * `editor` A {TextEditor} that is present in {::getTextEditors} at the time","     of subscription or that is added at some later time.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  observeTextEditors (callback) {\r\n    for (let textEditor of this.getTextEditors()) { callback(textEditor) }\r\n    return this.onDidAddTextEditor(({textEditor}) => callback(textEditor))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getTextEditors","start_line":1364,"end_line":1366,"comment":[" Essential: Get all text editors in the workspace.",""," Returns an {Array} of {TextEditor}s."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"onDidAddTextEditor","line":634,"func_location":"Workspace.observeTextEditors","func_start_line":632,"func_end_line":635,"args":[null],"comment":[" Essential: Invoke the given callback with all current and future text"," editors in the workspace.",""," * `callback` {Function} to be called with current and future text editors.","   * `editor` A {TextEditor} that is present in {::getTextEditors} at the time","     of subscription or that is added at some later time.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  observeTextEditors (callback) {\r\n    for (let textEditor of this.getTextEditors()) { callback(textEditor) }\r\n    return this.onDidAddTextEditor(({textEditor}) => callback(textEditor))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.onDidAddTextEditor","start_line":878,"end_line":880,"comment":[" Extended: Invoke the given callback when a text editor is added to the"," workspace.",""," * `callback` {Function} to be called panes are added.","   * `event` {Object} with the following keys:","     * `textEditor` {TextEditor} that was added.","     * `pane` {Pane} containing the added text editor.","     * `index` {Number} indicating the index of the added text editor in its","        pane.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"isVisible","line":455,"func_location":"Dock.observeVisible","func_start_line":454,"func_end_line":457,"args":[null],"comment":[" Essential: Invoke the given callback with the current and all future visibilities of the dock.",""," * `callback` {Function} to be called when the visibility changes.","   * `visible` {Boolean} Is the dock now visible?",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  observeVisible (callback) {\r\n    callback(this.isVisible())\r\n    return this.onDidChangeVisible(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.isVisible","start_line":140,"end_line":142,"comment":[" Extended: Check if the dock is visible.",""," Returns a {Boolean}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"onDidChangeVisible","line":456,"func_location":"Dock.observeVisible","func_start_line":454,"func_end_line":457,"args":["callback"],"comment":[" Essential: Invoke the given callback with the current and all future visibilities of the dock.",""," * `callback` {Function} to be called when the visibility changes.","   * `visible` {Boolean} Is the dock now visible?",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  observeVisible (callback) {\r\n    callback(this.isVisible())\r\n    return this.onDidChangeVisible(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.onDidChangeVisible","start_line":444,"end_line":446,"comment":["\r\n  Section: Event Subscription\r\n  "," Essential: Invoke the given callback when the visibility of the dock changes.",""," * `callback` {Function} to be called when the visibility changes.","   * `visible` {Boolean} Is the dock now visible?",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getPaneContainers","line":748,"func_location":"Workspace.onDidAddPane","func_start_line":746,"func_end_line":750,"args":[null],"comment":[" Extended: Invoke the given callback when a pane is added to the workspace.",""," * `callback` {Function} to be called panes are added.","   * `event` {Object} with the following keys:","     * `pane` The added pane.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  onDidAddPane (callback) {\r\n    return new CompositeDisposable(\r\n      ...this.getPaneContainers().map(container => container.onDidAddPane(callback))\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getPaneContainers","start_line":1618,"end_line":1625,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getPaneContainers","line":829,"func_location":"Workspace.onDidAddPaneItem","func_start_line":827,"func_end_line":831,"args":[null],"comment":[" Extended: Invoke the given callback when a pane item is added to the"," workspace.",""," * `callback` {Function} to be called when pane items are added.","   * `event` {Object} with the following keys:","     * `item` The added pane item.","     * `pane` {Pane} containing the added item.","     * `index` {Number} indicating the index of the added item in its pane.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  onDidAddPaneItem (callback) {\r\n    return new CompositeDisposable(\r\n      ...this.getPaneContainers().map(container => container.onDidAddPaneItem(callback))\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getPaneContainers","start_line":1618,"end_line":1625,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js","name":"onDidAddPaneItem","line":242,"func_location":"WorkspaceCenter.onDidAddTextEditor","func_start_line":241,"func_end_line":247},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js","name":"WorkspaceCenter.onDidAddPaneItem","start_line":197,"end_line":199,"comment":[" Extended: Invoke the given callback when a pane item is added to the"," workspace center.",""," * `callback` {Function} to be called when pane items are added.","   * `event` {Object} with the following keys:","     * `item` The added pane item.","     * `pane` {Pane} containing the added item.","     * `index` {Number} indicating the index of the added item in its pane.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js","name":"ipcMessageEmitter","line":282,"func_location":"ApplicationDelegate.onDidBeginCheckingForUpdate","func_start_line":281,"func_end_line":283,"args":[{"type":"string"},"callback"],"code":"  onDidBeginCheckingForUpdate (callback) {\r\n    return this.ipcMessageEmitter().on('checking-for-update', callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js","name":"ApplicationDelegate.ipcMessageEmitter","start_line":13,"end_line":21,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js","name":"onUpdateAvailable","line":278,"func_location":"ApplicationDelegate.onDidBeginDownloadingUpdate","func_start_line":277,"func_end_line":279,"args":["callback"],"code":"  onDidBeginDownloadingUpdate (callback) {\r\n    return this.onUpdateAvailable(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js","name":"ApplicationDelegate.onUpdateAvailable","start_line":270,"end_line":275,"comment":[],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js","name":"start","line":79,"func_location":"NativeWatcher.onDidChange","func_start_line":78,"func_end_line":88,"args":[],"comment":[" Private: Register a callback to be invoked with normalized filesystem events as they arrive. Starts the watcher"," automatically if it is not already running. The watcher will be stopped automatically when all subscribers"," dispose their subscriptions.",""," Returns: A {Disposable} to revoke the subscription."],"code":"  onDidChange (callback) {\r\n    this.start()\r\n\r\n    const sub = this.emitter.on('did-change', callback)\r\n    return new Disposable(() => {\r\n      sub.dispose()\r\n      if (this.emitter.listenerCountForEventName('did-change') === 0) {\r\n        this.stop()\r\n      }\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js","name":"NativeWatcher.start","start_line":45,"end_line":55,"comment":[" Private: Begin watching for filesystem events.",""," Has no effect if the watcher has already been started."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"onDidChangeScopedKeyPath","line":520,"func_location":"Config.onDidChange","func_start_line":507,"func_end_line":524,"args":["scopeDescriptor","keyPath","callback"],"comment":[" Essential: Add a listener for changes to a given key path. If `keyPath` is"," not specified, your callback will be called on changes to any key.",""," * `keyPath` (optional) {String} name of the key to observe. Must be","   specified if `scopeDescriptor` is specified."," * `options` (optional) {Object}","   * `scope` (optional) {ScopeDescriptor} describing a path from","     the root of the syntax tree to a token. Get one by calling","     {editor.getLastCursor().getScopeDescriptor()}. See {::get} for examples.","     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)","     for more information."," * `callback` {Function} to call when the value of the key changes.","   * `event` {Object}","     * `newValue` the new value of the key","     * `oldValue` the prior value of the key.",""," Returns a {Disposable} with the following keys on which you can call"," `.dispose()` to unsubscribe."],"code":"  onDidChange (...args) {\r\n    let callback, keyPath, scopeDescriptor\r\n    if (args.length === 1) {\r\n      [callback] = args\r\n    } else if (args.length === 2) {\r\n      [keyPath, callback] = args\r\n    } else {\r\n      let options;\r\n      [keyPath, options, callback] = args\r\n      scopeDescriptor = options.scope\r\n    }\r\n\r\n    if (scopeDescriptor != null) {\r\n      return this.onDidChangeScopedKeyPath(scopeDescriptor, keyPath, callback)\r\n    } else {\r\n      return this.onDidChangeKeyPath(keyPath, callback)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.onDidChangeScopedKeyPath","start_line":1269,"end_line":1279,"comment":[],"params":["scope","keyPath","callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"onDidChangeKeyPath","line":522,"func_location":"Config.onDidChange","func_start_line":507,"func_end_line":524,"args":["keyPath","callback"],"comment":[" Essential: Add a listener for changes to a given key path. If `keyPath` is"," not specified, your callback will be called on changes to any key.",""," * `keyPath` (optional) {String} name of the key to observe. Must be","   specified if `scopeDescriptor` is specified."," * `options` (optional) {Object}","   * `scope` (optional) {ScopeDescriptor} describing a path from","     the root of the syntax tree to a token. Get one by calling","     {editor.getLastCursor().getScopeDescriptor()}. See {::get} for examples.","     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)","     for more information."," * `callback` {Function} to call when the value of the key changes.","   * `event` {Object}","     * `newValue` the new value of the key","     * `oldValue` the prior value of the key.",""," Returns a {Disposable} with the following keys on which you can call"," `.dispose()` to unsubscribe."],"code":"  onDidChange (...args) {\r\n    let callback, keyPath, scopeDescriptor\r\n    if (args.length === 1) {\r\n      [callback] = args\r\n    } else if (args.length === 2) {\r\n      [keyPath, callback] = args\r\n    } else {\r\n      let options;\r\n      [keyPath, options, callback] = args\r\n      scopeDescriptor = options.scope\r\n    }\r\n\r\n    if (scopeDescriptor != null) {\r\n      return this.onDidChangeScopedKeyPath(scopeDescriptor, keyPath, callback)\r\n    } else {\r\n      return this.onDidChangeKeyPath(keyPath, callback)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.onDidChangeKeyPath","start_line":1046,"end_line":1056,"comment":[],"params":["keyPath","callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"get","line":1047,"func_location":"Config.onDidChangeKeyPath","func_start_line":1046,"func_end_line":1056,"args":["keyPath"],"code":"  onDidChangeKeyPath (keyPath, callback) {\r\n    let oldValue = this.get(keyPath)\r\n    return this.emitter.on('did-change', () => {\r\n      const newValue = this.get(keyPath)\r\n      if (!_.isEqual(oldValue, newValue)) {\r\n        const event = {oldValue, newValue}\r\n        oldValue = newValue\r\n        return callback(event)\r\n      }\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.get","start_line":585,"end_line":602,"comment":["\r\n  Section: Managing Settings\r\n  "," Essential: Retrieves the setting for the given key.",""," ### Examples",""," You might want to know what themes are enabled, so check `core.themes`",""," ```coffee"," atom.config.get('core.themes')"," ```",""," With scope descriptors you can get settings within a specific editor"," scope. For example, you might want to know `editor.tabLength` for ruby"," files.",""," ```coffee"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," ```",""," This setting in ruby files might be different than the global tabLength setting",""," ```coffee"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," ```",""," You can get the language scope descriptor via"," {TextEditor::getRootScopeDescriptor}. This will get the setting specifically"," for the editor's language.",""," ```coffee"," atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2"," ```",""," Additionally, you can get the setting at the specific cursor position.",""," ```coffee"," scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()"," atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2"," ```",""," * `keyPath` The {String} name of the key to retrieve."," * `options` (optional) {Object}","   * `sources` (optional) {Array} of {String} source names. If provided, only","     values that were associated with these sources during {::set} will be used.","   * `excludeSources` (optional) {Array} of {String} source names. If provided,","     values that  were associated with these sources during {::set} will not","     be used.","   * `scope` (optional) {ScopeDescriptor} describing a path from","     the root of the syntax tree to a token. Get one by calling","     {editor.getLastCursor().getScopeDescriptor()}","     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)","     for more information.",""," Returns the value from Atom's default settings, the user's configuration"," file in the type specified by the configuration schema."],"params":["args"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"getBuffer","line":771,"func_location":"TextEditor.onDidChangeModified","func_start_line":770,"func_end_line":772,"args":["callback"],"comment":[" Extended: Calls your `callback` when the result of {::isModified} changes.",""," * `callback` {Function}",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  onDidChangeModified (callback) {\r\n    return this.getBuffer().onDidChangeModified(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.getBuffer","start_line":963,"end_line":963,"comment":[" Essential: Retrieves the current {TextBuffer}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"get","line":1270,"func_location":"Config.onDidChangeScopedKeyPath","func_start_line":1269,"func_end_line":1279,"args":["keyPath",null],"code":"  onDidChangeScopedKeyPath (scope, keyPath, callback) {\r\n    let oldValue = this.get(keyPath, {scope})\r\n    return this.emitter.on('did-change', () => {\r\n      const newValue = this.get(keyPath, {scope})\r\n      if (!_.isEqual(oldValue, newValue)) {\r\n        const event = {oldValue, newValue}\r\n        oldValue = newValue\r\n        callback(event)\r\n      }\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.get","start_line":585,"end_line":602,"comment":["\r\n  Section: Managing Settings\r\n  "," Essential: Retrieves the setting for the given key.",""," ### Examples",""," You might want to know what themes are enabled, so check `core.themes`",""," ```coffee"," atom.config.get('core.themes')"," ```",""," With scope descriptors you can get settings within a specific editor"," scope. For example, you might want to know `editor.tabLength` for ruby"," files.",""," ```coffee"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," ```",""," This setting in ruby files might be different than the global tabLength setting",""," ```coffee"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," ```",""," You can get the language scope descriptor via"," {TextEditor::getRootScopeDescriptor}. This will get the setting specifically"," for the editor's language.",""," ```coffee"," atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2"," ```",""," Additionally, you can get the setting at the specific cursor position.",""," ```coffee"," scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()"," atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2"," ```",""," * `keyPath` The {String} name of the key to retrieve."," * `options` (optional) {Object}","   * `sources` (optional) {Array} of {String} source names. If provided, only","     values that were associated with these sources during {::set} will be used.","   * `excludeSources` (optional) {Array} of {String} source names. If provided,","     values that  were associated with these sources during {::set} will not","     be used.","   * `scope` (optional) {ScopeDescriptor} describing a path from","     the root of the syntax tree to a token. Get one by calling","     {editor.getLastCursor().getScopeDescriptor()}","     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)","     for more information.",""," Returns the value from Atom's default settings, the user's configuration"," file in the type specified by the configuration schema."],"params":["args"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js","name":"ipcMessageEmitter","line":203,"func_location":"ApplicationDelegate.onDidChangeUserSettings","func_start_line":202,"func_end_line":206,"args":[],"code":"  onDidChangeUserSettings (callback) {\r\n    return this.ipcMessageEmitter().on('did-change-user-settings', detail => {\r\n      if (this.pendingSettingsUpdateCount === 0) callback(detail)\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js","name":"ApplicationDelegate.ipcMessageEmitter","start_line":13,"end_line":21,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js","name":"ipcMessageEmitter","line":286,"func_location":"ApplicationDelegate.onDidCompleteDownloadingUpdate","func_start_line":285,"func_end_line":287,"args":[{"type":"string"},"callback"],"code":"  onDidCompleteDownloadingUpdate (callback) {\r\n    return this.ipcMessageEmitter().on('update-available', callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js","name":"ApplicationDelegate.ipcMessageEmitter","start_line":13,"end_line":21,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"getBuffer","line":781,"func_location":"TextEditor.onDidConflict","func_start_line":780,"func_end_line":782,"args":["callback"],"comment":[" Extended: Calls your `callback` when the buffer's underlying file changes on"," disk at a moment when the result of {::isModified} is true.",""," * `callback` {Function}",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  onDidConflict (callback) {\r\n    return this.getBuffer().onDidConflict(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.getBuffer","start_line":963,"end_line":963,"comment":[" Essential: Retrieves the current {TextBuffer}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getPaneContainers","line":776,"func_location":"Workspace.onDidDestroyPane","func_start_line":774,"func_end_line":778,"args":[null],"comment":[" Extended: Invoke the given callback when a pane is destroyed in the"," workspace.",""," * `callback` {Function} to be called panes are destroyed.","   * `event` {Object} with the following keys:","     * `pane` The destroyed pane.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  onDidDestroyPane (callback) {\r\n    return new CompositeDisposable(\r\n      ...this.getPaneContainers().map(container => container.onDidDestroyPane(callback))\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getPaneContainers","start_line":1618,"end_line":1625,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getPaneContainers","line":863,"func_location":"Workspace.onDidDestroyPaneItem","func_start_line":861,"func_end_line":865,"args":[null],"comment":[" Extended: Invoke the given callback when a pane item is destroyed.",""," * `callback` {Function} to be called when pane items are destroyed.","   * `event` {Object} with the following keys:","     * `item` The destroyed item.","     * `pane` {Pane} containing the destroyed item.","     * `index` {Number} indicating the index of the destroyed item in its","       pane.",""," Returns a {Disposable} on which `.dispose` can be called to unsubscribe."],"code":"  onDidDestroyPaneItem (callback) {\r\n    return new CompositeDisposable(\r\n      ...this.getPaneContainers().map(container => container.onDidDestroyPaneItem(callback))\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getPaneContainers","start_line":1618,"end_line":1625,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js","name":"ipcMessageEmitter","line":209,"func_location":"ApplicationDelegate.onDidFailToReadUserSettings","func_start_line":208,"func_end_line":210,"args":[{"type":"string"},"callback"],"code":"  onDidFailToReadUserSettings (callback) {\r\n    return this.ipcMessageEmitter().on('did-fail-to-read-user-setting', callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js","name":"ApplicationDelegate.ipcMessageEmitter","start_line":13,"end_line":21,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js","name":"ipcMessageEmitter","line":267,"func_location":"ApplicationDelegate.onDidOpenLocations","func_start_line":266,"func_end_line":268,"args":[{"type":"string"},"callback"],"code":"  onDidOpenLocations (callback) {\r\n    return this.ipcMessageEmitter().on('open-locations', callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js","name":"ApplicationDelegate.ipcMessageEmitter","start_line":13,"end_line":21,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"getBuffer","line":815,"func_location":"TextEditor.onDidSave","func_start_line":814,"func_end_line":816,"args":["callback"],"comment":[" Essential: Invoke the given callback after the buffer is saved to disk.",""," * `callback` {Function} to be called after the buffer is saved.","   * `event` {Object} with the following keys:","     * `path` The path to which the buffer was saved.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  onDidSave (callback) {\r\n    return this.getBuffer().onDidSave(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.getBuffer","start_line":963,"end_line":963,"comment":[" Essential: Retrieves the current {TextBuffer}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"getBuffer","line":686,"func_location":"TextEditor.onDidStopChanging","func_start_line":685,"func_end_line":687,"args":["callback"],"comment":[" Essential: Invoke `callback` when the buffer's contents change. It is"," emit asynchronously 300ms after the last buffer change. This is a good place"," to handle changes to the buffer without compromising typing performance.",""," * `callback` {Function}",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  onDidStopChanging (callback) {\r\n    return this.getBuffer().onDidStopChanging(callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.getBuffer","start_line":963,"end_line":963,"comment":[" Essential: Retrieves the current {TextBuffer}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js","name":"ipcMessageEmitter","line":274,"func_location":"ApplicationDelegate.onUpdateAvailable","func_start_line":270,"func_end_line":275,"args":[{"type":"string"},"callback"],"code":"  onUpdateAvailable (callback) {\r\n    // TODO: Yes, this is strange that `onUpdateAvailable` is listening for\r\n    // `did-begin-downloading-update`. We currently have no mechanism to know\r\n    // if there is an update, so begin of downloading is a good proxy.\r\n    return this.ipcMessageEmitter().on('did-begin-downloading-update', callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js","name":"ApplicationDelegate.ipcMessageEmitter","start_line":13,"end_line":21,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js","name":"ipcMessageEmitter","line":294,"func_location":"ApplicationDelegate.onUpdateError","func_start_line":293,"func_end_line":295,"args":[{"type":"string"},"callback"],"code":"  onUpdateError (callback) {\r\n    return this.ipcMessageEmitter().on('update-error', callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js","name":"ApplicationDelegate.ipcMessageEmitter","start_line":13,"end_line":21,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js","name":"ipcMessageEmitter","line":290,"func_location":"ApplicationDelegate.onUpdateNotAvailable","func_start_line":289,"func_end_line":291,"args":[{"type":"string"},"callback"],"code":"  onUpdateNotAvailable (callback) {\r\n    return this.ipcMessageEmitter().on('update-not-available', callback)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js","name":"ApplicationDelegate.ipcMessageEmitter","start_line":13,"end_line":21,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getPaneContainers","line":762,"func_location":"Workspace.onWillDestroyPane","func_start_line":760,"func_end_line":764,"args":[null],"comment":[" Extended: Invoke the given callback before a pane is destroyed in the"," workspace.",""," * `callback` {Function} to be called before panes are destroyed.","   * `event` {Object} with the following keys:","     * `pane` The pane to be destroyed.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"code":"  onWillDestroyPane (callback) {\r\n    return new CompositeDisposable(\r\n      ...this.getPaneContainers().map(container => container.onWillDestroyPane(callback))\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getPaneContainers","start_line":1618,"end_line":1625,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getPaneContainers","line":847,"func_location":"Workspace.onWillDestroyPaneItem","func_start_line":845,"func_end_line":849,"args":[null],"comment":[" Extended: Invoke the given callback when a pane item is about to be"," destroyed, before the user is prompted to save it.",""," * `callback` {Function} to be called before pane items are destroyed. If this function returns","   a {Promise}, then the item will not be destroyed until the promise resolves.","   * `event` {Object} with the following keys:","     * `item` The item to be destroyed.","     * `pane` {Pane} containing the item to be destroyed.","     * `index` {Number} indicating the index of the item to be destroyed in","       its pane.",""," Returns a {Disposable} on which `.dispose` can be called to unsubscribe."],"code":"  onWillDestroyPaneItem (callback) {\r\n    return new CompositeDisposable(\r\n      ...this.getPaneContainers().map(container => container.onWillDestroyPaneItem(callback))\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getPaneContainers","start_line":1618,"end_line":1625,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"constructor","line":68,"func_location":"GitRepository.open","func_start_line":65,"func_end_line":72},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.constructor","start_line":74,"end_line":108,"comment":[],"params":["path","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"paneForItem","line":962,"func_location":"Workspace.open","func_start_line":925,"func_end_line":1079,"args":["item"],"comment":["\r\n  Section: Opening\r\n  "," Essential: Opens the given URI in Atom asynchronously."," If the URI is already open, the existing item for that URI will be"," activated. If no URI is given, or no registered opener can open"," the URI, a new empty {TextEditor} will be created.",""," * `uri` (optional) A {String} containing a URI."," * `options` (optional) {Object}","   * `initialLine` A {Number} indicating which row to move the cursor to","     initially. Defaults to `0`.","   * `initialColumn` A {Number} indicating which column to move the cursor to","     initially. Defaults to `0`.","   * `split` Either 'left', 'right', 'up' or 'down'.","     If 'left', the item will be opened in leftmost pane of the current active pane's row.","     If 'right', the item will be opened in the rightmost pane of the current active pane's row. If only one pane exists in the row, a new pane will be created.","     If 'up', the item will be opened in topmost pane of the current active pane's column.","     If 'down', the item will be opened in the bottommost pane of the current active pane's column. If only one pane exists in the column, a new pane will be created.","   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on","     containing pane. Defaults to `true`.","   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}","     on containing pane. Defaults to `true`.","   * `pending` A {Boolean} indicating whether or not the item should be opened","     in a pending state. Existing pending items in a pane are replaced with","     new pending items when they are opened.","   * `searchAllPanes` A {Boolean}. If `true`, the workspace will attempt to","     activate an existing item for the given URI on any pane.","     If `false`, only the active pane will be searched for","     an existing item for the same URI. Defaults to `false`.","   * `location` (optional) A {String} containing the name of the location","     in which this item should be opened (one of \"left\", \"right\", \"bottom\",","     or \"center\"). If omitted, Atom will fall back to the last location in","     which a user has placed an item with the same URI or, if this is a new","     URI, the default location specified by the item. NOTE: This option","     should almost always be omitted to honor user preference.",""," Returns a {Promise} that resolves to the {TextEditor} for the file URI."],"code":"  async open (itemOrURI, options = {}) {\r\n    let uri, item\r\n    if (typeof itemOrURI === 'string') {\r\n      uri = this.project.resolvePath(itemOrURI)\r\n    } else if (itemOrURI) {\r\n      item = itemOrURI\r\n      if (typeof item.getURI === 'function') uri = item.getURI()\r\n    }\r\n\r\n    let resolveItem = () => {}\r\n    if (uri) {\r\n      const incomingItem = this.incoming.get(uri)\r\n      if (!incomingItem) {\r\n        this.incoming.set(uri, new Promise(resolve => { resolveItem = resolve }))\r\n      } else {\r\n        await incomingItem\r\n      }\r\n    }\r\n\r\n    try {\r\n      if (!atom.config.get('core.allowPendingPaneItems')) {\r\n        options.pending = false\r\n      }\r\n\r\n      // Avoid adding URLs as recent documents to work-around this Spotlight crash:\r\n      // https://github.com/atom/atom/issues/10071\r\n      if (uri && (!url.parse(uri).protocol || process.platform === 'win32')) {\r\n        this.applicationDelegate.addRecentDocument(uri)\r\n      }\r\n\r\n      let pane, itemExistsInWorkspace\r\n\r\n      // Try to find an existing item in the workspace.\r\n      if (item || uri) {\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else if (options.searchAllPanes) {\r\n          pane = item ? this.paneForItem(item) : this.paneForURI(uri)\r\n        } else {\r\n          // If an item with the given URI is already in the workspace, assume\r\n          // that item's pane container is the preferred location for that URI.\r\n          let container\r\n          if (uri) container = this.paneContainerForURI(uri)\r\n          if (!container) container = this.getActivePaneContainer()\r\n\r\n          // The `split` option affects where we search for the item.\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n\r\n        if (pane) {\r\n          if (item) {\r\n            itemExistsInWorkspace = pane.getItems().includes(item)\r\n          } else {\r\n            item = pane.itemForURI(uri)\r\n            itemExistsInWorkspace = item != null\r\n          }\r\n        }\r\n      }\r\n\r\n      // If we already have an item at this stage, we won't need to do an async\r\n      // lookup of the URI, so we yield the event loop to ensure this method\r\n      // is consistently asynchronous.\r\n      if (item) await Promise.resolve()\r\n\r\n      if (!itemExistsInWorkspace) {\r\n        item = item || await this.createItemForURI(uri, options)\r\n        if (!item) return\r\n\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else {\r\n          let location = options.location\r\n          if (!location && !options.split && uri && this.enablePersistence) {\r\n            location = await this.itemLocationStore.load(uri)\r\n          }\r\n          if (!location && typeof item.getDefaultLocation === 'function') {\r\n            location = item.getDefaultLocation()\r\n          }\r\n\r\n          const allowedLocations = typeof item.getAllowedLocations === 'function' ? item.getAllowedLocations() : ALL_LOCATIONS\r\n          location = allowedLocations.includes(location) ? location : allowedLocations[0]\r\n\r\n          const container = this.paneContainers[location] || this.getCenter()\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findOrCreateRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findOrCreateBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!options.pending && (pane.getPendingItem() === item)) {\r\n        pane.clearPendingItem()\r\n      }\r\n\r\n      this.itemOpened(item)\r\n\r\n      if (options.activateItem === false) {\r\n        pane.addItem(item, {pending: options.pending})\r\n      } else {\r\n        pane.activateItem(item, {pending: options.pending})\r\n      }\r\n\r\n      if (options.activatePane !== false) {\r\n        pane.activate()\r\n      }\r\n\r\n      let initialColumn = 0\r\n      let initialLine = 0\r\n      if (!Number.isNaN(options.initialLine)) {\r\n        initialLine = options.initialLine\r\n      }\r\n      if (!Number.isNaN(options.initialColumn)) {\r\n        initialColumn = options.initialColumn\r\n      }\r\n      if (initialLine >= 0 || initialColumn >= 0) {\r\n        if (typeof item.setCursorBufferPosition === 'function') {\r\n          item.setCursorBufferPosition([initialLine, initialColumn])\r\n        }\r\n      }\r\n\r\n      const index = pane.getActiveItemIndex()\r\n      this.emitter.emit('did-open', {uri, pane, item, index})\r\n      if (uri) {\r\n        this.incoming.delete(uri)\r\n      }\r\n    } finally {\r\n      resolveItem()\r\n    }\r\n    return item\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.paneForItem","start_line":1496,"end_line":1503,"comment":[" Extended: Get the {Pane} containing the given item.",""," * `item` the Item that the returned pane must contain.",""," Returns a {Pane} or `undefined` if no pane exists for the given item."],"params":["item"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"paneForURI","line":962,"func_location":"Workspace.open","func_start_line":925,"func_end_line":1079,"args":["item"],"comment":["\r\n  Section: Opening\r\n  "," Essential: Opens the given URI in Atom asynchronously."," If the URI is already open, the existing item for that URI will be"," activated. If no URI is given, or no registered opener can open"," the URI, a new empty {TextEditor} will be created.",""," * `uri` (optional) A {String} containing a URI."," * `options` (optional) {Object}","   * `initialLine` A {Number} indicating which row to move the cursor to","     initially. Defaults to `0`.","   * `initialColumn` A {Number} indicating which column to move the cursor to","     initially. Defaults to `0`.","   * `split` Either 'left', 'right', 'up' or 'down'.","     If 'left', the item will be opened in leftmost pane of the current active pane's row.","     If 'right', the item will be opened in the rightmost pane of the current active pane's row. If only one pane exists in the row, a new pane will be created.","     If 'up', the item will be opened in topmost pane of the current active pane's column.","     If 'down', the item will be opened in the bottommost pane of the current active pane's column. If only one pane exists in the column, a new pane will be created.","   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on","     containing pane. Defaults to `true`.","   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}","     on containing pane. Defaults to `true`.","   * `pending` A {Boolean} indicating whether or not the item should be opened","     in a pending state. Existing pending items in a pane are replaced with","     new pending items when they are opened.","   * `searchAllPanes` A {Boolean}. If `true`, the workspace will attempt to","     activate an existing item for the given URI on any pane.","     If `false`, only the active pane will be searched for","     an existing item for the same URI. Defaults to `false`.","   * `location` (optional) A {String} containing the name of the location","     in which this item should be opened (one of \"left\", \"right\", \"bottom\",","     or \"center\"). If omitted, Atom will fall back to the last location in","     which a user has placed an item with the same URI or, if this is a new","     URI, the default location specified by the item. NOTE: This option","     should almost always be omitted to honor user preference.",""," Returns a {Promise} that resolves to the {TextEditor} for the file URI."],"code":"  async open (itemOrURI, options = {}) {\r\n    let uri, item\r\n    if (typeof itemOrURI === 'string') {\r\n      uri = this.project.resolvePath(itemOrURI)\r\n    } else if (itemOrURI) {\r\n      item = itemOrURI\r\n      if (typeof item.getURI === 'function') uri = item.getURI()\r\n    }\r\n\r\n    let resolveItem = () => {}\r\n    if (uri) {\r\n      const incomingItem = this.incoming.get(uri)\r\n      if (!incomingItem) {\r\n        this.incoming.set(uri, new Promise(resolve => { resolveItem = resolve }))\r\n      } else {\r\n        await incomingItem\r\n      }\r\n    }\r\n\r\n    try {\r\n      if (!atom.config.get('core.allowPendingPaneItems')) {\r\n        options.pending = false\r\n      }\r\n\r\n      // Avoid adding URLs as recent documents to work-around this Spotlight crash:\r\n      // https://github.com/atom/atom/issues/10071\r\n      if (uri && (!url.parse(uri).protocol || process.platform === 'win32')) {\r\n        this.applicationDelegate.addRecentDocument(uri)\r\n      }\r\n\r\n      let pane, itemExistsInWorkspace\r\n\r\n      // Try to find an existing item in the workspace.\r\n      if (item || uri) {\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else if (options.searchAllPanes) {\r\n          pane = item ? this.paneForItem(item) : this.paneForURI(uri)\r\n        } else {\r\n          // If an item with the given URI is already in the workspace, assume\r\n          // that item's pane container is the preferred location for that URI.\r\n          let container\r\n          if (uri) container = this.paneContainerForURI(uri)\r\n          if (!container) container = this.getActivePaneContainer()\r\n\r\n          // The `split` option affects where we search for the item.\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n\r\n        if (pane) {\r\n          if (item) {\r\n            itemExistsInWorkspace = pane.getItems().includes(item)\r\n          } else {\r\n            item = pane.itemForURI(uri)\r\n            itemExistsInWorkspace = item != null\r\n          }\r\n        }\r\n      }\r\n\r\n      // If we already have an item at this stage, we won't need to do an async\r\n      // lookup of the URI, so we yield the event loop to ensure this method\r\n      // is consistently asynchronous.\r\n      if (item) await Promise.resolve()\r\n\r\n      if (!itemExistsInWorkspace) {\r\n        item = item || await this.createItemForURI(uri, options)\r\n        if (!item) return\r\n\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else {\r\n          let location = options.location\r\n          if (!location && !options.split && uri && this.enablePersistence) {\r\n            location = await this.itemLocationStore.load(uri)\r\n          }\r\n          if (!location && typeof item.getDefaultLocation === 'function') {\r\n            location = item.getDefaultLocation()\r\n          }\r\n\r\n          const allowedLocations = typeof item.getAllowedLocations === 'function' ? item.getAllowedLocations() : ALL_LOCATIONS\r\n          location = allowedLocations.includes(location) ? location : allowedLocations[0]\r\n\r\n          const container = this.paneContainers[location] || this.getCenter()\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findOrCreateRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findOrCreateBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!options.pending && (pane.getPendingItem() === item)) {\r\n        pane.clearPendingItem()\r\n      }\r\n\r\n      this.itemOpened(item)\r\n\r\n      if (options.activateItem === false) {\r\n        pane.addItem(item, {pending: options.pending})\r\n      } else {\r\n        pane.activateItem(item, {pending: options.pending})\r\n      }\r\n\r\n      if (options.activatePane !== false) {\r\n        pane.activate()\r\n      }\r\n\r\n      let initialColumn = 0\r\n      let initialLine = 0\r\n      if (!Number.isNaN(options.initialLine)) {\r\n        initialLine = options.initialLine\r\n      }\r\n      if (!Number.isNaN(options.initialColumn)) {\r\n        initialColumn = options.initialColumn\r\n      }\r\n      if (initialLine >= 0 || initialColumn >= 0) {\r\n        if (typeof item.setCursorBufferPosition === 'function') {\r\n          item.setCursorBufferPosition([initialLine, initialColumn])\r\n        }\r\n      }\r\n\r\n      const index = pane.getActiveItemIndex()\r\n      this.emitter.emit('did-open', {uri, pane, item, index})\r\n      if (uri) {\r\n        this.incoming.delete(uri)\r\n      }\r\n    } finally {\r\n      resolveItem()\r\n    }\r\n    return item\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.paneForURI","start_line":1482,"end_line":1489,"comment":[" Extended: Get the first {Pane} that contains an item with the given URI.",""," * `uri` {String} uri",""," Returns a {Pane} or `undefined` if no item exists with the given URI."],"params":["uri"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"paneContainerForURI","line":967,"func_location":"Workspace.open","func_start_line":925,"func_end_line":1079,"args":["uri"],"comment":["\r\n  Section: Opening\r\n  "," Essential: Opens the given URI in Atom asynchronously."," If the URI is already open, the existing item for that URI will be"," activated. If no URI is given, or no registered opener can open"," the URI, a new empty {TextEditor} will be created.",""," * `uri` (optional) A {String} containing a URI."," * `options` (optional) {Object}","   * `initialLine` A {Number} indicating which row to move the cursor to","     initially. Defaults to `0`.","   * `initialColumn` A {Number} indicating which column to move the cursor to","     initially. Defaults to `0`.","   * `split` Either 'left', 'right', 'up' or 'down'.","     If 'left', the item will be opened in leftmost pane of the current active pane's row.","     If 'right', the item will be opened in the rightmost pane of the current active pane's row. If only one pane exists in the row, a new pane will be created.","     If 'up', the item will be opened in topmost pane of the current active pane's column.","     If 'down', the item will be opened in the bottommost pane of the current active pane's column. If only one pane exists in the column, a new pane will be created.","   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on","     containing pane. Defaults to `true`.","   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}","     on containing pane. Defaults to `true`.","   * `pending` A {Boolean} indicating whether or not the item should be opened","     in a pending state. Existing pending items in a pane are replaced with","     new pending items when they are opened.","   * `searchAllPanes` A {Boolean}. If `true`, the workspace will attempt to","     activate an existing item for the given URI on any pane.","     If `false`, only the active pane will be searched for","     an existing item for the same URI. Defaults to `false`.","   * `location` (optional) A {String} containing the name of the location","     in which this item should be opened (one of \"left\", \"right\", \"bottom\",","     or \"center\"). If omitted, Atom will fall back to the last location in","     which a user has placed an item with the same URI or, if this is a new","     URI, the default location specified by the item. NOTE: This option","     should almost always be omitted to honor user preference.",""," Returns a {Promise} that resolves to the {TextEditor} for the file URI."],"code":"  async open (itemOrURI, options = {}) {\r\n    let uri, item\r\n    if (typeof itemOrURI === 'string') {\r\n      uri = this.project.resolvePath(itemOrURI)\r\n    } else if (itemOrURI) {\r\n      item = itemOrURI\r\n      if (typeof item.getURI === 'function') uri = item.getURI()\r\n    }\r\n\r\n    let resolveItem = () => {}\r\n    if (uri) {\r\n      const incomingItem = this.incoming.get(uri)\r\n      if (!incomingItem) {\r\n        this.incoming.set(uri, new Promise(resolve => { resolveItem = resolve }))\r\n      } else {\r\n        await incomingItem\r\n      }\r\n    }\r\n\r\n    try {\r\n      if (!atom.config.get('core.allowPendingPaneItems')) {\r\n        options.pending = false\r\n      }\r\n\r\n      // Avoid adding URLs as recent documents to work-around this Spotlight crash:\r\n      // https://github.com/atom/atom/issues/10071\r\n      if (uri && (!url.parse(uri).protocol || process.platform === 'win32')) {\r\n        this.applicationDelegate.addRecentDocument(uri)\r\n      }\r\n\r\n      let pane, itemExistsInWorkspace\r\n\r\n      // Try to find an existing item in the workspace.\r\n      if (item || uri) {\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else if (options.searchAllPanes) {\r\n          pane = item ? this.paneForItem(item) : this.paneForURI(uri)\r\n        } else {\r\n          // If an item with the given URI is already in the workspace, assume\r\n          // that item's pane container is the preferred location for that URI.\r\n          let container\r\n          if (uri) container = this.paneContainerForURI(uri)\r\n          if (!container) container = this.getActivePaneContainer()\r\n\r\n          // The `split` option affects where we search for the item.\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n\r\n        if (pane) {\r\n          if (item) {\r\n            itemExistsInWorkspace = pane.getItems().includes(item)\r\n          } else {\r\n            item = pane.itemForURI(uri)\r\n            itemExistsInWorkspace = item != null\r\n          }\r\n        }\r\n      }\r\n\r\n      // If we already have an item at this stage, we won't need to do an async\r\n      // lookup of the URI, so we yield the event loop to ensure this method\r\n      // is consistently asynchronous.\r\n      if (item) await Promise.resolve()\r\n\r\n      if (!itemExistsInWorkspace) {\r\n        item = item || await this.createItemForURI(uri, options)\r\n        if (!item) return\r\n\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else {\r\n          let location = options.location\r\n          if (!location && !options.split && uri && this.enablePersistence) {\r\n            location = await this.itemLocationStore.load(uri)\r\n          }\r\n          if (!location && typeof item.getDefaultLocation === 'function') {\r\n            location = item.getDefaultLocation()\r\n          }\r\n\r\n          const allowedLocations = typeof item.getAllowedLocations === 'function' ? item.getAllowedLocations() : ALL_LOCATIONS\r\n          location = allowedLocations.includes(location) ? location : allowedLocations[0]\r\n\r\n          const container = this.paneContainers[location] || this.getCenter()\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findOrCreateRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findOrCreateBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!options.pending && (pane.getPendingItem() === item)) {\r\n        pane.clearPendingItem()\r\n      }\r\n\r\n      this.itemOpened(item)\r\n\r\n      if (options.activateItem === false) {\r\n        pane.addItem(item, {pending: options.pending})\r\n      } else {\r\n        pane.activateItem(item, {pending: options.pending})\r\n      }\r\n\r\n      if (options.activatePane !== false) {\r\n        pane.activate()\r\n      }\r\n\r\n      let initialColumn = 0\r\n      let initialLine = 0\r\n      if (!Number.isNaN(options.initialLine)) {\r\n        initialLine = options.initialLine\r\n      }\r\n      if (!Number.isNaN(options.initialColumn)) {\r\n        initialColumn = options.initialColumn\r\n      }\r\n      if (initialLine >= 0 || initialColumn >= 0) {\r\n        if (typeof item.setCursorBufferPosition === 'function') {\r\n          item.setCursorBufferPosition([initialLine, initialColumn])\r\n        }\r\n      }\r\n\r\n      const index = pane.getActiveItemIndex()\r\n      this.emitter.emit('did-open', {uri, pane, item, index})\r\n      if (uri) {\r\n        this.incoming.delete(uri)\r\n      }\r\n    } finally {\r\n      resolveItem()\r\n    }\r\n    return item\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.paneContainerForURI","start_line":1463,"end_line":1465,"comment":[" Extended: Get the first pane container that contains an item with the given"," URI.",""," * `uri` {String} uri",""," Returns a {Dock}, the {WorkspaceCenter}, or `undefined` if no item exists"," with the given URI."],"params":["uri"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getActivePaneContainer","line":968,"func_location":"Workspace.open","func_start_line":925,"func_end_line":1079,"args":[],"comment":["\r\n  Section: Opening\r\n  "," Essential: Opens the given URI in Atom asynchronously."," If the URI is already open, the existing item for that URI will be"," activated. If no URI is given, or no registered opener can open"," the URI, a new empty {TextEditor} will be created.",""," * `uri` (optional) A {String} containing a URI."," * `options` (optional) {Object}","   * `initialLine` A {Number} indicating which row to move the cursor to","     initially. Defaults to `0`.","   * `initialColumn` A {Number} indicating which column to move the cursor to","     initially. Defaults to `0`.","   * `split` Either 'left', 'right', 'up' or 'down'.","     If 'left', the item will be opened in leftmost pane of the current active pane's row.","     If 'right', the item will be opened in the rightmost pane of the current active pane's row. If only one pane exists in the row, a new pane will be created.","     If 'up', the item will be opened in topmost pane of the current active pane's column.","     If 'down', the item will be opened in the bottommost pane of the current active pane's column. If only one pane exists in the column, a new pane will be created.","   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on","     containing pane. Defaults to `true`.","   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}","     on containing pane. Defaults to `true`.","   * `pending` A {Boolean} indicating whether or not the item should be opened","     in a pending state. Existing pending items in a pane are replaced with","     new pending items when they are opened.","   * `searchAllPanes` A {Boolean}. If `true`, the workspace will attempt to","     activate an existing item for the given URI on any pane.","     If `false`, only the active pane will be searched for","     an existing item for the same URI. Defaults to `false`.","   * `location` (optional) A {String} containing the name of the location","     in which this item should be opened (one of \"left\", \"right\", \"bottom\",","     or \"center\"). If omitted, Atom will fall back to the last location in","     which a user has placed an item with the same URI or, if this is a new","     URI, the default location specified by the item. NOTE: This option","     should almost always be omitted to honor user preference.",""," Returns a {Promise} that resolves to the {TextEditor} for the file URI."],"code":"  async open (itemOrURI, options = {}) {\r\n    let uri, item\r\n    if (typeof itemOrURI === 'string') {\r\n      uri = this.project.resolvePath(itemOrURI)\r\n    } else if (itemOrURI) {\r\n      item = itemOrURI\r\n      if (typeof item.getURI === 'function') uri = item.getURI()\r\n    }\r\n\r\n    let resolveItem = () => {}\r\n    if (uri) {\r\n      const incomingItem = this.incoming.get(uri)\r\n      if (!incomingItem) {\r\n        this.incoming.set(uri, new Promise(resolve => { resolveItem = resolve }))\r\n      } else {\r\n        await incomingItem\r\n      }\r\n    }\r\n\r\n    try {\r\n      if (!atom.config.get('core.allowPendingPaneItems')) {\r\n        options.pending = false\r\n      }\r\n\r\n      // Avoid adding URLs as recent documents to work-around this Spotlight crash:\r\n      // https://github.com/atom/atom/issues/10071\r\n      if (uri && (!url.parse(uri).protocol || process.platform === 'win32')) {\r\n        this.applicationDelegate.addRecentDocument(uri)\r\n      }\r\n\r\n      let pane, itemExistsInWorkspace\r\n\r\n      // Try to find an existing item in the workspace.\r\n      if (item || uri) {\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else if (options.searchAllPanes) {\r\n          pane = item ? this.paneForItem(item) : this.paneForURI(uri)\r\n        } else {\r\n          // If an item with the given URI is already in the workspace, assume\r\n          // that item's pane container is the preferred location for that URI.\r\n          let container\r\n          if (uri) container = this.paneContainerForURI(uri)\r\n          if (!container) container = this.getActivePaneContainer()\r\n\r\n          // The `split` option affects where we search for the item.\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n\r\n        if (pane) {\r\n          if (item) {\r\n            itemExistsInWorkspace = pane.getItems().includes(item)\r\n          } else {\r\n            item = pane.itemForURI(uri)\r\n            itemExistsInWorkspace = item != null\r\n          }\r\n        }\r\n      }\r\n\r\n      // If we already have an item at this stage, we won't need to do an async\r\n      // lookup of the URI, so we yield the event loop to ensure this method\r\n      // is consistently asynchronous.\r\n      if (item) await Promise.resolve()\r\n\r\n      if (!itemExistsInWorkspace) {\r\n        item = item || await this.createItemForURI(uri, options)\r\n        if (!item) return\r\n\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else {\r\n          let location = options.location\r\n          if (!location && !options.split && uri && this.enablePersistence) {\r\n            location = await this.itemLocationStore.load(uri)\r\n          }\r\n          if (!location && typeof item.getDefaultLocation === 'function') {\r\n            location = item.getDefaultLocation()\r\n          }\r\n\r\n          const allowedLocations = typeof item.getAllowedLocations === 'function' ? item.getAllowedLocations() : ALL_LOCATIONS\r\n          location = allowedLocations.includes(location) ? location : allowedLocations[0]\r\n\r\n          const container = this.paneContainers[location] || this.getCenter()\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findOrCreateRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findOrCreateBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!options.pending && (pane.getPendingItem() === item)) {\r\n        pane.clearPendingItem()\r\n      }\r\n\r\n      this.itemOpened(item)\r\n\r\n      if (options.activateItem === false) {\r\n        pane.addItem(item, {pending: options.pending})\r\n      } else {\r\n        pane.activateItem(item, {pending: options.pending})\r\n      }\r\n\r\n      if (options.activatePane !== false) {\r\n        pane.activate()\r\n      }\r\n\r\n      let initialColumn = 0\r\n      let initialLine = 0\r\n      if (!Number.isNaN(options.initialLine)) {\r\n        initialLine = options.initialLine\r\n      }\r\n      if (!Number.isNaN(options.initialColumn)) {\r\n        initialColumn = options.initialColumn\r\n      }\r\n      if (initialLine >= 0 || initialColumn >= 0) {\r\n        if (typeof item.setCursorBufferPosition === 'function') {\r\n          item.setCursorBufferPosition([initialLine, initialColumn])\r\n        }\r\n      }\r\n\r\n      const index = pane.getActiveItemIndex()\r\n      this.emitter.emit('did-open', {uri, pane, item, index})\r\n      if (uri) {\r\n        this.incoming.delete(uri)\r\n      }\r\n    } finally {\r\n      resolveItem()\r\n    }\r\n    return item\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getActivePaneContainer","start_line":1424,"end_line":1426,"comment":["\r\n  Section: Panes\r\n  "," Extended: Get the most recently focused pane container.",""," Returns a {Dock} or the {WorkspaceCenter}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"createItemForURI","line":1004,"func_location":"Workspace.open","func_start_line":925,"func_end_line":1079,"args":["uri","options"],"comment":["\r\n  Section: Opening\r\n  "," Essential: Opens the given URI in Atom asynchronously."," If the URI is already open, the existing item for that URI will be"," activated. If no URI is given, or no registered opener can open"," the URI, a new empty {TextEditor} will be created.",""," * `uri` (optional) A {String} containing a URI."," * `options` (optional) {Object}","   * `initialLine` A {Number} indicating which row to move the cursor to","     initially. Defaults to `0`.","   * `initialColumn` A {Number} indicating which column to move the cursor to","     initially. Defaults to `0`.","   * `split` Either 'left', 'right', 'up' or 'down'.","     If 'left', the item will be opened in leftmost pane of the current active pane's row.","     If 'right', the item will be opened in the rightmost pane of the current active pane's row. If only one pane exists in the row, a new pane will be created.","     If 'up', the item will be opened in topmost pane of the current active pane's column.","     If 'down', the item will be opened in the bottommost pane of the current active pane's column. If only one pane exists in the column, a new pane will be created.","   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on","     containing pane. Defaults to `true`.","   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}","     on containing pane. Defaults to `true`.","   * `pending` A {Boolean} indicating whether or not the item should be opened","     in a pending state. Existing pending items in a pane are replaced with","     new pending items when they are opened.","   * `searchAllPanes` A {Boolean}. If `true`, the workspace will attempt to","     activate an existing item for the given URI on any pane.","     If `false`, only the active pane will be searched for","     an existing item for the same URI. Defaults to `false`.","   * `location` (optional) A {String} containing the name of the location","     in which this item should be opened (one of \"left\", \"right\", \"bottom\",","     or \"center\"). If omitted, Atom will fall back to the last location in","     which a user has placed an item with the same URI or, if this is a new","     URI, the default location specified by the item. NOTE: This option","     should almost always be omitted to honor user preference.",""," Returns a {Promise} that resolves to the {TextEditor} for the file URI."],"code":"  async open (itemOrURI, options = {}) {\r\n    let uri, item\r\n    if (typeof itemOrURI === 'string') {\r\n      uri = this.project.resolvePath(itemOrURI)\r\n    } else if (itemOrURI) {\r\n      item = itemOrURI\r\n      if (typeof item.getURI === 'function') uri = item.getURI()\r\n    }\r\n\r\n    let resolveItem = () => {}\r\n    if (uri) {\r\n      const incomingItem = this.incoming.get(uri)\r\n      if (!incomingItem) {\r\n        this.incoming.set(uri, new Promise(resolve => { resolveItem = resolve }))\r\n      } else {\r\n        await incomingItem\r\n      }\r\n    }\r\n\r\n    try {\r\n      if (!atom.config.get('core.allowPendingPaneItems')) {\r\n        options.pending = false\r\n      }\r\n\r\n      // Avoid adding URLs as recent documents to work-around this Spotlight crash:\r\n      // https://github.com/atom/atom/issues/10071\r\n      if (uri && (!url.parse(uri).protocol || process.platform === 'win32')) {\r\n        this.applicationDelegate.addRecentDocument(uri)\r\n      }\r\n\r\n      let pane, itemExistsInWorkspace\r\n\r\n      // Try to find an existing item in the workspace.\r\n      if (item || uri) {\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else if (options.searchAllPanes) {\r\n          pane = item ? this.paneForItem(item) : this.paneForURI(uri)\r\n        } else {\r\n          // If an item with the given URI is already in the workspace, assume\r\n          // that item's pane container is the preferred location for that URI.\r\n          let container\r\n          if (uri) container = this.paneContainerForURI(uri)\r\n          if (!container) container = this.getActivePaneContainer()\r\n\r\n          // The `split` option affects where we search for the item.\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n\r\n        if (pane) {\r\n          if (item) {\r\n            itemExistsInWorkspace = pane.getItems().includes(item)\r\n          } else {\r\n            item = pane.itemForURI(uri)\r\n            itemExistsInWorkspace = item != null\r\n          }\r\n        }\r\n      }\r\n\r\n      // If we already have an item at this stage, we won't need to do an async\r\n      // lookup of the URI, so we yield the event loop to ensure this method\r\n      // is consistently asynchronous.\r\n      if (item) await Promise.resolve()\r\n\r\n      if (!itemExistsInWorkspace) {\r\n        item = item || await this.createItemForURI(uri, options)\r\n        if (!item) return\r\n\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else {\r\n          let location = options.location\r\n          if (!location && !options.split && uri && this.enablePersistence) {\r\n            location = await this.itemLocationStore.load(uri)\r\n          }\r\n          if (!location && typeof item.getDefaultLocation === 'function') {\r\n            location = item.getDefaultLocation()\r\n          }\r\n\r\n          const allowedLocations = typeof item.getAllowedLocations === 'function' ? item.getAllowedLocations() : ALL_LOCATIONS\r\n          location = allowedLocations.includes(location) ? location : allowedLocations[0]\r\n\r\n          const container = this.paneContainers[location] || this.getCenter()\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findOrCreateRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findOrCreateBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!options.pending && (pane.getPendingItem() === item)) {\r\n        pane.clearPendingItem()\r\n      }\r\n\r\n      this.itemOpened(item)\r\n\r\n      if (options.activateItem === false) {\r\n        pane.addItem(item, {pending: options.pending})\r\n      } else {\r\n        pane.activateItem(item, {pending: options.pending})\r\n      }\r\n\r\n      if (options.activatePane !== false) {\r\n        pane.activate()\r\n      }\r\n\r\n      let initialColumn = 0\r\n      let initialLine = 0\r\n      if (!Number.isNaN(options.initialLine)) {\r\n        initialLine = options.initialLine\r\n      }\r\n      if (!Number.isNaN(options.initialColumn)) {\r\n        initialColumn = options.initialColumn\r\n      }\r\n      if (initialLine >= 0 || initialColumn >= 0) {\r\n        if (typeof item.setCursorBufferPosition === 'function') {\r\n          item.setCursorBufferPosition([initialLine, initialColumn])\r\n        }\r\n      }\r\n\r\n      const index = pane.getActiveItemIndex()\r\n      this.emitter.emit('did-open', {uri, pane, item, index})\r\n      if (uri) {\r\n        this.incoming.delete(uri)\r\n      }\r\n    } finally {\r\n      resolveItem()\r\n    }\r\n    return item\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.createItemForURI","start_line":1191,"end_line":1229,"comment":[" Public: Creates a new item that corresponds to the provided URI.",""," If no URI is given, or no registered opener can open the URI, a new empty"," {TextEditor} will be created.",""," * `uri` A {String} containing a URI.",""," Returns a {Promise} that resolves to the {TextEditor} (or other item) for the given URI."],"params":["uri","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getCenter","line":1021,"func_location":"Workspace.open","func_start_line":925,"func_end_line":1079,"args":[],"comment":["\r\n  Section: Opening\r\n  "," Essential: Opens the given URI in Atom asynchronously."," If the URI is already open, the existing item for that URI will be"," activated. If no URI is given, or no registered opener can open"," the URI, a new empty {TextEditor} will be created.",""," * `uri` (optional) A {String} containing a URI."," * `options` (optional) {Object}","   * `initialLine` A {Number} indicating which row to move the cursor to","     initially. Defaults to `0`.","   * `initialColumn` A {Number} indicating which column to move the cursor to","     initially. Defaults to `0`.","   * `split` Either 'left', 'right', 'up' or 'down'.","     If 'left', the item will be opened in leftmost pane of the current active pane's row.","     If 'right', the item will be opened in the rightmost pane of the current active pane's row. If only one pane exists in the row, a new pane will be created.","     If 'up', the item will be opened in topmost pane of the current active pane's column.","     If 'down', the item will be opened in the bottommost pane of the current active pane's column. If only one pane exists in the column, a new pane will be created.","   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on","     containing pane. Defaults to `true`.","   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}","     on containing pane. Defaults to `true`.","   * `pending` A {Boolean} indicating whether or not the item should be opened","     in a pending state. Existing pending items in a pane are replaced with","     new pending items when they are opened.","   * `searchAllPanes` A {Boolean}. If `true`, the workspace will attempt to","     activate an existing item for the given URI on any pane.","     If `false`, only the active pane will be searched for","     an existing item for the same URI. Defaults to `false`.","   * `location` (optional) A {String} containing the name of the location","     in which this item should be opened (one of \"left\", \"right\", \"bottom\",","     or \"center\"). If omitted, Atom will fall back to the last location in","     which a user has placed an item with the same URI or, if this is a new","     URI, the default location specified by the item. NOTE: This option","     should almost always be omitted to honor user preference.",""," Returns a {Promise} that resolves to the {TextEditor} for the file URI."],"code":"  async open (itemOrURI, options = {}) {\r\n    let uri, item\r\n    if (typeof itemOrURI === 'string') {\r\n      uri = this.project.resolvePath(itemOrURI)\r\n    } else if (itemOrURI) {\r\n      item = itemOrURI\r\n      if (typeof item.getURI === 'function') uri = item.getURI()\r\n    }\r\n\r\n    let resolveItem = () => {}\r\n    if (uri) {\r\n      const incomingItem = this.incoming.get(uri)\r\n      if (!incomingItem) {\r\n        this.incoming.set(uri, new Promise(resolve => { resolveItem = resolve }))\r\n      } else {\r\n        await incomingItem\r\n      }\r\n    }\r\n\r\n    try {\r\n      if (!atom.config.get('core.allowPendingPaneItems')) {\r\n        options.pending = false\r\n      }\r\n\r\n      // Avoid adding URLs as recent documents to work-around this Spotlight crash:\r\n      // https://github.com/atom/atom/issues/10071\r\n      if (uri && (!url.parse(uri).protocol || process.platform === 'win32')) {\r\n        this.applicationDelegate.addRecentDocument(uri)\r\n      }\r\n\r\n      let pane, itemExistsInWorkspace\r\n\r\n      // Try to find an existing item in the workspace.\r\n      if (item || uri) {\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else if (options.searchAllPanes) {\r\n          pane = item ? this.paneForItem(item) : this.paneForURI(uri)\r\n        } else {\r\n          // If an item with the given URI is already in the workspace, assume\r\n          // that item's pane container is the preferred location for that URI.\r\n          let container\r\n          if (uri) container = this.paneContainerForURI(uri)\r\n          if (!container) container = this.getActivePaneContainer()\r\n\r\n          // The `split` option affects where we search for the item.\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n\r\n        if (pane) {\r\n          if (item) {\r\n            itemExistsInWorkspace = pane.getItems().includes(item)\r\n          } else {\r\n            item = pane.itemForURI(uri)\r\n            itemExistsInWorkspace = item != null\r\n          }\r\n        }\r\n      }\r\n\r\n      // If we already have an item at this stage, we won't need to do an async\r\n      // lookup of the URI, so we yield the event loop to ensure this method\r\n      // is consistently asynchronous.\r\n      if (item) await Promise.resolve()\r\n\r\n      if (!itemExistsInWorkspace) {\r\n        item = item || await this.createItemForURI(uri, options)\r\n        if (!item) return\r\n\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else {\r\n          let location = options.location\r\n          if (!location && !options.split && uri && this.enablePersistence) {\r\n            location = await this.itemLocationStore.load(uri)\r\n          }\r\n          if (!location && typeof item.getDefaultLocation === 'function') {\r\n            location = item.getDefaultLocation()\r\n          }\r\n\r\n          const allowedLocations = typeof item.getAllowedLocations === 'function' ? item.getAllowedLocations() : ALL_LOCATIONS\r\n          location = allowedLocations.includes(location) ? location : allowedLocations[0]\r\n\r\n          const container = this.paneContainers[location] || this.getCenter()\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findOrCreateRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findOrCreateBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!options.pending && (pane.getPendingItem() === item)) {\r\n        pane.clearPendingItem()\r\n      }\r\n\r\n      this.itemOpened(item)\r\n\r\n      if (options.activateItem === false) {\r\n        pane.addItem(item, {pending: options.pending})\r\n      } else {\r\n        pane.activateItem(item, {pending: options.pending})\r\n      }\r\n\r\n      if (options.activatePane !== false) {\r\n        pane.activate()\r\n      }\r\n\r\n      let initialColumn = 0\r\n      let initialLine = 0\r\n      if (!Number.isNaN(options.initialLine)) {\r\n        initialLine = options.initialLine\r\n      }\r\n      if (!Number.isNaN(options.initialColumn)) {\r\n        initialColumn = options.initialColumn\r\n      }\r\n      if (initialLine >= 0 || initialColumn >= 0) {\r\n        if (typeof item.setCursorBufferPosition === 'function') {\r\n          item.setCursorBufferPosition([initialLine, initialColumn])\r\n        }\r\n      }\r\n\r\n      const index = pane.getActiveItemIndex()\r\n      this.emitter.emit('did-open', {uri, pane, item, index})\r\n      if (uri) {\r\n        this.incoming.delete(uri)\r\n      }\r\n    } finally {\r\n      resolveItem()\r\n    }\r\n    return item\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getCenter","start_line":1599,"end_line":1601,"comment":["\r\n  Section: Pane Locations\r\n  "," Essential: Get the {WorkspaceCenter} at the center of the editor window."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"itemOpened","line":1044,"func_location":"Workspace.open","func_start_line":925,"func_end_line":1079,"args":["item"],"comment":["\r\n  Section: Opening\r\n  "," Essential: Opens the given URI in Atom asynchronously."," If the URI is already open, the existing item for that URI will be"," activated. If no URI is given, or no registered opener can open"," the URI, a new empty {TextEditor} will be created.",""," * `uri` (optional) A {String} containing a URI."," * `options` (optional) {Object}","   * `initialLine` A {Number} indicating which row to move the cursor to","     initially. Defaults to `0`.","   * `initialColumn` A {Number} indicating which column to move the cursor to","     initially. Defaults to `0`.","   * `split` Either 'left', 'right', 'up' or 'down'.","     If 'left', the item will be opened in leftmost pane of the current active pane's row.","     If 'right', the item will be opened in the rightmost pane of the current active pane's row. If only one pane exists in the row, a new pane will be created.","     If 'up', the item will be opened in topmost pane of the current active pane's column.","     If 'down', the item will be opened in the bottommost pane of the current active pane's column. If only one pane exists in the column, a new pane will be created.","   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on","     containing pane. Defaults to `true`.","   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}","     on containing pane. Defaults to `true`.","   * `pending` A {Boolean} indicating whether or not the item should be opened","     in a pending state. Existing pending items in a pane are replaced with","     new pending items when they are opened.","   * `searchAllPanes` A {Boolean}. If `true`, the workspace will attempt to","     activate an existing item for the given URI on any pane.","     If `false`, only the active pane will be searched for","     an existing item for the same URI. Defaults to `false`.","   * `location` (optional) A {String} containing the name of the location","     in which this item should be opened (one of \"left\", \"right\", \"bottom\",","     or \"center\"). If omitted, Atom will fall back to the last location in","     which a user has placed an item with the same URI or, if this is a new","     URI, the default location specified by the item. NOTE: This option","     should almost always be omitted to honor user preference.",""," Returns a {Promise} that resolves to the {TextEditor} for the file URI."],"code":"  async open (itemOrURI, options = {}) {\r\n    let uri, item\r\n    if (typeof itemOrURI === 'string') {\r\n      uri = this.project.resolvePath(itemOrURI)\r\n    } else if (itemOrURI) {\r\n      item = itemOrURI\r\n      if (typeof item.getURI === 'function') uri = item.getURI()\r\n    }\r\n\r\n    let resolveItem = () => {}\r\n    if (uri) {\r\n      const incomingItem = this.incoming.get(uri)\r\n      if (!incomingItem) {\r\n        this.incoming.set(uri, new Promise(resolve => { resolveItem = resolve }))\r\n      } else {\r\n        await incomingItem\r\n      }\r\n    }\r\n\r\n    try {\r\n      if (!atom.config.get('core.allowPendingPaneItems')) {\r\n        options.pending = false\r\n      }\r\n\r\n      // Avoid adding URLs as recent documents to work-around this Spotlight crash:\r\n      // https://github.com/atom/atom/issues/10071\r\n      if (uri && (!url.parse(uri).protocol || process.platform === 'win32')) {\r\n        this.applicationDelegate.addRecentDocument(uri)\r\n      }\r\n\r\n      let pane, itemExistsInWorkspace\r\n\r\n      // Try to find an existing item in the workspace.\r\n      if (item || uri) {\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else if (options.searchAllPanes) {\r\n          pane = item ? this.paneForItem(item) : this.paneForURI(uri)\r\n        } else {\r\n          // If an item with the given URI is already in the workspace, assume\r\n          // that item's pane container is the preferred location for that URI.\r\n          let container\r\n          if (uri) container = this.paneContainerForURI(uri)\r\n          if (!container) container = this.getActivePaneContainer()\r\n\r\n          // The `split` option affects where we search for the item.\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n\r\n        if (pane) {\r\n          if (item) {\r\n            itemExistsInWorkspace = pane.getItems().includes(item)\r\n          } else {\r\n            item = pane.itemForURI(uri)\r\n            itemExistsInWorkspace = item != null\r\n          }\r\n        }\r\n      }\r\n\r\n      // If we already have an item at this stage, we won't need to do an async\r\n      // lookup of the URI, so we yield the event loop to ensure this method\r\n      // is consistently asynchronous.\r\n      if (item) await Promise.resolve()\r\n\r\n      if (!itemExistsInWorkspace) {\r\n        item = item || await this.createItemForURI(uri, options)\r\n        if (!item) return\r\n\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else {\r\n          let location = options.location\r\n          if (!location && !options.split && uri && this.enablePersistence) {\r\n            location = await this.itemLocationStore.load(uri)\r\n          }\r\n          if (!location && typeof item.getDefaultLocation === 'function') {\r\n            location = item.getDefaultLocation()\r\n          }\r\n\r\n          const allowedLocations = typeof item.getAllowedLocations === 'function' ? item.getAllowedLocations() : ALL_LOCATIONS\r\n          location = allowedLocations.includes(location) ? location : allowedLocations[0]\r\n\r\n          const container = this.paneContainers[location] || this.getCenter()\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findOrCreateRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findOrCreateBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!options.pending && (pane.getPendingItem() === item)) {\r\n        pane.clearPendingItem()\r\n      }\r\n\r\n      this.itemOpened(item)\r\n\r\n      if (options.activateItem === false) {\r\n        pane.addItem(item, {pending: options.pending})\r\n      } else {\r\n        pane.activateItem(item, {pending: options.pending})\r\n      }\r\n\r\n      if (options.activatePane !== false) {\r\n        pane.activate()\r\n      }\r\n\r\n      let initialColumn = 0\r\n      let initialLine = 0\r\n      if (!Number.isNaN(options.initialLine)) {\r\n        initialLine = options.initialLine\r\n      }\r\n      if (!Number.isNaN(options.initialColumn)) {\r\n        initialColumn = options.initialColumn\r\n      }\r\n      if (initialLine >= 0 || initialColumn >= 0) {\r\n        if (typeof item.setCursorBufferPosition === 'function') {\r\n          item.setCursorBufferPosition([initialLine, initialColumn])\r\n        }\r\n      }\r\n\r\n      const index = pane.getActiveItemIndex()\r\n      this.emitter.emit('did-open', {uri, pane, item, index})\r\n      if (uri) {\r\n        this.incoming.delete(uri)\r\n      }\r\n    } finally {\r\n      resolveItem()\r\n    }\r\n    return item\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.itemOpened","start_line":1554,"end_line":1565,"comment":[" Removes the item's uri from the list of potential items to reopen."],"params":["item"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"constructor","line":73,"func_location":"AtomApplication.open","func_start_line":34,"func_end_line":85,"args":["options"],"comment":[" Public: The entry point into the Atom application."],"code":"  static open (options) {\r\n    if (!options.socketPath) {\r\n      const {username} = os.userInfo()\r\n\r\n      // Lowercasing the ATOM_HOME to make sure that we don't get multiple sockets\r\n      // on case-insensitive filesystems due to arbitrary case differences in paths.\r\n      const atomHomeUnique = path.resolve(process.env.ATOM_HOME).toLowerCase()\r\n      const hash = crypto\r\n        .createHash('sha1')\r\n        .update(options.version)\r\n        .update('|')\r\n        .update(process.arch)\r\n        .update('|')\r\n        .update(username || '')\r\n        .update('|')\r\n        .update(atomHomeUnique)\r\n\r\n      // We only keep the first 12 characters of the hash as not to have excessively long\r\n      // socket file. Note that macOS/BSD limit the length of socket file paths (see #15081).\r\n      // The replace calls convert the digest into \"URL and Filename Safe\" encoding (see RFC 4648).\r\n      const atomInstanceDigest = hash\r\n        .digest('base64')\r\n        .substring(0, 12)\r\n        .replace(/\\+/g, '-')\r\n        .replace(/\\//g, '_')\r\n\r\n      if (process.platform === 'win32') {\r\n        options.socketPath = `\\\\\\\\.\\\\pipe\\\\atom-${atomInstanceDigest}-sock`\r\n      } else {\r\n        options.socketPath = path.join(os.tmpdir(), `atom-${atomInstanceDigest}.sock`)\r\n      }\r\n    }\r\n\r\n    // FIXME: Sometimes when socketPath doesn't exist, net.connect would strangely\r\n    // take a few seconds to trigger 'error' event, it could be a bug of node\r\n    // or electron, before it's fixed we check the existence of socketPath to\r\n    // speedup startup.\r\n    if ((process.platform !== 'win32' && !fs.existsSync(options.socketPath)) ||\r\n        options.test || options.benchmark || options.benchmarkTest) {\r\n      new AtomApplication(options).initialize(options)\r\n      return\r\n    }\r\n\r\n    const client = net.connect({path: options.socketPath}, () => {\r\n      client.write(JSON.stringify(options), () => {\r\n        client.end()\r\n        app.quit()\r\n      })\r\n    })\r\n\r\n    client.on('error', () => new AtomApplication(options).initialize(options))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.constructor","start_line":91,"end_line":136,"comment":[],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"initialize","line":73,"func_location":"AtomApplication.open","func_start_line":34,"func_end_line":85,"args":["options"],"comment":[" Public: The entry point into the Atom application."],"code":"  static open (options) {\r\n    if (!options.socketPath) {\r\n      const {username} = os.userInfo()\r\n\r\n      // Lowercasing the ATOM_HOME to make sure that we don't get multiple sockets\r\n      // on case-insensitive filesystems due to arbitrary case differences in paths.\r\n      const atomHomeUnique = path.resolve(process.env.ATOM_HOME).toLowerCase()\r\n      const hash = crypto\r\n        .createHash('sha1')\r\n        .update(options.version)\r\n        .update('|')\r\n        .update(process.arch)\r\n        .update('|')\r\n        .update(username || '')\r\n        .update('|')\r\n        .update(atomHomeUnique)\r\n\r\n      // We only keep the first 12 characters of the hash as not to have excessively long\r\n      // socket file. Note that macOS/BSD limit the length of socket file paths (see #15081).\r\n      // The replace calls convert the digest into \"URL and Filename Safe\" encoding (see RFC 4648).\r\n      const atomInstanceDigest = hash\r\n        .digest('base64')\r\n        .substring(0, 12)\r\n        .replace(/\\+/g, '-')\r\n        .replace(/\\//g, '_')\r\n\r\n      if (process.platform === 'win32') {\r\n        options.socketPath = `\\\\\\\\.\\\\pipe\\\\atom-${atomInstanceDigest}-sock`\r\n      } else {\r\n        options.socketPath = path.join(os.tmpdir(), `atom-${atomInstanceDigest}.sock`)\r\n      }\r\n    }\r\n\r\n    // FIXME: Sometimes when socketPath doesn't exist, net.connect would strangely\r\n    // take a few seconds to trigger 'error' event, it could be a bug of node\r\n    // or electron, before it's fixed we check the existence of socketPath to\r\n    // speedup startup.\r\n    if ((process.platform !== 'win32' && !fs.existsSync(options.socketPath)) ||\r\n        options.test || options.benchmark || options.benchmarkTest) {\r\n      new AtomApplication(options).initialize(options)\r\n      return\r\n    }\r\n\r\n    const client = net.connect({path: options.socketPath}, () => {\r\n      client.write(JSON.stringify(options), () => {\r\n        client.end()\r\n        app.quit()\r\n      })\r\n    })\r\n\r\n    client.on('error', () => new AtomApplication(options).initialize(options))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.initialize","start_line":142,"end_line":161,"comment":[" This stuff was previously done in the constructor, but we want to be able to construct this object"," for testing purposes without booting up the world. As you add tests, feel free to move instantiation"," of these various sub-objects into the constructor, but you'll need to remove the side-effects they"," perform during their construction, adding an initialize method that you call here."],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/core-uri-handlers.js","name":"getLineColNumber","line":12,"func_location":"openFile","func_start_line":8,"func_end_line":16,"args":["line"],"code":"function openFile (atom, {query}) {\r\n  const {filename, line, column} = query\r\n\r\n  atom.workspace.open(filename, {\r\n    initialLine: getLineColNumber(line),\r\n    initialColumn: getLineColNumber(column),\r\n    searchAllPanes: true\r\n  })\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/core-uri-handlers.js","name":"getLineColNumber","start_line":3,"end_line":6,"comment":[" Converts a query string parameter for a line or column number"," to a zero-based line or column number for the Atom API."],"params":["numStr"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/core-uri-handlers.js","name":"getLineColNumber","line":13,"func_location":"openFile","func_start_line":8,"func_end_line":16,"args":["column"],"code":"function openFile (atom, {query}) {\r\n  const {filename, line, column} = query\r\n\r\n  atom.workspace.open(filename, {\r\n    initialLine: getLineColNumber(line),\r\n    initialColumn: getLineColNumber(column),\r\n    searchAllPanes: true\r\n  })\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/core-uri-handlers.js","name":"getLineColNumber","start_line":3,"end_line":6,"comment":[" Converts a query string parameter for a line or column number"," to a zero-based line or column number for the Atom API."],"params":["numStr"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"getLoadSettings","line":916,"func_location":"AtomEnvironment.openInitialEmptyEditorIfNecessary","func_start_line":914,"func_end_line":920,"args":[],"code":"  openInitialEmptyEditorIfNecessary () {\r\n    if (!this.config.get('core.openEmptyEditorOnStart')) return\r\n    const {initialPaths} = this.getLoadSettings()\r\n    if (initialPaths && initialPaths.length === 0 && this.workspace.getPaneItems().length === 0) {\r\n      return this.workspace.open(null)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.getLoadSettings","start_line":525,"end_line":527,"comment":[" Public: Get the load settings for the current window.",""," Returns an {Object} containing all the load setting key/value pairs."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"open","line":1135,"func_location":"Workspace.openLicense","func_start_line":1134,"func_end_line":1136,"args":[null],"comment":[" Open Atom's license in the active pane."],"code":"  openLicense () {\r\n    return this.open(path.join(process.resourcesPath, 'LICENSE.md'))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.open","start_line":925,"end_line":1079,"comment":["\r\n  Section: Opening\r\n  "," Essential: Opens the given URI in Atom asynchronously."," If the URI is already open, the existing item for that URI will be"," activated. If no URI is given, or no registered opener can open"," the URI, a new empty {TextEditor} will be created.",""," * `uri` (optional) A {String} containing a URI."," * `options` (optional) {Object}","   * `initialLine` A {Number} indicating which row to move the cursor to","     initially. Defaults to `0`.","   * `initialColumn` A {Number} indicating which column to move the cursor to","     initially. Defaults to `0`.","   * `split` Either 'left', 'right', 'up' or 'down'.","     If 'left', the item will be opened in leftmost pane of the current active pane's row.","     If 'right', the item will be opened in the rightmost pane of the current active pane's row. If only one pane exists in the row, a new pane will be created.","     If 'up', the item will be opened in topmost pane of the current active pane's column.","     If 'down', the item will be opened in the bottommost pane of the current active pane's column. If only one pane exists in the column, a new pane will be created.","   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on","     containing pane. Defaults to `true`.","   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}","     on containing pane. Defaults to `true`.","   * `pending` A {Boolean} indicating whether or not the item should be opened","     in a pending state. Existing pending items in a pane are replaced with","     new pending items when they are opened.","   * `searchAllPanes` A {Boolean}. If `true`, the workspace will attempt to","     activate an existing item for the given URI on any pane.","     If `false`, only the active pane will be searched for","     an existing item for the same URI. Defaults to `false`.","   * `location` (optional) A {String} containing the name of the location","     in which this item should be opened (one of \"left\", \"right\", \"bottom\",","     or \"center\"). If omitted, Atom will fall back to the last location in","     which a user has placed an item with the same URI or, if this is a new","     URI, the default location specified by the item. NOTE: This option","     should almost always be omitted to honor user preference.",""," Returns a {Promise} that resolves to the {TextEditor} for the file URI."],"params":["itemOrURI","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"sendMessage","line":254,"func_location":"AtomWindow.openLocations","func_start_line":252,"func_end_line":255,"args":[{"type":"string"},"locationsToOpen"],"code":"  async openLocations (locationsToOpen) {\r\n    await this.loadedPromise\r\n    this.sendMessage('open-locations', locationsToOpen)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"AtomWindow.sendMessage","start_line":269,"end_line":271,"comment":[],"params":["message","detail"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"pushFolderToOpen","line":1374,"func_location":"AtomEnvironment.openLocations","func_start_line":1359,"func_end_line":1414,"args":[null],"code":"  async openLocations (locations) {\r\n    const needsProjectPaths = this.project && this.project.getPaths().length === 0\r\n    const foldersToAddToProject = []\r\n    const fileLocationsToOpen = []\r\n\r\n    function pushFolderToOpen (folder) {\r\n      if (!foldersToAddToProject.includes(folder)) {\r\n        foldersToAddToProject.push(folder)\r\n      }\r\n    }\r\n\r\n    for (const location of locations) {\r\n      const {pathToOpen} = location\r\n      if (pathToOpen && (needsProjectPaths || location.forceAddToWindow)) {\r\n        if (fs.existsSync(pathToOpen)) {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(pathToOpen).getPath())\r\n        } else if (fs.existsSync(path.dirname(pathToOpen))) {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(path.dirname(pathToOpen)).getPath())\r\n        } else {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(pathToOpen).getPath())\r\n        }\r\n      }\r\n\r\n      if (!fs.isDirectorySync(pathToOpen)) {\r\n        fileLocationsToOpen.push(location)\r\n      }\r\n\r\n      if (location.hasWaitSession) this.pathsWithWaitSessions.add(pathToOpen)\r\n    }\r\n\r\n    let restoredState = false\r\n    if (foldersToAddToProject.length > 0) {\r\n      const state = await this.loadState(this.getStateKey(foldersToAddToProject))\r\n\r\n      // only restore state if this is the first path added to the project\r\n      if (state && needsProjectPaths) {\r\n        const files = fileLocationsToOpen.map((location) => location.pathToOpen)\r\n        await this.attemptRestoreProjectStateForPaths(state, foldersToAddToProject, files)\r\n        restoredState = true\r\n      } else {\r\n        for (let folder of foldersToAddToProject) {\r\n          this.project.addPath(folder)\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!restoredState) {\r\n      const fileOpenPromises = []\r\n      for (const {pathToOpen, initialLine, initialColumn} of fileLocationsToOpen) {\r\n        fileOpenPromises.push(this.workspace && this.workspace.open(pathToOpen, {initialLine, initialColumn}))\r\n      }\r\n      await Promise.all(fileOpenPromises)\r\n    }\r\n\r\n    ipcRenderer.send('window-command', 'window:locations-opened')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.openLocations.pushFolderToOpen","start_line":1364,"end_line":1368,"comment":[],"params":["folder"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"pushFolderToOpen","line":1376,"func_location":"AtomEnvironment.openLocations","func_start_line":1359,"func_end_line":1414,"args":[null],"code":"  async openLocations (locations) {\r\n    const needsProjectPaths = this.project && this.project.getPaths().length === 0\r\n    const foldersToAddToProject = []\r\n    const fileLocationsToOpen = []\r\n\r\n    function pushFolderToOpen (folder) {\r\n      if (!foldersToAddToProject.includes(folder)) {\r\n        foldersToAddToProject.push(folder)\r\n      }\r\n    }\r\n\r\n    for (const location of locations) {\r\n      const {pathToOpen} = location\r\n      if (pathToOpen && (needsProjectPaths || location.forceAddToWindow)) {\r\n        if (fs.existsSync(pathToOpen)) {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(pathToOpen).getPath())\r\n        } else if (fs.existsSync(path.dirname(pathToOpen))) {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(path.dirname(pathToOpen)).getPath())\r\n        } else {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(pathToOpen).getPath())\r\n        }\r\n      }\r\n\r\n      if (!fs.isDirectorySync(pathToOpen)) {\r\n        fileLocationsToOpen.push(location)\r\n      }\r\n\r\n      if (location.hasWaitSession) this.pathsWithWaitSessions.add(pathToOpen)\r\n    }\r\n\r\n    let restoredState = false\r\n    if (foldersToAddToProject.length > 0) {\r\n      const state = await this.loadState(this.getStateKey(foldersToAddToProject))\r\n\r\n      // only restore state if this is the first path added to the project\r\n      if (state && needsProjectPaths) {\r\n        const files = fileLocationsToOpen.map((location) => location.pathToOpen)\r\n        await this.attemptRestoreProjectStateForPaths(state, foldersToAddToProject, files)\r\n        restoredState = true\r\n      } else {\r\n        for (let folder of foldersToAddToProject) {\r\n          this.project.addPath(folder)\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!restoredState) {\r\n      const fileOpenPromises = []\r\n      for (const {pathToOpen, initialLine, initialColumn} of fileLocationsToOpen) {\r\n        fileOpenPromises.push(this.workspace && this.workspace.open(pathToOpen, {initialLine, initialColumn}))\r\n      }\r\n      await Promise.all(fileOpenPromises)\r\n    }\r\n\r\n    ipcRenderer.send('window-command', 'window:locations-opened')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.openLocations.pushFolderToOpen","start_line":1364,"end_line":1368,"comment":[],"params":["folder"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"pushFolderToOpen","line":1378,"func_location":"AtomEnvironment.openLocations","func_start_line":1359,"func_end_line":1414,"args":[null],"code":"  async openLocations (locations) {\r\n    const needsProjectPaths = this.project && this.project.getPaths().length === 0\r\n    const foldersToAddToProject = []\r\n    const fileLocationsToOpen = []\r\n\r\n    function pushFolderToOpen (folder) {\r\n      if (!foldersToAddToProject.includes(folder)) {\r\n        foldersToAddToProject.push(folder)\r\n      }\r\n    }\r\n\r\n    for (const location of locations) {\r\n      const {pathToOpen} = location\r\n      if (pathToOpen && (needsProjectPaths || location.forceAddToWindow)) {\r\n        if (fs.existsSync(pathToOpen)) {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(pathToOpen).getPath())\r\n        } else if (fs.existsSync(path.dirname(pathToOpen))) {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(path.dirname(pathToOpen)).getPath())\r\n        } else {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(pathToOpen).getPath())\r\n        }\r\n      }\r\n\r\n      if (!fs.isDirectorySync(pathToOpen)) {\r\n        fileLocationsToOpen.push(location)\r\n      }\r\n\r\n      if (location.hasWaitSession) this.pathsWithWaitSessions.add(pathToOpen)\r\n    }\r\n\r\n    let restoredState = false\r\n    if (foldersToAddToProject.length > 0) {\r\n      const state = await this.loadState(this.getStateKey(foldersToAddToProject))\r\n\r\n      // only restore state if this is the first path added to the project\r\n      if (state && needsProjectPaths) {\r\n        const files = fileLocationsToOpen.map((location) => location.pathToOpen)\r\n        await this.attemptRestoreProjectStateForPaths(state, foldersToAddToProject, files)\r\n        restoredState = true\r\n      } else {\r\n        for (let folder of foldersToAddToProject) {\r\n          this.project.addPath(folder)\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!restoredState) {\r\n      const fileOpenPromises = []\r\n      for (const {pathToOpen, initialLine, initialColumn} of fileLocationsToOpen) {\r\n        fileOpenPromises.push(this.workspace && this.workspace.open(pathToOpen, {initialLine, initialColumn}))\r\n      }\r\n      await Promise.all(fileOpenPromises)\r\n    }\r\n\r\n    ipcRenderer.send('window-command', 'window:locations-opened')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.openLocations.pushFolderToOpen","start_line":1364,"end_line":1368,"comment":[],"params":["folder"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"loadState","line":1391,"func_location":"AtomEnvironment.openLocations","func_start_line":1359,"func_end_line":1414,"args":[null],"code":"  async openLocations (locations) {\r\n    const needsProjectPaths = this.project && this.project.getPaths().length === 0\r\n    const foldersToAddToProject = []\r\n    const fileLocationsToOpen = []\r\n\r\n    function pushFolderToOpen (folder) {\r\n      if (!foldersToAddToProject.includes(folder)) {\r\n        foldersToAddToProject.push(folder)\r\n      }\r\n    }\r\n\r\n    for (const location of locations) {\r\n      const {pathToOpen} = location\r\n      if (pathToOpen && (needsProjectPaths || location.forceAddToWindow)) {\r\n        if (fs.existsSync(pathToOpen)) {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(pathToOpen).getPath())\r\n        } else if (fs.existsSync(path.dirname(pathToOpen))) {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(path.dirname(pathToOpen)).getPath())\r\n        } else {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(pathToOpen).getPath())\r\n        }\r\n      }\r\n\r\n      if (!fs.isDirectorySync(pathToOpen)) {\r\n        fileLocationsToOpen.push(location)\r\n      }\r\n\r\n      if (location.hasWaitSession) this.pathsWithWaitSessions.add(pathToOpen)\r\n    }\r\n\r\n    let restoredState = false\r\n    if (foldersToAddToProject.length > 0) {\r\n      const state = await this.loadState(this.getStateKey(foldersToAddToProject))\r\n\r\n      // only restore state if this is the first path added to the project\r\n      if (state && needsProjectPaths) {\r\n        const files = fileLocationsToOpen.map((location) => location.pathToOpen)\r\n        await this.attemptRestoreProjectStateForPaths(state, foldersToAddToProject, files)\r\n        restoredState = true\r\n      } else {\r\n        for (let folder of foldersToAddToProject) {\r\n          this.project.addPath(folder)\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!restoredState) {\r\n      const fileOpenPromises = []\r\n      for (const {pathToOpen, initialLine, initialColumn} of fileLocationsToOpen) {\r\n        fileOpenPromises.push(this.workspace && this.workspace.open(pathToOpen, {initialLine, initialColumn}))\r\n      }\r\n      await Promise.all(fileOpenPromises)\r\n    }\r\n\r\n    ipcRenderer.send('window-command', 'window:locations-opened')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.loadState","start_line":1210,"end_line":1221,"comment":[],"params":["stateKey"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"getStateKey","line":1391,"func_location":"AtomEnvironment.openLocations","func_start_line":1359,"func_end_line":1414,"args":[null],"code":"  async openLocations (locations) {\r\n    const needsProjectPaths = this.project && this.project.getPaths().length === 0\r\n    const foldersToAddToProject = []\r\n    const fileLocationsToOpen = []\r\n\r\n    function pushFolderToOpen (folder) {\r\n      if (!foldersToAddToProject.includes(folder)) {\r\n        foldersToAddToProject.push(folder)\r\n      }\r\n    }\r\n\r\n    for (const location of locations) {\r\n      const {pathToOpen} = location\r\n      if (pathToOpen && (needsProjectPaths || location.forceAddToWindow)) {\r\n        if (fs.existsSync(pathToOpen)) {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(pathToOpen).getPath())\r\n        } else if (fs.existsSync(path.dirname(pathToOpen))) {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(path.dirname(pathToOpen)).getPath())\r\n        } else {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(pathToOpen).getPath())\r\n        }\r\n      }\r\n\r\n      if (!fs.isDirectorySync(pathToOpen)) {\r\n        fileLocationsToOpen.push(location)\r\n      }\r\n\r\n      if (location.hasWaitSession) this.pathsWithWaitSessions.add(pathToOpen)\r\n    }\r\n\r\n    let restoredState = false\r\n    if (foldersToAddToProject.length > 0) {\r\n      const state = await this.loadState(this.getStateKey(foldersToAddToProject))\r\n\r\n      // only restore state if this is the first path added to the project\r\n      if (state && needsProjectPaths) {\r\n        const files = fileLocationsToOpen.map((location) => location.pathToOpen)\r\n        await this.attemptRestoreProjectStateForPaths(state, foldersToAddToProject, files)\r\n        restoredState = true\r\n      } else {\r\n        for (let folder of foldersToAddToProject) {\r\n          this.project.addPath(folder)\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!restoredState) {\r\n      const fileOpenPromises = []\r\n      for (const {pathToOpen, initialLine, initialColumn} of fileLocationsToOpen) {\r\n        fileOpenPromises.push(this.workspace && this.workspace.open(pathToOpen, {initialLine, initialColumn}))\r\n      }\r\n      await Promise.all(fileOpenPromises)\r\n    }\r\n\r\n    ipcRenderer.send('window-command', 'window:locations-opened')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.getStateKey","start_line":1279,"end_line":1286,"comment":[],"params":["paths"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"attemptRestoreProjectStateForPaths","line":1396,"func_location":"AtomEnvironment.openLocations","func_start_line":1359,"func_end_line":1414,"args":["state","foldersToAddToProject","files"],"code":"  async openLocations (locations) {\r\n    const needsProjectPaths = this.project && this.project.getPaths().length === 0\r\n    const foldersToAddToProject = []\r\n    const fileLocationsToOpen = []\r\n\r\n    function pushFolderToOpen (folder) {\r\n      if (!foldersToAddToProject.includes(folder)) {\r\n        foldersToAddToProject.push(folder)\r\n      }\r\n    }\r\n\r\n    for (const location of locations) {\r\n      const {pathToOpen} = location\r\n      if (pathToOpen && (needsProjectPaths || location.forceAddToWindow)) {\r\n        if (fs.existsSync(pathToOpen)) {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(pathToOpen).getPath())\r\n        } else if (fs.existsSync(path.dirname(pathToOpen))) {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(path.dirname(pathToOpen)).getPath())\r\n        } else {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(pathToOpen).getPath())\r\n        }\r\n      }\r\n\r\n      if (!fs.isDirectorySync(pathToOpen)) {\r\n        fileLocationsToOpen.push(location)\r\n      }\r\n\r\n      if (location.hasWaitSession) this.pathsWithWaitSessions.add(pathToOpen)\r\n    }\r\n\r\n    let restoredState = false\r\n    if (foldersToAddToProject.length > 0) {\r\n      const state = await this.loadState(this.getStateKey(foldersToAddToProject))\r\n\r\n      // only restore state if this is the first path added to the project\r\n      if (state && needsProjectPaths) {\r\n        const files = fileLocationsToOpen.map((location) => location.pathToOpen)\r\n        await this.attemptRestoreProjectStateForPaths(state, foldersToAddToProject, files)\r\n        restoredState = true\r\n      } else {\r\n        for (let folder of foldersToAddToProject) {\r\n          this.project.addPath(folder)\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!restoredState) {\r\n      const fileOpenPromises = []\r\n      for (const {pathToOpen, initialLine, initialColumn} of fileLocationsToOpen) {\r\n        fileOpenPromises.push(this.workspace && this.workspace.open(pathToOpen, {initialLine, initialColumn}))\r\n      }\r\n      await Promise.all(fileOpenPromises)\r\n    }\r\n\r\n    ipcRenderer.send('window-command', 'window:locations-opened')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.attemptRestoreProjectStateForPaths","start_line":1129,"end_line":1181,"comment":[],"params":["state","projectPaths","filesToOpen"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"getLastFocusedWindow","line":1032,"func_location":"AtomApplication.openPackageUriHandler","func_start_line":1027,"func_end_line":1069,"args":[null],"code":"  openPackageUriHandler (url, parsedUrl, devMode, safeMode, env) {\r\n    let bestWindow\r\n\r\n    if (parsedUrl.host === 'core') {\r\n      const predicate = require('../core-uri-handlers').windowPredicate(parsedUrl)\r\n      bestWindow = this.getLastFocusedWindow(win => !win.isSpecWindow() && predicate(win))\r\n    }\r\n\r\n    if (!bestWindow) bestWindow = this.getLastFocusedWindow(win => !win.isSpecWindow())\r\n\r\n    if (bestWindow) {\r\n      bestWindow.sendURIMessage(url)\r\n      bestWindow.focus()\r\n    } else {\r\n      let windowInitializationScript\r\n      let {resourcePath} = this\r\n      if (devMode) {\r\n        try {\r\n          windowInitializationScript = require.resolve(\r\n            path.join(this.devResourcePath, 'src', 'initialize-application-window')\r\n          )\r\n          resourcePath = this.devResourcePath\r\n        } catch (error) {}\r\n      }\r\n\r\n      if (!windowInitializationScript) {\r\n        windowInitializationScript = require.resolve('../initialize-application-window')\r\n      }\r\n\r\n      const windowDimensions = this.getDimensionsForNewWindow()\r\n      const window = new AtomWindow(this, this.fileRecoveryService, {\r\n        resourcePath,\r\n        windowInitializationScript,\r\n        devMode,\r\n        safeMode,\r\n        windowDimensions,\r\n        env\r\n      })\r\n      this.addWindow(window)\r\n      window.on('window:loaded', () => window.sendURIMessage(url))\r\n      return window\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.getLastFocusedWindow","start_line":325,"end_line":327,"comment":[],"params":["predicate"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"getLastFocusedWindow","line":1035,"func_location":"AtomApplication.openPackageUriHandler","func_start_line":1027,"func_end_line":1069,"args":[null],"code":"  openPackageUriHandler (url, parsedUrl, devMode, safeMode, env) {\r\n    let bestWindow\r\n\r\n    if (parsedUrl.host === 'core') {\r\n      const predicate = require('../core-uri-handlers').windowPredicate(parsedUrl)\r\n      bestWindow = this.getLastFocusedWindow(win => !win.isSpecWindow() && predicate(win))\r\n    }\r\n\r\n    if (!bestWindow) bestWindow = this.getLastFocusedWindow(win => !win.isSpecWindow())\r\n\r\n    if (bestWindow) {\r\n      bestWindow.sendURIMessage(url)\r\n      bestWindow.focus()\r\n    } else {\r\n      let windowInitializationScript\r\n      let {resourcePath} = this\r\n      if (devMode) {\r\n        try {\r\n          windowInitializationScript = require.resolve(\r\n            path.join(this.devResourcePath, 'src', 'initialize-application-window')\r\n          )\r\n          resourcePath = this.devResourcePath\r\n        } catch (error) {}\r\n      }\r\n\r\n      if (!windowInitializationScript) {\r\n        windowInitializationScript = require.resolve('../initialize-application-window')\r\n      }\r\n\r\n      const windowDimensions = this.getDimensionsForNewWindow()\r\n      const window = new AtomWindow(this, this.fileRecoveryService, {\r\n        resourcePath,\r\n        windowInitializationScript,\r\n        devMode,\r\n        safeMode,\r\n        windowDimensions,\r\n        env\r\n      })\r\n      this.addWindow(window)\r\n      window.on('window:loaded', () => window.sendURIMessage(url))\r\n      return window\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.getLastFocusedWindow","start_line":325,"end_line":327,"comment":[],"params":["predicate"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"getDimensionsForNewWindow","line":1056,"func_location":"AtomApplication.openPackageUriHandler","func_start_line":1027,"func_end_line":1069,"args":[],"code":"  openPackageUriHandler (url, parsedUrl, devMode, safeMode, env) {\r\n    let bestWindow\r\n\r\n    if (parsedUrl.host === 'core') {\r\n      const predicate = require('../core-uri-handlers').windowPredicate(parsedUrl)\r\n      bestWindow = this.getLastFocusedWindow(win => !win.isSpecWindow() && predicate(win))\r\n    }\r\n\r\n    if (!bestWindow) bestWindow = this.getLastFocusedWindow(win => !win.isSpecWindow())\r\n\r\n    if (bestWindow) {\r\n      bestWindow.sendURIMessage(url)\r\n      bestWindow.focus()\r\n    } else {\r\n      let windowInitializationScript\r\n      let {resourcePath} = this\r\n      if (devMode) {\r\n        try {\r\n          windowInitializationScript = require.resolve(\r\n            path.join(this.devResourcePath, 'src', 'initialize-application-window')\r\n          )\r\n          resourcePath = this.devResourcePath\r\n        } catch (error) {}\r\n      }\r\n\r\n      if (!windowInitializationScript) {\r\n        windowInitializationScript = require.resolve('../initialize-application-window')\r\n      }\r\n\r\n      const windowDimensions = this.getDimensionsForNewWindow()\r\n      const window = new AtomWindow(this, this.fileRecoveryService, {\r\n        resourcePath,\r\n        windowInitializationScript,\r\n        devMode,\r\n        safeMode,\r\n        windowDimensions,\r\n        env\r\n      })\r\n      this.addWindow(window)\r\n      window.on('window:loaded', () => window.sendURIMessage(url))\r\n      return window\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.getDimensionsForNewWindow","start_line":763,"end_line":773,"comment":[" Get the dimensions for opening a new window by cascading as appropriate to"," the platform."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"addWindow","line":1065,"func_location":"AtomApplication.openPackageUriHandler","func_start_line":1027,"func_end_line":1069,"args":["window"],"code":"  openPackageUriHandler (url, parsedUrl, devMode, safeMode, env) {\r\n    let bestWindow\r\n\r\n    if (parsedUrl.host === 'core') {\r\n      const predicate = require('../core-uri-handlers').windowPredicate(parsedUrl)\r\n      bestWindow = this.getLastFocusedWindow(win => !win.isSpecWindow() && predicate(win))\r\n    }\r\n\r\n    if (!bestWindow) bestWindow = this.getLastFocusedWindow(win => !win.isSpecWindow())\r\n\r\n    if (bestWindow) {\r\n      bestWindow.sendURIMessage(url)\r\n      bestWindow.focus()\r\n    } else {\r\n      let windowInitializationScript\r\n      let {resourcePath} = this\r\n      if (devMode) {\r\n        try {\r\n          windowInitializationScript = require.resolve(\r\n            path.join(this.devResourcePath, 'src', 'initialize-application-window')\r\n          )\r\n          resourcePath = this.devResourcePath\r\n        } catch (error) {}\r\n      }\r\n\r\n      if (!windowInitializationScript) {\r\n        windowInitializationScript = require.resolve('../initialize-application-window')\r\n      }\r\n\r\n      const windowDimensions = this.getDimensionsForNewWindow()\r\n      const window = new AtomWindow(this, this.fileRecoveryService, {\r\n        resourcePath,\r\n        windowInitializationScript,\r\n        devMode,\r\n        safeMode,\r\n        windowDimensions,\r\n        env\r\n      })\r\n      this.addWindow(window)\r\n      window.on('window:loaded', () => window.sendURIMessage(url))\r\n      return window\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.addWindow","start_line":299,"end_line":319,"comment":[" Public: Adds the {AtomWindow} to the global window list."],"params":["window"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"getPackageManager","line":1078,"func_location":"AtomApplication.openPackageUrlMain","func_start_line":1077,"func_end_line":1092,"args":["packageName"],"code":"  openPackageUrlMain (packageName, packageUrlMain, urlToOpen, devMode, safeMode, env) {\r\n    const packagePath = this.getPackageManager(devMode).resolvePackagePath(packageName)\r\n    const windowInitializationScript = path.resolve(packagePath, packageUrlMain)\r\n    const windowDimensions = this.getDimensionsForNewWindow()\r\n    const window = new AtomWindow(this, this.fileRecoveryService, {\r\n      windowInitializationScript,\r\n      resourcePath: this.resourcePath,\r\n      devMode,\r\n      safeMode,\r\n      urlToOpen,\r\n      windowDimensions,\r\n      env\r\n    })\r\n    this.addWindow(window)\r\n    return window\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.getPackageManager","start_line":1094,"end_line":1106,"comment":[],"params":["devMode"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"getDimensionsForNewWindow","line":1080,"func_location":"AtomApplication.openPackageUrlMain","func_start_line":1077,"func_end_line":1092,"args":[],"code":"  openPackageUrlMain (packageName, packageUrlMain, urlToOpen, devMode, safeMode, env) {\r\n    const packagePath = this.getPackageManager(devMode).resolvePackagePath(packageName)\r\n    const windowInitializationScript = path.resolve(packagePath, packageUrlMain)\r\n    const windowDimensions = this.getDimensionsForNewWindow()\r\n    const window = new AtomWindow(this, this.fileRecoveryService, {\r\n      windowInitializationScript,\r\n      resourcePath: this.resourcePath,\r\n      devMode,\r\n      safeMode,\r\n      urlToOpen,\r\n      windowDimensions,\r\n      env\r\n    })\r\n    this.addWindow(window)\r\n    return window\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.getDimensionsForNewWindow","start_line":763,"end_line":773,"comment":[" Get the dimensions for opening a new window by cascading as appropriate to"," the platform."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"addWindow","line":1090,"func_location":"AtomApplication.openPackageUrlMain","func_start_line":1077,"func_end_line":1092,"args":["window"],"code":"  openPackageUrlMain (packageName, packageUrlMain, urlToOpen, devMode, safeMode, env) {\r\n    const packagePath = this.getPackageManager(devMode).resolvePackagePath(packageName)\r\n    const windowInitializationScript = path.resolve(packagePath, packageUrlMain)\r\n    const windowDimensions = this.getDimensionsForNewWindow()\r\n    const window = new AtomWindow(this, this.fileRecoveryService, {\r\n      windowInitializationScript,\r\n      resourcePath: this.resourcePath,\r\n      devMode,\r\n      safeMode,\r\n      urlToOpen,\r\n      windowDimensions,\r\n      env\r\n    })\r\n    this.addWindow(window)\r\n    return window\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.addWindow","start_line":299,"end_line":319,"comment":[" Public: Adds the {AtomWindow} to the global window list."],"params":["window"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"openLocations","line":249,"func_location":"AtomWindow.openPath","func_start_line":248,"func_end_line":250,"args":[null],"code":"  openPath (pathToOpen, initialLine, initialColumn) {\r\n    return this.openLocations([{pathToOpen, initialLine, initialColumn}])\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"AtomWindow.openLocations","start_line":252,"end_line":255,"comment":[],"params":["locationsToOpen"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"openPaths","line":799,"func_location":"AtomApplication.openPath","func_start_line":786,"func_end_line":812},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.openPaths","start_line":825,"end_line":925,"comment":[" Public: Opens multiple paths, in existing windows if possible.",""," options -","   :pathsToOpen - The array of file paths to open","   :pidToKillWhenClosed - The integer of the pid to kill","   :newWindow - Boolean of whether this should be opened in a new window.","   :devMode - Boolean to control the opened window's dev mode.","   :safeMode - Boolean to control the opened window's safe mode.","   :windowDimensions - Object with height and width keys.","   :window - {AtomWindow} to open file paths in.","   :addToLastWindow - Boolean of whether this should be opened in last focused window."],"params":[["initialPaths","pathsToOpen","executedFrom","pidToKillWhenClosed","newWindow","devMode","safeMode","windowDimensions","profileStartup","window","clearWindowState","addToLastWindow","env"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"parsePathToOpen","line":848,"func_location":"AtomApplication.openPaths","func_start_line":825,"func_end_line":925,"args":["pathsToOpen.i","executedFrom","addToLastWindow"],"comment":[" Public: Opens multiple paths, in existing windows if possible.",""," options -","   :pathsToOpen - The array of file paths to open","   :pidToKillWhenClosed - The integer of the pid to kill","   :newWindow - Boolean of whether this should be opened in a new window.","   :devMode - Boolean to control the opened window's dev mode.","   :safeMode - Boolean to control the opened window's safe mode.","   :windowDimensions - Object with height and width keys.","   :window - {AtomWindow} to open file paths in.","   :addToLastWindow - Boolean of whether this should be opened in last focused window."],"code":"  openPaths ({\r\n    initialPaths,\r\n    pathsToOpen,\r\n    executedFrom,\r\n    pidToKillWhenClosed,\r\n    newWindow,\r\n    devMode,\r\n    safeMode,\r\n    windowDimensions,\r\n    profileStartup,\r\n    window,\r\n    clearWindowState,\r\n    addToLastWindow,\r\n    env\r\n  } = {}) {\r\n    if (!pathsToOpen || pathsToOpen.length === 0) return\r\n    if (!env) env = process.env\r\n    devMode = Boolean(devMode)\r\n    safeMode = Boolean(safeMode)\r\n    clearWindowState = Boolean(clearWindowState)\r\n\r\n    const locationsToOpen = []\r\n    for (let i = 0; i < pathsToOpen.length; i++) {\r\n      const location = this.parsePathToOpen(pathsToOpen[i], executedFrom, addToLastWindow)\r\n      location.forceAddToWindow = addToLastWindow\r\n      location.hasWaitSession = pidToKillWhenClosed != null\r\n      locationsToOpen.push(location)\r\n      pathsToOpen[i] = location.pathToOpen\r\n    }\r\n\r\n    let existingWindow\r\n    if (!newWindow) {\r\n      existingWindow = this.windowForPaths(pathsToOpen, devMode)\r\n      if (!existingWindow) {\r\n        let lastWindow = window || this.getLastFocusedWindow()\r\n        if (lastWindow && lastWindow.devMode === devMode) {\r\n          if (addToLastWindow || (\r\n              locationsToOpen.every(({stat}) => stat && stat.isFile()) ||\r\n              (locationsToOpen.some(({stat}) => stat && stat.isDirectory()) && !lastWindow.hasProjectPath()))) {\r\n            existingWindow = lastWindow\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    let openedWindow\r\n    if (existingWindow) {\r\n      openedWindow = existingWindow\r\n      openedWindow.openLocations(locationsToOpen)\r\n      if (openedWindow.isMinimized()) {\r\n        openedWindow.restore()\r\n      } else {\r\n        openedWindow.focus()\r\n      }\r\n      openedWindow.replaceEnvironment(env)\r\n    } else {\r\n      let resourcePath, windowInitializationScript\r\n      if (devMode) {\r\n        try {\r\n          windowInitializationScript = require.resolve(\r\n            path.join(this.devResourcePath, 'src', 'initialize-application-window')\r\n          )\r\n          resourcePath = this.devResourcePath\r\n        } catch (error) {}\r\n      }\r\n\r\n      if (!windowInitializationScript) {\r\n        windowInitializationScript = require.resolve('../initialize-application-window')\r\n      }\r\n      if (!resourcePath) resourcePath = this.resourcePath\r\n      if (!windowDimensions) windowDimensions = this.getDimensionsForNewWindow()\r\n\r\n      openedWindow = new AtomWindow(this, this.fileRecoveryService, {\r\n        initialPaths,\r\n        locationsToOpen,\r\n        windowInitializationScript,\r\n        resourcePath,\r\n        devMode,\r\n        safeMode,\r\n        windowDimensions,\r\n        profileStartup,\r\n        clearWindowState,\r\n        env\r\n      })\r\n      this.addWindow(openedWindow)\r\n      openedWindow.focus()\r\n    }\r\n\r\n    if (pidToKillWhenClosed != null) {\r\n      if (!this.waitSessionsByWindow.has(openedWindow)) {\r\n        this.waitSessionsByWindow.set(openedWindow, [])\r\n      }\r\n      this.waitSessionsByWindow.get(openedWindow).push({\r\n        pid: pidToKillWhenClosed,\r\n        remainingPaths: new Set(pathsToOpen)\r\n      })\r\n    }\r\n\r\n    openedWindow.browserWindow.once('closed', () => this.killProcessesForWindow(openedWindow))\r\n    return openedWindow\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.parsePathToOpen","start_line":1267,"end_line":1293,"comment":[],"params":["pathToOpen","executedFrom"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"windowForPaths","line":857,"func_location":"AtomApplication.openPaths","func_start_line":825,"func_end_line":925,"args":["pathsToOpen","devMode"],"comment":[" Public: Opens multiple paths, in existing windows if possible.",""," options -","   :pathsToOpen - The array of file paths to open","   :pidToKillWhenClosed - The integer of the pid to kill","   :newWindow - Boolean of whether this should be opened in a new window.","   :devMode - Boolean to control the opened window's dev mode.","   :safeMode - Boolean to control the opened window's safe mode.","   :windowDimensions - Object with height and width keys.","   :window - {AtomWindow} to open file paths in.","   :addToLastWindow - Boolean of whether this should be opened in last focused window."],"code":"  openPaths ({\r\n    initialPaths,\r\n    pathsToOpen,\r\n    executedFrom,\r\n    pidToKillWhenClosed,\r\n    newWindow,\r\n    devMode,\r\n    safeMode,\r\n    windowDimensions,\r\n    profileStartup,\r\n    window,\r\n    clearWindowState,\r\n    addToLastWindow,\r\n    env\r\n  } = {}) {\r\n    if (!pathsToOpen || pathsToOpen.length === 0) return\r\n    if (!env) env = process.env\r\n    devMode = Boolean(devMode)\r\n    safeMode = Boolean(safeMode)\r\n    clearWindowState = Boolean(clearWindowState)\r\n\r\n    const locationsToOpen = []\r\n    for (let i = 0; i < pathsToOpen.length; i++) {\r\n      const location = this.parsePathToOpen(pathsToOpen[i], executedFrom, addToLastWindow)\r\n      location.forceAddToWindow = addToLastWindow\r\n      location.hasWaitSession = pidToKillWhenClosed != null\r\n      locationsToOpen.push(location)\r\n      pathsToOpen[i] = location.pathToOpen\r\n    }\r\n\r\n    let existingWindow\r\n    if (!newWindow) {\r\n      existingWindow = this.windowForPaths(pathsToOpen, devMode)\r\n      if (!existingWindow) {\r\n        let lastWindow = window || this.getLastFocusedWindow()\r\n        if (lastWindow && lastWindow.devMode === devMode) {\r\n          if (addToLastWindow || (\r\n              locationsToOpen.every(({stat}) => stat && stat.isFile()) ||\r\n              (locationsToOpen.some(({stat}) => stat && stat.isDirectory()) && !lastWindow.hasProjectPath()))) {\r\n            existingWindow = lastWindow\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    let openedWindow\r\n    if (existingWindow) {\r\n      openedWindow = existingWindow\r\n      openedWindow.openLocations(locationsToOpen)\r\n      if (openedWindow.isMinimized()) {\r\n        openedWindow.restore()\r\n      } else {\r\n        openedWindow.focus()\r\n      }\r\n      openedWindow.replaceEnvironment(env)\r\n    } else {\r\n      let resourcePath, windowInitializationScript\r\n      if (devMode) {\r\n        try {\r\n          windowInitializationScript = require.resolve(\r\n            path.join(this.devResourcePath, 'src', 'initialize-application-window')\r\n          )\r\n          resourcePath = this.devResourcePath\r\n        } catch (error) {}\r\n      }\r\n\r\n      if (!windowInitializationScript) {\r\n        windowInitializationScript = require.resolve('../initialize-application-window')\r\n      }\r\n      if (!resourcePath) resourcePath = this.resourcePath\r\n      if (!windowDimensions) windowDimensions = this.getDimensionsForNewWindow()\r\n\r\n      openedWindow = new AtomWindow(this, this.fileRecoveryService, {\r\n        initialPaths,\r\n        locationsToOpen,\r\n        windowInitializationScript,\r\n        resourcePath,\r\n        devMode,\r\n        safeMode,\r\n        windowDimensions,\r\n        profileStartup,\r\n        clearWindowState,\r\n        env\r\n      })\r\n      this.addWindow(openedWindow)\r\n      openedWindow.focus()\r\n    }\r\n\r\n    if (pidToKillWhenClosed != null) {\r\n      if (!this.waitSessionsByWindow.has(openedWindow)) {\r\n        this.waitSessionsByWindow.set(openedWindow, [])\r\n      }\r\n      this.waitSessionsByWindow.get(openedWindow).push({\r\n        pid: pidToKillWhenClosed,\r\n        remainingPaths: new Set(pathsToOpen)\r\n      })\r\n    }\r\n\r\n    openedWindow.browserWindow.once('closed', () => this.killProcessesForWindow(openedWindow))\r\n    return openedWindow\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.windowForPaths","start_line":732,"end_line":736,"comment":[" Returns the {AtomWindow} for the given paths."],"params":["pathsToOpen","devMode"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"getLastFocusedWindow","line":859,"func_location":"AtomApplication.openPaths","func_start_line":825,"func_end_line":925,"args":[],"comment":[" Public: Opens multiple paths, in existing windows if possible.",""," options -","   :pathsToOpen - The array of file paths to open","   :pidToKillWhenClosed - The integer of the pid to kill","   :newWindow - Boolean of whether this should be opened in a new window.","   :devMode - Boolean to control the opened window's dev mode.","   :safeMode - Boolean to control the opened window's safe mode.","   :windowDimensions - Object with height and width keys.","   :window - {AtomWindow} to open file paths in.","   :addToLastWindow - Boolean of whether this should be opened in last focused window."],"code":"  openPaths ({\r\n    initialPaths,\r\n    pathsToOpen,\r\n    executedFrom,\r\n    pidToKillWhenClosed,\r\n    newWindow,\r\n    devMode,\r\n    safeMode,\r\n    windowDimensions,\r\n    profileStartup,\r\n    window,\r\n    clearWindowState,\r\n    addToLastWindow,\r\n    env\r\n  } = {}) {\r\n    if (!pathsToOpen || pathsToOpen.length === 0) return\r\n    if (!env) env = process.env\r\n    devMode = Boolean(devMode)\r\n    safeMode = Boolean(safeMode)\r\n    clearWindowState = Boolean(clearWindowState)\r\n\r\n    const locationsToOpen = []\r\n    for (let i = 0; i < pathsToOpen.length; i++) {\r\n      const location = this.parsePathToOpen(pathsToOpen[i], executedFrom, addToLastWindow)\r\n      location.forceAddToWindow = addToLastWindow\r\n      location.hasWaitSession = pidToKillWhenClosed != null\r\n      locationsToOpen.push(location)\r\n      pathsToOpen[i] = location.pathToOpen\r\n    }\r\n\r\n    let existingWindow\r\n    if (!newWindow) {\r\n      existingWindow = this.windowForPaths(pathsToOpen, devMode)\r\n      if (!existingWindow) {\r\n        let lastWindow = window || this.getLastFocusedWindow()\r\n        if (lastWindow && lastWindow.devMode === devMode) {\r\n          if (addToLastWindow || (\r\n              locationsToOpen.every(({stat}) => stat && stat.isFile()) ||\r\n              (locationsToOpen.some(({stat}) => stat && stat.isDirectory()) && !lastWindow.hasProjectPath()))) {\r\n            existingWindow = lastWindow\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    let openedWindow\r\n    if (existingWindow) {\r\n      openedWindow = existingWindow\r\n      openedWindow.openLocations(locationsToOpen)\r\n      if (openedWindow.isMinimized()) {\r\n        openedWindow.restore()\r\n      } else {\r\n        openedWindow.focus()\r\n      }\r\n      openedWindow.replaceEnvironment(env)\r\n    } else {\r\n      let resourcePath, windowInitializationScript\r\n      if (devMode) {\r\n        try {\r\n          windowInitializationScript = require.resolve(\r\n            path.join(this.devResourcePath, 'src', 'initialize-application-window')\r\n          )\r\n          resourcePath = this.devResourcePath\r\n        } catch (error) {}\r\n      }\r\n\r\n      if (!windowInitializationScript) {\r\n        windowInitializationScript = require.resolve('../initialize-application-window')\r\n      }\r\n      if (!resourcePath) resourcePath = this.resourcePath\r\n      if (!windowDimensions) windowDimensions = this.getDimensionsForNewWindow()\r\n\r\n      openedWindow = new AtomWindow(this, this.fileRecoveryService, {\r\n        initialPaths,\r\n        locationsToOpen,\r\n        windowInitializationScript,\r\n        resourcePath,\r\n        devMode,\r\n        safeMode,\r\n        windowDimensions,\r\n        profileStartup,\r\n        clearWindowState,\r\n        env\r\n      })\r\n      this.addWindow(openedWindow)\r\n      openedWindow.focus()\r\n    }\r\n\r\n    if (pidToKillWhenClosed != null) {\r\n      if (!this.waitSessionsByWindow.has(openedWindow)) {\r\n        this.waitSessionsByWindow.set(openedWindow, [])\r\n      }\r\n      this.waitSessionsByWindow.get(openedWindow).push({\r\n        pid: pidToKillWhenClosed,\r\n        remainingPaths: new Set(pathsToOpen)\r\n      })\r\n    }\r\n\r\n    openedWindow.browserWindow.once('closed', () => this.killProcessesForWindow(openedWindow))\r\n    return openedWindow\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.getLastFocusedWindow","start_line":325,"end_line":327,"comment":[],"params":["predicate"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"getDimensionsForNewWindow","line":895,"func_location":"AtomApplication.openPaths","func_start_line":825,"func_end_line":925,"args":[],"comment":[" Public: Opens multiple paths, in existing windows if possible.",""," options -","   :pathsToOpen - The array of file paths to open","   :pidToKillWhenClosed - The integer of the pid to kill","   :newWindow - Boolean of whether this should be opened in a new window.","   :devMode - Boolean to control the opened window's dev mode.","   :safeMode - Boolean to control the opened window's safe mode.","   :windowDimensions - Object with height and width keys.","   :window - {AtomWindow} to open file paths in.","   :addToLastWindow - Boolean of whether this should be opened in last focused window."],"code":"  openPaths ({\r\n    initialPaths,\r\n    pathsToOpen,\r\n    executedFrom,\r\n    pidToKillWhenClosed,\r\n    newWindow,\r\n    devMode,\r\n    safeMode,\r\n    windowDimensions,\r\n    profileStartup,\r\n    window,\r\n    clearWindowState,\r\n    addToLastWindow,\r\n    env\r\n  } = {}) {\r\n    if (!pathsToOpen || pathsToOpen.length === 0) return\r\n    if (!env) env = process.env\r\n    devMode = Boolean(devMode)\r\n    safeMode = Boolean(safeMode)\r\n    clearWindowState = Boolean(clearWindowState)\r\n\r\n    const locationsToOpen = []\r\n    for (let i = 0; i < pathsToOpen.length; i++) {\r\n      const location = this.parsePathToOpen(pathsToOpen[i], executedFrom, addToLastWindow)\r\n      location.forceAddToWindow = addToLastWindow\r\n      location.hasWaitSession = pidToKillWhenClosed != null\r\n      locationsToOpen.push(location)\r\n      pathsToOpen[i] = location.pathToOpen\r\n    }\r\n\r\n    let existingWindow\r\n    if (!newWindow) {\r\n      existingWindow = this.windowForPaths(pathsToOpen, devMode)\r\n      if (!existingWindow) {\r\n        let lastWindow = window || this.getLastFocusedWindow()\r\n        if (lastWindow && lastWindow.devMode === devMode) {\r\n          if (addToLastWindow || (\r\n              locationsToOpen.every(({stat}) => stat && stat.isFile()) ||\r\n              (locationsToOpen.some(({stat}) => stat && stat.isDirectory()) && !lastWindow.hasProjectPath()))) {\r\n            existingWindow = lastWindow\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    let openedWindow\r\n    if (existingWindow) {\r\n      openedWindow = existingWindow\r\n      openedWindow.openLocations(locationsToOpen)\r\n      if (openedWindow.isMinimized()) {\r\n        openedWindow.restore()\r\n      } else {\r\n        openedWindow.focus()\r\n      }\r\n      openedWindow.replaceEnvironment(env)\r\n    } else {\r\n      let resourcePath, windowInitializationScript\r\n      if (devMode) {\r\n        try {\r\n          windowInitializationScript = require.resolve(\r\n            path.join(this.devResourcePath, 'src', 'initialize-application-window')\r\n          )\r\n          resourcePath = this.devResourcePath\r\n        } catch (error) {}\r\n      }\r\n\r\n      if (!windowInitializationScript) {\r\n        windowInitializationScript = require.resolve('../initialize-application-window')\r\n      }\r\n      if (!resourcePath) resourcePath = this.resourcePath\r\n      if (!windowDimensions) windowDimensions = this.getDimensionsForNewWindow()\r\n\r\n      openedWindow = new AtomWindow(this, this.fileRecoveryService, {\r\n        initialPaths,\r\n        locationsToOpen,\r\n        windowInitializationScript,\r\n        resourcePath,\r\n        devMode,\r\n        safeMode,\r\n        windowDimensions,\r\n        profileStartup,\r\n        clearWindowState,\r\n        env\r\n      })\r\n      this.addWindow(openedWindow)\r\n      openedWindow.focus()\r\n    }\r\n\r\n    if (pidToKillWhenClosed != null) {\r\n      if (!this.waitSessionsByWindow.has(openedWindow)) {\r\n        this.waitSessionsByWindow.set(openedWindow, [])\r\n      }\r\n      this.waitSessionsByWindow.get(openedWindow).push({\r\n        pid: pidToKillWhenClosed,\r\n        remainingPaths: new Set(pathsToOpen)\r\n      })\r\n    }\r\n\r\n    openedWindow.browserWindow.once('closed', () => this.killProcessesForWindow(openedWindow))\r\n    return openedWindow\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.getDimensionsForNewWindow","start_line":763,"end_line":773,"comment":[" Get the dimensions for opening a new window by cascading as appropriate to"," the platform."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"addWindow","line":909,"func_location":"AtomApplication.openPaths","func_start_line":825,"func_end_line":925,"args":["openedWindow"],"comment":[" Public: Opens multiple paths, in existing windows if possible.",""," options -","   :pathsToOpen - The array of file paths to open","   :pidToKillWhenClosed - The integer of the pid to kill","   :newWindow - Boolean of whether this should be opened in a new window.","   :devMode - Boolean to control the opened window's dev mode.","   :safeMode - Boolean to control the opened window's safe mode.","   :windowDimensions - Object with height and width keys.","   :window - {AtomWindow} to open file paths in.","   :addToLastWindow - Boolean of whether this should be opened in last focused window."],"code":"  openPaths ({\r\n    initialPaths,\r\n    pathsToOpen,\r\n    executedFrom,\r\n    pidToKillWhenClosed,\r\n    newWindow,\r\n    devMode,\r\n    safeMode,\r\n    windowDimensions,\r\n    profileStartup,\r\n    window,\r\n    clearWindowState,\r\n    addToLastWindow,\r\n    env\r\n  } = {}) {\r\n    if (!pathsToOpen || pathsToOpen.length === 0) return\r\n    if (!env) env = process.env\r\n    devMode = Boolean(devMode)\r\n    safeMode = Boolean(safeMode)\r\n    clearWindowState = Boolean(clearWindowState)\r\n\r\n    const locationsToOpen = []\r\n    for (let i = 0; i < pathsToOpen.length; i++) {\r\n      const location = this.parsePathToOpen(pathsToOpen[i], executedFrom, addToLastWindow)\r\n      location.forceAddToWindow = addToLastWindow\r\n      location.hasWaitSession = pidToKillWhenClosed != null\r\n      locationsToOpen.push(location)\r\n      pathsToOpen[i] = location.pathToOpen\r\n    }\r\n\r\n    let existingWindow\r\n    if (!newWindow) {\r\n      existingWindow = this.windowForPaths(pathsToOpen, devMode)\r\n      if (!existingWindow) {\r\n        let lastWindow = window || this.getLastFocusedWindow()\r\n        if (lastWindow && lastWindow.devMode === devMode) {\r\n          if (addToLastWindow || (\r\n              locationsToOpen.every(({stat}) => stat && stat.isFile()) ||\r\n              (locationsToOpen.some(({stat}) => stat && stat.isDirectory()) && !lastWindow.hasProjectPath()))) {\r\n            existingWindow = lastWindow\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    let openedWindow\r\n    if (existingWindow) {\r\n      openedWindow = existingWindow\r\n      openedWindow.openLocations(locationsToOpen)\r\n      if (openedWindow.isMinimized()) {\r\n        openedWindow.restore()\r\n      } else {\r\n        openedWindow.focus()\r\n      }\r\n      openedWindow.replaceEnvironment(env)\r\n    } else {\r\n      let resourcePath, windowInitializationScript\r\n      if (devMode) {\r\n        try {\r\n          windowInitializationScript = require.resolve(\r\n            path.join(this.devResourcePath, 'src', 'initialize-application-window')\r\n          )\r\n          resourcePath = this.devResourcePath\r\n        } catch (error) {}\r\n      }\r\n\r\n      if (!windowInitializationScript) {\r\n        windowInitializationScript = require.resolve('../initialize-application-window')\r\n      }\r\n      if (!resourcePath) resourcePath = this.resourcePath\r\n      if (!windowDimensions) windowDimensions = this.getDimensionsForNewWindow()\r\n\r\n      openedWindow = new AtomWindow(this, this.fileRecoveryService, {\r\n        initialPaths,\r\n        locationsToOpen,\r\n        windowInitializationScript,\r\n        resourcePath,\r\n        devMode,\r\n        safeMode,\r\n        windowDimensions,\r\n        profileStartup,\r\n        clearWindowState,\r\n        env\r\n      })\r\n      this.addWindow(openedWindow)\r\n      openedWindow.focus()\r\n    }\r\n\r\n    if (pidToKillWhenClosed != null) {\r\n      if (!this.waitSessionsByWindow.has(openedWindow)) {\r\n        this.waitSessionsByWindow.set(openedWindow, [])\r\n      }\r\n      this.waitSessionsByWindow.get(openedWindow).push({\r\n        pid: pidToKillWhenClosed,\r\n        remainingPaths: new Set(pathsToOpen)\r\n      })\r\n    }\r\n\r\n    openedWindow.browserWindow.once('closed', () => this.killProcessesForWindow(openedWindow))\r\n    return openedWindow\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.addWindow","start_line":299,"end_line":319,"comment":[" Public: Adds the {AtomWindow} to the global window list."],"params":["window"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"scopesFromTags","line":466,"func_location":"TextMateLanguageMode.openScopesForRow","func_start_line":463,"func_end_line":470,"args":["precedingLine.openScopes","precedingLine.tags"],"code":"  openScopesForRow (bufferRow) {\r\n    const precedingLine = this.tokenizedLines[bufferRow - 1]\r\n    if (precedingLine) {\r\n      return this.scopesFromTags(precedingLine.openScopes, precedingLine.tags)\r\n    } else {\r\n      return []\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.scopesFromTags","start_line":472,"end_line":490,"comment":[],"params":["startingScopes","tags"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getActivePane","line":1158,"func_location":"Workspace.openSync","func_start_line":1152,"func_end_line":1177,"args":["uri"],"comment":[" Synchronously open the given URI in the active pane. **Only use this method"," in specs. Calling this in production code will block the UI thread and"," everyone will be mad at you.**",""," * `uri` A {String} containing a URI."," * `options` An optional options {Object}","   * `initialLine` A {Number} indicating which row to move the cursor to","     initially. Defaults to `0`.","   * `initialColumn` A {Number} indicating which column to move the cursor to","     initially. Defaults to `0`.","   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on","     the containing pane. Defaults to `true`.","   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}","     on containing pane. Defaults to `true`."],"code":"  openSync (uri_ = '', options = {}) {\r\n    const {initialLine, initialColumn} = options\r\n    const activatePane = options.activatePane != null ? options.activatePane : true\r\n    const activateItem = options.activateItem != null ? options.activateItem : true\r\n\r\n    const uri = this.project.resolvePath(uri_)\r\n    let item = this.getActivePane().itemForURI(uri)\r\n    if (uri && (item == null)) {\r\n      for (const opener of this.getOpeners()) {\r\n        item = opener(uri, options)\r\n        if (item) break\r\n      }\r\n    }\r\n    if (item == null) {\r\n      item = this.project.openSync(uri, {initialLine, initialColumn})\r\n    }\r\n\r\n    if (activateItem) {\r\n      this.getActivePane().activateItem(item)\r\n    }\r\n    this.itemOpened(item)\r\n    if (activatePane) {\r\n      this.getActivePane().activate()\r\n    }\r\n    return item\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getActivePane","start_line":1442,"end_line":1444,"comment":[" Extended: Get the active {Pane}.",""," Returns a {Pane}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getOpeners","line":1160,"func_location":"Workspace.openSync","func_start_line":1152,"func_end_line":1177,"args":[],"comment":[" Synchronously open the given URI in the active pane. **Only use this method"," in specs. Calling this in production code will block the UI thread and"," everyone will be mad at you.**",""," * `uri` A {String} containing a URI."," * `options` An optional options {Object}","   * `initialLine` A {Number} indicating which row to move the cursor to","     initially. Defaults to `0`.","   * `initialColumn` A {Number} indicating which column to move the cursor to","     initially. Defaults to `0`.","   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on","     the containing pane. Defaults to `true`.","   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}","     on containing pane. Defaults to `true`."],"code":"  openSync (uri_ = '', options = {}) {\r\n    const {initialLine, initialColumn} = options\r\n    const activatePane = options.activatePane != null ? options.activatePane : true\r\n    const activateItem = options.activateItem != null ? options.activateItem : true\r\n\r\n    const uri = this.project.resolvePath(uri_)\r\n    let item = this.getActivePane().itemForURI(uri)\r\n    if (uri && (item == null)) {\r\n      for (const opener of this.getOpeners()) {\r\n        item = opener(uri, options)\r\n        if (item) break\r\n      }\r\n    }\r\n    if (item == null) {\r\n      item = this.project.openSync(uri, {initialLine, initialColumn})\r\n    }\r\n\r\n    if (activateItem) {\r\n      this.getActivePane().activateItem(item)\r\n    }\r\n    this.itemOpened(item)\r\n    if (activatePane) {\r\n      this.getActivePane().activate()\r\n    }\r\n    return item\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getOpeners","start_line":1339,"end_line":1341,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getActivePane","line":1170,"func_location":"Workspace.openSync","func_start_line":1152,"func_end_line":1177,"args":["item"],"comment":[" Synchronously open the given URI in the active pane. **Only use this method"," in specs. Calling this in production code will block the UI thread and"," everyone will be mad at you.**",""," * `uri` A {String} containing a URI."," * `options` An optional options {Object}","   * `initialLine` A {Number} indicating which row to move the cursor to","     initially. Defaults to `0`.","   * `initialColumn` A {Number} indicating which column to move the cursor to","     initially. Defaults to `0`.","   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on","     the containing pane. Defaults to `true`.","   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}","     on containing pane. Defaults to `true`."],"code":"  openSync (uri_ = '', options = {}) {\r\n    const {initialLine, initialColumn} = options\r\n    const activatePane = options.activatePane != null ? options.activatePane : true\r\n    const activateItem = options.activateItem != null ? options.activateItem : true\r\n\r\n    const uri = this.project.resolvePath(uri_)\r\n    let item = this.getActivePane().itemForURI(uri)\r\n    if (uri && (item == null)) {\r\n      for (const opener of this.getOpeners()) {\r\n        item = opener(uri, options)\r\n        if (item) break\r\n      }\r\n    }\r\n    if (item == null) {\r\n      item = this.project.openSync(uri, {initialLine, initialColumn})\r\n    }\r\n\r\n    if (activateItem) {\r\n      this.getActivePane().activateItem(item)\r\n    }\r\n    this.itemOpened(item)\r\n    if (activatePane) {\r\n      this.getActivePane().activate()\r\n    }\r\n    return item\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getActivePane","start_line":1442,"end_line":1444,"comment":[" Extended: Get the active {Pane}.",""," Returns a {Pane}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"itemOpened","line":1172,"func_location":"Workspace.openSync","func_start_line":1152,"func_end_line":1177,"args":["item"],"comment":[" Synchronously open the given URI in the active pane. **Only use this method"," in specs. Calling this in production code will block the UI thread and"," everyone will be mad at you.**",""," * `uri` A {String} containing a URI."," * `options` An optional options {Object}","   * `initialLine` A {Number} indicating which row to move the cursor to","     initially. Defaults to `0`.","   * `initialColumn` A {Number} indicating which column to move the cursor to","     initially. Defaults to `0`.","   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on","     the containing pane. Defaults to `true`.","   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}","     on containing pane. Defaults to `true`."],"code":"  openSync (uri_ = '', options = {}) {\r\n    const {initialLine, initialColumn} = options\r\n    const activatePane = options.activatePane != null ? options.activatePane : true\r\n    const activateItem = options.activateItem != null ? options.activateItem : true\r\n\r\n    const uri = this.project.resolvePath(uri_)\r\n    let item = this.getActivePane().itemForURI(uri)\r\n    if (uri && (item == null)) {\r\n      for (const opener of this.getOpeners()) {\r\n        item = opener(uri, options)\r\n        if (item) break\r\n      }\r\n    }\r\n    if (item == null) {\r\n      item = this.project.openSync(uri, {initialLine, initialColumn})\r\n    }\r\n\r\n    if (activateItem) {\r\n      this.getActivePane().activateItem(item)\r\n    }\r\n    this.itemOpened(item)\r\n    if (activatePane) {\r\n      this.getActivePane().activate()\r\n    }\r\n    return item\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.itemOpened","start_line":1554,"end_line":1565,"comment":[" Removes the item's uri from the list of potential items to reopen."],"params":["item"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getActivePane","line":1174,"func_location":"Workspace.openSync","func_start_line":1152,"func_end_line":1177,"args":[],"comment":[" Synchronously open the given URI in the active pane. **Only use this method"," in specs. Calling this in production code will block the UI thread and"," everyone will be mad at you.**",""," * `uri` A {String} containing a URI."," * `options` An optional options {Object}","   * `initialLine` A {Number} indicating which row to move the cursor to","     initially. Defaults to `0`.","   * `initialColumn` A {Number} indicating which column to move the cursor to","     initially. Defaults to `0`.","   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on","     the containing pane. Defaults to `true`.","   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}","     on containing pane. Defaults to `true`."],"code":"  openSync (uri_ = '', options = {}) {\r\n    const {initialLine, initialColumn} = options\r\n    const activatePane = options.activatePane != null ? options.activatePane : true\r\n    const activateItem = options.activateItem != null ? options.activateItem : true\r\n\r\n    const uri = this.project.resolvePath(uri_)\r\n    let item = this.getActivePane().itemForURI(uri)\r\n    if (uri && (item == null)) {\r\n      for (const opener of this.getOpeners()) {\r\n        item = opener(uri, options)\r\n        if (item) break\r\n      }\r\n    }\r\n    if (item == null) {\r\n      item = this.project.openSync(uri, {initialLine, initialColumn})\r\n    }\r\n\r\n    if (activateItem) {\r\n      this.getActivePane().activateItem(item)\r\n    }\r\n    this.itemOpened(item)\r\n    if (activatePane) {\r\n      this.getActivePane().activate()\r\n    }\r\n    return item\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getActivePane","start_line":1442,"end_line":1444,"comment":[" Extended: Get the active {Pane}.",""," Returns a {Pane}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"open","line":1180,"func_location":"Workspace.openURIInPane","func_start_line":1179,"func_end_line":1181,"args":["uri",null],"code":"  openURIInPane (uri, pane) {\r\n    return this.open(uri, {pane})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.open","start_line":925,"end_line":1079,"comment":["\r\n  Section: Opening\r\n  "," Essential: Opens the given URI in Atom asynchronously."," If the URI is already open, the existing item for that URI will be"," activated. If no URI is given, or no registered opener can open"," the URI, a new empty {TextEditor} will be created.",""," * `uri` (optional) A {String} containing a URI."," * `options` (optional) {Object}","   * `initialLine` A {Number} indicating which row to move the cursor to","     initially. Defaults to `0`.","   * `initialColumn` A {Number} indicating which column to move the cursor to","     initially. Defaults to `0`.","   * `split` Either 'left', 'right', 'up' or 'down'.","     If 'left', the item will be opened in leftmost pane of the current active pane's row.","     If 'right', the item will be opened in the rightmost pane of the current active pane's row. If only one pane exists in the row, a new pane will be created.","     If 'up', the item will be opened in topmost pane of the current active pane's column.","     If 'down', the item will be opened in the bottommost pane of the current active pane's column. If only one pane exists in the column, a new pane will be created.","   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on","     containing pane. Defaults to `true`.","   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}","     on containing pane. Defaults to `true`.","   * `pending` A {Boolean} indicating whether or not the item should be opened","     in a pending state. Existing pending items in a pane are replaced with","     new pending items when they are opened.","   * `searchAllPanes` A {Boolean}. If `true`, the workspace will attempt to","     activate an existing item for the given URI on any pane.","     If `false`, only the active pane will be searched for","     an existing item for the same URI. Defaults to `false`.","   * `location` (optional) A {String} containing the name of the location","     in which this item should be opened (one of \"left\", \"right\", \"bottom\",","     or \"center\"). If omitted, Atom will fall back to the last location in","     which a user has placed an item with the same URI or, if this is a new","     URI, the default location specified by the item. NOTE: This option","     should almost always be omitted to honor user preference.",""," Returns a {Promise} that resolves to the {TextEditor} for the file URI."],"params":["itemOrURI","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"findPackageWithName","line":1012,"func_location":"AtomApplication.openUrl","func_start_line":1008,"func_end_line":1025,"args":["parsedUrl.host","devMode"],"comment":[" Open an atom:// url.",""," The host of the URL being opened is assumed to be the package name"," responsible for opening the URL.  A new window will be created with"," that package's `urlMain` as the bootstrap script.",""," options -","   :urlToOpen - The atom:// url to open.","   :devMode - Boolean to control the opened window's dev mode.","   :safeMode - Boolean to control the opened window's safe mode."],"code":"  openUrl ({urlToOpen, devMode, safeMode, env}) {\r\n    const parsedUrl = url.parse(urlToOpen, true)\r\n    if (parsedUrl.protocol !== 'atom:') return\r\n\r\n    const pack = this.findPackageWithName(parsedUrl.host, devMode)\r\n    if (pack && pack.urlMain) {\r\n      return this.openPackageUrlMain(\r\n        parsedUrl.host,\r\n        pack.urlMain,\r\n        urlToOpen,\r\n        devMode,\r\n        safeMode,\r\n        env\r\n      )\r\n    } else {\r\n      return this.openPackageUriHandler(urlToOpen, parsedUrl, devMode, safeMode, env)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.findPackageWithName","start_line":1071,"end_line":1075,"comment":[],"params":["packageName","devMode"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"openPackageUrlMain","line":1014,"func_location":"AtomApplication.openUrl","func_start_line":1008,"func_end_line":1025},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.openPackageUrlMain","start_line":1077,"end_line":1092,"comment":[],"params":["packageName","packageUrlMain","urlToOpen","devMode","safeMode","env"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"openPackageUriHandler","line":1023,"func_location":"AtomApplication.openUrl","func_start_line":1008,"func_end_line":1025,"args":["urlToOpen","parsedUrl","devMode","safeMode","env"],"comment":[" Open an atom:// url.",""," The host of the URL being opened is assumed to be the package name"," responsible for opening the URL.  A new window will be created with"," that package's `urlMain` as the bootstrap script.",""," options -","   :urlToOpen - The atom:// url to open.","   :devMode - Boolean to control the opened window's dev mode.","   :safeMode - Boolean to control the opened window's safe mode."],"code":"  openUrl ({urlToOpen, devMode, safeMode, env}) {\r\n    const parsedUrl = url.parse(urlToOpen, true)\r\n    if (parsedUrl.protocol !== 'atom:') return\r\n\r\n    const pack = this.findPackageWithName(parsedUrl.host, devMode)\r\n    if (pack && pack.urlMain) {\r\n      return this.openPackageUrlMain(\r\n        parsedUrl.host,\r\n        pack.urlMain,\r\n        urlToOpen,\r\n        devMode,\r\n        safeMode,\r\n        env\r\n      )\r\n    } else {\r\n      return this.openPackageUriHandler(urlToOpen, parsedUrl, devMode, safeMode, env)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.openPackageUriHandler","start_line":1027,"end_line":1069,"comment":[],"params":["url","parsedUrl","devMode","safeMode","env"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"runTests","line":231,"func_location":"AtomApplication.openWithOptions","func_start_line":207,"func_end_line":281},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.runTests","start_line":1117,"end_line":1179,"comment":[" Opens up a new {AtomWindow} to run specs within.",""," options -","   :headless - A Boolean that, if true, will close the window upon","                   completion.","   :resourcePath - The path to include specs from.","   :specPath - The directory to load specs from.","   :safeMode - A Boolean that, if true, won't run specs from ~/.atom/packages","               and ~/.atom/dev/packages, defaults to false."],"params":[["headless","resourcePath","executedFrom","pathsToOpen","logFile","safeMode","timeout","env"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"runBenchmarks","line":242,"func_location":"AtomApplication.openWithOptions","func_start_line":207,"func_end_line":281},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.runBenchmarks","start_line":1181,"end_line":1225,"comment":[],"params":[["headless","test","resourcePath","executedFrom","pathsToOpen","env"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"openPaths","line":252,"func_location":"AtomApplication.openWithOptions","func_start_line":207,"func_end_line":281},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.openPaths","start_line":825,"end_line":925,"comment":[" Public: Opens multiple paths, in existing windows if possible.",""," options -","   :pathsToOpen - The array of file paths to open","   :pidToKillWhenClosed - The integer of the pid to kill","   :newWindow - Boolean of whether this should be opened in a new window.","   :devMode - Boolean to control the opened window's dev mode.","   :safeMode - Boolean to control the opened window's safe mode.","   :windowDimensions - Object with height and width keys.","   :window - {AtomWindow} to open file paths in.","   :addToLastWindow - Boolean of whether this should be opened in last focused window."],"params":[["initialPaths","pathsToOpen","executedFrom","pidToKillWhenClosed","newWindow","devMode","safeMode","windowDimensions","profileStartup","window","clearWindowState","addToLastWindow","env"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"openPath","line":269,"func_location":"AtomApplication.openWithOptions","func_start_line":207,"func_end_line":281},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.openPath","start_line":786,"end_line":812,"comment":[" Public: Opens a single path, in an existing window if possible.",""," options -","   :pathToOpen - The file path to open","   :pidToKillWhenClosed - The integer of the pid to kill","   :newWindow - Boolean of whether this should be opened in a new window.","   :devMode - Boolean to control the opened window's dev mode.","   :safeMode - Boolean to control the opened window's safe mode.","   :profileStartup - Boolean to control creating a profile of the startup time.","   :window - {AtomWindow} to open file paths in.","   :addToLastWindow - Boolean of whether this should be opened in last focused window."],"params":[["initialPaths","pathToOpen","pidToKillWhenClosed","newWindow","devMode","safeMode","profileStartup","window","clearWindowState","addToLastWindow","env"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getPaneContainers","line":1474,"func_location":"Workspace.paneContainerForItem","func_start_line":1473,"func_end_line":1475,"args":[null],"comment":[" Extended: Get the first pane container that contains the given item.",""," * `item` the Item that the returned pane container must contain.",""," Returns a {Dock}, the {WorkspaceCenter}, or `undefined` if no item exists"," with the given URI."],"code":"  paneContainerForItem (uri) {\r\n    return this.getPaneContainers().find(container => container.paneForItem(uri))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getPaneContainers","start_line":1618,"end_line":1625,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getPaneContainers","line":1464,"func_location":"Workspace.paneContainerForURI","func_start_line":1463,"func_end_line":1465,"args":[null],"comment":[" Extended: Get the first pane container that contains an item with the given"," URI.",""," * `uri` {String} uri",""," Returns a {Dock}, the {WorkspaceCenter}, or `undefined` if no item exists"," with the given URI."],"code":"  paneContainerForURI (uri) {\r\n    return this.getPaneContainers().find(container => container.paneForURI(uri))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getPaneContainers","start_line":1618,"end_line":1625,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"getPanes","line":171,"func_location":"PaneContainer.paneForItem","func_start_line":170,"func_end_line":172,"args":[null,null],"code":"  paneForItem (item) {\r\n    return find(this.getPanes(), pane => pane.getItems().includes(item))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.getPanes","start_line":146,"end_line":152,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getPaneContainers","line":1497,"func_location":"Workspace.paneForItem","func_start_line":1496,"func_end_line":1503,"args":[],"comment":[" Extended: Get the {Pane} containing the given item.",""," * `item` the Item that the returned pane must contain.",""," Returns a {Pane} or `undefined` if no pane exists for the given item."],"code":"  paneForItem (item) {\r\n    for (let location of this.getPaneContainers()) {\r\n      const pane = location.paneForItem(item)\r\n      if (pane != null) {\r\n        return pane\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getPaneContainers","start_line":1618,"end_line":1625,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"getPanes","line":167,"func_location":"PaneContainer.paneForURI","func_start_line":166,"func_end_line":168,"args":[null,null],"code":"  paneForURI (uri) {\r\n    return find(this.getPanes(), pane => pane.itemForURI(uri) != null)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.getPanes","start_line":146,"end_line":152,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getPaneContainers","line":1483,"func_location":"Workspace.paneForURI","func_start_line":1482,"func_end_line":1489,"args":[],"comment":[" Extended: Get the first {Pane} that contains an item with the given URI.",""," * `uri` {String} uri",""," Returns a {Pane} or `undefined` if no item exists with the given URI."],"code":"  paneForURI (uri) {\r\n    for (let location of this.getPaneContainers()) {\r\n      const pane = location.paneForURI(uri)\r\n      if (pane != null) {\r\n        return pane\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getPaneContainers","start_line":1618,"end_line":1625,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/panel-container-element.js","name":"hideAllPanelsExcept","line":52,"func_location":"PanelContainerElement.panelAdded","func_start_line":35,"func_end_line":77,"args":["panel"],"code":"  panelAdded ({panel, index}) {\r\n    const panelElement = panel.getElement()\r\n    panelElement.classList.add(this.model.getLocation())\r\n    if (this.model.isModal()) {\r\n      panelElement.classList.add('overlay', 'from-top')\r\n    } else {\r\n      panelElement.classList.add('tool-panel', `panel-${this.model.getLocation()}`)\r\n    }\r\n\r\n    if (index >= this.childNodes.length) {\r\n      this.appendChild(panelElement)\r\n    } else {\r\n      const referenceItem = this.childNodes[index]\r\n      this.insertBefore(panelElement, referenceItem)\r\n    }\r\n\r\n    if (this.model.isModal()) {\r\n      this.hideAllPanelsExcept(panel)\r\n      this.subscriptions.add(panel.onDidChangeVisible(visible => {\r\n        if (visible) { this.hideAllPanelsExcept(panel) }\r\n      }))\r\n\r\n      if (panel.autoFocus) {\r\n        const modalFocusTrap = focusTrap(panelElement, {\r\n          // focus-trap will attempt to give focus to the first tabbable element\r\n          // on activation. If there aren't any tabbable elements,\r\n          // give focus to the panel element itself\r\n          fallbackFocus: panelElement,\r\n          // closing is handled by core Atom commands and this already deactivates\r\n          // on visibility changes\r\n          escapeDeactivates: false\r\n        })\r\n\r\n        this.subscriptions.add(panel.onDidChangeVisible(visible => {\r\n          if (visible) {\r\n            modalFocusTrap.activate()\r\n          } else {\r\n            modalFocusTrap.deactivate()\r\n          }\r\n        }))\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/panel-container-element.js","name":"PanelContainerElement.hideAllPanelsExcept","start_line":86,"end_line":90,"comment":[],"params":["excludedPanel"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js","name":"constructor","line":35,"func_location":"Color.parse","func_start_line":14,"func_end_line":36,"args":[],"comment":[" Essential: Parse a {String} or {Object} into a {Color}.",""," * `value` A {String} such as `'white'`, `#ff00ff`, or","   `'rgba(255, 15, 60, .75)'` or an {Object} with `red`, `green`, `blue`,","   and `alpha` properties.",""," Returns a {Color} or `null` if it cannot be parsed."],"code":"  static parse (value) {\r\n    switch (typeof value) {\r\n      case 'string':\r\n        break\r\n      case 'object':\r\n        if (Array.isArray(value)) { return null }\r\n        break\r\n      default:\r\n        return null\r\n    }\r\n\r\n    if (!ParsedColor) {\r\n      ParsedColor = require('color')\r\n    }\r\n\r\n    try {\r\n      var parsedColor = new ParsedColor(value)\r\n    } catch (error) {\r\n      return null\r\n    }\r\n\r\n    return new Color(parsedColor.red(), parsedColor.green(), parsedColor.blue(), parsedColor.alpha())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js","name":"Color.constructor","start_line":38,"end_line":43,"comment":[],"params":["red","green","blue","alpha"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/storage-folder.js","name":"getPath","line":43,"func_location":"StorageFolder.pathForKey","func_start_line":42,"func_end_line":44,"args":[null,"name"],"code":"  pathForKey (name) {\r\n    return path.join(this.getPath(), name)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/storage-folder.js","name":"StorageFolder.getPath","start_line":46,"end_line":48,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"stopCursorBlinking","line":1982,"func_location":"TextEditorComponent.pauseCursorBlinking","func_start_line":1981,"func_end_line":1984,"args":[],"code":"  pauseCursorBlinking () {\r\n    this.stopCursorBlinking()\r\n    this.debouncedResumeCursorBlinking()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.stopCursorBlinking","start_line":1991,"end_line":1999,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"renderedScreenLineForRow","line":2370,"func_location":"TextEditorComponent.pixelLeftForRowAndColumn","func_start_line":2368,"func_end_line":2377,"args":["row"],"code":"  pixelLeftForRowAndColumn (row, column) {\r\n    if (column === 0) return 0\r\n    const screenLine = this.renderedScreenLineForRow(row)\r\n    if (screenLine) {\r\n      const horizontalPositionsByColumn = this.horizontalPixelPositionsByScreenLineId.get(screenLine.id)\r\n      if (horizontalPositionsByColumn) {\r\n        return horizontalPositionsByColumn.get(column)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.renderedScreenLineForRow","start_line":956,"end_line":961,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getModel","line":230,"func_location":"TextEditorElement.pixelPositionForBufferPosition","func_start_line":229,"func_end_line":232,"args":["bufferPosition"],"comment":[" Extended: Converts a buffer position to a pixel position.",""," * `bufferPosition` A {Point}-like object that represents a buffer position.",""," Be aware that calling this method with a column that does not translate"," to column 0 on screen could cause a synchronous DOM update in order to"," measure the requested horizontal pixel position if it isn't already"," cached.",""," Returns an {Object} with two values: `top` and `left`, representing the"," pixel position."],"code":"  pixelPositionForBufferPosition (bufferPosition) {\r\n    const screenPosition = this.getModel().screenPositionForBufferPosition(bufferPosition)\r\n    return this.getComponent().pixelPositionForScreenPosition(screenPosition)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getModel","start_line":80,"end_line":82,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":231,"func_location":"TextEditorElement.pixelPositionForBufferPosition","func_start_line":229,"func_end_line":232,"args":["screenPosition"],"comment":[" Extended: Converts a buffer position to a pixel position.",""," * `bufferPosition` A {Point}-like object that represents a buffer position.",""," Be aware that calling this method with a column that does not translate"," to column 0 on screen could cause a synchronous DOM update in order to"," measure the requested horizontal pixel position if it isn't already"," cached.",""," Returns an {Object} with two values: `top` and `left`, representing the"," pixel position."],"code":"  pixelPositionForBufferPosition (bufferPosition) {\r\n    const screenPosition = this.getModel().screenPositionForBufferPosition(bufferPosition)\r\n    return this.getComponent().pixelPositionForScreenPosition(screenPosition)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelPositionAfterBlocksForRow","line":194,"func_location":"TextEditorComponent.pixelPositionForScreenPosition","func_start_line":193,"func_end_line":202,"args":["row"],"code":"  pixelPositionForScreenPosition ({row, column}) {\r\n    const top = this.pixelPositionAfterBlocksForRow(row)\r\n    let left = column === 0 ? 0 : this.pixelLeftForRowAndColumn(row, column)\r\n    if (left == null) {\r\n      this.requestHorizontalMeasurement(row, column)\r\n      this.updateSync()\r\n      left = this.pixelLeftForRowAndColumn(row, column)\r\n    }\r\n    return {top, left}\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelPositionAfterBlocksForRow","start_line":2364,"end_line":2366,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelLeftForRowAndColumn","line":195,"func_location":"TextEditorComponent.pixelPositionForScreenPosition","func_start_line":193,"func_end_line":202,"args":["row","column"],"code":"  pixelPositionForScreenPosition ({row, column}) {\r\n    const top = this.pixelPositionAfterBlocksForRow(row)\r\n    let left = column === 0 ? 0 : this.pixelLeftForRowAndColumn(row, column)\r\n    if (left == null) {\r\n      this.requestHorizontalMeasurement(row, column)\r\n      this.updateSync()\r\n      left = this.pixelLeftForRowAndColumn(row, column)\r\n    }\r\n    return {top, left}\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelLeftForRowAndColumn","start_line":2368,"end_line":2377,"comment":[],"params":["row","column"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"requestHorizontalMeasurement","line":197,"func_location":"TextEditorComponent.pixelPositionForScreenPosition","func_start_line":193,"func_end_line":202,"args":["row","column"],"code":"  pixelPositionForScreenPosition ({row, column}) {\r\n    const top = this.pixelPositionAfterBlocksForRow(row)\r\n    let left = column === 0 ? 0 : this.pixelLeftForRowAndColumn(row, column)\r\n    if (left == null) {\r\n      this.requestHorizontalMeasurement(row, column)\r\n      this.updateSync()\r\n      left = this.pixelLeftForRowAndColumn(row, column)\r\n    }\r\n    return {top, left}\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.requestHorizontalMeasurement","start_line":2243,"end_line":2257,"comment":[],"params":["row","column"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateSync","line":198,"func_location":"TextEditorComponent.pixelPositionForScreenPosition","func_start_line":193,"func_end_line":202,"args":[],"code":"  pixelPositionForScreenPosition ({row, column}) {\r\n    const top = this.pixelPositionAfterBlocksForRow(row)\r\n    let left = column === 0 ? 0 : this.pixelLeftForRowAndColumn(row, column)\r\n    if (left == null) {\r\n      this.requestHorizontalMeasurement(row, column)\r\n      this.updateSync()\r\n      left = this.pixelLeftForRowAndColumn(row, column)\r\n    }\r\n    return {top, left}\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateSync","start_line":221,"end_line":289,"comment":[],"params":["useScheduler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelLeftForRowAndColumn","line":199,"func_location":"TextEditorComponent.pixelPositionForScreenPosition","func_start_line":193,"func_end_line":202,"args":["row","column"],"code":"  pixelPositionForScreenPosition ({row, column}) {\r\n    const top = this.pixelPositionAfterBlocksForRow(row)\r\n    let left = column === 0 ? 0 : this.pixelLeftForRowAndColumn(row, column)\r\n    if (left == null) {\r\n      this.requestHorizontalMeasurement(row, column)\r\n      this.updateSync()\r\n      left = this.pixelLeftForRowAndColumn(row, column)\r\n    }\r\n    return {top, left}\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelLeftForRowAndColumn","start_line":2368,"end_line":2377,"comment":[],"params":["row","column"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getModel","line":245,"func_location":"TextEditorElement.pixelPositionForScreenPosition","func_start_line":244,"func_end_line":247,"args":["screenPosition"],"comment":[" Extended: Converts a screen position to a pixel position.",""," * `screenPosition` A {Point}-like object that represents a buffer position.",""," Be aware that calling this method with a non-zero column value could"," cause a synchronous DOM update in order to measure the requested"," horizontal pixel position if it isn't already cached.",""," Returns an {Object} with two values: `top` and `left`, representing the"," pixel position."],"code":"  pixelPositionForScreenPosition (screenPosition) {\r\n    screenPosition = this.getModel().clipScreenPosition(screenPosition)\r\n    return this.getComponent().pixelPositionForScreenPosition(screenPosition)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getModel","start_line":80,"end_line":82,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":246,"func_location":"TextEditorElement.pixelPositionForScreenPosition","func_start_line":244,"func_end_line":247,"args":["screenPosition"],"comment":[" Extended: Converts a screen position to a pixel position.",""," * `screenPosition` A {Point}-like object that represents a buffer position.",""," Be aware that calling this method with a non-zero column value could"," cause a synchronous DOM update in order to measure the requested"," horizontal pixel position if it isn't already cached.",""," Returns an {Object} with two values: `top` and `left`, representing the"," pixel position."],"code":"  pixelPositionForScreenPosition (screenPosition) {\r\n    screenPosition = this.getModel().clipScreenPosition(screenPosition)\r\n    return this.getComponent().pixelPositionForScreenPosition(screenPosition)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"pixelPositionForScreenPosition","line":271,"func_location":"TextEditorElement.pixelRangeForScreenRange","func_start_line":268,"func_end_line":274,"args":["range.start"],"code":"  pixelRangeForScreenRange (range) {\r\n    range = Range.fromObject(range)\r\n    return {\r\n      start: this.pixelPositionForScreenPosition(range.start),\r\n      end: this.pixelPositionForScreenPosition(range.end)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.pixelPositionForScreenPosition","start_line":244,"end_line":247,"comment":[" Extended: Converts a screen position to a pixel position.",""," * `screenPosition` A {Point}-like object that represents a buffer position.",""," Be aware that calling this method with a non-zero column value could"," cause a synchronous DOM update in order to measure the requested"," horizontal pixel position if it isn't already cached.",""," Returns an {Object} with two values: `top` and `left`, representing the"," pixel position."],"params":["screenPosition"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"pixelPositionForScreenPosition","line":272,"func_location":"TextEditorElement.pixelRangeForScreenRange","func_start_line":268,"func_end_line":274,"args":["range.end"],"code":"  pixelRangeForScreenRange (range) {\r\n    range = Range.fromObject(range)\r\n    return {\r\n      start: this.pixelPositionForScreenPosition(range.start),\r\n      end: this.pixelPositionForScreenPosition(range.end)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.pixelPositionForScreenPosition","start_line":244,"end_line":247,"comment":[" Extended: Converts a screen position to a pixel position.",""," * `screenPosition` A {Point}-like object that represents a buffer position.",""," Be aware that calling this method with a non-zero column value could"," cause a synchronous DOM update in order to measure the requested"," horizontal pixel position if it isn't already cached.",""," Returns an {Object} with two values: `top` and `left`, representing the"," pixel position."],"params":["screenPosition"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"pixelPositionForScreenPosition","line":256,"func_location":"TextEditorElement.pixelRectForScreenRange","func_start_line":253,"func_end_line":266,"args":["range.start"],"code":"  pixelRectForScreenRange (range) {\r\n    range = Range.fromObject(range)\r\n\r\n    const start = this.pixelPositionForScreenPosition(range.start)\r\n    const end = this.pixelPositionForScreenPosition(range.end)\r\n    const lineHeight = this.getComponent().getLineHeight()\r\n\r\n    return {\r\n      top: start.top,\r\n      left: start.left,\r\n      height: end.top + lineHeight - start.top,\r\n      width: end.left - start.left\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.pixelPositionForScreenPosition","start_line":244,"end_line":247,"comment":[" Extended: Converts a screen position to a pixel position.",""," * `screenPosition` A {Point}-like object that represents a buffer position.",""," Be aware that calling this method with a non-zero column value could"," cause a synchronous DOM update in order to measure the requested"," horizontal pixel position if it isn't already cached.",""," Returns an {Object} with two values: `top` and `left`, representing the"," pixel position."],"params":["screenPosition"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"pixelPositionForScreenPosition","line":257,"func_location":"TextEditorElement.pixelRectForScreenRange","func_start_line":253,"func_end_line":266,"args":["range.end"],"code":"  pixelRectForScreenRange (range) {\r\n    range = Range.fromObject(range)\r\n\r\n    const start = this.pixelPositionForScreenPosition(range.start)\r\n    const end = this.pixelPositionForScreenPosition(range.end)\r\n    const lineHeight = this.getComponent().getLineHeight()\r\n\r\n    return {\r\n      top: start.top,\r\n      left: start.left,\r\n      height: end.top + lineHeight - start.top,\r\n      width: end.left - start.left\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.pixelPositionForScreenPosition","start_line":244,"end_line":247,"comment":[" Extended: Converts a screen position to a pixel position.",""," * `screenPosition` A {Point}-like object that represents a buffer position.",""," Be aware that calling this method with a non-zero column value could"," cause a synchronous DOM update in order to measure the requested"," horizontal pixel position if it isn't already cached.",""," Returns an {Object} with two values: `top` and `left`, representing the"," pixel position."],"params":["screenPosition"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":258,"func_location":"TextEditorElement.pixelRectForScreenRange","func_start_line":253,"func_end_line":266,"args":[],"code":"  pixelRectForScreenRange (range) {\r\n    range = Range.fromObject(range)\r\n\r\n    const start = this.pixelPositionForScreenPosition(range.start)\r\n    const end = this.pixelPositionForScreenPosition(range.end)\r\n    const lineHeight = this.getComponent().getLineHeight()\r\n\r\n    return {\r\n      top: start.top,\r\n      left: start.left,\r\n      height: end.top + lineHeight - start.top,\r\n      width: end.left - start.left\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/auto-update-manager.js","name":"getState","line":53,"func_location":"AutoUpdateManager.platformSupportsUpdates","func_start_line":52,"func_end_line":54,"args":[],"code":"  platformSupportsUpdates () {\r\n    return atom.getReleaseChannel() !== 'dev' && this.getState() !== 'unsupported'\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/auto-update-manager.js","name":"AutoUpdateManager.getState","start_line":44,"end_line":46,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"rectContainsPoint","line":372,"func_location":"Dock.pointWithinHoverArea","func_start_line":333,"func_end_line":405,"args":["bounds","point"],"comment":[" Determine whether the cursor is within the dock hover area. This isn't as simple as just using"," mouseenter/leave because we want to be a little more forgiving. For example, if the cursor is"," over the footer, we want to show the bottom dock's toggle button. Also note that our criteria"," for detecting entry are different than detecting exit but, in order for us to avoid jitter, the"," area considered when detecting exit MUST fully encompass the area considered when detecting"," entry."],"code":"  pointWithinHoverArea (point, detectingExit) {\r\n    const dockBounds = this.refs.innerElement.getBoundingClientRect()\r\n\r\n    // Copy the bounds object since we can't mutate it.\r\n    const bounds = {\r\n      top: dockBounds.top,\r\n      right: dockBounds.right,\r\n      bottom: dockBounds.bottom,\r\n      left: dockBounds.left\r\n    }\r\n\r\n    // To provide a minimum target, expand the area toward the center a bit.\r\n    switch (this.location) {\r\n      case 'right':\r\n        bounds.left = Math.min(bounds.left, bounds.right - 2)\r\n        break\r\n      case 'bottom':\r\n        bounds.top = Math.min(bounds.top, bounds.bottom - 1)\r\n        break\r\n      case 'left':\r\n        bounds.right = Math.max(bounds.right, bounds.left + 2)\r\n        break\r\n    }\r\n\r\n    // Further expand the area to include all panels that are closer to the edge than the dock.\r\n    switch (this.location) {\r\n      case 'right':\r\n        bounds.right = Number.POSITIVE_INFINITY\r\n        break\r\n      case 'bottom':\r\n        bounds.bottom = Number.POSITIVE_INFINITY\r\n        break\r\n      case 'left':\r\n        bounds.left = Number.NEGATIVE_INFINITY\r\n        break\r\n    }\r\n\r\n    // If we're in this area, we know we're within the hover area without having to take further\r\n    // measurements.\r\n    if (rectContainsPoint(bounds, point)) return true\r\n\r\n    // If we're within the toggle button, we're definitely in the hover area. Unfortunately, we\r\n    // can't do this measurement conditionally (e.g. only if the toggle button is visible) because\r\n    // our knowledge of the toggle's button is incomplete due to CSS animations. (We may think the\r\n    // toggle button isn't visible when in actuality it is, but is animating to its hidden state.)\r\n    //\r\n    // Since `point` is always the current mouse position, one possible optimization would be to\r\n    // remove it as an argument and determine whether we're inside the toggle button using\r\n    // mouseenter/leave events on it. This class would still need to keep track of the mouse\r\n    // position (via a mousemove listener) for the other measurements, though.\r\n    const toggleButtonBounds = this.refs.toggleButton.getBounds()\r\n    if (rectContainsPoint(toggleButtonBounds, point)) return true\r\n\r\n    // The area used when detecting exit is actually larger than when detecting entrances. Expand\r\n    // our bounds and recheck them.\r\n    if (detectingExit) {\r\n      const hoverMargin = 20\r\n      switch (this.location) {\r\n        case 'right':\r\n          bounds.left = Math.min(bounds.left, toggleButtonBounds.left) - hoverMargin\r\n          break\r\n        case 'bottom':\r\n          bounds.top = Math.min(bounds.top, toggleButtonBounds.top) - hoverMargin\r\n          break\r\n        case 'left':\r\n          bounds.right = Math.max(bounds.right, toggleButtonBounds.right) + hoverMargin\r\n          break\r\n      }\r\n      if (rectContainsPoint(bounds, point)) return true\r\n    }\r\n\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"rectContainsPoint","start_line":848,"end_line":855,"comment":[],"params":["rect","point"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"rectContainsPoint","line":384,"func_location":"Dock.pointWithinHoverArea","func_start_line":333,"func_end_line":405,"args":["toggleButtonBounds","point"],"comment":[" Determine whether the cursor is within the dock hover area. This isn't as simple as just using"," mouseenter/leave because we want to be a little more forgiving. For example, if the cursor is"," over the footer, we want to show the bottom dock's toggle button. Also note that our criteria"," for detecting entry are different than detecting exit but, in order for us to avoid jitter, the"," area considered when detecting exit MUST fully encompass the area considered when detecting"," entry."],"code":"  pointWithinHoverArea (point, detectingExit) {\r\n    const dockBounds = this.refs.innerElement.getBoundingClientRect()\r\n\r\n    // Copy the bounds object since we can't mutate it.\r\n    const bounds = {\r\n      top: dockBounds.top,\r\n      right: dockBounds.right,\r\n      bottom: dockBounds.bottom,\r\n      left: dockBounds.left\r\n    }\r\n\r\n    // To provide a minimum target, expand the area toward the center a bit.\r\n    switch (this.location) {\r\n      case 'right':\r\n        bounds.left = Math.min(bounds.left, bounds.right - 2)\r\n        break\r\n      case 'bottom':\r\n        bounds.top = Math.min(bounds.top, bounds.bottom - 1)\r\n        break\r\n      case 'left':\r\n        bounds.right = Math.max(bounds.right, bounds.left + 2)\r\n        break\r\n    }\r\n\r\n    // Further expand the area to include all panels that are closer to the edge than the dock.\r\n    switch (this.location) {\r\n      case 'right':\r\n        bounds.right = Number.POSITIVE_INFINITY\r\n        break\r\n      case 'bottom':\r\n        bounds.bottom = Number.POSITIVE_INFINITY\r\n        break\r\n      case 'left':\r\n        bounds.left = Number.NEGATIVE_INFINITY\r\n        break\r\n    }\r\n\r\n    // If we're in this area, we know we're within the hover area without having to take further\r\n    // measurements.\r\n    if (rectContainsPoint(bounds, point)) return true\r\n\r\n    // If we're within the toggle button, we're definitely in the hover area. Unfortunately, we\r\n    // can't do this measurement conditionally (e.g. only if the toggle button is visible) because\r\n    // our knowledge of the toggle's button is incomplete due to CSS animations. (We may think the\r\n    // toggle button isn't visible when in actuality it is, but is animating to its hidden state.)\r\n    //\r\n    // Since `point` is always the current mouse position, one possible optimization would be to\r\n    // remove it as an argument and determine whether we're inside the toggle button using\r\n    // mouseenter/leave events on it. This class would still need to keep track of the mouse\r\n    // position (via a mousemove listener) for the other measurements, though.\r\n    const toggleButtonBounds = this.refs.toggleButton.getBounds()\r\n    if (rectContainsPoint(toggleButtonBounds, point)) return true\r\n\r\n    // The area used when detecting exit is actually larger than when detecting entrances. Expand\r\n    // our bounds and recheck them.\r\n    if (detectingExit) {\r\n      const hoverMargin = 20\r\n      switch (this.location) {\r\n        case 'right':\r\n          bounds.left = Math.min(bounds.left, toggleButtonBounds.left) - hoverMargin\r\n          break\r\n        case 'bottom':\r\n          bounds.top = Math.min(bounds.top, toggleButtonBounds.top) - hoverMargin\r\n          break\r\n        case 'left':\r\n          bounds.right = Math.max(bounds.right, toggleButtonBounds.right) + hoverMargin\r\n          break\r\n      }\r\n      if (rectContainsPoint(bounds, point)) return true\r\n    }\r\n\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"rectContainsPoint","start_line":848,"end_line":855,"comment":[],"params":["rect","point"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"rectContainsPoint","line":401,"func_location":"Dock.pointWithinHoverArea","func_start_line":333,"func_end_line":405,"args":["bounds","point"],"comment":[" Determine whether the cursor is within the dock hover area. This isn't as simple as just using"," mouseenter/leave because we want to be a little more forgiving. For example, if the cursor is"," over the footer, we want to show the bottom dock's toggle button. Also note that our criteria"," for detecting entry are different than detecting exit but, in order for us to avoid jitter, the"," area considered when detecting exit MUST fully encompass the area considered when detecting"," entry."],"code":"  pointWithinHoverArea (point, detectingExit) {\r\n    const dockBounds = this.refs.innerElement.getBoundingClientRect()\r\n\r\n    // Copy the bounds object since we can't mutate it.\r\n    const bounds = {\r\n      top: dockBounds.top,\r\n      right: dockBounds.right,\r\n      bottom: dockBounds.bottom,\r\n      left: dockBounds.left\r\n    }\r\n\r\n    // To provide a minimum target, expand the area toward the center a bit.\r\n    switch (this.location) {\r\n      case 'right':\r\n        bounds.left = Math.min(bounds.left, bounds.right - 2)\r\n        break\r\n      case 'bottom':\r\n        bounds.top = Math.min(bounds.top, bounds.bottom - 1)\r\n        break\r\n      case 'left':\r\n        bounds.right = Math.max(bounds.right, bounds.left + 2)\r\n        break\r\n    }\r\n\r\n    // Further expand the area to include all panels that are closer to the edge than the dock.\r\n    switch (this.location) {\r\n      case 'right':\r\n        bounds.right = Number.POSITIVE_INFINITY\r\n        break\r\n      case 'bottom':\r\n        bounds.bottom = Number.POSITIVE_INFINITY\r\n        break\r\n      case 'left':\r\n        bounds.left = Number.NEGATIVE_INFINITY\r\n        break\r\n    }\r\n\r\n    // If we're in this area, we know we're within the hover area without having to take further\r\n    // measurements.\r\n    if (rectContainsPoint(bounds, point)) return true\r\n\r\n    // If we're within the toggle button, we're definitely in the hover area. Unfortunately, we\r\n    // can't do this measurement conditionally (e.g. only if the toggle button is visible) because\r\n    // our knowledge of the toggle's button is incomplete due to CSS animations. (We may think the\r\n    // toggle button isn't visible when in actuality it is, but is animating to its hidden state.)\r\n    //\r\n    // Since `point` is always the current mouse position, one possible optimization would be to\r\n    // remove it as an argument and determine whether we're inside the toggle button using\r\n    // mouseenter/leave events on it. This class would still need to keep track of the mouse\r\n    // position (via a mousemove listener) for the other measurements, though.\r\n    const toggleButtonBounds = this.refs.toggleButton.getBounds()\r\n    if (rectContainsPoint(toggleButtonBounds, point)) return true\r\n\r\n    // The area used when detecting exit is actually larger than when detecting entrances. Expand\r\n    // our bounds and recheck them.\r\n    if (detectingExit) {\r\n      const hoverMargin = 20\r\n      switch (this.location) {\r\n        case 'right':\r\n          bounds.left = Math.min(bounds.left, toggleButtonBounds.left) - hoverMargin\r\n          break\r\n        case 'bottom':\r\n          bounds.top = Math.min(bounds.top, toggleButtonBounds.top) - hoverMargin\r\n          break\r\n        case 'left':\r\n          bounds.right = Math.max(bounds.right, toggleButtonBounds.right) + hoverMargin\r\n          break\r\n      }\r\n      if (rectContainsPoint(bounds, point)) return true\r\n    }\r\n\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"rectContainsPoint","start_line":848,"end_line":855,"comment":[],"params":["rect","point"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedStartRow","line":1240,"func_location":"TextEditorComponent.populateTextDecorationsToRender","func_start_line":1209,"func_end_line":1309,"args":[],"code":"  populateTextDecorationsToRender () {\r\n    // Sort all boundaries in ascending order of position\r\n    this.textDecorationBoundaries.sort((a, b) => a.position.compare(b.position))\r\n\r\n    // Combine adjacent boundaries with the same position\r\n    for (let i = 0; i < this.textDecorationBoundaries.length;) {\r\n      const boundary = this.textDecorationBoundaries[i]\r\n      const nextBoundary = this.textDecorationBoundaries[i + 1]\r\n      if (nextBoundary && nextBoundary.position.isEqual(boundary.position)) {\r\n        if (nextBoundary.starting) {\r\n          if (boundary.starting) {\r\n            boundary.starting.push(...nextBoundary.starting)\r\n          } else {\r\n            boundary.starting = nextBoundary.starting\r\n          }\r\n        }\r\n\r\n        if (nextBoundary.ending) {\r\n          if (boundary.ending) {\r\n            boundary.ending.push(...nextBoundary.ending)\r\n          } else {\r\n            boundary.ending = nextBoundary.ending\r\n          }\r\n        }\r\n\r\n        this.textDecorationBoundaries.splice(i + 1, 1)\r\n      } else {\r\n        i++\r\n      }\r\n    }\r\n\r\n    const renderedStartRow = this.getRenderedStartRow()\r\n    const renderedEndRow = this.getRenderedEndRow()\r\n    const containingMarkers = []\r\n\r\n    // Iterate over boundaries to build up text decorations.\r\n    for (let i = 0; i < this.textDecorationBoundaries.length; i++) {\r\n      const boundary = this.textDecorationBoundaries[i]\r\n\r\n      // If multiple markers start here, sort them by order of nesting (markers ending later come first)\r\n      if (boundary.starting && boundary.starting.length > 1) {\r\n        boundary.starting.sort((a, b) => a.compare(b))\r\n      }\r\n\r\n      // If multiple markers start here, sort them by order of nesting (markers starting earlier come first)\r\n      if (boundary.ending && boundary.ending.length > 1) {\r\n        boundary.ending.sort((a, b) => b.compare(a))\r\n      }\r\n\r\n      // Remove markers ending here from containing markers array\r\n      if (boundary.ending) {\r\n        for (let j = boundary.ending.length - 1; j >= 0; j--) {\r\n          containingMarkers.splice(containingMarkers.lastIndexOf(boundary.ending[j]), 1)\r\n        }\r\n      }\r\n      // Add markers starting here to containing markers array\r\n      if (boundary.starting) containingMarkers.push(...boundary.starting)\r\n\r\n      // Determine desired className and style based on containing markers\r\n      let className, style\r\n      for (let j = 0; j < containingMarkers.length; j++) {\r\n        const marker = containingMarkers[j]\r\n        const decorations = this.textDecorationsByMarker.get(marker)\r\n        for (let k = 0; k < decorations.length; k++) {\r\n          const decoration = decorations[k]\r\n          if (decoration.class) {\r\n            if (className) {\r\n              className += ' ' + decoration.class\r\n            } else {\r\n              className = decoration.class\r\n            }\r\n          }\r\n          if (decoration.style) {\r\n            if (style) {\r\n              Object.assign(style, decoration.style)\r\n            } else {\r\n              style = Object.assign({}, decoration.style)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Add decoration start with className/style for current position's column,\r\n      // and also for the start of every row up until the next decoration boundary\r\n      if (boundary.position.row >= renderedStartRow) {\r\n        this.addTextDecorationStart(boundary.position.row, boundary.position.column, className, style)\r\n      }\r\n      const nextBoundary = this.textDecorationBoundaries[i + 1]\r\n      if (nextBoundary) {\r\n        let row = Math.max(boundary.position.row + 1, renderedStartRow)\r\n        const endRow = Math.min(nextBoundary.position.row, renderedEndRow)\r\n        for (; row < endRow; row++) {\r\n          this.addTextDecorationStart(row, 0, className, style)\r\n        }\r\n\r\n        if (row === nextBoundary.position.row && nextBoundary.position.column !== 0) {\r\n          this.addTextDecorationStart(row, 0, className, style)\r\n        }\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedStartRow","start_line":2720,"end_line":2726,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedEndRow","line":1241,"func_location":"TextEditorComponent.populateTextDecorationsToRender","func_start_line":1209,"func_end_line":1309,"args":[],"code":"  populateTextDecorationsToRender () {\r\n    // Sort all boundaries in ascending order of position\r\n    this.textDecorationBoundaries.sort((a, b) => a.position.compare(b.position))\r\n\r\n    // Combine adjacent boundaries with the same position\r\n    for (let i = 0; i < this.textDecorationBoundaries.length;) {\r\n      const boundary = this.textDecorationBoundaries[i]\r\n      const nextBoundary = this.textDecorationBoundaries[i + 1]\r\n      if (nextBoundary && nextBoundary.position.isEqual(boundary.position)) {\r\n        if (nextBoundary.starting) {\r\n          if (boundary.starting) {\r\n            boundary.starting.push(...nextBoundary.starting)\r\n          } else {\r\n            boundary.starting = nextBoundary.starting\r\n          }\r\n        }\r\n\r\n        if (nextBoundary.ending) {\r\n          if (boundary.ending) {\r\n            boundary.ending.push(...nextBoundary.ending)\r\n          } else {\r\n            boundary.ending = nextBoundary.ending\r\n          }\r\n        }\r\n\r\n        this.textDecorationBoundaries.splice(i + 1, 1)\r\n      } else {\r\n        i++\r\n      }\r\n    }\r\n\r\n    const renderedStartRow = this.getRenderedStartRow()\r\n    const renderedEndRow = this.getRenderedEndRow()\r\n    const containingMarkers = []\r\n\r\n    // Iterate over boundaries to build up text decorations.\r\n    for (let i = 0; i < this.textDecorationBoundaries.length; i++) {\r\n      const boundary = this.textDecorationBoundaries[i]\r\n\r\n      // If multiple markers start here, sort them by order of nesting (markers ending later come first)\r\n      if (boundary.starting && boundary.starting.length > 1) {\r\n        boundary.starting.sort((a, b) => a.compare(b))\r\n      }\r\n\r\n      // If multiple markers start here, sort them by order of nesting (markers starting earlier come first)\r\n      if (boundary.ending && boundary.ending.length > 1) {\r\n        boundary.ending.sort((a, b) => b.compare(a))\r\n      }\r\n\r\n      // Remove markers ending here from containing markers array\r\n      if (boundary.ending) {\r\n        for (let j = boundary.ending.length - 1; j >= 0; j--) {\r\n          containingMarkers.splice(containingMarkers.lastIndexOf(boundary.ending[j]), 1)\r\n        }\r\n      }\r\n      // Add markers starting here to containing markers array\r\n      if (boundary.starting) containingMarkers.push(...boundary.starting)\r\n\r\n      // Determine desired className and style based on containing markers\r\n      let className, style\r\n      for (let j = 0; j < containingMarkers.length; j++) {\r\n        const marker = containingMarkers[j]\r\n        const decorations = this.textDecorationsByMarker.get(marker)\r\n        for (let k = 0; k < decorations.length; k++) {\r\n          const decoration = decorations[k]\r\n          if (decoration.class) {\r\n            if (className) {\r\n              className += ' ' + decoration.class\r\n            } else {\r\n              className = decoration.class\r\n            }\r\n          }\r\n          if (decoration.style) {\r\n            if (style) {\r\n              Object.assign(style, decoration.style)\r\n            } else {\r\n              style = Object.assign({}, decoration.style)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Add decoration start with className/style for current position's column,\r\n      // and also for the start of every row up until the next decoration boundary\r\n      if (boundary.position.row >= renderedStartRow) {\r\n        this.addTextDecorationStart(boundary.position.row, boundary.position.column, className, style)\r\n      }\r\n      const nextBoundary = this.textDecorationBoundaries[i + 1]\r\n      if (nextBoundary) {\r\n        let row = Math.max(boundary.position.row + 1, renderedStartRow)\r\n        const endRow = Math.min(nextBoundary.position.row, renderedEndRow)\r\n        for (; row < endRow; row++) {\r\n          this.addTextDecorationStart(row, 0, className, style)\r\n        }\r\n\r\n        if (row === nextBoundary.position.row && nextBoundary.position.column !== 0) {\r\n          this.addTextDecorationStart(row, 0, className, style)\r\n        }\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedEndRow","start_line":2728,"end_line":2737,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"addTextDecorationStart","line":1294,"func_location":"TextEditorComponent.populateTextDecorationsToRender","func_start_line":1209,"func_end_line":1309,"args":["boundary.position.row","boundary.position.column","className","style"],"code":"  populateTextDecorationsToRender () {\r\n    // Sort all boundaries in ascending order of position\r\n    this.textDecorationBoundaries.sort((a, b) => a.position.compare(b.position))\r\n\r\n    // Combine adjacent boundaries with the same position\r\n    for (let i = 0; i < this.textDecorationBoundaries.length;) {\r\n      const boundary = this.textDecorationBoundaries[i]\r\n      const nextBoundary = this.textDecorationBoundaries[i + 1]\r\n      if (nextBoundary && nextBoundary.position.isEqual(boundary.position)) {\r\n        if (nextBoundary.starting) {\r\n          if (boundary.starting) {\r\n            boundary.starting.push(...nextBoundary.starting)\r\n          } else {\r\n            boundary.starting = nextBoundary.starting\r\n          }\r\n        }\r\n\r\n        if (nextBoundary.ending) {\r\n          if (boundary.ending) {\r\n            boundary.ending.push(...nextBoundary.ending)\r\n          } else {\r\n            boundary.ending = nextBoundary.ending\r\n          }\r\n        }\r\n\r\n        this.textDecorationBoundaries.splice(i + 1, 1)\r\n      } else {\r\n        i++\r\n      }\r\n    }\r\n\r\n    const renderedStartRow = this.getRenderedStartRow()\r\n    const renderedEndRow = this.getRenderedEndRow()\r\n    const containingMarkers = []\r\n\r\n    // Iterate over boundaries to build up text decorations.\r\n    for (let i = 0; i < this.textDecorationBoundaries.length; i++) {\r\n      const boundary = this.textDecorationBoundaries[i]\r\n\r\n      // If multiple markers start here, sort them by order of nesting (markers ending later come first)\r\n      if (boundary.starting && boundary.starting.length > 1) {\r\n        boundary.starting.sort((a, b) => a.compare(b))\r\n      }\r\n\r\n      // If multiple markers start here, sort them by order of nesting (markers starting earlier come first)\r\n      if (boundary.ending && boundary.ending.length > 1) {\r\n        boundary.ending.sort((a, b) => b.compare(a))\r\n      }\r\n\r\n      // Remove markers ending here from containing markers array\r\n      if (boundary.ending) {\r\n        for (let j = boundary.ending.length - 1; j >= 0; j--) {\r\n          containingMarkers.splice(containingMarkers.lastIndexOf(boundary.ending[j]), 1)\r\n        }\r\n      }\r\n      // Add markers starting here to containing markers array\r\n      if (boundary.starting) containingMarkers.push(...boundary.starting)\r\n\r\n      // Determine desired className and style based on containing markers\r\n      let className, style\r\n      for (let j = 0; j < containingMarkers.length; j++) {\r\n        const marker = containingMarkers[j]\r\n        const decorations = this.textDecorationsByMarker.get(marker)\r\n        for (let k = 0; k < decorations.length; k++) {\r\n          const decoration = decorations[k]\r\n          if (decoration.class) {\r\n            if (className) {\r\n              className += ' ' + decoration.class\r\n            } else {\r\n              className = decoration.class\r\n            }\r\n          }\r\n          if (decoration.style) {\r\n            if (style) {\r\n              Object.assign(style, decoration.style)\r\n            } else {\r\n              style = Object.assign({}, decoration.style)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Add decoration start with className/style for current position's column,\r\n      // and also for the start of every row up until the next decoration boundary\r\n      if (boundary.position.row >= renderedStartRow) {\r\n        this.addTextDecorationStart(boundary.position.row, boundary.position.column, className, style)\r\n      }\r\n      const nextBoundary = this.textDecorationBoundaries[i + 1]\r\n      if (nextBoundary) {\r\n        let row = Math.max(boundary.position.row + 1, renderedStartRow)\r\n        const endRow = Math.min(nextBoundary.position.row, renderedEndRow)\r\n        for (; row < endRow; row++) {\r\n          this.addTextDecorationStart(row, 0, className, style)\r\n        }\r\n\r\n        if (row === nextBoundary.position.row && nextBoundary.position.column !== 0) {\r\n          this.addTextDecorationStart(row, 0, className, style)\r\n        }\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.addTextDecorationStart","start_line":1311,"end_line":1319,"comment":[],"params":["row","column","className","style"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"addTextDecorationStart","line":1301,"func_location":"TextEditorComponent.populateTextDecorationsToRender","func_start_line":1209,"func_end_line":1309,"args":["row",{"type":"number"},"className","style"],"code":"  populateTextDecorationsToRender () {\r\n    // Sort all boundaries in ascending order of position\r\n    this.textDecorationBoundaries.sort((a, b) => a.position.compare(b.position))\r\n\r\n    // Combine adjacent boundaries with the same position\r\n    for (let i = 0; i < this.textDecorationBoundaries.length;) {\r\n      const boundary = this.textDecorationBoundaries[i]\r\n      const nextBoundary = this.textDecorationBoundaries[i + 1]\r\n      if (nextBoundary && nextBoundary.position.isEqual(boundary.position)) {\r\n        if (nextBoundary.starting) {\r\n          if (boundary.starting) {\r\n            boundary.starting.push(...nextBoundary.starting)\r\n          } else {\r\n            boundary.starting = nextBoundary.starting\r\n          }\r\n        }\r\n\r\n        if (nextBoundary.ending) {\r\n          if (boundary.ending) {\r\n            boundary.ending.push(...nextBoundary.ending)\r\n          } else {\r\n            boundary.ending = nextBoundary.ending\r\n          }\r\n        }\r\n\r\n        this.textDecorationBoundaries.splice(i + 1, 1)\r\n      } else {\r\n        i++\r\n      }\r\n    }\r\n\r\n    const renderedStartRow = this.getRenderedStartRow()\r\n    const renderedEndRow = this.getRenderedEndRow()\r\n    const containingMarkers = []\r\n\r\n    // Iterate over boundaries to build up text decorations.\r\n    for (let i = 0; i < this.textDecorationBoundaries.length; i++) {\r\n      const boundary = this.textDecorationBoundaries[i]\r\n\r\n      // If multiple markers start here, sort them by order of nesting (markers ending later come first)\r\n      if (boundary.starting && boundary.starting.length > 1) {\r\n        boundary.starting.sort((a, b) => a.compare(b))\r\n      }\r\n\r\n      // If multiple markers start here, sort them by order of nesting (markers starting earlier come first)\r\n      if (boundary.ending && boundary.ending.length > 1) {\r\n        boundary.ending.sort((a, b) => b.compare(a))\r\n      }\r\n\r\n      // Remove markers ending here from containing markers array\r\n      if (boundary.ending) {\r\n        for (let j = boundary.ending.length - 1; j >= 0; j--) {\r\n          containingMarkers.splice(containingMarkers.lastIndexOf(boundary.ending[j]), 1)\r\n        }\r\n      }\r\n      // Add markers starting here to containing markers array\r\n      if (boundary.starting) containingMarkers.push(...boundary.starting)\r\n\r\n      // Determine desired className and style based on containing markers\r\n      let className, style\r\n      for (let j = 0; j < containingMarkers.length; j++) {\r\n        const marker = containingMarkers[j]\r\n        const decorations = this.textDecorationsByMarker.get(marker)\r\n        for (let k = 0; k < decorations.length; k++) {\r\n          const decoration = decorations[k]\r\n          if (decoration.class) {\r\n            if (className) {\r\n              className += ' ' + decoration.class\r\n            } else {\r\n              className = decoration.class\r\n            }\r\n          }\r\n          if (decoration.style) {\r\n            if (style) {\r\n              Object.assign(style, decoration.style)\r\n            } else {\r\n              style = Object.assign({}, decoration.style)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Add decoration start with className/style for current position's column,\r\n      // and also for the start of every row up until the next decoration boundary\r\n      if (boundary.position.row >= renderedStartRow) {\r\n        this.addTextDecorationStart(boundary.position.row, boundary.position.column, className, style)\r\n      }\r\n      const nextBoundary = this.textDecorationBoundaries[i + 1]\r\n      if (nextBoundary) {\r\n        let row = Math.max(boundary.position.row + 1, renderedStartRow)\r\n        const endRow = Math.min(nextBoundary.position.row, renderedEndRow)\r\n        for (; row < endRow; row++) {\r\n          this.addTextDecorationStart(row, 0, className, style)\r\n        }\r\n\r\n        if (row === nextBoundary.position.row && nextBoundary.position.column !== 0) {\r\n          this.addTextDecorationStart(row, 0, className, style)\r\n        }\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.addTextDecorationStart","start_line":1311,"end_line":1319,"comment":[],"params":["row","column","className","style"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"addTextDecorationStart","line":1305,"func_location":"TextEditorComponent.populateTextDecorationsToRender","func_start_line":1209,"func_end_line":1309,"args":["row",{"type":"number"},"className","style"],"code":"  populateTextDecorationsToRender () {\r\n    // Sort all boundaries in ascending order of position\r\n    this.textDecorationBoundaries.sort((a, b) => a.position.compare(b.position))\r\n\r\n    // Combine adjacent boundaries with the same position\r\n    for (let i = 0; i < this.textDecorationBoundaries.length;) {\r\n      const boundary = this.textDecorationBoundaries[i]\r\n      const nextBoundary = this.textDecorationBoundaries[i + 1]\r\n      if (nextBoundary && nextBoundary.position.isEqual(boundary.position)) {\r\n        if (nextBoundary.starting) {\r\n          if (boundary.starting) {\r\n            boundary.starting.push(...nextBoundary.starting)\r\n          } else {\r\n            boundary.starting = nextBoundary.starting\r\n          }\r\n        }\r\n\r\n        if (nextBoundary.ending) {\r\n          if (boundary.ending) {\r\n            boundary.ending.push(...nextBoundary.ending)\r\n          } else {\r\n            boundary.ending = nextBoundary.ending\r\n          }\r\n        }\r\n\r\n        this.textDecorationBoundaries.splice(i + 1, 1)\r\n      } else {\r\n        i++\r\n      }\r\n    }\r\n\r\n    const renderedStartRow = this.getRenderedStartRow()\r\n    const renderedEndRow = this.getRenderedEndRow()\r\n    const containingMarkers = []\r\n\r\n    // Iterate over boundaries to build up text decorations.\r\n    for (let i = 0; i < this.textDecorationBoundaries.length; i++) {\r\n      const boundary = this.textDecorationBoundaries[i]\r\n\r\n      // If multiple markers start here, sort them by order of nesting (markers ending later come first)\r\n      if (boundary.starting && boundary.starting.length > 1) {\r\n        boundary.starting.sort((a, b) => a.compare(b))\r\n      }\r\n\r\n      // If multiple markers start here, sort them by order of nesting (markers starting earlier come first)\r\n      if (boundary.ending && boundary.ending.length > 1) {\r\n        boundary.ending.sort((a, b) => b.compare(a))\r\n      }\r\n\r\n      // Remove markers ending here from containing markers array\r\n      if (boundary.ending) {\r\n        for (let j = boundary.ending.length - 1; j >= 0; j--) {\r\n          containingMarkers.splice(containingMarkers.lastIndexOf(boundary.ending[j]), 1)\r\n        }\r\n      }\r\n      // Add markers starting here to containing markers array\r\n      if (boundary.starting) containingMarkers.push(...boundary.starting)\r\n\r\n      // Determine desired className and style based on containing markers\r\n      let className, style\r\n      for (let j = 0; j < containingMarkers.length; j++) {\r\n        const marker = containingMarkers[j]\r\n        const decorations = this.textDecorationsByMarker.get(marker)\r\n        for (let k = 0; k < decorations.length; k++) {\r\n          const decoration = decorations[k]\r\n          if (decoration.class) {\r\n            if (className) {\r\n              className += ' ' + decoration.class\r\n            } else {\r\n              className = decoration.class\r\n            }\r\n          }\r\n          if (decoration.style) {\r\n            if (style) {\r\n              Object.assign(style, decoration.style)\r\n            } else {\r\n              style = Object.assign({}, decoration.style)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Add decoration start with className/style for current position's column,\r\n      // and also for the start of every row up until the next decoration boundary\r\n      if (boundary.position.row >= renderedStartRow) {\r\n        this.addTextDecorationStart(boundary.position.row, boundary.position.column, className, style)\r\n      }\r\n      const nextBoundary = this.textDecorationBoundaries[i + 1]\r\n      if (nextBoundary) {\r\n        let row = Math.max(boundary.position.row + 1, renderedStartRow)\r\n        const endRow = Math.min(nextBoundary.position.row, renderedEndRow)\r\n        for (; row < endRow; row++) {\r\n          this.addTextDecorationStart(row, 0, className, style)\r\n        }\r\n\r\n        if (row === nextBoundary.position.row && nextBoundary.position.column !== 0) {\r\n          this.addTextDecorationStart(row, 0, className, style)\r\n        }\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.addTextDecorationStart","start_line":1311,"end_line":1319,"comment":[],"params":["row","column","className","style"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getVisibleTileCount","line":2900,"func_location":"TextEditorComponent.populateVisibleRowRange","func_start_line":2896,"func_end_line":2908,"args":[],"comment":[" Ensure the spatial index is populated with rows that are currently visible"],"code":"  populateVisibleRowRange (renderedStartRow) {\r\n    const {model} = this.props\r\n    const previousScreenLineCount = model.getApproximateScreenLineCount()\r\n\r\n    const renderedEndRow = renderedStartRow + (this.getVisibleTileCount() * this.getRowsPerTile())\r\n    this.props.model.displayLayer.populateSpatialIndexIfNeeded(Infinity, renderedEndRow)\r\n\r\n    // If the approximate screen line count changes, previously-cached derived\r\n    // dimensions could now be out of date.\r\n    if (model.getApproximateScreenLineCount() !== previousScreenLineCount) {\r\n      this.derivedDimensionsCache = {}\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getVisibleTileCount","start_line":2779,"end_line":2785,"comment":[" We may render more tiles than needed if some contain block decorations,"," but keeping this calculation simple ensures the number of tiles remains"," fixed for a given editor height, which eliminates situations where a"," tile is repeatedly added and removed during scrolling in certain"," combinations of editor height and line height."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRowsPerTile","line":2900,"func_location":"TextEditorComponent.populateVisibleRowRange","func_start_line":2896,"func_end_line":2908,"args":[],"comment":[" Ensure the spatial index is populated with rows that are currently visible"],"code":"  populateVisibleRowRange (renderedStartRow) {\r\n    const {model} = this.props\r\n    const previousScreenLineCount = model.getApproximateScreenLineCount()\r\n\r\n    const renderedEndRow = renderedStartRow + (this.getVisibleTileCount() * this.getRowsPerTile())\r\n    this.props.model.displayLayer.populateSpatialIndexIfNeeded(Infinity, renderedEndRow)\r\n\r\n    // If the approximate screen line count changes, previously-cached derived\r\n    // dimensions could now be out of date.\r\n    if (model.getApproximateScreenLineCount() !== previousScreenLineCount) {\r\n      this.derivedDimensionsCache = {}\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRowsPerTile","start_line":2712,"end_line":2714,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedStartRow","line":2911,"func_location":"TextEditorComponent.populateVisibleTiles","func_start_line":2910,"func_end_line":2937,"args":[],"code":"  populateVisibleTiles () {\r\n    const startRow = this.getRenderedStartRow()\r\n    const endRow = this.getRenderedEndRow()\r\n    const freeTileIds = []\r\n    for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n      const tileStartRow = this.renderedTileStartRows[i]\r\n      if (tileStartRow < startRow || tileStartRow >= endRow) {\r\n        const tileId = this.idsByTileStartRow.get(tileStartRow)\r\n        freeTileIds.push(tileId)\r\n        this.idsByTileStartRow.delete(tileStartRow)\r\n      }\r\n    }\r\n\r\n    const rowsPerTile = this.getRowsPerTile()\r\n    this.renderedTileStartRows.length = this.getRenderedTileCount()\r\n    for (let tileStartRow = startRow, i = 0; tileStartRow < endRow; tileStartRow = tileStartRow + rowsPerTile, i++) {\r\n      this.renderedTileStartRows[i] = tileStartRow\r\n      if (!this.idsByTileStartRow.has(tileStartRow)) {\r\n        if (freeTileIds.length > 0) {\r\n          this.idsByTileStartRow.set(tileStartRow, freeTileIds.shift())\r\n        } else {\r\n          this.idsByTileStartRow.set(tileStartRow, this.nextTileId++)\r\n        }\r\n      }\r\n    }\r\n\r\n    this.renderedTileStartRows.sort((a, b) => this.idsByTileStartRow.get(a) - this.idsByTileStartRow.get(b))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedStartRow","start_line":2720,"end_line":2726,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedEndRow","line":2912,"func_location":"TextEditorComponent.populateVisibleTiles","func_start_line":2910,"func_end_line":2937,"args":[],"code":"  populateVisibleTiles () {\r\n    const startRow = this.getRenderedStartRow()\r\n    const endRow = this.getRenderedEndRow()\r\n    const freeTileIds = []\r\n    for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n      const tileStartRow = this.renderedTileStartRows[i]\r\n      if (tileStartRow < startRow || tileStartRow >= endRow) {\r\n        const tileId = this.idsByTileStartRow.get(tileStartRow)\r\n        freeTileIds.push(tileId)\r\n        this.idsByTileStartRow.delete(tileStartRow)\r\n      }\r\n    }\r\n\r\n    const rowsPerTile = this.getRowsPerTile()\r\n    this.renderedTileStartRows.length = this.getRenderedTileCount()\r\n    for (let tileStartRow = startRow, i = 0; tileStartRow < endRow; tileStartRow = tileStartRow + rowsPerTile, i++) {\r\n      this.renderedTileStartRows[i] = tileStartRow\r\n      if (!this.idsByTileStartRow.has(tileStartRow)) {\r\n        if (freeTileIds.length > 0) {\r\n          this.idsByTileStartRow.set(tileStartRow, freeTileIds.shift())\r\n        } else {\r\n          this.idsByTileStartRow.set(tileStartRow, this.nextTileId++)\r\n        }\r\n      }\r\n    }\r\n\r\n    this.renderedTileStartRows.sort((a, b) => this.idsByTileStartRow.get(a) - this.idsByTileStartRow.get(b))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedEndRow","start_line":2728,"end_line":2737,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRowsPerTile","line":2923,"func_location":"TextEditorComponent.populateVisibleTiles","func_start_line":2910,"func_end_line":2937,"args":[],"code":"  populateVisibleTiles () {\r\n    const startRow = this.getRenderedStartRow()\r\n    const endRow = this.getRenderedEndRow()\r\n    const freeTileIds = []\r\n    for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n      const tileStartRow = this.renderedTileStartRows[i]\r\n      if (tileStartRow < startRow || tileStartRow >= endRow) {\r\n        const tileId = this.idsByTileStartRow.get(tileStartRow)\r\n        freeTileIds.push(tileId)\r\n        this.idsByTileStartRow.delete(tileStartRow)\r\n      }\r\n    }\r\n\r\n    const rowsPerTile = this.getRowsPerTile()\r\n    this.renderedTileStartRows.length = this.getRenderedTileCount()\r\n    for (let tileStartRow = startRow, i = 0; tileStartRow < endRow; tileStartRow = tileStartRow + rowsPerTile, i++) {\r\n      this.renderedTileStartRows[i] = tileStartRow\r\n      if (!this.idsByTileStartRow.has(tileStartRow)) {\r\n        if (freeTileIds.length > 0) {\r\n          this.idsByTileStartRow.set(tileStartRow, freeTileIds.shift())\r\n        } else {\r\n          this.idsByTileStartRow.set(tileStartRow, this.nextTileId++)\r\n        }\r\n      }\r\n    }\r\n\r\n    this.renderedTileStartRows.sort((a, b) => this.idsByTileStartRow.get(a) - this.idsByTileStartRow.get(b))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRowsPerTile","start_line":2712,"end_line":2714,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedTileCount","line":2924,"func_location":"TextEditorComponent.populateVisibleTiles","func_start_line":2910,"func_end_line":2937,"args":[],"code":"  populateVisibleTiles () {\r\n    const startRow = this.getRenderedStartRow()\r\n    const endRow = this.getRenderedEndRow()\r\n    const freeTileIds = []\r\n    for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n      const tileStartRow = this.renderedTileStartRows[i]\r\n      if (tileStartRow < startRow || tileStartRow >= endRow) {\r\n        const tileId = this.idsByTileStartRow.get(tileStartRow)\r\n        freeTileIds.push(tileId)\r\n        this.idsByTileStartRow.delete(tileStartRow)\r\n      }\r\n    }\r\n\r\n    const rowsPerTile = this.getRowsPerTile()\r\n    this.renderedTileStartRows.length = this.getRenderedTileCount()\r\n    for (let tileStartRow = startRow, i = 0; tileStartRow < endRow; tileStartRow = tileStartRow + rowsPerTile, i++) {\r\n      this.renderedTileStartRows[i] = tileStartRow\r\n      if (!this.idsByTileStartRow.has(tileStartRow)) {\r\n        if (freeTileIds.length > 0) {\r\n          this.idsByTileStartRow.set(tileStartRow, freeTileIds.shift())\r\n        } else {\r\n          this.idsByTileStartRow.set(tileStartRow, this.nextTileId++)\r\n        }\r\n      }\r\n    }\r\n\r\n    this.renderedTileStartRows.sort((a, b) => this.idsByTileStartRow.get(a) - this.idsByTileStartRow.get(b))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedTileCount","start_line":2747,"end_line":2753,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"loadKeymaps","line":92,"func_location":"Package.preload","func_start_line":91,"func_end_line":108,"args":[],"code":"  preload () {\r\n    this.loadKeymaps()\r\n    this.loadMenus()\r\n    this.registerDeserializerMethods()\r\n    this.activateCoreStartupServices()\r\n    this.registerURIHandler()\r\n    this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n    this.requireMainModule()\r\n    this.settingsPromise = this.loadSettings()\r\n\r\n    this.activationDisposables = new CompositeDisposable()\r\n    this.activateKeymaps()\r\n    this.activateMenus()\r\n    for (let settings of this.settings) {\r\n      settings.activate(this.config)\r\n    }\r\n    this.settingsActivated = true\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.loadKeymaps","start_line":438,"end_line":451,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"loadMenus","line":93,"func_location":"Package.preload","func_start_line":91,"func_end_line":108,"args":[],"code":"  preload () {\r\n    this.loadKeymaps()\r\n    this.loadMenus()\r\n    this.registerDeserializerMethods()\r\n    this.activateCoreStartupServices()\r\n    this.registerURIHandler()\r\n    this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n    this.requireMainModule()\r\n    this.settingsPromise = this.loadSettings()\r\n\r\n    this.activationDisposables = new CompositeDisposable()\r\n    this.activateKeymaps()\r\n    this.activateMenus()\r\n    for (let settings of this.settings) {\r\n      settings.activate(this.config)\r\n    }\r\n    this.settingsActivated = true\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.loadMenus","start_line":453,"end_line":466,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"registerDeserializerMethods","line":94,"func_location":"Package.preload","func_start_line":91,"func_end_line":108,"args":[],"code":"  preload () {\r\n    this.loadKeymaps()\r\n    this.loadMenus()\r\n    this.registerDeserializerMethods()\r\n    this.activateCoreStartupServices()\r\n    this.registerURIHandler()\r\n    this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n    this.requireMainModule()\r\n    this.settingsPromise = this.loadSettings()\r\n\r\n    this.activationDisposables = new CompositeDisposable()\r\n    this.activateKeymaps()\r\n    this.activateMenus()\r\n    for (let settings of this.settings) {\r\n      settings.activate(this.config)\r\n    }\r\n    this.settingsActivated = true\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.registerDeserializerMethods","start_line":492,"end_line":507,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"activateCoreStartupServices","line":95,"func_location":"Package.preload","func_start_line":91,"func_end_line":108,"args":[],"code":"  preload () {\r\n    this.loadKeymaps()\r\n    this.loadMenus()\r\n    this.registerDeserializerMethods()\r\n    this.activateCoreStartupServices()\r\n    this.registerURIHandler()\r\n    this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n    this.requireMainModule()\r\n    this.settingsPromise = this.loadSettings()\r\n\r\n    this.activationDisposables = new CompositeDisposable()\r\n    this.activateKeymaps()\r\n    this.activateMenus()\r\n    for (let settings of this.settings) {\r\n      settings.activate(this.config)\r\n    }\r\n    this.settingsActivated = true\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.activateCoreStartupServices","start_line":509,"end_line":524,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"registerURIHandler","line":96,"func_location":"Package.preload","func_start_line":91,"func_end_line":108,"args":[],"code":"  preload () {\r\n    this.loadKeymaps()\r\n    this.loadMenus()\r\n    this.registerDeserializerMethods()\r\n    this.activateCoreStartupServices()\r\n    this.registerURIHandler()\r\n    this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n    this.requireMainModule()\r\n    this.settingsPromise = this.loadSettings()\r\n\r\n    this.activationDisposables = new CompositeDisposable()\r\n    this.activateKeymaps()\r\n    this.activateMenus()\r\n    for (let settings of this.settings) {\r\n      settings.activate(this.config)\r\n    }\r\n    this.settingsActivated = true\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.registerURIHandler","start_line":405,"end_line":413,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"registerConfigSchemaFromMetadata","line":97,"func_location":"Package.preload","func_start_line":91,"func_end_line":108,"args":[],"code":"  preload () {\r\n    this.loadKeymaps()\r\n    this.loadMenus()\r\n    this.registerDeserializerMethods()\r\n    this.activateCoreStartupServices()\r\n    this.registerURIHandler()\r\n    this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n    this.requireMainModule()\r\n    this.settingsPromise = this.loadSettings()\r\n\r\n    this.activationDisposables = new CompositeDisposable()\r\n    this.activateKeymaps()\r\n    this.activateMenus()\r\n    for (let settings of this.settings) {\r\n      settings.activate(this.config)\r\n    }\r\n    this.settingsActivated = true\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.registerConfigSchemaFromMetadata","start_line":238,"end_line":246,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"requireMainModule","line":98,"func_location":"Package.preload","func_start_line":91,"func_end_line":108,"args":[],"code":"  preload () {\r\n    this.loadKeymaps()\r\n    this.loadMenus()\r\n    this.registerDeserializerMethods()\r\n    this.activateCoreStartupServices()\r\n    this.registerURIHandler()\r\n    this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n    this.requireMainModule()\r\n    this.settingsPromise = this.loadSettings()\r\n\r\n    this.activationDisposables = new CompositeDisposable()\r\n    this.activateKeymaps()\r\n    this.activateMenus()\r\n    for (let settings of this.settings) {\r\n      settings.activate(this.config)\r\n    }\r\n    this.settingsActivated = true\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.requireMainModule","start_line":755,"end_line":784,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"loadSettings","line":99,"func_location":"Package.preload","func_start_line":91,"func_end_line":108,"args":[],"code":"  preload () {\r\n    this.loadKeymaps()\r\n    this.loadMenus()\r\n    this.registerDeserializerMethods()\r\n    this.activateCoreStartupServices()\r\n    this.registerURIHandler()\r\n    this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n    this.requireMainModule()\r\n    this.settingsPromise = this.loadSettings()\r\n\r\n    this.activationDisposables = new CompositeDisposable()\r\n    this.activateKeymaps()\r\n    this.activateMenus()\r\n    for (let settings of this.settings) {\r\n      settings.activate(this.config)\r\n    }\r\n    this.settingsActivated = true\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.loadSettings","start_line":634,"end_line":671,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"activateKeymaps","line":102,"func_location":"Package.preload","func_start_line":91,"func_end_line":108,"args":[],"code":"  preload () {\r\n    this.loadKeymaps()\r\n    this.loadMenus()\r\n    this.registerDeserializerMethods()\r\n    this.activateCoreStartupServices()\r\n    this.registerURIHandler()\r\n    this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n    this.requireMainModule()\r\n    this.settingsPromise = this.loadSettings()\r\n\r\n    this.activationDisposables = new CompositeDisposable()\r\n    this.activateKeymaps()\r\n    this.activateMenus()\r\n    for (let settings of this.settings) {\r\n      settings.activate(this.config)\r\n    }\r\n    this.settingsActivated = true\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.activateKeymaps","start_line":326,"end_line":338,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"activateMenus","line":103,"func_location":"Package.preload","func_start_line":91,"func_end_line":108,"args":[],"code":"  preload () {\r\n    this.loadKeymaps()\r\n    this.loadMenus()\r\n    this.registerDeserializerMethods()\r\n    this.activateCoreStartupServices()\r\n    this.registerURIHandler()\r\n    this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n    this.requireMainModule()\r\n    this.settingsPromise = this.loadSettings()\r\n\r\n    this.activationDisposables = new CompositeDisposable()\r\n    this.activateKeymaps()\r\n    this.activateMenus()\r\n    for (let settings of this.settings) {\r\n      settings.activate(this.config)\r\n    }\r\n    this.settingsActivated = true\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.activateMenus","start_line":356,"end_line":378,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"preloadPackage","line":495,"func_location":"PackageManager.preloadPackages","func_start_line":492,"func_end_line":498,"args":[null],"code":"  preloadPackages () {\r\n    const result = []\r\n    for (const packageName in this.packagesCache) {\r\n      result.push(this.preloadPackage(packageName, this.packagesCache[packageName]))\r\n    }\r\n    return result\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.preloadPackage","start_line":500,"end_line":534,"comment":[],"params":["packageName","pack"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"isSpecWindow","line":228,"func_location":"AtomWindow.prepareToUnload","func_start_line":227,"func_end_line":246,"args":[],"code":"  async prepareToUnload () {\r\n    if (this.isSpecWindow()) return true\r\n\r\n    this.lastPrepareToUnloadPromise = new Promise(resolve => {\r\n      const callback = (event, result) => {\r\n        if (BrowserWindow.fromWebContents(event.sender) === this.browserWindow) {\r\n          ipcMain.removeListener('did-prepare-to-unload', callback)\r\n          if (!result) {\r\n            this.unloading = false\r\n            this.atomApplication.quitting = false\r\n          }\r\n          resolve(result)\r\n        }\r\n      }\r\n      ipcMain.on('did-prepare-to-unload', callback)\r\n      this.browserWindow.webContents.send('prepare-to-unload')\r\n    })\r\n\r\n    return this.lastPrepareToUnloadPromise\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"AtomWindow.isSpecWindow","start_line":382,"end_line":384,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"saveState","line":884,"func_location":"AtomEnvironment.prepareToUnloadEditorWindow","func_start_line":882,"func_end_line":899,"args":[null],"code":"  async prepareToUnloadEditorWindow () {\r\n    try {\r\n      await this.saveState({isUnloading: true})\r\n    } catch (error) {\r\n      console.error(error)\r\n    }\r\n\r\n    const closing = !this.workspace || await this.workspace.confirmClose({\r\n      windowCloseRequested: true,\r\n      projectHasPaths: this.project.getPaths().length > 0\r\n    })\r\n\r\n    if (closing) {\r\n      this.unloading = true\r\n      await this.packages.deactivatePackages()\r\n    }\r\n    return closing\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.saveState","start_line":1198,"end_line":1208,"comment":[],"params":["options","storageKey"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/window.js","name":"measure","line":24,"func_location":"window.profile","func_start_line":23,"func_end_line":30},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/window.js","name":"window.measure","start_line":8,"end_line":14,"comment":[" Public: Measure how long a function takes to run.",""," description - A {String} description that will be logged to the console when","               the function completes."," fn - A {Function} to measure the duration of.",""," Returns the value returned by the given function."],"params":["description","fn"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"promptForPath","line":1310,"func_location":"AtomApplication.promptForPathToOpen","func_start_line":1309,"func_end_line":1317},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.promptForPath","start_line":1319,"end_line":1347,"comment":[],"params":["type","callback","path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"get","line":872,"func_location":"Config.pushAtKeyPath","func_start_line":871,"func_end_line":877,"args":["keyPath"],"code":"  pushAtKeyPath (keyPath, value) {\r\n    const left = this.get(keyPath)\r\n    const arrayValue = (left == null ? [] : left)\r\n    const result = arrayValue.push(value)\r\n    this.set(keyPath, arrayValue)\r\n    return result\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.get","start_line":585,"end_line":602,"comment":["\r\n  Section: Managing Settings\r\n  "," Essential: Retrieves the setting for the given key.",""," ### Examples",""," You might want to know what themes are enabled, so check `core.themes`",""," ```coffee"," atom.config.get('core.themes')"," ```",""," With scope descriptors you can get settings within a specific editor"," scope. For example, you might want to know `editor.tabLength` for ruby"," files.",""," ```coffee"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," ```",""," This setting in ruby files might be different than the global tabLength setting",""," ```coffee"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," ```",""," You can get the language scope descriptor via"," {TextEditor::getRootScopeDescriptor}. This will get the setting specifically"," for the editor's language.",""," ```coffee"," atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2"," ```",""," Additionally, you can get the setting at the specific cursor position.",""," ```coffee"," scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()"," atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2"," ```",""," * `keyPath` The {String} name of the key to retrieve."," * `options` (optional) {Object}","   * `sources` (optional) {Array} of {String} source names. If provided, only","     values that were associated with these sources during {::set} will be used.","   * `excludeSources` (optional) {Array} of {String} source names. If provided,","     values that  were associated with these sources during {::set} will not","     be used.","   * `scope` (optional) {ScopeDescriptor} describing a path from","     the root of the syntax tree to a token. Get one by calling","     {editor.getLastCursor().getScopeDescriptor()}","     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)","     for more information.",""," Returns the value from Atom's default settings, the user's configuration"," file in the type specified by the configuration schema."],"params":["args"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"set","line":875,"func_location":"Config.pushAtKeyPath","func_start_line":871,"func_end_line":877,"args":["keyPath","arrayValue"],"code":"  pushAtKeyPath (keyPath, value) {\r\n    const left = this.get(keyPath)\r\n    const arrayValue = (left == null ? [] : left)\r\n    const result = arrayValue.push(value)\r\n    this.set(keyPath, arrayValue)\r\n    return result\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.set","start_line":687,"end_line":722,"comment":[" Essential: Sets the value for a configuration setting.",""," This value is stored in Atom's internal configuration file.",""," ### Examples",""," You might want to change the themes programmatically:",""," ```coffee"," atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])"," ```",""," You can also set scoped settings. For example, you might want change the"," `editor.tabLength` only for ruby files.",""," ```coffee"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4"," atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",""," # Set ruby to 2"," atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true",""," # Notice it's only set to 2 in the case of ruby"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," atom.config.get('editor.tabLength', scope: ['source.js']) # => 4"," ```",""," * `keyPath` The {String} name of the key."," * `value` The value of the setting. Passing `undefined` will revert the","   setting to the default value."," * `options` (optional) {Object}","   * `scopeSelector` (optional) {String}. eg. '.source.ruby'","     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)","     for more information.","   * `source` (optional) {String} The name of a file with which the setting","     is associated. Defaults to the user's config file.",""," Returns a {Boolean}"," * `true` if the value was set."," * `false` if the value was not able to be coerced to the type specified in the setting's schema."],"params":["args"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedStartRow","line":995,"func_location":"TextEditorComponent.queryDecorationsToRender","func_start_line":981,"func_end_line":1009,"args":[],"code":"  queryDecorationsToRender () {\r\n    this.decorationsToRender.lineNumbers.clear()\r\n    this.decorationsToRender.lines = []\r\n    this.decorationsToRender.overlays.length = 0\r\n    this.decorationsToRender.customGutter.clear()\r\n    this.decorationsToRender.blocks = new Map()\r\n    this.decorationsToRender.text = []\r\n    this.decorationsToMeasure.highlights.length = 0\r\n    this.decorationsToMeasure.cursors.clear()\r\n    this.textDecorationsByMarker.clear()\r\n    this.textDecorationBoundaries.length = 0\r\n\r\n    const decorationsByMarker =\r\n      this.props.model.decorationManager.decorationPropertiesByMarkerForScreenRowRange(\r\n        this.getRenderedStartRow(),\r\n        this.getRenderedEndRow()\r\n      )\r\n\r\n    decorationsByMarker.forEach((decorations, marker) => {\r\n      const screenRange = marker.getScreenRange()\r\n      const reversed = marker.isReversed()\r\n      for (let i = 0; i < decorations.length; i++) {\r\n        const decoration = decorations[i]\r\n        this.addDecorationToRender(decoration.type, decoration, marker, screenRange, reversed)\r\n      }\r\n    })\r\n\r\n    this.populateTextDecorationsToRender()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedStartRow","start_line":2720,"end_line":2726,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedEndRow","line":996,"func_location":"TextEditorComponent.queryDecorationsToRender","func_start_line":981,"func_end_line":1009,"args":[],"code":"  queryDecorationsToRender () {\r\n    this.decorationsToRender.lineNumbers.clear()\r\n    this.decorationsToRender.lines = []\r\n    this.decorationsToRender.overlays.length = 0\r\n    this.decorationsToRender.customGutter.clear()\r\n    this.decorationsToRender.blocks = new Map()\r\n    this.decorationsToRender.text = []\r\n    this.decorationsToMeasure.highlights.length = 0\r\n    this.decorationsToMeasure.cursors.clear()\r\n    this.textDecorationsByMarker.clear()\r\n    this.textDecorationBoundaries.length = 0\r\n\r\n    const decorationsByMarker =\r\n      this.props.model.decorationManager.decorationPropertiesByMarkerForScreenRowRange(\r\n        this.getRenderedStartRow(),\r\n        this.getRenderedEndRow()\r\n      )\r\n\r\n    decorationsByMarker.forEach((decorations, marker) => {\r\n      const screenRange = marker.getScreenRange()\r\n      const reversed = marker.isReversed()\r\n      for (let i = 0; i < decorations.length; i++) {\r\n        const decoration = decorations[i]\r\n        this.addDecorationToRender(decoration.type, decoration, marker, screenRange, reversed)\r\n      }\r\n    })\r\n\r\n    this.populateTextDecorationsToRender()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedEndRow","start_line":2728,"end_line":2737,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"populateTextDecorationsToRender","line":1008,"func_location":"TextEditorComponent.queryDecorationsToRender","func_start_line":981,"func_end_line":1009,"args":[],"code":"  queryDecorationsToRender () {\r\n    this.decorationsToRender.lineNumbers.clear()\r\n    this.decorationsToRender.lines = []\r\n    this.decorationsToRender.overlays.length = 0\r\n    this.decorationsToRender.customGutter.clear()\r\n    this.decorationsToRender.blocks = new Map()\r\n    this.decorationsToRender.text = []\r\n    this.decorationsToMeasure.highlights.length = 0\r\n    this.decorationsToMeasure.cursors.clear()\r\n    this.textDecorationsByMarker.clear()\r\n    this.textDecorationBoundaries.length = 0\r\n\r\n    const decorationsByMarker =\r\n      this.props.model.decorationManager.decorationPropertiesByMarkerForScreenRowRange(\r\n        this.getRenderedStartRow(),\r\n        this.getRenderedEndRow()\r\n      )\r\n\r\n    decorationsByMarker.forEach((decorations, marker) => {\r\n      const screenRange = marker.getScreenRange()\r\n      const reversed = marker.isReversed()\r\n      for (let i = 0; i < decorations.length; i++) {\r\n        const decoration = decorations[i]\r\n        this.addDecorationToRender(decoration.type, decoration, marker, screenRange, reversed)\r\n      }\r\n    })\r\n\r\n    this.populateTextDecorationsToRender()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.populateTextDecorationsToRender","start_line":1209,"end_line":1309,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"queryMaxLineNumberDigits","line":897,"func_location":"TextEditorComponent.queryLineNumbersToRender","func_start_line":889,"func_end_line":943,"args":[],"code":"  queryLineNumbersToRender () {\r\n    const {model} = this.props\r\n    if (!model.anyLineNumberGutterVisible()) return\r\n    if (this.showLineNumbers !== model.doesShowLineNumbers()) {\r\n      this.remeasureGutterDimensions = true\r\n      this.showLineNumbers = model.doesShowLineNumbers()\r\n    }\r\n\r\n    this.queryMaxLineNumberDigits()\r\n\r\n    const startRow = this.getRenderedStartRow()\r\n    const endRow = this.getRenderedEndRow()\r\n    const renderedRowCount = this.getRenderedRowCount()\r\n\r\n    const bufferRows = model.bufferRowsForScreenRows(startRow, endRow)\r\n    const screenRows = new Array(renderedRowCount)\r\n    const keys = new Array(renderedRowCount)\r\n    const foldableFlags = new Array(renderedRowCount)\r\n    const softWrappedFlags = new Array(renderedRowCount)\r\n\r\n    let previousBufferRow = (startRow > 0) ? model.bufferRowForScreenRow(startRow - 1) : -1\r\n    let softWrapCount = 0\r\n    for (let row = startRow; row < endRow; row++) {\r\n      const i = row - startRow\r\n      const bufferRow = bufferRows[i]\r\n      if (bufferRow === previousBufferRow) {\r\n        softWrapCount++\r\n        softWrappedFlags[i] = true\r\n        keys[i] = bufferRow + '-' + softWrapCount\r\n      } else {\r\n        softWrapCount = 0\r\n        softWrappedFlags[i] = false\r\n        keys[i] = bufferRow\r\n      }\r\n\r\n      const nextBufferRow = bufferRows[i + 1]\r\n      if (bufferRow !== nextBufferRow) {\r\n        foldableFlags[i] = model.isFoldableAtBufferRow(bufferRow)\r\n      } else {\r\n        foldableFlags[i] = false\r\n      }\r\n\r\n      screenRows[i] = row\r\n      previousBufferRow = bufferRow\r\n    }\r\n\r\n    // Delete extra buffer row at the end because it's not currently on screen.\r\n    bufferRows.pop()\r\n\r\n    this.lineNumbersToRender.bufferRows = bufferRows\r\n    this.lineNumbersToRender.screenRows = screenRows\r\n    this.lineNumbersToRender.keys = keys\r\n    this.lineNumbersToRender.foldableFlags = foldableFlags\r\n    this.lineNumbersToRender.softWrappedFlags = softWrappedFlags\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.queryMaxLineNumberDigits","start_line":945,"end_line":954,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedStartRow","line":899,"func_location":"TextEditorComponent.queryLineNumbersToRender","func_start_line":889,"func_end_line":943,"args":[],"code":"  queryLineNumbersToRender () {\r\n    const {model} = this.props\r\n    if (!model.anyLineNumberGutterVisible()) return\r\n    if (this.showLineNumbers !== model.doesShowLineNumbers()) {\r\n      this.remeasureGutterDimensions = true\r\n      this.showLineNumbers = model.doesShowLineNumbers()\r\n    }\r\n\r\n    this.queryMaxLineNumberDigits()\r\n\r\n    const startRow = this.getRenderedStartRow()\r\n    const endRow = this.getRenderedEndRow()\r\n    const renderedRowCount = this.getRenderedRowCount()\r\n\r\n    const bufferRows = model.bufferRowsForScreenRows(startRow, endRow)\r\n    const screenRows = new Array(renderedRowCount)\r\n    const keys = new Array(renderedRowCount)\r\n    const foldableFlags = new Array(renderedRowCount)\r\n    const softWrappedFlags = new Array(renderedRowCount)\r\n\r\n    let previousBufferRow = (startRow > 0) ? model.bufferRowForScreenRow(startRow - 1) : -1\r\n    let softWrapCount = 0\r\n    for (let row = startRow; row < endRow; row++) {\r\n      const i = row - startRow\r\n      const bufferRow = bufferRows[i]\r\n      if (bufferRow === previousBufferRow) {\r\n        softWrapCount++\r\n        softWrappedFlags[i] = true\r\n        keys[i] = bufferRow + '-' + softWrapCount\r\n      } else {\r\n        softWrapCount = 0\r\n        softWrappedFlags[i] = false\r\n        keys[i] = bufferRow\r\n      }\r\n\r\n      const nextBufferRow = bufferRows[i + 1]\r\n      if (bufferRow !== nextBufferRow) {\r\n        foldableFlags[i] = model.isFoldableAtBufferRow(bufferRow)\r\n      } else {\r\n        foldableFlags[i] = false\r\n      }\r\n\r\n      screenRows[i] = row\r\n      previousBufferRow = bufferRow\r\n    }\r\n\r\n    // Delete extra buffer row at the end because it's not currently on screen.\r\n    bufferRows.pop()\r\n\r\n    this.lineNumbersToRender.bufferRows = bufferRows\r\n    this.lineNumbersToRender.screenRows = screenRows\r\n    this.lineNumbersToRender.keys = keys\r\n    this.lineNumbersToRender.foldableFlags = foldableFlags\r\n    this.lineNumbersToRender.softWrappedFlags = softWrappedFlags\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedStartRow","start_line":2720,"end_line":2726,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedEndRow","line":900,"func_location":"TextEditorComponent.queryLineNumbersToRender","func_start_line":889,"func_end_line":943,"args":[],"code":"  queryLineNumbersToRender () {\r\n    const {model} = this.props\r\n    if (!model.anyLineNumberGutterVisible()) return\r\n    if (this.showLineNumbers !== model.doesShowLineNumbers()) {\r\n      this.remeasureGutterDimensions = true\r\n      this.showLineNumbers = model.doesShowLineNumbers()\r\n    }\r\n\r\n    this.queryMaxLineNumberDigits()\r\n\r\n    const startRow = this.getRenderedStartRow()\r\n    const endRow = this.getRenderedEndRow()\r\n    const renderedRowCount = this.getRenderedRowCount()\r\n\r\n    const bufferRows = model.bufferRowsForScreenRows(startRow, endRow)\r\n    const screenRows = new Array(renderedRowCount)\r\n    const keys = new Array(renderedRowCount)\r\n    const foldableFlags = new Array(renderedRowCount)\r\n    const softWrappedFlags = new Array(renderedRowCount)\r\n\r\n    let previousBufferRow = (startRow > 0) ? model.bufferRowForScreenRow(startRow - 1) : -1\r\n    let softWrapCount = 0\r\n    for (let row = startRow; row < endRow; row++) {\r\n      const i = row - startRow\r\n      const bufferRow = bufferRows[i]\r\n      if (bufferRow === previousBufferRow) {\r\n        softWrapCount++\r\n        softWrappedFlags[i] = true\r\n        keys[i] = bufferRow + '-' + softWrapCount\r\n      } else {\r\n        softWrapCount = 0\r\n        softWrappedFlags[i] = false\r\n        keys[i] = bufferRow\r\n      }\r\n\r\n      const nextBufferRow = bufferRows[i + 1]\r\n      if (bufferRow !== nextBufferRow) {\r\n        foldableFlags[i] = model.isFoldableAtBufferRow(bufferRow)\r\n      } else {\r\n        foldableFlags[i] = false\r\n      }\r\n\r\n      screenRows[i] = row\r\n      previousBufferRow = bufferRow\r\n    }\r\n\r\n    // Delete extra buffer row at the end because it's not currently on screen.\r\n    bufferRows.pop()\r\n\r\n    this.lineNumbersToRender.bufferRows = bufferRows\r\n    this.lineNumbersToRender.screenRows = screenRows\r\n    this.lineNumbersToRender.keys = keys\r\n    this.lineNumbersToRender.foldableFlags = foldableFlags\r\n    this.lineNumbersToRender.softWrappedFlags = softWrappedFlags\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedEndRow","start_line":2728,"end_line":2737,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedRowCount","line":901,"func_location":"TextEditorComponent.queryLineNumbersToRender","func_start_line":889,"func_end_line":943,"args":[],"code":"  queryLineNumbersToRender () {\r\n    const {model} = this.props\r\n    if (!model.anyLineNumberGutterVisible()) return\r\n    if (this.showLineNumbers !== model.doesShowLineNumbers()) {\r\n      this.remeasureGutterDimensions = true\r\n      this.showLineNumbers = model.doesShowLineNumbers()\r\n    }\r\n\r\n    this.queryMaxLineNumberDigits()\r\n\r\n    const startRow = this.getRenderedStartRow()\r\n    const endRow = this.getRenderedEndRow()\r\n    const renderedRowCount = this.getRenderedRowCount()\r\n\r\n    const bufferRows = model.bufferRowsForScreenRows(startRow, endRow)\r\n    const screenRows = new Array(renderedRowCount)\r\n    const keys = new Array(renderedRowCount)\r\n    const foldableFlags = new Array(renderedRowCount)\r\n    const softWrappedFlags = new Array(renderedRowCount)\r\n\r\n    let previousBufferRow = (startRow > 0) ? model.bufferRowForScreenRow(startRow - 1) : -1\r\n    let softWrapCount = 0\r\n    for (let row = startRow; row < endRow; row++) {\r\n      const i = row - startRow\r\n      const bufferRow = bufferRows[i]\r\n      if (bufferRow === previousBufferRow) {\r\n        softWrapCount++\r\n        softWrappedFlags[i] = true\r\n        keys[i] = bufferRow + '-' + softWrapCount\r\n      } else {\r\n        softWrapCount = 0\r\n        softWrappedFlags[i] = false\r\n        keys[i] = bufferRow\r\n      }\r\n\r\n      const nextBufferRow = bufferRows[i + 1]\r\n      if (bufferRow !== nextBufferRow) {\r\n        foldableFlags[i] = model.isFoldableAtBufferRow(bufferRow)\r\n      } else {\r\n        foldableFlags[i] = false\r\n      }\r\n\r\n      screenRows[i] = row\r\n      previousBufferRow = bufferRow\r\n    }\r\n\r\n    // Delete extra buffer row at the end because it's not currently on screen.\r\n    bufferRows.pop()\r\n\r\n    this.lineNumbersToRender.bufferRows = bufferRows\r\n    this.lineNumbersToRender.screenRows = screenRows\r\n    this.lineNumbersToRender.keys = keys\r\n    this.lineNumbersToRender.foldableFlags = foldableFlags\r\n    this.lineNumbersToRender.softWrappedFlags = softWrappedFlags\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedRowCount","start_line":2739,"end_line":2745,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"requestLineToMeasure","line":874,"func_location":"TextEditorComponent.queryLongestLine","func_start_line":868,"func_end_line":878,"args":["longestLineRow","longestLine"],"code":"  queryLongestLine () {\r\n    const {model} = this.props\r\n\r\n    const longestLineRow = model.getApproximateLongestScreenRow()\r\n    const longestLine = model.screenLineForScreenRow(longestLineRow)\r\n    if (longestLine !== this.previousLongestLine || this.remeasureCharacterDimensions) {\r\n      this.requestLineToMeasure(longestLineRow, longestLine)\r\n      this.longestLineToMeasure = longestLine\r\n      this.previousLongestLine = longestLine\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.requestLineToMeasure","start_line":2239,"end_line":2241,"comment":[],"params":["row","screenLine"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedStartRow","line":863,"func_location":"TextEditorComponent.queryScreenLinesToRender","func_start_line":859,"func_end_line":866,"args":[],"code":"  queryScreenLinesToRender () {\r\n    const {model} = this.props\r\n\r\n    this.renderedScreenLines = model.displayLayer.getScreenLines(\r\n      this.getRenderedStartRow(),\r\n      this.getRenderedEndRow()\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedStartRow","start_line":2720,"end_line":2726,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedEndRow","line":864,"func_location":"TextEditorComponent.queryScreenLinesToRender","func_start_line":859,"func_end_line":866,"args":[],"code":"  queryScreenLinesToRender () {\r\n    const {model} = this.props\r\n\r\n    this.renderedScreenLines = model.displayLayer.getScreenLines(\r\n      this.getRenderedStartRow(),\r\n      this.getRenderedEndRow()\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedEndRow","start_line":2728,"end_line":2737,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"vecFromRange","line":1181,"func_location":"rangeIsSmaller","func_start_line":1179,"func_end_line":1184,"args":["mouse"],"comment":[" Return true iff `mouse` is smaller than `house`. Only correct if"," mouse and house overlap.",""," * `mouse` {Range}"," * `house` {Range}"],"code":"function rangeIsSmaller (mouse, house) {\r\n  if (!house) return true\r\n  const mvec = vecFromRange(mouse)\r\n  const hvec = vecFromRange(house)\r\n  return Point.min(mvec, hvec) === mvec\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"vecFromRange","start_line":1186,"end_line":1188,"comment":[],"params":[["start","end"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"vecFromRange","line":1182,"func_location":"rangeIsSmaller","func_start_line":1179,"func_end_line":1184,"args":["house"],"comment":[" Return true iff `mouse` is smaller than `house`. Only correct if"," mouse and house overlap.",""," * `mouse` {Range}"," * `house` {Range}"],"code":"function rangeIsSmaller (mouse, house) {\r\n  if (!house) return true\r\n  const mvec = vecFromRange(mouse)\r\n  const hvec = vecFromRange(house)\r\n  return Point.min(mvec, hvec) === mvec\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"vecFromRange","start_line":1186,"end_line":1188,"comment":[],"params":[["start","end"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/view-registry.js","name":"requestDocumentUpdate","line":197,"func_location":"ViewRegistry.readDocument","func_start_line":195,"func_end_line":201,"args":[],"code":"  readDocument (fn) {\r\n    this.documentReaders.push(fn)\r\n    this.requestDocumentUpdate()\r\n    return new Disposable(() => {\r\n      this.documentReaders = this.documentReaders.filter(reader => reader !== fn)\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/view-registry.js","name":"ViewRegistry.requestDocumentUpdate","start_line":224,"end_line":228,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"createGrammar","line":535,"func_location":"GrammarRegistry.readGrammarSync","func_start_line":534,"func_end_line":536,"args":["grammarPath",null],"comment":[" Extended: Read a grammar synchronously but don't add it to the registry.",""," * `grammarPath` A {String} absolute file path to a grammar file.",""," Returns a {Grammar}."],"code":"  readGrammarSync (grammarPath) {\r\n    return this.createGrammar(grammarPath, CSON.readFileSync(grammarPath) || {})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.createGrammar","start_line":538,"end_line":547,"comment":[],"params":["grammarPath","params"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/clipboard.js","name":"read","line":62,"func_location":"Clipboard.readWithMetadata","func_start_line":61,"func_end_line":68,"args":[],"comment":[" Public: Read the text from the clipboard and return both the text and the"," associated metadata.",""," Returns an {Object} with the following keys:"," * `text` The {String} clipboard text."," * `metadata` The metadata stored by an earlier call to {::write}."],"code":"  readWithMetadata () {\r\n    const text = this.read()\r\n    if (this.signatureForMetadata === this.md5(text)) {\r\n      return {text, metadata: this.metadata}\r\n    } else {\r\n      return {text}\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/clipboard.js","name":"Clipboard.read","start_line":51,"end_line":53,"comment":[" Public: Read the text from the clipboard.",""," Returns a {String}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/clipboard.js","name":"md5","line":63,"func_location":"Clipboard.readWithMetadata","func_start_line":61,"func_end_line":68,"args":["text"],"comment":[" Public: Read the text from the clipboard and return both the text and the"," associated metadata.",""," Returns an {Object} with the following keys:"," * `text` The {String} clipboard text."," * `metadata` The metadata stored by an earlier call to {::write}."],"code":"  readWithMetadata () {\r\n    const text = this.read()\r\n    if (this.signatureForMetadata === this.md5(text)) {\r\n      return {text, metadata: this.metadata}\r\n    } else {\r\n      return {text}\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/clipboard.js","name":"Clipboard.md5","start_line":31,"end_line":33,"comment":[" Creates an `md5` hash of some text.",""," * `text` A {String} to hash.",""," Returns a hashed {String}."],"params":["text"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js","name":"copyFile","line":114,"func_location":"RecoveryFile.recover","func_start_line":113,"func_end_line":116,"args":[".recoveryPath",".originalPath",".fileMode"],"code":"  async recover () {\r\n    await copyFile(this.recoveryPath, this.originalPath, this.fileMode)\r\n    await this.remove()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js","name":"copyFile","start_line":149,"end_line":165,"comment":[],"params":["source","destination","mode"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js","name":"remove","line":115,"func_location":"RecoveryFile.recover","func_start_line":113,"func_end_line":116,"args":[],"code":"  async recover () {\r\n    await copyFile(this.recoveryPath, this.originalPath, this.fileMode)\r\n    await this.remove()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js","name":"RecoveryFile.remove","start_line":118,"end_line":124,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getRepo","line":535,"func_location":"GitRepository.refreshIndex","func_start_line":534,"func_end_line":536,"args":[],"comment":[" Reread the index to update any values that have changed since the"," last time the index was read."],"code":"  refreshIndex () {\r\n    return this.getRepo().refreshIndex()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getRepo","start_line":524,"end_line":530,"comment":[" Returns the corresponding {Repository}"],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"getImportPaths","line":378,"func_location":"ThemeManager.refreshLessCache","func_start_line":377,"func_end_line":379,"args":[null],"code":"  refreshLessCache () {\r\n    if (this.lessCache) this.lessCache.setImportPaths(this.getImportPaths())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.getImportPaths","start_line":381,"end_line":402,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getRepo","line":542,"func_location":"GitRepository.refreshStatus","func_start_line":540,"func_end_line":594,"args":[],"comment":[" Refreshes the current git status in an outside process and asynchronously"," updates the relevant properties."],"code":"  async refreshStatus () {\r\n    const statusRefreshCount = ++this.statusRefreshCount\r\n    const repo = this.getRepo()\r\n\r\n    const relativeProjectPaths = this.project && this.project.getPaths()\r\n      .map(projectPath => this.relativize(projectPath))\r\n      .filter(projectPath => (projectPath.length > 0) && !path.isAbsolute(projectPath))\r\n\r\n    const branch = await repo.getHeadAsync()\r\n    const upstream = await repo.getAheadBehindCountAsync()\r\n\r\n    const statuses = {}\r\n    const repoStatus = relativeProjectPaths.length > 0\r\n      ? await repo.getStatusAsync(relativeProjectPaths)\r\n      : await repo.getStatusAsync()\r\n    for (let filePath in repoStatus) {\r\n      statuses[filePath] = repoStatus[filePath]\r\n    }\r\n\r\n    const submodules = {}\r\n    for (let submodulePath in repo.submodules) {\r\n      const submoduleRepo = repo.submodules[submodulePath]\r\n      submodules[submodulePath] = {\r\n        branch: await submoduleRepo.getHeadAsync(),\r\n        upstream: await submoduleRepo.getAheadBehindCountAsync()\r\n      }\r\n\r\n      const workingDirectoryPath = submoduleRepo.getWorkingDirectory()\r\n      const submoduleStatus = await submoduleRepo.getStatusAsync()\r\n      for (let filePath in submoduleStatus) {\r\n        const absolutePath = path.join(workingDirectoryPath, filePath)\r\n        const relativizePath = repo.relativize(absolutePath)\r\n        statuses[relativizePath] = submoduleStatus[filePath]\r\n      }\r\n    }\r\n\r\n    if (this.statusRefreshCount !== statusRefreshCount || this.isDestroyed()) return\r\n\r\n    const statusesUnchanged =\r\n      _.isEqual(branch, this.branch) &&\r\n      _.isEqual(statuses, this.statuses) &&\r\n      _.isEqual(upstream, this.upstream) &&\r\n      _.isEqual(submodules, this.submodules)\r\n\r\n    this.branch = branch\r\n    this.statuses = statuses\r\n    this.upstream = upstream\r\n    this.submodules = submodules\r\n\r\n    for (let submodulePath in repo.submodules) {\r\n      repo.submodules[submodulePath].upstream = submodules[submodulePath].upstream\r\n    }\r\n\r\n    if (!statusesUnchanged) this.emitter.emit('did-change-statuses')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getRepo","start_line":524,"end_line":530,"comment":[" Returns the corresponding {Repository}"],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"isDestroyed","line":576,"func_location":"GitRepository.refreshStatus","func_start_line":540,"func_end_line":594,"args":[],"comment":[" Refreshes the current git status in an outside process and asynchronously"," updates the relevant properties."],"code":"  async refreshStatus () {\r\n    const statusRefreshCount = ++this.statusRefreshCount\r\n    const repo = this.getRepo()\r\n\r\n    const relativeProjectPaths = this.project && this.project.getPaths()\r\n      .map(projectPath => this.relativize(projectPath))\r\n      .filter(projectPath => (projectPath.length > 0) && !path.isAbsolute(projectPath))\r\n\r\n    const branch = await repo.getHeadAsync()\r\n    const upstream = await repo.getAheadBehindCountAsync()\r\n\r\n    const statuses = {}\r\n    const repoStatus = relativeProjectPaths.length > 0\r\n      ? await repo.getStatusAsync(relativeProjectPaths)\r\n      : await repo.getStatusAsync()\r\n    for (let filePath in repoStatus) {\r\n      statuses[filePath] = repoStatus[filePath]\r\n    }\r\n\r\n    const submodules = {}\r\n    for (let submodulePath in repo.submodules) {\r\n      const submoduleRepo = repo.submodules[submodulePath]\r\n      submodules[submodulePath] = {\r\n        branch: await submoduleRepo.getHeadAsync(),\r\n        upstream: await submoduleRepo.getAheadBehindCountAsync()\r\n      }\r\n\r\n      const workingDirectoryPath = submoduleRepo.getWorkingDirectory()\r\n      const submoduleStatus = await submoduleRepo.getStatusAsync()\r\n      for (let filePath in submoduleStatus) {\r\n        const absolutePath = path.join(workingDirectoryPath, filePath)\r\n        const relativizePath = repo.relativize(absolutePath)\r\n        statuses[relativizePath] = submoduleStatus[filePath]\r\n      }\r\n    }\r\n\r\n    if (this.statusRefreshCount !== statusRefreshCount || this.isDestroyed()) return\r\n\r\n    const statusesUnchanged =\r\n      _.isEqual(branch, this.branch) &&\r\n      _.isEqual(statuses, this.statuses) &&\r\n      _.isEqual(upstream, this.upstream) &&\r\n      _.isEqual(submodules, this.submodules)\r\n\r\n    this.branch = branch\r\n    this.statuses = statuses\r\n    this.upstream = upstream\r\n    this.submodules = submodules\r\n\r\n    for (let submodulePath in repo.submodules) {\r\n      repo.submodules[submodulePath].upstream = submodules[submodulePath].upstream\r\n    }\r\n\r\n    if (!statusesUnchanged) this.emitter.emit('did-change-statuses')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.isDestroyed","start_line":130,"end_line":132,"comment":[" Public: Returns a {Boolean} indicating if this repository has been destroyed."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js","name":"registerBuiltins","line":289,"func_location":"exports.register","func_start_line":274,"func_end_line":290,"args":["devMode"],"code":"exports.register = function ({resourcePath, devMode} = {}) {\r\n  if (cache.registered) return\r\n\r\n  const originalResolveFilename = Module._resolveFilename\r\n  Module._resolveFilename = function (relativePath, parentModule) {\r\n    let resolvedPath = resolveModulePath(relativePath, parentModule)\r\n    if (!resolvedPath) {\r\n      resolvedPath = resolveFilePath(relativePath, parentModule)\r\n    }\r\n    return resolvedPath || originalResolveFilename(relativePath, parentModule)\r\n  }\r\n\r\n  cache.registered = true\r\n  cache.resourcePath = resourcePath\r\n  cache.resourcePathWithTrailingSlash = `${resourcePath}${path.sep}`\r\n  registerBuiltins(devMode)\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js","name":"registerBuiltins","start_line":229,"end_line":250,"comment":[],"params":["devMode"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"getURIHandler","line":406,"func_location":"Package.registerURIHandler","func_start_line":405,"func_end_line":413,"args":[],"code":"  registerURIHandler () {\r\n    const handlerConfig = this.getURIHandler()\r\n    const methodName = handlerConfig && handlerConfig.method\r\n    if (methodName) {\r\n      this.uriHandlerSubscription = this.packageManager.registerURIHandlerForPackage(this.name, (...args) =>\r\n        this.handleURI(methodName, args)\r\n      )\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.getURIHandler","start_line":919,"end_line":921,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"requireMainModule","line":528,"func_location":"Package.registerViewProviders","func_start_line":526,"func_end_line":537,"args":[],"code":"  registerViewProviders () {\r\n    if (this.metadata.viewProviders && !this.registeredViewProviders) {\r\n      this.requireMainModule()\r\n      this.metadata.viewProviders.forEach(methodName => {\r\n        this.viewRegistry.addViewProvider(model => {\r\n          this.initializeIfNeeded()\r\n          return this.mainModule[methodName](model)\r\n        })\r\n      })\r\n      this.registeredViewProviders = true\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.requireMainModule","start_line":755,"end_line":784,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"getRepo","line":209,"func_location":"GitRepository.relativize","func_start_line":208,"func_end_line":210,"args":["path"],"comment":[" Public: Makes a path relative to the repository's working directory."],"code":"  relativize (path) {\r\n    return this.getRepo().relativize(path)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js","name":"GitRepository.getRepo","start_line":524,"end_line":530,"comment":[" Returns the corresponding {Repository}"],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"relativizePath","line":533,"func_location":"Project.relativize","func_start_line":532,"func_end_line":534,"args":["fullPath"],"code":"  relativize (fullPath) {\r\n    return this.relativizePath(fullPath)[1]\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.relativizePath","start_line":546,"end_line":557,"comment":[" Public: Get the path to the project directory that contains the given path,"," and the relative path from that project directory to the given path.",""," * `fullPath` {String} An absolute path.",""," Returns an {Array} with two elements:"," * `projectPath` The {String} path to the project directory that contains the","   given path, or `null` if none is found."," * `relativePath` {String} The relative path from the project directory to","   the given path."],"params":["fullPath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"release","line":4480,"func_location":"NodePool.release","func_start_line":4461,"func_end_line":4483,"args":["node.childNodes.i",null],"code":"  release (node, depth = 0) {\r\n    var {nodeName} = node\r\n    if (nodeName === '#text') {\r\n      this.textNodes.push(node)\r\n    } else {\r\n      var elementsByDepth = this.elementsByType[nodeName]\r\n      if (!elementsByDepth) {\r\n        elementsByDepth = []\r\n        this.elementsByType[nodeName] = elementsByDepth\r\n      }\r\n\r\n      var elements = elementsByDepth[depth]\r\n      if (!elements) {\r\n        elements = []\r\n        elementsByDepth[depth] = elements\r\n      }\r\n\r\n      elements.push(node)\r\n      for (var i = 0; i < node.childNodes.length; i++) {\r\n        this.release(node.childNodes[i], depth + 1)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"NodePool.release","start_line":4461,"end_line":4483,"comment":[],"params":["node","depth"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js","name":"isReleased","line":133,"func_location":"RecoveryFile.release","func_start_line":131,"func_end_line":134,"args":[],"code":"  async release () {\r\n    this.refCount--\r\n    if (this.isReleased()) await this.remove()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js","name":"RecoveryFile.isReleased","start_line":136,"end_line":138,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js","name":"remove","line":133,"func_location":"RecoveryFile.release","func_start_line":131,"func_end_line":134,"args":[],"code":"  async release () {\r\n    this.refCount--\r\n    if (this.isReleased()) await this.remove()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js","name":"RecoveryFile.remove","start_line":118,"end_line":124,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"prepareToUnload","line":388,"func_location":"AtomWindow.reload","func_start_line":386,"func_end_line":392,"args":[],"code":"  reload () {\r\n    this.loadedPromise = new Promise(resolve => { this.resolveLoadedPromise = resolve })\r\n    this.prepareToUnload().then(canUnload => {\r\n      if (canUnload) this.browserWindow.reload()\r\n    })\r\n    return this.loadedPromise\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"AtomWindow.prepareToUnload","start_line":227,"end_line":246,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"getActivePackages","line":820,"func_location":"PackageManager.reloadActivePackageStyleSheets","func_start_line":819,"func_end_line":825,"args":[],"code":"  reloadActivePackageStyleSheets () {\r\n    for (const pack of this.getActivePackages()) {\r\n      if (pack.getType() !== 'theme' && typeof pack.reloadStylesheets === 'function') {\r\n        pack.reloadStylesheets()\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.getActivePackages","start_line":291,"end_line":293,"comment":["\r\n  Section: Accessing active packages\r\n  "," Public: Get an {Array} of all the active {Package}s."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"requireStylesheet","line":225,"func_location":"ThemeManager.reloadBaseStylesheets","func_start_line":224,"func_end_line":226,"args":[{"type":"string"},null,{"type":"boolean"}],"code":"  reloadBaseStylesheets () {\r\n    this.requireStylesheet('../static/atom', -2, true)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.requireStylesheet","start_line":167,"end_line":175,"comment":["\r\n  Section: Private\r\n  "," Resolve and apply the stylesheet specified by the path.",""," This supports both CSS and Less stylesheets.",""," * `stylesheetPath` A {String} path to the stylesheet that can be an absolute","   path or a relative path that will be resolved against the load path.",""," Returns a {Disposable} on which `.dispose()` can be called to remove the"," required stylesheet."],"params":["stylesheetPath","priority","skipDeprecatedSelectorsTransformation"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"loadStylesheets","line":744,"func_location":"Package.reloadStylesheets","func_start_line":742,"func_end_line":753,"args":[],"code":"  reloadStylesheets () {\r\n    try {\r\n      this.loadStylesheets()\r\n    } catch (error) {\r\n      this.handleError(`Failed to reload the ${this.name} package stylesheets`, error)\r\n    }\r\n\r\n    if (this.stylesheetDisposables) this.stylesheetDisposables.dispose()\r\n    this.stylesheetDisposables = new CompositeDisposable()\r\n    this.stylesheetsActivated = false\r\n    this.activateStylesheets()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.loadStylesheets","start_line":486,"end_line":490,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"handleError","line":746,"func_location":"Package.reloadStylesheets","func_start_line":742,"func_end_line":753,"args":[null,"error"],"code":"  reloadStylesheets () {\r\n    try {\r\n      this.loadStylesheets()\r\n    } catch (error) {\r\n      this.handleError(`Failed to reload the ${this.name} package stylesheets`, error)\r\n    }\r\n\r\n    if (this.stylesheetDisposables) this.stylesheetDisposables.dispose()\r\n    this.stylesheetDisposables = new CompositeDisposable()\r\n    this.stylesheetsActivated = false\r\n    this.activateStylesheets()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.handleError","start_line":1085,"end_line":1105,"comment":[],"params":["message","error"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"activateStylesheets","line":752,"func_location":"Package.reloadStylesheets","func_start_line":742,"func_end_line":753,"args":[],"code":"  reloadStylesheets () {\r\n    try {\r\n      this.loadStylesheets()\r\n    } catch (error) {\r\n      this.handleError(`Failed to reload the ${this.name} package stylesheets`, error)\r\n    }\r\n\r\n    if (this.stylesheetDisposables) this.stylesheetDisposables.dispose()\r\n    this.stylesheetDisposables = new CompositeDisposable()\r\n    this.stylesheetsActivated = false\r\n    this.activateStylesheets()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.activateStylesheets","start_line":265,"end_line":295,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"getActiveThemes","line":372,"func_location":"ThemeManager.removeActiveThemeClasses","func_start_line":370,"func_end_line":375,"args":[],"code":"  removeActiveThemeClasses () {\r\n    const workspaceElement = this.viewRegistry.getView(this.workspace)\r\n    for (const pack of this.getActiveThemes()) {\r\n      workspaceElement.classList.remove(`theme-${pack.name}`)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.getActiveThemes","start_line":92,"end_line":94,"comment":[" Public: Returns an {Array} of all the active themes."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"get","line":888,"func_location":"Config.removeAtKeyPath","func_start_line":887,"func_end_line":893,"args":["keyPath"],"code":"  removeAtKeyPath (keyPath, value) {\r\n    const left = this.get(keyPath)\r\n    const arrayValue = (left == null ? [] : left)\r\n    const result = _.remove(arrayValue, value)\r\n    this.set(keyPath, arrayValue)\r\n    return result\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.get","start_line":585,"end_line":602,"comment":["\r\n  Section: Managing Settings\r\n  "," Essential: Retrieves the setting for the given key.",""," ### Examples",""," You might want to know what themes are enabled, so check `core.themes`",""," ```coffee"," atom.config.get('core.themes')"," ```",""," With scope descriptors you can get settings within a specific editor"," scope. For example, you might want to know `editor.tabLength` for ruby"," files.",""," ```coffee"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," ```",""," This setting in ruby files might be different than the global tabLength setting",""," ```coffee"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," ```",""," You can get the language scope descriptor via"," {TextEditor::getRootScopeDescriptor}. This will get the setting specifically"," for the editor's language.",""," ```coffee"," atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2"," ```",""," Additionally, you can get the setting at the specific cursor position.",""," ```coffee"," scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()"," atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2"," ```",""," * `keyPath` The {String} name of the key to retrieve."," * `options` (optional) {Object}","   * `sources` (optional) {Array} of {String} source names. If provided, only","     values that were associated with these sources during {::set} will be used.","   * `excludeSources` (optional) {Array} of {String} source names. If provided,","     values that  were associated with these sources during {::set} will not","     be used.","   * `scope` (optional) {ScopeDescriptor} describing a path from","     the root of the syntax tree to a token. Get one by calling","     {editor.getLastCursor().getScopeDescriptor()}","     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)","     for more information.",""," Returns the value from Atom's default settings, the user's configuration"," file in the type specified by the configuration schema."],"params":["args"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"set","line":891,"func_location":"Config.removeAtKeyPath","func_start_line":887,"func_end_line":893,"args":["keyPath","arrayValue"],"code":"  removeAtKeyPath (keyPath, value) {\r\n    const left = this.get(keyPath)\r\n    const arrayValue = (left == null ? [] : left)\r\n    const result = _.remove(arrayValue, value)\r\n    this.set(keyPath, arrayValue)\r\n    return result\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.set","start_line":687,"end_line":722,"comment":[" Essential: Sets the value for a configuration setting.",""," This value is stored in Atom's internal configuration file.",""," ### Examples",""," You might want to change the themes programmatically:",""," ```coffee"," atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])"," ```",""," You can also set scoped settings. For example, you might want change the"," `editor.tabLength` only for ruby files.",""," ```coffee"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4"," atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",""," # Set ruby to 2"," atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true",""," # Notice it's only set to 2 in the case of ruby"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," atom.config.get('editor.tabLength', scope: ['source.js']) # => 4"," ```",""," * `keyPath` The {String} name of the key."," * `value` The value of the setting. Passing `undefined` will revert the","   setting to the default value."," * `options` (optional) {Object}","   * `scopeSelector` (optional) {String}. eg. '.source.ruby'","     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)","     for more information.","   * `source` (optional) {String} The name of a file with which the setting","     is associated. Defaults to the user's config file.",""," Returns a {Boolean}"," * `true` if the value was set."," * `false` if the value was not able to be coerced to the type specified in the setting's schema."],"params":["args"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"removeBufferAtIndex","line":741,"func_location":"Project.removeBuffer","func_start_line":739,"func_end_line":742,"args":["index"],"comment":[" Removes a {TextBuffer} association from the project.",""," Returns the removed {TextBuffer}."],"code":"  removeBuffer (buffer) {\r\n    const index = this.buffers.indexOf(buffer)\r\n    if (index !== -1) { return this.removeBufferAtIndex(index) }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.removeBufferAtIndex","start_line":744,"end_line":747,"comment":[],"params":["index","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js","name":"unsubscribeFromChild","line":141,"func_location":"PaneAxis.removeChild","func_start_line":137,"func_end_line":149,"args":["child"],"code":"  removeChild (child, replacing = false) {\r\n    const index = this.children.indexOf(child)\r\n    if (index === -1) { throw new Error('Removing non-existent child') }\r\n\r\n    this.unsubscribeFromChild(child)\r\n\r\n    this.children.splice(index, 1)\r\n    this.adjustFlexScale()\r\n    this.emitter.emit('did-remove-child', {child, index})\r\n    if (!replacing && this.children.length < 2) {\r\n      this.reparentLastChild()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js","name":"PaneAxis.unsubscribeFromChild","start_line":186,"end_line":190,"comment":[],"params":["child"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js","name":"adjustFlexScale","line":144,"func_location":"PaneAxis.removeChild","func_start_line":137,"func_end_line":149,"args":[],"code":"  removeChild (child, replacing = false) {\r\n    const index = this.children.indexOf(child)\r\n    if (index === -1) { throw new Error('Removing non-existent child') }\r\n\r\n    this.unsubscribeFromChild(child)\r\n\r\n    this.children.splice(index, 1)\r\n    this.adjustFlexScale()\r\n    this.emitter.emit('did-remove-child', {child, index})\r\n    if (!replacing && this.children.length < 2) {\r\n      this.reparentLastChild()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js","name":"PaneAxis.adjustFlexScale","start_line":125,"end_line":135,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js","name":"reparentLastChild","line":147,"func_location":"PaneAxis.removeChild","func_start_line":137,"func_end_line":149,"args":[],"code":"  removeChild (child, replacing = false) {\r\n    const index = this.children.indexOf(child)\r\n    if (index === -1) { throw new Error('Removing non-existent child') }\r\n\r\n    this.unsubscribeFromChild(child)\r\n\r\n    this.children.splice(index, 1)\r\n    this.adjustFlexScale()\r\n    this.emitter.emit('did-remove-child', {child, index})\r\n    if (!replacing && this.children.length < 2) {\r\n      this.reparentLastChild()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js","name":"PaneAxis.reparentLastChild","start_line":173,"end_line":178,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/gutter-container.js","name":"scheduleComponentUpdate","line":89,"func_location":"GutterContainer.removeGutter","func_start_line":85,"func_end_line":96,"args":[],"comment":["\r\n  Section: Private Methods\r\n  "," Processes the destruction of the gutter. Throws an error if this gutter is"," not within this gutterContainer."],"code":"  removeGutter (gutter) {\r\n    const index = this.gutters.indexOf(gutter)\r\n    if (index > -1) {\r\n      this.gutters.splice(index, 1)\r\n      this.scheduleComponentUpdate()\r\n      this.emitter.emit('did-remove-gutter', gutter.name)\r\n    } else {\r\n      throw new Error('The given gutter cannot be removed because it is not ' +\r\n          'within this GutterContainer.'\r\n      )\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/gutter-container.js","name":"GutterContainer.scheduleComponentUpdate","start_line":11,"end_line":13,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getPendingItem","line":687,"func_location":"Pane.removeItem","func_start_line":684,"func_end_line":705,"args":[],"code":"  removeItem (item, moved) {\r\n    const index = this.items.indexOf(item)\r\n    if (index === -1) return\r\n    if (this.getPendingItem() === item) this.pendingItem = null\r\n    this.removeItemFromStack(item)\r\n    this.emitter.emit('will-remove-item', {item, index, destroyed: !moved, moved})\r\n    this.unsubscribeFromItem(item)\r\n\r\n    if (item === this.activeItem) {\r\n      if (this.items.length === 1) {\r\n        this.setActiveItem(undefined)\r\n      } else if (index === 0) {\r\n        this.activateNextItem()\r\n      } else {\r\n        this.activatePreviousItem()\r\n      }\r\n    }\r\n    this.items.splice(index, 1)\r\n    this.emitter.emit('did-remove-item', {item, index, destroyed: !moved, moved})\r\n    if (!moved && this.container) this.container.didDestroyPaneItem({item, index, pane: this})\r\n    if (this.items.length === 0 && this.config.get('core.destroyEmptyPanes')) this.destroy()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getPendingItem","start_line":654,"end_line":656,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"removeItemFromStack","line":688,"func_location":"Pane.removeItem","func_start_line":684,"func_end_line":705,"args":["item"],"code":"  removeItem (item, moved) {\r\n    const index = this.items.indexOf(item)\r\n    if (index === -1) return\r\n    if (this.getPendingItem() === item) this.pendingItem = null\r\n    this.removeItemFromStack(item)\r\n    this.emitter.emit('will-remove-item', {item, index, destroyed: !moved, moved})\r\n    this.unsubscribeFromItem(item)\r\n\r\n    if (item === this.activeItem) {\r\n      if (this.items.length === 1) {\r\n        this.setActiveItem(undefined)\r\n      } else if (index === 0) {\r\n        this.activateNextItem()\r\n      } else {\r\n        this.activatePreviousItem()\r\n      }\r\n    }\r\n    this.items.splice(index, 1)\r\n    this.emitter.emit('did-remove-item', {item, index, destroyed: !moved, moved})\r\n    if (!moved && this.container) this.container.didDestroyPaneItem({item, index, pane: this})\r\n    if (this.items.length === 0 && this.config.get('core.destroyEmptyPanes')) this.destroy()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.removeItemFromStack","start_line":711,"end_line":714,"comment":[" Remove the given item from the itemStack.",""," * `item` The item to remove."," * `index` {Number} indicating the index to which to remove the item from the itemStack."],"params":["item"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"unsubscribeFromItem","line":690,"func_location":"Pane.removeItem","func_start_line":684,"func_end_line":705,"args":["item"],"code":"  removeItem (item, moved) {\r\n    const index = this.items.indexOf(item)\r\n    if (index === -1) return\r\n    if (this.getPendingItem() === item) this.pendingItem = null\r\n    this.removeItemFromStack(item)\r\n    this.emitter.emit('will-remove-item', {item, index, destroyed: !moved, moved})\r\n    this.unsubscribeFromItem(item)\r\n\r\n    if (item === this.activeItem) {\r\n      if (this.items.length === 1) {\r\n        this.setActiveItem(undefined)\r\n      } else if (index === 0) {\r\n        this.activateNextItem()\r\n      } else {\r\n        this.activatePreviousItem()\r\n      }\r\n    }\r\n    this.items.splice(index, 1)\r\n    this.emitter.emit('did-remove-item', {item, index, destroyed: !moved, moved})\r\n    if (!moved && this.container) this.container.didDestroyPaneItem({item, index, pane: this})\r\n    if (this.items.length === 0 && this.config.get('core.destroyEmptyPanes')) this.destroy()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.unsubscribeFromItem","start_line":410,"end_line":416,"comment":[],"params":["item"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"setActiveItem","line":694,"func_location":"Pane.removeItem","func_start_line":684,"func_end_line":705,"args":["undefined"],"code":"  removeItem (item, moved) {\r\n    const index = this.items.indexOf(item)\r\n    if (index === -1) return\r\n    if (this.getPendingItem() === item) this.pendingItem = null\r\n    this.removeItemFromStack(item)\r\n    this.emitter.emit('will-remove-item', {item, index, destroyed: !moved, moved})\r\n    this.unsubscribeFromItem(item)\r\n\r\n    if (item === this.activeItem) {\r\n      if (this.items.length === 1) {\r\n        this.setActiveItem(undefined)\r\n      } else if (index === 0) {\r\n        this.activateNextItem()\r\n      } else {\r\n        this.activatePreviousItem()\r\n      }\r\n    }\r\n    this.items.splice(index, 1)\r\n    this.emitter.emit('did-remove-item', {item, index, destroyed: !moved, moved})\r\n    if (!moved && this.container) this.container.didDestroyPaneItem({item, index, pane: this})\r\n    if (this.items.length === 0 && this.config.get('core.destroyEmptyPanes')) this.destroy()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.setActiveItem","start_line":434,"end_line":443,"comment":[],"params":["activeItem","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"activateNextItem","line":696,"func_location":"Pane.removeItem","func_start_line":684,"func_end_line":705,"args":[],"code":"  removeItem (item, moved) {\r\n    const index = this.items.indexOf(item)\r\n    if (index === -1) return\r\n    if (this.getPendingItem() === item) this.pendingItem = null\r\n    this.removeItemFromStack(item)\r\n    this.emitter.emit('will-remove-item', {item, index, destroyed: !moved, moved})\r\n    this.unsubscribeFromItem(item)\r\n\r\n    if (item === this.activeItem) {\r\n      if (this.items.length === 1) {\r\n        this.setActiveItem(undefined)\r\n      } else if (index === 0) {\r\n        this.activateNextItem()\r\n      } else {\r\n        this.activatePreviousItem()\r\n      }\r\n    }\r\n    this.items.splice(index, 1)\r\n    this.emitter.emit('did-remove-item', {item, index, destroyed: !moved, moved})\r\n    if (!moved && this.container) this.container.didDestroyPaneItem({item, index, pane: this})\r\n    if (this.items.length === 0 && this.config.get('core.destroyEmptyPanes')) this.destroy()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.activateNextItem","start_line":513,"end_line":520,"comment":[" Public: Makes the next item active."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"activatePreviousItem","line":698,"func_location":"Pane.removeItem","func_start_line":684,"func_end_line":705,"args":[],"code":"  removeItem (item, moved) {\r\n    const index = this.items.indexOf(item)\r\n    if (index === -1) return\r\n    if (this.getPendingItem() === item) this.pendingItem = null\r\n    this.removeItemFromStack(item)\r\n    this.emitter.emit('will-remove-item', {item, index, destroyed: !moved, moved})\r\n    this.unsubscribeFromItem(item)\r\n\r\n    if (item === this.activeItem) {\r\n      if (this.items.length === 1) {\r\n        this.setActiveItem(undefined)\r\n      } else if (index === 0) {\r\n        this.activateNextItem()\r\n      } else {\r\n        this.activatePreviousItem()\r\n      }\r\n    }\r\n    this.items.splice(index, 1)\r\n    this.emitter.emit('did-remove-item', {item, index, destroyed: !moved, moved})\r\n    if (!moved && this.container) this.container.didDestroyPaneItem({item, index, pane: this})\r\n    if (this.items.length === 0 && this.config.get('core.destroyEmptyPanes')) this.destroy()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.activatePreviousItem","start_line":523,"end_line":530,"comment":[" Public: Makes the previous item active."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"destroy","line":704,"func_location":"Pane.removeItem","func_start_line":684,"func_end_line":705,"args":[{"type":"string"}],"code":"  removeItem (item, moved) {\r\n    const index = this.items.indexOf(item)\r\n    if (index === -1) return\r\n    if (this.getPendingItem() === item) this.pendingItem = null\r\n    this.removeItemFromStack(item)\r\n    this.emitter.emit('will-remove-item', {item, index, destroyed: !moved, moved})\r\n    this.unsubscribeFromItem(item)\r\n\r\n    if (item === this.activeItem) {\r\n      if (this.items.length === 1) {\r\n        this.setActiveItem(undefined)\r\n      } else if (index === 0) {\r\n        this.activateNextItem()\r\n      } else {\r\n        this.activatePreviousItem()\r\n      }\r\n    }\r\n    this.items.splice(index, 1)\r\n    this.emitter.emit('did-remove-item', {item, index, destroyed: !moved, moved})\r\n    if (!moved && this.container) this.container.didDestroyPaneItem({item, index, pane: this})\r\n    if (this.items.length === 0 && this.config.get('core.destroyEmptyPanes')) this.destroy()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.destroy","start_line":1022,"end_line":1039,"comment":[" Public: Close the pane and destroy all its items.",""," If this is the last pane, all the items will be destroyed but the pane"," itself will not be destroyed."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"getPaths","line":479,"func_location":"Project.removePath","func_start_line":477,"func_end_line":507,"args":["projectPath"],"comment":[" Public: remove a path from the project's list of root paths.",""," * `projectPath` {String} The path to remove."],"code":"  removePath (projectPath) {\r\n    // The projectPath may be a URI, in which case it should not be normalized.\r\n    if (!this.getPaths().includes(projectPath)) {\r\n      projectPath = this.defaultDirectoryProvider.normalizePath(projectPath)\r\n    }\r\n\r\n    let indexToRemove = null\r\n    for (let i = 0; i < this.rootDirectories.length; i++) {\r\n      const directory = this.rootDirectories[i]\r\n      if (directory.getPath() === projectPath) {\r\n        indexToRemove = i\r\n        break\r\n      }\r\n    }\r\n\r\n    if (indexToRemove != null) {\r\n      this.rootDirectories.splice(indexToRemove, 1)\r\n      const [removedRepository] = this.repositories.splice(indexToRemove, 1)\r\n      if (!this.repositories.includes(removedRepository)) {\r\n        if (removedRepository) removedRepository.destroy()\r\n      }\r\n      if (this.watcherPromisesByPath[projectPath] != null) {\r\n        this.watcherPromisesByPath[projectPath].then(w => w.dispose())\r\n      }\r\n      delete this.watcherPromisesByPath[projectPath]\r\n      this.emitter.emit('did-change-paths', this.getPaths())\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.getPaths","start_line":327,"end_line":329,"comment":["\r\n  Section: Managing Paths\r\n  "," Public: Get an {Array} of {String}s containing the paths of the project's"," directories."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"getPaths","line":502,"func_location":"Project.removePath","func_start_line":477,"func_end_line":507,"args":[{"type":"string"},null],"comment":[" Public: remove a path from the project's list of root paths.",""," * `projectPath` {String} The path to remove."],"code":"  removePath (projectPath) {\r\n    // The projectPath may be a URI, in which case it should not be normalized.\r\n    if (!this.getPaths().includes(projectPath)) {\r\n      projectPath = this.defaultDirectoryProvider.normalizePath(projectPath)\r\n    }\r\n\r\n    let indexToRemove = null\r\n    for (let i = 0; i < this.rootDirectories.length; i++) {\r\n      const directory = this.rootDirectories[i]\r\n      if (directory.getPath() === projectPath) {\r\n        indexToRemove = i\r\n        break\r\n      }\r\n    }\r\n\r\n    if (indexToRemove != null) {\r\n      this.rootDirectories.splice(indexToRemove, 1)\r\n      const [removedRepository] = this.repositories.splice(indexToRemove, 1)\r\n      if (!this.repositories.includes(removedRepository)) {\r\n        if (removedRepository) removedRepository.destroy()\r\n      }\r\n      if (this.watcherPromisesByPath[projectPath] != null) {\r\n        this.watcherPromisesByPath[projectPath].then(w => w.dispose())\r\n      }\r\n      delete this.watcherPromisesByPath[projectPath]\r\n      this.emitter.emit('did-change-paths', this.getPaths())\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.getPaths","start_line":327,"end_line":329,"comment":["\r\n  Section: Managing Paths\r\n  "," Public: Get an {Array} of {String}s containing the paths of the project's"," directories."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"getProject","line":73,"func_location":"HistoryManager.removeProject","func_start_line":70,"func_end_line":81,"args":["paths"],"code":"  async removeProject (paths) {\r\n    if (paths.length === 0) return\r\n\r\n    let project = this.getProject(paths)\r\n    if (!project) return\r\n\r\n    let index = this.projects.indexOf(project)\r\n    this.projects.splice(index, 1)\r\n\r\n    await this.saveState()\r\n    this.didChangeProjects()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"HistoryManager.getProject","start_line":83,"end_line":91,"comment":[],"params":["paths"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"saveState","line":79,"func_location":"HistoryManager.removeProject","func_start_line":70,"func_end_line":81,"args":[],"code":"  async removeProject (paths) {\r\n    if (paths.length === 0) return\r\n\r\n    let project = this.getProject(paths)\r\n    if (!project) return\r\n\r\n    let index = this.projects.indexOf(project)\r\n    this.projects.splice(index, 1)\r\n\r\n    await this.saveState()\r\n    this.didChangeProjects()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"HistoryManager.saveState","start_line":103,"end_line":106,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"didChangeProjects","line":80,"func_location":"HistoryManager.removeProject","func_start_line":70,"func_end_line":81,"args":[],"code":"  async removeProject (paths) {\r\n    if (paths.length === 0) return\r\n\r\n    let project = this.getProject(paths)\r\n    if (!project) return\r\n\r\n    let index = this.projects.indexOf(project)\r\n    this.projects.splice(index, 1)\r\n\r\n    await this.saveState()\r\n    this.didChangeProjects()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js","name":"HistoryManager.didChangeProjects","start_line":51,"end_line":53,"comment":[],"params":["args"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"getAllWindows","line":286,"func_location":"AtomApplication.removeWindow","func_start_line":284,"func_end_line":296,"args":[],"comment":[" Public: Removes the {AtomWindow} from the global window list."],"code":"  removeWindow (window) {\r\n    this.windowStack.removeWindow(window)\r\n    if (this.getAllWindows().length === 0) {\r\n      if (this.applicationMenu != null) {\r\n        this.applicationMenu.enableWindowSpecificItems(false)\r\n      }\r\n      if (['win32', 'linux'].includes(process.platform)) {\r\n        app.quit()\r\n        return\r\n      }\r\n    }\r\n    if (!window.isSpec) this.saveCurrentWindowOptions(true)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.getAllWindows","start_line":321,"end_line":323,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"saveCurrentWindowOptions","line":295,"func_location":"AtomApplication.removeWindow","func_start_line":284,"func_end_line":296,"args":[{"type":"boolean"}],"comment":[" Public: Removes the {AtomWindow} from the global window list."],"code":"  removeWindow (window) {\r\n    this.windowStack.removeWindow(window)\r\n    if (this.getAllWindows().length === 0) {\r\n      if (this.applicationMenu != null) {\r\n        this.applicationMenu.enableWindowSpecificItems(false)\r\n      }\r\n      if (['win32', 'linux'].includes(process.platform)) {\r\n        app.quit()\r\n        return\r\n      }\r\n    }\r\n    if (!window.isSpec) this.saveCurrentWindowOptions(true)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.saveCurrentWindowOptions","start_line":968,"end_line":981,"comment":[],"params":["allowEmpty"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getContentHeight","line":464,"func_location":"TextEditorComponent.render","func_start_line":451,"func_end_line":521,"args":[],"code":"  render () {\r\n    const {model} = this.props\r\n    const style = {}\r\n\r\n    if (!model.getAutoHeight() && !model.getAutoWidth()) {\r\n      style.contain = 'size'\r\n    }\r\n\r\n    let clientContainerHeight = '100%'\r\n    let clientContainerWidth = '100%'\r\n    if (this.hasInitialMeasurements) {\r\n      if (model.getAutoHeight()) {\r\n        clientContainerHeight =\r\n          this.getContentHeight() +\r\n          this.getHorizontalScrollbarHeight() +\r\n          'px'\r\n      }\r\n      if (model.getAutoWidth()) {\r\n        style.width = 'min-content'\r\n        clientContainerWidth =\r\n          this.getGutterContainerWidth() +\r\n          this.getContentWidth() +\r\n          this.getVerticalScrollbarWidth() +\r\n          'px'\r\n      } else {\r\n        style.width = this.element.style.width\r\n      }\r\n    }\r\n\r\n    let attributes = {}\r\n    if (model.isMini()) {\r\n      attributes.mini = ''\r\n    }\r\n\r\n    if (model.isReadOnly()) {\r\n      attributes.readonly = ''\r\n    }\r\n\r\n    const dataset = {encoding: model.getEncoding()}\r\n    const grammar = model.getGrammar()\r\n    if (grammar && grammar.scopeName) {\r\n      dataset.grammar = grammar.scopeName.replace(/\\./g, ' ')\r\n    }\r\n\r\n    return $('atom-text-editor',\r\n      {\r\n        // See this.updateClassList() for construction of the class name\r\n        style,\r\n        attributes,\r\n        dataset,\r\n        tabIndex: -1,\r\n        on: {mousewheel: this.didMouseWheel}\r\n      },\r\n      $.div(\r\n        {\r\n          ref: 'clientContainer',\r\n          style: {\r\n            position: 'relative',\r\n            contain: 'strict',\r\n            overflow: 'hidden',\r\n            backgroundColor: 'inherit',\r\n            height: clientContainerHeight,\r\n            width: clientContainerWidth\r\n          }\r\n        },\r\n        this.renderGutterContainer(),\r\n        this.renderScrollContainer()\r\n      ),\r\n      this.renderOverlayDecorations()\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getContentHeight","start_line":2684,"end_line":2686,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getHorizontalScrollbarHeight","line":465,"func_location":"TextEditorComponent.render","func_start_line":451,"func_end_line":521,"args":[],"code":"  render () {\r\n    const {model} = this.props\r\n    const style = {}\r\n\r\n    if (!model.getAutoHeight() && !model.getAutoWidth()) {\r\n      style.contain = 'size'\r\n    }\r\n\r\n    let clientContainerHeight = '100%'\r\n    let clientContainerWidth = '100%'\r\n    if (this.hasInitialMeasurements) {\r\n      if (model.getAutoHeight()) {\r\n        clientContainerHeight =\r\n          this.getContentHeight() +\r\n          this.getHorizontalScrollbarHeight() +\r\n          'px'\r\n      }\r\n      if (model.getAutoWidth()) {\r\n        style.width = 'min-content'\r\n        clientContainerWidth =\r\n          this.getGutterContainerWidth() +\r\n          this.getContentWidth() +\r\n          this.getVerticalScrollbarWidth() +\r\n          'px'\r\n      } else {\r\n        style.width = this.element.style.width\r\n      }\r\n    }\r\n\r\n    let attributes = {}\r\n    if (model.isMini()) {\r\n      attributes.mini = ''\r\n    }\r\n\r\n    if (model.isReadOnly()) {\r\n      attributes.readonly = ''\r\n    }\r\n\r\n    const dataset = {encoding: model.getEncoding()}\r\n    const grammar = model.getGrammar()\r\n    if (grammar && grammar.scopeName) {\r\n      dataset.grammar = grammar.scopeName.replace(/\\./g, ' ')\r\n    }\r\n\r\n    return $('atom-text-editor',\r\n      {\r\n        // See this.updateClassList() for construction of the class name\r\n        style,\r\n        attributes,\r\n        dataset,\r\n        tabIndex: -1,\r\n        on: {mousewheel: this.didMouseWheel}\r\n      },\r\n      $.div(\r\n        {\r\n          ref: 'clientContainer',\r\n          style: {\r\n            position: 'relative',\r\n            contain: 'strict',\r\n            overflow: 'hidden',\r\n            backgroundColor: 'inherit',\r\n            height: clientContainerHeight,\r\n            width: clientContainerWidth\r\n          }\r\n        },\r\n        this.renderGutterContainer(),\r\n        this.renderScrollContainer()\r\n      ),\r\n      this.renderOverlayDecorations()\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getHorizontalScrollbarHeight","start_line":2708,"end_line":2710,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getGutterContainerWidth","line":471,"func_location":"TextEditorComponent.render","func_start_line":451,"func_end_line":521,"args":[],"code":"  render () {\r\n    const {model} = this.props\r\n    const style = {}\r\n\r\n    if (!model.getAutoHeight() && !model.getAutoWidth()) {\r\n      style.contain = 'size'\r\n    }\r\n\r\n    let clientContainerHeight = '100%'\r\n    let clientContainerWidth = '100%'\r\n    if (this.hasInitialMeasurements) {\r\n      if (model.getAutoHeight()) {\r\n        clientContainerHeight =\r\n          this.getContentHeight() +\r\n          this.getHorizontalScrollbarHeight() +\r\n          'px'\r\n      }\r\n      if (model.getAutoWidth()) {\r\n        style.width = 'min-content'\r\n        clientContainerWidth =\r\n          this.getGutterContainerWidth() +\r\n          this.getContentWidth() +\r\n          this.getVerticalScrollbarWidth() +\r\n          'px'\r\n      } else {\r\n        style.width = this.element.style.width\r\n      }\r\n    }\r\n\r\n    let attributes = {}\r\n    if (model.isMini()) {\r\n      attributes.mini = ''\r\n    }\r\n\r\n    if (model.isReadOnly()) {\r\n      attributes.readonly = ''\r\n    }\r\n\r\n    const dataset = {encoding: model.getEncoding()}\r\n    const grammar = model.getGrammar()\r\n    if (grammar && grammar.scopeName) {\r\n      dataset.grammar = grammar.scopeName.replace(/\\./g, ' ')\r\n    }\r\n\r\n    return $('atom-text-editor',\r\n      {\r\n        // See this.updateClassList() for construction of the class name\r\n        style,\r\n        attributes,\r\n        dataset,\r\n        tabIndex: -1,\r\n        on: {mousewheel: this.didMouseWheel}\r\n      },\r\n      $.div(\r\n        {\r\n          ref: 'clientContainer',\r\n          style: {\r\n            position: 'relative',\r\n            contain: 'strict',\r\n            overflow: 'hidden',\r\n            backgroundColor: 'inherit',\r\n            height: clientContainerHeight,\r\n            width: clientContainerWidth\r\n          }\r\n        },\r\n        this.renderGutterContainer(),\r\n        this.renderScrollContainer()\r\n      ),\r\n      this.renderOverlayDecorations()\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getGutterContainerWidth","start_line":2696,"end_line":2698,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getContentWidth","line":472,"func_location":"TextEditorComponent.render","func_start_line":451,"func_end_line":521,"args":[],"code":"  render () {\r\n    const {model} = this.props\r\n    const style = {}\r\n\r\n    if (!model.getAutoHeight() && !model.getAutoWidth()) {\r\n      style.contain = 'size'\r\n    }\r\n\r\n    let clientContainerHeight = '100%'\r\n    let clientContainerWidth = '100%'\r\n    if (this.hasInitialMeasurements) {\r\n      if (model.getAutoHeight()) {\r\n        clientContainerHeight =\r\n          this.getContentHeight() +\r\n          this.getHorizontalScrollbarHeight() +\r\n          'px'\r\n      }\r\n      if (model.getAutoWidth()) {\r\n        style.width = 'min-content'\r\n        clientContainerWidth =\r\n          this.getGutterContainerWidth() +\r\n          this.getContentWidth() +\r\n          this.getVerticalScrollbarWidth() +\r\n          'px'\r\n      } else {\r\n        style.width = this.element.style.width\r\n      }\r\n    }\r\n\r\n    let attributes = {}\r\n    if (model.isMini()) {\r\n      attributes.mini = ''\r\n    }\r\n\r\n    if (model.isReadOnly()) {\r\n      attributes.readonly = ''\r\n    }\r\n\r\n    const dataset = {encoding: model.getEncoding()}\r\n    const grammar = model.getGrammar()\r\n    if (grammar && grammar.scopeName) {\r\n      dataset.grammar = grammar.scopeName.replace(/\\./g, ' ')\r\n    }\r\n\r\n    return $('atom-text-editor',\r\n      {\r\n        // See this.updateClassList() for construction of the class name\r\n        style,\r\n        attributes,\r\n        dataset,\r\n        tabIndex: -1,\r\n        on: {mousewheel: this.didMouseWheel}\r\n      },\r\n      $.div(\r\n        {\r\n          ref: 'clientContainer',\r\n          style: {\r\n            position: 'relative',\r\n            contain: 'strict',\r\n            overflow: 'hidden',\r\n            backgroundColor: 'inherit',\r\n            height: clientContainerHeight,\r\n            width: clientContainerWidth\r\n          }\r\n        },\r\n        this.renderGutterContainer(),\r\n        this.renderScrollContainer()\r\n      ),\r\n      this.renderOverlayDecorations()\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getContentWidth","start_line":2688,"end_line":2690,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getVerticalScrollbarWidth","line":473,"func_location":"TextEditorComponent.render","func_start_line":451,"func_end_line":521,"args":[],"code":"  render () {\r\n    const {model} = this.props\r\n    const style = {}\r\n\r\n    if (!model.getAutoHeight() && !model.getAutoWidth()) {\r\n      style.contain = 'size'\r\n    }\r\n\r\n    let clientContainerHeight = '100%'\r\n    let clientContainerWidth = '100%'\r\n    if (this.hasInitialMeasurements) {\r\n      if (model.getAutoHeight()) {\r\n        clientContainerHeight =\r\n          this.getContentHeight() +\r\n          this.getHorizontalScrollbarHeight() +\r\n          'px'\r\n      }\r\n      if (model.getAutoWidth()) {\r\n        style.width = 'min-content'\r\n        clientContainerWidth =\r\n          this.getGutterContainerWidth() +\r\n          this.getContentWidth() +\r\n          this.getVerticalScrollbarWidth() +\r\n          'px'\r\n      } else {\r\n        style.width = this.element.style.width\r\n      }\r\n    }\r\n\r\n    let attributes = {}\r\n    if (model.isMini()) {\r\n      attributes.mini = ''\r\n    }\r\n\r\n    if (model.isReadOnly()) {\r\n      attributes.readonly = ''\r\n    }\r\n\r\n    const dataset = {encoding: model.getEncoding()}\r\n    const grammar = model.getGrammar()\r\n    if (grammar && grammar.scopeName) {\r\n      dataset.grammar = grammar.scopeName.replace(/\\./g, ' ')\r\n    }\r\n\r\n    return $('atom-text-editor',\r\n      {\r\n        // See this.updateClassList() for construction of the class name\r\n        style,\r\n        attributes,\r\n        dataset,\r\n        tabIndex: -1,\r\n        on: {mousewheel: this.didMouseWheel}\r\n      },\r\n      $.div(\r\n        {\r\n          ref: 'clientContainer',\r\n          style: {\r\n            position: 'relative',\r\n            contain: 'strict',\r\n            overflow: 'hidden',\r\n            backgroundColor: 'inherit',\r\n            height: clientContainerHeight,\r\n            width: clientContainerWidth\r\n          }\r\n        },\r\n        this.renderGutterContainer(),\r\n        this.renderScrollContainer()\r\n      ),\r\n      this.renderOverlayDecorations()\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getVerticalScrollbarWidth","start_line":2704,"end_line":2706,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"renderGutterContainer","line":516,"func_location":"TextEditorComponent.render","func_start_line":451,"func_end_line":521,"args":[],"code":"  render () {\r\n    const {model} = this.props\r\n    const style = {}\r\n\r\n    if (!model.getAutoHeight() && !model.getAutoWidth()) {\r\n      style.contain = 'size'\r\n    }\r\n\r\n    let clientContainerHeight = '100%'\r\n    let clientContainerWidth = '100%'\r\n    if (this.hasInitialMeasurements) {\r\n      if (model.getAutoHeight()) {\r\n        clientContainerHeight =\r\n          this.getContentHeight() +\r\n          this.getHorizontalScrollbarHeight() +\r\n          'px'\r\n      }\r\n      if (model.getAutoWidth()) {\r\n        style.width = 'min-content'\r\n        clientContainerWidth =\r\n          this.getGutterContainerWidth() +\r\n          this.getContentWidth() +\r\n          this.getVerticalScrollbarWidth() +\r\n          'px'\r\n      } else {\r\n        style.width = this.element.style.width\r\n      }\r\n    }\r\n\r\n    let attributes = {}\r\n    if (model.isMini()) {\r\n      attributes.mini = ''\r\n    }\r\n\r\n    if (model.isReadOnly()) {\r\n      attributes.readonly = ''\r\n    }\r\n\r\n    const dataset = {encoding: model.getEncoding()}\r\n    const grammar = model.getGrammar()\r\n    if (grammar && grammar.scopeName) {\r\n      dataset.grammar = grammar.scopeName.replace(/\\./g, ' ')\r\n    }\r\n\r\n    return $('atom-text-editor',\r\n      {\r\n        // See this.updateClassList() for construction of the class name\r\n        style,\r\n        attributes,\r\n        dataset,\r\n        tabIndex: -1,\r\n        on: {mousewheel: this.didMouseWheel}\r\n      },\r\n      $.div(\r\n        {\r\n          ref: 'clientContainer',\r\n          style: {\r\n            position: 'relative',\r\n            contain: 'strict',\r\n            overflow: 'hidden',\r\n            backgroundColor: 'inherit',\r\n            height: clientContainerHeight,\r\n            width: clientContainerWidth\r\n          }\r\n        },\r\n        this.renderGutterContainer(),\r\n        this.renderScrollContainer()\r\n      ),\r\n      this.renderOverlayDecorations()\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.renderGutterContainer","start_line":523,"end_line":548,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"renderScrollContainer","line":517,"func_location":"TextEditorComponent.render","func_start_line":451,"func_end_line":521,"args":[],"code":"  render () {\r\n    const {model} = this.props\r\n    const style = {}\r\n\r\n    if (!model.getAutoHeight() && !model.getAutoWidth()) {\r\n      style.contain = 'size'\r\n    }\r\n\r\n    let clientContainerHeight = '100%'\r\n    let clientContainerWidth = '100%'\r\n    if (this.hasInitialMeasurements) {\r\n      if (model.getAutoHeight()) {\r\n        clientContainerHeight =\r\n          this.getContentHeight() +\r\n          this.getHorizontalScrollbarHeight() +\r\n          'px'\r\n      }\r\n      if (model.getAutoWidth()) {\r\n        style.width = 'min-content'\r\n        clientContainerWidth =\r\n          this.getGutterContainerWidth() +\r\n          this.getContentWidth() +\r\n          this.getVerticalScrollbarWidth() +\r\n          'px'\r\n      } else {\r\n        style.width = this.element.style.width\r\n      }\r\n    }\r\n\r\n    let attributes = {}\r\n    if (model.isMini()) {\r\n      attributes.mini = ''\r\n    }\r\n\r\n    if (model.isReadOnly()) {\r\n      attributes.readonly = ''\r\n    }\r\n\r\n    const dataset = {encoding: model.getEncoding()}\r\n    const grammar = model.getGrammar()\r\n    if (grammar && grammar.scopeName) {\r\n      dataset.grammar = grammar.scopeName.replace(/\\./g, ' ')\r\n    }\r\n\r\n    return $('atom-text-editor',\r\n      {\r\n        // See this.updateClassList() for construction of the class name\r\n        style,\r\n        attributes,\r\n        dataset,\r\n        tabIndex: -1,\r\n        on: {mousewheel: this.didMouseWheel}\r\n      },\r\n      $.div(\r\n        {\r\n          ref: 'clientContainer',\r\n          style: {\r\n            position: 'relative',\r\n            contain: 'strict',\r\n            overflow: 'hidden',\r\n            backgroundColor: 'inherit',\r\n            height: clientContainerHeight,\r\n            width: clientContainerWidth\r\n          }\r\n        },\r\n        this.renderGutterContainer(),\r\n        this.renderScrollContainer()\r\n      ),\r\n      this.renderOverlayDecorations()\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.renderScrollContainer","start_line":550,"end_line":575,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"renderOverlayDecorations","line":519,"func_location":"TextEditorComponent.render","func_start_line":451,"func_end_line":521,"args":[],"code":"  render () {\r\n    const {model} = this.props\r\n    const style = {}\r\n\r\n    if (!model.getAutoHeight() && !model.getAutoWidth()) {\r\n      style.contain = 'size'\r\n    }\r\n\r\n    let clientContainerHeight = '100%'\r\n    let clientContainerWidth = '100%'\r\n    if (this.hasInitialMeasurements) {\r\n      if (model.getAutoHeight()) {\r\n        clientContainerHeight =\r\n          this.getContentHeight() +\r\n          this.getHorizontalScrollbarHeight() +\r\n          'px'\r\n      }\r\n      if (model.getAutoWidth()) {\r\n        style.width = 'min-content'\r\n        clientContainerWidth =\r\n          this.getGutterContainerWidth() +\r\n          this.getContentWidth() +\r\n          this.getVerticalScrollbarWidth() +\r\n          'px'\r\n      } else {\r\n        style.width = this.element.style.width\r\n      }\r\n    }\r\n\r\n    let attributes = {}\r\n    if (model.isMini()) {\r\n      attributes.mini = ''\r\n    }\r\n\r\n    if (model.isReadOnly()) {\r\n      attributes.readonly = ''\r\n    }\r\n\r\n    const dataset = {encoding: model.getEncoding()}\r\n    const grammar = model.getGrammar()\r\n    if (grammar && grammar.scopeName) {\r\n      dataset.grammar = grammar.scopeName.replace(/\\./g, ' ')\r\n    }\r\n\r\n    return $('atom-text-editor',\r\n      {\r\n        // See this.updateClassList() for construction of the class name\r\n        style,\r\n        attributes,\r\n        dataset,\r\n        tabIndex: -1,\r\n        on: {mousewheel: this.didMouseWheel}\r\n      },\r\n      $.div(\r\n        {\r\n          ref: 'clientContainer',\r\n          style: {\r\n            position: 'relative',\r\n            contain: 'strict',\r\n            overflow: 'hidden',\r\n            backgroundColor: 'inherit',\r\n            height: clientContainerHeight,\r\n            width: clientContainerWidth\r\n          }\r\n        },\r\n        this.renderGutterContainer(),\r\n        this.renderScrollContainer()\r\n      ),\r\n      this.renderOverlayDecorations()\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.renderOverlayDecorations","start_line":811,"end_line":825,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"ceilToPhysicalPixelBoundary","line":3295,"func_location":"LineNumberGutterComponent.render","func_start_line":3206,"func_end_line":3307,"args":["height"],"code":"  render () {\r\n    const {\r\n      rootComponent, showLineNumbers, height, width, startRow, endRow, rowsPerTile,\r\n      maxDigits, keys, bufferRows, screenRows, softWrappedFlags, foldableFlags, decorations,\r\n      className\r\n    } = this.props\r\n\r\n    let children = null\r\n\r\n    if (bufferRows) {\r\n      children = new Array(rootComponent.renderedTileStartRows.length)\r\n      for (let i = 0; i < rootComponent.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = rootComponent.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileChildren = new Array(tileEndRow - tileStartRow)\r\n        for (let row = tileStartRow; row < tileEndRow; row++) {\r\n          const indexInTile = row - tileStartRow\r\n          const j = row - startRow\r\n          const key = keys[j]\r\n          const softWrapped = softWrappedFlags[j]\r\n          const foldable = foldableFlags[j]\r\n          const bufferRow = bufferRows[j]\r\n          const screenRow = screenRows[j]\r\n\r\n          let className = 'line-number'\r\n          if (foldable) className = className + ' foldable'\r\n\r\n          const decorationsForRow = decorations[row - startRow]\r\n          if (decorationsForRow) className = className + ' ' + decorationsForRow\r\n\r\n          let number = null\r\n          if (showLineNumbers) {\r\n            if (this.props.labelFn == null) {\r\n              number = softWrapped ? '' : bufferRow + 1\r\n              number = NBSP_CHARACTER.repeat(maxDigits - number.length) + number\r\n            } else {\r\n              number = this.props.labelFn({bufferRow, screenRow, foldable, softWrapped, maxDigits})\r\n            }\r\n          }\r\n\r\n          // We need to adjust the line number position to account for block\r\n          // decorations preceding the current row and following the preceding\r\n          // row. Note that we ignore the latter when the line number starts at\r\n          // the beginning of the tile, because the tile will already be\r\n          // positioned to take into account block decorations added after the\r\n          // last row of the previous tile.\r\n          let marginTop = rootComponent.heightForBlockDecorationsBeforeRow(row)\r\n          if (indexInTile > 0) marginTop += rootComponent.heightForBlockDecorationsAfterRow(row - 1)\r\n\r\n          tileChildren[row - tileStartRow] = $(LineNumberComponent, {\r\n            key,\r\n            className,\r\n            width,\r\n            bufferRow,\r\n            screenRow,\r\n            number,\r\n            marginTop,\r\n            nodePool: this.nodePool\r\n          })\r\n        }\r\n\r\n        const tileTop = rootComponent.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n        const tileBottom = rootComponent.pixelPositionBeforeBlocksForRow(tileEndRow)\r\n        const tileHeight = tileBottom - tileTop\r\n        const tileWidth = width != null && width > 0 ? width + 'px' : ''\r\n\r\n        children[i] = $.div({\r\n          key: rootComponent.idsByTileStartRow.get(tileStartRow),\r\n          style: {\r\n            contain: 'layout style',\r\n            position: 'absolute',\r\n            top: 0,\r\n            height: tileHeight + 'px',\r\n            width: tileWidth,\r\n            transform: `translateY(${tileTop}px)`\r\n          }\r\n        }, ...tileChildren)\r\n      }\r\n    }\r\n\r\n    let rootClassName = 'gutter line-numbers'\r\n    if (className) {\r\n      rootClassName += ' ' + className\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        className: rootClassName,\r\n        attributes: {'gutter-name': this.props.name},\r\n        style: {position: 'relative', height: ceilToPhysicalPixelBoundary(height) + 'px'},\r\n        on: {\r\n          mousedown: this.didMouseDown,\r\n          mousemove: this.didMouseMove\r\n        }\r\n      },\r\n      $.div({key: 'placeholder', className: 'line-number dummy', style: {visibility: 'hidden'}},\r\n        showLineNumbers ? '0'.repeat(maxDigits) : null,\r\n        $.div({className: 'icon-right'})\r\n      ),\r\n      children\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"ceilToPhysicalPixelBoundary","start_line":4491,"end_line":4494,"comment":[],"params":["virtualPixelPosition"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"roundToPhysicalPixelBoundary","line":3098,"func_location":"GutterContainerComponent.render","func_start_line":3089,"func_end_line":3129,"args":["scrollTop"],"code":"  render () {\r\n    const {hasInitialMeasurements, scrollTop, scrollHeight, guttersToRender, decorationsToRender} = this.props\r\n\r\n    const innerStyle = {\r\n      willChange: 'transform',\r\n      display: 'flex'\r\n    }\r\n\r\n    if (hasInitialMeasurements) {\r\n      innerStyle.transform = `translateY(${-roundToPhysicalPixelBoundary(scrollTop)}px)`\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'gutterContainer',\r\n        key: 'gutterContainer',\r\n        className: 'gutter-container',\r\n        style: {\r\n          position: 'relative',\r\n          zIndex: 1,\r\n          backgroundColor: 'inherit'\r\n        }\r\n      },\r\n      $.div({style: innerStyle},\r\n        guttersToRender.map((gutter) => {\r\n          if (gutter.type === 'line-number') {\r\n            return this.renderLineNumberGutter(gutter)\r\n          } else {\r\n            return $(CustomGutterComponent, {\r\n              key: gutter,\r\n              element: gutter.getElement(),\r\n              name: gutter.name,\r\n              visible: gutter.isVisible(),\r\n              height: scrollHeight,\r\n              decorations: decorationsToRender.customGutter.get(gutter.name)\r\n            })\r\n          }\r\n        })\r\n      )\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"roundToPhysicalPixelBoundary","start_line":4486,"end_line":4489,"comment":[],"params":["virtualPixelPosition"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"renderDecorations","line":3484,"func_location":"CustomGutterComponent.render","func_start_line":3466,"func_end_line":3487,"args":[],"code":"  render () {\r\n    let className = 'gutter'\r\n    if (this.props.className) {\r\n      className += ' ' + this.props.className\r\n    }\r\n    return $.div(\r\n      {\r\n        className,\r\n        attributes: {'gutter-name': this.props.name},\r\n        style: {\r\n          display: this.props.visible ? '' : 'none'\r\n        }\r\n      },\r\n      $.div(\r\n        {\r\n          className: 'custom-decorations',\r\n          style: {height: this.props.height + 'px'}\r\n        },\r\n        this.renderDecorations()\r\n      )\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"CustomGutterComponent.renderDecorations","start_line":3489,"end_line":3500,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getCursorsClassName","line":3562,"func_location":"CursorsAndInputComponent.render","func_start_line":3559,"func_end_line":3598,"args":[],"code":"  render () {\r\n    const {lineHeight, decorationsToRender, scrollHeight, scrollWidth} = this.props\r\n\r\n    const className = this.getCursorsClassName()\r\n    const cursorHeight = lineHeight + 'px'\r\n\r\n    const children = [this.renderHiddenInput()]\r\n    for (let i = 0; i < decorationsToRender.cursors.length; i++) {\r\n      const {pixelLeft, pixelTop, pixelWidth, className: extraCursorClassName, style: extraCursorStyle} = decorationsToRender.cursors[i]\r\n      let cursorClassName = 'cursor'\r\n      if (extraCursorClassName) cursorClassName += ' ' + extraCursorClassName\r\n\r\n      const cursorStyle = {\r\n        height: cursorHeight,\r\n        width: Math.min(pixelWidth, scrollWidth - pixelLeft) + 'px',\r\n        transform: `translate(${pixelLeft}px, ${pixelTop}px)`\r\n      }\r\n      if (extraCursorStyle) Object.assign(cursorStyle, extraCursorStyle)\r\n\r\n      children.push($.div({\r\n        className: cursorClassName,\r\n        style: cursorStyle\r\n      }))\r\n    }\r\n\r\n    return $.div({\r\n      key: 'cursors',\r\n      ref: 'cursors',\r\n      className,\r\n      style: {\r\n        position: 'absolute',\r\n        contain: 'strict',\r\n        zIndex: 1,\r\n        width: scrollWidth + 'px',\r\n        height: scrollHeight + 'px',\r\n        pointerEvents: 'none',\r\n        userSelect: 'none'\r\n      }\r\n    }, children)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"CursorsAndInputComponent.getCursorsClassName","start_line":3600,"end_line":3602,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"renderHiddenInput","line":3565,"func_location":"CursorsAndInputComponent.render","func_start_line":3559,"func_end_line":3598,"args":[],"code":"  render () {\r\n    const {lineHeight, decorationsToRender, scrollHeight, scrollWidth} = this.props\r\n\r\n    const className = this.getCursorsClassName()\r\n    const cursorHeight = lineHeight + 'px'\r\n\r\n    const children = [this.renderHiddenInput()]\r\n    for (let i = 0; i < decorationsToRender.cursors.length; i++) {\r\n      const {pixelLeft, pixelTop, pixelWidth, className: extraCursorClassName, style: extraCursorStyle} = decorationsToRender.cursors[i]\r\n      let cursorClassName = 'cursor'\r\n      if (extraCursorClassName) cursorClassName += ' ' + extraCursorClassName\r\n\r\n      const cursorStyle = {\r\n        height: cursorHeight,\r\n        width: Math.min(pixelWidth, scrollWidth - pixelLeft) + 'px',\r\n        transform: `translate(${pixelLeft}px, ${pixelTop}px)`\r\n      }\r\n      if (extraCursorStyle) Object.assign(cursorStyle, extraCursorStyle)\r\n\r\n      children.push($.div({\r\n        className: cursorClassName,\r\n        style: cursorStyle\r\n      }))\r\n    }\r\n\r\n    return $.div({\r\n      key: 'cursors',\r\n      ref: 'cursors',\r\n      className,\r\n      style: {\r\n        position: 'absolute',\r\n        contain: 'strict',\r\n        zIndex: 1,\r\n        width: scrollWidth + 'px',\r\n        height: scrollHeight + 'px',\r\n        pointerEvents: 'none',\r\n        userSelect: 'none'\r\n      }\r\n    }, children)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"CursorsAndInputComponent.renderHiddenInput","start_line":3604,"end_line":3648,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"getIconName","line":782,"func_location":"DockToggleButton.render","func_start_line":765,"func_end_line":789},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"getIconName","start_line":839,"end_line":846,"comment":[],"params":["location","visible"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"getPreferredSize","line":192,"func_location":"Dock.render","func_start_line":179,"func_end_line":244,"args":[".state.draggingItem",".location"],"code":"  render () {\r\n    const innerElementClassList = ['atom-dock-inner', this.location]\r\n    if (this.state.visible) innerElementClassList.push(VISIBLE_CLASS)\r\n\r\n    const maskElementClassList = ['atom-dock-mask']\r\n    if (this.state.shouldAnimate) maskElementClassList.push(SHOULD_ANIMATE_CLASS)\r\n\r\n    const cursorOverlayElementClassList = ['atom-dock-cursor-overlay', this.location]\r\n    if (this.state.resizing) cursorOverlayElementClassList.push(CURSOR_OVERLAY_VISIBLE_CLASS)\r\n\r\n    const shouldBeVisible = this.state.visible || this.state.showDropTarget\r\n    const size = Math.max(MINIMUM_SIZE,\r\n      this.state.size ||\r\n      (this.state.draggingItem && getPreferredSize(this.state.draggingItem, this.location)) ||\r\n      DEFAULT_INITIAL_SIZE\r\n    )\r\n\r\n    // We need to change the size of the mask...\r\n    const maskStyle = {[this.widthOrHeight]: `${shouldBeVisible ? size : 0}px`}\r\n    // ...but the content needs to maintain a constant size.\r\n    const wrapperStyle = {[this.widthOrHeight]: `${size}px`}\r\n\r\n    return $(\r\n      'atom-dock',\r\n      {className: this.location},\r\n      $.div(\r\n        {ref: 'innerElement', className: innerElementClassList.join(' ')},\r\n        $.div(\r\n          {\r\n            className: maskElementClassList.join(' '),\r\n            style: maskStyle\r\n          },\r\n          $.div(\r\n            {\r\n              ref: 'wrapperElement',\r\n              className: `atom-dock-content-wrapper ${this.location}`,\r\n              style: wrapperStyle\r\n            },\r\n            $(DockResizeHandle, {\r\n              location: this.location,\r\n              onResizeStart: this.handleResizeHandleDragStart,\r\n              onResizeToFit: this.handleResizeToFit,\r\n              dockIsVisible: this.state.visible\r\n            }),\r\n            $(ElementComponent, {element: this.paneContainer.getElement()}),\r\n            $.div({className: cursorOverlayElementClassList.join(' ')})\r\n          )\r\n        ),\r\n        $(DockToggleButton, {\r\n          ref: 'toggleButton',\r\n          onDragEnter: this.state.draggingItem ? this.handleToggleButtonDragEnter : null,\r\n          location: this.location,\r\n          toggle: this.toggle,\r\n          dockIsVisible: shouldBeVisible,\r\n          visible:\r\n            // Don't show the toggle button if the dock is closed and empty...\r\n            (this.state.hovered &&\r\n              (this.state.visible || this.getPaneItems().length > 0)) ||\r\n            // ...or if the item can't be dropped in that dock.\r\n            (!shouldBeVisible &&\r\n              this.state.draggingItem &&\r\n              isItemAllowed(this.state.draggingItem, this.location))\r\n        })\r\n      )\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"getPreferredSize","start_line":825,"end_line":837,"comment":[],"params":["item","location"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"getPaneItems","line":236,"func_location":"Dock.render","func_start_line":179,"func_end_line":244,"args":[],"code":"  render () {\r\n    const innerElementClassList = ['atom-dock-inner', this.location]\r\n    if (this.state.visible) innerElementClassList.push(VISIBLE_CLASS)\r\n\r\n    const maskElementClassList = ['atom-dock-mask']\r\n    if (this.state.shouldAnimate) maskElementClassList.push(SHOULD_ANIMATE_CLASS)\r\n\r\n    const cursorOverlayElementClassList = ['atom-dock-cursor-overlay', this.location]\r\n    if (this.state.resizing) cursorOverlayElementClassList.push(CURSOR_OVERLAY_VISIBLE_CLASS)\r\n\r\n    const shouldBeVisible = this.state.visible || this.state.showDropTarget\r\n    const size = Math.max(MINIMUM_SIZE,\r\n      this.state.size ||\r\n      (this.state.draggingItem && getPreferredSize(this.state.draggingItem, this.location)) ||\r\n      DEFAULT_INITIAL_SIZE\r\n    )\r\n\r\n    // We need to change the size of the mask...\r\n    const maskStyle = {[this.widthOrHeight]: `${shouldBeVisible ? size : 0}px`}\r\n    // ...but the content needs to maintain a constant size.\r\n    const wrapperStyle = {[this.widthOrHeight]: `${size}px`}\r\n\r\n    return $(\r\n      'atom-dock',\r\n      {className: this.location},\r\n      $.div(\r\n        {ref: 'innerElement', className: innerElementClassList.join(' ')},\r\n        $.div(\r\n          {\r\n            className: maskElementClassList.join(' '),\r\n            style: maskStyle\r\n          },\r\n          $.div(\r\n            {\r\n              ref: 'wrapperElement',\r\n              className: `atom-dock-content-wrapper ${this.location}`,\r\n              style: wrapperStyle\r\n            },\r\n            $(DockResizeHandle, {\r\n              location: this.location,\r\n              onResizeStart: this.handleResizeHandleDragStart,\r\n              onResizeToFit: this.handleResizeToFit,\r\n              dockIsVisible: this.state.visible\r\n            }),\r\n            $(ElementComponent, {element: this.paneContainer.getElement()}),\r\n            $.div({className: cursorOverlayElementClassList.join(' ')})\r\n          )\r\n        ),\r\n        $(DockToggleButton, {\r\n          ref: 'toggleButton',\r\n          onDragEnter: this.state.draggingItem ? this.handleToggleButtonDragEnter : null,\r\n          location: this.location,\r\n          toggle: this.toggle,\r\n          dockIsVisible: shouldBeVisible,\r\n          visible:\r\n            // Don't show the toggle button if the dock is closed and empty...\r\n            (this.state.hovered &&\r\n              (this.state.visible || this.getPaneItems().length > 0)) ||\r\n            // ...or if the item can't be dropped in that dock.\r\n            (!shouldBeVisible &&\r\n              this.state.draggingItem &&\r\n              isItemAllowed(this.state.draggingItem, this.location))\r\n        })\r\n      )\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.getPaneItems","start_line":642,"end_line":644,"comment":["\r\n  Section: Pane Items\r\n  "," Essential: Get all pane items in the dock.",""," Returns an {Array} of items."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"isItemAllowed","line":240,"func_location":"Dock.render","func_start_line":179,"func_end_line":244,"args":[".state.draggingItem",".location"],"code":"  render () {\r\n    const innerElementClassList = ['atom-dock-inner', this.location]\r\n    if (this.state.visible) innerElementClassList.push(VISIBLE_CLASS)\r\n\r\n    const maskElementClassList = ['atom-dock-mask']\r\n    if (this.state.shouldAnimate) maskElementClassList.push(SHOULD_ANIMATE_CLASS)\r\n\r\n    const cursorOverlayElementClassList = ['atom-dock-cursor-overlay', this.location]\r\n    if (this.state.resizing) cursorOverlayElementClassList.push(CURSOR_OVERLAY_VISIBLE_CLASS)\r\n\r\n    const shouldBeVisible = this.state.visible || this.state.showDropTarget\r\n    const size = Math.max(MINIMUM_SIZE,\r\n      this.state.size ||\r\n      (this.state.draggingItem && getPreferredSize(this.state.draggingItem, this.location)) ||\r\n      DEFAULT_INITIAL_SIZE\r\n    )\r\n\r\n    // We need to change the size of the mask...\r\n    const maskStyle = {[this.widthOrHeight]: `${shouldBeVisible ? size : 0}px`}\r\n    // ...but the content needs to maintain a constant size.\r\n    const wrapperStyle = {[this.widthOrHeight]: `${size}px`}\r\n\r\n    return $(\r\n      'atom-dock',\r\n      {className: this.location},\r\n      $.div(\r\n        {ref: 'innerElement', className: innerElementClassList.join(' ')},\r\n        $.div(\r\n          {\r\n            className: maskElementClassList.join(' '),\r\n            style: maskStyle\r\n          },\r\n          $.div(\r\n            {\r\n              ref: 'wrapperElement',\r\n              className: `atom-dock-content-wrapper ${this.location}`,\r\n              style: wrapperStyle\r\n            },\r\n            $(DockResizeHandle, {\r\n              location: this.location,\r\n              onResizeStart: this.handleResizeHandleDragStart,\r\n              onResizeToFit: this.handleResizeToFit,\r\n              dockIsVisible: this.state.visible\r\n            }),\r\n            $(ElementComponent, {element: this.paneContainer.getElement()}),\r\n            $.div({className: cursorOverlayElementClassList.join(' ')})\r\n          )\r\n        ),\r\n        $(DockToggleButton, {\r\n          ref: 'toggleButton',\r\n          onDragEnter: this.state.draggingItem ? this.handleToggleButtonDragEnter : null,\r\n          location: this.location,\r\n          toggle: this.toggle,\r\n          dockIsVisible: shouldBeVisible,\r\n          visible:\r\n            // Don't show the toggle button if the dock is closed and empty...\r\n            (this.state.hovered &&\r\n              (this.state.visible || this.getPaneItems().length > 0)) ||\r\n            // ...or if the item can't be dropped in that dock.\r\n            (!shouldBeVisible &&\r\n              this.state.draggingItem &&\r\n              isItemAllowed(this.state.draggingItem, this.location))\r\n        })\r\n      )\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"isItemAllowed","start_line":858,"end_line":861,"comment":[" Is the item allowed in the given location?"],"params":["item","location"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollWidth","line":741,"func_location":"TextEditorComponent.renderBlockDecorationMeasurementArea","func_start_line":733,"func_end_line":744,"args":[],"code":"  renderBlockDecorationMeasurementArea () {\r\n    return $.div({\r\n      ref: 'blockDecorationMeasurementArea',\r\n      key: 'blockDecorationMeasurementArea',\r\n      style: {\r\n        contain: 'strict',\r\n        position: 'absolute',\r\n        visibility: 'hidden',\r\n        width: this.getScrollWidth() + 'px'\r\n      }\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollWidth","start_line":2672,"end_line":2682,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"ceilToPhysicalPixelBoundary","line":584,"func_location":"TextEditorComponent.renderContent","func_start_line":577,"func_end_line":600,"args":[null],"code":"  renderContent () {\r\n    let style = {\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      backgroundColor: 'inherit'\r\n    }\r\n    if (this.hasInitialMeasurements) {\r\n      style.width = ceilToPhysicalPixelBoundary(this.getScrollWidth()) + 'px'\r\n      style.height = ceilToPhysicalPixelBoundary(this.getScrollHeight()) + 'px'\r\n      style.willChange = 'transform'\r\n      style.transform = `translate(${-roundToPhysicalPixelBoundary(this.getScrollLeft())}px, ${-roundToPhysicalPixelBoundary(this.getScrollTop())}px)`\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'content',\r\n        on: {mousedown: this.didMouseDownOnContent},\r\n        style\r\n      },\r\n      this.renderLineTiles(),\r\n      this.renderBlockDecorationMeasurementArea(),\r\n      this.renderCharacterMeasurementLine()\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"ceilToPhysicalPixelBoundary","start_line":4491,"end_line":4494,"comment":[],"params":["virtualPixelPosition"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollWidth","line":584,"func_location":"TextEditorComponent.renderContent","func_start_line":577,"func_end_line":600,"args":[null],"code":"  renderContent () {\r\n    let style = {\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      backgroundColor: 'inherit'\r\n    }\r\n    if (this.hasInitialMeasurements) {\r\n      style.width = ceilToPhysicalPixelBoundary(this.getScrollWidth()) + 'px'\r\n      style.height = ceilToPhysicalPixelBoundary(this.getScrollHeight()) + 'px'\r\n      style.willChange = 'transform'\r\n      style.transform = `translate(${-roundToPhysicalPixelBoundary(this.getScrollLeft())}px, ${-roundToPhysicalPixelBoundary(this.getScrollTop())}px)`\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'content',\r\n        on: {mousedown: this.didMouseDownOnContent},\r\n        style\r\n      },\r\n      this.renderLineTiles(),\r\n      this.renderBlockDecorationMeasurementArea(),\r\n      this.renderCharacterMeasurementLine()\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollWidth","start_line":2672,"end_line":2682,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"ceilToPhysicalPixelBoundary","line":585,"func_location":"TextEditorComponent.renderContent","func_start_line":577,"func_end_line":600,"args":[null],"code":"  renderContent () {\r\n    let style = {\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      backgroundColor: 'inherit'\r\n    }\r\n    if (this.hasInitialMeasurements) {\r\n      style.width = ceilToPhysicalPixelBoundary(this.getScrollWidth()) + 'px'\r\n      style.height = ceilToPhysicalPixelBoundary(this.getScrollHeight()) + 'px'\r\n      style.willChange = 'transform'\r\n      style.transform = `translate(${-roundToPhysicalPixelBoundary(this.getScrollLeft())}px, ${-roundToPhysicalPixelBoundary(this.getScrollTop())}px)`\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'content',\r\n        on: {mousedown: this.didMouseDownOnContent},\r\n        style\r\n      },\r\n      this.renderLineTiles(),\r\n      this.renderBlockDecorationMeasurementArea(),\r\n      this.renderCharacterMeasurementLine()\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"ceilToPhysicalPixelBoundary","start_line":4491,"end_line":4494,"comment":[],"params":["virtualPixelPosition"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollHeight","line":585,"func_location":"TextEditorComponent.renderContent","func_start_line":577,"func_end_line":600,"args":[null],"code":"  renderContent () {\r\n    let style = {\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      backgroundColor: 'inherit'\r\n    }\r\n    if (this.hasInitialMeasurements) {\r\n      style.width = ceilToPhysicalPixelBoundary(this.getScrollWidth()) + 'px'\r\n      style.height = ceilToPhysicalPixelBoundary(this.getScrollHeight()) + 'px'\r\n      style.willChange = 'transform'\r\n      style.transform = `translate(${-roundToPhysicalPixelBoundary(this.getScrollLeft())}px, ${-roundToPhysicalPixelBoundary(this.getScrollTop())}px)`\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'content',\r\n        on: {mousedown: this.didMouseDownOnContent},\r\n        style\r\n      },\r\n      this.renderLineTiles(),\r\n      this.renderBlockDecorationMeasurementArea(),\r\n      this.renderCharacterMeasurementLine()\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollHeight","start_line":2659,"end_line":2670,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"roundToPhysicalPixelBoundary","line":587,"func_location":"TextEditorComponent.renderContent","func_start_line":577,"func_end_line":600,"args":[null],"code":"  renderContent () {\r\n    let style = {\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      backgroundColor: 'inherit'\r\n    }\r\n    if (this.hasInitialMeasurements) {\r\n      style.width = ceilToPhysicalPixelBoundary(this.getScrollWidth()) + 'px'\r\n      style.height = ceilToPhysicalPixelBoundary(this.getScrollHeight()) + 'px'\r\n      style.willChange = 'transform'\r\n      style.transform = `translate(${-roundToPhysicalPixelBoundary(this.getScrollLeft())}px, ${-roundToPhysicalPixelBoundary(this.getScrollTop())}px)`\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'content',\r\n        on: {mousedown: this.didMouseDownOnContent},\r\n        style\r\n      },\r\n      this.renderLineTiles(),\r\n      this.renderBlockDecorationMeasurementArea(),\r\n      this.renderCharacterMeasurementLine()\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"roundToPhysicalPixelBoundary","start_line":4486,"end_line":4489,"comment":[],"params":["virtualPixelPosition"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollLeft","line":587,"func_location":"TextEditorComponent.renderContent","func_start_line":577,"func_end_line":600,"args":[null],"code":"  renderContent () {\r\n    let style = {\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      backgroundColor: 'inherit'\r\n    }\r\n    if (this.hasInitialMeasurements) {\r\n      style.width = ceilToPhysicalPixelBoundary(this.getScrollWidth()) + 'px'\r\n      style.height = ceilToPhysicalPixelBoundary(this.getScrollHeight()) + 'px'\r\n      style.willChange = 'transform'\r\n      style.transform = `translate(${-roundToPhysicalPixelBoundary(this.getScrollLeft())}px, ${-roundToPhysicalPixelBoundary(this.getScrollTop())}px)`\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'content',\r\n        on: {mousedown: this.didMouseDownOnContent},\r\n        style\r\n      },\r\n      this.renderLineTiles(),\r\n      this.renderBlockDecorationMeasurementArea(),\r\n      this.renderCharacterMeasurementLine()\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollLeft","start_line":2823,"end_line":2825,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"roundToPhysicalPixelBoundary","line":587,"func_location":"TextEditorComponent.renderContent","func_start_line":577,"func_end_line":600,"args":[null],"code":"  renderContent () {\r\n    let style = {\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      backgroundColor: 'inherit'\r\n    }\r\n    if (this.hasInitialMeasurements) {\r\n      style.width = ceilToPhysicalPixelBoundary(this.getScrollWidth()) + 'px'\r\n      style.height = ceilToPhysicalPixelBoundary(this.getScrollHeight()) + 'px'\r\n      style.willChange = 'transform'\r\n      style.transform = `translate(${-roundToPhysicalPixelBoundary(this.getScrollLeft())}px, ${-roundToPhysicalPixelBoundary(this.getScrollTop())}px)`\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'content',\r\n        on: {mousedown: this.didMouseDownOnContent},\r\n        style\r\n      },\r\n      this.renderLineTiles(),\r\n      this.renderBlockDecorationMeasurementArea(),\r\n      this.renderCharacterMeasurementLine()\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"roundToPhysicalPixelBoundary","start_line":4486,"end_line":4489,"comment":[],"params":["virtualPixelPosition"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollTop","line":587,"func_location":"TextEditorComponent.renderContent","func_start_line":577,"func_end_line":600,"args":[null],"code":"  renderContent () {\r\n    let style = {\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      backgroundColor: 'inherit'\r\n    }\r\n    if (this.hasInitialMeasurements) {\r\n      style.width = ceilToPhysicalPixelBoundary(this.getScrollWidth()) + 'px'\r\n      style.height = ceilToPhysicalPixelBoundary(this.getScrollHeight()) + 'px'\r\n      style.willChange = 'transform'\r\n      style.transform = `translate(${-roundToPhysicalPixelBoundary(this.getScrollLeft())}px, ${-roundToPhysicalPixelBoundary(this.getScrollTop())}px)`\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'content',\r\n        on: {mousedown: this.didMouseDownOnContent},\r\n        style\r\n      },\r\n      this.renderLineTiles(),\r\n      this.renderBlockDecorationMeasurementArea(),\r\n      this.renderCharacterMeasurementLine()\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollTop","start_line":2791,"end_line":2794,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"renderLineTiles","line":596,"func_location":"TextEditorComponent.renderContent","func_start_line":577,"func_end_line":600,"args":[],"code":"  renderContent () {\r\n    let style = {\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      backgroundColor: 'inherit'\r\n    }\r\n    if (this.hasInitialMeasurements) {\r\n      style.width = ceilToPhysicalPixelBoundary(this.getScrollWidth()) + 'px'\r\n      style.height = ceilToPhysicalPixelBoundary(this.getScrollHeight()) + 'px'\r\n      style.willChange = 'transform'\r\n      style.transform = `translate(${-roundToPhysicalPixelBoundary(this.getScrollLeft())}px, ${-roundToPhysicalPixelBoundary(this.getScrollTop())}px)`\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'content',\r\n        on: {mousedown: this.didMouseDownOnContent},\r\n        style\r\n      },\r\n      this.renderLineTiles(),\r\n      this.renderBlockDecorationMeasurementArea(),\r\n      this.renderCharacterMeasurementLine()\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.renderLineTiles","start_line":612,"end_line":680,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"renderBlockDecorationMeasurementArea","line":597,"func_location":"TextEditorComponent.renderContent","func_start_line":577,"func_end_line":600,"args":[],"code":"  renderContent () {\r\n    let style = {\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      backgroundColor: 'inherit'\r\n    }\r\n    if (this.hasInitialMeasurements) {\r\n      style.width = ceilToPhysicalPixelBoundary(this.getScrollWidth()) + 'px'\r\n      style.height = ceilToPhysicalPixelBoundary(this.getScrollHeight()) + 'px'\r\n      style.willChange = 'transform'\r\n      style.transform = `translate(${-roundToPhysicalPixelBoundary(this.getScrollLeft())}px, ${-roundToPhysicalPixelBoundary(this.getScrollTop())}px)`\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'content',\r\n        on: {mousedown: this.didMouseDownOnContent},\r\n        style\r\n      },\r\n      this.renderLineTiles(),\r\n      this.renderBlockDecorationMeasurementArea(),\r\n      this.renderCharacterMeasurementLine()\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.renderBlockDecorationMeasurementArea","start_line":733,"end_line":744,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"renderCharacterMeasurementLine","line":598,"func_location":"TextEditorComponent.renderContent","func_start_line":577,"func_end_line":600,"args":[],"code":"  renderContent () {\r\n    let style = {\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      backgroundColor: 'inherit'\r\n    }\r\n    if (this.hasInitialMeasurements) {\r\n      style.width = ceilToPhysicalPixelBoundary(this.getScrollWidth()) + 'px'\r\n      style.height = ceilToPhysicalPixelBoundary(this.getScrollHeight()) + 'px'\r\n      style.willChange = 'transform'\r\n      style.transform = `translate(${-roundToPhysicalPixelBoundary(this.getScrollLeft())}px, ${-roundToPhysicalPixelBoundary(this.getScrollTop())}px)`\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'content',\r\n        on: {mousedown: this.didMouseDownOnContent},\r\n        style\r\n      },\r\n      this.renderLineTiles(),\r\n      this.renderBlockDecorationMeasurementArea(),\r\n      this.renderCharacterMeasurementLine()\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.renderCharacterMeasurementLine","start_line":718,"end_line":731,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getLineHeight","line":697,"func_location":"TextEditorComponent.renderCursorsAndInput","func_start_line":682,"func_end_line":705,"args":[],"code":"  renderCursorsAndInput () {\r\n    return $(CursorsAndInputComponent, {\r\n      ref: 'cursorsAndInput',\r\n      key: 'cursorsAndInput',\r\n      didBlurHiddenInput: this.didBlurHiddenInput,\r\n      didFocusHiddenInput: this.didFocusHiddenInput,\r\n      didTextInput: this.didTextInput,\r\n      didPaste: this.didPaste,\r\n      didKeydown: this.didKeydown,\r\n      didKeyup: this.didKeyup,\r\n      didKeypress: this.didKeypress,\r\n      didCompositionStart: this.didCompositionStart,\r\n      didCompositionUpdate: this.didCompositionUpdate,\r\n      didCompositionEnd: this.didCompositionEnd,\r\n      measuredContent: this.measuredContent,\r\n      lineHeight: this.getLineHeight(),\r\n      scrollHeight: this.getScrollHeight(),\r\n      scrollWidth: this.getScrollWidth(),\r\n      decorationsToRender: this.decorationsToRender,\r\n      cursorsBlinkedOff: this.cursorsBlinkedOff,\r\n      hiddenInputPosition: this.hiddenInputPosition,\r\n      tabIndex: this.tabIndex\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getLineHeight","start_line":2600,"end_line":2602,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollHeight","line":698,"func_location":"TextEditorComponent.renderCursorsAndInput","func_start_line":682,"func_end_line":705,"args":[],"code":"  renderCursorsAndInput () {\r\n    return $(CursorsAndInputComponent, {\r\n      ref: 'cursorsAndInput',\r\n      key: 'cursorsAndInput',\r\n      didBlurHiddenInput: this.didBlurHiddenInput,\r\n      didFocusHiddenInput: this.didFocusHiddenInput,\r\n      didTextInput: this.didTextInput,\r\n      didPaste: this.didPaste,\r\n      didKeydown: this.didKeydown,\r\n      didKeyup: this.didKeyup,\r\n      didKeypress: this.didKeypress,\r\n      didCompositionStart: this.didCompositionStart,\r\n      didCompositionUpdate: this.didCompositionUpdate,\r\n      didCompositionEnd: this.didCompositionEnd,\r\n      measuredContent: this.measuredContent,\r\n      lineHeight: this.getLineHeight(),\r\n      scrollHeight: this.getScrollHeight(),\r\n      scrollWidth: this.getScrollWidth(),\r\n      decorationsToRender: this.decorationsToRender,\r\n      cursorsBlinkedOff: this.cursorsBlinkedOff,\r\n      hiddenInputPosition: this.hiddenInputPosition,\r\n      tabIndex: this.tabIndex\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollHeight","start_line":2659,"end_line":2670,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollWidth","line":699,"func_location":"TextEditorComponent.renderCursorsAndInput","func_start_line":682,"func_end_line":705,"args":[],"code":"  renderCursorsAndInput () {\r\n    return $(CursorsAndInputComponent, {\r\n      ref: 'cursorsAndInput',\r\n      key: 'cursorsAndInput',\r\n      didBlurHiddenInput: this.didBlurHiddenInput,\r\n      didFocusHiddenInput: this.didFocusHiddenInput,\r\n      didTextInput: this.didTextInput,\r\n      didPaste: this.didPaste,\r\n      didKeydown: this.didKeydown,\r\n      didKeyup: this.didKeyup,\r\n      didKeypress: this.didKeypress,\r\n      didCompositionStart: this.didCompositionStart,\r\n      didCompositionUpdate: this.didCompositionUpdate,\r\n      didCompositionEnd: this.didCompositionEnd,\r\n      measuredContent: this.measuredContent,\r\n      lineHeight: this.getLineHeight(),\r\n      scrollHeight: this.getScrollHeight(),\r\n      scrollWidth: this.getScrollWidth(),\r\n      decorationsToRender: this.decorationsToRender,\r\n      cursorsBlinkedOff: this.cursorsBlinkedOff,\r\n      hiddenInputPosition: this.hiddenInputPosition,\r\n      tabIndex: this.tabIndex\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollWidth","start_line":2672,"end_line":2682,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollHeight","line":753,"func_location":"TextEditorComponent.renderDummyScrollbars","func_start_line":746,"func_end_line":809,"args":[],"code":"  renderDummyScrollbars () {\r\n    if (this.shouldRenderDummyScrollbars && !this.props.model.isMini()) {\r\n      let scrollHeight, scrollTop, horizontalScrollbarHeight\r\n      let scrollWidth, scrollLeft, verticalScrollbarWidth, forceScrollbarVisible\r\n      let canScrollHorizontally, canScrollVertically\r\n\r\n      if (this.hasInitialMeasurements) {\r\n        scrollHeight = this.getScrollHeight()\r\n        scrollWidth = this.getScrollWidth()\r\n        scrollTop = this.getScrollTop()\r\n        scrollLeft = this.getScrollLeft()\r\n        canScrollHorizontally = this.canScrollHorizontally()\r\n        canScrollVertically = this.canScrollVertically()\r\n        horizontalScrollbarHeight = this.getHorizontalScrollbarHeight()\r\n        verticalScrollbarWidth = this.getVerticalScrollbarWidth()\r\n        forceScrollbarVisible = this.remeasureScrollbars\r\n      } else {\r\n        forceScrollbarVisible = true\r\n      }\r\n\r\n      return [\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'verticalScrollbar',\r\n          orientation: 'vertical',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollVertically,\r\n          scrollHeight,\r\n          scrollTop,\r\n          horizontalScrollbarHeight,\r\n          forceScrollbarVisible\r\n        }),\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'horizontalScrollbar',\r\n          orientation: 'horizontal',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollHorizontally,\r\n          scrollWidth,\r\n          scrollLeft,\r\n          verticalScrollbarWidth,\r\n          forceScrollbarVisible\r\n        }),\r\n\r\n        // Force a \"corner\" to render where the two scrollbars meet at the lower right\r\n        $.div(\r\n          {\r\n            ref: 'scrollbarCorner',\r\n            className: 'scrollbar-corner',\r\n            style: {\r\n              position: 'absolute',\r\n              height: '20px',\r\n              width: '20px',\r\n              bottom: 0,\r\n              right: 0,\r\n              overflow: 'scroll'\r\n            }\r\n          }\r\n        )\r\n      ]\r\n    } else {\r\n      return null\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollHeight","start_line":2659,"end_line":2670,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollWidth","line":754,"func_location":"TextEditorComponent.renderDummyScrollbars","func_start_line":746,"func_end_line":809,"args":[],"code":"  renderDummyScrollbars () {\r\n    if (this.shouldRenderDummyScrollbars && !this.props.model.isMini()) {\r\n      let scrollHeight, scrollTop, horizontalScrollbarHeight\r\n      let scrollWidth, scrollLeft, verticalScrollbarWidth, forceScrollbarVisible\r\n      let canScrollHorizontally, canScrollVertically\r\n\r\n      if (this.hasInitialMeasurements) {\r\n        scrollHeight = this.getScrollHeight()\r\n        scrollWidth = this.getScrollWidth()\r\n        scrollTop = this.getScrollTop()\r\n        scrollLeft = this.getScrollLeft()\r\n        canScrollHorizontally = this.canScrollHorizontally()\r\n        canScrollVertically = this.canScrollVertically()\r\n        horizontalScrollbarHeight = this.getHorizontalScrollbarHeight()\r\n        verticalScrollbarWidth = this.getVerticalScrollbarWidth()\r\n        forceScrollbarVisible = this.remeasureScrollbars\r\n      } else {\r\n        forceScrollbarVisible = true\r\n      }\r\n\r\n      return [\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'verticalScrollbar',\r\n          orientation: 'vertical',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollVertically,\r\n          scrollHeight,\r\n          scrollTop,\r\n          horizontalScrollbarHeight,\r\n          forceScrollbarVisible\r\n        }),\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'horizontalScrollbar',\r\n          orientation: 'horizontal',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollHorizontally,\r\n          scrollWidth,\r\n          scrollLeft,\r\n          verticalScrollbarWidth,\r\n          forceScrollbarVisible\r\n        }),\r\n\r\n        // Force a \"corner\" to render where the two scrollbars meet at the lower right\r\n        $.div(\r\n          {\r\n            ref: 'scrollbarCorner',\r\n            className: 'scrollbar-corner',\r\n            style: {\r\n              position: 'absolute',\r\n              height: '20px',\r\n              width: '20px',\r\n              bottom: 0,\r\n              right: 0,\r\n              overflow: 'scroll'\r\n            }\r\n          }\r\n        )\r\n      ]\r\n    } else {\r\n      return null\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollWidth","start_line":2672,"end_line":2682,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollTop","line":755,"func_location":"TextEditorComponent.renderDummyScrollbars","func_start_line":746,"func_end_line":809,"args":[],"code":"  renderDummyScrollbars () {\r\n    if (this.shouldRenderDummyScrollbars && !this.props.model.isMini()) {\r\n      let scrollHeight, scrollTop, horizontalScrollbarHeight\r\n      let scrollWidth, scrollLeft, verticalScrollbarWidth, forceScrollbarVisible\r\n      let canScrollHorizontally, canScrollVertically\r\n\r\n      if (this.hasInitialMeasurements) {\r\n        scrollHeight = this.getScrollHeight()\r\n        scrollWidth = this.getScrollWidth()\r\n        scrollTop = this.getScrollTop()\r\n        scrollLeft = this.getScrollLeft()\r\n        canScrollHorizontally = this.canScrollHorizontally()\r\n        canScrollVertically = this.canScrollVertically()\r\n        horizontalScrollbarHeight = this.getHorizontalScrollbarHeight()\r\n        verticalScrollbarWidth = this.getVerticalScrollbarWidth()\r\n        forceScrollbarVisible = this.remeasureScrollbars\r\n      } else {\r\n        forceScrollbarVisible = true\r\n      }\r\n\r\n      return [\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'verticalScrollbar',\r\n          orientation: 'vertical',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollVertically,\r\n          scrollHeight,\r\n          scrollTop,\r\n          horizontalScrollbarHeight,\r\n          forceScrollbarVisible\r\n        }),\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'horizontalScrollbar',\r\n          orientation: 'horizontal',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollHorizontally,\r\n          scrollWidth,\r\n          scrollLeft,\r\n          verticalScrollbarWidth,\r\n          forceScrollbarVisible\r\n        }),\r\n\r\n        // Force a \"corner\" to render where the two scrollbars meet at the lower right\r\n        $.div(\r\n          {\r\n            ref: 'scrollbarCorner',\r\n            className: 'scrollbar-corner',\r\n            style: {\r\n              position: 'absolute',\r\n              height: '20px',\r\n              width: '20px',\r\n              bottom: 0,\r\n              right: 0,\r\n              overflow: 'scroll'\r\n            }\r\n          }\r\n        )\r\n      ]\r\n    } else {\r\n      return null\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollTop","start_line":2791,"end_line":2794,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollLeft","line":756,"func_location":"TextEditorComponent.renderDummyScrollbars","func_start_line":746,"func_end_line":809,"args":[],"code":"  renderDummyScrollbars () {\r\n    if (this.shouldRenderDummyScrollbars && !this.props.model.isMini()) {\r\n      let scrollHeight, scrollTop, horizontalScrollbarHeight\r\n      let scrollWidth, scrollLeft, verticalScrollbarWidth, forceScrollbarVisible\r\n      let canScrollHorizontally, canScrollVertically\r\n\r\n      if (this.hasInitialMeasurements) {\r\n        scrollHeight = this.getScrollHeight()\r\n        scrollWidth = this.getScrollWidth()\r\n        scrollTop = this.getScrollTop()\r\n        scrollLeft = this.getScrollLeft()\r\n        canScrollHorizontally = this.canScrollHorizontally()\r\n        canScrollVertically = this.canScrollVertically()\r\n        horizontalScrollbarHeight = this.getHorizontalScrollbarHeight()\r\n        verticalScrollbarWidth = this.getVerticalScrollbarWidth()\r\n        forceScrollbarVisible = this.remeasureScrollbars\r\n      } else {\r\n        forceScrollbarVisible = true\r\n      }\r\n\r\n      return [\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'verticalScrollbar',\r\n          orientation: 'vertical',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollVertically,\r\n          scrollHeight,\r\n          scrollTop,\r\n          horizontalScrollbarHeight,\r\n          forceScrollbarVisible\r\n        }),\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'horizontalScrollbar',\r\n          orientation: 'horizontal',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollHorizontally,\r\n          scrollWidth,\r\n          scrollLeft,\r\n          verticalScrollbarWidth,\r\n          forceScrollbarVisible\r\n        }),\r\n\r\n        // Force a \"corner\" to render where the two scrollbars meet at the lower right\r\n        $.div(\r\n          {\r\n            ref: 'scrollbarCorner',\r\n            className: 'scrollbar-corner',\r\n            style: {\r\n              position: 'absolute',\r\n              height: '20px',\r\n              width: '20px',\r\n              bottom: 0,\r\n              right: 0,\r\n              overflow: 'scroll'\r\n            }\r\n          }\r\n        )\r\n      ]\r\n    } else {\r\n      return null\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollLeft","start_line":2823,"end_line":2825,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"canScrollHorizontally","line":757,"func_location":"TextEditorComponent.renderDummyScrollbars","func_start_line":746,"func_end_line":809,"args":[],"code":"  renderDummyScrollbars () {\r\n    if (this.shouldRenderDummyScrollbars && !this.props.model.isMini()) {\r\n      let scrollHeight, scrollTop, horizontalScrollbarHeight\r\n      let scrollWidth, scrollLeft, verticalScrollbarWidth, forceScrollbarVisible\r\n      let canScrollHorizontally, canScrollVertically\r\n\r\n      if (this.hasInitialMeasurements) {\r\n        scrollHeight = this.getScrollHeight()\r\n        scrollWidth = this.getScrollWidth()\r\n        scrollTop = this.getScrollTop()\r\n        scrollLeft = this.getScrollLeft()\r\n        canScrollHorizontally = this.canScrollHorizontally()\r\n        canScrollVertically = this.canScrollVertically()\r\n        horizontalScrollbarHeight = this.getHorizontalScrollbarHeight()\r\n        verticalScrollbarWidth = this.getVerticalScrollbarWidth()\r\n        forceScrollbarVisible = this.remeasureScrollbars\r\n      } else {\r\n        forceScrollbarVisible = true\r\n      }\r\n\r\n      return [\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'verticalScrollbar',\r\n          orientation: 'vertical',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollVertically,\r\n          scrollHeight,\r\n          scrollTop,\r\n          horizontalScrollbarHeight,\r\n          forceScrollbarVisible\r\n        }),\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'horizontalScrollbar',\r\n          orientation: 'horizontal',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollHorizontally,\r\n          scrollWidth,\r\n          scrollLeft,\r\n          verticalScrollbarWidth,\r\n          forceScrollbarVisible\r\n        }),\r\n\r\n        // Force a \"corner\" to render where the two scrollbars meet at the lower right\r\n        $.div(\r\n          {\r\n            ref: 'scrollbarCorner',\r\n            className: 'scrollbar-corner',\r\n            style: {\r\n              position: 'absolute',\r\n              height: '20px',\r\n              width: '20px',\r\n              bottom: 0,\r\n              right: 0,\r\n              overflow: 'scroll'\r\n            }\r\n          }\r\n        )\r\n      ]\r\n    } else {\r\n      return null\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.canScrollHorizontally","start_line":2651,"end_line":2657,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"canScrollVertically","line":758,"func_location":"TextEditorComponent.renderDummyScrollbars","func_start_line":746,"func_end_line":809,"args":[],"code":"  renderDummyScrollbars () {\r\n    if (this.shouldRenderDummyScrollbars && !this.props.model.isMini()) {\r\n      let scrollHeight, scrollTop, horizontalScrollbarHeight\r\n      let scrollWidth, scrollLeft, verticalScrollbarWidth, forceScrollbarVisible\r\n      let canScrollHorizontally, canScrollVertically\r\n\r\n      if (this.hasInitialMeasurements) {\r\n        scrollHeight = this.getScrollHeight()\r\n        scrollWidth = this.getScrollWidth()\r\n        scrollTop = this.getScrollTop()\r\n        scrollLeft = this.getScrollLeft()\r\n        canScrollHorizontally = this.canScrollHorizontally()\r\n        canScrollVertically = this.canScrollVertically()\r\n        horizontalScrollbarHeight = this.getHorizontalScrollbarHeight()\r\n        verticalScrollbarWidth = this.getVerticalScrollbarWidth()\r\n        forceScrollbarVisible = this.remeasureScrollbars\r\n      } else {\r\n        forceScrollbarVisible = true\r\n      }\r\n\r\n      return [\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'verticalScrollbar',\r\n          orientation: 'vertical',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollVertically,\r\n          scrollHeight,\r\n          scrollTop,\r\n          horizontalScrollbarHeight,\r\n          forceScrollbarVisible\r\n        }),\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'horizontalScrollbar',\r\n          orientation: 'horizontal',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollHorizontally,\r\n          scrollWidth,\r\n          scrollLeft,\r\n          verticalScrollbarWidth,\r\n          forceScrollbarVisible\r\n        }),\r\n\r\n        // Force a \"corner\" to render where the two scrollbars meet at the lower right\r\n        $.div(\r\n          {\r\n            ref: 'scrollbarCorner',\r\n            className: 'scrollbar-corner',\r\n            style: {\r\n              position: 'absolute',\r\n              height: '20px',\r\n              width: '20px',\r\n              bottom: 0,\r\n              right: 0,\r\n              overflow: 'scroll'\r\n            }\r\n          }\r\n        )\r\n      ]\r\n    } else {\r\n      return null\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.canScrollVertically","start_line":2644,"end_line":2649,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getHorizontalScrollbarHeight","line":759,"func_location":"TextEditorComponent.renderDummyScrollbars","func_start_line":746,"func_end_line":809,"args":[],"code":"  renderDummyScrollbars () {\r\n    if (this.shouldRenderDummyScrollbars && !this.props.model.isMini()) {\r\n      let scrollHeight, scrollTop, horizontalScrollbarHeight\r\n      let scrollWidth, scrollLeft, verticalScrollbarWidth, forceScrollbarVisible\r\n      let canScrollHorizontally, canScrollVertically\r\n\r\n      if (this.hasInitialMeasurements) {\r\n        scrollHeight = this.getScrollHeight()\r\n        scrollWidth = this.getScrollWidth()\r\n        scrollTop = this.getScrollTop()\r\n        scrollLeft = this.getScrollLeft()\r\n        canScrollHorizontally = this.canScrollHorizontally()\r\n        canScrollVertically = this.canScrollVertically()\r\n        horizontalScrollbarHeight = this.getHorizontalScrollbarHeight()\r\n        verticalScrollbarWidth = this.getVerticalScrollbarWidth()\r\n        forceScrollbarVisible = this.remeasureScrollbars\r\n      } else {\r\n        forceScrollbarVisible = true\r\n      }\r\n\r\n      return [\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'verticalScrollbar',\r\n          orientation: 'vertical',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollVertically,\r\n          scrollHeight,\r\n          scrollTop,\r\n          horizontalScrollbarHeight,\r\n          forceScrollbarVisible\r\n        }),\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'horizontalScrollbar',\r\n          orientation: 'horizontal',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollHorizontally,\r\n          scrollWidth,\r\n          scrollLeft,\r\n          verticalScrollbarWidth,\r\n          forceScrollbarVisible\r\n        }),\r\n\r\n        // Force a \"corner\" to render where the two scrollbars meet at the lower right\r\n        $.div(\r\n          {\r\n            ref: 'scrollbarCorner',\r\n            className: 'scrollbar-corner',\r\n            style: {\r\n              position: 'absolute',\r\n              height: '20px',\r\n              width: '20px',\r\n              bottom: 0,\r\n              right: 0,\r\n              overflow: 'scroll'\r\n            }\r\n          }\r\n        )\r\n      ]\r\n    } else {\r\n      return null\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getHorizontalScrollbarHeight","start_line":2708,"end_line":2710,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getVerticalScrollbarWidth","line":760,"func_location":"TextEditorComponent.renderDummyScrollbars","func_start_line":746,"func_end_line":809,"args":[],"code":"  renderDummyScrollbars () {\r\n    if (this.shouldRenderDummyScrollbars && !this.props.model.isMini()) {\r\n      let scrollHeight, scrollTop, horizontalScrollbarHeight\r\n      let scrollWidth, scrollLeft, verticalScrollbarWidth, forceScrollbarVisible\r\n      let canScrollHorizontally, canScrollVertically\r\n\r\n      if (this.hasInitialMeasurements) {\r\n        scrollHeight = this.getScrollHeight()\r\n        scrollWidth = this.getScrollWidth()\r\n        scrollTop = this.getScrollTop()\r\n        scrollLeft = this.getScrollLeft()\r\n        canScrollHorizontally = this.canScrollHorizontally()\r\n        canScrollVertically = this.canScrollVertically()\r\n        horizontalScrollbarHeight = this.getHorizontalScrollbarHeight()\r\n        verticalScrollbarWidth = this.getVerticalScrollbarWidth()\r\n        forceScrollbarVisible = this.remeasureScrollbars\r\n      } else {\r\n        forceScrollbarVisible = true\r\n      }\r\n\r\n      return [\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'verticalScrollbar',\r\n          orientation: 'vertical',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollVertically,\r\n          scrollHeight,\r\n          scrollTop,\r\n          horizontalScrollbarHeight,\r\n          forceScrollbarVisible\r\n        }),\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'horizontalScrollbar',\r\n          orientation: 'horizontal',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollHorizontally,\r\n          scrollWidth,\r\n          scrollLeft,\r\n          verticalScrollbarWidth,\r\n          forceScrollbarVisible\r\n        }),\r\n\r\n        // Force a \"corner\" to render where the two scrollbars meet at the lower right\r\n        $.div(\r\n          {\r\n            ref: 'scrollbarCorner',\r\n            className: 'scrollbar-corner',\r\n            style: {\r\n              position: 'absolute',\r\n              height: '20px',\r\n              width: '20px',\r\n              bottom: 0,\r\n              right: 0,\r\n              overflow: 'scroll'\r\n            }\r\n          }\r\n        )\r\n      ]\r\n    } else {\r\n      return null\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getVerticalScrollbarWidth","start_line":2704,"end_line":2706,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedStartRow","line":958,"func_location":"TextEditorComponent.renderedScreenLineForRow","func_start_line":956,"func_end_line":961,"args":[],"code":"  renderedScreenLineForRow (row) {\r\n    return (\r\n      this.renderedScreenLines[row - this.getRenderedStartRow()] ||\r\n      this.extraRenderedScreenLines.get(row)\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedStartRow","start_line":2720,"end_line":2726,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollTop","line":533,"func_location":"TextEditorComponent.renderGutterContainer","func_start_line":523,"func_end_line":548,"args":[],"code":"  renderGutterContainer () {\r\n    if (this.props.model.isMini()) {\r\n      return null\r\n    } else {\r\n      return $(GutterContainerComponent, {\r\n        ref: 'gutterContainer',\r\n        key: 'gutterContainer',\r\n        rootComponent: this,\r\n        hasInitialMeasurements: this.hasInitialMeasurements,\r\n        measuredContent: this.measuredContent,\r\n        scrollTop: this.getScrollTop(),\r\n        scrollHeight: this.getScrollHeight(),\r\n        lineNumberGutterWidth: this.getLineNumberGutterWidth(),\r\n        lineHeight: this.getLineHeight(),\r\n        renderedStartRow: this.getRenderedStartRow(),\r\n        renderedEndRow: this.getRenderedEndRow(),\r\n        rowsPerTile: this.getRowsPerTile(),\r\n        guttersToRender: this.guttersToRender,\r\n        decorationsToRender: this.decorationsToRender,\r\n        isLineNumberGutterVisible: this.props.model.isLineNumberGutterVisible(),\r\n        showLineNumbers: this.showLineNumbers,\r\n        lineNumbersToRender: this.lineNumbersToRender,\r\n        didMeasureVisibleBlockDecoration: this.didMeasureVisibleBlockDecoration\r\n      })\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollTop","start_line":2791,"end_line":2794,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollHeight","line":534,"func_location":"TextEditorComponent.renderGutterContainer","func_start_line":523,"func_end_line":548,"args":[],"code":"  renderGutterContainer () {\r\n    if (this.props.model.isMini()) {\r\n      return null\r\n    } else {\r\n      return $(GutterContainerComponent, {\r\n        ref: 'gutterContainer',\r\n        key: 'gutterContainer',\r\n        rootComponent: this,\r\n        hasInitialMeasurements: this.hasInitialMeasurements,\r\n        measuredContent: this.measuredContent,\r\n        scrollTop: this.getScrollTop(),\r\n        scrollHeight: this.getScrollHeight(),\r\n        lineNumberGutterWidth: this.getLineNumberGutterWidth(),\r\n        lineHeight: this.getLineHeight(),\r\n        renderedStartRow: this.getRenderedStartRow(),\r\n        renderedEndRow: this.getRenderedEndRow(),\r\n        rowsPerTile: this.getRowsPerTile(),\r\n        guttersToRender: this.guttersToRender,\r\n        decorationsToRender: this.decorationsToRender,\r\n        isLineNumberGutterVisible: this.props.model.isLineNumberGutterVisible(),\r\n        showLineNumbers: this.showLineNumbers,\r\n        lineNumbersToRender: this.lineNumbersToRender,\r\n        didMeasureVisibleBlockDecoration: this.didMeasureVisibleBlockDecoration\r\n      })\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollHeight","start_line":2659,"end_line":2670,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getLineNumberGutterWidth","line":535,"func_location":"TextEditorComponent.renderGutterContainer","func_start_line":523,"func_end_line":548,"args":[],"code":"  renderGutterContainer () {\r\n    if (this.props.model.isMini()) {\r\n      return null\r\n    } else {\r\n      return $(GutterContainerComponent, {\r\n        ref: 'gutterContainer',\r\n        key: 'gutterContainer',\r\n        rootComponent: this,\r\n        hasInitialMeasurements: this.hasInitialMeasurements,\r\n        measuredContent: this.measuredContent,\r\n        scrollTop: this.getScrollTop(),\r\n        scrollHeight: this.getScrollHeight(),\r\n        lineNumberGutterWidth: this.getLineNumberGutterWidth(),\r\n        lineHeight: this.getLineHeight(),\r\n        renderedStartRow: this.getRenderedStartRow(),\r\n        renderedEndRow: this.getRenderedEndRow(),\r\n        rowsPerTile: this.getRowsPerTile(),\r\n        guttersToRender: this.guttersToRender,\r\n        decorationsToRender: this.decorationsToRender,\r\n        isLineNumberGutterVisible: this.props.model.isLineNumberGutterVisible(),\r\n        showLineNumbers: this.showLineNumbers,\r\n        lineNumbersToRender: this.lineNumbersToRender,\r\n        didMeasureVisibleBlockDecoration: this.didMeasureVisibleBlockDecoration\r\n      })\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getLineNumberGutterWidth","start_line":2700,"end_line":2702,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getLineHeight","line":536,"func_location":"TextEditorComponent.renderGutterContainer","func_start_line":523,"func_end_line":548,"args":[],"code":"  renderGutterContainer () {\r\n    if (this.props.model.isMini()) {\r\n      return null\r\n    } else {\r\n      return $(GutterContainerComponent, {\r\n        ref: 'gutterContainer',\r\n        key: 'gutterContainer',\r\n        rootComponent: this,\r\n        hasInitialMeasurements: this.hasInitialMeasurements,\r\n        measuredContent: this.measuredContent,\r\n        scrollTop: this.getScrollTop(),\r\n        scrollHeight: this.getScrollHeight(),\r\n        lineNumberGutterWidth: this.getLineNumberGutterWidth(),\r\n        lineHeight: this.getLineHeight(),\r\n        renderedStartRow: this.getRenderedStartRow(),\r\n        renderedEndRow: this.getRenderedEndRow(),\r\n        rowsPerTile: this.getRowsPerTile(),\r\n        guttersToRender: this.guttersToRender,\r\n        decorationsToRender: this.decorationsToRender,\r\n        isLineNumberGutterVisible: this.props.model.isLineNumberGutterVisible(),\r\n        showLineNumbers: this.showLineNumbers,\r\n        lineNumbersToRender: this.lineNumbersToRender,\r\n        didMeasureVisibleBlockDecoration: this.didMeasureVisibleBlockDecoration\r\n      })\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getLineHeight","start_line":2600,"end_line":2602,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedStartRow","line":537,"func_location":"TextEditorComponent.renderGutterContainer","func_start_line":523,"func_end_line":548,"args":[],"code":"  renderGutterContainer () {\r\n    if (this.props.model.isMini()) {\r\n      return null\r\n    } else {\r\n      return $(GutterContainerComponent, {\r\n        ref: 'gutterContainer',\r\n        key: 'gutterContainer',\r\n        rootComponent: this,\r\n        hasInitialMeasurements: this.hasInitialMeasurements,\r\n        measuredContent: this.measuredContent,\r\n        scrollTop: this.getScrollTop(),\r\n        scrollHeight: this.getScrollHeight(),\r\n        lineNumberGutterWidth: this.getLineNumberGutterWidth(),\r\n        lineHeight: this.getLineHeight(),\r\n        renderedStartRow: this.getRenderedStartRow(),\r\n        renderedEndRow: this.getRenderedEndRow(),\r\n        rowsPerTile: this.getRowsPerTile(),\r\n        guttersToRender: this.guttersToRender,\r\n        decorationsToRender: this.decorationsToRender,\r\n        isLineNumberGutterVisible: this.props.model.isLineNumberGutterVisible(),\r\n        showLineNumbers: this.showLineNumbers,\r\n        lineNumbersToRender: this.lineNumbersToRender,\r\n        didMeasureVisibleBlockDecoration: this.didMeasureVisibleBlockDecoration\r\n      })\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedStartRow","start_line":2720,"end_line":2726,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedEndRow","line":538,"func_location":"TextEditorComponent.renderGutterContainer","func_start_line":523,"func_end_line":548,"args":[],"code":"  renderGutterContainer () {\r\n    if (this.props.model.isMini()) {\r\n      return null\r\n    } else {\r\n      return $(GutterContainerComponent, {\r\n        ref: 'gutterContainer',\r\n        key: 'gutterContainer',\r\n        rootComponent: this,\r\n        hasInitialMeasurements: this.hasInitialMeasurements,\r\n        measuredContent: this.measuredContent,\r\n        scrollTop: this.getScrollTop(),\r\n        scrollHeight: this.getScrollHeight(),\r\n        lineNumberGutterWidth: this.getLineNumberGutterWidth(),\r\n        lineHeight: this.getLineHeight(),\r\n        renderedStartRow: this.getRenderedStartRow(),\r\n        renderedEndRow: this.getRenderedEndRow(),\r\n        rowsPerTile: this.getRowsPerTile(),\r\n        guttersToRender: this.guttersToRender,\r\n        decorationsToRender: this.decorationsToRender,\r\n        isLineNumberGutterVisible: this.props.model.isLineNumberGutterVisible(),\r\n        showLineNumbers: this.showLineNumbers,\r\n        lineNumbersToRender: this.lineNumbersToRender,\r\n        didMeasureVisibleBlockDecoration: this.didMeasureVisibleBlockDecoration\r\n      })\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedEndRow","start_line":2728,"end_line":2737,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRowsPerTile","line":539,"func_location":"TextEditorComponent.renderGutterContainer","func_start_line":523,"func_end_line":548,"args":[],"code":"  renderGutterContainer () {\r\n    if (this.props.model.isMini()) {\r\n      return null\r\n    } else {\r\n      return $(GutterContainerComponent, {\r\n        ref: 'gutterContainer',\r\n        key: 'gutterContainer',\r\n        rootComponent: this,\r\n        hasInitialMeasurements: this.hasInitialMeasurements,\r\n        measuredContent: this.measuredContent,\r\n        scrollTop: this.getScrollTop(),\r\n        scrollHeight: this.getScrollHeight(),\r\n        lineNumberGutterWidth: this.getLineNumberGutterWidth(),\r\n        lineHeight: this.getLineHeight(),\r\n        renderedStartRow: this.getRenderedStartRow(),\r\n        renderedEndRow: this.getRenderedEndRow(),\r\n        rowsPerTile: this.getRowsPerTile(),\r\n        guttersToRender: this.guttersToRender,\r\n        decorationsToRender: this.decorationsToRender,\r\n        isLineNumberGutterVisible: this.props.model.isLineNumberGutterVisible(),\r\n        showLineNumbers: this.showLineNumbers,\r\n        lineNumbersToRender: this.lineNumbersToRender,\r\n        didMeasureVisibleBlockDecoration: this.didMeasureVisibleBlockDecoration\r\n      })\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRowsPerTile","start_line":2712,"end_line":2714,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollWidth","line":606,"func_location":"TextEditorComponent.renderHighlightDecorations","func_start_line":602,"func_end_line":610,"args":[],"code":"  renderHighlightDecorations () {\r\n    return $(HighlightsComponent, {\r\n      hasInitialMeasurements: this.hasInitialMeasurements,\r\n      highlightDecorations: this.decorationsToRender.highlights.slice(),\r\n      width: this.getScrollWidth(),\r\n      height: this.getScrollHeight(),\r\n      lineHeight: this.getLineHeight()\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollWidth","start_line":2672,"end_line":2682,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollHeight","line":607,"func_location":"TextEditorComponent.renderHighlightDecorations","func_start_line":602,"func_end_line":610,"args":[],"code":"  renderHighlightDecorations () {\r\n    return $(HighlightsComponent, {\r\n      hasInitialMeasurements: this.hasInitialMeasurements,\r\n      highlightDecorations: this.decorationsToRender.highlights.slice(),\r\n      width: this.getScrollWidth(),\r\n      height: this.getScrollHeight(),\r\n      lineHeight: this.getLineHeight()\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollHeight","start_line":2659,"end_line":2670,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getLineHeight","line":608,"func_location":"TextEditorComponent.renderHighlightDecorations","func_start_line":602,"func_end_line":610,"args":[],"code":"  renderHighlightDecorations () {\r\n    return $(HighlightsComponent, {\r\n      hasInitialMeasurements: this.hasInitialMeasurements,\r\n      highlightDecorations: this.decorationsToRender.highlights.slice(),\r\n      width: this.getScrollWidth(),\r\n      height: this.getScrollHeight(),\r\n      lineHeight: this.getLineHeight()\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getLineHeight","start_line":2600,"end_line":2602,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"renderHighlightDecorations","line":620,"func_location":"TextEditorComponent.renderLineTiles","func_start_line":612,"func_end_line":680,"args":[null],"code":"  renderLineTiles () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden'\r\n    }\r\n\r\n    const children = []\r\n    children.push(this.renderHighlightDecorations())\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      const {lineComponentsByScreenLineId} = this\r\n\r\n      const startRow = this.getRenderedStartRow()\r\n      const endRow = this.getRenderedEndRow()\r\n      const rowsPerTile = this.getRowsPerTile()\r\n      const tileWidth = this.getScrollWidth()\r\n\r\n      for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = this.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileHeight = this.pixelPositionBeforeBlocksForRow(tileEndRow) - this.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n\r\n        children.push($(LinesTileComponent, {\r\n          key: this.idsByTileStartRow.get(tileStartRow),\r\n          measuredContent: this.measuredContent,\r\n          height: tileHeight,\r\n          width: tileWidth,\r\n          top: this.pixelPositionBeforeBlocksForRow(tileStartRow),\r\n          lineHeight: this.getLineHeight(),\r\n          renderedStartRow: startRow,\r\n          tileStartRow,\r\n          tileEndRow,\r\n          screenLines: this.renderedScreenLines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          lineDecorations: this.decorationsToRender.lines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          textDecorations: this.decorationsToRender.text.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),\r\n          displayLayer: this.props.model.displayLayer,\r\n          nodePool: this.lineNodesPool,\r\n          lineComponentsByScreenLineId\r\n        }))\r\n      }\r\n\r\n      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {\r\n        if (screenRow < startRow || screenRow >= endRow) {\r\n          children.push($(LineComponent, {\r\n            key: 'extra-' + screenLine.id,\r\n            offScreen: true,\r\n            screenLine,\r\n            screenRow,\r\n            displayLayer: this.props.model.displayLayer,\r\n            nodePool: this.lineNodesPool,\r\n            lineComponentsByScreenLineId\r\n          }))\r\n        }\r\n      })\r\n\r\n      style.width = this.getScrollWidth() + 'px'\r\n      style.height = this.getScrollHeight() + 'px'\r\n    }\r\n\r\n    children.push(this.renderPlaceholderText())\r\n    children.push(this.renderCursorsAndInput())\r\n\r\n    return $.div(\r\n      {key: 'lineTiles', ref: 'lineTiles', className: 'lines', style},\r\n      children\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.renderHighlightDecorations","start_line":602,"end_line":610,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedStartRow","line":625,"func_location":"TextEditorComponent.renderLineTiles","func_start_line":612,"func_end_line":680,"args":[],"code":"  renderLineTiles () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden'\r\n    }\r\n\r\n    const children = []\r\n    children.push(this.renderHighlightDecorations())\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      const {lineComponentsByScreenLineId} = this\r\n\r\n      const startRow = this.getRenderedStartRow()\r\n      const endRow = this.getRenderedEndRow()\r\n      const rowsPerTile = this.getRowsPerTile()\r\n      const tileWidth = this.getScrollWidth()\r\n\r\n      for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = this.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileHeight = this.pixelPositionBeforeBlocksForRow(tileEndRow) - this.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n\r\n        children.push($(LinesTileComponent, {\r\n          key: this.idsByTileStartRow.get(tileStartRow),\r\n          measuredContent: this.measuredContent,\r\n          height: tileHeight,\r\n          width: tileWidth,\r\n          top: this.pixelPositionBeforeBlocksForRow(tileStartRow),\r\n          lineHeight: this.getLineHeight(),\r\n          renderedStartRow: startRow,\r\n          tileStartRow,\r\n          tileEndRow,\r\n          screenLines: this.renderedScreenLines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          lineDecorations: this.decorationsToRender.lines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          textDecorations: this.decorationsToRender.text.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),\r\n          displayLayer: this.props.model.displayLayer,\r\n          nodePool: this.lineNodesPool,\r\n          lineComponentsByScreenLineId\r\n        }))\r\n      }\r\n\r\n      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {\r\n        if (screenRow < startRow || screenRow >= endRow) {\r\n          children.push($(LineComponent, {\r\n            key: 'extra-' + screenLine.id,\r\n            offScreen: true,\r\n            screenLine,\r\n            screenRow,\r\n            displayLayer: this.props.model.displayLayer,\r\n            nodePool: this.lineNodesPool,\r\n            lineComponentsByScreenLineId\r\n          }))\r\n        }\r\n      })\r\n\r\n      style.width = this.getScrollWidth() + 'px'\r\n      style.height = this.getScrollHeight() + 'px'\r\n    }\r\n\r\n    children.push(this.renderPlaceholderText())\r\n    children.push(this.renderCursorsAndInput())\r\n\r\n    return $.div(\r\n      {key: 'lineTiles', ref: 'lineTiles', className: 'lines', style},\r\n      children\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedStartRow","start_line":2720,"end_line":2726,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedEndRow","line":626,"func_location":"TextEditorComponent.renderLineTiles","func_start_line":612,"func_end_line":680,"args":[],"code":"  renderLineTiles () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden'\r\n    }\r\n\r\n    const children = []\r\n    children.push(this.renderHighlightDecorations())\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      const {lineComponentsByScreenLineId} = this\r\n\r\n      const startRow = this.getRenderedStartRow()\r\n      const endRow = this.getRenderedEndRow()\r\n      const rowsPerTile = this.getRowsPerTile()\r\n      const tileWidth = this.getScrollWidth()\r\n\r\n      for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = this.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileHeight = this.pixelPositionBeforeBlocksForRow(tileEndRow) - this.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n\r\n        children.push($(LinesTileComponent, {\r\n          key: this.idsByTileStartRow.get(tileStartRow),\r\n          measuredContent: this.measuredContent,\r\n          height: tileHeight,\r\n          width: tileWidth,\r\n          top: this.pixelPositionBeforeBlocksForRow(tileStartRow),\r\n          lineHeight: this.getLineHeight(),\r\n          renderedStartRow: startRow,\r\n          tileStartRow,\r\n          tileEndRow,\r\n          screenLines: this.renderedScreenLines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          lineDecorations: this.decorationsToRender.lines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          textDecorations: this.decorationsToRender.text.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),\r\n          displayLayer: this.props.model.displayLayer,\r\n          nodePool: this.lineNodesPool,\r\n          lineComponentsByScreenLineId\r\n        }))\r\n      }\r\n\r\n      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {\r\n        if (screenRow < startRow || screenRow >= endRow) {\r\n          children.push($(LineComponent, {\r\n            key: 'extra-' + screenLine.id,\r\n            offScreen: true,\r\n            screenLine,\r\n            screenRow,\r\n            displayLayer: this.props.model.displayLayer,\r\n            nodePool: this.lineNodesPool,\r\n            lineComponentsByScreenLineId\r\n          }))\r\n        }\r\n      })\r\n\r\n      style.width = this.getScrollWidth() + 'px'\r\n      style.height = this.getScrollHeight() + 'px'\r\n    }\r\n\r\n    children.push(this.renderPlaceholderText())\r\n    children.push(this.renderCursorsAndInput())\r\n\r\n    return $.div(\r\n      {key: 'lineTiles', ref: 'lineTiles', className: 'lines', style},\r\n      children\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedEndRow","start_line":2728,"end_line":2737,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRowsPerTile","line":627,"func_location":"TextEditorComponent.renderLineTiles","func_start_line":612,"func_end_line":680,"args":[],"code":"  renderLineTiles () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden'\r\n    }\r\n\r\n    const children = []\r\n    children.push(this.renderHighlightDecorations())\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      const {lineComponentsByScreenLineId} = this\r\n\r\n      const startRow = this.getRenderedStartRow()\r\n      const endRow = this.getRenderedEndRow()\r\n      const rowsPerTile = this.getRowsPerTile()\r\n      const tileWidth = this.getScrollWidth()\r\n\r\n      for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = this.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileHeight = this.pixelPositionBeforeBlocksForRow(tileEndRow) - this.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n\r\n        children.push($(LinesTileComponent, {\r\n          key: this.idsByTileStartRow.get(tileStartRow),\r\n          measuredContent: this.measuredContent,\r\n          height: tileHeight,\r\n          width: tileWidth,\r\n          top: this.pixelPositionBeforeBlocksForRow(tileStartRow),\r\n          lineHeight: this.getLineHeight(),\r\n          renderedStartRow: startRow,\r\n          tileStartRow,\r\n          tileEndRow,\r\n          screenLines: this.renderedScreenLines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          lineDecorations: this.decorationsToRender.lines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          textDecorations: this.decorationsToRender.text.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),\r\n          displayLayer: this.props.model.displayLayer,\r\n          nodePool: this.lineNodesPool,\r\n          lineComponentsByScreenLineId\r\n        }))\r\n      }\r\n\r\n      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {\r\n        if (screenRow < startRow || screenRow >= endRow) {\r\n          children.push($(LineComponent, {\r\n            key: 'extra-' + screenLine.id,\r\n            offScreen: true,\r\n            screenLine,\r\n            screenRow,\r\n            displayLayer: this.props.model.displayLayer,\r\n            nodePool: this.lineNodesPool,\r\n            lineComponentsByScreenLineId\r\n          }))\r\n        }\r\n      })\r\n\r\n      style.width = this.getScrollWidth() + 'px'\r\n      style.height = this.getScrollHeight() + 'px'\r\n    }\r\n\r\n    children.push(this.renderPlaceholderText())\r\n    children.push(this.renderCursorsAndInput())\r\n\r\n    return $.div(\r\n      {key: 'lineTiles', ref: 'lineTiles', className: 'lines', style},\r\n      children\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRowsPerTile","start_line":2712,"end_line":2714,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollWidth","line":628,"func_location":"TextEditorComponent.renderLineTiles","func_start_line":612,"func_end_line":680,"args":[],"code":"  renderLineTiles () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden'\r\n    }\r\n\r\n    const children = []\r\n    children.push(this.renderHighlightDecorations())\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      const {lineComponentsByScreenLineId} = this\r\n\r\n      const startRow = this.getRenderedStartRow()\r\n      const endRow = this.getRenderedEndRow()\r\n      const rowsPerTile = this.getRowsPerTile()\r\n      const tileWidth = this.getScrollWidth()\r\n\r\n      for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = this.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileHeight = this.pixelPositionBeforeBlocksForRow(tileEndRow) - this.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n\r\n        children.push($(LinesTileComponent, {\r\n          key: this.idsByTileStartRow.get(tileStartRow),\r\n          measuredContent: this.measuredContent,\r\n          height: tileHeight,\r\n          width: tileWidth,\r\n          top: this.pixelPositionBeforeBlocksForRow(tileStartRow),\r\n          lineHeight: this.getLineHeight(),\r\n          renderedStartRow: startRow,\r\n          tileStartRow,\r\n          tileEndRow,\r\n          screenLines: this.renderedScreenLines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          lineDecorations: this.decorationsToRender.lines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          textDecorations: this.decorationsToRender.text.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),\r\n          displayLayer: this.props.model.displayLayer,\r\n          nodePool: this.lineNodesPool,\r\n          lineComponentsByScreenLineId\r\n        }))\r\n      }\r\n\r\n      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {\r\n        if (screenRow < startRow || screenRow >= endRow) {\r\n          children.push($(LineComponent, {\r\n            key: 'extra-' + screenLine.id,\r\n            offScreen: true,\r\n            screenLine,\r\n            screenRow,\r\n            displayLayer: this.props.model.displayLayer,\r\n            nodePool: this.lineNodesPool,\r\n            lineComponentsByScreenLineId\r\n          }))\r\n        }\r\n      })\r\n\r\n      style.width = this.getScrollWidth() + 'px'\r\n      style.height = this.getScrollHeight() + 'px'\r\n    }\r\n\r\n    children.push(this.renderPlaceholderText())\r\n    children.push(this.renderCursorsAndInput())\r\n\r\n    return $.div(\r\n      {key: 'lineTiles', ref: 'lineTiles', className: 'lines', style},\r\n      children\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollWidth","start_line":2672,"end_line":2682,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelPositionBeforeBlocksForRow","line":633,"func_location":"TextEditorComponent.renderLineTiles","func_start_line":612,"func_end_line":680,"args":["tileEndRow"],"code":"  renderLineTiles () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden'\r\n    }\r\n\r\n    const children = []\r\n    children.push(this.renderHighlightDecorations())\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      const {lineComponentsByScreenLineId} = this\r\n\r\n      const startRow = this.getRenderedStartRow()\r\n      const endRow = this.getRenderedEndRow()\r\n      const rowsPerTile = this.getRowsPerTile()\r\n      const tileWidth = this.getScrollWidth()\r\n\r\n      for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = this.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileHeight = this.pixelPositionBeforeBlocksForRow(tileEndRow) - this.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n\r\n        children.push($(LinesTileComponent, {\r\n          key: this.idsByTileStartRow.get(tileStartRow),\r\n          measuredContent: this.measuredContent,\r\n          height: tileHeight,\r\n          width: tileWidth,\r\n          top: this.pixelPositionBeforeBlocksForRow(tileStartRow),\r\n          lineHeight: this.getLineHeight(),\r\n          renderedStartRow: startRow,\r\n          tileStartRow,\r\n          tileEndRow,\r\n          screenLines: this.renderedScreenLines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          lineDecorations: this.decorationsToRender.lines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          textDecorations: this.decorationsToRender.text.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),\r\n          displayLayer: this.props.model.displayLayer,\r\n          nodePool: this.lineNodesPool,\r\n          lineComponentsByScreenLineId\r\n        }))\r\n      }\r\n\r\n      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {\r\n        if (screenRow < startRow || screenRow >= endRow) {\r\n          children.push($(LineComponent, {\r\n            key: 'extra-' + screenLine.id,\r\n            offScreen: true,\r\n            screenLine,\r\n            screenRow,\r\n            displayLayer: this.props.model.displayLayer,\r\n            nodePool: this.lineNodesPool,\r\n            lineComponentsByScreenLineId\r\n          }))\r\n        }\r\n      })\r\n\r\n      style.width = this.getScrollWidth() + 'px'\r\n      style.height = this.getScrollHeight() + 'px'\r\n    }\r\n\r\n    children.push(this.renderPlaceholderText())\r\n    children.push(this.renderCursorsAndInput())\r\n\r\n    return $.div(\r\n      {key: 'lineTiles', ref: 'lineTiles', className: 'lines', style},\r\n      children\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelPositionBeforeBlocksForRow","start_line":2360,"end_line":2362,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelPositionBeforeBlocksForRow","line":633,"func_location":"TextEditorComponent.renderLineTiles","func_start_line":612,"func_end_line":680,"args":["tileEndRow"],"code":"  renderLineTiles () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden'\r\n    }\r\n\r\n    const children = []\r\n    children.push(this.renderHighlightDecorations())\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      const {lineComponentsByScreenLineId} = this\r\n\r\n      const startRow = this.getRenderedStartRow()\r\n      const endRow = this.getRenderedEndRow()\r\n      const rowsPerTile = this.getRowsPerTile()\r\n      const tileWidth = this.getScrollWidth()\r\n\r\n      for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = this.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileHeight = this.pixelPositionBeforeBlocksForRow(tileEndRow) - this.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n\r\n        children.push($(LinesTileComponent, {\r\n          key: this.idsByTileStartRow.get(tileStartRow),\r\n          measuredContent: this.measuredContent,\r\n          height: tileHeight,\r\n          width: tileWidth,\r\n          top: this.pixelPositionBeforeBlocksForRow(tileStartRow),\r\n          lineHeight: this.getLineHeight(),\r\n          renderedStartRow: startRow,\r\n          tileStartRow,\r\n          tileEndRow,\r\n          screenLines: this.renderedScreenLines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          lineDecorations: this.decorationsToRender.lines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          textDecorations: this.decorationsToRender.text.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),\r\n          displayLayer: this.props.model.displayLayer,\r\n          nodePool: this.lineNodesPool,\r\n          lineComponentsByScreenLineId\r\n        }))\r\n      }\r\n\r\n      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {\r\n        if (screenRow < startRow || screenRow >= endRow) {\r\n          children.push($(LineComponent, {\r\n            key: 'extra-' + screenLine.id,\r\n            offScreen: true,\r\n            screenLine,\r\n            screenRow,\r\n            displayLayer: this.props.model.displayLayer,\r\n            nodePool: this.lineNodesPool,\r\n            lineComponentsByScreenLineId\r\n          }))\r\n        }\r\n      })\r\n\r\n      style.width = this.getScrollWidth() + 'px'\r\n      style.height = this.getScrollHeight() + 'px'\r\n    }\r\n\r\n    children.push(this.renderPlaceholderText())\r\n    children.push(this.renderCursorsAndInput())\r\n\r\n    return $.div(\r\n      {key: 'lineTiles', ref: 'lineTiles', className: 'lines', style},\r\n      children\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelPositionBeforeBlocksForRow","start_line":2360,"end_line":2362,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelPositionBeforeBlocksForRow","line":640,"func_location":"TextEditorComponent.renderLineTiles","func_start_line":612,"func_end_line":680,"args":["tileStartRow"],"code":"  renderLineTiles () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden'\r\n    }\r\n\r\n    const children = []\r\n    children.push(this.renderHighlightDecorations())\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      const {lineComponentsByScreenLineId} = this\r\n\r\n      const startRow = this.getRenderedStartRow()\r\n      const endRow = this.getRenderedEndRow()\r\n      const rowsPerTile = this.getRowsPerTile()\r\n      const tileWidth = this.getScrollWidth()\r\n\r\n      for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = this.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileHeight = this.pixelPositionBeforeBlocksForRow(tileEndRow) - this.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n\r\n        children.push($(LinesTileComponent, {\r\n          key: this.idsByTileStartRow.get(tileStartRow),\r\n          measuredContent: this.measuredContent,\r\n          height: tileHeight,\r\n          width: tileWidth,\r\n          top: this.pixelPositionBeforeBlocksForRow(tileStartRow),\r\n          lineHeight: this.getLineHeight(),\r\n          renderedStartRow: startRow,\r\n          tileStartRow,\r\n          tileEndRow,\r\n          screenLines: this.renderedScreenLines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          lineDecorations: this.decorationsToRender.lines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          textDecorations: this.decorationsToRender.text.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),\r\n          displayLayer: this.props.model.displayLayer,\r\n          nodePool: this.lineNodesPool,\r\n          lineComponentsByScreenLineId\r\n        }))\r\n      }\r\n\r\n      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {\r\n        if (screenRow < startRow || screenRow >= endRow) {\r\n          children.push($(LineComponent, {\r\n            key: 'extra-' + screenLine.id,\r\n            offScreen: true,\r\n            screenLine,\r\n            screenRow,\r\n            displayLayer: this.props.model.displayLayer,\r\n            nodePool: this.lineNodesPool,\r\n            lineComponentsByScreenLineId\r\n          }))\r\n        }\r\n      })\r\n\r\n      style.width = this.getScrollWidth() + 'px'\r\n      style.height = this.getScrollHeight() + 'px'\r\n    }\r\n\r\n    children.push(this.renderPlaceholderText())\r\n    children.push(this.renderCursorsAndInput())\r\n\r\n    return $.div(\r\n      {key: 'lineTiles', ref: 'lineTiles', className: 'lines', style},\r\n      children\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelPositionBeforeBlocksForRow","start_line":2360,"end_line":2362,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getLineHeight","line":641,"func_location":"TextEditorComponent.renderLineTiles","func_start_line":612,"func_end_line":680,"args":[],"code":"  renderLineTiles () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden'\r\n    }\r\n\r\n    const children = []\r\n    children.push(this.renderHighlightDecorations())\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      const {lineComponentsByScreenLineId} = this\r\n\r\n      const startRow = this.getRenderedStartRow()\r\n      const endRow = this.getRenderedEndRow()\r\n      const rowsPerTile = this.getRowsPerTile()\r\n      const tileWidth = this.getScrollWidth()\r\n\r\n      for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = this.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileHeight = this.pixelPositionBeforeBlocksForRow(tileEndRow) - this.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n\r\n        children.push($(LinesTileComponent, {\r\n          key: this.idsByTileStartRow.get(tileStartRow),\r\n          measuredContent: this.measuredContent,\r\n          height: tileHeight,\r\n          width: tileWidth,\r\n          top: this.pixelPositionBeforeBlocksForRow(tileStartRow),\r\n          lineHeight: this.getLineHeight(),\r\n          renderedStartRow: startRow,\r\n          tileStartRow,\r\n          tileEndRow,\r\n          screenLines: this.renderedScreenLines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          lineDecorations: this.decorationsToRender.lines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          textDecorations: this.decorationsToRender.text.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),\r\n          displayLayer: this.props.model.displayLayer,\r\n          nodePool: this.lineNodesPool,\r\n          lineComponentsByScreenLineId\r\n        }))\r\n      }\r\n\r\n      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {\r\n        if (screenRow < startRow || screenRow >= endRow) {\r\n          children.push($(LineComponent, {\r\n            key: 'extra-' + screenLine.id,\r\n            offScreen: true,\r\n            screenLine,\r\n            screenRow,\r\n            displayLayer: this.props.model.displayLayer,\r\n            nodePool: this.lineNodesPool,\r\n            lineComponentsByScreenLineId\r\n          }))\r\n        }\r\n      })\r\n\r\n      style.width = this.getScrollWidth() + 'px'\r\n      style.height = this.getScrollHeight() + 'px'\r\n    }\r\n\r\n    children.push(this.renderPlaceholderText())\r\n    children.push(this.renderCursorsAndInput())\r\n\r\n    return $.div(\r\n      {key: 'lineTiles', ref: 'lineTiles', className: 'lines', style},\r\n      children\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getLineHeight","start_line":2600,"end_line":2602,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollWidth","line":669,"func_location":"TextEditorComponent.renderLineTiles","func_start_line":612,"func_end_line":680,"args":[],"code":"  renderLineTiles () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden'\r\n    }\r\n\r\n    const children = []\r\n    children.push(this.renderHighlightDecorations())\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      const {lineComponentsByScreenLineId} = this\r\n\r\n      const startRow = this.getRenderedStartRow()\r\n      const endRow = this.getRenderedEndRow()\r\n      const rowsPerTile = this.getRowsPerTile()\r\n      const tileWidth = this.getScrollWidth()\r\n\r\n      for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = this.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileHeight = this.pixelPositionBeforeBlocksForRow(tileEndRow) - this.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n\r\n        children.push($(LinesTileComponent, {\r\n          key: this.idsByTileStartRow.get(tileStartRow),\r\n          measuredContent: this.measuredContent,\r\n          height: tileHeight,\r\n          width: tileWidth,\r\n          top: this.pixelPositionBeforeBlocksForRow(tileStartRow),\r\n          lineHeight: this.getLineHeight(),\r\n          renderedStartRow: startRow,\r\n          tileStartRow,\r\n          tileEndRow,\r\n          screenLines: this.renderedScreenLines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          lineDecorations: this.decorationsToRender.lines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          textDecorations: this.decorationsToRender.text.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),\r\n          displayLayer: this.props.model.displayLayer,\r\n          nodePool: this.lineNodesPool,\r\n          lineComponentsByScreenLineId\r\n        }))\r\n      }\r\n\r\n      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {\r\n        if (screenRow < startRow || screenRow >= endRow) {\r\n          children.push($(LineComponent, {\r\n            key: 'extra-' + screenLine.id,\r\n            offScreen: true,\r\n            screenLine,\r\n            screenRow,\r\n            displayLayer: this.props.model.displayLayer,\r\n            nodePool: this.lineNodesPool,\r\n            lineComponentsByScreenLineId\r\n          }))\r\n        }\r\n      })\r\n\r\n      style.width = this.getScrollWidth() + 'px'\r\n      style.height = this.getScrollHeight() + 'px'\r\n    }\r\n\r\n    children.push(this.renderPlaceholderText())\r\n    children.push(this.renderCursorsAndInput())\r\n\r\n    return $.div(\r\n      {key: 'lineTiles', ref: 'lineTiles', className: 'lines', style},\r\n      children\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollWidth","start_line":2672,"end_line":2682,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollHeight","line":670,"func_location":"TextEditorComponent.renderLineTiles","func_start_line":612,"func_end_line":680,"args":[],"code":"  renderLineTiles () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden'\r\n    }\r\n\r\n    const children = []\r\n    children.push(this.renderHighlightDecorations())\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      const {lineComponentsByScreenLineId} = this\r\n\r\n      const startRow = this.getRenderedStartRow()\r\n      const endRow = this.getRenderedEndRow()\r\n      const rowsPerTile = this.getRowsPerTile()\r\n      const tileWidth = this.getScrollWidth()\r\n\r\n      for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = this.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileHeight = this.pixelPositionBeforeBlocksForRow(tileEndRow) - this.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n\r\n        children.push($(LinesTileComponent, {\r\n          key: this.idsByTileStartRow.get(tileStartRow),\r\n          measuredContent: this.measuredContent,\r\n          height: tileHeight,\r\n          width: tileWidth,\r\n          top: this.pixelPositionBeforeBlocksForRow(tileStartRow),\r\n          lineHeight: this.getLineHeight(),\r\n          renderedStartRow: startRow,\r\n          tileStartRow,\r\n          tileEndRow,\r\n          screenLines: this.renderedScreenLines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          lineDecorations: this.decorationsToRender.lines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          textDecorations: this.decorationsToRender.text.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),\r\n          displayLayer: this.props.model.displayLayer,\r\n          nodePool: this.lineNodesPool,\r\n          lineComponentsByScreenLineId\r\n        }))\r\n      }\r\n\r\n      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {\r\n        if (screenRow < startRow || screenRow >= endRow) {\r\n          children.push($(LineComponent, {\r\n            key: 'extra-' + screenLine.id,\r\n            offScreen: true,\r\n            screenLine,\r\n            screenRow,\r\n            displayLayer: this.props.model.displayLayer,\r\n            nodePool: this.lineNodesPool,\r\n            lineComponentsByScreenLineId\r\n          }))\r\n        }\r\n      })\r\n\r\n      style.width = this.getScrollWidth() + 'px'\r\n      style.height = this.getScrollHeight() + 'px'\r\n    }\r\n\r\n    children.push(this.renderPlaceholderText())\r\n    children.push(this.renderCursorsAndInput())\r\n\r\n    return $.div(\r\n      {key: 'lineTiles', ref: 'lineTiles', className: 'lines', style},\r\n      children\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollHeight","start_line":2659,"end_line":2670,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"renderPlaceholderText","line":673,"func_location":"TextEditorComponent.renderLineTiles","func_start_line":612,"func_end_line":680,"args":[null],"code":"  renderLineTiles () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden'\r\n    }\r\n\r\n    const children = []\r\n    children.push(this.renderHighlightDecorations())\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      const {lineComponentsByScreenLineId} = this\r\n\r\n      const startRow = this.getRenderedStartRow()\r\n      const endRow = this.getRenderedEndRow()\r\n      const rowsPerTile = this.getRowsPerTile()\r\n      const tileWidth = this.getScrollWidth()\r\n\r\n      for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = this.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileHeight = this.pixelPositionBeforeBlocksForRow(tileEndRow) - this.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n\r\n        children.push($(LinesTileComponent, {\r\n          key: this.idsByTileStartRow.get(tileStartRow),\r\n          measuredContent: this.measuredContent,\r\n          height: tileHeight,\r\n          width: tileWidth,\r\n          top: this.pixelPositionBeforeBlocksForRow(tileStartRow),\r\n          lineHeight: this.getLineHeight(),\r\n          renderedStartRow: startRow,\r\n          tileStartRow,\r\n          tileEndRow,\r\n          screenLines: this.renderedScreenLines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          lineDecorations: this.decorationsToRender.lines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          textDecorations: this.decorationsToRender.text.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),\r\n          displayLayer: this.props.model.displayLayer,\r\n          nodePool: this.lineNodesPool,\r\n          lineComponentsByScreenLineId\r\n        }))\r\n      }\r\n\r\n      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {\r\n        if (screenRow < startRow || screenRow >= endRow) {\r\n          children.push($(LineComponent, {\r\n            key: 'extra-' + screenLine.id,\r\n            offScreen: true,\r\n            screenLine,\r\n            screenRow,\r\n            displayLayer: this.props.model.displayLayer,\r\n            nodePool: this.lineNodesPool,\r\n            lineComponentsByScreenLineId\r\n          }))\r\n        }\r\n      })\r\n\r\n      style.width = this.getScrollWidth() + 'px'\r\n      style.height = this.getScrollHeight() + 'px'\r\n    }\r\n\r\n    children.push(this.renderPlaceholderText())\r\n    children.push(this.renderCursorsAndInput())\r\n\r\n    return $.div(\r\n      {key: 'lineTiles', ref: 'lineTiles', className: 'lines', style},\r\n      children\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.renderPlaceholderText","start_line":707,"end_line":716,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"renderCursorsAndInput","line":674,"func_location":"TextEditorComponent.renderLineTiles","func_start_line":612,"func_end_line":680,"args":[null],"code":"  renderLineTiles () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden'\r\n    }\r\n\r\n    const children = []\r\n    children.push(this.renderHighlightDecorations())\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      const {lineComponentsByScreenLineId} = this\r\n\r\n      const startRow = this.getRenderedStartRow()\r\n      const endRow = this.getRenderedEndRow()\r\n      const rowsPerTile = this.getRowsPerTile()\r\n      const tileWidth = this.getScrollWidth()\r\n\r\n      for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = this.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileHeight = this.pixelPositionBeforeBlocksForRow(tileEndRow) - this.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n\r\n        children.push($(LinesTileComponent, {\r\n          key: this.idsByTileStartRow.get(tileStartRow),\r\n          measuredContent: this.measuredContent,\r\n          height: tileHeight,\r\n          width: tileWidth,\r\n          top: this.pixelPositionBeforeBlocksForRow(tileStartRow),\r\n          lineHeight: this.getLineHeight(),\r\n          renderedStartRow: startRow,\r\n          tileStartRow,\r\n          tileEndRow,\r\n          screenLines: this.renderedScreenLines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          lineDecorations: this.decorationsToRender.lines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          textDecorations: this.decorationsToRender.text.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),\r\n          displayLayer: this.props.model.displayLayer,\r\n          nodePool: this.lineNodesPool,\r\n          lineComponentsByScreenLineId\r\n        }))\r\n      }\r\n\r\n      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {\r\n        if (screenRow < startRow || screenRow >= endRow) {\r\n          children.push($(LineComponent, {\r\n            key: 'extra-' + screenLine.id,\r\n            offScreen: true,\r\n            screenLine,\r\n            screenRow,\r\n            displayLayer: this.props.model.displayLayer,\r\n            nodePool: this.lineNodesPool,\r\n            lineComponentsByScreenLineId\r\n          }))\r\n        }\r\n      })\r\n\r\n      style.width = this.getScrollWidth() + 'px'\r\n      style.height = this.getScrollHeight() + 'px'\r\n    }\r\n\r\n    children.push(this.renderPlaceholderText())\r\n    children.push(this.renderCursorsAndInput())\r\n\r\n    return $.div(\r\n      {key: 'lineTiles', ref: 'lineTiles', className: 'lines', style},\r\n      children\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.renderCursorsAndInput","start_line":682,"end_line":705,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getGutterContainerWidth","line":561,"func_location":"TextEditorComponent.renderScrollContainer","func_start_line":550,"func_end_line":575,"args":[],"code":"  renderScrollContainer () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      top: 0,\r\n      bottom: 0,\r\n      backgroundColor: 'inherit'\r\n    }\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      style.left = this.getGutterContainerWidth() + 'px'\r\n      style.width = this.getScrollContainerWidth() + 'px'\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'scrollContainer',\r\n        key: 'scrollContainer',\r\n        className: 'scroll-view',\r\n        style\r\n      },\r\n      this.renderContent(),\r\n      this.renderDummyScrollbars()\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getGutterContainerWidth","start_line":2696,"end_line":2698,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollContainerWidth","line":562,"func_location":"TextEditorComponent.renderScrollContainer","func_start_line":550,"func_end_line":575,"args":[],"code":"  renderScrollContainer () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      top: 0,\r\n      bottom: 0,\r\n      backgroundColor: 'inherit'\r\n    }\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      style.left = this.getGutterContainerWidth() + 'px'\r\n      style.width = this.getScrollContainerWidth() + 'px'\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'scrollContainer',\r\n        key: 'scrollContainer',\r\n        className: 'scroll-view',\r\n        style\r\n      },\r\n      this.renderContent(),\r\n      this.renderDummyScrollbars()\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollContainerWidth","start_line":2620,"end_line":2626,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"renderContent","line":572,"func_location":"TextEditorComponent.renderScrollContainer","func_start_line":550,"func_end_line":575,"args":[],"code":"  renderScrollContainer () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      top: 0,\r\n      bottom: 0,\r\n      backgroundColor: 'inherit'\r\n    }\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      style.left = this.getGutterContainerWidth() + 'px'\r\n      style.width = this.getScrollContainerWidth() + 'px'\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'scrollContainer',\r\n        key: 'scrollContainer',\r\n        className: 'scroll-view',\r\n        style\r\n      },\r\n      this.renderContent(),\r\n      this.renderDummyScrollbars()\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.renderContent","start_line":577,"end_line":600,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"renderDummyScrollbars","line":573,"func_location":"TextEditorComponent.renderScrollContainer","func_start_line":550,"func_end_line":575,"args":[],"code":"  renderScrollContainer () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      top: 0,\r\n      bottom: 0,\r\n      backgroundColor: 'inherit'\r\n    }\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      style.left = this.getGutterContainerWidth() + 'px'\r\n      style.width = this.getScrollContainerWidth() + 'px'\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'scrollContainer',\r\n        key: 'scrollContainer',\r\n        className: 'scroll-view',\r\n        style\r\n      },\r\n      this.renderContent(),\r\n      this.renderDummyScrollbars()\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.renderDummyScrollbars","start_line":746,"end_line":809,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"open","line":1299,"func_location":"Workspace.reopenItem","func_start_line":1296,"func_end_line":1303,"args":["uri"],"comment":[" Public: Asynchronously reopens the last-closed item's URI if it hasn't already been"," reopened.",""," Returns a {Promise} that is resolved when the item is opened"],"code":"  reopenItem () {\r\n    const uri = this.destroyedItemURIs.pop()\r\n    if (uri) {\r\n      return this.open(uri)\r\n    } else {\r\n      return Promise.resolve()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.open","start_line":925,"end_line":1079,"comment":["\r\n  Section: Opening\r\n  "," Essential: Opens the given URI in Atom asynchronously."," If the URI is already open, the existing item for that URI will be"," activated. If no URI is given, or no registered opener can open"," the URI, a new empty {TextEditor} will be created.",""," * `uri` (optional) A {String} containing a URI."," * `options` (optional) {Object}","   * `initialLine` A {Number} indicating which row to move the cursor to","     initially. Defaults to `0`.","   * `initialColumn` A {Number} indicating which column to move the cursor to","     initially. Defaults to `0`.","   * `split` Either 'left', 'right', 'up' or 'down'.","     If 'left', the item will be opened in leftmost pane of the current active pane's row.","     If 'right', the item will be opened in the rightmost pane of the current active pane's row. If only one pane exists in the row, a new pane will be created.","     If 'up', the item will be opened in topmost pane of the current active pane's column.","     If 'down', the item will be opened in the bottommost pane of the current active pane's column. If only one pane exists in the column, a new pane will be created.","   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on","     containing pane. Defaults to `true`.","   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}","     on containing pane. Defaults to `true`.","   * `pending` A {Boolean} indicating whether or not the item should be opened","     in a pending state. Existing pending items in a pane are replaced with","     new pending items when they are opened.","   * `searchAllPanes` A {Boolean}. If `true`, the workspace will attempt to","     activate an existing item for the given URI on any pane.","     If `false`, only the active pane will be searched for","     an existing item for the same URI. Defaults to `false`.","   * `location` (optional) A {String} containing the name of the location","     in which this item should be opened (one of \"left\", \"right\", \"bottom\",","     or \"center\"). If omitted, Atom will fall back to the last location in","     which a user has placed an item with the same URI or, if this is a new","     URI, the default location specified by the item. NOTE: This option","     should almost always be omitted to honor user preference.",""," Returns a {Promise} that resolves to the {TextEditor} for the file URI."],"params":["itemOrURI","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js","name":"createReopenProjectListView","line":29,"func_location":"ReopenProjectMenuManager.reopenProjectCommand","func_start_line":25,"func_end_line":31,"args":[],"code":"  reopenProjectCommand (e) {\r\n    if (e.detail != null && e.detail.index != null) {\r\n      this.open(this.projects[e.detail.index].paths)\r\n    } else {\r\n      this.createReopenProjectListView()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js","name":"ReopenProjectMenuManager.createReopenProjectListView","start_line":33,"end_line":43,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"setPaths","line":85,"func_location":"Project.replace","func_start_line":82,"func_end_line":99,"args":[null],"comment":[" Layers the contents of a project's file's config"," on top of the current global config."],"code":"  replace (projectSpecification) {\r\n    if (projectSpecification == null) {\r\n      atom.config.clearProjectSettings()\r\n      this.setPaths([])\r\n    } else {\r\n      if (projectSpecification.originPath == null) {\r\n        return\r\n      }\r\n\r\n      // If no path is specified, set to directory of originPath.\r\n      if (!Array.isArray(projectSpecification.paths)) {\r\n        projectSpecification.paths = [path.dirname(projectSpecification.originPath)]\r\n      }\r\n      atom.config.resetProjectSettings(projectSpecification.config, projectSpecification.originPath)\r\n      this.setPaths(projectSpecification.paths)\r\n    }\r\n    this.emitter.emit('did-replace', projectSpecification)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.setPaths","start_line":339,"end_line":371,"comment":[" Public: Set the paths of the project's directories.",""," * `projectPaths` {Array} of {String} paths."," * `options` An optional {Object} that may contain the following keys:","   * `mustExist` If `true`, throw an Error if any `projectPaths` do not exist. Any remaining `projectPaths` that","     do exist will still be added to the project. Default: `false`.","   * `exact` If `true`, only add a `projectPath` if it names an existing directory. If `false` and any `projectPath`","     is a file or does not exist, its parent directory will be added instead. Default: `false`."],"params":["projectPaths","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"setPaths","line":96,"func_location":"Project.replace","func_start_line":82,"func_end_line":99,"args":["projectSpecification.paths"],"comment":[" Layers the contents of a project's file's config"," on top of the current global config."],"code":"  replace (projectSpecification) {\r\n    if (projectSpecification == null) {\r\n      atom.config.clearProjectSettings()\r\n      this.setPaths([])\r\n    } else {\r\n      if (projectSpecification.originPath == null) {\r\n        return\r\n      }\r\n\r\n      // If no path is specified, set to directory of originPath.\r\n      if (!Array.isArray(projectSpecification.paths)) {\r\n        projectSpecification.paths = [path.dirname(projectSpecification.originPath)]\r\n      }\r\n      atom.config.resetProjectSettings(projectSpecification.config, projectSpecification.originPath)\r\n      this.setPaths(projectSpecification.paths)\r\n    }\r\n    this.emitter.emit('did-replace', projectSpecification)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.setPaths","start_line":339,"end_line":371,"comment":[" Public: Set the paths of the project's directories.",""," * `projectPaths` {Array} of {String} paths."," * `options` An optional {Object} that may contain the following keys:","   * `mustExist` If `true`, throw an Error if any `projectPaths` do not exist. Any remaining `projectPaths` that","     do exist will still be added to the project. Default: `false`.","   * `exact` If `true`, only add a `projectPath` if it names an existing directory. If `false` and any `projectPath`","     is a file or does not exist, its parent directory will be added instead. Default: `false`."],"params":["projectPaths","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"setRoot","line":143,"func_location":"PaneContainer.replaceChild","func_start_line":141,"func_end_line":144,"args":["newChild"],"code":"  replaceChild (oldChild, newChild) {\r\n    if (oldChild !== this.root) { throw new Error('Replacing non-existent child') }\r\n    this.setRoot(newChild)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.setRoot","start_line":131,"end_line":139,"comment":[],"params":["root"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js","name":"unsubscribeFromChild","line":152,"func_location":"PaneAxis.replaceChild","func_start_line":151,"func_end_line":161,"args":["oldChild"],"code":"  replaceChild (oldChild, newChild) {\r\n    this.unsubscribeFromChild(oldChild)\r\n    this.subscribeToChild(newChild)\r\n\r\n    newChild.setParent(this)\r\n    newChild.setContainer(this.container)\r\n\r\n    const index = this.children.indexOf(oldChild)\r\n    this.children.splice(index, 1, newChild)\r\n    this.emitter.emit('did-replace-child', {oldChild, newChild, index})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js","name":"PaneAxis.unsubscribeFromChild","start_line":186,"end_line":190,"comment":[],"params":["child"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js","name":"subscribeToChild","line":153,"func_location":"PaneAxis.replaceChild","func_start_line":151,"func_end_line":161,"args":["newChild"],"code":"  replaceChild (oldChild, newChild) {\r\n    this.unsubscribeFromChild(oldChild)\r\n    this.subscribeToChild(newChild)\r\n\r\n    newChild.setParent(this)\r\n    newChild.setContainer(this.container)\r\n\r\n    const index = this.children.indexOf(oldChild)\r\n    this.children.splice(index, 1, newChild)\r\n    this.emitter.emit('did-replace-child', {oldChild, newChild, index})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js","name":"PaneAxis.subscribeToChild","start_line":180,"end_line":184,"comment":[],"params":["child"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"requestLineToMeasure","line":2248,"func_location":"TextEditorComponent.requestHorizontalMeasurement","func_start_line":2243,"func_end_line":2257,"args":["row","screenLine"],"code":"  requestHorizontalMeasurement (row, column) {\r\n    if (column === 0) return\r\n\r\n    const screenLine = this.props.model.screenLineForScreenRow(row)\r\n    if (screenLine) {\r\n      this.requestLineToMeasure(row, screenLine)\r\n\r\n      let columns = this.horizontalPositionsToMeasure.get(row)\r\n      if (columns == null) {\r\n        columns = []\r\n        this.horizontalPositionsToMeasure.set(row, columns)\r\n      }\r\n      columns.push(column)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.requestLineToMeasure","start_line":2239,"end_line":2241,"comment":[],"params":["row","screenLine"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"isCompatible","line":763,"func_location":"Package.requireMainModule","func_start_line":755,"func_end_line":784,"args":[],"code":"  requireMainModule () {\r\n    if (this.bundledPackage && this.packageManager.packagesCache[this.name]) {\r\n      if (this.packageManager.packagesCache[this.name].main) {\r\n        this.mainModule = require(this.packageManager.packagesCache[this.name].main)\r\n        return this.mainModule\r\n      }\r\n    } else if (this.mainModuleRequired) {\r\n      return this.mainModule\r\n    } else if (!this.isCompatible()) {\r\n      const nativeModuleNames = this.incompatibleModules.map(m => m.name).join(', ')\r\n      console.warn(dedent `\r\n        Failed to require the main module of '${this.name}' because it requires one or more incompatible native modules (${nativeModuleNames}).\r\n        Run \\`apm rebuild\\` in the package directory and restart Atom to resolve.\\\r\n      `)\r\n    } else {\r\n      const mainModulePath = this.getMainModulePath()\r\n      if (fs.isFileSync(mainModulePath)) {\r\n        this.mainModuleRequired = true\r\n\r\n        const previousViewProviderCount = this.viewRegistry.getViewProviderCount()\r\n        const previousDeserializerCount = this.deserializerManager.getDeserializerCount()\r\n        this.mainModule = require(mainModulePath)\r\n        if ((this.viewRegistry.getViewProviderCount() === previousViewProviderCount) &&\r\n            (this.deserializerManager.getDeserializerCount() === previousDeserializerCount)) {\r\n          localStorage.setItem(this.getCanDeferMainModuleRequireStorageKey(), 'true')\r\n        }\r\n        return this.mainModule\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.isCompatible","start_line":975,"end_line":989,"comment":["\r\n  Section: Native Module Compatibility\r\n  "," Extended: Are all native modules depended on by this package correctly"," compiled against the current version of Atom?",""," Incompatible packages cannot be activated.",""," Returns a {Boolean}, true if compatible, false if incompatible."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"getMainModulePath","line":770,"func_location":"Package.requireMainModule","func_start_line":755,"func_end_line":784,"args":[],"code":"  requireMainModule () {\r\n    if (this.bundledPackage && this.packageManager.packagesCache[this.name]) {\r\n      if (this.packageManager.packagesCache[this.name].main) {\r\n        this.mainModule = require(this.packageManager.packagesCache[this.name].main)\r\n        return this.mainModule\r\n      }\r\n    } else if (this.mainModuleRequired) {\r\n      return this.mainModule\r\n    } else if (!this.isCompatible()) {\r\n      const nativeModuleNames = this.incompatibleModules.map(m => m.name).join(', ')\r\n      console.warn(dedent `\r\n        Failed to require the main module of '${this.name}' because it requires one or more incompatible native modules (${nativeModuleNames}).\r\n        Run \\`apm rebuild\\` in the package directory and restart Atom to resolve.\\\r\n      `)\r\n    } else {\r\n      const mainModulePath = this.getMainModulePath()\r\n      if (fs.isFileSync(mainModulePath)) {\r\n        this.mainModuleRequired = true\r\n\r\n        const previousViewProviderCount = this.viewRegistry.getViewProviderCount()\r\n        const previousDeserializerCount = this.deserializerManager.getDeserializerCount()\r\n        this.mainModule = require(mainModulePath)\r\n        if ((this.viewRegistry.getViewProviderCount() === previousViewProviderCount) &&\r\n            (this.deserializerManager.getDeserializerCount() === previousDeserializerCount)) {\r\n          localStorage.setItem(this.getCanDeferMainModuleRequireStorageKey(), 'true')\r\n        }\r\n        return this.mainModule\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.getMainModulePath","start_line":786,"end_line":803,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"getCanDeferMainModuleRequireStorageKey","line":779,"func_location":"Package.requireMainModule","func_start_line":755,"func_end_line":784,"args":[null,{"type":"string"}],"code":"  requireMainModule () {\r\n    if (this.bundledPackage && this.packageManager.packagesCache[this.name]) {\r\n      if (this.packageManager.packagesCache[this.name].main) {\r\n        this.mainModule = require(this.packageManager.packagesCache[this.name].main)\r\n        return this.mainModule\r\n      }\r\n    } else if (this.mainModuleRequired) {\r\n      return this.mainModule\r\n    } else if (!this.isCompatible()) {\r\n      const nativeModuleNames = this.incompatibleModules.map(m => m.name).join(', ')\r\n      console.warn(dedent `\r\n        Failed to require the main module of '${this.name}' because it requires one or more incompatible native modules (${nativeModuleNames}).\r\n        Run \\`apm rebuild\\` in the package directory and restart Atom to resolve.\\\r\n      `)\r\n    } else {\r\n      const mainModulePath = this.getMainModulePath()\r\n      if (fs.isFileSync(mainModulePath)) {\r\n        this.mainModuleRequired = true\r\n\r\n        const previousViewProviderCount = this.viewRegistry.getViewProviderCount()\r\n        const previousDeserializerCount = this.deserializerManager.getDeserializerCount()\r\n        this.mainModule = require(mainModulePath)\r\n        if ((this.viewRegistry.getViewProviderCount() === previousViewProviderCount) &&\r\n            (this.deserializerManager.getDeserializerCount() === previousDeserializerCount)) {\r\n          localStorage.setItem(this.getCanDeferMainModuleRequireStorageKey(), 'true')\r\n        }\r\n        return this.mainModule\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.getCanDeferMainModuleRequireStorageKey","start_line":1041,"end_line":1043,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"resolveStylesheet","line":168,"func_location":"ThemeManager.requireStylesheet","func_start_line":167,"func_end_line":175,"args":["stylesheetPath"],"comment":["\r\n  Section: Private\r\n  "," Resolve and apply the stylesheet specified by the path.",""," This supports both CSS and Less stylesheets.",""," * `stylesheetPath` A {String} path to the stylesheet that can be an absolute","   path or a relative path that will be resolved against the load path.",""," Returns a {Disposable} on which `.dispose()` can be called to remove the"," required stylesheet."],"code":"  requireStylesheet (stylesheetPath, priority, skipDeprecatedSelectorsTransformation) {\r\n    let fullPath = this.resolveStylesheet(stylesheetPath)\r\n    if (fullPath) {\r\n      const content = this.loadStylesheet(fullPath)\r\n      return this.applyStylesheet(fullPath, content, priority, skipDeprecatedSelectorsTransformation)\r\n    } else {\r\n      throw new Error(`Could not find a file at path '${stylesheetPath}'`)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.resolveStylesheet","start_line":233,"end_line":239,"comment":[],"params":["stylesheetPath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"loadStylesheet","line":170,"func_location":"ThemeManager.requireStylesheet","func_start_line":167,"func_end_line":175,"args":["fullPath"],"comment":["\r\n  Section: Private\r\n  "," Resolve and apply the stylesheet specified by the path.",""," This supports both CSS and Less stylesheets.",""," * `stylesheetPath` A {String} path to the stylesheet that can be an absolute","   path or a relative path that will be resolved against the load path.",""," Returns a {Disposable} on which `.dispose()` can be called to remove the"," required stylesheet."],"code":"  requireStylesheet (stylesheetPath, priority, skipDeprecatedSelectorsTransformation) {\r\n    let fullPath = this.resolveStylesheet(stylesheetPath)\r\n    if (fullPath) {\r\n      const content = this.loadStylesheet(fullPath)\r\n      return this.applyStylesheet(fullPath, content, priority, skipDeprecatedSelectorsTransformation)\r\n    } else {\r\n      throw new Error(`Could not find a file at path '${stylesheetPath}'`)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.loadStylesheet","start_line":241,"end_line":247,"comment":[],"params":["stylesheetPath","importFallbackVariables"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"applyStylesheet","line":171,"func_location":"ThemeManager.requireStylesheet","func_start_line":167,"func_end_line":175,"args":["fullPath","content","priority","skipDeprecatedSelectorsTransformation"],"comment":["\r\n  Section: Private\r\n  "," Resolve and apply the stylesheet specified by the path.",""," This supports both CSS and Less stylesheets.",""," * `stylesheetPath` A {String} path to the stylesheet that can be an absolute","   path or a relative path that will be resolved against the load path.",""," Returns a {Disposable} on which `.dispose()` can be called to remove the"," required stylesheet."],"code":"  requireStylesheet (stylesheetPath, priority, skipDeprecatedSelectorsTransformation) {\r\n    let fullPath = this.resolveStylesheet(stylesheetPath)\r\n    if (fullPath) {\r\n      const content = this.loadStylesheet(fullPath)\r\n      return this.applyStylesheet(fullPath, content, priority, skipDeprecatedSelectorsTransformation)\r\n    } else {\r\n      throw new Error(`Could not find a file at path '${stylesheetPath}'`)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js","name":"ThemeManager.applyStylesheet","start_line":306,"end_line":317,"comment":[],"params":["path","text","priority","skipDeprecatedSelectorsTransformation"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"getUserInitScriptPath","line":1299,"func_location":"AtomEnvironment.requireUserInitScript","func_start_line":1298,"func_end_line":1310,"args":[],"code":"  requireUserInitScript () {\r\n    const userInitScriptPath = this.getUserInitScriptPath()\r\n    if (userInitScriptPath) {\r\n      try {\r\n        if (fs.isFileSync(userInitScriptPath)) require(userInitScriptPath)\r\n      } catch (error) {\r\n        this.notifications.addError(`Failed to load \\`${userInitScriptPath}\\``, {\r\n          detail: error.message,\r\n          dismissable: true\r\n        })\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.getUserInitScriptPath","start_line":1293,"end_line":1296,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"createCenter","line":292,"func_location":"Workspace.reset","func_start_line":279,"func_end_line":318,"args":[],"code":"  reset (packageManager) {\r\n    this.packageManager = packageManager\r\n    this.emitter.dispose()\r\n    this.emitter = new Emitter()\r\n\r\n    this.paneContainers.center.destroy()\r\n    this.paneContainers.left.destroy()\r\n    this.paneContainers.right.destroy()\r\n    this.paneContainers.bottom.destroy()\r\n\r\n    _.values(this.panelContainers).forEach(panelContainer => { panelContainer.destroy() })\r\n\r\n    this.paneContainers = {\r\n      center: this.createCenter(),\r\n      left: this.createDock('left'),\r\n      right: this.createDock('right'),\r\n      bottom: this.createDock('bottom')\r\n    }\r\n    this.activePaneContainer = this.paneContainers.center\r\n    this.hasActiveTextEditor = false\r\n\r\n    this.panelContainers = {\r\n      top: new PanelContainer({viewRegistry: this.viewRegistry, location: 'top'}),\r\n      left: new PanelContainer({viewRegistry: this.viewRegistry, location: 'left', dock: this.paneContainers.left}),\r\n      right: new PanelContainer({viewRegistry: this.viewRegistry, location: 'right', dock: this.paneContainers.right}),\r\n      bottom: new PanelContainer({viewRegistry: this.viewRegistry, location: 'bottom', dock: this.paneContainers.bottom}),\r\n      header: new PanelContainer({viewRegistry: this.viewRegistry, location: 'header'}),\r\n      footer: new PanelContainer({viewRegistry: this.viewRegistry, location: 'footer'}),\r\n      modal: new PanelContainer({viewRegistry: this.viewRegistry, location: 'modal'})\r\n    }\r\n\r\n    this.originalFontSize = null\r\n    this.openers = []\r\n    this.destroyedItemURIs = []\r\n    if (this.element) {\r\n      this.element.destroy()\r\n      this.element = null\r\n    }\r\n    this.consumeServices(this.packageManager)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.createCenter","start_line":250,"end_line":262,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"createDock","line":293,"func_location":"Workspace.reset","func_start_line":279,"func_end_line":318,"args":[{"type":"string"}],"code":"  reset (packageManager) {\r\n    this.packageManager = packageManager\r\n    this.emitter.dispose()\r\n    this.emitter = new Emitter()\r\n\r\n    this.paneContainers.center.destroy()\r\n    this.paneContainers.left.destroy()\r\n    this.paneContainers.right.destroy()\r\n    this.paneContainers.bottom.destroy()\r\n\r\n    _.values(this.panelContainers).forEach(panelContainer => { panelContainer.destroy() })\r\n\r\n    this.paneContainers = {\r\n      center: this.createCenter(),\r\n      left: this.createDock('left'),\r\n      right: this.createDock('right'),\r\n      bottom: this.createDock('bottom')\r\n    }\r\n    this.activePaneContainer = this.paneContainers.center\r\n    this.hasActiveTextEditor = false\r\n\r\n    this.panelContainers = {\r\n      top: new PanelContainer({viewRegistry: this.viewRegistry, location: 'top'}),\r\n      left: new PanelContainer({viewRegistry: this.viewRegistry, location: 'left', dock: this.paneContainers.left}),\r\n      right: new PanelContainer({viewRegistry: this.viewRegistry, location: 'right', dock: this.paneContainers.right}),\r\n      bottom: new PanelContainer({viewRegistry: this.viewRegistry, location: 'bottom', dock: this.paneContainers.bottom}),\r\n      header: new PanelContainer({viewRegistry: this.viewRegistry, location: 'header'}),\r\n      footer: new PanelContainer({viewRegistry: this.viewRegistry, location: 'footer'}),\r\n      modal: new PanelContainer({viewRegistry: this.viewRegistry, location: 'modal'})\r\n    }\r\n\r\n    this.originalFontSize = null\r\n    this.openers = []\r\n    this.destroyedItemURIs = []\r\n    if (this.element) {\r\n      this.element.destroy()\r\n      this.element = null\r\n    }\r\n    this.consumeServices(this.packageManager)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.createDock","start_line":264,"end_line":277,"comment":[],"params":["location"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"createDock","line":294,"func_location":"Workspace.reset","func_start_line":279,"func_end_line":318,"args":[{"type":"string"}],"code":"  reset (packageManager) {\r\n    this.packageManager = packageManager\r\n    this.emitter.dispose()\r\n    this.emitter = new Emitter()\r\n\r\n    this.paneContainers.center.destroy()\r\n    this.paneContainers.left.destroy()\r\n    this.paneContainers.right.destroy()\r\n    this.paneContainers.bottom.destroy()\r\n\r\n    _.values(this.panelContainers).forEach(panelContainer => { panelContainer.destroy() })\r\n\r\n    this.paneContainers = {\r\n      center: this.createCenter(),\r\n      left: this.createDock('left'),\r\n      right: this.createDock('right'),\r\n      bottom: this.createDock('bottom')\r\n    }\r\n    this.activePaneContainer = this.paneContainers.center\r\n    this.hasActiveTextEditor = false\r\n\r\n    this.panelContainers = {\r\n      top: new PanelContainer({viewRegistry: this.viewRegistry, location: 'top'}),\r\n      left: new PanelContainer({viewRegistry: this.viewRegistry, location: 'left', dock: this.paneContainers.left}),\r\n      right: new PanelContainer({viewRegistry: this.viewRegistry, location: 'right', dock: this.paneContainers.right}),\r\n      bottom: new PanelContainer({viewRegistry: this.viewRegistry, location: 'bottom', dock: this.paneContainers.bottom}),\r\n      header: new PanelContainer({viewRegistry: this.viewRegistry, location: 'header'}),\r\n      footer: new PanelContainer({viewRegistry: this.viewRegistry, location: 'footer'}),\r\n      modal: new PanelContainer({viewRegistry: this.viewRegistry, location: 'modal'})\r\n    }\r\n\r\n    this.originalFontSize = null\r\n    this.openers = []\r\n    this.destroyedItemURIs = []\r\n    if (this.element) {\r\n      this.element.destroy()\r\n      this.element = null\r\n    }\r\n    this.consumeServices(this.packageManager)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.createDock","start_line":264,"end_line":277,"comment":[],"params":["location"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"createDock","line":295,"func_location":"Workspace.reset","func_start_line":279,"func_end_line":318,"args":[{"type":"string"}],"code":"  reset (packageManager) {\r\n    this.packageManager = packageManager\r\n    this.emitter.dispose()\r\n    this.emitter = new Emitter()\r\n\r\n    this.paneContainers.center.destroy()\r\n    this.paneContainers.left.destroy()\r\n    this.paneContainers.right.destroy()\r\n    this.paneContainers.bottom.destroy()\r\n\r\n    _.values(this.panelContainers).forEach(panelContainer => { panelContainer.destroy() })\r\n\r\n    this.paneContainers = {\r\n      center: this.createCenter(),\r\n      left: this.createDock('left'),\r\n      right: this.createDock('right'),\r\n      bottom: this.createDock('bottom')\r\n    }\r\n    this.activePaneContainer = this.paneContainers.center\r\n    this.hasActiveTextEditor = false\r\n\r\n    this.panelContainers = {\r\n      top: new PanelContainer({viewRegistry: this.viewRegistry, location: 'top'}),\r\n      left: new PanelContainer({viewRegistry: this.viewRegistry, location: 'left', dock: this.paneContainers.left}),\r\n      right: new PanelContainer({viewRegistry: this.viewRegistry, location: 'right', dock: this.paneContainers.right}),\r\n      bottom: new PanelContainer({viewRegistry: this.viewRegistry, location: 'bottom', dock: this.paneContainers.bottom}),\r\n      header: new PanelContainer({viewRegistry: this.viewRegistry, location: 'header'}),\r\n      footer: new PanelContainer({viewRegistry: this.viewRegistry, location: 'footer'}),\r\n      modal: new PanelContainer({viewRegistry: this.viewRegistry, location: 'modal'})\r\n    }\r\n\r\n    this.originalFontSize = null\r\n    this.openers = []\r\n    this.destroyedItemURIs = []\r\n    if (this.element) {\r\n      this.element.destroy()\r\n      this.element = null\r\n    }\r\n    this.consumeServices(this.packageManager)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.createDock","start_line":264,"end_line":277,"comment":[],"params":["location"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"consumeServices","line":317,"func_location":"Workspace.reset","func_start_line":279,"func_end_line":318,"args":[".packageManager"],"code":"  reset (packageManager) {\r\n    this.packageManager = packageManager\r\n    this.emitter.dispose()\r\n    this.emitter = new Emitter()\r\n\r\n    this.paneContainers.center.destroy()\r\n    this.paneContainers.left.destroy()\r\n    this.paneContainers.right.destroy()\r\n    this.paneContainers.bottom.destroy()\r\n\r\n    _.values(this.panelContainers).forEach(panelContainer => { panelContainer.destroy() })\r\n\r\n    this.paneContainers = {\r\n      center: this.createCenter(),\r\n      left: this.createDock('left'),\r\n      right: this.createDock('right'),\r\n      bottom: this.createDock('bottom')\r\n    }\r\n    this.activePaneContainer = this.paneContainers.center\r\n    this.hasActiveTextEditor = false\r\n\r\n    this.panelContainers = {\r\n      top: new PanelContainer({viewRegistry: this.viewRegistry, location: 'top'}),\r\n      left: new PanelContainer({viewRegistry: this.viewRegistry, location: 'left', dock: this.paneContainers.left}),\r\n      right: new PanelContainer({viewRegistry: this.viewRegistry, location: 'right', dock: this.paneContainers.right}),\r\n      bottom: new PanelContainer({viewRegistry: this.viewRegistry, location: 'bottom', dock: this.paneContainers.bottom}),\r\n      header: new PanelContainer({viewRegistry: this.viewRegistry, location: 'header'}),\r\n      footer: new PanelContainer({viewRegistry: this.viewRegistry, location: 'footer'}),\r\n      modal: new PanelContainer({viewRegistry: this.viewRegistry, location: 'modal'})\r\n    }\r\n\r\n    this.originalFontSize = null\r\n    this.openers = []\r\n    this.destroyedItemURIs = []\r\n    if (this.element) {\r\n      this.element.destroy()\r\n      this.element = null\r\n    }\r\n    this.consumeServices(this.packageManager)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.consumeServices","start_line":328,"end_line":335,"comment":[],"params":[["serviceHub"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"setPaths","line":67,"func_location":"Project.reset","func_start_line":56,"func_end_line":72,"args":[null],"code":"  reset (packageManager) {\r\n    this.emitter.dispose()\r\n    this.emitter = new Emitter()\r\n\r\n    this.subscriptions.dispose()\r\n    this.subscriptions = new CompositeDisposable()\r\n\r\n    for (let buffer of this.buffers) {\r\n      if (buffer != null) buffer.destroy()\r\n    }\r\n    this.buffers = []\r\n    this.setPaths([])\r\n    this.loadPromisesByPath = {}\r\n    this.retiredBufferIDs = new Set()\r\n    this.retiredBufferPaths = new Set()\r\n    this.consumeServices(packageManager)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.setPaths","start_line":339,"end_line":371,"comment":[" Public: Set the paths of the project's directories.",""," * `projectPaths` {Array} of {String} paths."," * `options` An optional {Object} that may contain the following keys:","   * `mustExist` If `true`, throw an Error if any `projectPaths` do not exist. Any remaining `projectPaths` that","     do exist will still be added to the project. Default: `false`.","   * `exact` If `true`, only add a `projectPath` if it names an existing directory. If `false` and any `projectPath`","     is a file or does not exist, its parent directory will be added instead. Default: `false`."],"params":["projectPaths","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"consumeServices","line":71,"func_location":"Project.reset","func_start_line":56,"func_end_line":72,"args":["packageManager"],"code":"  reset (packageManager) {\r\n    this.emitter.dispose()\r\n    this.emitter = new Emitter()\r\n\r\n    this.subscriptions.dispose()\r\n    this.subscriptions = new CompositeDisposable()\r\n\r\n    for (let buffer of this.buffers) {\r\n      if (buffer != null) buffer.destroy()\r\n    }\r\n    this.buffers = []\r\n    this.setPaths([])\r\n    this.loadPromisesByPath = {}\r\n    this.retiredBufferIDs = new Set()\r\n    this.retiredBufferPaths = new Set()\r\n    this.consumeServices(packageManager)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.consumeServices","start_line":594,"end_line":615,"comment":["\r\n  Section: Private\r\n  "],"params":[["serviceHub"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"registerDefaultDeserializers","line":337,"func_location":"AtomEnvironment.reset","func_start_line":335,"func_end_line":367,"args":[],"code":"  async reset () {\r\n    this.deserializers.clear()\r\n    this.registerDefaultDeserializers()\r\n\r\n    this.config.clear()\r\n    this.config.setSchema(null, {type: 'object', properties: _.clone(ConfigSchema)})\r\n\r\n    this.keymaps.clear()\r\n    this.keymaps.loadBundledKeymaps()\r\n\r\n    this.commands.clear()\r\n    this.registerDefaultCommands()\r\n\r\n    this.styles.restoreSnapshot(this.initialStyleElements)\r\n\r\n    this.menu.clear()\r\n\r\n    this.clipboard.reset()\r\n\r\n    this.notifications.clear()\r\n\r\n    this.contextMenu.clear()\r\n\r\n    await this.packages.reset()\r\n    this.workspace.reset(this.packages)\r\n    this.registerDefaultOpeners()\r\n    this.project.reset(this.packages)\r\n    this.workspace.subscribeToEvents()\r\n    this.grammars.clear()\r\n    this.textEditors.clear()\r\n    this.views.clear()\r\n    this.pathsWithWaitSessions.clear()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.registerDefaultDeserializers","start_line":294,"end_line":303,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"registerDefaultCommands","line":346,"func_location":"AtomEnvironment.reset","func_start_line":335,"func_end_line":367,"args":[],"code":"  async reset () {\r\n    this.deserializers.clear()\r\n    this.registerDefaultDeserializers()\r\n\r\n    this.config.clear()\r\n    this.config.setSchema(null, {type: 'object', properties: _.clone(ConfigSchema)})\r\n\r\n    this.keymaps.clear()\r\n    this.keymaps.loadBundledKeymaps()\r\n\r\n    this.commands.clear()\r\n    this.registerDefaultCommands()\r\n\r\n    this.styles.restoreSnapshot(this.initialStyleElements)\r\n\r\n    this.menu.clear()\r\n\r\n    this.clipboard.reset()\r\n\r\n    this.notifications.clear()\r\n\r\n    this.contextMenu.clear()\r\n\r\n    await this.packages.reset()\r\n    this.workspace.reset(this.packages)\r\n    this.registerDefaultOpeners()\r\n    this.project.reset(this.packages)\r\n    this.workspace.subscribeToEvents()\r\n    this.grammars.clear()\r\n    this.textEditors.clear()\r\n    this.views.clear()\r\n    this.pathsWithWaitSessions.clear()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.registerDefaultCommands","start_line":305,"end_line":307,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"registerDefaultOpeners","line":360,"func_location":"AtomEnvironment.reset","func_start_line":335,"func_end_line":367,"args":[],"code":"  async reset () {\r\n    this.deserializers.clear()\r\n    this.registerDefaultDeserializers()\r\n\r\n    this.config.clear()\r\n    this.config.setSchema(null, {type: 'object', properties: _.clone(ConfigSchema)})\r\n\r\n    this.keymaps.clear()\r\n    this.keymaps.loadBundledKeymaps()\r\n\r\n    this.commands.clear()\r\n    this.registerDefaultCommands()\r\n\r\n    this.styles.restoreSnapshot(this.initialStyleElements)\r\n\r\n    this.menu.clear()\r\n\r\n    this.clipboard.reset()\r\n\r\n    this.notifications.clear()\r\n\r\n    this.contextMenu.clear()\r\n\r\n    await this.packages.reset()\r\n    this.workspace.reset(this.packages)\r\n    this.registerDefaultOpeners()\r\n    this.project.reset(this.packages)\r\n    this.workspace.subscribeToEvents()\r\n    this.grammars.clear()\r\n    this.textEditors.clear()\r\n    this.views.clear()\r\n    this.pathsWithWaitSessions.clear()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.registerDefaultOpeners","start_line":309,"end_line":322,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"deactivatePackages","line":86,"func_location":"PackageManager.reset","func_start_line":84,"func_end_line":93,"args":[],"code":"  async reset () {\r\n    this.serviceHub.clear()\r\n    await this.deactivatePackages()\r\n    this.loadedPackages = {}\r\n    this.preloadedPackages = {}\r\n    this.packageStates = {}\r\n    this.packagesCache = packageJSON._atomPackages != null ? packageJSON._atomPackages : {}\r\n    this.packageDependencies = packageJSON.packageDependencies != null ? packageJSON.packageDependencies : {}\r\n    this.triggeredActivationHooks.clear()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.deactivatePackages","start_line":770,"end_line":776,"comment":[" Deactivate all packages"],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"_resetSettings","line":983,"func_location":"Config.resetProjectSettings","func_start_line":977,"func_end_line":988,"args":["newSettings",null],"code":"  resetProjectSettings (newSettings, projectFile) {\r\n    // Sets the scope and source of all project settings to `path`.\r\n    newSettings = Object.assign({}, newSettings)\r\n    const oldProjectFile = this.projectFile\r\n    this.projectFile = projectFile\r\n    if (this.projectFile != null) {\r\n      this._resetSettings(newSettings, {source: this.projectFile})\r\n    } else {\r\n      this.scopedSettingsStore.removePropertiesForSource(oldProjectFile)\r\n      this.projectSettings = {}\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config._resetSettings","start_line":940,"end_line":967,"comment":[],"params":["newSettings","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"priorityForSource","line":1217,"func_location":"Config.resetScopedSettings","func_start_line":1215,"func_end_line":1229,"args":["source"],"code":"  resetScopedSettings (newScopedSettings, options = {}) {\r\n    const source = options.source == null ? this.mainSource : options.source\r\n    const priority = this.priorityForSource(source)\r\n    this.scopedSettingsStore.removePropertiesForSource(source)\r\n\r\n    for (let scopeSelector in newScopedSettings) {\r\n      let settings = newScopedSettings[scopeSelector]\r\n      settings = this.makeValueConformToSchema(null, settings, {suppressException: true})\r\n      const validatedSettings = {}\r\n      validatedSettings[scopeSelector] = withoutEmptyObjects(settings)\r\n      if (validatedSettings[scopeSelector] != null) { this.scopedSettingsStore.addProperties(source, validatedSettings, {priority}) }\r\n    }\r\n\r\n    return this.emitChangeEvent()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.priorityForSource","start_line":1200,"end_line":1209,"comment":["\r\n  Section: Private Scoped Settings\r\n  "],"params":["source"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"makeValueConformToSchema","line":1222,"func_location":"Config.resetScopedSettings","func_start_line":1215,"func_end_line":1229,"args":[{"type":"object"},"settings",null],"code":"  resetScopedSettings (newScopedSettings, options = {}) {\r\n    const source = options.source == null ? this.mainSource : options.source\r\n    const priority = this.priorityForSource(source)\r\n    this.scopedSettingsStore.removePropertiesForSource(source)\r\n\r\n    for (let scopeSelector in newScopedSettings) {\r\n      let settings = newScopedSettings[scopeSelector]\r\n      settings = this.makeValueConformToSchema(null, settings, {suppressException: true})\r\n      const validatedSettings = {}\r\n      validatedSettings[scopeSelector] = withoutEmptyObjects(settings)\r\n      if (validatedSettings[scopeSelector] != null) { this.scopedSettingsStore.addProperties(source, validatedSettings, {priority}) }\r\n    }\r\n\r\n    return this.emitChangeEvent()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.makeValueConformToSchema","start_line":1164,"end_line":1178,"comment":[],"params":["keyPath","value","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"emitChangeEvent","line":1228,"func_location":"Config.resetScopedSettings","func_start_line":1215,"func_end_line":1229,"args":[],"code":"  resetScopedSettings (newScopedSettings, options = {}) {\r\n    const source = options.source == null ? this.mainSource : options.source\r\n    const priority = this.priorityForSource(source)\r\n    this.scopedSettingsStore.removePropertiesForSource(source)\r\n\r\n    for (let scopeSelector in newScopedSettings) {\r\n      let settings = newScopedSettings[scopeSelector]\r\n      settings = this.makeValueConformToSchema(null, settings, {suppressException: true})\r\n      const validatedSettings = {}\r\n      validatedSettings[scopeSelector] = withoutEmptyObjects(settings)\r\n      if (validatedSettings[scopeSelector] != null) { this.scopedSettingsStore.addProperties(source, validatedSettings, {priority}) }\r\n    }\r\n\r\n    return this.emitChangeEvent()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.emitChangeEvent","start_line":1211,"end_line":1213,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"transact","line":1184,"func_location":"Config.resetSettingsForSchemaChange","func_start_line":1182,"func_end_line":1194},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.transact","start_line":816,"end_line":823,"comment":[" Extended: Suppress calls to handler functions registered with {::onDidChange}"," and {::observe} for the duration of `callback`. After `callback` executes,"," handlers will be called once if the value for their key-path has changed.",""," * `callback` {Function} to execute while suppressing calls to handlers."],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"_resetSettings","line":937,"func_location":"Config.resetUserSettings","func_start_line":936,"func_end_line":938,"args":["newSettings","options"],"comment":["\r\n  Section: Private methods managing global settings\r\n  "],"code":"  resetUserSettings (newSettings, options = {}) {\r\n    this._resetSettings(newSettings, options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config._resetSettings","start_line":940,"end_line":967,"comment":[],"params":["newSettings","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js","name":"satisfies","line":224,"func_location":"resolveModulePath","func_start_line":197,"func_end_line":227,"args":["version","range"],"code":"function resolveModulePath (relativePath, parentModule) {\r\n  if (!relativePath) return\r\n  if (!(parentModule && parentModule.filename)) return\r\n\r\n  if (!nativeModules) nativeModules = process.binding('natives')\r\n  if (nativeModules.hasOwnProperty(relativePath)) return\r\n  if (relativePath[0] === '.') return\r\n  if (isAbsolute(relativePath)) return\r\n\r\n  const folderPath = path.dirname(parentModule.filename)\r\n\r\n  const range = cache.folders[folderPath] && cache.folders[folderPath][relativePath]\r\n  if (!range) {\r\n    const builtinPath = cache.builtins[relativePath]\r\n    if (builtinPath) {\r\n      return builtinPath\r\n    } else {\r\n      return\r\n    }\r\n  }\r\n\r\n  const candidates = cache.dependencies[relativePath]\r\n  if (candidates == null) return\r\n\r\n  for (let version in candidates) {\r\n    const resolvedPath = candidates[version]\r\n    if (Module._cache[resolvedPath] || isCorePath(resolvedPath)) {\r\n      if (satisfies(version, range)) return resolvedPath\r\n    }\r\n  }\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js","name":"satisfies","start_line":166,"end_line":173,"comment":[],"params":["version","rawRange"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"hasAtomEngine","line":208,"func_location":"PackageManager.resolvePackagePath","func_start_line":197,"func_end_line":213,"args":["packagePath"],"comment":["\r\n  Section: General package data\r\n  "," Public: Resolve the given package name to a path on disk.",""," * `name` - The {String} package name.",""," Return a {String} folder path or undefined if it could not be resolved."],"code":"  resolvePackagePath (name) {\r\n    if (fs.isDirectorySync(name)) {\r\n      return name\r\n    }\r\n\r\n    let packagePath = fs.resolve(...this.packageDirPaths, name)\r\n    if (fs.isDirectorySync(packagePath)) {\r\n      return packagePath\r\n    }\r\n\r\n    packagePath = path.join(this.resourcePath, 'node_modules', name)\r\n    if (this.hasAtomEngine(packagePath)) {\r\n      return packagePath\r\n    }\r\n\r\n    return null\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.hasAtomEngine","start_line":432,"end_line":435,"comment":[],"params":["packagePath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"getPaths","line":524,"func_location":"Project.resolvePath","func_start_line":514,"func_end_line":530,"args":[],"code":"  resolvePath (uri) {\r\n    if (!uri) { return }\r\n\r\n    if (uri.match(/[A-Za-z0-9+-.]+:\\/\\//)) { // leave path alone if it has a scheme\r\n      return uri\r\n    } else {\r\n      let projectPath\r\n      if (fs.isAbsolute(uri)) {\r\n        return this.defaultDirectoryProvider.normalizePath(fs.resolveHome(uri))\r\n      // TODO: what should we do here when there are multiple directories?\r\n      } else if ((projectPath = this.getPaths()[0])) {\r\n        return this.defaultDirectoryProvider.normalizePath(fs.resolveHome(path.join(projectPath, uri)))\r\n      } else {\r\n        return undefined\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.getPaths","start_line":327,"end_line":329,"comment":["\r\n  Section: Managing Paths\r\n  "," Public: Get an {Array} of {String}s containing the paths of the project's"," directories."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"resolveLegacyTestRunnerPath","line":1256,"func_location":"AtomApplication.resolveTestRunnerPath","func_start_line":1227,"func_end_line":1257,"args":[],"code":"  resolveTestRunnerPath (testPath) {\r\n    let packageRoot\r\n    if (FindParentDir == null) {\r\n      FindParentDir = require('find-parent-dir')\r\n    }\r\n\r\n    if ((packageRoot = FindParentDir.sync(testPath, 'package.json'))) {\r\n      const packageMetadata = require(path.join(packageRoot, 'package.json'))\r\n      if (packageMetadata.atomTestRunner) {\r\n        let testRunnerPath\r\n        if (Resolve == null) {\r\n          Resolve = require('resolve')\r\n        }\r\n        if (\r\n          (testRunnerPath = Resolve.sync(packageMetadata.atomTestRunner, {\r\n            basedir: packageRoot,\r\n            extensions: Object.keys(require.extensions)\r\n          }))\r\n        ) {\r\n          return testRunnerPath\r\n        } else {\r\n          process.stderr.write(\r\n            `Error: Could not resolve test runner path '${packageMetadata.atomTestRunner}'`\r\n          )\r\n          process.exit(1)\r\n        }\r\n      }\r\n    }\r\n\r\n    return this.resolveLegacyTestRunnerPath()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.resolveLegacyTestRunnerPath","start_line":1259,"end_line":1265,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js","name":"getStyleElements","line":222,"func_location":"StyleManager.restoreSnapshot","func_start_line":221,"func_end_line":234,"args":[],"code":"  restoreSnapshot (styleElementsToRestore) {\r\n    for (let styleElement of this.getStyleElements()) {\r\n      if (!styleElementsToRestore.includes(styleElement)) {\r\n        this.removeStyleElement(styleElement)\r\n      }\r\n    }\r\n\r\n    const existingStyleElements = this.getStyleElements()\r\n    for (let styleElement of styleElementsToRestore) {\r\n      if (!existingStyleElements.includes(styleElement)) {\r\n        this.addStyleElement(styleElement)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js","name":"StyleManager.getStyleElements","start_line":113,"end_line":115,"comment":["\r\n  Section: Reading Style Elements\r\n  "," Extended: Get all loaded style elements."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js","name":"removeStyleElement","line":224,"func_location":"StyleManager.restoreSnapshot","func_start_line":221,"func_end_line":234,"args":["styleElement"],"code":"  restoreSnapshot (styleElementsToRestore) {\r\n    for (let styleElement of this.getStyleElements()) {\r\n      if (!styleElementsToRestore.includes(styleElement)) {\r\n        this.removeStyleElement(styleElement)\r\n      }\r\n    }\r\n\r\n    const existingStyleElements = this.getStyleElements()\r\n    for (let styleElement of styleElementsToRestore) {\r\n      if (!existingStyleElements.includes(styleElement)) {\r\n        this.addStyleElement(styleElement)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js","name":"StyleManager.removeStyleElement","start_line":178,"end_line":187,"comment":[],"params":["styleElement"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js","name":"getStyleElements","line":228,"func_location":"StyleManager.restoreSnapshot","func_start_line":221,"func_end_line":234,"args":[],"code":"  restoreSnapshot (styleElementsToRestore) {\r\n    for (let styleElement of this.getStyleElements()) {\r\n      if (!styleElementsToRestore.includes(styleElement)) {\r\n        this.removeStyleElement(styleElement)\r\n      }\r\n    }\r\n\r\n    const existingStyleElements = this.getStyleElements()\r\n    for (let styleElement of styleElementsToRestore) {\r\n      if (!existingStyleElements.includes(styleElement)) {\r\n        this.addStyleElement(styleElement)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js","name":"StyleManager.getStyleElements","start_line":113,"end_line":115,"comment":["\r\n  Section: Reading Style Elements\r\n  "," Extended: Get all loaded style elements."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js","name":"addStyleElement","line":231,"func_location":"StyleManager.restoreSnapshot","func_start_line":221,"func_end_line":234,"args":["styleElement"],"code":"  restoreSnapshot (styleElementsToRestore) {\r\n    for (let styleElement of this.getStyleElements()) {\r\n      if (!styleElementsToRestore.includes(styleElement)) {\r\n        this.removeStyleElement(styleElement)\r\n      }\r\n    }\r\n\r\n    const existingStyleElements = this.getStyleElements()\r\n    for (let styleElement of styleElementsToRestore) {\r\n      if (!existingStyleElements.includes(styleElement)) {\r\n        this.addStyleElement(styleElement)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js","name":"StyleManager.addStyleElement","start_line":159,"end_line":176,"comment":[],"params":["styleElement"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"isFullScreen","line":1184,"func_location":"AtomEnvironment.restoreStateIntoThisEnvironment","func_start_line":1183,"func_end_line":1189,"args":[],"code":"  restoreStateIntoThisEnvironment (state) {\r\n    state.fullScreen = this.isFullScreen()\r\n    for (let pane of this.workspace.getPanes()) {\r\n      pane.destroy()\r\n    }\r\n    return this.deserialize(state)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.isFullScreen","start_line":641,"end_line":643,"comment":[" Extended: Returns a {Boolean} that is `true` if the current window is in full screen mode."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"deserialize","line":1188,"func_location":"AtomEnvironment.restoreStateIntoThisEnvironment","func_start_line":1183,"func_end_line":1189,"args":["state"],"code":"  restoreStateIntoThisEnvironment (state) {\r\n    state.fullScreen = this.isFullScreen()\r\n    for (let pane of this.workspace.getPanes()) {\r\n      pane.destroy()\r\n    }\r\n    return this.deserialize(state)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.deserialize","start_line":1223,"end_line":1277,"comment":[],"params":["state"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"isValidDimensions","line":748,"func_location":"AtomEnvironment.restoreWindowDimensions","func_start_line":747,"func_end_line":753,"args":[".windowDimensions"],"code":"  async restoreWindowDimensions () {\r\n    if (!this.windowDimensions || !this.isValidDimensions(this.windowDimensions)) {\r\n      this.windowDimensions = this.getDefaultWindowDimensions()\r\n    }\r\n    await this.setWindowDimensions(this.windowDimensions)\r\n    return this.windowDimensions\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.isValidDimensions","start_line":716,"end_line":718,"comment":[" Returns true if the dimensions are useable, false if they should be ignored."," Work around for https://github.com/atom/atom-shell/issues/473"],"params":[["x","y","width","height"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"getDefaultWindowDimensions","line":749,"func_location":"AtomEnvironment.restoreWindowDimensions","func_start_line":747,"func_end_line":753,"args":[],"code":"  async restoreWindowDimensions () {\r\n    if (!this.windowDimensions || !this.isValidDimensions(this.windowDimensions)) {\r\n      this.windowDimensions = this.getDefaultWindowDimensions()\r\n    }\r\n    await this.setWindowDimensions(this.windowDimensions)\r\n    return this.windowDimensions\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.getDefaultWindowDimensions","start_line":727,"end_line":745,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"setWindowDimensions","line":751,"func_location":"AtomEnvironment.restoreWindowDimensions","func_start_line":747,"func_end_line":753,"args":[".windowDimensions"],"code":"  async restoreWindowDimensions () {\r\n    if (!this.windowDimensions || !this.isValidDimensions(this.windowDimensions)) {\r\n      this.windowDimensions = this.getDefaultWindowDimensions()\r\n    }\r\n    await this.setWindowDimensions(this.windowDimensions)\r\n    return this.windowDimensions\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.setWindowDimensions","start_line":701,"end_line":712,"comment":[" Set the dimensions of the window.",""," The window will be centered if either the x or y coordinate is not set"," in the dimensions parameter. If x or y are omitted the window will be"," centered. If height or width are omitted only the position will be changed.",""," * `dimensions` An {Object} with the following keys:","   * `x` The new x coordinate.","   * `y` The new y coordinate.","   * `width` The new width.","   * `height` The new height."],"params":[["x","y","width","height"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"startCursorBlinking","line":1988,"func_location":"TextEditorComponent.resumeCursorBlinking","func_start_line":1986,"func_end_line":1989,"args":[],"code":"  resumeCursorBlinking () {\r\n    this.cursorsBlinkedOff = true\r\n    this.startCursorBlinking()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.startCursorBlinking","start_line":2001,"end_line":2010,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js","name":"isReleased","line":127,"func_location":"RecoveryFile.retain","func_start_line":126,"func_end_line":129,"args":[],"code":"  async retain () {\r\n    if (this.isReleased()) await this.store()\r\n    this.refCount++\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js","name":"RecoveryFile.isReleased","start_line":136,"end_line":138,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js","name":"store","line":127,"func_location":"RecoveryFile.retain","func_start_line":126,"func_end_line":129,"args":[],"code":"  async retain () {\r\n    if (this.isReleased()) await this.store()\r\n    this.refCount++\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js","name":"RecoveryFile.store","start_line":109,"end_line":111,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"markTokenizationComplete","line":259,"func_location":"TextMateLanguageMode.retokenizeLines","func_start_line":253,"func_end_line":263,"args":[],"code":"  retokenizeLines () {\r\n    if (!this.alive) return\r\n    this.fullyTokenized = false\r\n    this.tokenizedLines = new Array(this.buffer.getLineCount())\r\n    this.invalidRows = []\r\n    if (this.largeFileMode || this.grammar.name === 'Null Grammar') {\r\n      this.markTokenizationComplete()\r\n    } else {\r\n      this.invalidateRow(0)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.markTokenizationComplete","start_line":321,"end_line":326,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"invalidateRow","line":261,"func_location":"TextMateLanguageMode.retokenizeLines","func_start_line":253,"func_end_line":263,"args":[{"type":"number"}],"code":"  retokenizeLines () {\r\n    if (!this.alive) return\r\n    this.fullyTokenized = false\r\n    this.tokenizedLines = new Array(this.buffer.getLineCount())\r\n    this.invalidRows = []\r\n    if (this.largeFileMode || this.grammar.name === 'Null Grammar') {\r\n      this.markTokenizationComplete()\r\n    } else {\r\n      this.invalidateRow(0)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.invalidateRow","start_line":336,"end_line":340,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/compile-cache.js","name":"readCachedJavaScript","line":157,"func_location":"retrieveSourceMap","func_start_line":137,"func_end_line":190,"args":[null],"comment":[" Most of this logic is the same as the default implementation in the"," source-map-support module, but we've overridden it to read the javascript"," code from our cache directory."],"code":"    retrieveSourceMap: function (filePath) {\r\n      if (filePath === '<embedded>') {\r\n        return {map: snapshotSourceMapConsumer}\r\n      }\r\n\r\n      if (!cacheDirectory || !fs.isFileSync(filePath)) {\r\n        return null\r\n      }\r\n\r\n      try {\r\n        var sourceCode = fs.readFileSync(filePath, 'utf8')\r\n      } catch (error) {\r\n        console.warn('Error reading source file', error.stack)\r\n        return null\r\n      }\r\n\r\n      var compiler = COMPILERS[path.extname(filePath)]\r\n      if (!compiler) compiler = COMPILERS['.js']\r\n\r\n      try {\r\n        var fileData = readCachedJavaScript(compiler.getCachePath(sourceCode, filePath))\r\n      } catch (error) {\r\n        console.warn('Error reading compiled file', error.stack)\r\n        return null\r\n      }\r\n\r\n      if (fileData == null) {\r\n        return null\r\n      }\r\n\r\n      var match, lastMatch\r\n      INLINE_SOURCE_MAP_REGEXP.lastIndex = 0\r\n      while ((match = INLINE_SOURCE_MAP_REGEXP.exec(fileData))) {\r\n        lastMatch = match\r\n      }\r\n      if (lastMatch == null) {\r\n        return null\r\n      }\r\n\r\n      var sourceMappingURL = lastMatch[1]\r\n      var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1)\r\n\r\n      try {\r\n        var sourceMap = JSON.parse(new Buffer(rawData, 'base64'))\r\n      } catch (error) {\r\n        console.warn('Error parsing source map', error.stack)\r\n        return null\r\n      }\r\n\r\n      return {\r\n        map: sourceMap,\r\n        url: null\r\n      }\r\n    }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/compile-cache.js","name":"readCachedJavaScript","start_line":101,"end_line":109,"comment":[],"params":["relativeCachePath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container-element.js","name":"hasFocus","line":20,"func_location":"PaneContainerElement.rootChanged","func_start_line":19,"func_end_line":31,"args":[],"code":"  rootChanged (root) {\r\n    const focusedElement = this.hasFocus() ? document.activeElement : null\r\n    if (this.firstChild != null) {\r\n      this.firstChild.remove()\r\n    }\r\n    if (root != null) {\r\n      const view = this.views.getView(root)\r\n      this.appendChild(view)\r\n      if (focusedElement != null) {\r\n        focusedElement.focus()\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container-element.js","name":"PaneContainerElement.hasFocus","start_line":33,"end_line":35,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"addWindow","line":1223,"func_location":"AtomApplication.runBenchmarks","func_start_line":1181,"func_end_line":1225,"args":["window"],"code":"  runBenchmarks ({headless, test, resourcePath, executedFrom, pathsToOpen, env}) {\r\n    let windowInitializationScript\r\n    if (resourcePath !== this.resourcePath && !fs.existsSync(resourcePath)) {\r\n      ;({resourcePath} = this)\r\n    }\r\n\r\n    try {\r\n      windowInitializationScript = require.resolve(\r\n        path.resolve(this.devResourcePath, 'src', 'initialize-benchmark-window')\r\n      )\r\n    } catch (error) {\r\n      windowInitializationScript = require.resolve(\r\n        path.resolve(__dirname, '..', '..', 'src', 'initialize-benchmark-window')\r\n      )\r\n    }\r\n\r\n    const benchmarkPaths = []\r\n    if (pathsToOpen != null) {\r\n      for (let pathToOpen of pathsToOpen) {\r\n        benchmarkPaths.push(path.resolve(executedFrom, fs.normalize(pathToOpen)))\r\n      }\r\n    }\r\n\r\n    if (benchmarkPaths.length === 0) {\r\n      process.stderr.write('Error: Specify at least one benchmark path.\\n\\n')\r\n      process.exit(1)\r\n    }\r\n\r\n    const devMode = true\r\n    const isSpec = true\r\n    const safeMode = false\r\n    const window = new AtomWindow(this, this.fileRecoveryService, {\r\n      windowInitializationScript,\r\n      resourcePath,\r\n      headless,\r\n      test,\r\n      isSpec,\r\n      devMode,\r\n      benchmarkPaths,\r\n      safeMode,\r\n      env\r\n    })\r\n    this.addWindow(window)\r\n    return window\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.addWindow","start_line":299,"end_line":319,"comment":[" Public: Adds the {AtomWindow} to the global window list."],"params":["window"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"resolveLegacyTestRunnerPath","line":1156,"func_location":"AtomApplication.runTests","func_start_line":1117,"func_end_line":1179,"args":[],"comment":[" Opens up a new {AtomWindow} to run specs within.",""," options -","   :headless - A Boolean that, if true, will close the window upon","                   completion.","   :resourcePath - The path to include specs from.","   :specPath - The directory to load specs from.","   :safeMode - A Boolean that, if true, won't run specs from ~/.atom/packages","               and ~/.atom/dev/packages, defaults to false."],"code":"  runTests ({headless, resourcePath, executedFrom, pathsToOpen, logFile, safeMode, timeout, env}) {\r\n    let windowInitializationScript\r\n    if (resourcePath !== this.resourcePath && !fs.existsSync(resourcePath)) {\r\n      ;({resourcePath} = this)\r\n    }\r\n\r\n    const timeoutInSeconds = Number.parseFloat(timeout)\r\n    if (!Number.isNaN(timeoutInSeconds)) {\r\n      const timeoutHandler = function () {\r\n        console.log(\r\n          `The test suite has timed out because it has been running for more than ${timeoutInSeconds} seconds.`\r\n        )\r\n        return process.exit(124) // Use the same exit code as the UNIX timeout util.\r\n      }\r\n      setTimeout(timeoutHandler, timeoutInSeconds * 1000)\r\n    }\r\n\r\n    try {\r\n      windowInitializationScript = require.resolve(\r\n        path.resolve(this.devResourcePath, 'src', 'initialize-test-window')\r\n      )\r\n    } catch (error) {\r\n      windowInitializationScript = require.resolve(\r\n        path.resolve(__dirname, '..', '..', 'src', 'initialize-test-window')\r\n      )\r\n    }\r\n\r\n    const testPaths = []\r\n    if (pathsToOpen != null) {\r\n      for (let pathToOpen of pathsToOpen) {\r\n        testPaths.push(path.resolve(executedFrom, fs.normalize(pathToOpen)))\r\n      }\r\n    }\r\n\r\n    if (testPaths.length === 0) {\r\n      process.stderr.write('Error: Specify at least one test path\\n\\n')\r\n      process.exit(1)\r\n    }\r\n\r\n    const legacyTestRunnerPath = this.resolveLegacyTestRunnerPath()\r\n    const testRunnerPath = this.resolveTestRunnerPath(testPaths[0])\r\n    const devMode = true\r\n    const isSpec = true\r\n    if (safeMode == null) {\r\n      safeMode = false\r\n    }\r\n    const window = new AtomWindow(this, this.fileRecoveryService, {\r\n      windowInitializationScript,\r\n      resourcePath,\r\n      headless,\r\n      isSpec,\r\n      devMode,\r\n      testRunnerPath,\r\n      legacyTestRunnerPath,\r\n      testPaths,\r\n      logFile,\r\n      safeMode,\r\n      env\r\n    })\r\n    this.addWindow(window)\r\n    if (env) window.replaceEnvironment(env)\r\n    return window\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.resolveLegacyTestRunnerPath","start_line":1259,"end_line":1265,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"resolveTestRunnerPath","line":1157,"func_location":"AtomApplication.runTests","func_start_line":1117,"func_end_line":1179,"args":["testPaths."],"comment":[" Opens up a new {AtomWindow} to run specs within.",""," options -","   :headless - A Boolean that, if true, will close the window upon","                   completion.","   :resourcePath - The path to include specs from.","   :specPath - The directory to load specs from.","   :safeMode - A Boolean that, if true, won't run specs from ~/.atom/packages","               and ~/.atom/dev/packages, defaults to false."],"code":"  runTests ({headless, resourcePath, executedFrom, pathsToOpen, logFile, safeMode, timeout, env}) {\r\n    let windowInitializationScript\r\n    if (resourcePath !== this.resourcePath && !fs.existsSync(resourcePath)) {\r\n      ;({resourcePath} = this)\r\n    }\r\n\r\n    const timeoutInSeconds = Number.parseFloat(timeout)\r\n    if (!Number.isNaN(timeoutInSeconds)) {\r\n      const timeoutHandler = function () {\r\n        console.log(\r\n          `The test suite has timed out because it has been running for more than ${timeoutInSeconds} seconds.`\r\n        )\r\n        return process.exit(124) // Use the same exit code as the UNIX timeout util.\r\n      }\r\n      setTimeout(timeoutHandler, timeoutInSeconds * 1000)\r\n    }\r\n\r\n    try {\r\n      windowInitializationScript = require.resolve(\r\n        path.resolve(this.devResourcePath, 'src', 'initialize-test-window')\r\n      )\r\n    } catch (error) {\r\n      windowInitializationScript = require.resolve(\r\n        path.resolve(__dirname, '..', '..', 'src', 'initialize-test-window')\r\n      )\r\n    }\r\n\r\n    const testPaths = []\r\n    if (pathsToOpen != null) {\r\n      for (let pathToOpen of pathsToOpen) {\r\n        testPaths.push(path.resolve(executedFrom, fs.normalize(pathToOpen)))\r\n      }\r\n    }\r\n\r\n    if (testPaths.length === 0) {\r\n      process.stderr.write('Error: Specify at least one test path\\n\\n')\r\n      process.exit(1)\r\n    }\r\n\r\n    const legacyTestRunnerPath = this.resolveLegacyTestRunnerPath()\r\n    const testRunnerPath = this.resolveTestRunnerPath(testPaths[0])\r\n    const devMode = true\r\n    const isSpec = true\r\n    if (safeMode == null) {\r\n      safeMode = false\r\n    }\r\n    const window = new AtomWindow(this, this.fileRecoveryService, {\r\n      windowInitializationScript,\r\n      resourcePath,\r\n      headless,\r\n      isSpec,\r\n      devMode,\r\n      testRunnerPath,\r\n      legacyTestRunnerPath,\r\n      testPaths,\r\n      logFile,\r\n      safeMode,\r\n      env\r\n    })\r\n    this.addWindow(window)\r\n    if (env) window.replaceEnvironment(env)\r\n    return window\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.resolveTestRunnerPath","start_line":1227,"end_line":1257,"comment":[],"params":["testPath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"addWindow","line":1176,"func_location":"AtomApplication.runTests","func_start_line":1117,"func_end_line":1179,"args":["window"],"comment":[" Opens up a new {AtomWindow} to run specs within.",""," options -","   :headless - A Boolean that, if true, will close the window upon","                   completion.","   :resourcePath - The path to include specs from.","   :specPath - The directory to load specs from.","   :safeMode - A Boolean that, if true, won't run specs from ~/.atom/packages","               and ~/.atom/dev/packages, defaults to false."],"code":"  runTests ({headless, resourcePath, executedFrom, pathsToOpen, logFile, safeMode, timeout, env}) {\r\n    let windowInitializationScript\r\n    if (resourcePath !== this.resourcePath && !fs.existsSync(resourcePath)) {\r\n      ;({resourcePath} = this)\r\n    }\r\n\r\n    const timeoutInSeconds = Number.parseFloat(timeout)\r\n    if (!Number.isNaN(timeoutInSeconds)) {\r\n      const timeoutHandler = function () {\r\n        console.log(\r\n          `The test suite has timed out because it has been running for more than ${timeoutInSeconds} seconds.`\r\n        )\r\n        return process.exit(124) // Use the same exit code as the UNIX timeout util.\r\n      }\r\n      setTimeout(timeoutHandler, timeoutInSeconds * 1000)\r\n    }\r\n\r\n    try {\r\n      windowInitializationScript = require.resolve(\r\n        path.resolve(this.devResourcePath, 'src', 'initialize-test-window')\r\n      )\r\n    } catch (error) {\r\n      windowInitializationScript = require.resolve(\r\n        path.resolve(__dirname, '..', '..', 'src', 'initialize-test-window')\r\n      )\r\n    }\r\n\r\n    const testPaths = []\r\n    if (pathsToOpen != null) {\r\n      for (let pathToOpen of pathsToOpen) {\r\n        testPaths.push(path.resolve(executedFrom, fs.normalize(pathToOpen)))\r\n      }\r\n    }\r\n\r\n    if (testPaths.length === 0) {\r\n      process.stderr.write('Error: Specify at least one test path\\n\\n')\r\n      process.exit(1)\r\n    }\r\n\r\n    const legacyTestRunnerPath = this.resolveLegacyTestRunnerPath()\r\n    const testRunnerPath = this.resolveTestRunnerPath(testPaths[0])\r\n    const devMode = true\r\n    const isSpec = true\r\n    if (safeMode == null) {\r\n      safeMode = false\r\n    }\r\n    const window = new AtomWindow(this, this.fileRecoveryService, {\r\n      windowInitializationScript,\r\n      resourcePath,\r\n      headless,\r\n      isSpec,\r\n      devMode,\r\n      testRunnerPath,\r\n      legacyTestRunnerPath,\r\n      testPaths,\r\n      logFile,\r\n      safeMode,\r\n      env\r\n    })\r\n    this.addWindow(window)\r\n    if (env) window.replaceEnvironment(env)\r\n    return window\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.addWindow","start_line":299,"end_line":319,"comment":[" Public: Adds the {AtomWindow} to the global window list."],"params":["window"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js","name":"constructor","line":169,"func_location":"satisfies","func_start_line":166,"func_end_line":173},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js","name":"Range.constructor","start_line":7,"end_line":11,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"saveItem","line":852,"func_location":"Pane.saveActiveItem","func_start_line":851,"func_end_line":853,"args":[null,"nextAction"],"comment":[" Public: Save the active item."],"code":"  saveActiveItem (nextAction) {\r\n    return this.saveItem(this.getActiveItem(), nextAction)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.saveItem","start_line":875,"end_line":905,"comment":[" Public: Save the given item.",""," * `item` The item to save."," * `nextAction` (optional) {Function} which will be called with no argument","   after the item is successfully saved, or with the error if it failed.","   The return value will be that of `nextAction` or `undefined` if it was not","   provided",""," Returns a {Promise} that resolves when the save is complete"],"params":["item","nextAction"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getActiveItem","line":852,"func_location":"Pane.saveActiveItem","func_start_line":851,"func_end_line":853,"args":[null,"nextAction"],"comment":[" Public: Save the active item."],"code":"  saveActiveItem (nextAction) {\r\n    return this.saveItem(this.getActiveItem(), nextAction)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getActiveItem","start_line":432,"end_line":432,"comment":[" Public: Get the active pane item in this pane.",""," Returns a pane item."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"saveItemAs","line":863,"func_location":"Pane.saveActiveItemAs","func_start_line":862,"func_end_line":864,"args":[null,"nextAction"],"comment":[" Public: Prompt the user for a location and save the active item with the"," path they select.",""," * `nextAction` (optional) {Function} which will be called after the item is","   successfully saved.",""," Returns a {Promise} that resolves when the save is complete"],"code":"  saveActiveItemAs (nextAction) {\r\n    return this.saveItemAs(this.getActiveItem(), nextAction)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.saveItemAs","start_line":915,"end_line":954,"comment":[" Public: Prompt the user for a location and save the active item with the"," path they select.",""," * `item` The item to save."," * `nextAction` (optional) {Function} which will be called with no argument","   after the item is successfully saved, or with the error if it failed.","   The return value will be that of `nextAction` or `undefined` if it was not","   provided"],"params":["item","nextAction"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getActiveItem","line":863,"func_location":"Pane.saveActiveItemAs","func_start_line":862,"func_end_line":864,"args":[null,"nextAction"],"comment":[" Public: Prompt the user for a location and save the active item with the"," path they select.",""," * `nextAction` (optional) {Function} which will be called after the item is","   successfully saved.",""," Returns a {Promise} that resolves when the save is complete"],"code":"  saveActiveItemAs (nextAction) {\r\n    return this.saveItemAs(this.getActiveItem(), nextAction)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getActiveItem","start_line":432,"end_line":432,"comment":[" Public: Get the active pane item in this pane.",""," Returns a pane item."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getCenter","line":1397,"func_location":"Workspace.saveActivePaneItem","func_start_line":1396,"func_end_line":1398,"args":[],"comment":[" Save the active pane item.",""," If the active pane item currently has a URI according to the item's"," `.getURI` method, calls `.save` on the item. Otherwise"," {::saveActivePaneItemAs} # will be called instead. This method does nothing"," if the active item does not implement a `.save` method."],"code":"  saveActivePaneItem () {\r\n    return this.getCenter().getActivePane().saveActiveItem()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getCenter","start_line":1599,"end_line":1601,"comment":["\r\n  Section: Pane Locations\r\n  "," Essential: Get the {WorkspaceCenter} at the center of the editor window."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getCenter","line":1406,"func_location":"Workspace.saveActivePaneItemAs","func_start_line":1405,"func_end_line":1407,"args":[],"comment":[" Prompt the user for a path and save the active pane item to it.",""," Opens a native dialog where the user selects a path on disk, then calls"," `.saveAs` on the item with the selected path. This method does nothing if"," the active item does not implement a `.saveAs` method."],"code":"  saveActivePaneItemAs () {\r\n    this.getCenter().getActivePane().saveActiveItemAs()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getCenter","start_line":1599,"end_line":1601,"comment":["\r\n  Section: Pane Locations\r\n  "," Essential: Get the {WorkspaceCenter} at the center of the editor window."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"getPanes","line":175,"func_location":"PaneContainer.saveAll","func_start_line":174,"func_end_line":176,"args":[],"code":"  saveAll () {\r\n    for (let pane of this.getPanes()) { pane.saveItems() }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.getPanes","start_line":146,"end_line":152,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getPaneContainers","line":1379,"func_location":"Workspace.saveAll","func_start_line":1378,"func_end_line":1382,"args":[],"comment":[" Save all pane items."],"code":"  saveAll () {\r\n    this.getPaneContainers().forEach(container => {\r\n      container.saveAll()\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getPaneContainers","start_line":1618,"end_line":1625,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"getAllWindows","line":972,"func_location":"AtomApplication.saveCurrentWindowOptions","func_start_line":968,"func_end_line":981,"args":[],"code":"  async saveCurrentWindowOptions (allowEmpty = false) {\r\n    if (this.quitting) return\r\n\r\n    const states = []\r\n    for (let window of this.getAllWindows()) {\r\n      if (!window.isSpec) states.push({initialPaths: window.representedDirectoryPaths})\r\n    }\r\n    states.reverse()\r\n\r\n    if (states.length > 0 || allowEmpty) {\r\n      await this.storageFolder.store('application.json', states)\r\n      this.emit('application:did-save-state')\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.getAllWindows","start_line":321,"end_line":323,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"promisify","line":887,"func_location":"Pane.saveItem","func_start_line":875,"func_end_line":905,"args":[null],"comment":[" Public: Save the given item.",""," * `item` The item to save."," * `nextAction` (optional) {Function} which will be called with no argument","   after the item is successfully saved, or with the error if it failed.","   The return value will be that of `nextAction` or `undefined` if it was not","   provided",""," Returns a {Promise} that resolves when the save is complete"],"code":"  saveItem (item, nextAction) {\r\n    if (!item) return Promise.resolve()\r\n\r\n    let itemURI\r\n    if (typeof item.getURI === 'function') {\r\n      itemURI = item.getURI()\r\n    } else if (typeof item.getUri === 'function') {\r\n      itemURI = item.getUri()\r\n    }\r\n\r\n    if (itemURI != null) {\r\n      if (typeof item.save === 'function') {\r\n        return promisify(() => item.save())\r\n          .then(() => {\r\n            if (nextAction) nextAction()\r\n          })\r\n          .catch(error => {\r\n            if (nextAction) {\r\n              nextAction(error)\r\n            } else {\r\n              this.handleSaveError(error, item)\r\n            }\r\n          })\r\n      } else if (nextAction) {\r\n        nextAction()\r\n        return Promise.resolve()\r\n      }\r\n    } else {\r\n      return this.saveItemAs(item, nextAction)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"promisify","start_line":1262,"end_line":1268,"comment":[],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"saveItemAs","line":903,"func_location":"Pane.saveItem","func_start_line":875,"func_end_line":905,"args":["item","nextAction"],"comment":[" Public: Save the given item.",""," * `item` The item to save."," * `nextAction` (optional) {Function} which will be called with no argument","   after the item is successfully saved, or with the error if it failed.","   The return value will be that of `nextAction` or `undefined` if it was not","   provided",""," Returns a {Promise} that resolves when the save is complete"],"code":"  saveItem (item, nextAction) {\r\n    if (!item) return Promise.resolve()\r\n\r\n    let itemURI\r\n    if (typeof item.getURI === 'function') {\r\n      itemURI = item.getURI()\r\n    } else if (typeof item.getUri === 'function') {\r\n      itemURI = item.getUri()\r\n    }\r\n\r\n    if (itemURI != null) {\r\n      if (typeof item.save === 'function') {\r\n        return promisify(() => item.save())\r\n          .then(() => {\r\n            if (nextAction) nextAction()\r\n          })\r\n          .catch(error => {\r\n            if (nextAction) {\r\n              nextAction(error)\r\n            } else {\r\n              this.handleSaveError(error, item)\r\n            }\r\n          })\r\n      } else if (nextAction) {\r\n        nextAction()\r\n        return Promise.resolve()\r\n      }\r\n    } else {\r\n      return this.saveItemAs(item, nextAction)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.saveItemAs","start_line":915,"end_line":954,"comment":[" Public: Prompt the user for a location and save the active item with the"," path they select.",""," * `item` The item to save."," * `nextAction` (optional) {Function} which will be called with no argument","   after the item is successfully saved, or with the error if it failed.","   The return value will be that of `nextAction` or `undefined` if it was not","   provided"],"params":["item","nextAction"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"getItems","line":958,"func_location":"Pane.saveItems","func_start_line":957,"func_end_line":963,"args":[],"comment":[" Public: Save all items."],"code":"  saveItems () {\r\n    for (let item of this.getItems()) {\r\n      if (typeof item.isModified === 'function' && item.isModified()) {\r\n        this.saveItem(item)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.getItems","start_line":425,"end_line":427,"comment":["\r\n  Section: Items\r\n  "," Public: Get the items in this pane.",""," Returns an {Array} of items."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"saveItem","line":960,"func_location":"Pane.saveItems","func_start_line":957,"func_end_line":963,"args":["item"],"comment":[" Public: Save all items."],"code":"  saveItems () {\r\n    for (let item of this.getItems()) {\r\n      if (typeof item.isModified === 'function' && item.isModified()) {\r\n        this.saveItem(item)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.saveItem","start_line":875,"end_line":905,"comment":[" Public: Save the given item.",""," * `item` The item to save."," * `nextAction` (optional) {Function} which will be called with no argument","   after the item is successfully saved, or with the error if it failed.","   The return value will be that of `nextAction` or `undefined` if it was not","   provided",""," Returns a {Promise} that resolves when the save is complete"],"params":["item","nextAction"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"serialize","line":1200,"func_location":"AtomEnvironment.saveState","func_start_line":1198,"func_end_line":1208,"args":["options"],"code":"  async saveState (options, storageKey) {\r\n    if (this.enablePersistence && this.project) {\r\n      const state = this.serialize(options)\r\n      if (!storageKey) storageKey = this.getStateKey(this.project && this.project.getPaths())\r\n      if (storageKey) {\r\n        await this.stateStore.save(storageKey, state)\r\n      } else {\r\n        await this.applicationDelegate.setTemporaryWindowState(state)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.serialize","start_line":870,"end_line":880,"comment":[],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"getStateKey","line":1201,"func_location":"AtomEnvironment.saveState","func_start_line":1198,"func_end_line":1208,"args":[null],"code":"  async saveState (options, storageKey) {\r\n    if (this.enablePersistence && this.project) {\r\n      const state = this.serialize(options)\r\n      if (!storageKey) storageKey = this.getStateKey(this.project && this.project.getPaths())\r\n      if (storageKey) {\r\n        await this.stateStore.save(storageKey, state)\r\n      } else {\r\n        await this.applicationDelegate.setTemporaryWindowState(state)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.getStateKey","start_line":1279,"end_line":1286,"comment":[],"params":["paths"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateSync","line":212,"func_location":"TextEditorComponent.scheduleUpdate","func_start_line":204,"func_end_line":219,"args":[],"code":"  scheduleUpdate (nextUpdateOnlyBlinksCursors = false) {\r\n    if (!this.visible) return\r\n    if (this.suppressUpdates) return\r\n\r\n    this.nextUpdateOnlyBlinksCursors =\r\n      this.nextUpdateOnlyBlinksCursors !== false && nextUpdateOnlyBlinksCursors === true\r\n\r\n    if (this.updatedSynchronously) {\r\n      this.updateSync()\r\n    } else if (!this.updateScheduled) {\r\n      this.updateScheduled = true\r\n      etch.getScheduler().updateDocument(() => {\r\n        if (this.updateScheduled) this.updateSync(true)\r\n      })\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateSync","start_line":221,"end_line":289,"comment":[],"params":["useScheduler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"tokenizedLineForRow","line":511,"func_location":"TextMateLanguageMode.scopeDescriptorForPosition","func_start_line":507,"func_end_line":526,"args":[],"code":"  scopeDescriptorForPosition (position) {\r\n    let scopes\r\n    const {row, column} = this.buffer.clipPosition(Point.fromObject(position))\r\n\r\n    const iterator = this.tokenizedLineForRow(row).getTokenIterator()\r\n    while (iterator.next()) {\r\n      if (iterator.getBufferEnd() > column) {\r\n        scopes = iterator.getScopes()\r\n        break\r\n      }\r\n    }\r\n\r\n    // rebuild scope of last token if we iterated off the end\r\n    if (!scopes) {\r\n      scopes = iterator.getScopes()\r\n      scopes.push(...iterator.getScopeEnds().reverse())\r\n    }\r\n\r\n    return new ScopeDescriptor({scopes})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.tokenizedLineForRow","start_line":425,"end_line":449,"comment":[],"params":["bufferRow"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"buildHighlightIterator","line":496,"func_location":"TreeSitterLanguageMode.scopeDescriptorForPosition","func_start_line":486,"func_end_line":510,"args":[],"code":"  scopeDescriptorForPosition (point) {\r\n    point = this.buffer.clipPosition(Point.fromObject(point))\r\n\r\n    // If the position is the end of a line, get scope of left character instead of newline\r\n    // This is to match TextMate behaviour, see https://github.com/atom/atom/issues/18463\r\n    if (point.column > 0 && point.column === this.buffer.lineLengthForRow(point.row)) {\r\n      point = point.copy()\r\n      point.column--\r\n    }\r\n\r\n    const iterator = this.buildHighlightIterator()\r\n    const scopes = []\r\n    for (const scope of iterator.seek(point, point.row + 1)) {\r\n      scopes.push(this.grammar.scopeNameForScopeId(scope))\r\n    }\r\n    if (point.isEqual(iterator.getPosition())) {\r\n      for (const scope of iterator.getOpenScopeIds()) {\r\n        scopes.push(this.grammar.scopeNameForScopeId(scope))\r\n      }\r\n    }\r\n    if (scopes.length === 0 || scopes[0] !== this.grammar.scopeName) {\r\n      scopes.unshift(this.grammar.scopeName)\r\n    }\r\n    return new ScopeDescriptor({scopes})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"TreeSitterLanguageMode.buildHighlightIterator","start_line":141,"end_line":144,"comment":["\r\n  Section - Highlighting\r\n  "],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"screenPositionForPixelPosition","line":1962,"func_location":"TextEditorComponent.screenPositionForMouseEvent","func_start_line":1961,"func_end_line":1963,"args":[null],"code":"  screenPositionForMouseEvent (event) {\r\n    return this.screenPositionForPixelPosition(this.pixelPositionForMouseEvent(event))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.screenPositionForPixelPosition","start_line":2379,"end_line":2456,"comment":[],"params":[["top","left"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelPositionForMouseEvent","line":1962,"func_location":"TextEditorComponent.screenPositionForMouseEvent","func_start_line":1961,"func_end_line":1963,"args":[null],"code":"  screenPositionForMouseEvent (event) {\r\n    return this.screenPositionForPixelPosition(this.pixelPositionForMouseEvent(event))\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelPositionForMouseEvent","start_line":1965,"end_line":1974,"comment":[],"params":[["clientX","clientY"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"rowForPixelPosition","line":2383,"func_location":"TextEditorComponent.screenPositionForPixelPosition","func_start_line":2379,"func_end_line":2456,"args":["top"],"code":"  screenPositionForPixelPosition ({top, left}) {\r\n    const {model} = this.props\r\n\r\n    const row = Math.min(\r\n      this.rowForPixelPosition(top),\r\n      model.getApproximateScreenLineCount() - 1\r\n    )\r\n\r\n    let screenLine = this.renderedScreenLineForRow(row)\r\n    if (!screenLine) {\r\n      this.requestLineToMeasure(row, model.screenLineForScreenRow(row))\r\n      this.updateSyncBeforeMeasuringContent()\r\n      this.measureContentDuringUpdateSync()\r\n      screenLine = this.renderedScreenLineForRow(row)\r\n    }\r\n\r\n    const linesClientLeft = this.refs.lineTiles.getBoundingClientRect().left\r\n    const targetClientLeft = linesClientLeft + Math.max(0, left)\r\n    const {textNodes} = this.lineComponentsByScreenLineId.get(screenLine.id)\r\n\r\n    let containingTextNodeIndex\r\n    {\r\n      let low = 0\r\n      let high = textNodes.length - 1\r\n      while (low <= high) {\r\n        const mid = low + ((high - low) >> 1)\r\n        const textNode = textNodes[mid]\r\n        const textNodeRect = clientRectForRange(textNode, 0, textNode.length)\r\n\r\n        if (targetClientLeft < textNodeRect.left) {\r\n          high = mid - 1\r\n          containingTextNodeIndex = Math.max(0, mid - 1)\r\n        } else if (targetClientLeft > textNodeRect.right) {\r\n          low = mid + 1\r\n          containingTextNodeIndex = Math.min(textNodes.length - 1, mid + 1)\r\n        } else {\r\n          containingTextNodeIndex = mid\r\n          break\r\n        }\r\n      }\r\n    }\r\n    const containingTextNode = textNodes[containingTextNodeIndex]\r\n    let characterIndex = 0\r\n    {\r\n      let low = 0\r\n      let high = containingTextNode.length - 1\r\n      while (low <= high) {\r\n        const charIndex = low + ((high - low) >> 1)\r\n        const nextCharIndex = isPairedCharacter(containingTextNode.textContent, charIndex)\r\n          ? charIndex + 2\r\n          : charIndex + 1\r\n\r\n        const rangeRect = clientRectForRange(containingTextNode, charIndex, nextCharIndex)\r\n        if (targetClientLeft < rangeRect.left) {\r\n          high = charIndex - 1\r\n          characterIndex = Math.max(0, charIndex - 1)\r\n        } else if (targetClientLeft > rangeRect.right) {\r\n          low = nextCharIndex\r\n          characterIndex = Math.min(containingTextNode.textContent.length, nextCharIndex)\r\n        } else {\r\n          if (targetClientLeft <= ((rangeRect.left + rangeRect.right) / 2)) {\r\n            characterIndex = charIndex\r\n          } else {\r\n            characterIndex = nextCharIndex\r\n          }\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    let textNodeStartColumn = 0\r\n    for (let i = 0; i < containingTextNodeIndex; i++) {\r\n      textNodeStartColumn = textNodeStartColumn + textNodes[i].length\r\n    }\r\n    const column = textNodeStartColumn + characterIndex\r\n\r\n    return Point(row, column)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.rowForPixelPosition","start_line":2346,"end_line":2348,"comment":[],"params":["pixelPosition"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"renderedScreenLineForRow","line":2387,"func_location":"TextEditorComponent.screenPositionForPixelPosition","func_start_line":2379,"func_end_line":2456,"args":["row"],"code":"  screenPositionForPixelPosition ({top, left}) {\r\n    const {model} = this.props\r\n\r\n    const row = Math.min(\r\n      this.rowForPixelPosition(top),\r\n      model.getApproximateScreenLineCount() - 1\r\n    )\r\n\r\n    let screenLine = this.renderedScreenLineForRow(row)\r\n    if (!screenLine) {\r\n      this.requestLineToMeasure(row, model.screenLineForScreenRow(row))\r\n      this.updateSyncBeforeMeasuringContent()\r\n      this.measureContentDuringUpdateSync()\r\n      screenLine = this.renderedScreenLineForRow(row)\r\n    }\r\n\r\n    const linesClientLeft = this.refs.lineTiles.getBoundingClientRect().left\r\n    const targetClientLeft = linesClientLeft + Math.max(0, left)\r\n    const {textNodes} = this.lineComponentsByScreenLineId.get(screenLine.id)\r\n\r\n    let containingTextNodeIndex\r\n    {\r\n      let low = 0\r\n      let high = textNodes.length - 1\r\n      while (low <= high) {\r\n        const mid = low + ((high - low) >> 1)\r\n        const textNode = textNodes[mid]\r\n        const textNodeRect = clientRectForRange(textNode, 0, textNode.length)\r\n\r\n        if (targetClientLeft < textNodeRect.left) {\r\n          high = mid - 1\r\n          containingTextNodeIndex = Math.max(0, mid - 1)\r\n        } else if (targetClientLeft > textNodeRect.right) {\r\n          low = mid + 1\r\n          containingTextNodeIndex = Math.min(textNodes.length - 1, mid + 1)\r\n        } else {\r\n          containingTextNodeIndex = mid\r\n          break\r\n        }\r\n      }\r\n    }\r\n    const containingTextNode = textNodes[containingTextNodeIndex]\r\n    let characterIndex = 0\r\n    {\r\n      let low = 0\r\n      let high = containingTextNode.length - 1\r\n      while (low <= high) {\r\n        const charIndex = low + ((high - low) >> 1)\r\n        const nextCharIndex = isPairedCharacter(containingTextNode.textContent, charIndex)\r\n          ? charIndex + 2\r\n          : charIndex + 1\r\n\r\n        const rangeRect = clientRectForRange(containingTextNode, charIndex, nextCharIndex)\r\n        if (targetClientLeft < rangeRect.left) {\r\n          high = charIndex - 1\r\n          characterIndex = Math.max(0, charIndex - 1)\r\n        } else if (targetClientLeft > rangeRect.right) {\r\n          low = nextCharIndex\r\n          characterIndex = Math.min(containingTextNode.textContent.length, nextCharIndex)\r\n        } else {\r\n          if (targetClientLeft <= ((rangeRect.left + rangeRect.right) / 2)) {\r\n            characterIndex = charIndex\r\n          } else {\r\n            characterIndex = nextCharIndex\r\n          }\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    let textNodeStartColumn = 0\r\n    for (let i = 0; i < containingTextNodeIndex; i++) {\r\n      textNodeStartColumn = textNodeStartColumn + textNodes[i].length\r\n    }\r\n    const column = textNodeStartColumn + characterIndex\r\n\r\n    return Point(row, column)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.renderedScreenLineForRow","start_line":956,"end_line":961,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"requestLineToMeasure","line":2389,"func_location":"TextEditorComponent.screenPositionForPixelPosition","func_start_line":2379,"func_end_line":2456,"args":["row",null],"code":"  screenPositionForPixelPosition ({top, left}) {\r\n    const {model} = this.props\r\n\r\n    const row = Math.min(\r\n      this.rowForPixelPosition(top),\r\n      model.getApproximateScreenLineCount() - 1\r\n    )\r\n\r\n    let screenLine = this.renderedScreenLineForRow(row)\r\n    if (!screenLine) {\r\n      this.requestLineToMeasure(row, model.screenLineForScreenRow(row))\r\n      this.updateSyncBeforeMeasuringContent()\r\n      this.measureContentDuringUpdateSync()\r\n      screenLine = this.renderedScreenLineForRow(row)\r\n    }\r\n\r\n    const linesClientLeft = this.refs.lineTiles.getBoundingClientRect().left\r\n    const targetClientLeft = linesClientLeft + Math.max(0, left)\r\n    const {textNodes} = this.lineComponentsByScreenLineId.get(screenLine.id)\r\n\r\n    let containingTextNodeIndex\r\n    {\r\n      let low = 0\r\n      let high = textNodes.length - 1\r\n      while (low <= high) {\r\n        const mid = low + ((high - low) >> 1)\r\n        const textNode = textNodes[mid]\r\n        const textNodeRect = clientRectForRange(textNode, 0, textNode.length)\r\n\r\n        if (targetClientLeft < textNodeRect.left) {\r\n          high = mid - 1\r\n          containingTextNodeIndex = Math.max(0, mid - 1)\r\n        } else if (targetClientLeft > textNodeRect.right) {\r\n          low = mid + 1\r\n          containingTextNodeIndex = Math.min(textNodes.length - 1, mid + 1)\r\n        } else {\r\n          containingTextNodeIndex = mid\r\n          break\r\n        }\r\n      }\r\n    }\r\n    const containingTextNode = textNodes[containingTextNodeIndex]\r\n    let characterIndex = 0\r\n    {\r\n      let low = 0\r\n      let high = containingTextNode.length - 1\r\n      while (low <= high) {\r\n        const charIndex = low + ((high - low) >> 1)\r\n        const nextCharIndex = isPairedCharacter(containingTextNode.textContent, charIndex)\r\n          ? charIndex + 2\r\n          : charIndex + 1\r\n\r\n        const rangeRect = clientRectForRange(containingTextNode, charIndex, nextCharIndex)\r\n        if (targetClientLeft < rangeRect.left) {\r\n          high = charIndex - 1\r\n          characterIndex = Math.max(0, charIndex - 1)\r\n        } else if (targetClientLeft > rangeRect.right) {\r\n          low = nextCharIndex\r\n          characterIndex = Math.min(containingTextNode.textContent.length, nextCharIndex)\r\n        } else {\r\n          if (targetClientLeft <= ((rangeRect.left + rangeRect.right) / 2)) {\r\n            characterIndex = charIndex\r\n          } else {\r\n            characterIndex = nextCharIndex\r\n          }\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    let textNodeStartColumn = 0\r\n    for (let i = 0; i < containingTextNodeIndex; i++) {\r\n      textNodeStartColumn = textNodeStartColumn + textNodes[i].length\r\n    }\r\n    const column = textNodeStartColumn + characterIndex\r\n\r\n    return Point(row, column)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.requestLineToMeasure","start_line":2239,"end_line":2241,"comment":[],"params":["row","screenLine"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateSyncBeforeMeasuringContent","line":2390,"func_location":"TextEditorComponent.screenPositionForPixelPosition","func_start_line":2379,"func_end_line":2456,"args":[],"code":"  screenPositionForPixelPosition ({top, left}) {\r\n    const {model} = this.props\r\n\r\n    const row = Math.min(\r\n      this.rowForPixelPosition(top),\r\n      model.getApproximateScreenLineCount() - 1\r\n    )\r\n\r\n    let screenLine = this.renderedScreenLineForRow(row)\r\n    if (!screenLine) {\r\n      this.requestLineToMeasure(row, model.screenLineForScreenRow(row))\r\n      this.updateSyncBeforeMeasuringContent()\r\n      this.measureContentDuringUpdateSync()\r\n      screenLine = this.renderedScreenLineForRow(row)\r\n    }\r\n\r\n    const linesClientLeft = this.refs.lineTiles.getBoundingClientRect().left\r\n    const targetClientLeft = linesClientLeft + Math.max(0, left)\r\n    const {textNodes} = this.lineComponentsByScreenLineId.get(screenLine.id)\r\n\r\n    let containingTextNodeIndex\r\n    {\r\n      let low = 0\r\n      let high = textNodes.length - 1\r\n      while (low <= high) {\r\n        const mid = low + ((high - low) >> 1)\r\n        const textNode = textNodes[mid]\r\n        const textNodeRect = clientRectForRange(textNode, 0, textNode.length)\r\n\r\n        if (targetClientLeft < textNodeRect.left) {\r\n          high = mid - 1\r\n          containingTextNodeIndex = Math.max(0, mid - 1)\r\n        } else if (targetClientLeft > textNodeRect.right) {\r\n          low = mid + 1\r\n          containingTextNodeIndex = Math.min(textNodes.length - 1, mid + 1)\r\n        } else {\r\n          containingTextNodeIndex = mid\r\n          break\r\n        }\r\n      }\r\n    }\r\n    const containingTextNode = textNodes[containingTextNodeIndex]\r\n    let characterIndex = 0\r\n    {\r\n      let low = 0\r\n      let high = containingTextNode.length - 1\r\n      while (low <= high) {\r\n        const charIndex = low + ((high - low) >> 1)\r\n        const nextCharIndex = isPairedCharacter(containingTextNode.textContent, charIndex)\r\n          ? charIndex + 2\r\n          : charIndex + 1\r\n\r\n        const rangeRect = clientRectForRange(containingTextNode, charIndex, nextCharIndex)\r\n        if (targetClientLeft < rangeRect.left) {\r\n          high = charIndex - 1\r\n          characterIndex = Math.max(0, charIndex - 1)\r\n        } else if (targetClientLeft > rangeRect.right) {\r\n          low = nextCharIndex\r\n          characterIndex = Math.min(containingTextNode.textContent.length, nextCharIndex)\r\n        } else {\r\n          if (targetClientLeft <= ((rangeRect.left + rangeRect.right) / 2)) {\r\n            characterIndex = charIndex\r\n          } else {\r\n            characterIndex = nextCharIndex\r\n          }\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    let textNodeStartColumn = 0\r\n    for (let i = 0; i < containingTextNodeIndex; i++) {\r\n      textNodeStartColumn = textNodeStartColumn + textNodes[i].length\r\n    }\r\n    const column = textNodeStartColumn + characterIndex\r\n\r\n    return Point(row, column)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateSyncBeforeMeasuringContent","start_line":364,"end_line":387,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"measureContentDuringUpdateSync","line":2391,"func_location":"TextEditorComponent.screenPositionForPixelPosition","func_start_line":2379,"func_end_line":2456,"args":[],"code":"  screenPositionForPixelPosition ({top, left}) {\r\n    const {model} = this.props\r\n\r\n    const row = Math.min(\r\n      this.rowForPixelPosition(top),\r\n      model.getApproximateScreenLineCount() - 1\r\n    )\r\n\r\n    let screenLine = this.renderedScreenLineForRow(row)\r\n    if (!screenLine) {\r\n      this.requestLineToMeasure(row, model.screenLineForScreenRow(row))\r\n      this.updateSyncBeforeMeasuringContent()\r\n      this.measureContentDuringUpdateSync()\r\n      screenLine = this.renderedScreenLineForRow(row)\r\n    }\r\n\r\n    const linesClientLeft = this.refs.lineTiles.getBoundingClientRect().left\r\n    const targetClientLeft = linesClientLeft + Math.max(0, left)\r\n    const {textNodes} = this.lineComponentsByScreenLineId.get(screenLine.id)\r\n\r\n    let containingTextNodeIndex\r\n    {\r\n      let low = 0\r\n      let high = textNodes.length - 1\r\n      while (low <= high) {\r\n        const mid = low + ((high - low) >> 1)\r\n        const textNode = textNodes[mid]\r\n        const textNodeRect = clientRectForRange(textNode, 0, textNode.length)\r\n\r\n        if (targetClientLeft < textNodeRect.left) {\r\n          high = mid - 1\r\n          containingTextNodeIndex = Math.max(0, mid - 1)\r\n        } else if (targetClientLeft > textNodeRect.right) {\r\n          low = mid + 1\r\n          containingTextNodeIndex = Math.min(textNodes.length - 1, mid + 1)\r\n        } else {\r\n          containingTextNodeIndex = mid\r\n          break\r\n        }\r\n      }\r\n    }\r\n    const containingTextNode = textNodes[containingTextNodeIndex]\r\n    let characterIndex = 0\r\n    {\r\n      let low = 0\r\n      let high = containingTextNode.length - 1\r\n      while (low <= high) {\r\n        const charIndex = low + ((high - low) >> 1)\r\n        const nextCharIndex = isPairedCharacter(containingTextNode.textContent, charIndex)\r\n          ? charIndex + 2\r\n          : charIndex + 1\r\n\r\n        const rangeRect = clientRectForRange(containingTextNode, charIndex, nextCharIndex)\r\n        if (targetClientLeft < rangeRect.left) {\r\n          high = charIndex - 1\r\n          characterIndex = Math.max(0, charIndex - 1)\r\n        } else if (targetClientLeft > rangeRect.right) {\r\n          low = nextCharIndex\r\n          characterIndex = Math.min(containingTextNode.textContent.length, nextCharIndex)\r\n        } else {\r\n          if (targetClientLeft <= ((rangeRect.left + rangeRect.right) / 2)) {\r\n            characterIndex = charIndex\r\n          } else {\r\n            characterIndex = nextCharIndex\r\n          }\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    let textNodeStartColumn = 0\r\n    for (let i = 0; i < containingTextNodeIndex; i++) {\r\n      textNodeStartColumn = textNodeStartColumn + textNodes[i].length\r\n    }\r\n    const column = textNodeStartColumn + characterIndex\r\n\r\n    return Point(row, column)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.measureContentDuringUpdateSync","start_line":389,"end_line":424,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"renderedScreenLineForRow","line":2392,"func_location":"TextEditorComponent.screenPositionForPixelPosition","func_start_line":2379,"func_end_line":2456,"args":["row"],"code":"  screenPositionForPixelPosition ({top, left}) {\r\n    const {model} = this.props\r\n\r\n    const row = Math.min(\r\n      this.rowForPixelPosition(top),\r\n      model.getApproximateScreenLineCount() - 1\r\n    )\r\n\r\n    let screenLine = this.renderedScreenLineForRow(row)\r\n    if (!screenLine) {\r\n      this.requestLineToMeasure(row, model.screenLineForScreenRow(row))\r\n      this.updateSyncBeforeMeasuringContent()\r\n      this.measureContentDuringUpdateSync()\r\n      screenLine = this.renderedScreenLineForRow(row)\r\n    }\r\n\r\n    const linesClientLeft = this.refs.lineTiles.getBoundingClientRect().left\r\n    const targetClientLeft = linesClientLeft + Math.max(0, left)\r\n    const {textNodes} = this.lineComponentsByScreenLineId.get(screenLine.id)\r\n\r\n    let containingTextNodeIndex\r\n    {\r\n      let low = 0\r\n      let high = textNodes.length - 1\r\n      while (low <= high) {\r\n        const mid = low + ((high - low) >> 1)\r\n        const textNode = textNodes[mid]\r\n        const textNodeRect = clientRectForRange(textNode, 0, textNode.length)\r\n\r\n        if (targetClientLeft < textNodeRect.left) {\r\n          high = mid - 1\r\n          containingTextNodeIndex = Math.max(0, mid - 1)\r\n        } else if (targetClientLeft > textNodeRect.right) {\r\n          low = mid + 1\r\n          containingTextNodeIndex = Math.min(textNodes.length - 1, mid + 1)\r\n        } else {\r\n          containingTextNodeIndex = mid\r\n          break\r\n        }\r\n      }\r\n    }\r\n    const containingTextNode = textNodes[containingTextNodeIndex]\r\n    let characterIndex = 0\r\n    {\r\n      let low = 0\r\n      let high = containingTextNode.length - 1\r\n      while (low <= high) {\r\n        const charIndex = low + ((high - low) >> 1)\r\n        const nextCharIndex = isPairedCharacter(containingTextNode.textContent, charIndex)\r\n          ? charIndex + 2\r\n          : charIndex + 1\r\n\r\n        const rangeRect = clientRectForRange(containingTextNode, charIndex, nextCharIndex)\r\n        if (targetClientLeft < rangeRect.left) {\r\n          high = charIndex - 1\r\n          characterIndex = Math.max(0, charIndex - 1)\r\n        } else if (targetClientLeft > rangeRect.right) {\r\n          low = nextCharIndex\r\n          characterIndex = Math.min(containingTextNode.textContent.length, nextCharIndex)\r\n        } else {\r\n          if (targetClientLeft <= ((rangeRect.left + rangeRect.right) / 2)) {\r\n            characterIndex = charIndex\r\n          } else {\r\n            characterIndex = nextCharIndex\r\n          }\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    let textNodeStartColumn = 0\r\n    for (let i = 0; i < containingTextNodeIndex; i++) {\r\n      textNodeStartColumn = textNodeStartColumn + textNodes[i].length\r\n    }\r\n    const column = textNodeStartColumn + characterIndex\r\n\r\n    return Point(row, column)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.renderedScreenLineForRow","start_line":956,"end_line":961,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"clientRectForRange","line":2406,"func_location":"TextEditorComponent.screenPositionForPixelPosition","func_start_line":2379,"func_end_line":2456,"args":["textNode",{"type":"number"},"textNode.length"],"code":"  screenPositionForPixelPosition ({top, left}) {\r\n    const {model} = this.props\r\n\r\n    const row = Math.min(\r\n      this.rowForPixelPosition(top),\r\n      model.getApproximateScreenLineCount() - 1\r\n    )\r\n\r\n    let screenLine = this.renderedScreenLineForRow(row)\r\n    if (!screenLine) {\r\n      this.requestLineToMeasure(row, model.screenLineForScreenRow(row))\r\n      this.updateSyncBeforeMeasuringContent()\r\n      this.measureContentDuringUpdateSync()\r\n      screenLine = this.renderedScreenLineForRow(row)\r\n    }\r\n\r\n    const linesClientLeft = this.refs.lineTiles.getBoundingClientRect().left\r\n    const targetClientLeft = linesClientLeft + Math.max(0, left)\r\n    const {textNodes} = this.lineComponentsByScreenLineId.get(screenLine.id)\r\n\r\n    let containingTextNodeIndex\r\n    {\r\n      let low = 0\r\n      let high = textNodes.length - 1\r\n      while (low <= high) {\r\n        const mid = low + ((high - low) >> 1)\r\n        const textNode = textNodes[mid]\r\n        const textNodeRect = clientRectForRange(textNode, 0, textNode.length)\r\n\r\n        if (targetClientLeft < textNodeRect.left) {\r\n          high = mid - 1\r\n          containingTextNodeIndex = Math.max(0, mid - 1)\r\n        } else if (targetClientLeft > textNodeRect.right) {\r\n          low = mid + 1\r\n          containingTextNodeIndex = Math.min(textNodes.length - 1, mid + 1)\r\n        } else {\r\n          containingTextNodeIndex = mid\r\n          break\r\n        }\r\n      }\r\n    }\r\n    const containingTextNode = textNodes[containingTextNodeIndex]\r\n    let characterIndex = 0\r\n    {\r\n      let low = 0\r\n      let high = containingTextNode.length - 1\r\n      while (low <= high) {\r\n        const charIndex = low + ((high - low) >> 1)\r\n        const nextCharIndex = isPairedCharacter(containingTextNode.textContent, charIndex)\r\n          ? charIndex + 2\r\n          : charIndex + 1\r\n\r\n        const rangeRect = clientRectForRange(containingTextNode, charIndex, nextCharIndex)\r\n        if (targetClientLeft < rangeRect.left) {\r\n          high = charIndex - 1\r\n          characterIndex = Math.max(0, charIndex - 1)\r\n        } else if (targetClientLeft > rangeRect.right) {\r\n          low = nextCharIndex\r\n          characterIndex = Math.min(containingTextNode.textContent.length, nextCharIndex)\r\n        } else {\r\n          if (targetClientLeft <= ((rangeRect.left + rangeRect.right) / 2)) {\r\n            characterIndex = charIndex\r\n          } else {\r\n            characterIndex = nextCharIndex\r\n          }\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    let textNodeStartColumn = 0\r\n    for (let i = 0; i < containingTextNodeIndex; i++) {\r\n      textNodeStartColumn = textNodeStartColumn + textNodes[i].length\r\n    }\r\n    const column = textNodeStartColumn + characterIndex\r\n\r\n    return Point(row, column)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"clientRectForRange","start_line":4335,"end_line":4340,"comment":[],"params":["textNode","startIndex","endIndex"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"clientRectForRange","line":2431,"func_location":"TextEditorComponent.screenPositionForPixelPosition","func_start_line":2379,"func_end_line":2456,"args":["containingTextNode","charIndex","nextCharIndex"],"code":"  screenPositionForPixelPosition ({top, left}) {\r\n    const {model} = this.props\r\n\r\n    const row = Math.min(\r\n      this.rowForPixelPosition(top),\r\n      model.getApproximateScreenLineCount() - 1\r\n    )\r\n\r\n    let screenLine = this.renderedScreenLineForRow(row)\r\n    if (!screenLine) {\r\n      this.requestLineToMeasure(row, model.screenLineForScreenRow(row))\r\n      this.updateSyncBeforeMeasuringContent()\r\n      this.measureContentDuringUpdateSync()\r\n      screenLine = this.renderedScreenLineForRow(row)\r\n    }\r\n\r\n    const linesClientLeft = this.refs.lineTiles.getBoundingClientRect().left\r\n    const targetClientLeft = linesClientLeft + Math.max(0, left)\r\n    const {textNodes} = this.lineComponentsByScreenLineId.get(screenLine.id)\r\n\r\n    let containingTextNodeIndex\r\n    {\r\n      let low = 0\r\n      let high = textNodes.length - 1\r\n      while (low <= high) {\r\n        const mid = low + ((high - low) >> 1)\r\n        const textNode = textNodes[mid]\r\n        const textNodeRect = clientRectForRange(textNode, 0, textNode.length)\r\n\r\n        if (targetClientLeft < textNodeRect.left) {\r\n          high = mid - 1\r\n          containingTextNodeIndex = Math.max(0, mid - 1)\r\n        } else if (targetClientLeft > textNodeRect.right) {\r\n          low = mid + 1\r\n          containingTextNodeIndex = Math.min(textNodes.length - 1, mid + 1)\r\n        } else {\r\n          containingTextNodeIndex = mid\r\n          break\r\n        }\r\n      }\r\n    }\r\n    const containingTextNode = textNodes[containingTextNodeIndex]\r\n    let characterIndex = 0\r\n    {\r\n      let low = 0\r\n      let high = containingTextNode.length - 1\r\n      while (low <= high) {\r\n        const charIndex = low + ((high - low) >> 1)\r\n        const nextCharIndex = isPairedCharacter(containingTextNode.textContent, charIndex)\r\n          ? charIndex + 2\r\n          : charIndex + 1\r\n\r\n        const rangeRect = clientRectForRange(containingTextNode, charIndex, nextCharIndex)\r\n        if (targetClientLeft < rangeRect.left) {\r\n          high = charIndex - 1\r\n          characterIndex = Math.max(0, charIndex - 1)\r\n        } else if (targetClientLeft > rangeRect.right) {\r\n          low = nextCharIndex\r\n          characterIndex = Math.min(containingTextNode.textContent.length, nextCharIndex)\r\n        } else {\r\n          if (targetClientLeft <= ((rangeRect.left + rangeRect.right) / 2)) {\r\n            characterIndex = charIndex\r\n          } else {\r\n            characterIndex = nextCharIndex\r\n          }\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    let textNodeStartColumn = 0\r\n    for (let i = 0; i < containingTextNodeIndex; i++) {\r\n      textNodeStartColumn = textNodeStartColumn + textNodes[i].length\r\n    }\r\n    const column = textNodeStartColumn + characterIndex\r\n\r\n    return Point(row, column)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"clientRectForRange","start_line":4335,"end_line":4340,"comment":[],"params":["textNode","startIndex","endIndex"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":250,"func_location":"TextEditorElement.screenPositionForPixelPosition","func_start_line":249,"func_end_line":251,"args":["pixelPosition"],"code":"  screenPositionForPixelPosition (pixelPosition) {\r\n    return this.getComponent().screenPositionForPixelPosition(pixelPosition)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"setScrollTop","line":211,"func_location":"TextEditorElement.scrollToBottom","func_start_line":210,"func_end_line":212,"args":["Infinity"],"comment":[" Essential: Scrolls the editor to the bottom."],"code":"  scrollToBottom () {\r\n    this.setScrollTop(Infinity)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.setScrollTop","start_line":172,"end_line":176,"comment":[],"params":["scrollTop"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"setScrollTop","line":206,"func_location":"TextEditorElement.scrollToTop","func_start_line":205,"func_end_line":207,"args":[{"type":"number"}],"comment":[" Essential: Scrolls the editor to the top."],"code":"  scrollToTop () {\r\n    this.setScrollTop(0)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.setScrollTop","start_line":172,"end_line":176,"comment":[],"params":["scrollTop"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"_currentScopeId","line":909,"func_location":"LayerHighlightIterator.seek","func_start_line":885,"func_end_line":940,"args":[],"code":"  seek (targetIndex, containingTags, containingTagStartIndices) {\r\n    while (this.treeCursor.gotoParent()) {}\r\n\r\n    this.done = false\r\n    this.atEnd = true\r\n    this.closeTags.length = 0\r\n    this.openTags.length = 0\r\n    this.containingNodeTypes.length = 0\r\n    this.containingNodeChildIndices.length = 0\r\n    this.containingNodeEndIndices.length = 0\r\n\r\n    const containingTagEndIndices = []\r\n\r\n    if (targetIndex >= this.treeCursor.endIndex) {\r\n      this.done = true\r\n      return\r\n    }\r\n\r\n    let childIndex = -1\r\n    for (;;) {\r\n      this.containingNodeTypes.push(this.treeCursor.nodeType)\r\n      this.containingNodeChildIndices.push(childIndex)\r\n      this.containingNodeEndIndices.push(this.treeCursor.endIndex)\r\n\r\n      const scopeId = this._currentScopeId()\r\n      if (scopeId) {\r\n        if (this.treeCursor.startIndex < targetIndex) {\r\n          insertContainingTag(\r\n            scopeId, this.treeCursor.startIndex,\r\n            containingTags, containingTagStartIndices\r\n          )\r\n          containingTagEndIndices.push(this.treeCursor.endIndex)\r\n        } else {\r\n          this.atEnd = false\r\n          this.openTags.push(scopeId)\r\n          this._moveDown()\r\n          break\r\n        }\r\n      }\r\n\r\n      childIndex = this.treeCursor.gotoFirstChildForIndex(targetIndex)\r\n      if (childIndex === null) break\r\n      if (this.treeCursor.startIndex >= targetIndex) this.atEnd = false\r\n    }\r\n\r\n    if (this.atEnd) {\r\n      const currentIndex = this.treeCursor.endIndex\r\n      for (let i = 0, {length} = containingTags; i < length; i++) {\r\n        if (containingTagEndIndices[i] === currentIndex) {\r\n          this.closeTags.push(containingTags[i])\r\n        }\r\n      }\r\n    }\r\n\r\n    return containingTags\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"LayerHighlightIterator._currentScopeId","start_line":1052,"end_line":1062,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"insertContainingTag","line":912,"func_location":"LayerHighlightIterator.seek","func_start_line":885,"func_end_line":940},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"insertContainingTag","start_line":1163,"end_line":1172,"comment":[],"params":["tag","index","tags","indices"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"_moveDown","line":920,"func_location":"LayerHighlightIterator.seek","func_start_line":885,"func_end_line":940,"args":[],"code":"  seek (targetIndex, containingTags, containingTagStartIndices) {\r\n    while (this.treeCursor.gotoParent()) {}\r\n\r\n    this.done = false\r\n    this.atEnd = true\r\n    this.closeTags.length = 0\r\n    this.openTags.length = 0\r\n    this.containingNodeTypes.length = 0\r\n    this.containingNodeChildIndices.length = 0\r\n    this.containingNodeEndIndices.length = 0\r\n\r\n    const containingTagEndIndices = []\r\n\r\n    if (targetIndex >= this.treeCursor.endIndex) {\r\n      this.done = true\r\n      return\r\n    }\r\n\r\n    let childIndex = -1\r\n    for (;;) {\r\n      this.containingNodeTypes.push(this.treeCursor.nodeType)\r\n      this.containingNodeChildIndices.push(childIndex)\r\n      this.containingNodeEndIndices.push(this.treeCursor.endIndex)\r\n\r\n      const scopeId = this._currentScopeId()\r\n      if (scopeId) {\r\n        if (this.treeCursor.startIndex < targetIndex) {\r\n          insertContainingTag(\r\n            scopeId, this.treeCursor.startIndex,\r\n            containingTags, containingTagStartIndices\r\n          )\r\n          containingTagEndIndices.push(this.treeCursor.endIndex)\r\n        } else {\r\n          this.atEnd = false\r\n          this.openTags.push(scopeId)\r\n          this._moveDown()\r\n          break\r\n        }\r\n      }\r\n\r\n      childIndex = this.treeCursor.gotoFirstChildForIndex(targetIndex)\r\n      if (childIndex === null) break\r\n      if (this.treeCursor.startIndex >= targetIndex) this.atEnd = false\r\n    }\r\n\r\n    if (this.atEnd) {\r\n      const currentIndex = this.treeCursor.endIndex\r\n      for (let i = 0, {length} = containingTags; i < length; i++) {\r\n        if (containingTagEndIndices[i] === currentIndex) {\r\n          this.closeTags.push(containingTags[i])\r\n        }\r\n      }\r\n    }\r\n\r\n    return containingTags\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"LayerHighlightIterator._moveDown","start_line":1016,"end_line":1040,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"setBufferRange","line":283,"func_location":"Selection.selectAll","func_start_line":282,"func_end_line":284,"args":[null,null],"comment":[" Public: Selects all the text in the buffer."],"code":"  selectAll () {\r\n    this.setBufferRange(this.editor.buffer.getRange(), {autoscroll: false})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.setBufferRange","start_line":92,"end_line":104,"comment":[" Public: Modifies the buffer {Range} for the selection.",""," * `bufferRange` The new {Range} to select."," * `options` (optional) {Object} with the keys:","   * `preserveFolds` if `true`, the fold settings are preserved after the","     selection moves.","   * `autoscroll` {Boolean} indicating whether to autoscroll to the new","     range. Defaults to `true` if this is the most recently added selection,","     `false` otherwise."],"params":["bufferRange","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"selectGrammarWithScore","line":188,"func_location":"GrammarRegistry.selectGrammar","func_start_line":187,"func_end_line":189,"args":["filePath","fileContents"],"comment":[" Extended: Select a grammar for the given file path and file contents.",""," This picks the best match by checking the file path and contents against"," each grammar.",""," * `filePath` A {String} file path."," * `fileContents` A {String} of text for the file path.",""," Returns a {Grammar}, never null."],"code":"  selectGrammar (filePath, fileContents) {\r\n    return this.selectGrammarWithScore(filePath, fileContents).grammar\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.selectGrammarWithScore","start_line":191,"end_line":202,"comment":[],"params":["filePath","fileContents"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"forEachGrammar","line":194,"func_location":"GrammarRegistry.selectGrammarWithScore","func_start_line":191,"func_end_line":202},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.forEachGrammar","start_line":305,"end_line":311,"comment":[],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"intersectsVisibleRowRange","line":335,"func_location":"TextEditorElement.selectionIntersectsVisibleRowRange","func_start_line":333,"func_end_line":336,"args":["start.row",null],"code":"  selectionIntersectsVisibleRowRange (selection) {\r\n    const {start, end} = selection.getScreenRange()\r\n    return this.intersectsVisibleRowRange(start.row, end.row + 1)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.intersectsVisibleRowRange","start_line":326,"end_line":331,"comment":[],"params":["startRow","endRow"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"setBufferRange","line":387,"func_location":"Selection.selectLine","func_start_line":385,"func_end_line":397,"args":[null,"options"],"comment":[" Public: Selects an entire line in the buffer.",""," * `row` The line {Number} to select (default: the row of the cursor)."],"code":"  selectLine (row, options) {\r\n    if (row != null) {\r\n      this.setBufferRange(this.editor.bufferRangeForBufferRow(row, {includeNewline: true}), options)\r\n    } else {\r\n      const startRange = this.editor.bufferRangeForBufferRow(this.marker.getStartBufferPosition().row)\r\n      const endRange = this.editor.bufferRangeForBufferRow(this.marker.getEndBufferPosition().row, {includeNewline: true})\r\n      this.setBufferRange(startRange.union(endRange), options)\r\n    }\r\n\r\n    this.linewise = true\r\n    this.wordwise = false\r\n    this.initialScreenRange = this.getScreenRange()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.setBufferRange","start_line":92,"end_line":104,"comment":[" Public: Modifies the buffer {Range} for the selection.",""," * `bufferRange` The new {Range} to select."," * `options` (optional) {Object} with the keys:","   * `preserveFolds` if `true`, the fold settings are preserved after the","     selection moves.","   * `autoscroll` {Boolean} indicating whether to autoscroll to the new","     range. Defaults to `true` if this is the most recently added selection,","     `false` otherwise."],"params":["bufferRange","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"setBufferRange","line":391,"func_location":"Selection.selectLine","func_start_line":385,"func_end_line":397,"args":[null,"options"],"comment":[" Public: Selects an entire line in the buffer.",""," * `row` The line {Number} to select (default: the row of the cursor)."],"code":"  selectLine (row, options) {\r\n    if (row != null) {\r\n      this.setBufferRange(this.editor.bufferRangeForBufferRow(row, {includeNewline: true}), options)\r\n    } else {\r\n      const startRange = this.editor.bufferRangeForBufferRow(this.marker.getStartBufferPosition().row)\r\n      const endRange = this.editor.bufferRangeForBufferRow(this.marker.getEndBufferPosition().row, {includeNewline: true})\r\n      this.setBufferRange(startRange.union(endRange), options)\r\n    }\r\n\r\n    this.linewise = true\r\n    this.wordwise = false\r\n    this.initialScreenRange = this.getScreenRange()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.setBufferRange","start_line":92,"end_line":104,"comment":[" Public: Modifies the buffer {Range} for the selection.",""," * `bufferRange` The new {Range} to select."," * `options` (optional) {Object} with the keys:","   * `preserveFolds` if `true`, the fold settings are preserved after the","     selection moves.","   * `autoscroll` {Boolean} indicating whether to autoscroll to the new","     range. Defaults to `true` if this is the most recently added selection,","     `false` otherwise."],"params":["bufferRange","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"getScreenRange","line":396,"func_location":"Selection.selectLine","func_start_line":385,"func_end_line":397,"args":[],"comment":[" Public: Selects an entire line in the buffer.",""," * `row` The line {Number} to select (default: the row of the cursor)."],"code":"  selectLine (row, options) {\r\n    if (row != null) {\r\n      this.setBufferRange(this.editor.bufferRangeForBufferRow(row, {includeNewline: true}), options)\r\n    } else {\r\n      const startRange = this.editor.bufferRangeForBufferRow(this.marker.getStartBufferPosition().row)\r\n      const endRange = this.editor.bufferRangeForBufferRow(this.marker.getEndBufferPosition().row, {includeNewline: true})\r\n      this.setBufferRange(startRange.union(endRange), options)\r\n    }\r\n\r\n    this.linewise = true\r\n    this.wordwise = false\r\n    this.initialScreenRange = this.getScreenRange()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.getScreenRange","start_line":66,"end_line":68,"comment":["\r\n  Section: Managing the selection range\r\n  "," Public: Returns the screen {Range} for the selection."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selectors.js","name":"matcherForSelector","line":37,"func_location":"selectorMatchesAnyScope","func_start_line":36,"func_end_line":38,"args":[null],"comment":[" Essential: Return true iff the selector matches any provided scope.",""," * {String} selector"," * {Array<String>} scopes"," Returns {Boolean} true if any scope matches the selector."],"code":"function selectorMatchesAnyScope (selector, scopes) {\r\n  return !selector || scopes.some(matcherForSelector(selector))\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selectors.js","name":"matcherForSelector","start_line":23,"end_line":29,"comment":[" Essential: Return a matcher function for a selector.",""," * selector, a {String} selector"," Returns {(scope: String) -> Boolean}, a matcher function returning"," true iff the scope matches the selector."],"params":["selector"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"setBufferRange","line":369,"func_location":"Selection.selectWord","func_start_line":363,"func_end_line":372,"args":[null,"options"],"comment":[" Public: Modifies the selection to encompass the current word.",""," Returns a {Range}."],"code":"  selectWord (options = {}) {\r\n    if (this.cursor.isSurroundedByWhitespace()) options.wordRegex = /[\\t ]*/\r\n    if (this.cursor.isBetweenWordAndNonWord()) {\r\n      options.includeNonWordCharacters = false\r\n    }\r\n\r\n    this.setBufferRange(this.cursor.getCurrentWordBufferRange(options), options)\r\n    this.wordwise = true\r\n    this.initialScreenRange = this.getScreenRange()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.setBufferRange","start_line":92,"end_line":104,"comment":[" Public: Modifies the buffer {Range} for the selection.",""," * `bufferRange` The new {Range} to select."," * `options` (optional) {Object} with the keys:","   * `preserveFolds` if `true`, the fold settings are preserved after the","     selection moves.","   * `autoscroll` {Boolean} indicating whether to autoscroll to the new","     range. Defaults to `true` if this is the most recently added selection,","     `false` otherwise."],"params":["bufferRange","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"getScreenRange","line":371,"func_location":"Selection.selectWord","func_start_line":363,"func_end_line":372,"args":[],"comment":[" Public: Modifies the selection to encompass the current word.",""," Returns a {Range}."],"code":"  selectWord (options = {}) {\r\n    if (this.cursor.isSurroundedByWhitespace()) options.wordRegex = /[\\t ]*/\r\n    if (this.cursor.isBetweenWordAndNonWord()) {\r\n      options.includeNonWordCharacters = false\r\n    }\r\n\r\n    this.setBufferRange(this.cursor.getCurrentWordBufferRange(options), options)\r\n    this.wordwise = true\r\n    this.initialScreenRange = this.getScreenRange()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.getScreenRange","start_line":66,"end_line":68,"comment":["\r\n  Section: Managing the selection range\r\n  "," Public: Returns the screen {Range} for the selection."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"isSpecWindow","line":274,"func_location":"AtomWindow.sendCommand","func_start_line":273,"func_end_line":287,"args":[],"code":"  sendCommand (command, ...args) {\r\n    if (this.isSpecWindow()) {\r\n      if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n        switch (command) {\r\n          case 'window:reload': return this.reload()\r\n          case 'window:toggle-dev-tools': return this.toggleDevTools()\r\n          case 'window:close': return this.close()\r\n        }\r\n      }\r\n    } else if (this.isWebViewFocused()) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    } else if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"AtomWindow.isSpecWindow","start_line":382,"end_line":384,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"reload","line":277,"func_location":"AtomWindow.sendCommand","func_start_line":273,"func_end_line":287,"args":[],"code":"  sendCommand (command, ...args) {\r\n    if (this.isSpecWindow()) {\r\n      if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n        switch (command) {\r\n          case 'window:reload': return this.reload()\r\n          case 'window:toggle-dev-tools': return this.toggleDevTools()\r\n          case 'window:close': return this.close()\r\n        }\r\n      }\r\n    } else if (this.isWebViewFocused()) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    } else if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"AtomWindow.reload","start_line":386,"end_line":392,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"toggleDevTools","line":278,"func_location":"AtomWindow.sendCommand","func_start_line":273,"func_end_line":287,"args":[],"code":"  sendCommand (command, ...args) {\r\n    if (this.isSpecWindow()) {\r\n      if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n        switch (command) {\r\n          case 'window:reload': return this.reload()\r\n          case 'window:toggle-dev-tools': return this.toggleDevTools()\r\n          case 'window:close': return this.close()\r\n        }\r\n      }\r\n    } else if (this.isWebViewFocused()) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    } else if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"AtomWindow.toggleDevTools","start_line":409,"end_line":411,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"close","line":279,"func_location":"AtomWindow.sendCommand","func_start_line":273,"func_end_line":287,"args":[],"code":"  sendCommand (command, ...args) {\r\n    if (this.isSpecWindow()) {\r\n      if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n        switch (command) {\r\n          case 'window:reload': return this.reload()\r\n          case 'window:toggle-dev-tools': return this.toggleDevTools()\r\n          case 'window:close': return this.close()\r\n        }\r\n      }\r\n    } else if (this.isWebViewFocused()) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    } else if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"AtomWindow.close","start_line":330,"end_line":332,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"isWebViewFocused","line":282,"func_location":"AtomWindow.sendCommand","func_start_line":273,"func_end_line":287,"args":[],"code":"  sendCommand (command, ...args) {\r\n    if (this.isSpecWindow()) {\r\n      if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n        switch (command) {\r\n          case 'window:reload': return this.reload()\r\n          case 'window:toggle-dev-tools': return this.toggleDevTools()\r\n          case 'window:close': return this.close()\r\n        }\r\n      }\r\n    } else if (this.isWebViewFocused()) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    } else if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"AtomWindow.isWebViewFocused","start_line":378,"end_line":380,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"sendCommandToBrowserWindow","line":283,"func_location":"AtomWindow.sendCommand","func_start_line":273,"func_end_line":287,"args":["command",null],"code":"  sendCommand (command, ...args) {\r\n    if (this.isSpecWindow()) {\r\n      if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n        switch (command) {\r\n          case 'window:reload': return this.reload()\r\n          case 'window:toggle-dev-tools': return this.toggleDevTools()\r\n          case 'window:close': return this.close()\r\n        }\r\n      }\r\n    } else if (this.isWebViewFocused()) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    } else if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"AtomWindow.sendCommandToBrowserWindow","start_line":293,"end_line":298,"comment":[],"params":["command","args"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"sendCommandToBrowserWindow","line":285,"func_location":"AtomWindow.sendCommand","func_start_line":273,"func_end_line":287,"args":["command",null],"code":"  sendCommand (command, ...args) {\r\n    if (this.isSpecWindow()) {\r\n      if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n        switch (command) {\r\n          case 'window:reload': return this.reload()\r\n          case 'window:toggle-dev-tools': return this.toggleDevTools()\r\n          case 'window:close': return this.close()\r\n        }\r\n      }\r\n    } else if (this.isWebViewFocused()) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    } else if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js","name":"AtomWindow.sendCommandToBrowserWindow","start_line":293,"end_line":298,"comment":[],"params":["command","args"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"focusedWindow","line":659,"func_location":"AtomApplication.sendCommand","func_start_line":657,"func_end_line":666,"args":[],"comment":[" Public: Executes the given command.",""," If it isn't handled globally, delegate to the currently focused window.",""," command - The string representing the command."," args - The optional arguments to pass along."],"code":"  sendCommand (command, ...args) {\r\n    if (!this.emit(command, ...args)) {\r\n      const focusedWindow = this.focusedWindow()\r\n      if (focusedWindow) {\r\n        return focusedWindow.sendCommand(command, ...args)\r\n      } else {\r\n        return this.sendCommandToFirstResponder(command)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.focusedWindow","start_line":748,"end_line":750,"comment":[" Public: Returns the currently focused {AtomWindow} or undefined if none."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"sendCommandToFirstResponder","line":663,"func_location":"AtomApplication.sendCommand","func_start_line":657,"func_end_line":666,"args":["command"],"comment":[" Public: Executes the given command.",""," If it isn't handled globally, delegate to the currently focused window.",""," command - The string representing the command."," args - The optional arguments to pass along."],"code":"  sendCommand (command, ...args) {\r\n    if (!this.emit(command, ...args)) {\r\n      const focusedWindow = this.focusedWindow()\r\n      if (focusedWindow) {\r\n        return focusedWindow.sendCommand(command, ...args)\r\n      } else {\r\n        return this.sendCommandToFirstResponder(command)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.sendCommandToFirstResponder","start_line":685,"end_line":711,"comment":[" Translates the command into macOS action and sends it to application's first"," responder."],"params":["command"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"sendCommandToFirstResponder","line":678,"func_location":"AtomApplication.sendCommandToWindow","func_start_line":673,"func_end_line":681,"args":["command"],"comment":[" Public: Executes the given command on the given window.",""," command - The string representing the command."," atomWindow - The {AtomWindow} to send the command to."," args - The optional arguments to pass along."],"code":"  sendCommandToWindow (command, atomWindow, ...args) {\r\n    if (!this.emit(command, ...args)) {\r\n      if (atomWindow) {\r\n        return atomWindow.sendCommand(command, ...args)\r\n      } else {\r\n        return this.sendCommandToFirstResponder(command)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.sendCommandToFirstResponder","start_line":685,"end_line":711,"comment":[" Translates the command into macOS action and sends it to application's first"," responder."],"params":["command"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getPackageNamesWithActiveGrammars","line":341,"func_location":"Workspace.serialize","func_start_line":338,"func_end_line":353,"args":[],"comment":[" Called by the Serializable mixin during serialization."],"code":"  serialize () {\r\n    return {\r\n      deserializer: 'Workspace',\r\n      packagesWithActiveGrammars: this.getPackageNamesWithActiveGrammars(),\r\n      destroyedItemURIs: this.destroyedItemURIs.slice(),\r\n      // Ensure deserializing 1.17 state with pre 1.17 Atom does not error\r\n      // TODO: Remove after 1.17 has been on stable for a while\r\n      paneContainer: {version: 2},\r\n      paneContainers: {\r\n        center: this.paneContainers.center.serialize(),\r\n        left: this.paneContainers.left.serialize(),\r\n        right: this.paneContainers.right.serialize(),\r\n        bottom: this.paneContainers.bottom.serialize()\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getPackageNamesWithActiveGrammars","start_line":383,"end_line":408,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"getPaths","line":148,"func_location":"Project.serialize","func_start_line":145,"func_end_line":156,"args":[],"code":"  serialize (options = {}) {\r\n    return {\r\n      deserializer: 'Project',\r\n      paths: this.getPaths(),\r\n      buffers: _.compact(this.buffers.map(function (buffer) {\r\n        if (buffer.isRetained()) {\r\n          const isUnloading = options.isUnloading === true\r\n          return buffer.serialize({markerLayers: isUnloading, history: isUnloading})\r\n        }\r\n      }))\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.getPaths","start_line":327,"end_line":329,"comment":["\r\n  Section: Managing Paths\r\n  "," Public: Get an {Array} of {String}s containing the paths of the project's"," directories."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"isFullScreen","line":877,"func_location":"AtomEnvironment.serialize","func_start_line":870,"func_end_line":880,"args":[],"code":"  serialize (options) {\r\n    return {\r\n      version: this.constructor.version,\r\n      project: this.project.serialize(options),\r\n      workspace: this.workspace.serialize(),\r\n      packageStates: this.packages.serialize(),\r\n      grammars: this.grammars.serialize(),\r\n      fullScreen: this.isFullScreen(),\r\n      windowDimensions: this.windowDimensions\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.isFullScreen","start_line":641,"end_line":643,"comment":[" Extended: Returns a {Boolean} that is `true` if the current window is in full screen mode."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"getActivePackages","line":757,"func_location":"PackageManager.serialize","func_start_line":756,"func_end_line":761,"args":[],"code":"  serialize () {\r\n    for (const pack of this.getActivePackages()) {\r\n      this.serializePackage(pack)\r\n    }\r\n    return this.packageStates\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.getActivePackages","start_line":291,"end_line":293,"comment":["\r\n  Section: Accessing active packages\r\n  "," Public: Get an {Array} of all the active {Package}s."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"serializePackage","line":758,"func_location":"PackageManager.serialize","func_start_line":756,"func_end_line":761,"args":["pack"],"code":"  serialize () {\r\n    for (const pack of this.getActivePackages()) {\r\n      this.serializePackage(pack)\r\n    }\r\n    return this.packageStates\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.serializePackage","start_line":763,"end_line":767,"comment":[],"params":["pack"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"setPackageState","line":765,"func_location":"PackageManager.serializePackage","func_start_line":763,"func_end_line":767,"args":["pack.name",null],"code":"  serializePackage (pack) {\r\n    if (typeof pack.serialize === 'function') {\r\n      this.setPackageState(pack.name, pack.serialize())\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.setPackageState","start_line":424,"end_line":426,"comment":[],"params":["name","state"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"makeValueConformToSchema","line":706,"func_location":"Config.set","func_start_line":687,"func_end_line":722,"args":["keyPath","value"],"comment":[" Essential: Sets the value for a configuration setting.",""," This value is stored in Atom's internal configuration file.",""," ### Examples",""," You might want to change the themes programmatically:",""," ```coffee"," atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])"," ```",""," You can also set scoped settings. For example, you might want change the"," `editor.tabLength` only for ruby files.",""," ```coffee"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4"," atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",""," # Set ruby to 2"," atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true",""," # Notice it's only set to 2 in the case of ruby"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," atom.config.get('editor.tabLength', scope: ['source.js']) # => 4"," ```",""," * `keyPath` The {String} name of the key."," * `value` The value of the setting. Passing `undefined` will revert the","   setting to the default value."," * `options` (optional) {Object}","   * `scopeSelector` (optional) {String}. eg. '.source.ruby'","     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)","     for more information.","   * `source` (optional) {String} The name of a file with which the setting","     is associated. Defaults to the user's config file.",""," Returns a {Boolean}"," * `true` if the value was set."," * `false` if the value was not able to be coerced to the type specified in the setting's schema."],"code":"  set (...args) {\r\n    let [keyPath, value, options = {}] = args\r\n\r\n    if (!this.settingsLoaded) {\r\n      this.pendingOperations.push(() => this.set(keyPath, value, options))\r\n    }\r\n\r\n    const scopeSelector = options.scopeSelector\r\n    let source = options.source\r\n    const shouldSave = options.save != null ? options.save : true\r\n\r\n    if (source && !scopeSelector && source !== this.projectFile) {\r\n      throw new Error(\"::set with a 'source' and no 'sourceSelector' is not yet implemented!\")\r\n    }\r\n\r\n    if (!source) source = this.mainSource\r\n\r\n    if (value !== undefined) {\r\n      try {\r\n        value = this.makeValueConformToSchema(keyPath, value)\r\n      } catch (e) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    if (scopeSelector != null) {\r\n      this.setRawScopedValue(keyPath, value, source, scopeSelector)\r\n    } else {\r\n      this.setRawValue(keyPath, value, {source})\r\n    }\r\n\r\n    if (source === this.mainSource && shouldSave && this.settingsLoaded) {\r\n      this.requestSave()\r\n    }\r\n    return true\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.makeValueConformToSchema","start_line":1164,"end_line":1178,"comment":[],"params":["keyPath","value","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"setRawScopedValue","line":713,"func_location":"Config.set","func_start_line":687,"func_end_line":722,"args":["keyPath","value","source","scopeSelector"],"comment":[" Essential: Sets the value for a configuration setting.",""," This value is stored in Atom's internal configuration file.",""," ### Examples",""," You might want to change the themes programmatically:",""," ```coffee"," atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])"," ```",""," You can also set scoped settings. For example, you might want change the"," `editor.tabLength` only for ruby files.",""," ```coffee"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4"," atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",""," # Set ruby to 2"," atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true",""," # Notice it's only set to 2 in the case of ruby"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," atom.config.get('editor.tabLength', scope: ['source.js']) # => 4"," ```",""," * `keyPath` The {String} name of the key."," * `value` The value of the setting. Passing `undefined` will revert the","   setting to the default value."," * `options` (optional) {Object}","   * `scopeSelector` (optional) {String}. eg. '.source.ruby'","     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)","     for more information.","   * `source` (optional) {String} The name of a file with which the setting","     is associated. Defaults to the user's config file.",""," Returns a {Boolean}"," * `true` if the value was set."," * `false` if the value was not able to be coerced to the type specified in the setting's schema."],"code":"  set (...args) {\r\n    let [keyPath, value, options = {}] = args\r\n\r\n    if (!this.settingsLoaded) {\r\n      this.pendingOperations.push(() => this.set(keyPath, value, options))\r\n    }\r\n\r\n    const scopeSelector = options.scopeSelector\r\n    let source = options.source\r\n    const shouldSave = options.save != null ? options.save : true\r\n\r\n    if (source && !scopeSelector && source !== this.projectFile) {\r\n      throw new Error(\"::set with a 'source' and no 'sourceSelector' is not yet implemented!\")\r\n    }\r\n\r\n    if (!source) source = this.mainSource\r\n\r\n    if (value !== undefined) {\r\n      try {\r\n        value = this.makeValueConformToSchema(keyPath, value)\r\n      } catch (e) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    if (scopeSelector != null) {\r\n      this.setRawScopedValue(keyPath, value, source, scopeSelector)\r\n    } else {\r\n      this.setRawValue(keyPath, value, {source})\r\n    }\r\n\r\n    if (source === this.mainSource && shouldSave && this.settingsLoaded) {\r\n      this.requestSave()\r\n    }\r\n    return true\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.setRawScopedValue","start_line":1231,"end_line":1242,"comment":[],"params":["keyPath","value","source","selector","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"setRawValue","line":715,"func_location":"Config.set","func_start_line":687,"func_end_line":722,"args":["keyPath","value",null],"comment":[" Essential: Sets the value for a configuration setting.",""," This value is stored in Atom's internal configuration file.",""," ### Examples",""," You might want to change the themes programmatically:",""," ```coffee"," atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])"," ```",""," You can also set scoped settings. For example, you might want change the"," `editor.tabLength` only for ruby files.",""," ```coffee"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4"," atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",""," # Set ruby to 2"," atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true",""," # Notice it's only set to 2 in the case of ruby"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," atom.config.get('editor.tabLength', scope: ['source.js']) # => 4"," ```",""," * `keyPath` The {String} name of the key."," * `value` The value of the setting. Passing `undefined` will revert the","   setting to the default value."," * `options` (optional) {Object}","   * `scopeSelector` (optional) {String}. eg. '.source.ruby'","     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)","     for more information.","   * `source` (optional) {String} The name of a file with which the setting","     is associated. Defaults to the user's config file.",""," Returns a {Boolean}"," * `true` if the value was set."," * `false` if the value was not able to be coerced to the type specified in the setting's schema."],"code":"  set (...args) {\r\n    let [keyPath, value, options = {}] = args\r\n\r\n    if (!this.settingsLoaded) {\r\n      this.pendingOperations.push(() => this.set(keyPath, value, options))\r\n    }\r\n\r\n    const scopeSelector = options.scopeSelector\r\n    let source = options.source\r\n    const shouldSave = options.save != null ? options.save : true\r\n\r\n    if (source && !scopeSelector && source !== this.projectFile) {\r\n      throw new Error(\"::set with a 'source' and no 'sourceSelector' is not yet implemented!\")\r\n    }\r\n\r\n    if (!source) source = this.mainSource\r\n\r\n    if (value !== undefined) {\r\n      try {\r\n        value = this.makeValueConformToSchema(keyPath, value)\r\n      } catch (e) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    if (scopeSelector != null) {\r\n      this.setRawScopedValue(keyPath, value, source, scopeSelector)\r\n    } else {\r\n      this.setRawValue(keyPath, value, {source})\r\n    }\r\n\r\n    if (source === this.mainSource && shouldSave && this.settingsLoaded) {\r\n      this.requestSave()\r\n    }\r\n    return true\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.setRawValue","start_line":1020,"end_line":1039,"comment":[],"params":["keyPath","value","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js","name":"parseAlpha","line":58,"func_location":"Color.set","func_start_line":57,"func_end_line":59,"args":["alpha"],"code":"  set alpha (alpha) {\r\n    this._alpha = parseAlpha(alpha)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js","name":"parseAlpha","start_line":121,"end_line":124,"comment":[],"params":["alphaString"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js","name":"parseColor","line":54,"func_location":"Color.set","func_start_line":53,"func_end_line":55,"args":["blue"],"code":"  set blue (blue) {\r\n    this._blue = parseColor(blue)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js","name":"parseColor","start_line":116,"end_line":119,"comment":[],"params":["colorString"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js","name":"parseColor","line":50,"func_location":"Color.set","func_start_line":49,"func_end_line":51,"args":["green"],"code":"  set green (green) {\r\n    this._green = parseColor(green)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js","name":"parseColor","start_line":116,"end_line":119,"comment":[],"params":["colorString"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js","name":"parseColor","line":46,"func_location":"Color.set","func_start_line":45,"func_end_line":47,"args":["red"],"code":"  set red (red) {\r\n    this._red = parseColor(red)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js","name":"parseColor","start_line":116,"end_line":119,"comment":[],"params":["colorString"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"addItemToStack","line":437,"func_location":"Pane.setActiveItem","func_start_line":434,"func_end_line":443,"args":["activeItem"],"code":"  setActiveItem (activeItem, options) {\r\n    const modifyStack = options && options.modifyStack\r\n    if (activeItem !== this.activeItem) {\r\n      if (modifyStack !== false) this.addItemToStack(activeItem)\r\n      this.activeItem = activeItem\r\n      this.emitter.emit('did-change-active-item', this.activeItem)\r\n      if (this.container) this.container.didChangeActiveItemOnPane(this, this.activeItem)\r\n    }\r\n    return this.activeItem\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.addItemToStack","start_line":459,"end_line":464,"comment":[" Add item (or move item) to the end of the itemStack"],"params":["newItem"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"showUpdateMenuItem","line":39,"func_location":"ApplicationMenu.setActiveTemplate","func_start_line":32,"func_end_line":40,"args":[null],"code":"  setActiveTemplate (template) {\r\n    if (!_.isEqual(template, this.activeTemplate)) {\r\n      this.activeTemplate = template\r\n      this.menu = Menu.buildFromTemplate(_.deepClone(template))\r\n      Menu.setApplicationMenu(this.menu)\r\n    }\r\n\r\n    return this.showUpdateMenuItem(this.autoUpdateManager.getState())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"ApplicationMenu.showUpdateMenuItem","start_line":109,"end_line":140,"comment":[" Sets the proper visible state the update menu items"],"params":["state"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js","name":"isSupported","line":21,"func_location":"ProtocolHandlerInstaller.setAsDefaultProtocolClient","func_start_line":18,"func_end_line":22,"args":[],"code":"  setAsDefaultProtocolClient () {\r\n    // This Electron API is only available on Windows and macOS. There might be some\r\n    // hacks to make it work on Linux; see https://github.com/electron/electron/issues/6440\r\n    return this.isSupported() && remote.app.setAsDefaultProtocolClient('atom', process.execPath, ['--uri-handler', '--'])\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js","name":"ProtocolHandlerInstaller.isSupported","start_line":10,"end_line":12,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"changePosition","line":85,"func_location":"Cursor.setBufferPosition","func_start_line":84,"func_end_line":88},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.changePosition","start_line":720,"end_line":728,"comment":[],"params":["options","fn"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"isReversed","line":94,"func_location":"Selection.setBufferRange","func_start_line":92,"func_end_line":104,"args":[],"comment":[" Public: Modifies the buffer {Range} for the selection.",""," * `bufferRange` The new {Range} to select."," * `options` (optional) {Object} with the keys:","   * `preserveFolds` if `true`, the fold settings are preserved after the","     selection moves.","   * `autoscroll` {Boolean} indicating whether to autoscroll to the new","     range. Defaults to `true` if this is the most recently added selection,","     `false` otherwise."],"code":"  setBufferRange (bufferRange, options = {}) {\r\n    bufferRange = Range.fromObject(bufferRange)\r\n    if (options.reversed == null) options.reversed = this.isReversed()\r\n    if (!options.preserveFolds) this.editor.destroyFoldsContainingBufferPositions([bufferRange.start, bufferRange.end], true)\r\n    this.modifySelection(() => {\r\n      const needsFlash = options.flash\r\n      options.flash = null\r\n      this.marker.setBufferRange(bufferRange, options)\r\n      const autoscroll = options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n      if (autoscroll) this.autoscroll()\r\n      if (needsFlash) this.decoration.flash('flash', this.editor.selectionFlashDuration)\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.isReversed","start_line":147,"end_line":149,"comment":[" Public: Determines if the ending position of a marker is greater than the"," starting position.",""," This can happen when, for example, you highlight text \"up\" in a {TextBuffer}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"transact","line":1073,"func_location":"Config.setDefaults","func_start_line":1070,"func_end_line":1090},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.transact","start_line":816,"end_line":823,"comment":[" Extended: Suppress calls to handler functions registered with {::onDidChange}"," and {::observe} for the duration of `callback`. After `callback` executes,"," handlers will be called once if the value for their key-path has changed.",""," * `callback` {Function} to execute while suppressing calls to handlers."],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"makeValueConformToSchema","line":1084,"func_location":"Config.setDefaults","func_start_line":1070,"func_end_line":1090,"args":["keyPath","defaults"],"code":"  setDefaults (keyPath, defaults) {\r\n    if ((defaults != null) && isPlainObject(defaults)) {\r\n      const keys = splitKeyPath(keyPath)\r\n      this.transact(() => {\r\n        const result = []\r\n        for (let key in defaults) {\r\n          const childValue = defaults[key]\r\n          if (!defaults.hasOwnProperty(key)) { continue }\r\n          result.push(this.setDefaults(keys.concat([key]).join('.'), childValue))\r\n        }\r\n        return result\r\n      })\r\n    } else {\r\n      try {\r\n        defaults = this.makeValueConformToSchema(keyPath, defaults)\r\n        this.setRawDefault(keyPath, defaults)\r\n      } catch (e) {\r\n        console.warn(`'${keyPath}' could not set the default. Attempted default: ${JSON.stringify(defaults)}; Schema: ${JSON.stringify(this.getSchema(keyPath))}`)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.makeValueConformToSchema","start_line":1164,"end_line":1178,"comment":[],"params":["keyPath","value","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"setRawDefault","line":1085,"func_location":"Config.setDefaults","func_start_line":1070,"func_end_line":1090,"args":["keyPath","defaults"],"code":"  setDefaults (keyPath, defaults) {\r\n    if ((defaults != null) && isPlainObject(defaults)) {\r\n      const keys = splitKeyPath(keyPath)\r\n      this.transact(() => {\r\n        const result = []\r\n        for (let key in defaults) {\r\n          const childValue = defaults[key]\r\n          if (!defaults.hasOwnProperty(key)) { continue }\r\n          result.push(this.setDefaults(keys.concat([key]).join('.'), childValue))\r\n        }\r\n        return result\r\n      })\r\n    } else {\r\n      try {\r\n        defaults = this.makeValueConformToSchema(keyPath, defaults)\r\n        this.setRawDefault(keyPath, defaults)\r\n      } catch (e) {\r\n        console.warn(`'${keyPath}' could not set the default. Attempted default: ${JSON.stringify(defaults)}; Schema: ${JSON.stringify(this.getSchema(keyPath))}`)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.setRawDefault","start_line":1065,"end_line":1068,"comment":[],"params":["keyPath","value"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"getSchema","line":1087,"func_location":"Config.setDefaults","func_start_line":1070,"func_end_line":1090,"args":[null],"code":"  setDefaults (keyPath, defaults) {\r\n    if ((defaults != null) && isPlainObject(defaults)) {\r\n      const keys = splitKeyPath(keyPath)\r\n      this.transact(() => {\r\n        const result = []\r\n        for (let key in defaults) {\r\n          const childValue = defaults[key]\r\n          if (!defaults.hasOwnProperty(key)) { continue }\r\n          result.push(this.setDefaults(keys.concat([key]).join('.'), childValue))\r\n        }\r\n        return result\r\n      })\r\n    } else {\r\n      try {\r\n        defaults = this.makeValueConformToSchema(keyPath, defaults)\r\n        this.setRawDefault(keyPath, defaults)\r\n      } catch (e) {\r\n        console.warn(`'${keyPath}' could not set the default. Attempted default: ${JSON.stringify(defaults)}; Schema: ${JSON.stringify(this.getSchema(keyPath))}`)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.getSchema","start_line":783,"end_line":805,"comment":[" Extended: Retrieve the schema for a specific key path. The schema will tell"," you what type the keyPath expects, and other metadata about the config"," option.",""," * `keyPath` The {String} name of the key.",""," Returns an {Object} eg. `{type: 'integer', default: 23, minimum: 1}`."," Returns `null` when the keyPath has no schema specified, but is accessible"," from the root schema."],"params":["keyPath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"setState","line":110,"func_location":"Dock.setDraggingItem","func_start_line":108,"func_end_line":111,"args":[null],"code":"  setDraggingItem (draggingItem) {\r\n    if (draggingItem === this.state.draggingItem) return\r\n    this.setState({draggingItem})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.setState","start_line":144,"end_line":177,"comment":[],"params":["newState"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"update","line":1068,"func_location":"TextEditor.setEditorWidthInChars","func_start_line":1068,"func_end_line":1068,"args":[null],"comment":[" Set the number of characters that can be displayed horizontally in the"," editor.",""," * `editorWidthInChars` A {Number} representing the width of the"," {TextEditorElement} in characters."],"code":"  setEditorWidthInChars (editorWidthInChars) { this.update({editorWidthInChars}) }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.update","start_line":320,"end_line":539,"comment":[],"params":["params"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getModel","line":339,"func_location":"TextEditorElement.setFirstVisibleScreenColumn","func_start_line":338,"func_end_line":340,"args":["column"],"code":"  setFirstVisibleScreenColumn (column) {\r\n    return this.getModel().setFirstVisibleScreenColumn(column)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getModel","start_line":80,"end_line":82,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getModel","line":311,"func_location":"TextEditorElement.setFirstVisibleScreenRow","func_start_line":310,"func_end_line":312,"args":["row"],"code":"  setFirstVisibleScreenRow (row) {\r\n    this.getModel().setFirstVisibleScreenRow(row)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getModel","start_line":80,"end_line":82,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"grammarForScopeName","line":349,"func_location":"GrammarRegistry.setGrammarOverrideForPath","func_start_line":345,"func_end_line":352,"args":["languageId"],"comment":[" Deprecated: Set the grammar override for the given file path.",""," * `filePath` A non-empty {String} file path."," * `languageId` A {String} such as `\"source.js\"`.",""," Returns undefined."],"code":"  setGrammarOverrideForPath (filePath, languageId) {\r\n    Grim.deprecate('Use atom.grammars.assignLanguageMode(buffer, languageId) instead')\r\n    const buffer = atom.project.findBufferForPath(filePath)\r\n    if (buffer) {\r\n      const grammar = this.grammarForScopeName(languageId)\r\n      if (grammar) this.languageOverridesByBufferId.set(buffer.id, grammar.name)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js","name":"GrammarRegistry.grammarForScopeName","start_line":452,"end_line":454,"comment":[],"params":["scopeName"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"setState","line":105,"func_location":"Dock.setHovered","func_start_line":103,"func_end_line":106,"args":[null],"code":"  setHovered (hovered) {\r\n    if (hovered === this.state.hovered) return\r\n    this.setState({hovered})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.setState","start_line":144,"end_line":177,"comment":[],"params":["newState"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"update","line":1020,"func_location":"TextEditor.setLineNumberGutterVisible","func_start_line":1020,"func_end_line":1020,"args":[null],"code":"  setLineNumberGutterVisible (lineNumberGutterVisible) { this.update({lineNumberGutterVisible}) }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.update","start_line":320,"end_line":539,"comment":[],"params":["params"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"update","line":999,"func_location":"TextEditor.setMini","func_start_line":998,"func_end_line":1000,"args":[null],"code":"  setMini (mini) {\r\n    this.update({mini})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.update","start_line":320,"end_line":539,"comment":[],"params":["params"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":85,"func_location":"TextEditorElement.setModel","func_start_line":84,"func_end_line":87,"args":[null],"code":"  setModel (model) {\r\n    this.getComponent().update({model})\r\n    this.updateModelFromAttributes()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"updateModelFromAttributes","line":86,"func_location":"TextEditorElement.setModel","func_start_line":84,"func_end_line":87,"args":[],"code":"  setModel (model) {\r\n    this.getComponent().update({model})\r\n    this.updateModelFromAttributes()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.updateModelFromAttributes","start_line":89,"end_line":96,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"addPath","line":354,"func_location":"Project.setPaths","func_start_line":339,"func_end_line":371,"args":["projectPath",null],"comment":[" Public: Set the paths of the project's directories.",""," * `projectPaths` {Array} of {String} paths."," * `options` An optional {Object} that may contain the following keys:","   * `mustExist` If `true`, throw an Error if any `projectPaths` do not exist. Any remaining `projectPaths` that","     do exist will still be added to the project. Default: `false`.","   * `exact` If `true`, only add a `projectPath` if it names an existing directory. If `false` and any `projectPath`","     is a file or does not exist, its parent directory will be added instead. Default: `false`."],"code":"  setPaths (projectPaths, options = {}) {\r\n    for (let repository of this.repositories) {\r\n      if (repository != null) repository.destroy()\r\n    }\r\n    this.rootDirectories = []\r\n    this.repositories = []\r\n\r\n    for (let path in this.watcherPromisesByPath) {\r\n      this.watcherPromisesByPath[path].then(watcher => { watcher.dispose() })\r\n    }\r\n    this.watcherPromisesByPath = {}\r\n\r\n    const missingProjectPaths = []\r\n    for (let projectPath of projectPaths) {\r\n      try {\r\n        this.addPath(projectPath, {emitEvent: false, mustExist: true, exact: options.exact === true})\r\n      } catch (e) {\r\n        if (e.missingProjectPaths != null) {\r\n          missingProjectPaths.push(...e.missingProjectPaths)\r\n        } else {\r\n          throw e\r\n        }\r\n      }\r\n    }\r\n\r\n    this.emitter.emit('did-change-paths', projectPaths)\r\n\r\n    if ((options.mustExist === true) && (missingProjectPaths.length > 0)) {\r\n      const err = new Error('One or more project directories do not exist')\r\n      err.missingProjectPaths = missingProjectPaths\r\n      throw err\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js","name":"Project.addPath","start_line":381,"end_line":442,"comment":[" Public: Add a path to the project's list of root paths",""," * `projectPath` {String} The path to the directory to add."," * `options` An optional {Object} that may contain the following keys:","   * `mustExist` If `true`, throw an Error if the `projectPath` does not exist. If `false`, a `projectPath` that does","     not exist is ignored. Default: `false`.","   * `exact` If `true`, only add `projectPath` if it names an existing directory. If `false`, if `projectPath` is a","     a file or does not exist, its parent directory will be added instead."],"params":["projectPath","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration.js","name":"translateDecorationParamsOldToNew","line":167,"func_location":"Decoration.setProperties","func_start_line":164,"func_end_line":173,"args":["newProperties"],"comment":[" Essential: Update the marker with new Properties. Allows you to change the decoration's class.",""," ## Examples",""," ```coffee"," decoration.setProperties({type: 'line-number', class: 'my-new-class'})"," ```",""," * `newProperties` {Object} eg. `{type: 'line-number', class: 'my-new-class'}`"],"code":"  setProperties (newProperties) {\r\n    if (this.destroyed) { return }\r\n    const oldProperties = this.properties\r\n    this.properties = translateDecorationParamsOldToNew(newProperties)\r\n    if (newProperties.type != null) {\r\n      this.decorationManager.decorationDidChangeType(this)\r\n    }\r\n    this.decorationManager.emitDidUpdateDecorations()\r\n    return this.emitter.emit('did-change-properties', {oldProperties, newProperties})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration.js","name":"translateDecorationParamsOldToNew","start_line":8,"end_line":13,"comment":[" Applies changes to a decorationsParam {Object} to make it possible to"," differentiate decorations on custom gutters versus the line-number gutter."],"params":["decorationParams"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"emitChangeEvent","line":1067,"func_location":"Config.setRawDefault","func_start_line":1065,"func_end_line":1068,"args":[],"code":"  setRawDefault (keyPath, value) {\r\n    setValueAtKeyPath(this.defaultSettings, keyPath, value)\r\n    return this.emitChangeEvent()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.emitChangeEvent","start_line":1211,"end_line":1213,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"priorityForSource","line":1240,"func_location":"Config.setRawScopedValue","func_start_line":1231,"func_end_line":1242,"args":["source","settingsBySelector",null],"code":"  setRawScopedValue (keyPath, value, source, selector, options) {\r\n    if (keyPath != null) {\r\n      const newValue = {}\r\n      setValueAtKeyPath(newValue, keyPath, value)\r\n      value = newValue\r\n    }\r\n\r\n    const settingsBySelector = {}\r\n    settingsBySelector[selector] = value\r\n    this.scopedSettingsStore.addProperties(source, settingsBySelector, {priority: this.priorityForSource(source)})\r\n    return this.emitChangeEvent()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.priorityForSource","start_line":1200,"end_line":1209,"comment":["\r\n  Section: Private Scoped Settings\r\n  "],"params":["source"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"emitChangeEvent","line":1241,"func_location":"Config.setRawScopedValue","func_start_line":1231,"func_end_line":1242,"args":[],"code":"  setRawScopedValue (keyPath, value, source, selector, options) {\r\n    if (keyPath != null) {\r\n      const newValue = {}\r\n      setValueAtKeyPath(newValue, keyPath, value)\r\n      value = newValue\r\n    }\r\n\r\n    const settingsBySelector = {}\r\n    settingsBySelector[selector] = value\r\n    this.scopedSettingsStore.addProperties(source, settingsBySelector, {priority: this.priorityForSource(source)})\r\n    return this.emitChangeEvent()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.emitChangeEvent","start_line":1211,"end_line":1213,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"emitChangeEvent","line":1038,"func_location":"Config.setRawValue","func_start_line":1020,"func_end_line":1039,"args":[],"code":"  setRawValue (keyPath, value, options = {}) {\r\n    const source = options.source ? options.source : undefined\r\n    const settingsToChange = source === this.projectFile ? 'projectSettings' : 'settings'\r\n    const defaultValue = getValueAtKeyPath(this.defaultSettings, keyPath)\r\n\r\n    if (_.isEqual(defaultValue, value)) {\r\n      if (keyPath != null) {\r\n        deleteValueAtKeyPath(this[settingsToChange], keyPath)\r\n      } else {\r\n        this[settingsToChange] = null\r\n      }\r\n    } else {\r\n      if (keyPath != null) {\r\n        setValueAtKeyPath(this[settingsToChange], keyPath, value)\r\n      } else {\r\n        this[settingsToChange] = value\r\n      }\r\n    }\r\n    return this.emitChangeEvent()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.emitChangeEvent","start_line":1211,"end_line":1213,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"update","line":1005,"func_location":"TextEditor.setReadOnly","func_start_line":1004,"func_end_line":1006,"args":[null],"code":"  setReadOnly (readOnly) {\r\n    this.update({readOnly})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.update","start_line":320,"end_line":539,"comment":[],"params":["params"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"getActivePane","line":136,"func_location":"PaneContainer.setRoot","func_start_line":131,"func_end_line":139,"args":[],"code":"  setRoot (root) {\r\n    this.root = root\r\n    this.root.setParent(this)\r\n    this.root.setContainer(this)\r\n    this.emitter.emit('did-change-root', this.root)\r\n    if ((this.getActivePane() == null) && this.root instanceof Pane) {\r\n      this.didActivatePane(this.root)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.getActivePane","start_line":158,"end_line":160,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"didActivatePane","line":137,"func_location":"PaneContainer.setRoot","func_start_line":131,"func_end_line":139,"args":[".root"],"code":"  setRoot (root) {\r\n    this.root = root\r\n    this.root.setParent(this)\r\n    this.root.setContainer(this)\r\n    this.emitter.emit('did-change-root', this.root)\r\n    if ((this.getActivePane() == null) && this.root instanceof Pane) {\r\n      this.didActivatePane(this.root)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js","name":"PaneContainer.didActivatePane","start_line":251,"end_line":263,"comment":[],"params":["activePane"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"transact","line":916,"func_location":"Config.setSchema","func_start_line":895,"func_end_line":921},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.transact","start_line":816,"end_line":823,"comment":[" Extended: Suppress calls to handler functions registered with {::onDidChange}"," and {::observe} for the duration of `callback`. After `callback` executes,"," handlers will be called once if the value for their key-path has changed.",""," * `callback` {Function} to execute while suppressing calls to handlers."],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"setScopedDefaultsFromSchema","line":1148,"func_location":"Config.setScopedDefaultsFromSchema","func_start_line":1131,"func_end_line":1151,"args":[null,"childValue"],"comment":[" `schema` will look something like this",""," ```coffee"," type: 'string'"," default: 'ok'"," scopes:","   '.source.js':","     default: 'omg'"," ```"],"code":"  setScopedDefaultsFromSchema (keyPath, schema) {\r\n    if ((schema.scopes != null) && isPlainObject(schema.scopes)) {\r\n      const scopedDefaults = {}\r\n      for (let scope in schema.scopes) {\r\n        const scopeSchema = schema.scopes[scope]\r\n        if (!scopeSchema.hasOwnProperty('default')) { continue }\r\n        scopedDefaults[scope] = {}\r\n        setValueAtKeyPath(scopedDefaults[scope], keyPath, scopeSchema.default)\r\n      }\r\n      this.scopedSettingsStore.addProperties('schema-default', scopedDefaults)\r\n    }\r\n\r\n    if ((schema.type === 'object') && (schema.properties != null) && isPlainObject(schema.properties)) {\r\n      const keys = splitKeyPath(keyPath)\r\n      for (let key in schema.properties) {\r\n        const childValue = schema.properties[key]\r\n        if (!schema.properties.hasOwnProperty(key)) { continue }\r\n        this.setScopedDefaultsFromSchema(keys.concat([key]).join('.'), childValue)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.setScopedDefaultsFromSchema","start_line":1131,"end_line":1151,"comment":[" `schema` will look something like this",""," ```coffee"," type: 'string'"," default: 'ok'"," scopes:","   '.source.js':","     default: 'omg'"," ```"],"params":["keyPath","schema"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"changePosition","line":67,"func_location":"Cursor.setScreenPosition","func_start_line":66,"func_end_line":70},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.changePosition","start_line":720,"end_line":728,"comment":[],"params":["options","fn"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"setBufferRange","line":75,"func_location":"Selection.setScreenRange","func_start_line":74,"func_end_line":76,"args":[null,"options"],"comment":[" Public: Modifies the screen range for the selection.",""," * `screenRange` The new {Range} to use."," * `options` (optional) {Object} options matching those found in {::setBufferRange}."],"code":"  setScreenRange (screenRange, options) {\r\n    return this.setBufferRange(this.editor.bufferRangeForScreenRange(screenRange), options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js","name":"Selection.setBufferRange","start_line":92,"end_line":104,"comment":[" Public: Modifies the buffer {Range} for the selection.",""," * `bufferRange` The new {Range} to select."," * `options` (optional) {Object} with the keys:","   * `preserveFolds` if `true`, the fold settings are preserved after the","     selection moves.","   * `autoscroll` {Boolean} indicating whether to autoscroll to the new","     range. Defaults to `true` if this is the most recently added selection,","     `false` otherwise."],"params":["bufferRange","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"setScrollTop","line":2820,"func_location":"TextEditorComponent.setScrollBottom","func_start_line":2819,"func_end_line":2821,"args":[null],"code":"  setScrollBottom (scrollBottom) {\r\n    return this.setScrollTop(scrollBottom - this.getScrollContainerClientHeight())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.setScrollTop","start_line":2796,"end_line":2809,"comment":[],"params":["scrollTop"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollContainerClientHeight","line":2820,"func_location":"TextEditorComponent.setScrollBottom","func_start_line":2819,"func_end_line":2821,"args":[null],"code":"  setScrollBottom (scrollBottom) {\r\n    return this.setScrollTop(scrollBottom - this.getScrollContainerClientHeight())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollContainerClientHeight","start_line":2640,"end_line":2642,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":183,"func_location":"TextEditorElement.setScrollBottom","func_start_line":182,"func_end_line":184,"args":["scrollBottom"],"code":"  setScrollBottom (scrollBottom) {\r\n    return this.getComponent().setScrollBottom(scrollBottom)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"roundToPhysicalPixelBoundary","line":2830,"func_location":"TextEditorComponent.setScrollLeft","func_start_line":2827,"func_end_line":2839,"args":[null],"code":"  setScrollLeft (scrollLeft) {\r\n    if (Number.isNaN(scrollLeft) || scrollLeft == null) return false\r\n\r\n    scrollLeft = roundToPhysicalPixelBoundary(Math.max(0, Math.min(this.getMaxScrollLeft(), scrollLeft)))\r\n    if (scrollLeft !== this.scrollLeft) {\r\n      this.scrollLeftPending = true\r\n      this.scrollLeft = scrollLeft\r\n      this.element.emitter.emit('did-change-scroll-left', scrollLeft)\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"roundToPhysicalPixelBoundary","start_line":4486,"end_line":4489,"comment":[],"params":["virtualPixelPosition"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getMaxScrollLeft","line":2830,"func_location":"TextEditorComponent.setScrollLeft","func_start_line":2827,"func_end_line":2839,"args":[null],"code":"  setScrollLeft (scrollLeft) {\r\n    if (Number.isNaN(scrollLeft) || scrollLeft == null) return false\r\n\r\n    scrollLeft = roundToPhysicalPixelBoundary(Math.max(0, Math.min(this.getMaxScrollLeft(), scrollLeft)))\r\n    if (scrollLeft !== this.scrollLeft) {\r\n      this.scrollLeftPending = true\r\n      this.scrollLeft = scrollLeft\r\n      this.element.emitter.emit('did-change-scroll-left', scrollLeft)\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getMaxScrollLeft","start_line":2841,"end_line":2843,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":191,"func_location":"TextEditorElement.setScrollLeft","func_start_line":190,"func_end_line":194,"args":[],"code":"  setScrollLeft (scrollLeft) {\r\n    const component = this.getComponent()\r\n    component.setScrollLeft(scrollLeft)\r\n    component.scheduleUpdate()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getLongestLineWidth","line":2875,"func_location":"TextEditorComponent.setScrollLeftColumn","func_start_line":2874,"func_end_line":2885,"args":[],"code":"  setScrollLeftColumn (scrollLeftColumn, scheduleUpdate = true) {\r\n    if (this.hasInitialMeasurements && this.getLongestLineWidth() != null) {\r\n      const didScroll = this.setScrollLeft(scrollLeftColumn * this.getBaseCharacterWidth())\r\n      if (didScroll && scheduleUpdate) {\r\n        this.scheduleUpdate()\r\n      }\r\n      return didScroll\r\n    } else {\r\n      this.pendingScrollLeftColumn = scrollLeftColumn\r\n      return false\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getLongestLineWidth","start_line":2608,"end_line":2610,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"setScrollLeft","line":2876,"func_location":"TextEditorComponent.setScrollLeftColumn","func_start_line":2874,"func_end_line":2885,"args":[null],"code":"  setScrollLeftColumn (scrollLeftColumn, scheduleUpdate = true) {\r\n    if (this.hasInitialMeasurements && this.getLongestLineWidth() != null) {\r\n      const didScroll = this.setScrollLeft(scrollLeftColumn * this.getBaseCharacterWidth())\r\n      if (didScroll && scheduleUpdate) {\r\n        this.scheduleUpdate()\r\n      }\r\n      return didScroll\r\n    } else {\r\n      this.pendingScrollLeftColumn = scrollLeftColumn\r\n      return false\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.setScrollLeft","start_line":2827,"end_line":2839,"comment":[],"params":["scrollLeft"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getBaseCharacterWidth","line":2876,"func_location":"TextEditorComponent.setScrollLeftColumn","func_start_line":2874,"func_end_line":2885,"args":[null],"code":"  setScrollLeftColumn (scrollLeftColumn, scheduleUpdate = true) {\r\n    if (this.hasInitialMeasurements && this.getLongestLineWidth() != null) {\r\n      const didScroll = this.setScrollLeft(scrollLeftColumn * this.getBaseCharacterWidth())\r\n      if (didScroll && scheduleUpdate) {\r\n        this.scheduleUpdate()\r\n      }\r\n      return didScroll\r\n    } else {\r\n      this.pendingScrollLeftColumn = scrollLeftColumn\r\n      return false\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getBaseCharacterWidth","start_line":2604,"end_line":2606,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"scheduleUpdate","line":2878,"func_location":"TextEditorComponent.setScrollLeftColumn","func_start_line":2874,"func_end_line":2885,"args":[],"code":"  setScrollLeftColumn (scrollLeftColumn, scheduleUpdate = true) {\r\n    if (this.hasInitialMeasurements && this.getLongestLineWidth() != null) {\r\n      const didScroll = this.setScrollLeft(scrollLeftColumn * this.getBaseCharacterWidth())\r\n      if (didScroll && scheduleUpdate) {\r\n        this.scheduleUpdate()\r\n      }\r\n      return didScroll\r\n    } else {\r\n      this.pendingScrollLeftColumn = scrollLeftColumn\r\n      return false\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.scheduleUpdate","start_line":204,"end_line":219,"comment":[],"params":["nextUpdateOnlyBlinksCursors"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"setScrollLeft","line":2850,"func_location":"TextEditorComponent.setScrollRight","func_start_line":2849,"func_end_line":2851,"args":[null],"code":"  setScrollRight (scrollRight) {\r\n    return this.setScrollLeft(scrollRight - this.getScrollContainerClientWidth())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.setScrollLeft","start_line":2827,"end_line":2839,"comment":[],"params":["scrollLeft"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollContainerClientWidth","line":2850,"func_location":"TextEditorComponent.setScrollRight","func_start_line":2849,"func_end_line":2851,"args":[null],"code":"  setScrollRight (scrollRight) {\r\n    return this.setScrollLeft(scrollRight - this.getScrollContainerClientWidth())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollContainerClientWidth","start_line":2636,"end_line":2638,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":201,"func_location":"TextEditorElement.setScrollRight","func_start_line":200,"func_end_line":202,"args":["scrollRight"],"code":"  setScrollRight (scrollRight) {\r\n    return this.getComponent().setScrollRight(scrollRight)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"roundToPhysicalPixelBoundary","line":2799,"func_location":"TextEditorComponent.setScrollTop","func_start_line":2796,"func_end_line":2809,"args":[null],"code":"  setScrollTop (scrollTop) {\r\n    if (Number.isNaN(scrollTop) || scrollTop == null) return false\r\n\r\n    scrollTop = roundToPhysicalPixelBoundary(Math.max(0, Math.min(this.getMaxScrollTop(), scrollTop)))\r\n    if (scrollTop !== this.scrollTop) {\r\n      this.derivedDimensionsCache = {}\r\n      this.scrollTopPending = true\r\n      this.scrollTop = scrollTop\r\n      this.element.emitter.emit('did-change-scroll-top', scrollTop)\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"roundToPhysicalPixelBoundary","start_line":4486,"end_line":4489,"comment":[],"params":["virtualPixelPosition"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getMaxScrollTop","line":2799,"func_location":"TextEditorComponent.setScrollTop","func_start_line":2796,"func_end_line":2809,"args":[null],"code":"  setScrollTop (scrollTop) {\r\n    if (Number.isNaN(scrollTop) || scrollTop == null) return false\r\n\r\n    scrollTop = roundToPhysicalPixelBoundary(Math.max(0, Math.min(this.getMaxScrollTop(), scrollTop)))\r\n    if (scrollTop !== this.scrollTop) {\r\n      this.derivedDimensionsCache = {}\r\n      this.scrollTopPending = true\r\n      this.scrollTop = scrollTop\r\n      this.element.emitter.emit('did-change-scroll-top', scrollTop)\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getMaxScrollTop","start_line":2811,"end_line":2813,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":173,"func_location":"TextEditorElement.setScrollTop","func_start_line":172,"func_end_line":176,"args":[],"code":"  setScrollTop (scrollTop) {\r\n    const component = this.getComponent()\r\n    component.setScrollTop(scrollTop)\r\n    component.scheduleUpdate()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"setScrollTop","line":2855,"func_location":"TextEditorComponent.setScrollTopRow","func_start_line":2853,"func_end_line":2864,"args":[null],"code":"  setScrollTopRow (scrollTopRow, scheduleUpdate = true) {\r\n    if (this.hasInitialMeasurements) {\r\n      const didScroll = this.setScrollTop(this.pixelPositionBeforeBlocksForRow(scrollTopRow))\r\n      if (didScroll && scheduleUpdate) {\r\n        this.scheduleUpdate()\r\n      }\r\n      return didScroll\r\n    } else {\r\n      this.pendingScrollTopRow = scrollTopRow\r\n      return false\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.setScrollTop","start_line":2796,"end_line":2809,"comment":[],"params":["scrollTop"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelPositionBeforeBlocksForRow","line":2855,"func_location":"TextEditorComponent.setScrollTopRow","func_start_line":2853,"func_end_line":2864,"args":[null],"code":"  setScrollTopRow (scrollTopRow, scheduleUpdate = true) {\r\n    if (this.hasInitialMeasurements) {\r\n      const didScroll = this.setScrollTop(this.pixelPositionBeforeBlocksForRow(scrollTopRow))\r\n      if (didScroll && scheduleUpdate) {\r\n        this.scheduleUpdate()\r\n      }\r\n      return didScroll\r\n    } else {\r\n      this.pendingScrollTopRow = scrollTopRow\r\n      return false\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelPositionBeforeBlocksForRow","start_line":2360,"end_line":2362,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"scheduleUpdate","line":2857,"func_location":"TextEditorComponent.setScrollTopRow","func_start_line":2853,"func_end_line":2864,"args":[],"code":"  setScrollTopRow (scrollTopRow, scheduleUpdate = true) {\r\n    if (this.hasInitialMeasurements) {\r\n      const didScroll = this.setScrollTop(this.pixelPositionBeforeBlocksForRow(scrollTopRow))\r\n      if (didScroll && scheduleUpdate) {\r\n        this.scheduleUpdate()\r\n      }\r\n      return didScroll\r\n    } else {\r\n      this.pendingScrollTopRow = scrollTopRow\r\n      return false\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.scheduleUpdate","start_line":204,"end_line":219,"comment":[],"params":["nextUpdateOnlyBlinksCursors"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js","name":"mergeTable","line":137,"func_location":"setTableDefaults","func_start_line":129,"func_end_line":152,"args":["typeTable","defaultTypeTable"],"code":"function setTableDefaults (table, allowWildcardSelector) {\r\n  const defaultTypeTable = allowWildcardSelector ? table['*'] : null\r\n\r\n  for (let type in table) {\r\n    let typeTable = table[type]\r\n    if (typeTable === defaultTypeTable) continue\r\n\r\n    if (defaultTypeTable) {\r\n      mergeTable(typeTable, defaultTypeTable)\r\n    }\r\n\r\n    if (typeTable.parents) {\r\n      setTableDefaults(typeTable.parents, true)\r\n    }\r\n\r\n    for (let key in typeTable.indices) {\r\n      const indexTable = typeTable.indices[key]\r\n      mergeTable(indexTable, typeTable, false)\r\n      if (indexTable.parents) {\r\n        setTableDefaults(indexTable.parents, true)\r\n      }\r\n    }\r\n  }\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js","name":"mergeTable","start_line":154,"end_line":174,"comment":[],"params":["table","defaultTable","mergeIndices"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js","name":"setTableDefaults","line":141,"func_location":"setTableDefaults","func_start_line":129,"func_end_line":152,"args":["typeTable.parents",{"type":"boolean"}],"code":"function setTableDefaults (table, allowWildcardSelector) {\r\n  const defaultTypeTable = allowWildcardSelector ? table['*'] : null\r\n\r\n  for (let type in table) {\r\n    let typeTable = table[type]\r\n    if (typeTable === defaultTypeTable) continue\r\n\r\n    if (defaultTypeTable) {\r\n      mergeTable(typeTable, defaultTypeTable)\r\n    }\r\n\r\n    if (typeTable.parents) {\r\n      setTableDefaults(typeTable.parents, true)\r\n    }\r\n\r\n    for (let key in typeTable.indices) {\r\n      const indexTable = typeTable.indices[key]\r\n      mergeTable(indexTable, typeTable, false)\r\n      if (indexTable.parents) {\r\n        setTableDefaults(indexTable.parents, true)\r\n      }\r\n    }\r\n  }\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js","name":"setTableDefaults","start_line":129,"end_line":152,"comment":[],"params":["table","allowWildcardSelector"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js","name":"mergeTable","line":146,"func_location":"setTableDefaults","func_start_line":129,"func_end_line":152,"args":["indexTable","typeTable",{"type":"boolean"}],"code":"function setTableDefaults (table, allowWildcardSelector) {\r\n  const defaultTypeTable = allowWildcardSelector ? table['*'] : null\r\n\r\n  for (let type in table) {\r\n    let typeTable = table[type]\r\n    if (typeTable === defaultTypeTable) continue\r\n\r\n    if (defaultTypeTable) {\r\n      mergeTable(typeTable, defaultTypeTable)\r\n    }\r\n\r\n    if (typeTable.parents) {\r\n      setTableDefaults(typeTable.parents, true)\r\n    }\r\n\r\n    for (let key in typeTable.indices) {\r\n      const indexTable = typeTable.indices[key]\r\n      mergeTable(indexTable, typeTable, false)\r\n      if (indexTable.parents) {\r\n        setTableDefaults(indexTable.parents, true)\r\n      }\r\n    }\r\n  }\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js","name":"mergeTable","start_line":154,"end_line":174,"comment":[],"params":["table","defaultTable","mergeIndices"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js","name":"setTableDefaults","line":148,"func_location":"setTableDefaults","func_start_line":129,"func_end_line":152,"args":["indexTable.parents",{"type":"boolean"}],"code":"function setTableDefaults (table, allowWildcardSelector) {\r\n  const defaultTypeTable = allowWildcardSelector ? table['*'] : null\r\n\r\n  for (let type in table) {\r\n    let typeTable = table[type]\r\n    if (typeTable === defaultTypeTable) continue\r\n\r\n    if (defaultTypeTable) {\r\n      mergeTable(typeTable, defaultTypeTable)\r\n    }\r\n\r\n    if (typeTable.parents) {\r\n      setTableDefaults(typeTable.parents, true)\r\n    }\r\n\r\n    for (let key in typeTable.indices) {\r\n      const indexTable = typeTable.indices[key]\r\n      mergeTable(indexTable, typeTable, false)\r\n      if (indexTable.parents) {\r\n        setTableDefaults(indexTable.parents, true)\r\n      }\r\n    }\r\n  }\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js","name":"setTableDefaults","start_line":129,"end_line":152,"comment":[],"params":["table","allowWildcardSelector"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"getBuffer","line":1358,"func_location":"TextEditor.setTextInBufferRange","func_start_line":1356,"func_end_line":1359,"args":["range","text","options"],"comment":[" Essential: Set the text in the given {Range} in buffer coordinates.",""," * `range` A {Range} or range-compatible {Array}."," * `text` A {String}"," * `options` (optional) {Object}","   * `normalizeLineEndings` (optional) {Boolean} (default: true)","   * `undo` (optional) *Deprecated* {String} 'skip' will skip the undo system. This property is deprecated. Call groupLastChanges() on the {TextBuffer} afterward instead.","   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)",""," Returns the {Range} of the newly-inserted text."],"code":"  setTextInBufferRange (range, text, options = {}) {\r\n    if (!this.ensureWritable('setTextInBufferRange', options)) return\r\n    return this.getBuffer().setTextInRange(range, text, options)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.getBuffer","start_line":963,"end_line":963,"comment":[" Essential: Retrieves the current {TextBuffer}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getComponent","line":111,"func_location":"TextEditorElement.setWidth","func_start_line":110,"func_end_line":112,"args":[],"code":"  setWidth (width) {\r\n    this.style.width = this.getComponent().getGutterContainerWidth() + width + 'px'\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getComponent","start_line":276,"end_line":288,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"setSize","line":704,"func_location":"AtomEnvironment.setWindowDimensions","func_start_line":701,"func_end_line":712,"args":[null],"comment":[" Set the dimensions of the window.",""," The window will be centered if either the x or y coordinate is not set"," in the dimensions parameter. If x or y are omitted the window will be"," centered. If height or width are omitted only the position will be changed.",""," * `dimensions` An {Object} with the following keys:","   * `x` The new x coordinate.","   * `y` The new y coordinate.","   * `width` The new width.","   * `height` The new height."],"code":"  setWindowDimensions ({x, y, width, height}) {\r\n    const steps = []\r\n    if (width != null && height != null) {\r\n      steps.push(this.setSize(width, height))\r\n    }\r\n    if (x != null && y != null) {\r\n      steps.push(this.setPosition(x, y))\r\n    } else {\r\n      steps.push(this.center())\r\n    }\r\n    return Promise.all(steps)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.setSize","start_line":576,"end_line":578,"comment":[" Essential: Set the size of current window.",""," * `width` The {Number} of pixels."," * `height` The {Number} of pixels."],"params":["width","height"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"setPosition","line":707,"func_location":"AtomEnvironment.setWindowDimensions","func_start_line":701,"func_end_line":712,"args":[null],"comment":[" Set the dimensions of the window.",""," The window will be centered if either the x or y coordinate is not set"," in the dimensions parameter. If x or y are omitted the window will be"," centered. If height or width are omitted only the position will be changed.",""," * `dimensions` An {Object} with the following keys:","   * `x` The new x coordinate.","   * `y` The new y coordinate.","   * `width` The new width.","   * `height` The new height."],"code":"  setWindowDimensions ({x, y, width, height}) {\r\n    const steps = []\r\n    if (width != null && height != null) {\r\n      steps.push(this.setSize(width, height))\r\n    }\r\n    if (x != null && y != null) {\r\n      steps.push(this.setPosition(x, y))\r\n    } else {\r\n      steps.push(this.center())\r\n    }\r\n    return Promise.all(steps)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.setPosition","start_line":591,"end_line":593,"comment":[" Essential: Set the position of current window.",""," * `x` The {Number} of pixels."," * `y` The {Number} of pixels."],"params":["x","y"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"center","line":709,"func_location":"AtomEnvironment.setWindowDimensions","func_start_line":701,"func_end_line":712,"args":[null],"comment":[" Set the dimensions of the window.",""," The window will be centered if either the x or y coordinate is not set"," in the dimensions parameter. If x or y are omitted the window will be"," centered. If height or width are omitted only the position will be changed.",""," * `dimensions` An {Object} with the following keys:","   * `x` The new x coordinate.","   * `y` The new y coordinate.","   * `width` The new width.","   * `height` The new height."],"code":"  setWindowDimensions ({x, y, width, height}) {\r\n    const steps = []\r\n    if (width != null && height != null) {\r\n      steps.push(this.setSize(width, height))\r\n    }\r\n    if (x != null && y != null) {\r\n      steps.push(this.setPosition(x, y))\r\n    } else {\r\n      steps.push(this.center())\r\n    }\r\n    return Promise.all(steps)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.center","start_line":601,"end_line":603,"comment":[" Extended: Move current window to the center of the screen."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"isModified","line":1188,"func_location":"TextEditor.shouldPromptToSave","func_start_line":1184,"func_end_line":1190,"args":[],"comment":[" Determine whether the user should be prompted to save before closing"," this editor."],"code":"  shouldPromptToSave ({windowCloseRequested, projectHasPaths} = {}) {\r\n    if (windowCloseRequested && projectHasPaths && atom.stateStore.isConnected()) {\r\n      return this.buffer.isInConflict()\r\n    } else {\r\n      return this.isModified() && !this.buffer.hasMultipleEditors()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.isModified","start_line":1161,"end_line":1161,"comment":[" Essential: Returns {Boolean} `true` if this editor has been modified."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"activationShouldBeDeferred","line":155,"func_location":"Package.shouldRequireMainModuleOnLoad","func_start_line":150,"func_end_line":158,"args":[],"code":"  shouldRequireMainModuleOnLoad () {\r\n    return !(\r\n      this.metadata.deserializers ||\r\n      this.metadata.viewProviders ||\r\n      this.metadata.configSchema ||\r\n      this.activationShouldBeDeferred() ||\r\n      localStorage.getItem(this.getCanDeferMainModuleRequireStorageKey()) === 'true'\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.activationShouldBeDeferred","start_line":805,"end_line":807,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"getCanDeferMainModuleRequireStorageKey","line":156,"func_location":"Package.shouldRequireMainModuleOnLoad","func_start_line":150,"func_end_line":158,"args":[null],"code":"  shouldRequireMainModuleOnLoad () {\r\n    return !(\r\n      this.metadata.deserializers ||\r\n      this.metadata.viewProviders ||\r\n      this.metadata.configSchema ||\r\n      this.activationShouldBeDeferred() ||\r\n      localStorage.getItem(this.getCanDeferMainModuleRequireStorageKey()) === 'true'\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.getCanDeferMainModuleRequireStorageKey","start_line":1041,"end_line":1043,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"arraysEqual","line":3890,"func_location":"LinesTileComponent.shouldUpdate","func_start_line":3882,"func_end_line":3925,"args":["oldProps.screenLines","newProps.screenLines"],"code":"  shouldUpdate (newProps) {\r\n    const oldProps = this.props\r\n    if (oldProps.top !== newProps.top) return true\r\n    if (oldProps.height !== newProps.height) return true\r\n    if (oldProps.width !== newProps.width) return true\r\n    if (oldProps.lineHeight !== newProps.lineHeight) return true\r\n    if (oldProps.tileStartRow !== newProps.tileStartRow) return true\r\n    if (oldProps.tileEndRow !== newProps.tileEndRow) return true\r\n    if (!arraysEqual(oldProps.screenLines, newProps.screenLines)) return true\r\n    if (!arraysEqual(oldProps.lineDecorations, newProps.lineDecorations)) return true\r\n\r\n    if (oldProps.blockDecorations && newProps.blockDecorations) {\r\n      if (oldProps.blockDecorations.size !== newProps.blockDecorations.size) return true\r\n\r\n      let blockDecorationsChanged = false\r\n\r\n      oldProps.blockDecorations.forEach((oldDecorations, screenLineId) => {\r\n        if (!blockDecorationsChanged) {\r\n          const newDecorations = newProps.blockDecorations.get(screenLineId)\r\n          blockDecorationsChanged = (newDecorations == null || !arraysEqual(oldDecorations, newDecorations))\r\n        }\r\n      })\r\n      if (blockDecorationsChanged) return true\r\n\r\n      newProps.blockDecorations.forEach((newDecorations, screenLineId) => {\r\n        if (!blockDecorationsChanged) {\r\n          const oldDecorations = oldProps.blockDecorations.get(screenLineId)\r\n          blockDecorationsChanged = (oldDecorations == null)\r\n        }\r\n      })\r\n      if (blockDecorationsChanged) return true\r\n    } else if (oldProps.blockDecorations) {\r\n      return true\r\n    } else if (newProps.blockDecorations) {\r\n      return true\r\n    }\r\n\r\n    if (oldProps.textDecorations.length !== newProps.textDecorations.length) return true\r\n    for (let i = 0; i < oldProps.textDecorations.length; i++) {\r\n      if (!textDecorationsEqual(oldProps.textDecorations[i], newProps.textDecorations[i])) return true\r\n    }\r\n\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"arraysEqual","start_line":4356,"end_line":4362,"comment":[],"params":["a","b"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"arraysEqual","line":3891,"func_location":"LinesTileComponent.shouldUpdate","func_start_line":3882,"func_end_line":3925,"args":["oldProps.lineDecorations","newProps.lineDecorations"],"code":"  shouldUpdate (newProps) {\r\n    const oldProps = this.props\r\n    if (oldProps.top !== newProps.top) return true\r\n    if (oldProps.height !== newProps.height) return true\r\n    if (oldProps.width !== newProps.width) return true\r\n    if (oldProps.lineHeight !== newProps.lineHeight) return true\r\n    if (oldProps.tileStartRow !== newProps.tileStartRow) return true\r\n    if (oldProps.tileEndRow !== newProps.tileEndRow) return true\r\n    if (!arraysEqual(oldProps.screenLines, newProps.screenLines)) return true\r\n    if (!arraysEqual(oldProps.lineDecorations, newProps.lineDecorations)) return true\r\n\r\n    if (oldProps.blockDecorations && newProps.blockDecorations) {\r\n      if (oldProps.blockDecorations.size !== newProps.blockDecorations.size) return true\r\n\r\n      let blockDecorationsChanged = false\r\n\r\n      oldProps.blockDecorations.forEach((oldDecorations, screenLineId) => {\r\n        if (!blockDecorationsChanged) {\r\n          const newDecorations = newProps.blockDecorations.get(screenLineId)\r\n          blockDecorationsChanged = (newDecorations == null || !arraysEqual(oldDecorations, newDecorations))\r\n        }\r\n      })\r\n      if (blockDecorationsChanged) return true\r\n\r\n      newProps.blockDecorations.forEach((newDecorations, screenLineId) => {\r\n        if (!blockDecorationsChanged) {\r\n          const oldDecorations = oldProps.blockDecorations.get(screenLineId)\r\n          blockDecorationsChanged = (oldDecorations == null)\r\n        }\r\n      })\r\n      if (blockDecorationsChanged) return true\r\n    } else if (oldProps.blockDecorations) {\r\n      return true\r\n    } else if (newProps.blockDecorations) {\r\n      return true\r\n    }\r\n\r\n    if (oldProps.textDecorations.length !== newProps.textDecorations.length) return true\r\n    for (let i = 0; i < oldProps.textDecorations.length; i++) {\r\n      if (!textDecorationsEqual(oldProps.textDecorations[i], newProps.textDecorations[i])) return true\r\n    }\r\n\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"arraysEqual","start_line":4356,"end_line":4362,"comment":[],"params":["a","b"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"textDecorationsEqual","line":3921,"func_location":"LinesTileComponent.shouldUpdate","func_start_line":3882,"func_end_line":3925,"args":["oldProps.textDecorations.i","newProps.textDecorations.i"],"code":"  shouldUpdate (newProps) {\r\n    const oldProps = this.props\r\n    if (oldProps.top !== newProps.top) return true\r\n    if (oldProps.height !== newProps.height) return true\r\n    if (oldProps.width !== newProps.width) return true\r\n    if (oldProps.lineHeight !== newProps.lineHeight) return true\r\n    if (oldProps.tileStartRow !== newProps.tileStartRow) return true\r\n    if (oldProps.tileEndRow !== newProps.tileEndRow) return true\r\n    if (!arraysEqual(oldProps.screenLines, newProps.screenLines)) return true\r\n    if (!arraysEqual(oldProps.lineDecorations, newProps.lineDecorations)) return true\r\n\r\n    if (oldProps.blockDecorations && newProps.blockDecorations) {\r\n      if (oldProps.blockDecorations.size !== newProps.blockDecorations.size) return true\r\n\r\n      let blockDecorationsChanged = false\r\n\r\n      oldProps.blockDecorations.forEach((oldDecorations, screenLineId) => {\r\n        if (!blockDecorationsChanged) {\r\n          const newDecorations = newProps.blockDecorations.get(screenLineId)\r\n          blockDecorationsChanged = (newDecorations == null || !arraysEqual(oldDecorations, newDecorations))\r\n        }\r\n      })\r\n      if (blockDecorationsChanged) return true\r\n\r\n      newProps.blockDecorations.forEach((newDecorations, screenLineId) => {\r\n        if (!blockDecorationsChanged) {\r\n          const oldDecorations = oldProps.blockDecorations.get(screenLineId)\r\n          blockDecorationsChanged = (oldDecorations == null)\r\n        }\r\n      })\r\n      if (blockDecorationsChanged) return true\r\n    } else if (oldProps.blockDecorations) {\r\n      return true\r\n    } else if (newProps.blockDecorations) {\r\n      return true\r\n    }\r\n\r\n    if (oldProps.textDecorations.length !== newProps.textDecorations.length) return true\r\n    for (let i = 0; i < oldProps.textDecorations.length; i++) {\r\n      if (!textDecorationsEqual(oldProps.textDecorations[i], newProps.textDecorations[i])) return true\r\n    }\r\n\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"textDecorationsEqual","start_line":4342,"end_line":4354,"comment":[],"params":["oldDecorations","newDecorations"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"arraysEqual","line":3323,"func_location":"LineNumberGutterComponent.shouldUpdate","func_start_line":3309,"func_end_line":3365,"args":["oldProps.keys","newProps.keys"],"code":"  shouldUpdate (newProps) {\r\n    const oldProps = this.props\r\n\r\n    if (oldProps.showLineNumbers !== newProps.showLineNumbers) return true\r\n    if (oldProps.height !== newProps.height) return true\r\n    if (oldProps.width !== newProps.width) return true\r\n    if (oldProps.lineHeight !== newProps.lineHeight) return true\r\n    if (oldProps.startRow !== newProps.startRow) return true\r\n    if (oldProps.endRow !== newProps.endRow) return true\r\n    if (oldProps.rowsPerTile !== newProps.rowsPerTile) return true\r\n    if (oldProps.maxDigits !== newProps.maxDigits) return true\r\n    if (oldProps.labelFn !== newProps.labelFn) return true\r\n    if (oldProps.className !== newProps.className) return true\r\n    if (newProps.didMeasureVisibleBlockDecoration) return true\r\n    if (!arraysEqual(oldProps.keys, newProps.keys)) return true\r\n    if (!arraysEqual(oldProps.bufferRows, newProps.bufferRows)) return true\r\n    if (!arraysEqual(oldProps.foldableFlags, newProps.foldableFlags)) return true\r\n    if (!arraysEqual(oldProps.decorations, newProps.decorations)) return true\r\n\r\n    let oldTileStartRow = oldProps.startRow\r\n    let newTileStartRow = newProps.startRow\r\n    while (oldTileStartRow < oldProps.endRow || newTileStartRow < newProps.endRow) {\r\n      let oldTileBlockDecorations = oldProps.blockDecorations.get(oldTileStartRow)\r\n      let newTileBlockDecorations = newProps.blockDecorations.get(newTileStartRow)\r\n\r\n      if (oldTileBlockDecorations && newTileBlockDecorations) {\r\n        if (oldTileBlockDecorations.size !== newTileBlockDecorations.size) return true\r\n\r\n        let blockDecorationsChanged = false\r\n\r\n        oldTileBlockDecorations.forEach((oldDecorations, screenLineId) => {\r\n          if (!blockDecorationsChanged) {\r\n            const newDecorations = newTileBlockDecorations.get(screenLineId)\r\n            blockDecorationsChanged = (newDecorations == null || !arraysEqual(oldDecorations, newDecorations))\r\n          }\r\n        })\r\n        if (blockDecorationsChanged) return true\r\n\r\n        newTileBlockDecorations.forEach((newDecorations, screenLineId) => {\r\n          if (!blockDecorationsChanged) {\r\n            const oldDecorations = oldTileBlockDecorations.get(screenLineId)\r\n            blockDecorationsChanged = (oldDecorations == null)\r\n          }\r\n        })\r\n        if (blockDecorationsChanged) return true\r\n      } else if (oldTileBlockDecorations) {\r\n        return true\r\n      } else if (newTileBlockDecorations) {\r\n        return true\r\n      }\r\n\r\n      oldTileStartRow += oldProps.rowsPerTile\r\n      newTileStartRow += newProps.rowsPerTile\r\n    }\r\n\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"arraysEqual","start_line":4356,"end_line":4362,"comment":[],"params":["a","b"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"arraysEqual","line":3324,"func_location":"LineNumberGutterComponent.shouldUpdate","func_start_line":3309,"func_end_line":3365,"args":["oldProps.bufferRows","newProps.bufferRows"],"code":"  shouldUpdate (newProps) {\r\n    const oldProps = this.props\r\n\r\n    if (oldProps.showLineNumbers !== newProps.showLineNumbers) return true\r\n    if (oldProps.height !== newProps.height) return true\r\n    if (oldProps.width !== newProps.width) return true\r\n    if (oldProps.lineHeight !== newProps.lineHeight) return true\r\n    if (oldProps.startRow !== newProps.startRow) return true\r\n    if (oldProps.endRow !== newProps.endRow) return true\r\n    if (oldProps.rowsPerTile !== newProps.rowsPerTile) return true\r\n    if (oldProps.maxDigits !== newProps.maxDigits) return true\r\n    if (oldProps.labelFn !== newProps.labelFn) return true\r\n    if (oldProps.className !== newProps.className) return true\r\n    if (newProps.didMeasureVisibleBlockDecoration) return true\r\n    if (!arraysEqual(oldProps.keys, newProps.keys)) return true\r\n    if (!arraysEqual(oldProps.bufferRows, newProps.bufferRows)) return true\r\n    if (!arraysEqual(oldProps.foldableFlags, newProps.foldableFlags)) return true\r\n    if (!arraysEqual(oldProps.decorations, newProps.decorations)) return true\r\n\r\n    let oldTileStartRow = oldProps.startRow\r\n    let newTileStartRow = newProps.startRow\r\n    while (oldTileStartRow < oldProps.endRow || newTileStartRow < newProps.endRow) {\r\n      let oldTileBlockDecorations = oldProps.blockDecorations.get(oldTileStartRow)\r\n      let newTileBlockDecorations = newProps.blockDecorations.get(newTileStartRow)\r\n\r\n      if (oldTileBlockDecorations && newTileBlockDecorations) {\r\n        if (oldTileBlockDecorations.size !== newTileBlockDecorations.size) return true\r\n\r\n        let blockDecorationsChanged = false\r\n\r\n        oldTileBlockDecorations.forEach((oldDecorations, screenLineId) => {\r\n          if (!blockDecorationsChanged) {\r\n            const newDecorations = newTileBlockDecorations.get(screenLineId)\r\n            blockDecorationsChanged = (newDecorations == null || !arraysEqual(oldDecorations, newDecorations))\r\n          }\r\n        })\r\n        if (blockDecorationsChanged) return true\r\n\r\n        newTileBlockDecorations.forEach((newDecorations, screenLineId) => {\r\n          if (!blockDecorationsChanged) {\r\n            const oldDecorations = oldTileBlockDecorations.get(screenLineId)\r\n            blockDecorationsChanged = (oldDecorations == null)\r\n          }\r\n        })\r\n        if (blockDecorationsChanged) return true\r\n      } else if (oldTileBlockDecorations) {\r\n        return true\r\n      } else if (newTileBlockDecorations) {\r\n        return true\r\n      }\r\n\r\n      oldTileStartRow += oldProps.rowsPerTile\r\n      newTileStartRow += newProps.rowsPerTile\r\n    }\r\n\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"arraysEqual","start_line":4356,"end_line":4362,"comment":[],"params":["a","b"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"arraysEqual","line":3325,"func_location":"LineNumberGutterComponent.shouldUpdate","func_start_line":3309,"func_end_line":3365,"args":["oldProps.foldableFlags","newProps.foldableFlags"],"code":"  shouldUpdate (newProps) {\r\n    const oldProps = this.props\r\n\r\n    if (oldProps.showLineNumbers !== newProps.showLineNumbers) return true\r\n    if (oldProps.height !== newProps.height) return true\r\n    if (oldProps.width !== newProps.width) return true\r\n    if (oldProps.lineHeight !== newProps.lineHeight) return true\r\n    if (oldProps.startRow !== newProps.startRow) return true\r\n    if (oldProps.endRow !== newProps.endRow) return true\r\n    if (oldProps.rowsPerTile !== newProps.rowsPerTile) return true\r\n    if (oldProps.maxDigits !== newProps.maxDigits) return true\r\n    if (oldProps.labelFn !== newProps.labelFn) return true\r\n    if (oldProps.className !== newProps.className) return true\r\n    if (newProps.didMeasureVisibleBlockDecoration) return true\r\n    if (!arraysEqual(oldProps.keys, newProps.keys)) return true\r\n    if (!arraysEqual(oldProps.bufferRows, newProps.bufferRows)) return true\r\n    if (!arraysEqual(oldProps.foldableFlags, newProps.foldableFlags)) return true\r\n    if (!arraysEqual(oldProps.decorations, newProps.decorations)) return true\r\n\r\n    let oldTileStartRow = oldProps.startRow\r\n    let newTileStartRow = newProps.startRow\r\n    while (oldTileStartRow < oldProps.endRow || newTileStartRow < newProps.endRow) {\r\n      let oldTileBlockDecorations = oldProps.blockDecorations.get(oldTileStartRow)\r\n      let newTileBlockDecorations = newProps.blockDecorations.get(newTileStartRow)\r\n\r\n      if (oldTileBlockDecorations && newTileBlockDecorations) {\r\n        if (oldTileBlockDecorations.size !== newTileBlockDecorations.size) return true\r\n\r\n        let blockDecorationsChanged = false\r\n\r\n        oldTileBlockDecorations.forEach((oldDecorations, screenLineId) => {\r\n          if (!blockDecorationsChanged) {\r\n            const newDecorations = newTileBlockDecorations.get(screenLineId)\r\n            blockDecorationsChanged = (newDecorations == null || !arraysEqual(oldDecorations, newDecorations))\r\n          }\r\n        })\r\n        if (blockDecorationsChanged) return true\r\n\r\n        newTileBlockDecorations.forEach((newDecorations, screenLineId) => {\r\n          if (!blockDecorationsChanged) {\r\n            const oldDecorations = oldTileBlockDecorations.get(screenLineId)\r\n            blockDecorationsChanged = (oldDecorations == null)\r\n          }\r\n        })\r\n        if (blockDecorationsChanged) return true\r\n      } else if (oldTileBlockDecorations) {\r\n        return true\r\n      } else if (newTileBlockDecorations) {\r\n        return true\r\n      }\r\n\r\n      oldTileStartRow += oldProps.rowsPerTile\r\n      newTileStartRow += newProps.rowsPerTile\r\n    }\r\n\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"arraysEqual","start_line":4356,"end_line":4362,"comment":[],"params":["a","b"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"arraysEqual","line":3326,"func_location":"LineNumberGutterComponent.shouldUpdate","func_start_line":3309,"func_end_line":3365,"args":["oldProps.decorations","newProps.decorations"],"code":"  shouldUpdate (newProps) {\r\n    const oldProps = this.props\r\n\r\n    if (oldProps.showLineNumbers !== newProps.showLineNumbers) return true\r\n    if (oldProps.height !== newProps.height) return true\r\n    if (oldProps.width !== newProps.width) return true\r\n    if (oldProps.lineHeight !== newProps.lineHeight) return true\r\n    if (oldProps.startRow !== newProps.startRow) return true\r\n    if (oldProps.endRow !== newProps.endRow) return true\r\n    if (oldProps.rowsPerTile !== newProps.rowsPerTile) return true\r\n    if (oldProps.maxDigits !== newProps.maxDigits) return true\r\n    if (oldProps.labelFn !== newProps.labelFn) return true\r\n    if (oldProps.className !== newProps.className) return true\r\n    if (newProps.didMeasureVisibleBlockDecoration) return true\r\n    if (!arraysEqual(oldProps.keys, newProps.keys)) return true\r\n    if (!arraysEqual(oldProps.bufferRows, newProps.bufferRows)) return true\r\n    if (!arraysEqual(oldProps.foldableFlags, newProps.foldableFlags)) return true\r\n    if (!arraysEqual(oldProps.decorations, newProps.decorations)) return true\r\n\r\n    let oldTileStartRow = oldProps.startRow\r\n    let newTileStartRow = newProps.startRow\r\n    while (oldTileStartRow < oldProps.endRow || newTileStartRow < newProps.endRow) {\r\n      let oldTileBlockDecorations = oldProps.blockDecorations.get(oldTileStartRow)\r\n      let newTileBlockDecorations = newProps.blockDecorations.get(newTileStartRow)\r\n\r\n      if (oldTileBlockDecorations && newTileBlockDecorations) {\r\n        if (oldTileBlockDecorations.size !== newTileBlockDecorations.size) return true\r\n\r\n        let blockDecorationsChanged = false\r\n\r\n        oldTileBlockDecorations.forEach((oldDecorations, screenLineId) => {\r\n          if (!blockDecorationsChanged) {\r\n            const newDecorations = newTileBlockDecorations.get(screenLineId)\r\n            blockDecorationsChanged = (newDecorations == null || !arraysEqual(oldDecorations, newDecorations))\r\n          }\r\n        })\r\n        if (blockDecorationsChanged) return true\r\n\r\n        newTileBlockDecorations.forEach((newDecorations, screenLineId) => {\r\n          if (!blockDecorationsChanged) {\r\n            const oldDecorations = oldTileBlockDecorations.get(screenLineId)\r\n            blockDecorationsChanged = (oldDecorations == null)\r\n          }\r\n        })\r\n        if (blockDecorationsChanged) return true\r\n      } else if (oldTileBlockDecorations) {\r\n        return true\r\n      } else if (newTileBlockDecorations) {\r\n        return true\r\n      }\r\n\r\n      oldTileStartRow += oldProps.rowsPerTile\r\n      newTileStartRow += newProps.rowsPerTile\r\n    }\r\n\r\n    return false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"arraysEqual","start_line":4356,"end_line":4362,"comment":[],"params":["a","b"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"setState","line":120,"func_location":"Dock.show","func_start_line":119,"func_end_line":121,"args":[null],"comment":[" Extended: Show the dock without focusing it."],"code":"  show () {\r\n    this.setState({visible: true})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.setState","start_line":144,"end_line":177,"comment":[],"params":["newState"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js","name":"getCurrentWindow","line":252,"func_location":"ApplicationDelegate.showSaveDialog","func_start_line":249,"func_end_line":260,"args":["options","callback"],"code":"  showSaveDialog (options, callback) {\r\n    if (typeof callback === 'function') {\r\n      // Async\r\n      this.getCurrentWindow().showSaveDialog(options, callback)\r\n    } else {\r\n      // Sync\r\n      if (typeof options === 'string') {\r\n        options = {defaultPath: options}\r\n      }\r\n      return this.getCurrentWindow().showSaveDialog(options)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js","name":"ApplicationDelegate.getCurrentWindow","start_line":38,"end_line":40,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js","name":"getCurrentWindow","line":258,"func_location":"ApplicationDelegate.showSaveDialog","func_start_line":249,"func_end_line":260,"args":["options"],"code":"  showSaveDialog (options, callback) {\r\n    if (typeof callback === 'function') {\r\n      // Async\r\n      this.getCurrentWindow().showSaveDialog(options, callback)\r\n    } else {\r\n      // Sync\r\n      if (typeof options === 'string') {\r\n        options = {defaultPath: options}\r\n      }\r\n      return this.getCurrentWindow().showSaveDialog(options)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js","name":"ApplicationDelegate.getCurrentWindow","start_line":38,"end_line":40,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"flattenMenuItems","line":110,"func_location":"ApplicationMenu.showUpdateMenuItem","func_start_line":109,"func_end_line":140,"args":[".menu"],"comment":[" Sets the proper visible state the update menu items"],"code":"  showUpdateMenuItem (state) {\r\n    const items = this.flattenMenuItems(this.menu)\r\n    const checkForUpdateItem = items.find(({label}) => label === 'Check for Update')\r\n    const checkingForUpdateItem = items.find(({label}) => label === 'Checking for Update')\r\n    const downloadingUpdateItem = items.find(({label}) => label === 'Downloading Update')\r\n    const installUpdateItem = items.find(({label}) => label === 'Restart and Install Update')\r\n\r\n    if (!checkForUpdateItem || !checkingForUpdateItem ||\r\n        !downloadingUpdateItem || !installUpdateItem) return\r\n\r\n    checkForUpdateItem.visible = false\r\n    checkingForUpdateItem.visible = false\r\n    downloadingUpdateItem.visible = false\r\n    installUpdateItem.visible = false\r\n\r\n    switch (state) {\r\n      case 'idle':\r\n      case 'error':\r\n      case 'no-update-available':\r\n        checkForUpdateItem.visible = true\r\n        break\r\n      case 'checking':\r\n        checkingForUpdateItem.visible = true\r\n        break\r\n      case 'downloading':\r\n        downloadingUpdateItem.visible = true\r\n        break\r\n      case 'update-available':\r\n        installUpdateItem.visible = true\r\n        break\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"ApplicationMenu.flattenMenuItems","start_line":67,"end_line":76,"comment":[" Flattens the given menu and submenu items into an single Array.",""," menu - A complete menu configuration object for atom-shell's menu API.",""," Returns an Array of native menu items."],"params":["menu"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getBufferPosition","line":431,"func_location":"Cursor.skipLeadingWhitespace","func_start_line":430,"func_end_line":439,"args":[],"comment":[" Public: Moves the cursor to the beginning of the buffer line, skipping all"," whitespace."],"code":"  skipLeadingWhitespace () {\r\n    const position = this.getBufferPosition()\r\n    const scanRange = this.getCurrentLineBufferRange()\r\n    let endOfLeadingWhitespace = null\r\n    this.editor.scanInBufferRange(/^[ \\t]*/, scanRange, ({range}) => {\r\n      endOfLeadingWhitespace = range.end\r\n    })\r\n\r\n    if (endOfLeadingWhitespace.isGreaterThan(position)) this.setBufferPosition(endOfLeadingWhitespace)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getBufferPosition","start_line":91,"end_line":93,"comment":[" Public: Returns the current buffer position as an Array."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getCurrentLineBufferRange","line":432,"func_location":"Cursor.skipLeadingWhitespace","func_start_line":430,"func_end_line":439,"args":[],"comment":[" Public: Moves the cursor to the beginning of the buffer line, skipping all"," whitespace."],"code":"  skipLeadingWhitespace () {\r\n    const position = this.getBufferPosition()\r\n    const scanRange = this.getCurrentLineBufferRange()\r\n    let endOfLeadingWhitespace = null\r\n    this.editor.scanInBufferRange(/^[ \\t]*/, scanRange, ({range}) => {\r\n      endOfLeadingWhitespace = range.end\r\n    })\r\n\r\n    if (endOfLeadingWhitespace.isGreaterThan(position)) this.setBufferPosition(endOfLeadingWhitespace)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getCurrentLineBufferRange","start_line":623,"end_line":625,"comment":[" Public: Returns the buffer Range for the current line.",""," * `options` (optional) {Object}","   * `includeNewline` A {Boolean} which controls whether the Range should","     include the newline."],"params":["options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"setBufferPosition","line":438,"func_location":"Cursor.skipLeadingWhitespace","func_start_line":430,"func_end_line":439,"args":["position"],"comment":[" Public: Moves the cursor to the beginning of the buffer line, skipping all"," whitespace."],"code":"  skipLeadingWhitespace () {\r\n    const position = this.getBufferPosition()\r\n    const scanRange = this.getCurrentLineBufferRange()\r\n    let endOfLeadingWhitespace = null\r\n    this.editor.scanInBufferRange(/^[ \\t]*/, scanRange, ({range}) => {\r\n      endOfLeadingWhitespace = range.end\r\n    })\r\n\r\n    if (endOfLeadingWhitespace.isGreaterThan(position)) this.setBufferPosition(endOfLeadingWhitespace)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.setBufferPosition","start_line":84,"end_line":88,"comment":[" Public: Moves a cursor to a given buffer position.",""," * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column."," * `options` (optional) {Object} with the following keys:","   * `autoscroll` {Boolean} indicating whether to autoscroll to the new","     position. Defaults to `true` if this is the most recently added cursor,","     `false` otherwise."],"params":["bufferPosition","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js","name":"findEdgesInGroup","line":161,"func_location":"sortGroups","func_start_line":156,"func_end_line":166,"args":["groups","i","edges"],"code":"function sortGroups (groups) {\r\n  const originalOrder = groups.map((item, i) => i)\r\n  const edges = new Map()\r\n\r\n  for (let i = 0; i < groups.length; i++) {\r\n    findEdgesInGroup(groups, i, edges)\r\n  }\r\n\r\n  const sortedGroupIndexes = sortTopologically(originalOrder, edges)\r\n  return sortedGroupIndexes.map(i => groups[i])\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js","name":"findEdgesInGroup","start_line":132,"end_line":154,"comment":[],"params":["groups","i","edges"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js","name":"sortTopologically","line":164,"func_location":"sortGroups","func_start_line":156,"func_end_line":166,"args":["originalOrder","edges"],"code":"function sortGroups (groups) {\r\n  const originalOrder = groups.map((item, i) => i)\r\n  const edges = new Map()\r\n\r\n  for (let i = 0; i < groups.length; i++) {\r\n    findEdgesInGroup(groups, i, edges)\r\n  }\r\n\r\n  const sortedGroupIndexes = sortTopologically(originalOrder, edges)\r\n  return sortedGroupIndexes.map(i => groups[i])\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js","name":"sortTopologically","start_line":49,"end_line":69,"comment":[" Sort nodes topologically using a depth-first approach. Encountered cycles"," are broken."],"params":["originalOrder","edgesById"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js","name":"sortTopologically","line":127,"func_location":"sortItemsInGroup","func_start_line":103,"func_end_line":130,"args":["originalOrder","edges"],"code":"function sortItemsInGroup (group) {\r\n  const originalOrder = group.map((node, i) => i)\r\n  const edges = new Map()\r\n  const commandToIndex = new Map(group.map((item, i) => [item.command, i]))\r\n\r\n  group.forEach((item, i) => {\r\n    if (item.before) {\r\n      item.before.forEach(toCommand => {\r\n        const to = commandToIndex.get(toCommand)\r\n        if (to != null) {\r\n          pushOntoMultiMap(edges, to, i)\r\n        }\r\n      })\r\n    }\r\n    if (item.after) {\r\n      item.after.forEach(toCommand => {\r\n        const to = commandToIndex.get(toCommand)\r\n        if (to != null) {\r\n          pushOntoMultiMap(edges, i, to)\r\n        }\r\n      })\r\n    }\r\n  })\r\n\r\n  const sortedNodes = sortTopologically(originalOrder, edges)\r\n\r\n  return sortedNodes.map(i => group[i])\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js","name":"sortTopologically","start_line":49,"end_line":69,"comment":[" Sort nodes topologically using a depth-first approach. Encountered cycles"," are broken."],"params":["originalOrder","edgesById"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js","name":"splitArray","line":174,"func_location":"sortMenuItems","func_start_line":172,"func_end_line":184,"args":["menuItems","isSeparator"],"code":"function sortMenuItems (menuItems) {\r\n  // Split the items into their implicit groups based upon separators.\r\n  const groups = splitArray(menuItems, isSeparator)\r\n  // Merge groups that contain before/after references to eachother.\r\n  const mergedGroups = mergeGroups(groups)\r\n  // Sort each individual group internally.\r\n  const mergedGroupsWithSortedItems = mergedGroups.map(sortItemsInGroup)\r\n  // Sort the groups based upon their beforeGroupContaining/afterGroupContaining\r\n  // references.\r\n  const sortedGroups = sortGroups(mergedGroupsWithSortedItems)\r\n  // Join the groups back\r\n  return joinArrays(sortedGroups, { type: 'separator' })\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js","name":"splitArray","start_line":3,"end_line":17,"comment":[" UTILS"],"params":["arr","predicate"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js","name":"mergeGroups","line":176,"func_location":"sortMenuItems","func_start_line":172,"func_end_line":184,"args":["groups"],"code":"function sortMenuItems (menuItems) {\r\n  // Split the items into their implicit groups based upon separators.\r\n  const groups = splitArray(menuItems, isSeparator)\r\n  // Merge groups that contain before/after references to eachother.\r\n  const mergedGroups = mergeGroups(groups)\r\n  // Sort each individual group internally.\r\n  const mergedGroupsWithSortedItems = mergedGroups.map(sortItemsInGroup)\r\n  // Sort the groups based upon their beforeGroupContaining/afterGroupContaining\r\n  // references.\r\n  const sortedGroups = sortGroups(mergedGroupsWithSortedItems)\r\n  // Join the groups back\r\n  return joinArrays(sortedGroups, { type: 'separator' })\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js","name":"mergeGroups","start_line":95,"end_line":101,"comment":[" Merge groups based on before/after positions"," Mutates both the array of groups, and the individual group arrays."],"params":["groups"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js","name":"sortGroups","line":181,"func_location":"sortMenuItems","func_start_line":172,"func_end_line":184,"args":["mergedGroupsWithSortedItems"],"code":"function sortMenuItems (menuItems) {\r\n  // Split the items into their implicit groups based upon separators.\r\n  const groups = splitArray(menuItems, isSeparator)\r\n  // Merge groups that contain before/after references to eachother.\r\n  const mergedGroups = mergeGroups(groups)\r\n  // Sort each individual group internally.\r\n  const mergedGroupsWithSortedItems = mergedGroups.map(sortItemsInGroup)\r\n  // Sort the groups based upon their beforeGroupContaining/afterGroupContaining\r\n  // references.\r\n  const sortedGroups = sortGroups(mergedGroupsWithSortedItems)\r\n  // Join the groups back\r\n  return joinArrays(sortedGroups, { type: 'separator' })\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js","name":"sortGroups","start_line":156,"end_line":166,"comment":[],"params":["groups"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js","name":"joinArrays","line":183,"func_location":"sortMenuItems","func_start_line":172,"func_end_line":184,"args":["sortedGroups",null],"code":"function sortMenuItems (menuItems) {\r\n  // Split the items into their implicit groups based upon separators.\r\n  const groups = splitArray(menuItems, isSeparator)\r\n  // Merge groups that contain before/after references to eachother.\r\n  const mergedGroups = mergeGroups(groups)\r\n  // Sort each individual group internally.\r\n  const mergedGroupsWithSortedItems = mergedGroups.map(sortItemsInGroup)\r\n  // Sort the groups based upon their beforeGroupContaining/afterGroupContaining\r\n  // references.\r\n  const sortedGroups = sortGroups(mergedGroupsWithSortedItems)\r\n  // Join the groups back\r\n  return joinArrays(sortedGroups, { type: 'separator' })\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js","name":"joinArrays","start_line":19,"end_line":28,"comment":[],"params":["arrays","joiner"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"spawn","line":102,"func_location":"BufferedProcess.spawnWithEscapedWindowsArgs","func_start_line":79,"func_end_line":103,"args":[null,null,"cmdOptions"],"comment":[" Windows has a bunch of special rules that node still doesn't take care of for you"],"code":"  spawnWithEscapedWindowsArgs (command, args, options) {\r\n    let cmdArgs = []\r\n    // Quote all arguments and escapes inner quotes\r\n    if (args) {\r\n      cmdArgs = args.filter((arg) => arg != null)\r\n        .map((arg) => {\r\n          if (this.isExplorerCommand(command) && /^\\/[a-zA-Z]+,.*$/.test(arg)) {\r\n            // Don't wrap /root,C:\\folder style arguments to explorer calls in\r\n            // quotes since they will not be interpreted correctly if they are\r\n            return arg\r\n          } else {\r\n            // Escape double quotes by putting a backslash in front of them\r\n            return `\\\"${arg.toString().replace(/\"/g, '\\\\\"')}\\\"`\r\n          }\r\n        })\r\n    }\r\n\r\n    // The command itself is quoted if it contains spaces, &, ^, | or # chars\r\n    cmdArgs.unshift(/\\s|&|\\^|\\(|\\)|\\||#/.test(command) ? `\\\"${command}\\\"` : command)\r\n\r\n    const cmdOptions = _.clone(options)\r\n    cmdOptions.windowsVerbatimArguments = true\r\n\r\n    this.spawn(this.getCmdPath(), ['/s', '/d', '/c', `\\\"${cmdArgs.join(' ')}\\\"`], cmdOptions)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"BufferedProcess.spawn","start_line":244,"end_line":250,"comment":[],"params":["command","args","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"getCmdPath","line":102,"func_location":"BufferedProcess.spawnWithEscapedWindowsArgs","func_start_line":79,"func_end_line":103,"args":[null,null,"cmdOptions"],"comment":[" Windows has a bunch of special rules that node still doesn't take care of for you"],"code":"  spawnWithEscapedWindowsArgs (command, args, options) {\r\n    let cmdArgs = []\r\n    // Quote all arguments and escapes inner quotes\r\n    if (args) {\r\n      cmdArgs = args.filter((arg) => arg != null)\r\n        .map((arg) => {\r\n          if (this.isExplorerCommand(command) && /^\\/[a-zA-Z]+,.*$/.test(arg)) {\r\n            // Don't wrap /root,C:\\folder style arguments to explorer calls in\r\n            // quotes since they will not be interpreted correctly if they are\r\n            return arg\r\n          } else {\r\n            // Escape double quotes by putting a backslash in front of them\r\n            return `\\\"${arg.toString().replace(/\"/g, '\\\\\"')}\\\"`\r\n          }\r\n        })\r\n    }\r\n\r\n    // The command itself is quoted if it contains spaces, &, ^, | or # chars\r\n    cmdArgs.unshift(/\\s|&|\\^|\\(|\\)|\\||#/.test(command) ? `\\\"${command}\\\"` : command)\r\n\r\n    const cmdOptions = _.clone(options)\r\n    cmdOptions.windowsVerbatimArguments = true\r\n\r\n    this.spawn(this.getCmdPath(), ['/s', '/d', '/c', `\\\"${cmdArgs.join(' ')}\\\"`], cmdOptions)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"BufferedProcess.getCmdPath","start_line":222,"end_line":230,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"copyActiveItem","line":1099,"func_location":"Pane.split","func_start_line":1096,"func_end_line":1130,"args":[null],"code":"  split (orientation, side, params) {\r\n    if (params && params.copyActiveItem) {\r\n      if (!params.items) params.items = []\r\n      params.items.push(this.copyActiveItem())\r\n    }\r\n\r\n    if (this.parent.orientation !== orientation) {\r\n      this.parent.replaceChild(this, new PaneAxis({\r\n        container: this.container,\r\n        orientation,\r\n        children: [this],\r\n        flexScale: this.flexScale},\r\n        this.viewRegistry\r\n      ))\r\n      this.setFlexScale(1)\r\n    }\r\n\r\n    const newPane = new Pane(Object.assign({\r\n      applicationDelegate: this.applicationDelegate,\r\n      notificationManager: this.notificationManager,\r\n      deserializerManager: this.deserializerManager,\r\n      config: this.config,\r\n      viewRegistry: this.viewRegistry\r\n    }, params))\r\n\r\n    switch (side) {\r\n      case 'before': this.parent.insertChildBefore(this, newPane); break\r\n      case 'after': this.parent.insertChildAfter(this, newPane); break\r\n    }\r\n\r\n    if (params && params.moveActiveItem && this.activeItem) this.moveItemToPane(this.activeItem, newPane)\r\n\r\n    newPane.activate()\r\n    return newPane\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.copyActiveItem","start_line":994,"end_line":998,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"setFlexScale","line":1110,"func_location":"Pane.split","func_start_line":1096,"func_end_line":1130,"args":[{"type":"number"}],"code":"  split (orientation, side, params) {\r\n    if (params && params.copyActiveItem) {\r\n      if (!params.items) params.items = []\r\n      params.items.push(this.copyActiveItem())\r\n    }\r\n\r\n    if (this.parent.orientation !== orientation) {\r\n      this.parent.replaceChild(this, new PaneAxis({\r\n        container: this.container,\r\n        orientation,\r\n        children: [this],\r\n        flexScale: this.flexScale},\r\n        this.viewRegistry\r\n      ))\r\n      this.setFlexScale(1)\r\n    }\r\n\r\n    const newPane = new Pane(Object.assign({\r\n      applicationDelegate: this.applicationDelegate,\r\n      notificationManager: this.notificationManager,\r\n      deserializerManager: this.deserializerManager,\r\n      config: this.config,\r\n      viewRegistry: this.viewRegistry\r\n    }, params))\r\n\r\n    switch (side) {\r\n      case 'before': this.parent.insertChildBefore(this, newPane); break\r\n      case 'after': this.parent.insertChildAfter(this, newPane); break\r\n    }\r\n\r\n    if (params && params.moveActiveItem && this.activeItem) this.moveItemToPane(this.activeItem, newPane)\r\n\r\n    newPane.activate()\r\n    return newPane\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.setFlexScale","start_line":150,"end_line":154,"comment":[],"params":["flexScale"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"moveItemToPane","line":1126,"func_location":"Pane.split","func_start_line":1096,"func_end_line":1130,"args":[".activeItem","newPane"],"code":"  split (orientation, side, params) {\r\n    if (params && params.copyActiveItem) {\r\n      if (!params.items) params.items = []\r\n      params.items.push(this.copyActiveItem())\r\n    }\r\n\r\n    if (this.parent.orientation !== orientation) {\r\n      this.parent.replaceChild(this, new PaneAxis({\r\n        container: this.container,\r\n        orientation,\r\n        children: [this],\r\n        flexScale: this.flexScale},\r\n        this.viewRegistry\r\n      ))\r\n      this.setFlexScale(1)\r\n    }\r\n\r\n    const newPane = new Pane(Object.assign({\r\n      applicationDelegate: this.applicationDelegate,\r\n      notificationManager: this.notificationManager,\r\n      deserializerManager: this.deserializerManager,\r\n      config: this.config,\r\n      viewRegistry: this.viewRegistry\r\n    }, params))\r\n\r\n    switch (side) {\r\n      case 'before': this.parent.insertChildBefore(this, newPane); break\r\n      case 'after': this.parent.insertChildAfter(this, newPane); break\r\n    }\r\n\r\n    if (params && params.moveActiveItem && this.activeItem) this.moveItemToPane(this.activeItem, newPane)\r\n\r\n    newPane.activate()\r\n    return newPane\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.moveItemToPane","start_line":733,"end_line":736,"comment":[" Public: Move the given item to the given index on another pane.",""," * `item` The item to move."," * `pane` {Pane} to which to move the item."," * `index` {Number} indicating the index to which to move the item in the","   given pane."],"params":["item","pane","index"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"split","line":1093,"func_location":"Pane.splitDown","func_start_line":1092,"func_end_line":1094,"args":[{"type":"string"},{"type":"string"},"params"],"comment":[" Public: Creates a new pane below the receiver.",""," * `params` (optional) {Object} with the following keys:","   * `items` (optional) {Array} of items to add to the new pane.","   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane",""," Returns the new {Pane}."],"code":"  splitDown (params) {\r\n    return this.split('vertical', 'after', params)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.split","start_line":1096,"end_line":1130,"comment":[],"params":["orientation","side","params"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"split","line":1060,"func_location":"Pane.splitLeft","func_start_line":1059,"func_end_line":1061,"args":[{"type":"string"},{"type":"string"},"params"],"comment":["\r\n  Section: Splitting\r\n  "," Public: Create a new pane to the left of this pane.",""," * `params` (optional) {Object} with the following keys:","   * `items` (optional) {Array} of items to add to the new pane.","   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane",""," Returns the new {Pane}."],"code":"  splitLeft (params) {\r\n    return this.split('horizontal', 'before', params)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.split","start_line":1096,"end_line":1130,"comment":[],"params":["orientation","side","params"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"split","line":1071,"func_location":"Pane.splitRight","func_start_line":1070,"func_end_line":1072,"args":[{"type":"string"},{"type":"string"},"params"],"comment":[" Public: Create a new pane to the right of this pane.",""," * `params` (optional) {Object} with the following keys:","   * `items` (optional) {Array} of items to add to the new pane.","   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane",""," Returns the new {Pane}."],"code":"  splitRight (params) {\r\n    return this.split('horizontal', 'after', params)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.split","start_line":1096,"end_line":1130,"comment":[],"params":["orientation","side","params"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"split","line":1082,"func_location":"Pane.splitUp","func_start_line":1081,"func_end_line":1083,"args":[{"type":"string"},{"type":"string"},"params"],"comment":[" Public: Creates a new pane above the receiver.",""," * `params` (optional) {Object} with the following keys:","   * `items` (optional) {Array} of items to add to the new pane.","   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane",""," Returns the new {Pane}."],"code":"  splitUp (params) {\r\n    return this.split('vertical', 'before', params)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js","name":"Pane.split","start_line":1096,"end_line":1130,"comment":[],"params":["orientation","side","params"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js","name":"doStart","line":51,"func_location":"NativeWatcher.start","func_start_line":45,"func_end_line":55,"args":[],"comment":[" Private: Begin watching for filesystem events.",""," Has no effect if the watcher has already been started."],"code":"  async start () {\r\n    if (this.state !== WATCHER_STATE.STOPPED) {\r\n      return\r\n    }\r\n    this.state = WATCHER_STATE.STARTING\r\n\r\n    await this.doStart()\r\n\r\n    this.state = WATCHER_STATE.RUNNING\r\n    this.emitter.emit('did-start')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js","name":"NativeWatcher.doStart","start_line":57,"end_line":59,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"spawnWithEscapedWindowsArgs","line":71,"func_location":"BufferedProcess.start","func_start_line":65,"func_end_line":76,"args":[".command",".args",".options"],"code":"  start () {\r\n    if (this.started === true) return\r\n\r\n    this.started = true\r\n    // Related to joyent/node#2318\r\n    if (process.platform === 'win32' && this.options.shell === undefined) {\r\n      this.spawnWithEscapedWindowsArgs(this.command, this.args, this.options)\r\n    } else {\r\n      this.spawn(this.command, this.args, this.options)\r\n    }\r\n    this.handleEvents(this.stdout, this.stderr, this.exit)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"BufferedProcess.spawnWithEscapedWindowsArgs","start_line":79,"end_line":103,"comment":[" Windows has a bunch of special rules that node still doesn't take care of for you"],"params":["command","args","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"spawn","line":73,"func_location":"BufferedProcess.start","func_start_line":65,"func_end_line":76,"args":[".command",".args",".options"],"code":"  start () {\r\n    if (this.started === true) return\r\n\r\n    this.started = true\r\n    // Related to joyent/node#2318\r\n    if (process.platform === 'win32' && this.options.shell === undefined) {\r\n      this.spawnWithEscapedWindowsArgs(this.command, this.args, this.options)\r\n    } else {\r\n      this.spawn(this.command, this.args, this.options)\r\n    }\r\n    this.handleEvents(this.stdout, this.stderr, this.exit)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"BufferedProcess.spawn","start_line":244,"end_line":250,"comment":[],"params":["command","args","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"handleEvents","line":75,"func_location":"BufferedProcess.start","func_start_line":65,"func_end_line":76,"args":[".stdout",".stderr",".exit"],"code":"  start () {\r\n    if (this.started === true) return\r\n\r\n    this.started = true\r\n    // Related to joyent/node#2318\r\n    if (process.platform === 'win32' && this.options.shell === undefined) {\r\n      this.spawnWithEscapedWindowsArgs(this.command, this.args, this.options)\r\n    } else {\r\n      this.spawn(this.command, this.args, this.options)\r\n    }\r\n    this.handleEvents(this.stdout, this.stderr, this.exit)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js","name":"BufferedProcess.handleEvents","start_line":252,"end_line":295,"comment":[],"params":["stdout","stderr","exit"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/start.js","name":"normalizeDriveLetterName","line":41,"func_location":"start","func_start_line":12,"func_end_line":94,"args":["resourcePath"],"code":"module.exports = function start (resourcePath, devResourcePath, startTime) {\r\n  global.shellStartTime = startTime\r\n\r\n  process.on('uncaughtException', function (error = {}) {\r\n    if (error.message != null) {\r\n      console.log(error.message)\r\n    }\r\n\r\n    if (error.stack != null) {\r\n      console.log(error.stack)\r\n    }\r\n  })\r\n\r\n  process.on('unhandledRejection', function (error = {}) {\r\n    if (error.message != null) {\r\n      console.log(error.message)\r\n    }\r\n\r\n    if (error.stack != null) {\r\n      console.log(error.stack)\r\n    }\r\n  })\r\n\r\n  const previousConsoleLog = console.log\r\n  console.log = nslog\r\n\r\n  app.commandLine.appendSwitch('enable-experimental-web-platform-features')\r\n\r\n  const args = parseCommandLine(process.argv.slice(1))\r\n  args.resourcePath = normalizeDriveLetterName(resourcePath)\r\n  args.devResourcePath = normalizeDriveLetterName(devResourcePath)\r\n\r\n  atomPaths.setAtomHome(app.getPath('home'))\r\n  atomPaths.setUserData(app)\r\n\r\n  const config = getConfig()\r\n  const colorProfile = config.get('core.colorProfile')\r\n  if (colorProfile && colorProfile !== 'default') {\r\n    app.commandLine.appendSwitch('force-color-profile', colorProfile)\r\n  }\r\n\r\n  if (handleStartupEventWithSquirrel()) {\r\n    return\r\n  } else if (args.test && args.mainProcess) {\r\n    app.setPath('userData', temp.mkdirSync('atom-user-data-dir-for-main-process-tests'))\r\n    console.log = previousConsoleLog\r\n    app.on('ready', function () {\r\n      const testRunner = require(path.join(args.resourcePath, 'spec/main-process/mocha-test-runner'))\r\n      testRunner(args.pathsToOpen)\r\n    })\r\n    return\r\n  }\r\n\r\n  // NB: This prevents Win10 from showing dupe items in the taskbar\r\n  app.setAppUserModelId('com.squirrel.atom.' + process.arch)\r\n\r\n  function addPathToOpen (event, pathToOpen) {\r\n    event.preventDefault()\r\n    args.pathsToOpen.push(pathToOpen)\r\n  }\r\n\r\n  function addUrlToOpen (event, urlToOpen) {\r\n    event.preventDefault()\r\n    args.urlsToOpen.push(urlToOpen)\r\n  }\r\n\r\n  app.on('open-file', addPathToOpen)\r\n  app.on('open-url', addUrlToOpen)\r\n  app.on('will-finish-launching', startCrashReporter)\r\n\r\n  if (args.userDataDir != null) {\r\n    app.setPath('userData', args.userDataDir)\r\n  } else if (args.test || args.benchmark || args.benchmarkTest) {\r\n    app.setPath('userData', temp.mkdirSync('atom-test-data'))\r\n  }\r\n\r\n  app.on('ready', function () {\r\n    app.removeListener('open-file', addPathToOpen)\r\n    app.removeListener('open-url', addUrlToOpen)\r\n    const AtomApplication = require(path.join(args.resourcePath, 'src', 'main-process', 'atom-application'))\r\n    AtomApplication.open(args)\r\n  })\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/start.js","name":"normalizeDriveLetterName","start_line":124,"end_line":130,"comment":[],"params":["filePath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/start.js","name":"normalizeDriveLetterName","line":42,"func_location":"start","func_start_line":12,"func_end_line":94,"args":["devResourcePath"],"code":"module.exports = function start (resourcePath, devResourcePath, startTime) {\r\n  global.shellStartTime = startTime\r\n\r\n  process.on('uncaughtException', function (error = {}) {\r\n    if (error.message != null) {\r\n      console.log(error.message)\r\n    }\r\n\r\n    if (error.stack != null) {\r\n      console.log(error.stack)\r\n    }\r\n  })\r\n\r\n  process.on('unhandledRejection', function (error = {}) {\r\n    if (error.message != null) {\r\n      console.log(error.message)\r\n    }\r\n\r\n    if (error.stack != null) {\r\n      console.log(error.stack)\r\n    }\r\n  })\r\n\r\n  const previousConsoleLog = console.log\r\n  console.log = nslog\r\n\r\n  app.commandLine.appendSwitch('enable-experimental-web-platform-features')\r\n\r\n  const args = parseCommandLine(process.argv.slice(1))\r\n  args.resourcePath = normalizeDriveLetterName(resourcePath)\r\n  args.devResourcePath = normalizeDriveLetterName(devResourcePath)\r\n\r\n  atomPaths.setAtomHome(app.getPath('home'))\r\n  atomPaths.setUserData(app)\r\n\r\n  const config = getConfig()\r\n  const colorProfile = config.get('core.colorProfile')\r\n  if (colorProfile && colorProfile !== 'default') {\r\n    app.commandLine.appendSwitch('force-color-profile', colorProfile)\r\n  }\r\n\r\n  if (handleStartupEventWithSquirrel()) {\r\n    return\r\n  } else if (args.test && args.mainProcess) {\r\n    app.setPath('userData', temp.mkdirSync('atom-user-data-dir-for-main-process-tests'))\r\n    console.log = previousConsoleLog\r\n    app.on('ready', function () {\r\n      const testRunner = require(path.join(args.resourcePath, 'spec/main-process/mocha-test-runner'))\r\n      testRunner(args.pathsToOpen)\r\n    })\r\n    return\r\n  }\r\n\r\n  // NB: This prevents Win10 from showing dupe items in the taskbar\r\n  app.setAppUserModelId('com.squirrel.atom.' + process.arch)\r\n\r\n  function addPathToOpen (event, pathToOpen) {\r\n    event.preventDefault()\r\n    args.pathsToOpen.push(pathToOpen)\r\n  }\r\n\r\n  function addUrlToOpen (event, urlToOpen) {\r\n    event.preventDefault()\r\n    args.urlsToOpen.push(urlToOpen)\r\n  }\r\n\r\n  app.on('open-file', addPathToOpen)\r\n  app.on('open-url', addUrlToOpen)\r\n  app.on('will-finish-launching', startCrashReporter)\r\n\r\n  if (args.userDataDir != null) {\r\n    app.setPath('userData', args.userDataDir)\r\n  } else if (args.test || args.benchmark || args.benchmarkTest) {\r\n    app.setPath('userData', temp.mkdirSync('atom-test-data'))\r\n  }\r\n\r\n  app.on('ready', function () {\r\n    app.removeListener('open-file', addPathToOpen)\r\n    app.removeListener('open-url', addUrlToOpen)\r\n    const AtomApplication = require(path.join(args.resourcePath, 'src', 'main-process', 'atom-application'))\r\n    AtomApplication.open(args)\r\n  })\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/start.js","name":"normalizeDriveLetterName","start_line":124,"end_line":130,"comment":[],"params":["filePath"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/start.js","name":"getConfig","line":47,"func_location":"start","func_start_line":12,"func_end_line":94,"args":[],"code":"module.exports = function start (resourcePath, devResourcePath, startTime) {\r\n  global.shellStartTime = startTime\r\n\r\n  process.on('uncaughtException', function (error = {}) {\r\n    if (error.message != null) {\r\n      console.log(error.message)\r\n    }\r\n\r\n    if (error.stack != null) {\r\n      console.log(error.stack)\r\n    }\r\n  })\r\n\r\n  process.on('unhandledRejection', function (error = {}) {\r\n    if (error.message != null) {\r\n      console.log(error.message)\r\n    }\r\n\r\n    if (error.stack != null) {\r\n      console.log(error.stack)\r\n    }\r\n  })\r\n\r\n  const previousConsoleLog = console.log\r\n  console.log = nslog\r\n\r\n  app.commandLine.appendSwitch('enable-experimental-web-platform-features')\r\n\r\n  const args = parseCommandLine(process.argv.slice(1))\r\n  args.resourcePath = normalizeDriveLetterName(resourcePath)\r\n  args.devResourcePath = normalizeDriveLetterName(devResourcePath)\r\n\r\n  atomPaths.setAtomHome(app.getPath('home'))\r\n  atomPaths.setUserData(app)\r\n\r\n  const config = getConfig()\r\n  const colorProfile = config.get('core.colorProfile')\r\n  if (colorProfile && colorProfile !== 'default') {\r\n    app.commandLine.appendSwitch('force-color-profile', colorProfile)\r\n  }\r\n\r\n  if (handleStartupEventWithSquirrel()) {\r\n    return\r\n  } else if (args.test && args.mainProcess) {\r\n    app.setPath('userData', temp.mkdirSync('atom-user-data-dir-for-main-process-tests'))\r\n    console.log = previousConsoleLog\r\n    app.on('ready', function () {\r\n      const testRunner = require(path.join(args.resourcePath, 'spec/main-process/mocha-test-runner'))\r\n      testRunner(args.pathsToOpen)\r\n    })\r\n    return\r\n  }\r\n\r\n  // NB: This prevents Win10 from showing dupe items in the taskbar\r\n  app.setAppUserModelId('com.squirrel.atom.' + process.arch)\r\n\r\n  function addPathToOpen (event, pathToOpen) {\r\n    event.preventDefault()\r\n    args.pathsToOpen.push(pathToOpen)\r\n  }\r\n\r\n  function addUrlToOpen (event, urlToOpen) {\r\n    event.preventDefault()\r\n    args.urlsToOpen.push(urlToOpen)\r\n  }\r\n\r\n  app.on('open-file', addPathToOpen)\r\n  app.on('open-url', addUrlToOpen)\r\n  app.on('will-finish-launching', startCrashReporter)\r\n\r\n  if (args.userDataDir != null) {\r\n    app.setPath('userData', args.userDataDir)\r\n  } else if (args.test || args.benchmark || args.benchmarkTest) {\r\n    app.setPath('userData', temp.mkdirSync('atom-test-data'))\r\n  }\r\n\r\n  app.on('ready', function () {\r\n    app.removeListener('open-file', addPathToOpen)\r\n    app.removeListener('open-url', addUrlToOpen)\r\n    const AtomApplication = require(path.join(args.resourcePath, 'src', 'main-process', 'atom-application'))\r\n    AtomApplication.open(args)\r\n  })\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/start.js","name":"getConfig","start_line":106,"end_line":122,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/start.js","name":"handleStartupEventWithSquirrel","line":53,"func_location":"start","func_start_line":12,"func_end_line":94,"args":[],"code":"module.exports = function start (resourcePath, devResourcePath, startTime) {\r\n  global.shellStartTime = startTime\r\n\r\n  process.on('uncaughtException', function (error = {}) {\r\n    if (error.message != null) {\r\n      console.log(error.message)\r\n    }\r\n\r\n    if (error.stack != null) {\r\n      console.log(error.stack)\r\n    }\r\n  })\r\n\r\n  process.on('unhandledRejection', function (error = {}) {\r\n    if (error.message != null) {\r\n      console.log(error.message)\r\n    }\r\n\r\n    if (error.stack != null) {\r\n      console.log(error.stack)\r\n    }\r\n  })\r\n\r\n  const previousConsoleLog = console.log\r\n  console.log = nslog\r\n\r\n  app.commandLine.appendSwitch('enable-experimental-web-platform-features')\r\n\r\n  const args = parseCommandLine(process.argv.slice(1))\r\n  args.resourcePath = normalizeDriveLetterName(resourcePath)\r\n  args.devResourcePath = normalizeDriveLetterName(devResourcePath)\r\n\r\n  atomPaths.setAtomHome(app.getPath('home'))\r\n  atomPaths.setUserData(app)\r\n\r\n  const config = getConfig()\r\n  const colorProfile = config.get('core.colorProfile')\r\n  if (colorProfile && colorProfile !== 'default') {\r\n    app.commandLine.appendSwitch('force-color-profile', colorProfile)\r\n  }\r\n\r\n  if (handleStartupEventWithSquirrel()) {\r\n    return\r\n  } else if (args.test && args.mainProcess) {\r\n    app.setPath('userData', temp.mkdirSync('atom-user-data-dir-for-main-process-tests'))\r\n    console.log = previousConsoleLog\r\n    app.on('ready', function () {\r\n      const testRunner = require(path.join(args.resourcePath, 'spec/main-process/mocha-test-runner'))\r\n      testRunner(args.pathsToOpen)\r\n    })\r\n    return\r\n  }\r\n\r\n  // NB: This prevents Win10 from showing dupe items in the taskbar\r\n  app.setAppUserModelId('com.squirrel.atom.' + process.arch)\r\n\r\n  function addPathToOpen (event, pathToOpen) {\r\n    event.preventDefault()\r\n    args.pathsToOpen.push(pathToOpen)\r\n  }\r\n\r\n  function addUrlToOpen (event, urlToOpen) {\r\n    event.preventDefault()\r\n    args.urlsToOpen.push(urlToOpen)\r\n  }\r\n\r\n  app.on('open-file', addPathToOpen)\r\n  app.on('open-url', addUrlToOpen)\r\n  app.on('will-finish-launching', startCrashReporter)\r\n\r\n  if (args.userDataDir != null) {\r\n    app.setPath('userData', args.userDataDir)\r\n  } else if (args.test || args.benchmark || args.benchmarkTest) {\r\n    app.setPath('userData', temp.mkdirSync('atom-test-data'))\r\n  }\r\n\r\n  app.on('ready', function () {\r\n    app.removeListener('open-file', addPathToOpen)\r\n    app.removeListener('open-url', addUrlToOpen)\r\n    const AtomApplication = require(path.join(args.resourcePath, 'src', 'main-process', 'atom-application'))\r\n    AtomApplication.open(args)\r\n  })\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/start.js","name":"handleStartupEventWithSquirrel","start_line":96,"end_line":104,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"scheduleUpdate","line":2008,"func_location":"TextEditorComponent.startCursorBlinking","func_start_line":2001,"func_end_line":2010,"args":[{"type":"boolean"}],"code":"  startCursorBlinking () {\r\n    if (!this.cursorsBlinking) {\r\n      this.cursorBlinkIntervalHandle = window.setInterval(() => {\r\n        this.cursorsBlinkedOff = !this.cursorsBlinkedOff\r\n        this.scheduleUpdate(true)\r\n      }, (this.props.cursorBlinkPeriod || CURSOR_BLINK_PERIOD) / 2)\r\n      this.cursorsBlinking = true\r\n      this.scheduleUpdate(true)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.scheduleUpdate","start_line":204,"end_line":219,"comment":[],"params":["nextUpdateOnlyBlinksCursors"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"getLoadSettings","line":774,"func_location":"AtomEnvironment.startEditorWindow","func_start_line":773,"func_end_line":868,"args":[],"comment":[" Call this method when establishing a real application window."],"code":"  async startEditorWindow () {\r\n    if (this.getLoadSettings().clearWindowState) {\r\n      await this.stateStore.clear()\r\n    }\r\n\r\n    this.unloading = false\r\n\r\n    const updateProcessEnvPromise = this.updateProcessEnvAndTriggerHooks()\r\n\r\n    const loadStatePromise = this.loadState().then(async state => {\r\n      this.windowDimensions = state && state.windowDimensions\r\n      await this.displayWindow()\r\n      this.commandInstaller.installAtomCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n      this.commandInstaller.installApmCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidChangeUserSettings(settings =>\r\n        this.config.resetUserSettings(settings)\r\n      ))\r\n      this.disposables.add(this.applicationDelegate.onDidFailToReadUserSettings(message =>\r\n        this.notifications.addError(message)\r\n      ))\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidOpenLocations(this.openLocations.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onApplicationMenuCommand(this.dispatchApplicationMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onContextMenuCommand(this.dispatchContextMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onURIMessage(this.dispatchURIMessage.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onDidRequestUnload(this.prepareToUnloadEditorWindow.bind(this)))\r\n\r\n      this.listenForUpdates()\r\n\r\n      this.registerDefaultTargetForKeymaps()\r\n\r\n      this.packages.loadPackages()\r\n\r\n      const startTime = Date.now()\r\n      await this.deserialize(state)\r\n      this.deserializeTimings.atom = Date.now() - startTime\r\n\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom-inset') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-inset-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'hidden') {\r\n        this.document.body.classList.add('hidden-title-bar')\r\n      }\r\n\r\n      this.document.body.appendChild(this.workspace.getElement())\r\n      if (this.backgroundStylesheet) this.backgroundStylesheet.remove()\r\n\r\n      let previousProjectPaths = this.project.getPaths()\r\n      this.disposables.add(this.project.onDidChangePaths(newPaths => {\r\n        for (let path of previousProjectPaths) {\r\n          if (this.pathsWithWaitSessions.has(path) && !newPaths.includes(path)) {\r\n            this.applicationDelegate.didClosePathWithWaitSession(path)\r\n          }\r\n        }\r\n        previousProjectPaths = newPaths\r\n        this.applicationDelegate.setRepresentedDirectoryPaths(newPaths)\r\n      }))\r\n      this.disposables.add(this.workspace.onDidDestroyPaneItem(({item}) => {\r\n        const path = item.getPath && item.getPath()\r\n        if (this.pathsWithWaitSessions.has(path)) {\r\n          this.applicationDelegate.didClosePathWithWaitSession(path)\r\n        }\r\n      }))\r\n\r\n      this.packages.activate()\r\n      this.keymaps.loadUserKeymap()\r\n      if (!this.getLoadSettings().safeMode) this.requireUserInitScript()\r\n\r\n      this.menu.update()\r\n\r\n      await this.openInitialEmptyEditorIfNecessary()\r\n    })\r\n\r\n    const loadHistoryPromise = this.history.loadState().then(() => {\r\n      this.reopenProjectMenuManager = new ReopenProjectMenuManager({\r\n        menu: this.menu,\r\n        commands: this.commands,\r\n        history: this.history,\r\n        config: this.config,\r\n        open: paths => this.open({pathsToOpen: paths})\r\n      })\r\n      this.reopenProjectMenuManager.update()\r\n    })\r\n\r\n    return Promise.all([loadStatePromise, loadHistoryPromise, updateProcessEnvPromise])\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.getLoadSettings","start_line":525,"end_line":527,"comment":[" Public: Get the load settings for the current window.",""," Returns an {Object} containing all the load setting key/value pairs."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"updateProcessEnvAndTriggerHooks","line":780,"func_location":"AtomEnvironment.startEditorWindow","func_start_line":773,"func_end_line":868,"args":[],"comment":[" Call this method when establishing a real application window."],"code":"  async startEditorWindow () {\r\n    if (this.getLoadSettings().clearWindowState) {\r\n      await this.stateStore.clear()\r\n    }\r\n\r\n    this.unloading = false\r\n\r\n    const updateProcessEnvPromise = this.updateProcessEnvAndTriggerHooks()\r\n\r\n    const loadStatePromise = this.loadState().then(async state => {\r\n      this.windowDimensions = state && state.windowDimensions\r\n      await this.displayWindow()\r\n      this.commandInstaller.installAtomCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n      this.commandInstaller.installApmCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidChangeUserSettings(settings =>\r\n        this.config.resetUserSettings(settings)\r\n      ))\r\n      this.disposables.add(this.applicationDelegate.onDidFailToReadUserSettings(message =>\r\n        this.notifications.addError(message)\r\n      ))\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidOpenLocations(this.openLocations.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onApplicationMenuCommand(this.dispatchApplicationMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onContextMenuCommand(this.dispatchContextMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onURIMessage(this.dispatchURIMessage.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onDidRequestUnload(this.prepareToUnloadEditorWindow.bind(this)))\r\n\r\n      this.listenForUpdates()\r\n\r\n      this.registerDefaultTargetForKeymaps()\r\n\r\n      this.packages.loadPackages()\r\n\r\n      const startTime = Date.now()\r\n      await this.deserialize(state)\r\n      this.deserializeTimings.atom = Date.now() - startTime\r\n\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom-inset') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-inset-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'hidden') {\r\n        this.document.body.classList.add('hidden-title-bar')\r\n      }\r\n\r\n      this.document.body.appendChild(this.workspace.getElement())\r\n      if (this.backgroundStylesheet) this.backgroundStylesheet.remove()\r\n\r\n      let previousProjectPaths = this.project.getPaths()\r\n      this.disposables.add(this.project.onDidChangePaths(newPaths => {\r\n        for (let path of previousProjectPaths) {\r\n          if (this.pathsWithWaitSessions.has(path) && !newPaths.includes(path)) {\r\n            this.applicationDelegate.didClosePathWithWaitSession(path)\r\n          }\r\n        }\r\n        previousProjectPaths = newPaths\r\n        this.applicationDelegate.setRepresentedDirectoryPaths(newPaths)\r\n      }))\r\n      this.disposables.add(this.workspace.onDidDestroyPaneItem(({item}) => {\r\n        const path = item.getPath && item.getPath()\r\n        if (this.pathsWithWaitSessions.has(path)) {\r\n          this.applicationDelegate.didClosePathWithWaitSession(path)\r\n        }\r\n      }))\r\n\r\n      this.packages.activate()\r\n      this.keymaps.loadUserKeymap()\r\n      if (!this.getLoadSettings().safeMode) this.requireUserInitScript()\r\n\r\n      this.menu.update()\r\n\r\n      await this.openInitialEmptyEditorIfNecessary()\r\n    })\r\n\r\n    const loadHistoryPromise = this.history.loadState().then(() => {\r\n      this.reopenProjectMenuManager = new ReopenProjectMenuManager({\r\n        menu: this.menu,\r\n        commands: this.commands,\r\n        history: this.history,\r\n        config: this.config,\r\n        open: paths => this.open({pathsToOpen: paths})\r\n      })\r\n      this.reopenProjectMenuManager.update()\r\n    })\r\n\r\n    return Promise.all([loadStatePromise, loadHistoryPromise, updateProcessEnvPromise])\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.updateProcessEnvAndTriggerHooks","start_line":970,"end_line":975,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"loadState","line":782,"func_location":"AtomEnvironment.startEditorWindow","func_start_line":773,"func_end_line":868,"args":[],"comment":[" Call this method when establishing a real application window."],"code":"  async startEditorWindow () {\r\n    if (this.getLoadSettings().clearWindowState) {\r\n      await this.stateStore.clear()\r\n    }\r\n\r\n    this.unloading = false\r\n\r\n    const updateProcessEnvPromise = this.updateProcessEnvAndTriggerHooks()\r\n\r\n    const loadStatePromise = this.loadState().then(async state => {\r\n      this.windowDimensions = state && state.windowDimensions\r\n      await this.displayWindow()\r\n      this.commandInstaller.installAtomCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n      this.commandInstaller.installApmCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidChangeUserSettings(settings =>\r\n        this.config.resetUserSettings(settings)\r\n      ))\r\n      this.disposables.add(this.applicationDelegate.onDidFailToReadUserSettings(message =>\r\n        this.notifications.addError(message)\r\n      ))\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidOpenLocations(this.openLocations.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onApplicationMenuCommand(this.dispatchApplicationMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onContextMenuCommand(this.dispatchContextMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onURIMessage(this.dispatchURIMessage.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onDidRequestUnload(this.prepareToUnloadEditorWindow.bind(this)))\r\n\r\n      this.listenForUpdates()\r\n\r\n      this.registerDefaultTargetForKeymaps()\r\n\r\n      this.packages.loadPackages()\r\n\r\n      const startTime = Date.now()\r\n      await this.deserialize(state)\r\n      this.deserializeTimings.atom = Date.now() - startTime\r\n\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom-inset') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-inset-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'hidden') {\r\n        this.document.body.classList.add('hidden-title-bar')\r\n      }\r\n\r\n      this.document.body.appendChild(this.workspace.getElement())\r\n      if (this.backgroundStylesheet) this.backgroundStylesheet.remove()\r\n\r\n      let previousProjectPaths = this.project.getPaths()\r\n      this.disposables.add(this.project.onDidChangePaths(newPaths => {\r\n        for (let path of previousProjectPaths) {\r\n          if (this.pathsWithWaitSessions.has(path) && !newPaths.includes(path)) {\r\n            this.applicationDelegate.didClosePathWithWaitSession(path)\r\n          }\r\n        }\r\n        previousProjectPaths = newPaths\r\n        this.applicationDelegate.setRepresentedDirectoryPaths(newPaths)\r\n      }))\r\n      this.disposables.add(this.workspace.onDidDestroyPaneItem(({item}) => {\r\n        const path = item.getPath && item.getPath()\r\n        if (this.pathsWithWaitSessions.has(path)) {\r\n          this.applicationDelegate.didClosePathWithWaitSession(path)\r\n        }\r\n      }))\r\n\r\n      this.packages.activate()\r\n      this.keymaps.loadUserKeymap()\r\n      if (!this.getLoadSettings().safeMode) this.requireUserInitScript()\r\n\r\n      this.menu.update()\r\n\r\n      await this.openInitialEmptyEditorIfNecessary()\r\n    })\r\n\r\n    const loadHistoryPromise = this.history.loadState().then(() => {\r\n      this.reopenProjectMenuManager = new ReopenProjectMenuManager({\r\n        menu: this.menu,\r\n        commands: this.commands,\r\n        history: this.history,\r\n        config: this.config,\r\n        open: paths => this.open({pathsToOpen: paths})\r\n      })\r\n      this.reopenProjectMenuManager.update()\r\n    })\r\n\r\n    return Promise.all([loadStatePromise, loadHistoryPromise, updateProcessEnvPromise])\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.loadState","start_line":1210,"end_line":1221,"comment":[],"params":["stateKey"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"tokenizeInBackground","line":268,"func_location":"TextMateLanguageMode.startTokenizing","func_start_line":265,"func_end_line":270,"args":[],"code":"  startTokenizing () {\r\n    this.tokenizationStarted = true\r\n    if (this.grammar.name !== 'Null Grammar' && !this.largeFileMode) {\r\n      this.tokenizeInBackground()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.tokenizeInBackground","start_line":272,"end_line":280,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js","name":"doStop","line":137,"func_location":"NativeWatcher.stop","func_start_line":130,"func_end_line":142,"args":[],"comment":[" Private: Stop the native watcher and release any operating system resources associated with it.",""," Has no effect if the watcher is not running."],"code":"  async stop () {\r\n    if (this.state !== WATCHER_STATE.RUNNING) {\r\n      return\r\n    }\r\n    this.state = WATCHER_STATE.STOPPING\r\n    this.emitter.emit('will-stop')\r\n\r\n    await this.doStop()\r\n\r\n    this.state = WATCHER_STATE.STOPPED\r\n\r\n    this.emitter.emit('did-stop')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js","name":"NativeWatcher.doStop","start_line":144,"end_line":146,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"scheduleUpdate","line":1997,"func_location":"TextEditorComponent.stopCursorBlinking","func_start_line":1991,"func_end_line":1999,"args":[],"code":"  stopCursorBlinking () {\r\n    if (this.cursorsBlinking) {\r\n      this.cursorsBlinkedOff = false\r\n      this.cursorsBlinking = false\r\n      window.clearInterval(this.cursorBlinkIntervalHandle)\r\n      this.cursorBlinkIntervalHandle = null\r\n      this.scheduleUpdate()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.scheduleUpdate","start_line":204,"end_line":219,"comment":[],"params":["nextUpdateOnlyBlinksCursors"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js","name":"copyFile","line":110,"func_location":"RecoveryFile.store","func_start_line":109,"func_end_line":111,"args":[".originalPath",".recoveryPath",".fileMode"],"code":"  async store () {\r\n    await copyFile(this.originalPath, this.recoveryPath, this.fileMode)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js","name":"copyFile","start_line":149,"end_line":165,"comment":[],"params":["source","destination","mode"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"inSpecMode","line":766,"func_location":"AtomEnvironment.storeWindowBackground","func_start_line":765,"func_end_line":770,"args":[],"code":"  storeWindowBackground () {\r\n    if (this.inSpecMode()) return\r\n\r\n    const backgroundColor = this.window.getComputedStyle(this.workspace.getElement())['background-color']\r\n    this.window.localStorage.setItem('atom:window-background-color', backgroundColor)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.inSpecMode","start_line":468,"end_line":471,"comment":[" Public: Returns a {Boolean} that is `true` if the current window is running specs."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"getWindowDimensions","line":721,"func_location":"AtomEnvironment.storeWindowDimensions","func_start_line":720,"func_end_line":725,"args":[],"code":"  storeWindowDimensions () {\r\n    this.windowDimensions = this.getWindowDimensions()\r\n    if (this.isValidDimensions(this.windowDimensions)) {\r\n      localStorage.setItem('defaultWindowDimensions', JSON.stringify(this.windowDimensions))\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.getWindowDimensions","start_line":682,"end_line":688,"comment":[" Get the dimensions of this window.",""," Returns an {Object} with the following keys:","   * `x`      The window's x-position {Number}.","   * `y`      The window's y-position {Number}.","   * `width`  The window's width {Number}.","   * `height` The window's height {Number}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"isValidDimensions","line":722,"func_location":"AtomEnvironment.storeWindowDimensions","func_start_line":720,"func_end_line":725,"args":[".windowDimensions"],"code":"  storeWindowDimensions () {\r\n    this.windowDimensions = this.getWindowDimensions()\r\n    if (this.isValidDimensions(this.windowDimensions)) {\r\n      localStorage.setItem('defaultWindowDimensions', JSON.stringify(this.windowDimensions))\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.isValidDimensions","start_line":716,"end_line":718,"comment":[" Returns true if the dimensions are useable, false if they should be ignored."," Work around for https://github.com/atom/atom-shell/issues/473"],"params":[["x","y","width","height"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"getActivationCommands","line":835,"func_location":"Package.subscribeToActivationCommands","func_start_line":833,"func_end_line":868,"args":[],"code":"  subscribeToActivationCommands () {\r\n    this.activationCommandSubscriptions = new CompositeDisposable()\r\n    const object = this.getActivationCommands()\r\n    for (let selector in object) {\r\n      const commands = object[selector]\r\n      for (let command of commands) {\r\n        ((selector, command) => {\r\n          // Add dummy command so it appears in menu.\r\n          // The real command will be registered on package activation\r\n          try {\r\n            this.activationCommandSubscriptions.add(this.commandRegistry.add(selector, command, function () {}))\r\n          } catch (error) {\r\n            if (error.code === 'EBADSELECTOR') {\r\n              const metadataPath = path.join(this.path, 'package.json')\r\n              error.message += ` in ${metadataPath}`\r\n              error.stack += `\\n  at ${metadataPath}:1:1`\r\n            }\r\n            throw error\r\n          }\r\n\r\n          this.activationCommandSubscriptions.add(this.commandRegistry.onWillDispatch(event => {\r\n            if (event.type !== command) return\r\n            let currentTarget = event.target\r\n            while (currentTarget) {\r\n              if (currentTarget.webkitMatchesSelector(selector)) {\r\n                this.activationCommandSubscriptions.dispose()\r\n                this.activateNow()\r\n                break\r\n              }\r\n              currentTarget = currentTarget.parentElement\r\n            }\r\n          }))\r\n        })(selector, command)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.getActivationCommands","start_line":870,"end_line":888,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"getActivationHooks","line":892,"func_location":"Package.subscribeToActivationHooks","func_start_line":890,"func_end_line":899,"args":[],"code":"  subscribeToActivationHooks () {\r\n    this.activationHookSubscriptions = new CompositeDisposable()\r\n    for (let hook of this.getActivationHooks()) {\r\n      if (typeof hook === 'string' && hook.trim().length > 0) {\r\n        this.activationHookSubscriptions.add(\r\n          this.packageManager.onDidTriggerActivationHook(hook, () => this.activateNow())\r\n        )\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.getActivationHooks","start_line":901,"end_line":917,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"onDidAddPaneItem","line":496,"func_location":"Workspace.subscribeToAddedItems","func_start_line":495,"func_end_line":518},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.onDidAddPaneItem","start_line":827,"end_line":831,"comment":[" Extended: Invoke the given callback when a pane item is added to the"," workspace.",""," * `callback` {Function} to be called when pane items are added.","   * `event` {Object} with the following keys:","     * `item` The added pane item.","     * `pane` {Pane} containing the added item.","     * `index` {Number} indicating the index of the added item in its pane.",""," Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"subscribeToActivationCommands","line":829,"func_location":"Package.subscribeToDeferredActivation","func_start_line":828,"func_end_line":831,"args":[],"code":"  subscribeToDeferredActivation () {\r\n    this.subscribeToActivationCommands()\r\n    this.subscribeToActivationHooks()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.subscribeToActivationCommands","start_line":833,"end_line":868,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"subscribeToActivationHooks","line":830,"func_location":"Package.subscribeToDeferredActivation","func_start_line":828,"func_end_line":831,"args":[],"code":"  subscribeToDeferredActivation () {\r\n    this.subscribeToActivationCommands()\r\n    this.subscribeToActivationHooks()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.subscribeToActivationHooks","start_line":890,"end_line":899,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getLeftDock","line":521,"func_location":"Workspace.subscribeToDockToggling","func_start_line":520,"func_end_line":532,"args":[],"code":"  subscribeToDockToggling () {\r\n    const docks = [this.getLeftDock(), this.getRightDock(), this.getBottomDock()]\r\n    docks.forEach(dock => {\r\n      dock.onDidChangeVisible(visible => {\r\n        if (visible) return\r\n        const {activeElement} = document\r\n        const dockElement = dock.getElement()\r\n        if (dockElement === activeElement || dockElement.contains(activeElement)) {\r\n          this.getCenter().activate()\r\n        }\r\n      })\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getLeftDock","start_line":1604,"end_line":1606,"comment":[" Essential: Get the {Dock} to the left of the editor window."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getRightDock","line":521,"func_location":"Workspace.subscribeToDockToggling","func_start_line":520,"func_end_line":532,"args":[],"code":"  subscribeToDockToggling () {\r\n    const docks = [this.getLeftDock(), this.getRightDock(), this.getBottomDock()]\r\n    docks.forEach(dock => {\r\n      dock.onDidChangeVisible(visible => {\r\n        if (visible) return\r\n        const {activeElement} = document\r\n        const dockElement = dock.getElement()\r\n        if (dockElement === activeElement || dockElement.contains(activeElement)) {\r\n          this.getCenter().activate()\r\n        }\r\n      })\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getRightDock","start_line":1609,"end_line":1611,"comment":[" Essential: Get the {Dock} to the right of the editor window."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getBottomDock","line":521,"func_location":"Workspace.subscribeToDockToggling","func_start_line":520,"func_end_line":532,"args":[],"code":"  subscribeToDockToggling () {\r\n    const docks = [this.getLeftDock(), this.getRightDock(), this.getBottomDock()]\r\n    docks.forEach(dock => {\r\n      dock.onDidChangeVisible(visible => {\r\n        if (visible) return\r\n        const {activeElement} = document\r\n        const dockElement = dock.getElement()\r\n        if (dockElement === activeElement || dockElement.contains(activeElement)) {\r\n          this.getCenter().activate()\r\n        }\r\n      })\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getBottomDock","start_line":1614,"end_line":1616,"comment":[" Essential: Get the {Dock} below the editor window."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"subscribeToFontSize","line":322,"func_location":"Workspace.subscribeToEvents","func_start_line":320,"func_end_line":326,"args":[],"code":"  subscribeToEvents () {\r\n    this.project.onDidChangePaths(this.updateWindowTitle)\r\n    this.subscribeToFontSize()\r\n    this.subscribeToAddedItems()\r\n    this.subscribeToMovedItems()\r\n    this.subscribeToDockToggling()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.subscribeToFontSize","start_line":1545,"end_line":1551,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"subscribeToAddedItems","line":323,"func_location":"Workspace.subscribeToEvents","func_start_line":320,"func_end_line":326,"args":[],"code":"  subscribeToEvents () {\r\n    this.project.onDidChangePaths(this.updateWindowTitle)\r\n    this.subscribeToFontSize()\r\n    this.subscribeToAddedItems()\r\n    this.subscribeToMovedItems()\r\n    this.subscribeToDockToggling()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.subscribeToAddedItems","start_line":495,"end_line":518,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"subscribeToMovedItems","line":324,"func_location":"Workspace.subscribeToEvents","func_start_line":320,"func_end_line":326,"args":[],"code":"  subscribeToEvents () {\r\n    this.project.onDidChangePaths(this.updateWindowTitle)\r\n    this.subscribeToFontSize()\r\n    this.subscribeToAddedItems()\r\n    this.subscribeToMovedItems()\r\n    this.subscribeToDockToggling()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.subscribeToMovedItems","start_line":534,"end_line":557,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"subscribeToDockToggling","line":325,"func_location":"Workspace.subscribeToEvents","func_start_line":320,"func_end_line":326,"args":[],"code":"  subscribeToEvents () {\r\n    this.project.onDidChangePaths(this.updateWindowTitle)\r\n    this.subscribeToFontSize()\r\n    this.subscribeToAddedItems()\r\n    this.subscribeToMovedItems()\r\n    this.subscribeToDockToggling()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.subscribeToDockToggling","start_line":520,"end_line":532,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getPaneContainers","line":535,"func_location":"Workspace.subscribeToMovedItems","func_start_line":534,"func_end_line":557,"args":[],"code":"  subscribeToMovedItems () {\r\n    for (const paneContainer of this.getPaneContainers()) {\r\n      paneContainer.observePanes(pane => {\r\n        pane.onDidAddItem(({item}) => {\r\n          if (typeof item.getURI === 'function' && this.enablePersistence) {\r\n            const uri = item.getURI()\r\n            if (uri) {\r\n              const location = paneContainer.getLocation()\r\n              let defaultLocation\r\n              if (typeof item.getDefaultLocation === 'function') {\r\n                defaultLocation = item.getDefaultLocation()\r\n              }\r\n              defaultLocation = defaultLocation || 'center'\r\n              if (location === defaultLocation) {\r\n                this.itemLocationStore.delete(item.getURI())\r\n              } else {\r\n                this.itemLocationStore.save(item.getURI(), location)\r\n              }\r\n            }\r\n          }\r\n        })\r\n      })\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getPaneContainers","start_line":1618,"end_line":1625,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"flattenMenuTemplate","line":104,"func_location":"ApplicationMenu.substituteVersion","func_start_line":103,"func_end_line":106,"args":[null],"comment":[" Replaces VERSION with the current version."],"code":"  substituteVersion (template) {\r\n    let item = this.flattenMenuTemplate(template).find(({label}) => label === 'VERSION')\r\n    if (item) item.label = `Version ${this.version}`\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"ApplicationMenu.flattenMenuTemplate","start_line":83,"end_line":90,"comment":[" Flattens the given menu template into an single Array.",""," template - An object describing the menu item.",""," Returns an Array of native menu items."],"params":["template"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getNonWordCharacters","line":691,"func_location":"Cursor.subwordRegExp","func_start_line":690,"func_end_line":710,"args":[],"comment":[" Public: Get the RegExp used by the cursor to determine what a \"subword\" is.",""," * `options` (optional) {Object} with the following keys:","   * `backwards` A {Boolean} indicating whether to look forwards or backwards","     for the next subword. (default: false)",""," Returns a {RegExp}."],"code":"  subwordRegExp (options = {}) {\r\n    const nonWordCharacters = this.getNonWordCharacters()\r\n    const lowercaseLetters = 'a-z\\\\u00DF-\\\\u00F6\\\\u00F8-\\\\u00FF'\r\n    const uppercaseLetters = 'A-Z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00DE'\r\n    const snakeCamelSegment = `[${uppercaseLetters}]?[${lowercaseLetters}]+`\r\n    const segments = [\r\n      '^[\\t ]+',\r\n      '[\\t ]+$',\r\n      `[${uppercaseLetters}]+(?![${lowercaseLetters}])`,\r\n      '\\\\d+'\r\n    ]\r\n    if (options.backwards) {\r\n      segments.push(`${snakeCamelSegment}_*`)\r\n      segments.push(`[${_.escapeRegExp(nonWordCharacters)}]+\\\\s*`)\r\n    } else {\r\n      segments.push(`_*${snakeCamelSegment}`)\r\n      segments.push(`\\\\s*[${_.escapeRegExp(nonWordCharacters)}]+`)\r\n    }\r\n    segments.push('_+')\r\n    return new RegExp(segments.join('|'), 'g')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getNonWordCharacters","start_line":716,"end_line":718,"comment":["\r\n  Section: Private\r\n  "],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"tokenizedLineForRow","line":79,"func_location":"TextMateLanguageMode.suggestedIndentForBufferRow","func_start_line":77,"func_end_line":90,"args":["bufferRow"],"comment":["\r\n  Section - auto-indent\r\n  "," Get the suggested indentation level for an existing line in the buffer.",""," * bufferRow - A {Number} indicating the buffer row",""," Returns a {Number}."],"code":"  suggestedIndentForBufferRow (bufferRow, tabLength, options) {\r\n    const line = this.buffer.lineForRow(bufferRow)\r\n    const tokenizedLine = this.tokenizedLineForRow(bufferRow)\r\n    const iterator = tokenizedLine.getTokenIterator()\r\n    iterator.next()\r\n    const scopeDescriptor = new ScopeDescriptor({scopes: iterator.getScopes()})\r\n    return this._suggestedIndentForLineWithScopeAtBufferRow(\r\n      bufferRow,\r\n      line,\r\n      scopeDescriptor,\r\n      tabLength,\r\n      options\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.tokenizedLineForRow","start_line":425,"end_line":449,"comment":[],"params":["bufferRow"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"_suggestedIndentForLineWithScopeAtBufferRow","line":83,"func_location":"TextMateLanguageMode.suggestedIndentForBufferRow","func_start_line":77,"func_end_line":90},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode._suggestedIndentForLineWithScopeAtBufferRow","start_line":151,"end_line":179,"comment":[],"params":["bufferRow","line","scopeDescriptor","tabLength","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"indentLevelForLine","line":121,"func_location":"TextMateLanguageMode.suggestedIndentForEditedBufferRow","func_start_line":119,"func_end_line":149,"args":["line","tabLength"],"comment":[" Get the suggested indentation level for a line in the buffer on which the user is currently"," typing. This may return a different result from {::suggestedIndentForBufferRow} in order"," to avoid unexpected changes in indentation. It may also return undefined if no change should"," be made.",""," * bufferRow - The row {Number}",""," Returns a {Number}."],"code":"  suggestedIndentForEditedBufferRow (bufferRow, tabLength) {\r\n    const line = this.buffer.lineForRow(bufferRow)\r\n    const currentIndentLevel = this.indentLevelForLine(line, tabLength)\r\n    if (currentIndentLevel === 0) return\r\n\r\n    const scopeDescriptor = this.scopeDescriptorForPosition(new Point(bufferRow, 0))\r\n    const decreaseIndentRegex = this.decreaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (!decreaseIndentRegex) return\r\n\r\n    if (!decreaseIndentRegex.testSync(line)) return\r\n\r\n    const precedingRow = this.buffer.previousNonBlankRow(bufferRow)\r\n    if (precedingRow == null) return\r\n\r\n    const precedingLine = this.buffer.lineForRow(precedingRow)\r\n    let desiredIndentLevel = this.indentLevelForLine(precedingLine, tabLength)\r\n\r\n    const increaseIndentRegex = this.increaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (increaseIndentRegex) {\r\n      if (!increaseIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    const decreaseNextIndentRegex = this.decreaseNextIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (decreaseNextIndentRegex) {\r\n      if (decreaseNextIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    if (desiredIndentLevel < 0) return 0\r\n    if (desiredIndentLevel >= currentIndentLevel) return\r\n    return desiredIndentLevel\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.indentLevelForLine","start_line":492,"end_line":505,"comment":[],"params":["line","tabLength"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"scopeDescriptorForPosition","line":124,"func_location":"TextMateLanguageMode.suggestedIndentForEditedBufferRow","func_start_line":119,"func_end_line":149,"args":[null],"comment":[" Get the suggested indentation level for a line in the buffer on which the user is currently"," typing. This may return a different result from {::suggestedIndentForBufferRow} in order"," to avoid unexpected changes in indentation. It may also return undefined if no change should"," be made.",""," * bufferRow - The row {Number}",""," Returns a {Number}."],"code":"  suggestedIndentForEditedBufferRow (bufferRow, tabLength) {\r\n    const line = this.buffer.lineForRow(bufferRow)\r\n    const currentIndentLevel = this.indentLevelForLine(line, tabLength)\r\n    if (currentIndentLevel === 0) return\r\n\r\n    const scopeDescriptor = this.scopeDescriptorForPosition(new Point(bufferRow, 0))\r\n    const decreaseIndentRegex = this.decreaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (!decreaseIndentRegex) return\r\n\r\n    if (!decreaseIndentRegex.testSync(line)) return\r\n\r\n    const precedingRow = this.buffer.previousNonBlankRow(bufferRow)\r\n    if (precedingRow == null) return\r\n\r\n    const precedingLine = this.buffer.lineForRow(precedingRow)\r\n    let desiredIndentLevel = this.indentLevelForLine(precedingLine, tabLength)\r\n\r\n    const increaseIndentRegex = this.increaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (increaseIndentRegex) {\r\n      if (!increaseIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    const decreaseNextIndentRegex = this.decreaseNextIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (decreaseNextIndentRegex) {\r\n      if (decreaseNextIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    if (desiredIndentLevel < 0) return 0\r\n    if (desiredIndentLevel >= currentIndentLevel) return\r\n    return desiredIndentLevel\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.scopeDescriptorForPosition","start_line":507,"end_line":526,"comment":[],"params":["position"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"decreaseIndentRegexForScopeDescriptor","line":125,"func_location":"TextMateLanguageMode.suggestedIndentForEditedBufferRow","func_start_line":119,"func_end_line":149,"args":["scopeDescriptor"],"comment":[" Get the suggested indentation level for a line in the buffer on which the user is currently"," typing. This may return a different result from {::suggestedIndentForBufferRow} in order"," to avoid unexpected changes in indentation. It may also return undefined if no change should"," be made.",""," * bufferRow - The row {Number}",""," Returns a {Number}."],"code":"  suggestedIndentForEditedBufferRow (bufferRow, tabLength) {\r\n    const line = this.buffer.lineForRow(bufferRow)\r\n    const currentIndentLevel = this.indentLevelForLine(line, tabLength)\r\n    if (currentIndentLevel === 0) return\r\n\r\n    const scopeDescriptor = this.scopeDescriptorForPosition(new Point(bufferRow, 0))\r\n    const decreaseIndentRegex = this.decreaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (!decreaseIndentRegex) return\r\n\r\n    if (!decreaseIndentRegex.testSync(line)) return\r\n\r\n    const precedingRow = this.buffer.previousNonBlankRow(bufferRow)\r\n    if (precedingRow == null) return\r\n\r\n    const precedingLine = this.buffer.lineForRow(precedingRow)\r\n    let desiredIndentLevel = this.indentLevelForLine(precedingLine, tabLength)\r\n\r\n    const increaseIndentRegex = this.increaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (increaseIndentRegex) {\r\n      if (!increaseIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    const decreaseNextIndentRegex = this.decreaseNextIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (decreaseNextIndentRegex) {\r\n      if (decreaseNextIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    if (desiredIndentLevel < 0) return 0\r\n    if (desiredIndentLevel >= currentIndentLevel) return\r\n    return desiredIndentLevel\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.decreaseIndentRegexForScopeDescriptor","start_line":701,"end_line":703,"comment":[],"params":["scope"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"indentLevelForLine","line":134,"func_location":"TextMateLanguageMode.suggestedIndentForEditedBufferRow","func_start_line":119,"func_end_line":149,"args":["precedingLine","tabLength"],"comment":[" Get the suggested indentation level for a line in the buffer on which the user is currently"," typing. This may return a different result from {::suggestedIndentForBufferRow} in order"," to avoid unexpected changes in indentation. It may also return undefined if no change should"," be made.",""," * bufferRow - The row {Number}",""," Returns a {Number}."],"code":"  suggestedIndentForEditedBufferRow (bufferRow, tabLength) {\r\n    const line = this.buffer.lineForRow(bufferRow)\r\n    const currentIndentLevel = this.indentLevelForLine(line, tabLength)\r\n    if (currentIndentLevel === 0) return\r\n\r\n    const scopeDescriptor = this.scopeDescriptorForPosition(new Point(bufferRow, 0))\r\n    const decreaseIndentRegex = this.decreaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (!decreaseIndentRegex) return\r\n\r\n    if (!decreaseIndentRegex.testSync(line)) return\r\n\r\n    const precedingRow = this.buffer.previousNonBlankRow(bufferRow)\r\n    if (precedingRow == null) return\r\n\r\n    const precedingLine = this.buffer.lineForRow(precedingRow)\r\n    let desiredIndentLevel = this.indentLevelForLine(precedingLine, tabLength)\r\n\r\n    const increaseIndentRegex = this.increaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (increaseIndentRegex) {\r\n      if (!increaseIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    const decreaseNextIndentRegex = this.decreaseNextIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (decreaseNextIndentRegex) {\r\n      if (decreaseNextIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    if (desiredIndentLevel < 0) return 0\r\n    if (desiredIndentLevel >= currentIndentLevel) return\r\n    return desiredIndentLevel\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.indentLevelForLine","start_line":492,"end_line":505,"comment":[],"params":["line","tabLength"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"increaseIndentRegexForScopeDescriptor","line":136,"func_location":"TextMateLanguageMode.suggestedIndentForEditedBufferRow","func_start_line":119,"func_end_line":149,"args":["scopeDescriptor"],"comment":[" Get the suggested indentation level for a line in the buffer on which the user is currently"," typing. This may return a different result from {::suggestedIndentForBufferRow} in order"," to avoid unexpected changes in indentation. It may also return undefined if no change should"," be made.",""," * bufferRow - The row {Number}",""," Returns a {Number}."],"code":"  suggestedIndentForEditedBufferRow (bufferRow, tabLength) {\r\n    const line = this.buffer.lineForRow(bufferRow)\r\n    const currentIndentLevel = this.indentLevelForLine(line, tabLength)\r\n    if (currentIndentLevel === 0) return\r\n\r\n    const scopeDescriptor = this.scopeDescriptorForPosition(new Point(bufferRow, 0))\r\n    const decreaseIndentRegex = this.decreaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (!decreaseIndentRegex) return\r\n\r\n    if (!decreaseIndentRegex.testSync(line)) return\r\n\r\n    const precedingRow = this.buffer.previousNonBlankRow(bufferRow)\r\n    if (precedingRow == null) return\r\n\r\n    const precedingLine = this.buffer.lineForRow(precedingRow)\r\n    let desiredIndentLevel = this.indentLevelForLine(precedingLine, tabLength)\r\n\r\n    const increaseIndentRegex = this.increaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (increaseIndentRegex) {\r\n      if (!increaseIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    const decreaseNextIndentRegex = this.decreaseNextIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (decreaseNextIndentRegex) {\r\n      if (decreaseNextIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    if (desiredIndentLevel < 0) return 0\r\n    if (desiredIndentLevel >= currentIndentLevel) return\r\n    return desiredIndentLevel\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.increaseIndentRegexForScopeDescriptor","start_line":697,"end_line":699,"comment":[],"params":["scope"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"decreaseNextIndentRegexForScopeDescriptor","line":141,"func_location":"TextMateLanguageMode.suggestedIndentForEditedBufferRow","func_start_line":119,"func_end_line":149,"args":["scopeDescriptor"],"comment":[" Get the suggested indentation level for a line in the buffer on which the user is currently"," typing. This may return a different result from {::suggestedIndentForBufferRow} in order"," to avoid unexpected changes in indentation. It may also return undefined if no change should"," be made.",""," * bufferRow - The row {Number}",""," Returns a {Number}."],"code":"  suggestedIndentForEditedBufferRow (bufferRow, tabLength) {\r\n    const line = this.buffer.lineForRow(bufferRow)\r\n    const currentIndentLevel = this.indentLevelForLine(line, tabLength)\r\n    if (currentIndentLevel === 0) return\r\n\r\n    const scopeDescriptor = this.scopeDescriptorForPosition(new Point(bufferRow, 0))\r\n    const decreaseIndentRegex = this.decreaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (!decreaseIndentRegex) return\r\n\r\n    if (!decreaseIndentRegex.testSync(line)) return\r\n\r\n    const precedingRow = this.buffer.previousNonBlankRow(bufferRow)\r\n    if (precedingRow == null) return\r\n\r\n    const precedingLine = this.buffer.lineForRow(precedingRow)\r\n    let desiredIndentLevel = this.indentLevelForLine(precedingLine, tabLength)\r\n\r\n    const increaseIndentRegex = this.increaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (increaseIndentRegex) {\r\n      if (!increaseIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    const decreaseNextIndentRegex = this.decreaseNextIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (decreaseNextIndentRegex) {\r\n      if (decreaseNextIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    if (desiredIndentLevel < 0) return 0\r\n    if (desiredIndentLevel >= currentIndentLevel) return\r\n    return desiredIndentLevel\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.decreaseNextIndentRegexForScopeDescriptor","start_line":705,"end_line":707,"comment":[],"params":["scope"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"buildTokenizedLineForRowWithText","line":99,"func_location":"TextMateLanguageMode.suggestedIndentForLineAtBufferRow","func_start_line":98,"func_end_line":109,"args":["bufferRow","line"],"comment":[" Get the suggested indentation level for a given line of text, if it were inserted at the given"," row in the buffer.",""," * bufferRow - A {Number} indicating the buffer row",""," Returns a {Number}."],"code":"  suggestedIndentForLineAtBufferRow (bufferRow, line, tabLength) {\r\n    const tokenizedLine = this.buildTokenizedLineForRowWithText(bufferRow, line)\r\n    const iterator = tokenizedLine.getTokenIterator()\r\n    iterator.next()\r\n    const scopeDescriptor = new ScopeDescriptor({scopes: iterator.getScopes()})\r\n    return this._suggestedIndentForLineWithScopeAtBufferRow(\r\n      bufferRow,\r\n      line,\r\n      scopeDescriptor,\r\n      tabLength\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.buildTokenizedLineForRowWithText","start_line":411,"end_line":423,"comment":[],"params":["row","text","currentRuleStack","openScopes"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"_suggestedIndentForLineWithScopeAtBufferRow","line":103,"func_location":"TextMateLanguageMode.suggestedIndentForLineAtBufferRow","func_start_line":98,"func_end_line":109},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode._suggestedIndentForLineWithScopeAtBufferRow","start_line":151,"end_line":179,"comment":[],"params":["bufferRow","line","scopeDescriptor","tabLength","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"_forEachTreeWithRange","line":465,"func_location":"TreeSitterLanguageMode.syntaxTreeScopeDescriptorForPosition","func_start_line":454,"func_end_line":484},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"TreeSitterLanguageMode._forEachTreeWithRange","start_line":303,"end_line":316,"comment":[],"params":["range","callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"objectsEqual","line":4350,"func_location":"textDecorationsEqual","func_start_line":4342,"func_end_line":4354,"args":["oldDecorations.j.style","newDecorations.j.style"],"code":"function textDecorationsEqual (oldDecorations, newDecorations) {\r\n  if (!oldDecorations && newDecorations) return false\r\n  if (oldDecorations && !newDecorations) return false\r\n  if (oldDecorations && newDecorations) {\r\n    if (oldDecorations.length !== newDecorations.length) return false\r\n    for (let j = 0; j < oldDecorations.length; j++) {\r\n      if (oldDecorations[j].column !== newDecorations[j].column) return false\r\n      if (oldDecorations[j].className !== newDecorations[j].className) return false\r\n      if (!objectsEqual(oldDecorations[j].style, newDecorations[j].style)) return false\r\n    }\r\n  }\r\n  return true\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"objectsEqual","start_line":4364,"end_line":4376,"comment":[],"params":["a","b"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRowsPerTile","line":2717,"func_location":"TextEditorComponent.tileStartRowForRow","func_start_line":2716,"func_end_line":2718,"args":[],"code":"  tileStartRowForRow (row) {\r\n    return row - (row % this.getRowsPerTile())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRowsPerTile","start_line":2712,"end_line":2714,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js","name":"cancel","line":63,"func_location":"ReopenProjectListView.toggle","func_start_line":61,"func_end_line":70,"args":[],"code":"  async toggle () {\r\n    if (this.panel != null) {\r\n      this.cancel()\r\n    } else {\r\n      this.currentProjectName = atom.project != null ? this.makeName(atom.project.getPaths()) : null\r\n      const projects = atom.history.getProjects().map(p => ({ name: this.makeName(p.paths), value: p.paths }))\r\n      await this.selectListView.update({items: projects})\r\n      this.attach()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js","name":"ReopenProjectListView.cancel","start_line":40,"end_line":50,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js","name":"makeName","line":65,"func_location":"ReopenProjectListView.toggle","func_start_line":61,"func_end_line":70,"args":[null],"code":"  async toggle () {\r\n    if (this.panel != null) {\r\n      this.cancel()\r\n    } else {\r\n      this.currentProjectName = atom.project != null ? this.makeName(atom.project.getPaths()) : null\r\n      const projects = atom.history.getProjects().map(p => ({ name: this.makeName(p.paths), value: p.paths }))\r\n      await this.selectListView.update({items: projects})\r\n      this.attach()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js","name":"ReopenProjectListView.makeName","start_line":72,"end_line":74,"comment":[],"params":["paths"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js","name":"attach","line":68,"func_location":"ReopenProjectListView.toggle","func_start_line":61,"func_end_line":70,"args":[],"code":"  async toggle () {\r\n    if (this.panel != null) {\r\n      this.cancel()\r\n    } else {\r\n      this.currentProjectName = atom.project != null ? this.makeName(atom.project.getPaths()) : null\r\n      const projects = atom.history.getProjects().map(p => ({ name: this.makeName(p.paths), value: p.paths }))\r\n      await this.selectListView.update({items: projects})\r\n      this.attach()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js","name":"ReopenProjectListView.attach","start_line":52,"end_line":59,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"hide","line":1126,"func_location":"Workspace.toggle","func_start_line":1125,"func_end_line":1131,"args":["itemOrURI"],"comment":[" Essential: Search the workspace for items matching the given URI. If any are found, hide them."," Otherwise, open the URL.",""," * `itemOrURI` (optional) The item to toggle or a {String} containing the URI","   of the item to toggle.",""," Returns a Promise that resolves when the item is shown or hidden."],"code":"  toggle (itemOrURI) {\r\n    if (this.hide(itemOrURI)) {\r\n      return Promise.resolve()\r\n    } else {\r\n      return this.open(itemOrURI, {searchAllPanes: true})\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.hide","start_line":1087,"end_line":1116,"comment":[" Essential: Search the workspace for items matching the given URI and hide them.",""," * `itemOrURI` The item to hide or a {String} containing the URI","   of the item to hide.",""," Returns a {Boolean} indicating whether any items were found (and hidden)."],"params":["itemOrURI"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"open","line":1129,"func_location":"Workspace.toggle","func_start_line":1125,"func_end_line":1131,"args":["itemOrURI",null],"comment":[" Essential: Search the workspace for items matching the given URI. If any are found, hide them."," Otherwise, open the URL.",""," * `itemOrURI` (optional) The item to toggle or a {String} containing the URI","   of the item to toggle.",""," Returns a Promise that resolves when the item is shown or hidden."],"code":"  toggle (itemOrURI) {\r\n    if (this.hide(itemOrURI)) {\r\n      return Promise.resolve()\r\n    } else {\r\n      return this.open(itemOrURI, {searchAllPanes: true})\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.open","start_line":925,"end_line":1079,"comment":["\r\n  Section: Opening\r\n  "," Essential: Opens the given URI in Atom asynchronously."," If the URI is already open, the existing item for that URI will be"," activated. If no URI is given, or no registered opener can open"," the URI, a new empty {TextEditor} will be created.",""," * `uri` (optional) A {String} containing a URI."," * `options` (optional) {Object}","   * `initialLine` A {Number} indicating which row to move the cursor to","     initially. Defaults to `0`.","   * `initialColumn` A {Number} indicating which column to move the cursor to","     initially. Defaults to `0`.","   * `split` Either 'left', 'right', 'up' or 'down'.","     If 'left', the item will be opened in leftmost pane of the current active pane's row.","     If 'right', the item will be opened in the rightmost pane of the current active pane's row. If only one pane exists in the row, a new pane will be created.","     If 'up', the item will be opened in topmost pane of the current active pane's column.","     If 'down', the item will be opened in the bottommost pane of the current active pane's column. If only one pane exists in the column, a new pane will be created.","   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on","     containing pane. Defaults to `true`.","   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}","     on containing pane. Defaults to `true`.","   * `pending` A {Boolean} indicating whether or not the item should be opened","     in a pending state. Existing pending items in a pane are replaced with","     new pending items when they are opened.","   * `searchAllPanes` A {Boolean}. If `true`, the workspace will attempt to","     activate an existing item for the given URI on any pane.","     If `false`, only the active pane will be searched for","     an existing item for the same URI. Defaults to `false`.","   * `location` (optional) A {String} containing the name of the location","     in which this item should be opened (one of \"left\", \"right\", \"bottom\",","     or \"center\"). If omitted, Atom will fall back to the last location in","     which a user has placed an item with the same URI or, if this is a new","     URI, the default location specified by the item. NOTE: This option","     should almost always be omitted to honor user preference.",""," Returns a {Promise} that resolves to the {TextEditor} for the file URI."],"params":["itemOrURI","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"setState","line":134,"func_location":"Dock.toggle","func_start_line":131,"func_end_line":135,"args":["state"],"comment":[" Extended: Toggle the dock's visibility without changing the {Workspace}'s"," active pane container."],"code":"  toggle () {\r\n    const state = {visible: !this.state.visible}\r\n    if (!state.visible) state.hovered = false\r\n    this.setState(state)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js","name":"Dock.setState","start_line":144,"end_line":177,"comment":[],"params":["newState"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"setFullScreen","line":652,"func_location":"AtomEnvironment.toggleFullScreen","func_start_line":651,"func_end_line":653,"args":[null],"comment":[" Extended: Toggle the full screen state of the current window."],"code":"  toggleFullScreen () {\r\n    return this.setFullScreen(!this.isFullScreen())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.setFullScreen","start_line":646,"end_line":648,"comment":[" Extended: Set the full screen state of the current window."],"params":["fullScreen"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"isFullScreen","line":652,"func_location":"AtomEnvironment.toggleFullScreen","func_start_line":651,"func_end_line":653,"args":[null],"comment":[" Extended: Toggle the full screen state of the current window."],"code":"  toggleFullScreen () {\r\n    return this.setFullScreen(!this.isFullScreen())\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.isFullScreen","start_line":641,"end_line":643,"comment":[" Extended: Returns a {Boolean} that is `true` if the current window is in full screen mode."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js","name":"numberToHexString","line":79,"func_location":"Color.toHexString","func_start_line":78,"func_end_line":80,"args":[".red"],"comment":[" Essential: Returns a {String} in the form `'#abcdef'`."],"code":"  toHexString () {\r\n    return `#${numberToHexString(this.red)}${numberToHexString(this.green)}${numberToHexString(this.blue)}`\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js","name":"numberToHexString","start_line":126,"end_line":129,"comment":[],"params":["number"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js","name":"numberToHexString","line":79,"func_location":"Color.toHexString","func_start_line":78,"func_end_line":80,"args":[".red"],"comment":[" Essential: Returns a {String} in the form `'#abcdef'`."],"code":"  toHexString () {\r\n    return `#${numberToHexString(this.red)}${numberToHexString(this.green)}${numberToHexString(this.blue)}`\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js","name":"numberToHexString","start_line":126,"end_line":129,"comment":[],"params":["number"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js","name":"numberToHexString","line":79,"func_location":"Color.toHexString","func_start_line":78,"func_end_line":80,"args":[".red"],"comment":[" Essential: Returns a {String} in the form `'#abcdef'`."],"code":"  toHexString () {\r\n    return `#${numberToHexString(this.red)}${numberToHexString(this.green)}${numberToHexString(this.blue)}`\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js","name":"numberToHexString","start_line":126,"end_line":129,"comment":[],"params":["number"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js","name":"toHexString","line":88,"func_location":"Color.toJSON","func_start_line":87,"func_end_line":89,"args":[],"code":"  toJSON () {\r\n    return this.alpha === 1 ? this.toHexString() : this.toRGBAString()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js","name":"Color.toHexString","start_line":78,"end_line":80,"comment":[" Essential: Returns a {String} in the form `'#abcdef'`."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js","name":"toRGBAString","line":88,"func_location":"Color.toJSON","func_start_line":87,"func_end_line":89,"args":[],"code":"  toJSON () {\r\n    return this.alpha === 1 ? this.toHexString() : this.toRGBAString()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js","name":"Color.toRGBAString","start_line":83,"end_line":85,"comment":[" Essential: Returns a {String} in the form `'rgba(25, 50, 75, .9)'`."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"tokenizedLineForRow","line":530,"func_location":"TextMateLanguageMode.tokenForPosition","func_start_line":528,"func_end_line":531,"args":["column"],"code":"  tokenForPosition (position) {\r\n    const {row, column} = Point.fromObject(position)\r\n    return this.tokenizedLineForRow(row).tokenAtBufferColumn(column)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.tokenizedLineForRow","start_line":425,"end_line":449,"comment":[],"params":["bufferRow"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"getSyntaxNodeAtPosition","line":513,"func_location":"TreeSitterLanguageMode.tokenForPosition","func_start_line":512,"func_end_line":516,"args":["point"],"code":"  tokenForPosition (point) {\r\n    const node = this.getSyntaxNodeAtPosition(point)\r\n    const scopes = this.scopeDescriptorForPosition(point).getScopesArray()\r\n    return new Token({value: node.text, scopes})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"TreeSitterLanguageMode.getSyntaxNodeAtPosition","start_line":416,"end_line":418,"comment":[],"params":["position","where"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"scopeDescriptorForPosition","line":514,"func_location":"TreeSitterLanguageMode.tokenForPosition","func_start_line":512,"func_end_line":516,"args":[],"code":"  tokenForPosition (point) {\r\n    const node = this.getSyntaxNodeAtPosition(point)\r\n    const scopes = this.scopeDescriptorForPosition(point).getScopesArray()\r\n    return new Token({value: node.text, scopes})\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"TreeSitterLanguageMode.scopeDescriptorForPosition","start_line":486,"end_line":510,"comment":[],"params":["point"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"tokenizedLineForRow","line":454,"func_location":"TextMateLanguageMode.tokenizedLinesForRows","func_start_line":451,"func_end_line":457,"args":[null],"code":"  tokenizedLinesForRows (startRow, endRow) {\r\n    const result = []\r\n    for (let row = startRow, end = endRow; row <= end; row++) {\r\n      result.push(this.tokenizedLineForRow(row))\r\n    }\r\n    return result\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.tokenizedLineForRow","start_line":425,"end_line":449,"comment":[],"params":["bufferRow"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"firstInvalidRow","line":285,"func_location":"TextMateLanguageMode.tokenizeNextChunk","func_start_line":282,"func_end_line":319,"args":[],"code":"  tokenizeNextChunk () {\r\n    let rowsRemaining = this.chunkSize\r\n\r\n    while (this.firstInvalidRow() != null && rowsRemaining > 0) {\r\n      var endRow, filledRegion\r\n      const startRow = this.invalidRows.shift()\r\n      const lastRow = this.buffer.getLastRow()\r\n      if (startRow > lastRow) continue\r\n\r\n      let row = startRow\r\n      while (true) {\r\n        const previousStack = this.stackForRow(row)\r\n        this.tokenizedLines[row] = this.buildTokenizedLineForRow(row, this.stackForRow(row - 1), this.openScopesForRow(row))\r\n        if (--rowsRemaining === 0) {\r\n          filledRegion = false\r\n          endRow = row\r\n          break\r\n        }\r\n        if (row === lastRow || _.isEqual(this.stackForRow(row), previousStack)) {\r\n          filledRegion = true\r\n          endRow = row\r\n          break\r\n        }\r\n        row++\r\n      }\r\n\r\n      this.validateRow(endRow)\r\n      if (!filledRegion) this.invalidateRow(endRow + 1)\r\n\r\n      this.emitter.emit('did-change-highlighting', Range(Point(startRow, 0), Point(endRow + 1, 0)))\r\n    }\r\n\r\n    if (this.firstInvalidRow() != null) {\r\n      this.tokenizeInBackground()\r\n    } else {\r\n      this.markTokenizationComplete()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.firstInvalidRow","start_line":328,"end_line":330,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"stackForRow","line":293,"func_location":"TextMateLanguageMode.tokenizeNextChunk","func_start_line":282,"func_end_line":319,"args":["row"],"code":"  tokenizeNextChunk () {\r\n    let rowsRemaining = this.chunkSize\r\n\r\n    while (this.firstInvalidRow() != null && rowsRemaining > 0) {\r\n      var endRow, filledRegion\r\n      const startRow = this.invalidRows.shift()\r\n      const lastRow = this.buffer.getLastRow()\r\n      if (startRow > lastRow) continue\r\n\r\n      let row = startRow\r\n      while (true) {\r\n        const previousStack = this.stackForRow(row)\r\n        this.tokenizedLines[row] = this.buildTokenizedLineForRow(row, this.stackForRow(row - 1), this.openScopesForRow(row))\r\n        if (--rowsRemaining === 0) {\r\n          filledRegion = false\r\n          endRow = row\r\n          break\r\n        }\r\n        if (row === lastRow || _.isEqual(this.stackForRow(row), previousStack)) {\r\n          filledRegion = true\r\n          endRow = row\r\n          break\r\n        }\r\n        row++\r\n      }\r\n\r\n      this.validateRow(endRow)\r\n      if (!filledRegion) this.invalidateRow(endRow + 1)\r\n\r\n      this.emitter.emit('did-change-highlighting', Range(Point(startRow, 0), Point(endRow + 1, 0)))\r\n    }\r\n\r\n    if (this.firstInvalidRow() != null) {\r\n      this.tokenizeInBackground()\r\n    } else {\r\n      this.markTokenizationComplete()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.stackForRow","start_line":459,"end_line":461,"comment":[],"params":["bufferRow"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"buildTokenizedLineForRow","line":294,"func_location":"TextMateLanguageMode.tokenizeNextChunk","func_start_line":282,"func_end_line":319,"args":["row",null,null],"code":"  tokenizeNextChunk () {\r\n    let rowsRemaining = this.chunkSize\r\n\r\n    while (this.firstInvalidRow() != null && rowsRemaining > 0) {\r\n      var endRow, filledRegion\r\n      const startRow = this.invalidRows.shift()\r\n      const lastRow = this.buffer.getLastRow()\r\n      if (startRow > lastRow) continue\r\n\r\n      let row = startRow\r\n      while (true) {\r\n        const previousStack = this.stackForRow(row)\r\n        this.tokenizedLines[row] = this.buildTokenizedLineForRow(row, this.stackForRow(row - 1), this.openScopesForRow(row))\r\n        if (--rowsRemaining === 0) {\r\n          filledRegion = false\r\n          endRow = row\r\n          break\r\n        }\r\n        if (row === lastRow || _.isEqual(this.stackForRow(row), previousStack)) {\r\n          filledRegion = true\r\n          endRow = row\r\n          break\r\n        }\r\n        row++\r\n      }\r\n\r\n      this.validateRow(endRow)\r\n      if (!filledRegion) this.invalidateRow(endRow + 1)\r\n\r\n      this.emitter.emit('did-change-highlighting', Range(Point(startRow, 0), Point(endRow + 1, 0)))\r\n    }\r\n\r\n    if (this.firstInvalidRow() != null) {\r\n      this.tokenizeInBackground()\r\n    } else {\r\n      this.markTokenizationComplete()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.buildTokenizedLineForRow","start_line":407,"end_line":409,"comment":[],"params":["row","ruleStack","openScopes"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"stackForRow","line":294,"func_location":"TextMateLanguageMode.tokenizeNextChunk","func_start_line":282,"func_end_line":319,"args":["row",null,null],"code":"  tokenizeNextChunk () {\r\n    let rowsRemaining = this.chunkSize\r\n\r\n    while (this.firstInvalidRow() != null && rowsRemaining > 0) {\r\n      var endRow, filledRegion\r\n      const startRow = this.invalidRows.shift()\r\n      const lastRow = this.buffer.getLastRow()\r\n      if (startRow > lastRow) continue\r\n\r\n      let row = startRow\r\n      while (true) {\r\n        const previousStack = this.stackForRow(row)\r\n        this.tokenizedLines[row] = this.buildTokenizedLineForRow(row, this.stackForRow(row - 1), this.openScopesForRow(row))\r\n        if (--rowsRemaining === 0) {\r\n          filledRegion = false\r\n          endRow = row\r\n          break\r\n        }\r\n        if (row === lastRow || _.isEqual(this.stackForRow(row), previousStack)) {\r\n          filledRegion = true\r\n          endRow = row\r\n          break\r\n        }\r\n        row++\r\n      }\r\n\r\n      this.validateRow(endRow)\r\n      if (!filledRegion) this.invalidateRow(endRow + 1)\r\n\r\n      this.emitter.emit('did-change-highlighting', Range(Point(startRow, 0), Point(endRow + 1, 0)))\r\n    }\r\n\r\n    if (this.firstInvalidRow() != null) {\r\n      this.tokenizeInBackground()\r\n    } else {\r\n      this.markTokenizationComplete()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.stackForRow","start_line":459,"end_line":461,"comment":[],"params":["bufferRow"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"openScopesForRow","line":294,"func_location":"TextMateLanguageMode.tokenizeNextChunk","func_start_line":282,"func_end_line":319,"args":["row",null,null],"code":"  tokenizeNextChunk () {\r\n    let rowsRemaining = this.chunkSize\r\n\r\n    while (this.firstInvalidRow() != null && rowsRemaining > 0) {\r\n      var endRow, filledRegion\r\n      const startRow = this.invalidRows.shift()\r\n      const lastRow = this.buffer.getLastRow()\r\n      if (startRow > lastRow) continue\r\n\r\n      let row = startRow\r\n      while (true) {\r\n        const previousStack = this.stackForRow(row)\r\n        this.tokenizedLines[row] = this.buildTokenizedLineForRow(row, this.stackForRow(row - 1), this.openScopesForRow(row))\r\n        if (--rowsRemaining === 0) {\r\n          filledRegion = false\r\n          endRow = row\r\n          break\r\n        }\r\n        if (row === lastRow || _.isEqual(this.stackForRow(row), previousStack)) {\r\n          filledRegion = true\r\n          endRow = row\r\n          break\r\n        }\r\n        row++\r\n      }\r\n\r\n      this.validateRow(endRow)\r\n      if (!filledRegion) this.invalidateRow(endRow + 1)\r\n\r\n      this.emitter.emit('did-change-highlighting', Range(Point(startRow, 0), Point(endRow + 1, 0)))\r\n    }\r\n\r\n    if (this.firstInvalidRow() != null) {\r\n      this.tokenizeInBackground()\r\n    } else {\r\n      this.markTokenizationComplete()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.openScopesForRow","start_line":463,"end_line":470,"comment":[],"params":["bufferRow"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"stackForRow","line":300,"func_location":"TextMateLanguageMode.tokenizeNextChunk","func_start_line":282,"func_end_line":319,"args":[null,"previousStack"],"code":"  tokenizeNextChunk () {\r\n    let rowsRemaining = this.chunkSize\r\n\r\n    while (this.firstInvalidRow() != null && rowsRemaining > 0) {\r\n      var endRow, filledRegion\r\n      const startRow = this.invalidRows.shift()\r\n      const lastRow = this.buffer.getLastRow()\r\n      if (startRow > lastRow) continue\r\n\r\n      let row = startRow\r\n      while (true) {\r\n        const previousStack = this.stackForRow(row)\r\n        this.tokenizedLines[row] = this.buildTokenizedLineForRow(row, this.stackForRow(row - 1), this.openScopesForRow(row))\r\n        if (--rowsRemaining === 0) {\r\n          filledRegion = false\r\n          endRow = row\r\n          break\r\n        }\r\n        if (row === lastRow || _.isEqual(this.stackForRow(row), previousStack)) {\r\n          filledRegion = true\r\n          endRow = row\r\n          break\r\n        }\r\n        row++\r\n      }\r\n\r\n      this.validateRow(endRow)\r\n      if (!filledRegion) this.invalidateRow(endRow + 1)\r\n\r\n      this.emitter.emit('did-change-highlighting', Range(Point(startRow, 0), Point(endRow + 1, 0)))\r\n    }\r\n\r\n    if (this.firstInvalidRow() != null) {\r\n      this.tokenizeInBackground()\r\n    } else {\r\n      this.markTokenizationComplete()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.stackForRow","start_line":459,"end_line":461,"comment":[],"params":["bufferRow"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"validateRow","line":308,"func_location":"TextMateLanguageMode.tokenizeNextChunk","func_start_line":282,"func_end_line":319,"args":["endRow"],"code":"  tokenizeNextChunk () {\r\n    let rowsRemaining = this.chunkSize\r\n\r\n    while (this.firstInvalidRow() != null && rowsRemaining > 0) {\r\n      var endRow, filledRegion\r\n      const startRow = this.invalidRows.shift()\r\n      const lastRow = this.buffer.getLastRow()\r\n      if (startRow > lastRow) continue\r\n\r\n      let row = startRow\r\n      while (true) {\r\n        const previousStack = this.stackForRow(row)\r\n        this.tokenizedLines[row] = this.buildTokenizedLineForRow(row, this.stackForRow(row - 1), this.openScopesForRow(row))\r\n        if (--rowsRemaining === 0) {\r\n          filledRegion = false\r\n          endRow = row\r\n          break\r\n        }\r\n        if (row === lastRow || _.isEqual(this.stackForRow(row), previousStack)) {\r\n          filledRegion = true\r\n          endRow = row\r\n          break\r\n        }\r\n        row++\r\n      }\r\n\r\n      this.validateRow(endRow)\r\n      if (!filledRegion) this.invalidateRow(endRow + 1)\r\n\r\n      this.emitter.emit('did-change-highlighting', Range(Point(startRow, 0), Point(endRow + 1, 0)))\r\n    }\r\n\r\n    if (this.firstInvalidRow() != null) {\r\n      this.tokenizeInBackground()\r\n    } else {\r\n      this.markTokenizationComplete()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.validateRow","start_line":332,"end_line":334,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"invalidateRow","line":309,"func_location":"TextMateLanguageMode.tokenizeNextChunk","func_start_line":282,"func_end_line":319,"args":[null],"code":"  tokenizeNextChunk () {\r\n    let rowsRemaining = this.chunkSize\r\n\r\n    while (this.firstInvalidRow() != null && rowsRemaining > 0) {\r\n      var endRow, filledRegion\r\n      const startRow = this.invalidRows.shift()\r\n      const lastRow = this.buffer.getLastRow()\r\n      if (startRow > lastRow) continue\r\n\r\n      let row = startRow\r\n      while (true) {\r\n        const previousStack = this.stackForRow(row)\r\n        this.tokenizedLines[row] = this.buildTokenizedLineForRow(row, this.stackForRow(row - 1), this.openScopesForRow(row))\r\n        if (--rowsRemaining === 0) {\r\n          filledRegion = false\r\n          endRow = row\r\n          break\r\n        }\r\n        if (row === lastRow || _.isEqual(this.stackForRow(row), previousStack)) {\r\n          filledRegion = true\r\n          endRow = row\r\n          break\r\n        }\r\n        row++\r\n      }\r\n\r\n      this.validateRow(endRow)\r\n      if (!filledRegion) this.invalidateRow(endRow + 1)\r\n\r\n      this.emitter.emit('did-change-highlighting', Range(Point(startRow, 0), Point(endRow + 1, 0)))\r\n    }\r\n\r\n    if (this.firstInvalidRow() != null) {\r\n      this.tokenizeInBackground()\r\n    } else {\r\n      this.markTokenizationComplete()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.invalidateRow","start_line":336,"end_line":340,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"firstInvalidRow","line":314,"func_location":"TextMateLanguageMode.tokenizeNextChunk","func_start_line":282,"func_end_line":319,"args":[],"code":"  tokenizeNextChunk () {\r\n    let rowsRemaining = this.chunkSize\r\n\r\n    while (this.firstInvalidRow() != null && rowsRemaining > 0) {\r\n      var endRow, filledRegion\r\n      const startRow = this.invalidRows.shift()\r\n      const lastRow = this.buffer.getLastRow()\r\n      if (startRow > lastRow) continue\r\n\r\n      let row = startRow\r\n      while (true) {\r\n        const previousStack = this.stackForRow(row)\r\n        this.tokenizedLines[row] = this.buildTokenizedLineForRow(row, this.stackForRow(row - 1), this.openScopesForRow(row))\r\n        if (--rowsRemaining === 0) {\r\n          filledRegion = false\r\n          endRow = row\r\n          break\r\n        }\r\n        if (row === lastRow || _.isEqual(this.stackForRow(row), previousStack)) {\r\n          filledRegion = true\r\n          endRow = row\r\n          break\r\n        }\r\n        row++\r\n      }\r\n\r\n      this.validateRow(endRow)\r\n      if (!filledRegion) this.invalidateRow(endRow + 1)\r\n\r\n      this.emitter.emit('did-change-highlighting', Range(Point(startRow, 0), Point(endRow + 1, 0)))\r\n    }\r\n\r\n    if (this.firstInvalidRow() != null) {\r\n      this.tokenizeInBackground()\r\n    } else {\r\n      this.markTokenizationComplete()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.firstInvalidRow","start_line":328,"end_line":330,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"tokenizeInBackground","line":315,"func_location":"TextMateLanguageMode.tokenizeNextChunk","func_start_line":282,"func_end_line":319,"args":[],"code":"  tokenizeNextChunk () {\r\n    let rowsRemaining = this.chunkSize\r\n\r\n    while (this.firstInvalidRow() != null && rowsRemaining > 0) {\r\n      var endRow, filledRegion\r\n      const startRow = this.invalidRows.shift()\r\n      const lastRow = this.buffer.getLastRow()\r\n      if (startRow > lastRow) continue\r\n\r\n      let row = startRow\r\n      while (true) {\r\n        const previousStack = this.stackForRow(row)\r\n        this.tokenizedLines[row] = this.buildTokenizedLineForRow(row, this.stackForRow(row - 1), this.openScopesForRow(row))\r\n        if (--rowsRemaining === 0) {\r\n          filledRegion = false\r\n          endRow = row\r\n          break\r\n        }\r\n        if (row === lastRow || _.isEqual(this.stackForRow(row), previousStack)) {\r\n          filledRegion = true\r\n          endRow = row\r\n          break\r\n        }\r\n        row++\r\n      }\r\n\r\n      this.validateRow(endRow)\r\n      if (!filledRegion) this.invalidateRow(endRow + 1)\r\n\r\n      this.emitter.emit('did-change-highlighting', Range(Point(startRow, 0), Point(endRow + 1, 0)))\r\n    }\r\n\r\n    if (this.firstInvalidRow() != null) {\r\n      this.tokenizeInBackground()\r\n    } else {\r\n      this.markTokenizationComplete()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.tokenizeInBackground","start_line":272,"end_line":280,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"markTokenizationComplete","line":317,"func_location":"TextMateLanguageMode.tokenizeNextChunk","func_start_line":282,"func_end_line":319,"args":[],"code":"  tokenizeNextChunk () {\r\n    let rowsRemaining = this.chunkSize\r\n\r\n    while (this.firstInvalidRow() != null && rowsRemaining > 0) {\r\n      var endRow, filledRegion\r\n      const startRow = this.invalidRows.shift()\r\n      const lastRow = this.buffer.getLastRow()\r\n      if (startRow > lastRow) continue\r\n\r\n      let row = startRow\r\n      while (true) {\r\n        const previousStack = this.stackForRow(row)\r\n        this.tokenizedLines[row] = this.buildTokenizedLineForRow(row, this.stackForRow(row - 1), this.openScopesForRow(row))\r\n        if (--rowsRemaining === 0) {\r\n          filledRegion = false\r\n          endRow = row\r\n          break\r\n        }\r\n        if (row === lastRow || _.isEqual(this.stackForRow(row), previousStack)) {\r\n          filledRegion = true\r\n          endRow = row\r\n          break\r\n        }\r\n        row++\r\n      }\r\n\r\n      this.validateRow(endRow)\r\n      if (!filledRegion) this.invalidateRow(endRow + 1)\r\n\r\n      this.emitter.emit('did-change-highlighting', Range(Point(startRow, 0), Point(endRow + 1, 0)))\r\n    }\r\n\r\n    if (this.firstInvalidRow() != null) {\r\n      this.tokenizeInBackground()\r\n    } else {\r\n      this.markTokenizationComplete()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.markTokenizationComplete","start_line":321,"end_line":326,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"screenLineForScreenRow","line":1255,"func_location":"TextEditor.tokensForScreenRow","func_start_line":1251,"func_end_line":1270,"args":["screenRow"],"code":"  tokensForScreenRow (screenRow) {\r\n    const tokens = []\r\n    let lineTextIndex = 0\r\n    const currentTokenScopes = []\r\n    const {lineText, tags} = this.screenLineForScreenRow(screenRow)\r\n    for (const tag of tags) {\r\n      if (this.displayLayer.isOpenTag(tag)) {\r\n        currentTokenScopes.push(this.displayLayer.classNameForTag(tag))\r\n      } else if (this.displayLayer.isCloseTag(tag)) {\r\n        currentTokenScopes.pop()\r\n      } else {\r\n        tokens.push({\r\n          text: lineText.substr(lineTextIndex, tag),\r\n          scopes: currentTokenScopes.slice()\r\n        })\r\n        lineTextIndex += tag\r\n      }\r\n    }\r\n    return tokens\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.screenLineForScreenRow","start_line":1272,"end_line":1274,"comment":[],"params":["screenRow"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"tokenizedLineForRow","line":535,"func_location":"TextMateLanguageMode.tokenStartPositionForPosition","func_start_line":533,"func_end_line":537,"args":["column"],"code":"  tokenStartPositionForPosition (position) {\r\n    let {row, column} = Point.fromObject(position)\r\n    column = this.tokenizedLineForRow(row).tokenStartColumnForBufferColumn(column)\r\n    return new Point(row, column)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.tokenizedLineForRow","start_line":425,"end_line":449,"comment":[],"params":["bufferRow"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/scope-descriptor.js","name":"getScopeChain","line":65,"func_location":"ScopeDescriptor.toString","func_start_line":64,"func_end_line":66,"args":[],"code":"  toString () {\r\n    return this.getScopeChain()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/scope-descriptor.js","name":"ScopeDescriptor.getScopeChain","start_line":47,"end_line":62,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js","name":"toRGBAString","line":92,"func_location":"Color.toString","func_start_line":91,"func_end_line":93,"args":[],"code":"  toString () {\r\n    return this.toRGBAString()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js","name":"Color.toRGBAString","start_line":83,"end_line":85,"comment":[" Essential: Returns a {String} in the form `'rgba(25, 50, 75, .9)'`."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"addWindow","line":1405,"func_location":"WindowStack.touch","func_start_line":1404,"func_end_line":1406,"args":["window"],"code":"  touch (window) {\r\n    return this.addWindow(window)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"WindowStack.addWindow","start_line":1399,"end_line":1402,"comment":[],"params":["window"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"beginTransaction","line":817,"func_location":"Config.transact","func_start_line":816,"func_end_line":823,"args":[],"comment":[" Extended: Suppress calls to handler functions registered with {::onDidChange}"," and {::observe} for the duration of `callback`. After `callback` executes,"," handlers will be called once if the value for their key-path has changed.",""," * `callback` {Function} to execute while suppressing calls to handlers."],"code":"  transact (callback) {\r\n    this.beginTransaction()\r\n    try {\r\n      return callback()\r\n    } finally {\r\n      this.endTransaction()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.beginTransaction","start_line":862,"end_line":864,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"endTransaction","line":821,"func_location":"Config.transact","func_start_line":816,"func_end_line":823,"args":[],"comment":[" Extended: Suppress calls to handler functions registered with {::onDidChange}"," and {::observe} for the duration of `callback`. After `callback` executes,"," handlers will be called once if the value for their key-path has changed.",""," * `callback` {Function} to execute while suppressing calls to handlers."],"code":"  transact (callback) {\r\n    this.beginTransaction()\r\n    try {\r\n      return callback()\r\n    } finally {\r\n      this.endTransaction()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.endTransaction","start_line":866,"end_line":869,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"beginTransaction","line":846,"func_location":"Config.transactAsync","func_start_line":844,"func_end_line":860,"args":[],"comment":["\r\n  Section: Internal methods used by core\r\n  "," Private: Suppress calls to handler functions registered with {::onDidChange}"," and {::observe} for the duration of the {Promise} returned by `callback`."," After the {Promise} is either resolved or rejected, handlers will be called"," once if the value for their key-path has changed.",""," * `callback` {Function} that returns a {Promise}, which will be executed","   while suppressing calls to handlers.",""," Returns a {Promise} that is either resolved or rejected according to the"," `{Promise}` returned by `callback`. If `callback` throws an error, a"," rejected {Promise} will be returned instead."],"code":"  transactAsync (callback) {\r\n    let endTransaction\r\n    this.beginTransaction()\r\n    try {\r\n      endTransaction = fn => (...args) => {\r\n        this.endTransaction()\r\n        return fn(...args)\r\n      }\r\n      const result = callback()\r\n      return new Promise((resolve, reject) => {\r\n        return result.then(endTransaction(resolve)).catch(endTransaction(reject))\r\n      })\r\n    } catch (error) {\r\n      this.endTransaction()\r\n      return Promise.reject(error)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.beginTransaction","start_line":862,"end_line":864,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"endTransaction","line":857,"func_location":"Config.transactAsync","func_start_line":844,"func_end_line":860,"args":[],"comment":["\r\n  Section: Internal methods used by core\r\n  "," Private: Suppress calls to handler functions registered with {::onDidChange}"," and {::observe} for the duration of the {Promise} returned by `callback`."," After the {Promise} is either resolved or rejected, handlers will be called"," once if the value for their key-path has changed.",""," * `callback` {Function} that returns a {Promise}, which will be executed","   while suppressing calls to handlers.",""," Returns a {Promise} that is either resolved or rejected according to the"," `{Promise}` returned by `callback`. If `callback` throws an error, a"," rejected {Promise} will be returned instead."],"code":"  transactAsync (callback) {\r\n    let endTransaction\r\n    this.beginTransaction()\r\n    try {\r\n      endTransaction = fn => (...args) => {\r\n        this.endTransaction()\r\n        return fn(...args)\r\n      }\r\n      const result = callback()\r\n      return new Promise((resolve, reject) => {\r\n        return result.then(endTransaction(resolve)).catch(endTransaction(reject))\r\n      })\r\n    } catch (error) {\r\n      this.endTransaction()\r\n      return Promise.reject(error)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.endTransaction","start_line":866,"end_line":869,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js","name":"getTranspiler","line":134,"func_location":"PackageTranspilationRegistry.transpileWithPackageTranspiler","func_start_line":133,"func_end_line":150,"args":["spec"],"code":"  transpileWithPackageTranspiler (sourceCode, filePath, spec) {\r\n    const transpiler = this.getTranspiler(spec)\r\n\r\n    if (transpiler) {\r\n      const meta = this.getMetadata(spec)\r\n      const result = transpiler.transpile(sourceCode, filePath, spec.options || {}, meta)\r\n      if (result === undefined || (result && result.code === undefined)) {\r\n        return sourceCode\r\n      } else if (result.code) {\r\n        return result.code.toString()\r\n      } else {\r\n        throw new Error('Could not find a property `.code` on the transpilation results of ' + filePath)\r\n      }\r\n    } else {\r\n      const err = new Error(\"Could not resolve transpiler '\" + spec.transpiler + \"' from '\" + spec._config.path + \"'\")\r\n      throw err\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js","name":"PackageTranspilationRegistry.getTranspiler","start_line":168,"end_line":175,"comment":[],"params":["spec"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js","name":"getMetadata","line":137,"func_location":"PackageTranspilationRegistry.transpileWithPackageTranspiler","func_start_line":133,"func_end_line":150,"args":["spec"],"code":"  transpileWithPackageTranspiler (sourceCode, filePath, spec) {\r\n    const transpiler = this.getTranspiler(spec)\r\n\r\n    if (transpiler) {\r\n      const meta = this.getMetadata(spec)\r\n      const result = transpiler.transpile(sourceCode, filePath, spec.options || {}, meta)\r\n      if (result === undefined || (result && result.code === undefined)) {\r\n        return sourceCode\r\n      } else if (result.code) {\r\n        return result.code.toString()\r\n      } else {\r\n        throw new Error('Could not find a property `.code` on the transpilation results of ' + filePath)\r\n      }\r\n    } else {\r\n      const err = new Error(\"Could not resolve transpiler '\" + spec.transpiler + \"' from '\" + spec._config.path + \"'\")\r\n      throw err\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js","name":"PackageTranspilationRegistry.getMetadata","start_line":152,"end_line":158,"comment":[],"params":["spec"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/native-compile-cache.js","name":"restorePreviousModuleCompile","line":30,"func_location":"NativeCompileCache.uninstall","func_start_line":29,"func_end_line":31,"args":[],"code":"  uninstall () {\r\n    this.restorePreviousModuleCompile()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/native-compile-cache.js","name":"NativeCompileCache.restorePreviousModuleCompile","start_line":91,"end_line":93,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"unregisterTranspilerConfig","line":147,"func_location":"Package.unload","func_start_line":146,"func_end_line":148,"args":[],"code":"  unload () {\r\n    this.unregisterTranspilerConfig()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js","name":"Package.unregisterTranspilerConfig","start_line":432,"end_line":436,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"storeWindowBackground","line":904,"func_location":"AtomEnvironment.unloadEditorWindow","func_start_line":901,"func_end_line":906,"args":[],"code":"  unloadEditorWindow () {\r\n    if (!this.project) return\r\n\r\n    this.storeWindowBackground()\r\n    this.saveBlobStoreSync()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.storeWindowBackground","start_line":765,"end_line":770,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"saveBlobStoreSync","line":905,"func_location":"AtomEnvironment.unloadEditorWindow","func_start_line":901,"func_end_line":906,"args":[],"code":"  unloadEditorWindow () {\r\n    if (!this.project) return\r\n\r\n    this.storeWindowBackground()\r\n    this.saveBlobStoreSync()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.saveBlobStoreSync","start_line":908,"end_line":912,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"isPackageActive","line":642,"func_location":"PackageManager.unloadPackage","func_start_line":641,"func_end_line":653,"args":["name"],"code":"  unloadPackage (name) {\r\n    if (this.isPackageActive(name)) {\r\n      throw new Error(`Tried to unload active package '${name}'`)\r\n    }\r\n\r\n    const pack = this.getLoadedPackage(name)\r\n    if (pack) {\r\n      delete this.loadedPackages[pack.name]\r\n      this.emitter.emit('did-unload-package', pack)\r\n    } else {\r\n      throw new Error(`No loaded package for name '${name}'`)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.isPackageActive","start_line":309,"end_line":311,"comment":[" Public: Is the {Package} with the given name active?",""," * `name` - The {String} package name.",""," Returns a {Boolean}."],"params":["name"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"getLoadedPackage","line":646,"func_location":"PackageManager.unloadPackage","func_start_line":641,"func_end_line":653,"args":["name"],"code":"  unloadPackage (name) {\r\n    if (this.isPackageActive(name)) {\r\n      throw new Error(`Tried to unload active package '${name}'`)\r\n    }\r\n\r\n    const pack = this.getLoadedPackage(name)\r\n    if (pack) {\r\n      delete this.loadedPackages[pack.name]\r\n      this.emitter.emit('did-unload-package', pack)\r\n    } else {\r\n      throw new Error(`No loaded package for name '${name}'`)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js","name":"PackageManager.getLoadedPackage","start_line":339,"end_line":341,"comment":[" Public: Get the loaded {Package} with the given name.",""," * `name` - The {String} package name.",""," Returns a {Package} or undefined."],"params":["name"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js","name":"findMatchingItemIndex","line":35,"func_location":"unmerge","func_start_line":34,"func_end_line":50,"args":["menu","item"],"code":"function unmerge (menu, item) {\r\n  const matchingItemIndex = findMatchingItemIndex(menu, item)\r\n  if (matchingItemIndex === -1) {\r\n    return\r\n  }\r\n\r\n  const matchingItem = menu[matchingItemIndex]\r\n  if (item.submenu != null) {\r\n    for (let submenuItem of item.submenu) {\r\n      unmerge(matchingItem.submenu, submenuItem)\r\n    }\r\n  }\r\n\r\n  if (matchingItem.submenu == null || matchingItem.submenu.length === 0) {\r\n    menu.splice(matchingItemIndex, 1)\r\n  }\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js","name":"findMatchingItemIndex","start_line":52,"end_line":66,"comment":[],"params":["menu",["type","label","submenu"]]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js","name":"unmerge","line":43,"func_location":"unmerge","func_start_line":34,"func_end_line":50,"args":["matchingItem.submenu","submenuItem"],"code":"function unmerge (menu, item) {\r\n  const matchingItemIndex = findMatchingItemIndex(menu, item)\r\n  if (matchingItemIndex === -1) {\r\n    return\r\n  }\r\n\r\n  const matchingItem = menu[matchingItemIndex]\r\n  if (item.submenu != null) {\r\n    for (let submenuItem of item.submenu) {\r\n      unmerge(matchingItem.submenu, submenuItem)\r\n    }\r\n  }\r\n\r\n  if (matchingItem.submenu == null || matchingItem.submenu.length === 0) {\r\n    menu.splice(matchingItemIndex, 1)\r\n  }\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js","name":"unmerge","start_line":34,"end_line":50,"comment":[],"params":["menu","item"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"set","line":746,"func_location":"Config.unset","func_start_line":730,"func_end_line":766,"args":[{"type":"object"},"settings",null],"comment":[" Essential: Restore the setting at `keyPath` to its default value.",""," * `keyPath` The {String} name of the key."," * `options` (optional) {Object}","   * `scopeSelector` (optional) {String}. See {::set}","   * `source` (optional) {String}. See {::set}"],"code":"  unset (keyPath, options) {\r\n    if (!this.settingsLoaded) {\r\n      this.pendingOperations.push(() => this.unset(keyPath, options))\r\n    }\r\n\r\n    let {scopeSelector, source} = options != null ? options : {}\r\n    if (source == null) { source = this.mainSource }\r\n\r\n    if (scopeSelector != null) {\r\n      if (keyPath != null) {\r\n        let settings = this.scopedSettingsStore.propertiesForSourceAndSelector(source, scopeSelector)\r\n        if (getValueAtKeyPath(settings, keyPath) != null) {\r\n          this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n          setValueAtKeyPath(settings, keyPath, undefined)\r\n          settings = withoutEmptyObjects(settings)\r\n          if (settings != null) {\r\n            this.set(null, settings, {scopeSelector, source, priority: this.priorityForSource(source)})\r\n          }\r\n\r\n          const configIsReady = (source === this.mainSource) && this.settingsLoaded\r\n          if (configIsReady) {\r\n            return this.requestSave()\r\n          }\r\n        }\r\n      } else {\r\n        this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n        return this.emitChangeEvent()\r\n      }\r\n    } else {\r\n      for (scopeSelector in this.scopedSettingsStore.propertiesForSource(source)) {\r\n        this.unset(keyPath, {scopeSelector, source})\r\n      }\r\n      if ((keyPath != null) && (source === this.mainSource)) {\r\n        return this.set(keyPath, getValueAtKeyPath(this.defaultSettings, keyPath))\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.set","start_line":687,"end_line":722,"comment":[" Essential: Sets the value for a configuration setting.",""," This value is stored in Atom's internal configuration file.",""," ### Examples",""," You might want to change the themes programmatically:",""," ```coffee"," atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])"," ```",""," You can also set scoped settings. For example, you might want change the"," `editor.tabLength` only for ruby files.",""," ```coffee"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4"," atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",""," # Set ruby to 2"," atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true",""," # Notice it's only set to 2 in the case of ruby"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," atom.config.get('editor.tabLength', scope: ['source.js']) # => 4"," ```",""," * `keyPath` The {String} name of the key."," * `value` The value of the setting. Passing `undefined` will revert the","   setting to the default value."," * `options` (optional) {Object}","   * `scopeSelector` (optional) {String}. eg. '.source.ruby'","     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)","     for more information.","   * `source` (optional) {String} The name of a file with which the setting","     is associated. Defaults to the user's config file.",""," Returns a {Boolean}"," * `true` if the value was set."," * `false` if the value was not able to be coerced to the type specified in the setting's schema."],"params":["args"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"priorityForSource","line":746,"func_location":"Config.unset","func_start_line":730,"func_end_line":766,"args":[{"type":"object"},"settings",null],"comment":[" Essential: Restore the setting at `keyPath` to its default value.",""," * `keyPath` The {String} name of the key."," * `options` (optional) {Object}","   * `scopeSelector` (optional) {String}. See {::set}","   * `source` (optional) {String}. See {::set}"],"code":"  unset (keyPath, options) {\r\n    if (!this.settingsLoaded) {\r\n      this.pendingOperations.push(() => this.unset(keyPath, options))\r\n    }\r\n\r\n    let {scopeSelector, source} = options != null ? options : {}\r\n    if (source == null) { source = this.mainSource }\r\n\r\n    if (scopeSelector != null) {\r\n      if (keyPath != null) {\r\n        let settings = this.scopedSettingsStore.propertiesForSourceAndSelector(source, scopeSelector)\r\n        if (getValueAtKeyPath(settings, keyPath) != null) {\r\n          this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n          setValueAtKeyPath(settings, keyPath, undefined)\r\n          settings = withoutEmptyObjects(settings)\r\n          if (settings != null) {\r\n            this.set(null, settings, {scopeSelector, source, priority: this.priorityForSource(source)})\r\n          }\r\n\r\n          const configIsReady = (source === this.mainSource) && this.settingsLoaded\r\n          if (configIsReady) {\r\n            return this.requestSave()\r\n          }\r\n        }\r\n      } else {\r\n        this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n        return this.emitChangeEvent()\r\n      }\r\n    } else {\r\n      for (scopeSelector in this.scopedSettingsStore.propertiesForSource(source)) {\r\n        this.unset(keyPath, {scopeSelector, source})\r\n      }\r\n      if ((keyPath != null) && (source === this.mainSource)) {\r\n        return this.set(keyPath, getValueAtKeyPath(this.defaultSettings, keyPath))\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.priorityForSource","start_line":1200,"end_line":1209,"comment":["\r\n  Section: Private Scoped Settings\r\n  "],"params":["source"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"emitChangeEvent","line":756,"func_location":"Config.unset","func_start_line":730,"func_end_line":766,"args":[],"comment":[" Essential: Restore the setting at `keyPath` to its default value.",""," * `keyPath` The {String} name of the key."," * `options` (optional) {Object}","   * `scopeSelector` (optional) {String}. See {::set}","   * `source` (optional) {String}. See {::set}"],"code":"  unset (keyPath, options) {\r\n    if (!this.settingsLoaded) {\r\n      this.pendingOperations.push(() => this.unset(keyPath, options))\r\n    }\r\n\r\n    let {scopeSelector, source} = options != null ? options : {}\r\n    if (source == null) { source = this.mainSource }\r\n\r\n    if (scopeSelector != null) {\r\n      if (keyPath != null) {\r\n        let settings = this.scopedSettingsStore.propertiesForSourceAndSelector(source, scopeSelector)\r\n        if (getValueAtKeyPath(settings, keyPath) != null) {\r\n          this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n          setValueAtKeyPath(settings, keyPath, undefined)\r\n          settings = withoutEmptyObjects(settings)\r\n          if (settings != null) {\r\n            this.set(null, settings, {scopeSelector, source, priority: this.priorityForSource(source)})\r\n          }\r\n\r\n          const configIsReady = (source === this.mainSource) && this.settingsLoaded\r\n          if (configIsReady) {\r\n            return this.requestSave()\r\n          }\r\n        }\r\n      } else {\r\n        this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n        return this.emitChangeEvent()\r\n      }\r\n    } else {\r\n      for (scopeSelector in this.scopedSettingsStore.propertiesForSource(source)) {\r\n        this.unset(keyPath, {scopeSelector, source})\r\n      }\r\n      if ((keyPath != null) && (source === this.mainSource)) {\r\n        return this.set(keyPath, getValueAtKeyPath(this.defaultSettings, keyPath))\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.emitChangeEvent","start_line":1211,"end_line":1213,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"unset","line":760,"func_location":"Config.unset","func_start_line":730,"func_end_line":766,"args":["keyPath",null],"comment":[" Essential: Restore the setting at `keyPath` to its default value.",""," * `keyPath` The {String} name of the key."," * `options` (optional) {Object}","   * `scopeSelector` (optional) {String}. See {::set}","   * `source` (optional) {String}. See {::set}"],"code":"  unset (keyPath, options) {\r\n    if (!this.settingsLoaded) {\r\n      this.pendingOperations.push(() => this.unset(keyPath, options))\r\n    }\r\n\r\n    let {scopeSelector, source} = options != null ? options : {}\r\n    if (source == null) { source = this.mainSource }\r\n\r\n    if (scopeSelector != null) {\r\n      if (keyPath != null) {\r\n        let settings = this.scopedSettingsStore.propertiesForSourceAndSelector(source, scopeSelector)\r\n        if (getValueAtKeyPath(settings, keyPath) != null) {\r\n          this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n          setValueAtKeyPath(settings, keyPath, undefined)\r\n          settings = withoutEmptyObjects(settings)\r\n          if (settings != null) {\r\n            this.set(null, settings, {scopeSelector, source, priority: this.priorityForSource(source)})\r\n          }\r\n\r\n          const configIsReady = (source === this.mainSource) && this.settingsLoaded\r\n          if (configIsReady) {\r\n            return this.requestSave()\r\n          }\r\n        }\r\n      } else {\r\n        this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n        return this.emitChangeEvent()\r\n      }\r\n    } else {\r\n      for (scopeSelector in this.scopedSettingsStore.propertiesForSource(source)) {\r\n        this.unset(keyPath, {scopeSelector, source})\r\n      }\r\n      if ((keyPath != null) && (source === this.mainSource)) {\r\n        return this.set(keyPath, getValueAtKeyPath(this.defaultSettings, keyPath))\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.unset","start_line":730,"end_line":766,"comment":[" Essential: Restore the setting at `keyPath` to its default value.",""," * `keyPath` The {String} name of the key."," * `options` (optional) {Object}","   * `scopeSelector` (optional) {String}. See {::set}","   * `source` (optional) {String}. See {::set}"],"params":["keyPath","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"set","line":763,"func_location":"Config.unset","func_start_line":730,"func_end_line":766,"args":["keyPath",null],"comment":[" Essential: Restore the setting at `keyPath` to its default value.",""," * `keyPath` The {String} name of the key."," * `options` (optional) {Object}","   * `scopeSelector` (optional) {String}. See {::set}","   * `source` (optional) {String}. See {::set}"],"code":"  unset (keyPath, options) {\r\n    if (!this.settingsLoaded) {\r\n      this.pendingOperations.push(() => this.unset(keyPath, options))\r\n    }\r\n\r\n    let {scopeSelector, source} = options != null ? options : {}\r\n    if (source == null) { source = this.mainSource }\r\n\r\n    if (scopeSelector != null) {\r\n      if (keyPath != null) {\r\n        let settings = this.scopedSettingsStore.propertiesForSourceAndSelector(source, scopeSelector)\r\n        if (getValueAtKeyPath(settings, keyPath) != null) {\r\n          this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n          setValueAtKeyPath(settings, keyPath, undefined)\r\n          settings = withoutEmptyObjects(settings)\r\n          if (settings != null) {\r\n            this.set(null, settings, {scopeSelector, source, priority: this.priorityForSource(source)})\r\n          }\r\n\r\n          const configIsReady = (source === this.mainSource) && this.settingsLoaded\r\n          if (configIsReady) {\r\n            return this.requestSave()\r\n          }\r\n        }\r\n      } else {\r\n        this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n        return this.emitChangeEvent()\r\n      }\r\n    } else {\r\n      for (scopeSelector in this.scopedSettingsStore.propertiesForSource(source)) {\r\n        this.unset(keyPath, {scopeSelector, source})\r\n      }\r\n      if ((keyPath != null) && (source === this.mainSource)) {\r\n        return this.set(keyPath, getValueAtKeyPath(this.defaultSettings, keyPath))\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.set","start_line":687,"end_line":722,"comment":[" Essential: Sets the value for a configuration setting.",""," This value is stored in Atom's internal configuration file.",""," ### Examples",""," You might want to change the themes programmatically:",""," ```coffee"," atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])"," ```",""," You can also set scoped settings. For example, you might want change the"," `editor.tabLength` only for ruby files.",""," ```coffee"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4"," atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",""," # Set ruby to 2"," atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true",""," # Notice it's only set to 2 in the case of ruby"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," atom.config.get('editor.tabLength', scope: ['source.js']) # => 4"," ```",""," * `keyPath` The {String} name of the key."," * `value` The value of the setting. Passing `undefined` will revert the","   setting to the default value."," * `options` (optional) {Object}","   * `scopeSelector` (optional) {String}. eg. '.source.ruby'","     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)","     for more information.","   * `source` (optional) {String} The name of a file with which the setting","     is associated. Defaults to the user's config file.",""," Returns a {Boolean}"," * `true` if the value was set."," * `false` if the value was not able to be coerced to the type specified in the setting's schema."],"params":["args"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"get","line":880,"func_location":"Config.unshiftAtKeyPath","func_start_line":879,"func_end_line":885,"args":["keyPath"],"code":"  unshiftAtKeyPath (keyPath, value) {\r\n    const left = this.get(keyPath)\r\n    const arrayValue = (left == null ? [] : left)\r\n    const result = arrayValue.unshift(value)\r\n    this.set(keyPath, arrayValue)\r\n    return result\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.get","start_line":585,"end_line":602,"comment":["\r\n  Section: Managing Settings\r\n  "," Essential: Retrieves the setting for the given key.",""," ### Examples",""," You might want to know what themes are enabled, so check `core.themes`",""," ```coffee"," atom.config.get('core.themes')"," ```",""," With scope descriptors you can get settings within a specific editor"," scope. For example, you might want to know `editor.tabLength` for ruby"," files.",""," ```coffee"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," ```",""," This setting in ruby files might be different than the global tabLength setting",""," ```coffee"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," ```",""," You can get the language scope descriptor via"," {TextEditor::getRootScopeDescriptor}. This will get the setting specifically"," for the editor's language.",""," ```coffee"," atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2"," ```",""," Additionally, you can get the setting at the specific cursor position.",""," ```coffee"," scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()"," atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2"," ```",""," * `keyPath` The {String} name of the key to retrieve."," * `options` (optional) {Object}","   * `sources` (optional) {Array} of {String} source names. If provided, only","     values that were associated with these sources during {::set} will be used.","   * `excludeSources` (optional) {Array} of {String} source names. If provided,","     values that  were associated with these sources during {::set} will not","     be used.","   * `scope` (optional) {ScopeDescriptor} describing a path from","     the root of the syntax tree to a token. Get one by calling","     {editor.getLastCursor().getScopeDescriptor()}","     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)","     for more information.",""," Returns the value from Atom's default settings, the user's configuration"," file in the type specified by the configuration schema."],"params":["args"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"set","line":883,"func_location":"Config.unshiftAtKeyPath","func_start_line":879,"func_end_line":885,"args":["keyPath","arrayValue"],"code":"  unshiftAtKeyPath (keyPath, value) {\r\n    const left = this.get(keyPath)\r\n    const arrayValue = (left == null ? [] : left)\r\n    const result = arrayValue.unshift(value)\r\n    this.set(keyPath, arrayValue)\r\n    return result\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js","name":"Config.set","start_line":687,"end_line":722,"comment":[" Essential: Sets the value for a configuration setting.",""," This value is stored in Atom's internal configuration file.",""," ### Examples",""," You might want to change the themes programmatically:",""," ```coffee"," atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])"," ```",""," You can also set scoped settings. For example, you might want change the"," `editor.tabLength` only for ruby files.",""," ```coffee"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4"," atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",""," # Set ruby to 2"," atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true",""," # Notice it's only set to 2 in the case of ruby"," atom.config.get('editor.tabLength') # => 4"," atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2"," atom.config.get('editor.tabLength', scope: ['source.js']) # => 4"," ```",""," * `keyPath` The {String} name of the key."," * `value` The value of the setting. Passing `undefined` will revert the","   setting to the default value."," * `options` (optional) {Object}","   * `scopeSelector` (optional) {String}. eg. '.source.ruby'","     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)","     for more information.","   * `source` (optional) {String} The name of a file with which the setting","     is associated. Defaults to the user's config file.",""," Returns a {Boolean}"," * `true` if the value was set."," * `false` if the value was not able to be coerced to the type specified in the setting's schema."],"params":["args"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"decorateCursorLine","line":411,"func_location":"TextEditor.update","func_start_line":320,"func_end_line":539,"args":[],"code":"  update (params) {\r\n    const displayLayerParams = {}\r\n\r\n    for (let param of Object.keys(params)) {\r\n      const value = params[param]\r\n\r\n      switch (param) {\r\n        case 'autoIndent':\r\n          this.autoIndent = value\r\n          break\r\n\r\n        case 'autoIndentOnPaste':\r\n          this.autoIndentOnPaste = value\r\n          break\r\n\r\n        case 'undoGroupingInterval':\r\n          this.undoGroupingInterval = value\r\n          break\r\n\r\n        case 'scrollSensitivity':\r\n          this.scrollSensitivity = value\r\n          break\r\n\r\n        case 'encoding':\r\n          this.buffer.setEncoding(value)\r\n          break\r\n\r\n        case 'softTabs':\r\n          if (value !== this.softTabs) {\r\n            this.softTabs = value\r\n          }\r\n          break\r\n\r\n        case 'atomicSoftTabs':\r\n          if (value !== this.displayLayer.atomicSoftTabs) {\r\n            displayLayerParams.atomicSoftTabs = value\r\n          }\r\n          break\r\n\r\n        case 'tabLength':\r\n          if (value > 0 && value !== this.displayLayer.tabLength) {\r\n            displayLayerParams.tabLength = value\r\n          }\r\n          break\r\n\r\n        case 'softWrapped':\r\n          if (value !== this.softWrapped) {\r\n            this.softWrapped = value\r\n            displayLayerParams.softWrapColumn = this.getSoftWrapColumn()\r\n            this.emitter.emit('did-change-soft-wrapped', this.isSoftWrapped())\r\n          }\r\n          break\r\n\r\n        case 'softWrapHangingIndentLength':\r\n          if (value !== this.displayLayer.softWrapHangingIndent) {\r\n            displayLayerParams.softWrapHangingIndent = value\r\n          }\r\n          break\r\n\r\n        case 'softWrapAtPreferredLineLength':\r\n          if (value !== this.softWrapAtPreferredLineLength) {\r\n            this.softWrapAtPreferredLineLength = value\r\n            displayLayerParams.softWrapColumn = this.getSoftWrapColumn()\r\n          }\r\n          break\r\n\r\n        case 'preferredLineLength':\r\n          if (value !== this.preferredLineLength) {\r\n            this.preferredLineLength = value\r\n            displayLayerParams.softWrapColumn = this.getSoftWrapColumn()\r\n          }\r\n          break\r\n\r\n        case 'maxScreenLineLength':\r\n          if (value !== this.maxScreenLineLength) {\r\n            this.maxScreenLineLength = value\r\n            displayLayerParams.softWrapColumn = this.getSoftWrapColumn()\r\n          }\r\n          break\r\n\r\n        case 'mini':\r\n          if (value !== this.mini) {\r\n            this.mini = value\r\n            this.emitter.emit('did-change-mini', value)\r\n            displayLayerParams.invisibles = this.getInvisibles()\r\n            displayLayerParams.softWrapColumn = this.getSoftWrapColumn()\r\n            displayLayerParams.showIndentGuides = this.doesShowIndentGuide()\r\n            if (this.mini) {\r\n              for (let decoration of this.cursorLineDecorations) { decoration.destroy() }\r\n              this.cursorLineDecorations = null\r\n            } else {\r\n              this.decorateCursorLine()\r\n            }\r\n            if (this.component != null) {\r\n              this.component.scheduleUpdate()\r\n            }\r\n          }\r\n          break\r\n\r\n        case 'readOnly':\r\n          if (value !== this.readOnly) {\r\n            this.readOnly = value\r\n            if (this.component != null) {\r\n              this.component.scheduleUpdate()\r\n            }\r\n          }\r\n          break\r\n\r\n        case 'keyboardInputEnabled':\r\n          if (value !== this.keyboardInputEnabled) {\r\n            this.keyboardInputEnabled = value\r\n            if (this.component != null) {\r\n              this.component.scheduleUpdate()\r\n            }\r\n          }\r\n          break\r\n\r\n        case 'placeholderText':\r\n          if (value !== this.placeholderText) {\r\n            this.placeholderText = value\r\n            this.emitter.emit('did-change-placeholder-text', value)\r\n          }\r\n          break\r\n\r\n        case 'lineNumberGutterVisible':\r\n          if (value !== this.lineNumberGutterVisible) {\r\n            if (value) {\r\n              this.lineNumberGutter.show()\r\n            } else {\r\n              this.lineNumberGutter.hide()\r\n            }\r\n            this.emitter.emit('did-change-line-number-gutter-visible', this.lineNumberGutter.isVisible())\r\n          }\r\n          break\r\n\r\n        case 'showIndentGuide':\r\n          if (value !== this.showIndentGuide) {\r\n            this.showIndentGuide = value\r\n            displayLayerParams.showIndentGuides = this.doesShowIndentGuide()\r\n          }\r\n          break\r\n\r\n        case 'showLineNumbers':\r\n          if (value !== this.showLineNumbers) {\r\n            this.showLineNumbers = value\r\n            if (this.component != null) {\r\n              this.component.scheduleUpdate()\r\n            }\r\n          }\r\n          break\r\n\r\n        case 'showInvisibles':\r\n          if (value !== this.showInvisibles) {\r\n            this.showInvisibles = value\r\n            displayLayerParams.invisibles = this.getInvisibles()\r\n          }\r\n          break\r\n\r\n        case 'invisibles':\r\n          if (!_.isEqual(value, this.invisibles)) {\r\n            this.invisibles = value\r\n            displayLayerParams.invisibles = this.getInvisibles()\r\n          }\r\n          break\r\n\r\n        case 'editorWidthInChars':\r\n          if (value > 0 && value !== this.editorWidthInChars) {\r\n            this.editorWidthInChars = value\r\n            displayLayerParams.softWrapColumn = this.getSoftWrapColumn()\r\n          }\r\n          break\r\n\r\n        case 'width':\r\n          if (value !== this.width) {\r\n            this.width = value\r\n            displayLayerParams.softWrapColumn = this.getSoftWrapColumn()\r\n          }\r\n          break\r\n\r\n        case 'scrollPastEnd':\r\n          if (value !== this.scrollPastEnd) {\r\n            this.scrollPastEnd = value\r\n            if (this.component) this.component.scheduleUpdate()\r\n          }\r\n          break\r\n\r\n        case 'autoHeight':\r\n          if (value !== this.autoHeight) {\r\n            this.autoHeight = value\r\n          }\r\n          break\r\n\r\n        case 'autoWidth':\r\n          if (value !== this.autoWidth) {\r\n            this.autoWidth = value\r\n          }\r\n          break\r\n\r\n        case 'showCursorOnSelection':\r\n          if (value !== this.showCursorOnSelection) {\r\n            this.showCursorOnSelection = value\r\n            if (this.component) this.component.scheduleUpdate()\r\n          }\r\n          break\r\n\r\n        default:\r\n          if (param !== 'ref' && param !== 'key') {\r\n            throw new TypeError(`Invalid TextEditor parameter: '${param}'`)\r\n          }\r\n      }\r\n    }\r\n\r\n    this.displayLayer.reset(displayLayerParams)\r\n\r\n    if (this.component) {\r\n      return this.component.getNextUpdatePromise()\r\n    } else {\r\n      return Promise.resolve()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js","name":"TextEditor.decorateCursorLine","start_line":299,"end_line":305,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"scheduleUpdate","line":190,"func_location":"TextEditorComponent.update","func_start_line":184,"func_end_line":191,"args":[],"code":"  update (props) {\r\n    if (props.model !== this.props.model) {\r\n      this.props.model.component = null\r\n      props.model.component = this\r\n    }\r\n    this.props = props\r\n    this.scheduleUpdate()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.scheduleUpdate","start_line":204,"end_line":219,"comment":[],"params":["nextUpdateOnlyBlinksCursors"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"shouldUpdate","line":3660,"func_location":"LinesTileComponent.update","func_start_line":3659,"func_end_line":3669,"args":["newProps"],"code":"  update (newProps) {\r\n    if (this.shouldUpdate(newProps)) {\r\n      const oldProps = this.props\r\n      this.props = newProps\r\n      etch.updateSync(this)\r\n      if (!newProps.measuredContent) {\r\n        this.updateLines(oldProps, newProps)\r\n        this.updateBlockDecorations(oldProps, newProps)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"LinesTileComponent.shouldUpdate","start_line":3882,"end_line":3925,"comment":[],"params":["newProps"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateLines","line":3665,"func_location":"LinesTileComponent.update","func_start_line":3659,"func_end_line":3669,"args":["oldProps","newProps"],"code":"  update (newProps) {\r\n    if (this.shouldUpdate(newProps)) {\r\n      const oldProps = this.props\r\n      this.props = newProps\r\n      etch.updateSync(this)\r\n      if (!newProps.measuredContent) {\r\n        this.updateLines(oldProps, newProps)\r\n        this.updateBlockDecorations(oldProps, newProps)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"LinesTileComponent.updateLines","start_line":3719,"end_line":3819,"comment":[],"params":["oldProps","newProps"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateBlockDecorations","line":3666,"func_location":"LinesTileComponent.update","func_start_line":3659,"func_end_line":3669,"args":["oldProps","newProps"],"code":"  update (newProps) {\r\n    if (this.shouldUpdate(newProps)) {\r\n      const oldProps = this.props\r\n      this.props = newProps\r\n      etch.updateSync(this)\r\n      if (!newProps.measuredContent) {\r\n        this.updateLines(oldProps, newProps)\r\n        this.updateBlockDecorations(oldProps, newProps)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"LinesTileComponent.updateBlockDecorations","start_line":3845,"end_line":3880,"comment":[],"params":["oldProps","newProps"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"shouldUpdate","line":3200,"func_location":"LineNumberGutterComponent.update","func_start_line":3199,"func_end_line":3204,"args":["newProps"],"code":"  update (newProps) {\r\n    if (this.shouldUpdate(newProps)) {\r\n      this.props = newProps\r\n      etch.updateSync(this)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"LineNumberGutterComponent.shouldUpdate","start_line":3309,"end_line":3365,"comment":[],"params":["newProps"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"buildClassName","line":3949,"func_location":"LineComponent.update","func_start_line":3946,"func_end_line":3962,"args":[],"code":"  update (newProps) {\r\n    if (this.props.lineDecoration !== newProps.lineDecoration) {\r\n      this.props.lineDecoration = newProps.lineDecoration\r\n      this.element.className = this.buildClassName()\r\n    }\r\n\r\n    if (this.props.screenRow !== newProps.screenRow) {\r\n      this.props.screenRow = newProps.screenRow\r\n      this.element.dataset.screenRow = newProps.screenRow\r\n    }\r\n\r\n    if (!textDecorationsEqual(this.props.textDecorations, newProps.textDecorations)) {\r\n      this.props.textDecorations = newProps.textDecorations\r\n      this.element.firstChild.remove()\r\n      this.appendContents()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"LineComponent.buildClassName","start_line":4055,"end_line":4060,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"textDecorationsEqual","line":3957,"func_location":"LineComponent.update","func_start_line":3946,"func_end_line":3962,"args":[".props.textDecorations","newProps.textDecorations"],"code":"  update (newProps) {\r\n    if (this.props.lineDecoration !== newProps.lineDecoration) {\r\n      this.props.lineDecoration = newProps.lineDecoration\r\n      this.element.className = this.buildClassName()\r\n    }\r\n\r\n    if (this.props.screenRow !== newProps.screenRow) {\r\n      this.props.screenRow = newProps.screenRow\r\n      this.element.dataset.screenRow = newProps.screenRow\r\n    }\r\n\r\n    if (!textDecorationsEqual(this.props.textDecorations, newProps.textDecorations)) {\r\n      this.props.textDecorations = newProps.textDecorations\r\n      this.element.firstChild.remove()\r\n      this.appendContents()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"textDecorationsEqual","start_line":4342,"end_line":4354,"comment":[],"params":["oldDecorations","newDecorations"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"appendContents","line":3960,"func_location":"LineComponent.update","func_start_line":3946,"func_end_line":3962,"args":[],"code":"  update (newProps) {\r\n    if (this.props.lineDecoration !== newProps.lineDecoration) {\r\n      this.props.lineDecoration = newProps.lineDecoration\r\n      this.element.className = this.buildClassName()\r\n    }\r\n\r\n    if (this.props.screenRow !== newProps.screenRow) {\r\n      this.props.screenRow = newProps.screenRow\r\n      this.element.dataset.screenRow = newProps.screenRow\r\n    }\r\n\r\n    if (!textDecorationsEqual(this.props.textDecorations, newProps.textDecorations)) {\r\n      this.props.textDecorations = newProps.textDecorations\r\n      this.element.firstChild.remove()\r\n      this.appendContents()\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"LineComponent.appendContents","start_line":3975,"end_line":4039,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"shouldUpdate","line":4084,"func_location":"HighlightsComponent.update","func_start_line":4083,"func_end_line":4118,"args":["newProps"],"code":"  update (newProps) {\r\n    if (this.shouldUpdate(newProps)) {\r\n      this.props = newProps\r\n      const {height, width, lineHeight, highlightDecorations} = this.props\r\n\r\n      this.element.style.height = height + 'px'\r\n      this.element.style.width = width + 'px'\r\n\r\n      const visibleHighlightDecorations = new Set()\r\n      if (highlightDecorations) {\r\n        for (let i = 0; i < highlightDecorations.length; i++) {\r\n          const highlightDecoration = highlightDecorations[i]\r\n          const highlightProps = Object.assign({lineHeight}, highlightDecorations[i])\r\n\r\n          let highlightComponent = this.highlightComponentsByKey.get(highlightDecoration.key)\r\n          if (highlightComponent) {\r\n            highlightComponent.update(highlightProps)\r\n          } else {\r\n            highlightComponent = new HighlightComponent(highlightProps)\r\n            this.element.appendChild(highlightComponent.element)\r\n            this.highlightComponentsByKey.set(highlightDecoration.key, highlightComponent)\r\n          }\r\n\r\n          highlightDecorations[i].flashRequested = false\r\n          visibleHighlightDecorations.add(highlightDecoration.key)\r\n        }\r\n      }\r\n\r\n      this.highlightComponentsByKey.forEach((highlightComponent, key) => {\r\n        if (!visibleHighlightDecorations.has(key)) {\r\n          highlightComponent.destroy()\r\n          this.highlightComponentsByKey.delete(key)\r\n        }\r\n      })\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"HighlightsComponent.shouldUpdate","start_line":4120,"end_line":4145,"comment":[],"params":["newProps"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"constructor","line":4101,"func_location":"HighlightsComponent.update","func_start_line":4083,"func_end_line":4118},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"HighlightComponent.constructor","start_line":4149,"end_line":4153,"comment":[],"params":["props"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"performFlash","line":4169,"func_location":"HighlightComponent.update","func_start_line":4166,"func_end_line":4170,"args":[],"code":"  update (newProps) {\r\n    this.props = newProps\r\n    etch.updateSync(this)\r\n    if (newProps.flashRequested) this.performFlash()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"HighlightComponent.performFlash","start_line":4172,"end_line":4190,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"shouldUpdate","line":3076,"func_location":"GutterContainerComponent.update","func_start_line":3075,"func_end_line":3080,"args":["props"],"code":"  update (props) {\r\n    if (this.shouldUpdate(props)) {\r\n      this.props = props\r\n      etch.updateSync(this)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"GutterContainerComponent.shouldUpdate","start_line":3082,"end_line":3087,"comment":[],"params":["props"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"flushScrollPosition","line":2988,"func_location":"DummyScrollbarComponent.update","func_start_line":2979,"func_end_line":2989,"args":[],"code":"  update (newProps) {\r\n    const oldProps = this.props\r\n    this.props = newProps\r\n    etch.updateSync(this)\r\n\r\n    const shouldFlushScrollPosition = (\r\n      newProps.scrollTop !== oldProps.scrollTop ||\r\n      newProps.scrollLeft !== oldProps.scrollLeft\r\n    )\r\n    if (shouldFlushScrollPosition) this.flushScrollPosition()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"DummyScrollbarComponent.flushScrollPosition","start_line":2991,"end_line":2997,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js","name":"disposeProjectMenu","line":46,"func_location":"ReopenProjectMenuManager.update","func_start_line":45,"func_end_line":51,"args":[],"code":"  update () {\r\n    this.disposeProjectMenu()\r\n    this.projects = this.historyManager.getProjects().slice(0, this.config.get('core.reopenProjectMenuCount'))\r\n    const newMenu = ReopenProjectMenuManager.createProjectsMenu(this.projects)\r\n    this.lastProjectMenu = this.menuManager.add([newMenu])\r\n    this.updateWindowsJumpList()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js","name":"ReopenProjectMenuManager.disposeProjectMenu","start_line":112,"end_line":117,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js","name":"createProjectsMenu","line":48,"func_location":"ReopenProjectMenuManager.update","func_start_line":45,"func_end_line":51,"args":[".projects"],"code":"  update () {\r\n    this.disposeProjectMenu()\r\n    this.projects = this.historyManager.getProjects().slice(0, this.config.get('core.reopenProjectMenuCount'))\r\n    const newMenu = ReopenProjectMenuManager.createProjectsMenu(this.projects)\r\n    this.lastProjectMenu = this.menuManager.add([newMenu])\r\n    this.updateWindowsJumpList()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js","name":"ReopenProjectMenuManager.createProjectsMenu","start_line":119,"end_line":133,"comment":[],"params":["projects"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js","name":"updateWindowsJumpList","line":50,"func_location":"ReopenProjectMenuManager.update","func_start_line":45,"func_end_line":51,"args":[],"code":"  update () {\r\n    this.disposeProjectMenu()\r\n    this.projects = this.historyManager.getProjects().slice(0, this.config.get('core.reopenProjectMenuCount'))\r\n    const newMenu = ReopenProjectMenuManager.createProjectsMenu(this.projects)\r\n    this.lastProjectMenu = this.menuManager.add([newMenu])\r\n    this.updateWindowsJumpList()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js","name":"ReopenProjectMenuManager.updateWindowsJumpList","start_line":75,"end_line":102,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"_performUpdate","line":605,"func_location":"LanguageLayer.update","func_start_line":601,"func_end_line":611,"args":["nodeRangeSet","params"],"code":"  async update (nodeRangeSet) {\r\n    if (!this.currentParsePromise) {\r\n      while (!this.destroyed && (!this.tree || this.tree.rootNode.hasChanges())) {\r\n        const params = {async: false}\r\n        this.currentParsePromise = this._performUpdate(nodeRangeSet, params)\r\n        if (!params.async) break\r\n        await this.currentParsePromise\r\n      }\r\n      this.currentParsePromise = null\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js","name":"LanguageLayer._performUpdate","start_line":623,"end_line":699,"comment":[],"params":["nodeRangeSet","params"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"translateTemplate","line":26,"func_location":"ApplicationMenu.update","func_start_line":25,"func_end_line":30,"args":["template","keystrokesByCommand"],"comment":[" Public: Updates the entire menu with the given keybindings.",""," window - The BrowserWindow this menu template is associated with."," template - The Object which describes the menu to display."," keystrokesByCommand - An Object where the keys are commands and the values","                       are Arrays containing the keystroke."],"code":"  update (window, template, keystrokesByCommand) {\r\n    this.translateTemplate(template, keystrokesByCommand)\r\n    this.substituteVersion(template)\r\n    this.windowTemplates.set(window, template)\r\n    if (window === this.lastFocusedWindow) return this.setActiveTemplate(template)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"ApplicationMenu.translateTemplate","start_line":198,"end_line":211,"comment":[" Combines a menu template with the appropriate keystroke.",""," template - An Object conforming to atom-shell's menu api but lacking","            accelerator and click properties."," keystrokesByCommand - An Object where the keys are commands and the values","                       are Arrays containing the keystroke.",""," Returns a complete menu configuration object for atom-shell's menu API."],"params":["template","keystrokesByCommand"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"substituteVersion","line":27,"func_location":"ApplicationMenu.update","func_start_line":25,"func_end_line":30,"args":["template"],"comment":[" Public: Updates the entire menu with the given keybindings.",""," window - The BrowserWindow this menu template is associated with."," template - The Object which describes the menu to display."," keystrokesByCommand - An Object where the keys are commands and the values","                       are Arrays containing the keystroke."],"code":"  update (window, template, keystrokesByCommand) {\r\n    this.translateTemplate(template, keystrokesByCommand)\r\n    this.substituteVersion(template)\r\n    this.windowTemplates.set(window, template)\r\n    if (window === this.lastFocusedWindow) return this.setActiveTemplate(template)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"ApplicationMenu.substituteVersion","start_line":103,"end_line":106,"comment":[" Replaces VERSION with the current version."],"params":["template"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"setActiveTemplate","line":29,"func_location":"ApplicationMenu.update","func_start_line":25,"func_end_line":30,"args":["template"],"comment":[" Public: Updates the entire menu with the given keybindings.",""," window - The BrowserWindow this menu template is associated with."," template - The Object which describes the menu to display."," keystrokesByCommand - An Object where the keys are commands and the values","                       are Arrays containing the keystroke."],"code":"  update (window, template, keystrokesByCommand) {\r\n    this.translateTemplate(template, keystrokesByCommand)\r\n    this.substituteVersion(template)\r\n    this.windowTemplates.set(window, template)\r\n    if (window === this.lastFocusedWindow) return this.setActiveTemplate(template)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js","name":"ApplicationMenu.setActiveTemplate","start_line":32,"end_line":40,"comment":[],"params":["template"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateHighlightsToRender","line":1322,"func_location":"TextEditorComponent.updateAbsolutePositionedDecorations","func_start_line":1321,"func_end_line":1325,"args":[],"code":"  updateAbsolutePositionedDecorations () {\r\n    this.updateHighlightsToRender()\r\n    this.updateCursorsToRender()\r\n    this.updateOverlaysToRender()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateHighlightsToRender","start_line":1327,"end_line":1338,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateCursorsToRender","line":1323,"func_location":"TextEditorComponent.updateAbsolutePositionedDecorations","func_start_line":1321,"func_end_line":1325,"args":[],"code":"  updateAbsolutePositionedDecorations () {\r\n    this.updateHighlightsToRender()\r\n    this.updateCursorsToRender()\r\n    this.updateOverlaysToRender()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateCursorsToRender","start_line":1340,"end_line":1360,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateOverlaysToRender","line":1324,"func_location":"TextEditorComponent.updateAbsolutePositionedDecorations","func_start_line":1321,"func_end_line":1325,"args":[],"code":"  updateAbsolutePositionedDecorations () {\r\n    this.updateHighlightsToRender()\r\n    this.updateCursorsToRender()\r\n    this.updateOverlaysToRender()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateOverlaysToRender","start_line":1395,"end_line":1403,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js","name":"updateEditorSettingsForLanguageMode","line":220,"func_location":"TextEditorRegistry.updateAndMonitorEditorSettings","func_start_line":218,"func_end_line":222,"args":["editor","oldLanguageMode"],"code":"  async updateAndMonitorEditorSettings (editor, oldLanguageMode) {\r\n    await this.initialPackageActivationPromise\r\n    this.updateEditorSettingsForLanguageMode(editor, oldLanguageMode)\r\n    this.subscribeToSettingsForEditorScope(editor)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js","name":"TextEditorRegistry.updateEditorSettingsForLanguageMode","start_line":224,"end_line":247,"comment":[],"params":["editor","oldLanguageMode"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js","name":"subscribeToSettingsForEditorScope","line":221,"func_location":"TextEditorRegistry.updateAndMonitorEditorSettings","func_start_line":218,"func_end_line":222,"args":["editor"],"code":"  async updateAndMonitorEditorSettings (editor, oldLanguageMode) {\r\n    await this.initialPackageActivationPromise\r\n    this.updateEditorSettingsForLanguageMode(editor, oldLanguageMode)\r\n    this.subscribeToSettingsForEditorScope(editor)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js","name":"TextEditorRegistry.subscribeToSettingsForEditorScope","start_line":249,"end_line":286,"comment":[],"params":["editor"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getCursorsClassName","line":3554,"func_location":"CursorsAndInputComponent.updateCursorBlinkSync","func_start_line":3552,"func_end_line":3557,"args":[],"code":"  updateCursorBlinkSync (cursorsBlinkedOff) {\r\n    this.props.cursorsBlinkedOff = cursorsBlinkedOff\r\n    const className = this.getCursorsClassName()\r\n    this.refs.cursors.className = className\r\n    this.virtualNode.props.className = className\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"CursorsAndInputComponent.getCursorsClassName","start_line":3600,"end_line":3602,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/view-registry.js","name":"requestDocumentUpdate","line":189,"func_location":"ViewRegistry.updateDocument","func_start_line":187,"func_end_line":193,"args":[],"code":"  updateDocument (fn) {\r\n    this.documentWriters.push(fn)\r\n    if (!this.documentReadInProgress) { this.requestDocumentUpdate() }\r\n    return new Disposable(() => {\r\n      this.documentWriters = this.documentWriters.filter(writer => writer !== fn)\r\n    })\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/view-registry.js","name":"ViewRegistry.requestDocumentUpdate","start_line":224,"end_line":228,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getActivePaneItem","line":609,"func_location":"Workspace.updateDocumentEdited","func_start_line":608,"func_end_line":614,"args":[],"comment":[" On macOS, fades the application window's proxy icon when the current file"," has been modified."],"code":"  updateDocumentEdited () {\r\n    const activePaneItem = this.getActivePaneItem()\r\n    const modified = activePaneItem != null && typeof activePaneItem.isModified === 'function'\r\n      ? activePaneItem.isModified() || false\r\n      : false\r\n    this.applicationDelegate.setWindowDocumentEdited(modified)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getActivePaneItem","start_line":1357,"end_line":1359,"comment":[" Essential: Get the active {Pane}'s active item.",""," Returns an pane item {Object}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js","name":"textEditorParamsForScope","line":228,"func_location":"TextEditorRegistry.updateEditorSettingsForLanguageMode","func_start_line":224,"func_end_line":247,"args":["newLanguageMode.rootScopeDescriptor"],"code":"  updateEditorSettingsForLanguageMode (editor, oldLanguageMode) {\r\n    const newLanguageMode = editor.buffer.getLanguageMode()\r\n\r\n    if (oldLanguageMode) {\r\n      const newSettings = this.textEditorParamsForScope(newLanguageMode.rootScopeDescriptor)\r\n      const oldSettings = this.textEditorParamsForScope(oldLanguageMode.rootScopeDescriptor)\r\n\r\n      const updatedSettings = {}\r\n      for (const [, paramName] of EDITOR_PARAMS_BY_SETTING_KEY) {\r\n        // Update the setting only if it has changed between the two language\r\n        // modes.  This prevents user-modified settings in an editor (like\r\n        // 'softWrapped') from being reset when the language mode changes.\r\n        if (!_.isEqual(newSettings[paramName], oldSettings[paramName])) {\r\n          updatedSettings[paramName] = newSettings[paramName]\r\n        }\r\n      }\r\n\r\n      if (_.size(updatedSettings) > 0) {\r\n        editor.update(updatedSettings)\r\n      }\r\n    } else {\r\n      editor.update(this.textEditorParamsForScope(newLanguageMode.rootScopeDescriptor))\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js","name":"TextEditorRegistry.textEditorParamsForScope","start_line":288,"end_line":295,"comment":[],"params":["scopeDescriptor"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js","name":"textEditorParamsForScope","line":229,"func_location":"TextEditorRegistry.updateEditorSettingsForLanguageMode","func_start_line":224,"func_end_line":247,"args":["oldLanguageMode.rootScopeDescriptor"],"code":"  updateEditorSettingsForLanguageMode (editor, oldLanguageMode) {\r\n    const newLanguageMode = editor.buffer.getLanguageMode()\r\n\r\n    if (oldLanguageMode) {\r\n      const newSettings = this.textEditorParamsForScope(newLanguageMode.rootScopeDescriptor)\r\n      const oldSettings = this.textEditorParamsForScope(oldLanguageMode.rootScopeDescriptor)\r\n\r\n      const updatedSettings = {}\r\n      for (const [, paramName] of EDITOR_PARAMS_BY_SETTING_KEY) {\r\n        // Update the setting only if it has changed between the two language\r\n        // modes.  This prevents user-modified settings in an editor (like\r\n        // 'softWrapped') from being reset when the language mode changes.\r\n        if (!_.isEqual(newSettings[paramName], oldSettings[paramName])) {\r\n          updatedSettings[paramName] = newSettings[paramName]\r\n        }\r\n      }\r\n\r\n      if (_.size(updatedSettings) > 0) {\r\n        editor.update(updatedSettings)\r\n      }\r\n    } else {\r\n      editor.update(this.textEditorParamsForScope(newLanguageMode.rootScopeDescriptor))\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js","name":"TextEditorRegistry.textEditorParamsForScope","start_line":288,"end_line":295,"comment":[],"params":["scopeDescriptor"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js","name":"textEditorParamsForScope","line":245,"func_location":"TextEditorRegistry.updateEditorSettingsForLanguageMode","func_start_line":224,"func_end_line":247,"args":[null],"code":"  updateEditorSettingsForLanguageMode (editor, oldLanguageMode) {\r\n    const newLanguageMode = editor.buffer.getLanguageMode()\r\n\r\n    if (oldLanguageMode) {\r\n      const newSettings = this.textEditorParamsForScope(newLanguageMode.rootScopeDescriptor)\r\n      const oldSettings = this.textEditorParamsForScope(oldLanguageMode.rootScopeDescriptor)\r\n\r\n      const updatedSettings = {}\r\n      for (const [, paramName] of EDITOR_PARAMS_BY_SETTING_KEY) {\r\n        // Update the setting only if it has changed between the two language\r\n        // modes.  This prevents user-modified settings in an editor (like\r\n        // 'softWrapped') from being reset when the language mode changes.\r\n        if (!_.isEqual(newSettings[paramName], oldSettings[paramName])) {\r\n          updatedSettings[paramName] = newSettings[paramName]\r\n        }\r\n      }\r\n\r\n      if (_.size(updatedSettings) > 0) {\r\n        editor.update(updatedSettings)\r\n      }\r\n    } else {\r\n      editor.update(this.textEditorParamsForScope(newLanguageMode.rootScopeDescriptor))\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js","name":"TextEditorRegistry.textEditorParamsForScope","start_line":288,"end_line":295,"comment":[],"params":["scopeDescriptor"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"retokenizeLines","line":245,"func_location":"TextMateLanguageMode.updateForInjection","func_start_line":239,"func_end_line":251,"args":[],"code":"  updateForInjection (grammar) {\r\n    if (!grammar.injectionSelector) return\r\n    for (const tokenizedLine of this.tokenizedLines) {\r\n      if (tokenizedLine) {\r\n        for (let token of tokenizedLine.tokens) {\r\n          if (grammar.injectionSelector.matches(token.scopes)) {\r\n            this.retokenizeLines()\r\n            return\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js","name":"TextMateLanguageMode.retokenizeLines","start_line":253,"end_line":263,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelPositionAfterBlocksForRow","line":1332,"func_location":"TextEditorComponent.updateHighlightsToRender","func_start_line":1327,"func_end_line":1338,"args":["start.row"],"code":"  updateHighlightsToRender () {\r\n    this.decorationsToRender.highlights.length = 0\r\n    for (let i = 0; i < this.decorationsToMeasure.highlights.length; i++) {\r\n      const highlight = this.decorationsToMeasure.highlights[i]\r\n      const {start, end} = highlight.screenRange\r\n      highlight.startPixelTop = this.pixelPositionAfterBlocksForRow(start.row)\r\n      highlight.startPixelLeft = this.pixelLeftForRowAndColumn(start.row, start.column)\r\n      highlight.endPixelTop = this.pixelPositionAfterBlocksForRow(end.row) + this.getLineHeight()\r\n      highlight.endPixelLeft = this.pixelLeftForRowAndColumn(end.row, end.column)\r\n      this.decorationsToRender.highlights.push(highlight)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelPositionAfterBlocksForRow","start_line":2364,"end_line":2366,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelLeftForRowAndColumn","line":1333,"func_location":"TextEditorComponent.updateHighlightsToRender","func_start_line":1327,"func_end_line":1338,"args":["start.row","start.column"],"code":"  updateHighlightsToRender () {\r\n    this.decorationsToRender.highlights.length = 0\r\n    for (let i = 0; i < this.decorationsToMeasure.highlights.length; i++) {\r\n      const highlight = this.decorationsToMeasure.highlights[i]\r\n      const {start, end} = highlight.screenRange\r\n      highlight.startPixelTop = this.pixelPositionAfterBlocksForRow(start.row)\r\n      highlight.startPixelLeft = this.pixelLeftForRowAndColumn(start.row, start.column)\r\n      highlight.endPixelTop = this.pixelPositionAfterBlocksForRow(end.row) + this.getLineHeight()\r\n      highlight.endPixelLeft = this.pixelLeftForRowAndColumn(end.row, end.column)\r\n      this.decorationsToRender.highlights.push(highlight)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelLeftForRowAndColumn","start_line":2368,"end_line":2377,"comment":[],"params":["row","column"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelPositionAfterBlocksForRow","line":1334,"func_location":"TextEditorComponent.updateHighlightsToRender","func_start_line":1327,"func_end_line":1338,"args":["end.row"],"code":"  updateHighlightsToRender () {\r\n    this.decorationsToRender.highlights.length = 0\r\n    for (let i = 0; i < this.decorationsToMeasure.highlights.length; i++) {\r\n      const highlight = this.decorationsToMeasure.highlights[i]\r\n      const {start, end} = highlight.screenRange\r\n      highlight.startPixelTop = this.pixelPositionAfterBlocksForRow(start.row)\r\n      highlight.startPixelLeft = this.pixelLeftForRowAndColumn(start.row, start.column)\r\n      highlight.endPixelTop = this.pixelPositionAfterBlocksForRow(end.row) + this.getLineHeight()\r\n      highlight.endPixelLeft = this.pixelLeftForRowAndColumn(end.row, end.column)\r\n      this.decorationsToRender.highlights.push(highlight)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelPositionAfterBlocksForRow","start_line":2364,"end_line":2366,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getLineHeight","line":1334,"func_location":"TextEditorComponent.updateHighlightsToRender","func_start_line":1327,"func_end_line":1338,"args":["end.row"],"code":"  updateHighlightsToRender () {\r\n    this.decorationsToRender.highlights.length = 0\r\n    for (let i = 0; i < this.decorationsToMeasure.highlights.length; i++) {\r\n      const highlight = this.decorationsToMeasure.highlights[i]\r\n      const {start, end} = highlight.screenRange\r\n      highlight.startPixelTop = this.pixelPositionAfterBlocksForRow(start.row)\r\n      highlight.startPixelLeft = this.pixelLeftForRowAndColumn(start.row, start.column)\r\n      highlight.endPixelTop = this.pixelPositionAfterBlocksForRow(end.row) + this.getLineHeight()\r\n      highlight.endPixelLeft = this.pixelLeftForRowAndColumn(end.row, end.column)\r\n      this.decorationsToRender.highlights.push(highlight)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getLineHeight","start_line":2600,"end_line":2602,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelLeftForRowAndColumn","line":1335,"func_location":"TextEditorComponent.updateHighlightsToRender","func_start_line":1327,"func_end_line":1338,"args":["end.row","end.column"],"code":"  updateHighlightsToRender () {\r\n    this.decorationsToRender.highlights.length = 0\r\n    for (let i = 0; i < this.decorationsToMeasure.highlights.length; i++) {\r\n      const highlight = this.decorationsToMeasure.highlights[i]\r\n      const {start, end} = highlight.screenRange\r\n      highlight.startPixelTop = this.pixelPositionAfterBlocksForRow(start.row)\r\n      highlight.startPixelLeft = this.pixelLeftForRowAndColumn(start.row, start.column)\r\n      highlight.endPixelTop = this.pixelPositionAfterBlocksForRow(end.row) + this.getLineHeight()\r\n      highlight.endPixelLeft = this.pixelLeftForRowAndColumn(end.row, end.column)\r\n      this.decorationsToRender.highlights.push(highlight)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelLeftForRowAndColumn","start_line":2368,"end_line":2377,"comment":[],"params":["row","column"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getFirstElementForScreenLine","line":3783,"func_location":"LinesTileComponent.updateLines","func_start_line":3719,"func_end_line":3819,"args":["newScreenLineComponent.element",null],"code":"  updateLines (oldProps, newProps) {\r\n    var {\r\n      screenLines, tileStartRow, lineDecorations, textDecorations,\r\n      nodePool, displayLayer, lineComponentsByScreenLineId\r\n    } = newProps\r\n\r\n    var oldScreenLines = oldProps.screenLines\r\n    var newScreenLines = screenLines\r\n    var oldScreenLinesEndIndex = oldScreenLines.length\r\n    var newScreenLinesEndIndex = newScreenLines.length\r\n    var oldScreenLineIndex = 0\r\n    var newScreenLineIndex = 0\r\n    var lineComponentIndex = 0\r\n\r\n    while (oldScreenLineIndex < oldScreenLinesEndIndex || newScreenLineIndex < newScreenLinesEndIndex) {\r\n      var oldScreenLine = oldScreenLines[oldScreenLineIndex]\r\n      var newScreenLine = newScreenLines[newScreenLineIndex]\r\n\r\n      if (oldScreenLineIndex >= oldScreenLinesEndIndex) {\r\n        var newScreenLineComponent = new LineComponent({\r\n          screenLine: newScreenLine,\r\n          screenRow: tileStartRow + newScreenLineIndex,\r\n          lineDecoration: lineDecorations[newScreenLineIndex],\r\n          textDecorations: textDecorations[newScreenLineIndex],\r\n          displayLayer,\r\n          nodePool,\r\n          lineComponentsByScreenLineId\r\n        })\r\n        this.element.appendChild(newScreenLineComponent.element)\r\n        this.lineComponents.push(newScreenLineComponent)\r\n\r\n        newScreenLineIndex++\r\n        lineComponentIndex++\r\n      } else if (newScreenLineIndex >= newScreenLinesEndIndex) {\r\n        this.lineComponents[lineComponentIndex].destroy()\r\n        this.lineComponents.splice(lineComponentIndex, 1)\r\n\r\n        oldScreenLineIndex++\r\n      } else if (oldScreenLine === newScreenLine) {\r\n        var lineComponent = this.lineComponents[lineComponentIndex]\r\n        lineComponent.update({\r\n          screenRow: tileStartRow + newScreenLineIndex,\r\n          lineDecoration: lineDecorations[newScreenLineIndex],\r\n          textDecorations: textDecorations[newScreenLineIndex]\r\n        })\r\n\r\n        oldScreenLineIndex++\r\n        newScreenLineIndex++\r\n        lineComponentIndex++\r\n      } else {\r\n        var oldScreenLineIndexInNewScreenLines = newScreenLines.indexOf(oldScreenLine)\r\n        var newScreenLineIndexInOldScreenLines = oldScreenLines.indexOf(newScreenLine)\r\n        if (newScreenLineIndex < oldScreenLineIndexInNewScreenLines && oldScreenLineIndexInNewScreenLines < newScreenLinesEndIndex) {\r\n          var newScreenLineComponents = []\r\n          while (newScreenLineIndex < oldScreenLineIndexInNewScreenLines) {\r\n            var newScreenLineComponent = new LineComponent({ // eslint-disable-line no-redeclare\r\n              screenLine: newScreenLines[newScreenLineIndex],\r\n              screenRow: tileStartRow + newScreenLineIndex,\r\n              lineDecoration: lineDecorations[newScreenLineIndex],\r\n              textDecorations: textDecorations[newScreenLineIndex],\r\n              displayLayer,\r\n              nodePool,\r\n              lineComponentsByScreenLineId\r\n            })\r\n            this.element.insertBefore(newScreenLineComponent.element, this.getFirstElementForScreenLine(oldProps, oldScreenLine))\r\n            newScreenLineComponents.push(newScreenLineComponent)\r\n\r\n            newScreenLineIndex++\r\n          }\r\n\r\n          this.lineComponents.splice(lineComponentIndex, 0, ...newScreenLineComponents)\r\n          lineComponentIndex = lineComponentIndex + newScreenLineComponents.length\r\n        } else if (oldScreenLineIndex < newScreenLineIndexInOldScreenLines && newScreenLineIndexInOldScreenLines < oldScreenLinesEndIndex) {\r\n          while (oldScreenLineIndex < newScreenLineIndexInOldScreenLines) {\r\n            this.lineComponents[lineComponentIndex].destroy()\r\n            this.lineComponents.splice(lineComponentIndex, 1)\r\n\r\n            oldScreenLineIndex++\r\n          }\r\n        } else {\r\n          var oldScreenLineComponent = this.lineComponents[lineComponentIndex]\r\n          var newScreenLineComponent = new LineComponent({ // eslint-disable-line no-redeclare\r\n            screenLine: newScreenLines[newScreenLineIndex],\r\n            screenRow: tileStartRow + newScreenLineIndex,\r\n            lineDecoration: lineDecorations[newScreenLineIndex],\r\n            textDecorations: textDecorations[newScreenLineIndex],\r\n            displayLayer,\r\n            nodePool,\r\n            lineComponentsByScreenLineId\r\n          })\r\n          this.element.insertBefore(newScreenLineComponent.element, oldScreenLineComponent.element)\r\n          oldScreenLineComponent.destroy()\r\n          this.lineComponents[lineComponentIndex] = newScreenLineComponent\r\n\r\n          oldScreenLineIndex++\r\n          newScreenLineIndex++\r\n          lineComponentIndex++\r\n        }\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"LinesTileComponent.getFirstElementForScreenLine","start_line":3821,"end_line":3843,"comment":[],"params":["oldProps","screenLine"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getModel","line":94,"func_location":"TextEditorElement.updateModelFromAttributes","func_start_line":89,"func_end_line":96,"args":["props"],"code":"  updateModelFromAttributes () {\r\n    const props = {mini: this.hasAttribute('mini')}\r\n    if (this.hasAttribute('placeholder-text')) props.placeholderText = this.getAttribute('placeholder-text')\r\n    if (this.hasAttribute('gutter-hidden')) props.lineNumberGutterVisible = false\r\n\r\n    this.getModel().update(props)\r\n    if (this.initialText) this.getModel().setText(this.initialText)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getModel","start_line":80,"end_line":82,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"getModel","line":95,"func_location":"TextEditorElement.updateModelFromAttributes","func_start_line":89,"func_end_line":96,"args":[".initialText"],"code":"  updateModelFromAttributes () {\r\n    const props = {mini: this.hasAttribute('mini')}\r\n    if (this.hasAttribute('placeholder-text')) props.placeholderText = this.getAttribute('placeholder-text')\r\n    if (this.hasAttribute('gutter-hidden')) props.lineNumberGutterVisible = false\r\n\r\n    this.getModel().update(props)\r\n    if (this.initialText) this.getModel().setText(this.initialText)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js","name":"TextEditorElement.getModel","start_line":80,"end_line":82,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollContainerClientWidthInBaseCharacters","line":2123,"func_location":"TextEditorComponent.updateModelSoftWrapColumn","func_start_line":2121,"func_end_line":2145,"args":[],"comment":[" This method is called at the beginning of a frame render to relay any"," potential changes in the editor's width into the model before proceeding."],"code":"  updateModelSoftWrapColumn () {\r\n    const {model} = this.props\r\n    const newEditorWidthInChars = this.getScrollContainerClientWidthInBaseCharacters()\r\n    if (newEditorWidthInChars !== model.getEditorWidthInChars()) {\r\n      this.suppressUpdates = true\r\n\r\n      const renderedStartRow = this.getRenderedStartRow()\r\n      this.props.model.setEditorWidthInChars(newEditorWidthInChars)\r\n\r\n      // Relaying a change in to the editor's client width may cause the\r\n      // vertical scrollbar to appear or disappear, which causes the editor's\r\n      // client width to change *again*. Make sure the display layer is fully\r\n      // populated for the visible area before recalculating the editor's\r\n      // width in characters. Then update the display layer *again* just in\r\n      // case a change in scrollbar visibility causes lines to wrap\r\n      // differently. We capture the renderedStartRow before resetting the\r\n      // display layer because once it has been reset, we can't compute the\r\n      // rendered start row accurately. \r\n      this.populateVisibleRowRange(renderedStartRow)\r\n      this.props.model.setEditorWidthInChars(this.getScrollContainerClientWidthInBaseCharacters())\r\n      this.derivedDimensionsCache = {}\r\n\r\n      this.suppressUpdates = false\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollContainerClientWidthInBaseCharacters","start_line":2692,"end_line":2694,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedStartRow","line":2127,"func_location":"TextEditorComponent.updateModelSoftWrapColumn","func_start_line":2121,"func_end_line":2145,"args":[],"comment":[" This method is called at the beginning of a frame render to relay any"," potential changes in the editor's width into the model before proceeding."],"code":"  updateModelSoftWrapColumn () {\r\n    const {model} = this.props\r\n    const newEditorWidthInChars = this.getScrollContainerClientWidthInBaseCharacters()\r\n    if (newEditorWidthInChars !== model.getEditorWidthInChars()) {\r\n      this.suppressUpdates = true\r\n\r\n      const renderedStartRow = this.getRenderedStartRow()\r\n      this.props.model.setEditorWidthInChars(newEditorWidthInChars)\r\n\r\n      // Relaying a change in to the editor's client width may cause the\r\n      // vertical scrollbar to appear or disappear, which causes the editor's\r\n      // client width to change *again*. Make sure the display layer is fully\r\n      // populated for the visible area before recalculating the editor's\r\n      // width in characters. Then update the display layer *again* just in\r\n      // case a change in scrollbar visibility causes lines to wrap\r\n      // differently. We capture the renderedStartRow before resetting the\r\n      // display layer because once it has been reset, we can't compute the\r\n      // rendered start row accurately. \r\n      this.populateVisibleRowRange(renderedStartRow)\r\n      this.props.model.setEditorWidthInChars(this.getScrollContainerClientWidthInBaseCharacters())\r\n      this.derivedDimensionsCache = {}\r\n\r\n      this.suppressUpdates = false\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedStartRow","start_line":2720,"end_line":2726,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"populateVisibleRowRange","line":2139,"func_location":"TextEditorComponent.updateModelSoftWrapColumn","func_start_line":2121,"func_end_line":2145,"args":["renderedStartRow"],"comment":[" This method is called at the beginning of a frame render to relay any"," potential changes in the editor's width into the model before proceeding."],"code":"  updateModelSoftWrapColumn () {\r\n    const {model} = this.props\r\n    const newEditorWidthInChars = this.getScrollContainerClientWidthInBaseCharacters()\r\n    if (newEditorWidthInChars !== model.getEditorWidthInChars()) {\r\n      this.suppressUpdates = true\r\n\r\n      const renderedStartRow = this.getRenderedStartRow()\r\n      this.props.model.setEditorWidthInChars(newEditorWidthInChars)\r\n\r\n      // Relaying a change in to the editor's client width may cause the\r\n      // vertical scrollbar to appear or disappear, which causes the editor's\r\n      // client width to change *again*. Make sure the display layer is fully\r\n      // populated for the visible area before recalculating the editor's\r\n      // width in characters. Then update the display layer *again* just in\r\n      // case a change in scrollbar visibility causes lines to wrap\r\n      // differently. We capture the renderedStartRow before resetting the\r\n      // display layer because once it has been reset, we can't compute the\r\n      // rendered start row accurately. \r\n      this.populateVisibleRowRange(renderedStartRow)\r\n      this.props.model.setEditorWidthInChars(this.getScrollContainerClientWidthInBaseCharacters())\r\n      this.derivedDimensionsCache = {}\r\n\r\n      this.suppressUpdates = false\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.populateVisibleRowRange","start_line":2896,"end_line":2908,"comment":[" Ensure the spatial index is populated with rows that are currently visible"],"params":["renderedStartRow"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollContainerClientWidthInBaseCharacters","line":2140,"func_location":"TextEditorComponent.updateModelSoftWrapColumn","func_start_line":2121,"func_end_line":2145,"args":[null],"comment":[" This method is called at the beginning of a frame render to relay any"," potential changes in the editor's width into the model before proceeding."],"code":"  updateModelSoftWrapColumn () {\r\n    const {model} = this.props\r\n    const newEditorWidthInChars = this.getScrollContainerClientWidthInBaseCharacters()\r\n    if (newEditorWidthInChars !== model.getEditorWidthInChars()) {\r\n      this.suppressUpdates = true\r\n\r\n      const renderedStartRow = this.getRenderedStartRow()\r\n      this.props.model.setEditorWidthInChars(newEditorWidthInChars)\r\n\r\n      // Relaying a change in to the editor's client width may cause the\r\n      // vertical scrollbar to appear or disappear, which causes the editor's\r\n      // client width to change *again*. Make sure the display layer is fully\r\n      // populated for the visible area before recalculating the editor's\r\n      // width in characters. Then update the display layer *again* just in\r\n      // case a change in scrollbar visibility causes lines to wrap\r\n      // differently. We capture the renderedStartRow before resetting the\r\n      // display layer because once it has been reset, we can't compute the\r\n      // rendered start row accurately. \r\n      this.populateVisibleRowRange(renderedStartRow)\r\n      this.props.model.setEditorWidthInChars(this.getScrollContainerClientWidthInBaseCharacters())\r\n      this.derivedDimensionsCache = {}\r\n\r\n      this.suppressUpdates = false\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollContainerClientWidthInBaseCharacters","start_line":2692,"end_line":2694,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateOverlayToRender","line":1401,"func_location":"TextEditorComponent.updateOverlaysToRender","func_start_line":1395,"func_end_line":1403,"args":["decoration"],"code":"  updateOverlaysToRender () {\r\n    const overlayCount = this.decorationsToRender.overlays.length\r\n    if (overlayCount === 0) return null\r\n\r\n    for (let i = 0; i < overlayCount; i++) {\r\n      const decoration = this.decorationsToRender.overlays[i]\r\n      this.updateOverlayToRender(decoration)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateOverlayToRender","start_line":1362,"end_line":1393,"comment":[],"params":["decoration"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getWindowInnerHeight","line":1363,"func_location":"TextEditorComponent.updateOverlayToRender","func_start_line":1362,"func_end_line":1393,"args":[],"code":"  updateOverlayToRender (decoration) {\r\n    const windowInnerHeight = this.getWindowInnerHeight()\r\n    const windowInnerWidth = this.getWindowInnerWidth()\r\n    const contentClientRect = this.refs.content.getBoundingClientRect()\r\n\r\n    const {element, screenPosition, avoidOverflow} = decoration\r\n    const {row, column} = screenPosition\r\n    let wrapperTop = contentClientRect.top + this.pixelPositionAfterBlocksForRow(row) + this.getLineHeight()\r\n    let wrapperLeft = contentClientRect.left + this.pixelLeftForRowAndColumn(row, column)\r\n    const clientRect = element.getBoundingClientRect()\r\n\r\n    if (avoidOverflow !== false) {\r\n      const computedStyle = window.getComputedStyle(element)\r\n      const elementTop = wrapperTop + parseInt(computedStyle.marginTop)\r\n      const elementBottom = elementTop + clientRect.height\r\n      const flippedElementTop = wrapperTop - this.getLineHeight() - clientRect.height - parseInt(computedStyle.marginBottom)\r\n      const elementLeft = wrapperLeft + parseInt(computedStyle.marginLeft)\r\n      const elementRight = elementLeft + clientRect.width\r\n\r\n      if (elementBottom > windowInnerHeight && flippedElementTop >= 0) {\r\n        wrapperTop -= (elementTop - flippedElementTop)\r\n      }\r\n      if (elementLeft < 0) {\r\n        wrapperLeft -= elementLeft\r\n      } else if (elementRight > windowInnerWidth) {\r\n        wrapperLeft -= (elementRight - windowInnerWidth)\r\n      }\r\n    }\r\n\r\n    decoration.pixelTop = Math.round(wrapperTop)\r\n    decoration.pixelLeft = Math.round(wrapperLeft)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getWindowInnerHeight","start_line":2592,"end_line":2594,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getWindowInnerWidth","line":1364,"func_location":"TextEditorComponent.updateOverlayToRender","func_start_line":1362,"func_end_line":1393,"args":[],"code":"  updateOverlayToRender (decoration) {\r\n    const windowInnerHeight = this.getWindowInnerHeight()\r\n    const windowInnerWidth = this.getWindowInnerWidth()\r\n    const contentClientRect = this.refs.content.getBoundingClientRect()\r\n\r\n    const {element, screenPosition, avoidOverflow} = decoration\r\n    const {row, column} = screenPosition\r\n    let wrapperTop = contentClientRect.top + this.pixelPositionAfterBlocksForRow(row) + this.getLineHeight()\r\n    let wrapperLeft = contentClientRect.left + this.pixelLeftForRowAndColumn(row, column)\r\n    const clientRect = element.getBoundingClientRect()\r\n\r\n    if (avoidOverflow !== false) {\r\n      const computedStyle = window.getComputedStyle(element)\r\n      const elementTop = wrapperTop + parseInt(computedStyle.marginTop)\r\n      const elementBottom = elementTop + clientRect.height\r\n      const flippedElementTop = wrapperTop - this.getLineHeight() - clientRect.height - parseInt(computedStyle.marginBottom)\r\n      const elementLeft = wrapperLeft + parseInt(computedStyle.marginLeft)\r\n      const elementRight = elementLeft + clientRect.width\r\n\r\n      if (elementBottom > windowInnerHeight && flippedElementTop >= 0) {\r\n        wrapperTop -= (elementTop - flippedElementTop)\r\n      }\r\n      if (elementLeft < 0) {\r\n        wrapperLeft -= elementLeft\r\n      } else if (elementRight > windowInnerWidth) {\r\n        wrapperLeft -= (elementRight - windowInnerWidth)\r\n      }\r\n    }\r\n\r\n    decoration.pixelTop = Math.round(wrapperTop)\r\n    decoration.pixelLeft = Math.round(wrapperLeft)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getWindowInnerWidth","start_line":2596,"end_line":2598,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelPositionAfterBlocksForRow","line":1369,"func_location":"TextEditorComponent.updateOverlayToRender","func_start_line":1362,"func_end_line":1393,"args":["row"],"code":"  updateOverlayToRender (decoration) {\r\n    const windowInnerHeight = this.getWindowInnerHeight()\r\n    const windowInnerWidth = this.getWindowInnerWidth()\r\n    const contentClientRect = this.refs.content.getBoundingClientRect()\r\n\r\n    const {element, screenPosition, avoidOverflow} = decoration\r\n    const {row, column} = screenPosition\r\n    let wrapperTop = contentClientRect.top + this.pixelPositionAfterBlocksForRow(row) + this.getLineHeight()\r\n    let wrapperLeft = contentClientRect.left + this.pixelLeftForRowAndColumn(row, column)\r\n    const clientRect = element.getBoundingClientRect()\r\n\r\n    if (avoidOverflow !== false) {\r\n      const computedStyle = window.getComputedStyle(element)\r\n      const elementTop = wrapperTop + parseInt(computedStyle.marginTop)\r\n      const elementBottom = elementTop + clientRect.height\r\n      const flippedElementTop = wrapperTop - this.getLineHeight() - clientRect.height - parseInt(computedStyle.marginBottom)\r\n      const elementLeft = wrapperLeft + parseInt(computedStyle.marginLeft)\r\n      const elementRight = elementLeft + clientRect.width\r\n\r\n      if (elementBottom > windowInnerHeight && flippedElementTop >= 0) {\r\n        wrapperTop -= (elementTop - flippedElementTop)\r\n      }\r\n      if (elementLeft < 0) {\r\n        wrapperLeft -= elementLeft\r\n      } else if (elementRight > windowInnerWidth) {\r\n        wrapperLeft -= (elementRight - windowInnerWidth)\r\n      }\r\n    }\r\n\r\n    decoration.pixelTop = Math.round(wrapperTop)\r\n    decoration.pixelLeft = Math.round(wrapperLeft)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelPositionAfterBlocksForRow","start_line":2364,"end_line":2366,"comment":[],"params":["row"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getLineHeight","line":1369,"func_location":"TextEditorComponent.updateOverlayToRender","func_start_line":1362,"func_end_line":1393,"args":["row"],"code":"  updateOverlayToRender (decoration) {\r\n    const windowInnerHeight = this.getWindowInnerHeight()\r\n    const windowInnerWidth = this.getWindowInnerWidth()\r\n    const contentClientRect = this.refs.content.getBoundingClientRect()\r\n\r\n    const {element, screenPosition, avoidOverflow} = decoration\r\n    const {row, column} = screenPosition\r\n    let wrapperTop = contentClientRect.top + this.pixelPositionAfterBlocksForRow(row) + this.getLineHeight()\r\n    let wrapperLeft = contentClientRect.left + this.pixelLeftForRowAndColumn(row, column)\r\n    const clientRect = element.getBoundingClientRect()\r\n\r\n    if (avoidOverflow !== false) {\r\n      const computedStyle = window.getComputedStyle(element)\r\n      const elementTop = wrapperTop + parseInt(computedStyle.marginTop)\r\n      const elementBottom = elementTop + clientRect.height\r\n      const flippedElementTop = wrapperTop - this.getLineHeight() - clientRect.height - parseInt(computedStyle.marginBottom)\r\n      const elementLeft = wrapperLeft + parseInt(computedStyle.marginLeft)\r\n      const elementRight = elementLeft + clientRect.width\r\n\r\n      if (elementBottom > windowInnerHeight && flippedElementTop >= 0) {\r\n        wrapperTop -= (elementTop - flippedElementTop)\r\n      }\r\n      if (elementLeft < 0) {\r\n        wrapperLeft -= elementLeft\r\n      } else if (elementRight > windowInnerWidth) {\r\n        wrapperLeft -= (elementRight - windowInnerWidth)\r\n      }\r\n    }\r\n\r\n    decoration.pixelTop = Math.round(wrapperTop)\r\n    decoration.pixelLeft = Math.round(wrapperLeft)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getLineHeight","start_line":2600,"end_line":2602,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"pixelLeftForRowAndColumn","line":1370,"func_location":"TextEditorComponent.updateOverlayToRender","func_start_line":1362,"func_end_line":1393,"args":["row","column"],"code":"  updateOverlayToRender (decoration) {\r\n    const windowInnerHeight = this.getWindowInnerHeight()\r\n    const windowInnerWidth = this.getWindowInnerWidth()\r\n    const contentClientRect = this.refs.content.getBoundingClientRect()\r\n\r\n    const {element, screenPosition, avoidOverflow} = decoration\r\n    const {row, column} = screenPosition\r\n    let wrapperTop = contentClientRect.top + this.pixelPositionAfterBlocksForRow(row) + this.getLineHeight()\r\n    let wrapperLeft = contentClientRect.left + this.pixelLeftForRowAndColumn(row, column)\r\n    const clientRect = element.getBoundingClientRect()\r\n\r\n    if (avoidOverflow !== false) {\r\n      const computedStyle = window.getComputedStyle(element)\r\n      const elementTop = wrapperTop + parseInt(computedStyle.marginTop)\r\n      const elementBottom = elementTop + clientRect.height\r\n      const flippedElementTop = wrapperTop - this.getLineHeight() - clientRect.height - parseInt(computedStyle.marginBottom)\r\n      const elementLeft = wrapperLeft + parseInt(computedStyle.marginLeft)\r\n      const elementRight = elementLeft + clientRect.width\r\n\r\n      if (elementBottom > windowInnerHeight && flippedElementTop >= 0) {\r\n        wrapperTop -= (elementTop - flippedElementTop)\r\n      }\r\n      if (elementLeft < 0) {\r\n        wrapperLeft -= elementLeft\r\n      } else if (elementRight > windowInnerWidth) {\r\n        wrapperLeft -= (elementRight - windowInnerWidth)\r\n      }\r\n    }\r\n\r\n    decoration.pixelTop = Math.round(wrapperTop)\r\n    decoration.pixelLeft = Math.round(wrapperLeft)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.pixelLeftForRowAndColumn","start_line":2368,"end_line":2377,"comment":[],"params":["row","column"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getLineHeight","line":1377,"func_location":"TextEditorComponent.updateOverlayToRender","func_start_line":1362,"func_end_line":1393,"args":[],"code":"  updateOverlayToRender (decoration) {\r\n    const windowInnerHeight = this.getWindowInnerHeight()\r\n    const windowInnerWidth = this.getWindowInnerWidth()\r\n    const contentClientRect = this.refs.content.getBoundingClientRect()\r\n\r\n    const {element, screenPosition, avoidOverflow} = decoration\r\n    const {row, column} = screenPosition\r\n    let wrapperTop = contentClientRect.top + this.pixelPositionAfterBlocksForRow(row) + this.getLineHeight()\r\n    let wrapperLeft = contentClientRect.left + this.pixelLeftForRowAndColumn(row, column)\r\n    const clientRect = element.getBoundingClientRect()\r\n\r\n    if (avoidOverflow !== false) {\r\n      const computedStyle = window.getComputedStyle(element)\r\n      const elementTop = wrapperTop + parseInt(computedStyle.marginTop)\r\n      const elementBottom = elementTop + clientRect.height\r\n      const flippedElementTop = wrapperTop - this.getLineHeight() - clientRect.height - parseInt(computedStyle.marginBottom)\r\n      const elementLeft = wrapperLeft + parseInt(computedStyle.marginLeft)\r\n      const elementRight = elementLeft + clientRect.width\r\n\r\n      if (elementBottom > windowInnerHeight && flippedElementTop >= 0) {\r\n        wrapperTop -= (elementTop - flippedElementTop)\r\n      }\r\n      if (elementLeft < 0) {\r\n        wrapperLeft -= elementLeft\r\n      } else if (elementRight > windowInnerWidth) {\r\n        wrapperLeft -= (elementRight - windowInnerWidth)\r\n      }\r\n    }\r\n\r\n    decoration.pixelTop = Math.round(wrapperTop)\r\n    decoration.pixelLeft = Math.round(wrapperLeft)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getLineHeight","start_line":2600,"end_line":2602,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/update-process-env.js","name":"shouldGetEnvFromShell","line":19,"func_location":"updateProcessEnv","func_start_line":16,"func_end_line":43,"args":["launchEnv"],"code":"async function updateProcessEnv (launchEnv) {\r\n  let envToAssign\r\n  if (launchEnv) {\r\n    if (shouldGetEnvFromShell(launchEnv)) {\r\n      envToAssign = await getEnvFromShell(launchEnv)\r\n    } else if (launchEnv.PWD || launchEnv.PROMPT || launchEnv.PSModulePath) {\r\n      envToAssign = launchEnv\r\n    }\r\n  }\r\n\r\n  if (envToAssign) {\r\n    for (let key in process.env) {\r\n      if (!ENVIRONMENT_VARIABLES_TO_PRESERVE.has(key)) {\r\n        delete process.env[key]\r\n      }\r\n    }\r\n\r\n    for (let key in envToAssign) {\r\n      if (!ENVIRONMENT_VARIABLES_TO_PRESERVE.has(key) || (!process.env[key] && envToAssign[key])) {\r\n        process.env[key] = envToAssign[key]\r\n      }\r\n    }\r\n\r\n    if (envToAssign.ATOM_HOME && fs.existsSync(envToAssign.ATOM_HOME)) {\r\n      process.env.ATOM_HOME = envToAssign.ATOM_HOME\r\n    }\r\n  }\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/update-process-env.js","name":"shouldGetEnvFromShell","start_line":45,"end_line":59,"comment":[],"params":["env"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/update-process-env.js","name":"getEnvFromShell","line":20,"func_location":"updateProcessEnv","func_start_line":16,"func_end_line":43,"args":["launchEnv"],"code":"async function updateProcessEnv (launchEnv) {\r\n  let envToAssign\r\n  if (launchEnv) {\r\n    if (shouldGetEnvFromShell(launchEnv)) {\r\n      envToAssign = await getEnvFromShell(launchEnv)\r\n    } else if (launchEnv.PWD || launchEnv.PROMPT || launchEnv.PSModulePath) {\r\n      envToAssign = launchEnv\r\n    }\r\n  }\r\n\r\n  if (envToAssign) {\r\n    for (let key in process.env) {\r\n      if (!ENVIRONMENT_VARIABLES_TO_PRESERVE.has(key)) {\r\n        delete process.env[key]\r\n      }\r\n    }\r\n\r\n    for (let key in envToAssign) {\r\n      if (!ENVIRONMENT_VARIABLES_TO_PRESERVE.has(key) || (!process.env[key] && envToAssign[key])) {\r\n        process.env[key] = envToAssign[key]\r\n      }\r\n    }\r\n\r\n    if (envToAssign.ATOM_HOME && fs.existsSync(envToAssign.ATOM_HOME)) {\r\n      process.env.ATOM_HOME = envToAssign.ATOM_HOME\r\n    }\r\n  }\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/update-process-env.js","name":"getEnvFromShell","start_line":61,"end_line":119,"comment":[],"params":["env"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"getLoadSettings","line":971,"func_location":"AtomEnvironment.updateProcessEnvAndTriggerHooks","func_start_line":970,"func_end_line":975,"args":[".env"],"code":"  async updateProcessEnvAndTriggerHooks () {\r\n    await this.updateProcessEnv(this.getLoadSettings().env)\r\n    this.shellEnvironmentLoaded = true\r\n    this.emitter.emit('loaded-shell-environment')\r\n    this.packages.triggerActivationHook('core:loaded-shell-environment')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js","name":"AtomEnvironment.getLoadSettings","start_line":525,"end_line":527,"comment":[" Public: Get the load settings for the current window.",""," Returns an {Object} containing all the load setting key/value pairs."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"isVisible","line":230,"func_location":"TextEditorComponent.updateSync","func_start_line":221,"func_end_line":289,"args":[],"code":"  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.isVisible","start_line":2588,"end_line":2590,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getLineHeight","line":246,"func_location":"TextEditorComponent.updateSync","func_start_line":221,"func_end_line":289,"args":[],"code":"  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getLineHeight","start_line":2600,"end_line":2602,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getBaseCharacterWidth","line":247,"func_location":"TextEditorComponent.updateSync","func_start_line":221,"func_end_line":289,"args":[],"code":"  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getBaseCharacterWidth","start_line":2604,"end_line":2606,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollTopRow","line":248,"func_location":"TextEditorComponent.updateSync","func_start_line":221,"func_end_line":289,"args":[],"code":"  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollTopRow","start_line":2866,"end_line":2872,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getScrollLeftColumn","line":249,"func_location":"TextEditorComponent.updateSync","func_start_line":221,"func_end_line":289,"args":[],"code":"  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getScrollLeftColumn","start_line":2887,"end_line":2893,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"measureCharacterDimensions","line":251,"func_location":"TextEditorComponent.updateSync","func_start_line":221,"func_end_line":289,"args":[],"code":"  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.measureCharacterDimensions","start_line":2158,"end_line":2173,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"measureGutterDimensions","line":252,"func_location":"TextEditorComponent.updateSync","func_start_line":221,"func_end_line":289,"args":[],"code":"  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.measureGutterDimensions","start_line":2175,"end_line":2199,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"queryLongestLine","line":253,"func_location":"TextEditorComponent.updateSync","func_start_line":221,"func_end_line":289,"args":[],"code":"  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.queryLongestLine","start_line":868,"end_line":878,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getLineHeight","line":255,"func_location":"TextEditorComponent.updateSync","func_start_line":221,"func_end_line":289,"args":[],"code":"  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getLineHeight","start_line":2600,"end_line":2602,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"setScrollTopRow","line":256,"func_location":"TextEditorComponent.updateSync","func_start_line":221,"func_end_line":289,"args":["scrollTopRow"],"code":"  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.setScrollTopRow","start_line":2853,"end_line":2864,"comment":[],"params":["scrollTopRow","scheduleUpdate"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getBaseCharacterWidth","line":258,"func_location":"TextEditorComponent.updateSync","func_start_line":221,"func_end_line":289,"args":[],"code":"  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getBaseCharacterWidth","start_line":2604,"end_line":2606,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"setScrollLeftColumn","line":259,"func_location":"TextEditorComponent.updateSync","func_start_line":221,"func_end_line":289,"args":["scrollLeftColumn"],"code":"  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.setScrollLeftColumn","start_line":2874,"end_line":2885,"comment":[],"params":["scrollLeftColumn","scheduleUpdate"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"measureBlockDecorations","line":264,"func_location":"TextEditorComponent.updateSync","func_start_line":221,"func_end_line":289,"args":[],"code":"  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.measureBlockDecorations","start_line":291,"end_line":362,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateSyncBeforeMeasuringContent","line":266,"func_location":"TextEditorComponent.updateSync","func_start_line":221,"func_end_line":289,"args":[],"code":"  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateSyncBeforeMeasuringContent","start_line":364,"end_line":387,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"measureContentDuringUpdateSync","line":280,"func_location":"TextEditorComponent.updateSync","func_start_line":221,"func_end_line":289,"args":[],"code":"  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.measureContentDuringUpdateSync","start_line":389,"end_line":424,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateSync","line":282,"func_location":"TextEditorComponent.updateSync","func_start_line":221,"func_end_line":289,"args":[{"type":"boolean"}],"code":"  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateSync","start_line":221,"end_line":289,"comment":[],"params":["useScheduler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateSyncAfterMeasuringContent","line":284,"func_location":"TextEditorComponent.updateSync","func_start_line":221,"func_end_line":289,"args":[],"code":"  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateSyncAfterMeasuringContent","start_line":426,"end_line":449,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"measureScrollbarDimensions","line":442,"func_location":"TextEditorComponent.updateSyncAfterMeasuringContent","func_start_line":426,"func_end_line":449,"args":[],"code":"  updateSyncAfterMeasuringContent () {\r\n    this.derivedDimensionsCache = {}\r\n    etch.updateSync(this)\r\n\r\n    this.currentFrameLineNumberGutterProps = null\r\n    this.scrollTopPending = false\r\n    this.scrollLeftPending = false\r\n    if (this.remeasureScrollbars) {\r\n      // Flush stored scroll positions to the vertical and the horizontal\r\n      // scrollbars. This is because they have just been destroyed and recreated\r\n      // as a result of their remeasurement, but we could not assign the scroll\r\n      // top while they were initialized because they were not attached to the\r\n      // DOM yet.\r\n      this.refs.verticalScrollbar.flushScrollPosition()\r\n      this.refs.horizontalScrollbar.flushScrollPosition()\r\n\r\n      this.measureScrollbarDimensions()\r\n      this.remeasureScrollbars = false\r\n      etch.updateSync(this)\r\n    }\r\n\r\n    this.derivedDimensionsCache = {}\r\n    if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.measureScrollbarDimensions","start_line":2221,"end_line":2229,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateModelSoftWrapColumn","line":367,"func_location":"TextEditorComponent.updateSyncBeforeMeasuringContent","func_start_line":364,"func_end_line":387,"args":[],"code":"  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateModelSoftWrapColumn","start_line":2121,"end_line":2145,"comment":[" This method is called at the beginning of a frame render to relay any"," potential changes in the editor's width into the model before proceeding."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"autoscrollVertically","line":370,"func_location":"TextEditorComponent.updateSyncBeforeMeasuringContent","func_start_line":364,"func_end_line":387,"args":["screenRange","options"],"code":"  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.autoscrollVertically","start_line":2035,"end_line":2069,"comment":[],"params":["screenRange","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"requestHorizontalMeasurement","line":371,"func_location":"TextEditorComponent.updateSyncBeforeMeasuringContent","func_start_line":364,"func_end_line":387,"args":["screenRange.start.row","screenRange.start.column"],"code":"  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.requestHorizontalMeasurement","start_line":2243,"end_line":2257,"comment":[],"params":["row","column"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"requestHorizontalMeasurement","line":372,"func_location":"TextEditorComponent.updateSyncBeforeMeasuringContent","func_start_line":364,"func_end_line":387,"args":["screenRange.end.row","screenRange.end.column"],"code":"  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.requestHorizontalMeasurement","start_line":2243,"end_line":2257,"comment":[],"params":["row","column"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"populateVisibleRowRange","line":374,"func_location":"TextEditorComponent.updateSyncBeforeMeasuringContent","func_start_line":364,"func_end_line":387,"args":[null],"code":"  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.populateVisibleRowRange","start_line":2896,"end_line":2908,"comment":[" Ensure the spatial index is populated with rows that are currently visible"],"params":["renderedStartRow"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"getRenderedStartRow","line":374,"func_location":"TextEditorComponent.updateSyncBeforeMeasuringContent","func_start_line":364,"func_end_line":387,"args":[null],"code":"  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.getRenderedStartRow","start_line":2720,"end_line":2726,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"populateVisibleTiles","line":375,"func_location":"TextEditorComponent.updateSyncBeforeMeasuringContent","func_start_line":364,"func_end_line":387,"args":[],"code":"  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.populateVisibleTiles","start_line":2910,"end_line":2937,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"queryScreenLinesToRender","line":376,"func_location":"TextEditorComponent.updateSyncBeforeMeasuringContent","func_start_line":364,"func_end_line":387,"args":[],"code":"  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.queryScreenLinesToRender","start_line":859,"end_line":866,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"queryLongestLine","line":377,"func_location":"TextEditorComponent.updateSyncBeforeMeasuringContent","func_start_line":364,"func_end_line":387,"args":[],"code":"  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.queryLongestLine","start_line":868,"end_line":878,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"queryLineNumbersToRender","line":378,"func_location":"TextEditorComponent.updateSyncBeforeMeasuringContent","func_start_line":364,"func_end_line":387,"args":[],"code":"  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.queryLineNumbersToRender","start_line":889,"end_line":943,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"queryGuttersToRender","line":379,"func_location":"TextEditorComponent.updateSyncBeforeMeasuringContent","func_start_line":364,"func_end_line":387,"args":[],"code":"  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.queryGuttersToRender","start_line":963,"end_line":979,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"queryDecorationsToRender","line":380,"func_location":"TextEditorComponent.updateSyncBeforeMeasuringContent","func_start_line":364,"func_end_line":387,"args":[],"code":"  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.queryDecorationsToRender","start_line":981,"end_line":1009,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"queryExtraScreenLinesToRender","line":381,"func_location":"TextEditorComponent.updateSyncBeforeMeasuringContent","func_start_line":364,"func_end_line":387,"args":[],"code":"  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.queryExtraScreenLinesToRender","start_line":880,"end_line":887,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"updateClassList","line":384,"func_location":"TextEditorComponent.updateSyncBeforeMeasuringContent","func_start_line":364,"func_end_line":387,"args":[],"code":"  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js","name":"TextEditorComponent.updateClassList","start_line":829,"end_line":857,"comment":[" Imperatively manipulate the class list of the root element to avoid"," clearing classes assigned by package authors."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"getActivePaneItem","line":566,"func_location":"Workspace.updateWindowTitle","func_start_line":561,"func_end_line":604,"args":[],"comment":[" Updates the application's title and proxy icon based on whichever file is"," open."],"code":"  updateWindowTitle () {\r\n    let itemPath, itemTitle, projectPath, representedPath\r\n    const appName = 'Atom'\r\n    const left = this.project.getPaths()\r\n    const projectPaths = left != null ? left : []\r\n    const item = this.getActivePaneItem()\r\n    if (item) {\r\n      itemPath = typeof item.getPath === 'function' ? item.getPath() : undefined\r\n      const longTitle = typeof item.getLongTitle === 'function' ? item.getLongTitle() : undefined\r\n      itemTitle = longTitle == null\r\n        ? (typeof item.getTitle === 'function' ? item.getTitle() : undefined)\r\n        : longTitle\r\n      projectPath = _.find(\r\n        projectPaths,\r\n        projectPath =>\r\n          (itemPath === projectPath) || (itemPath != null ? itemPath.startsWith(projectPath + path.sep) : undefined)\r\n      )\r\n    }\r\n    if (itemTitle == null) { itemTitle = 'untitled' }\r\n    if (projectPath == null) { projectPath = itemPath ? path.dirname(itemPath) : projectPaths[0] }\r\n    if (projectPath != null) {\r\n      projectPath = fs.tildify(projectPath)\r\n    }\r\n\r\n    const titleParts = []\r\n    if ((item != null) && (projectPath != null)) {\r\n      titleParts.push(itemTitle, projectPath)\r\n      representedPath = itemPath != null ? itemPath : projectPath\r\n    } else if (projectPath != null) {\r\n      titleParts.push(projectPath)\r\n      representedPath = projectPath\r\n    } else {\r\n      titleParts.push(itemTitle)\r\n      representedPath = ''\r\n    }\r\n\r\n    if (process.platform !== 'darwin') {\r\n      titleParts.push(appName)\r\n    }\r\n\r\n    document.title = titleParts.join(' \\u2014 ')\r\n    this.applicationDelegate.setRepresentedFilename(representedPath)\r\n    this.emitter.emit('did-change-window-title')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js","name":"Workspace.getActivePaneItem","start_line":1357,"end_line":1359,"comment":[" Essential: Get the active {Pane}'s active item.",""," Returns an pane item {Object}."],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js","name":"transformDeprecatedShadowDOMSelectors","line":200,"func_location":"StyleManager.upgradeDeprecatedSelectorsForStyleSheet","func_start_line":189,"func_end_line":207,"args":["styleSheet","context"],"code":"  upgradeDeprecatedSelectorsForStyleSheet (styleSheet, context) {\r\n    if (this.cacheDirPath != null) {\r\n      const hash = crypto.createHash('sha1')\r\n      if (context != null) {\r\n        hash.update(context)\r\n      }\r\n      hash.update(styleSheet)\r\n      const cacheFilePath = path.join(this.cacheDirPath, hash.digest('hex'))\r\n      try {\r\n        return JSON.parse(fs.readFileSync(cacheFilePath))\r\n      } catch (e) {\r\n        const transformed = transformDeprecatedShadowDOMSelectors(styleSheet, context)\r\n        fs.writeFileSync(cacheFilePath, JSON.stringify(transformed))\r\n        return transformed\r\n      }\r\n    } else {\r\n      return transformDeprecatedShadowDOMSelectors(styleSheet, context)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js","name":"transformDeprecatedShadowDOMSelectors","start_line":263,"end_line":331,"comment":[],"params":["css","context"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js","name":"transformDeprecatedShadowDOMSelectors","line":205,"func_location":"StyleManager.upgradeDeprecatedSelectorsForStyleSheet","func_start_line":189,"func_end_line":207,"args":["styleSheet","context"],"code":"  upgradeDeprecatedSelectorsForStyleSheet (styleSheet, context) {\r\n    if (this.cacheDirPath != null) {\r\n      const hash = crypto.createHash('sha1')\r\n      if (context != null) {\r\n        hash.update(context)\r\n      }\r\n      hash.update(styleSheet)\r\n      const cacheFilePath = path.join(this.cacheDirPath, hash.digest('hex'))\r\n      try {\r\n        return JSON.parse(fs.readFileSync(cacheFilePath))\r\n      } catch (e) {\r\n        const transformed = transformDeprecatedShadowDOMSelectors(styleSheet, context)\r\n        fs.writeFileSync(cacheFilePath, JSON.stringify(transformed))\r\n        return transformed\r\n      }\r\n    } else {\r\n      return transformDeprecatedShadowDOMSelectors(styleSheet, context)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js","name":"transformDeprecatedShadowDOMSelectors","start_line":263,"end_line":331,"comment":[],"params":["css","context"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/compile-cache.js","name":"compileFileAtPath","line":234,"func_location":"value","func_start_line":233,"func_end_line":236,"args":["compiler","filePath","extension"],"code":"      value: function (module, filePath) {\r\n        var code = compileFileAtPath(compiler, filePath, extension)\r\n        return module._compile(code, filePath)\r\n      }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/compile-cache.js","name":"compileFileAtPath","start_line":84,"end_line":99,"comment":[],"params":["compiler","filePath","extension"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config-file.js","name":"reload","line":74,"func_location":"ConfigFile.watch","func_start_line":68,"func_end_line":92,"args":[],"code":"  async watch (callback) {\r\n    if (!fs.existsSync(this.path)) {\r\n      fs.makeTreeSync(Path.dirname(this.path))\r\n      CSON.writeFileSync(this.path, {}, {flag: 'wx'})\r\n    }\r\n\r\n    await this.reload()\r\n\r\n    try {\r\n      const watcher = await watchPath(this.path, {}, events => {\r\n        if (events.some(event => EVENT_TYPES.has(event.action))) this.requestLoad()\r\n      })\r\n      return watcher\r\n    } catch (error) {\r\n      this.emitter.emit('did-error', dedent `\r\n        Unable to watch path: \\`${Path.basename(this.path)}\\`.\r\n\r\n        Make sure you have permissions to \\`${this.path}\\`.\r\n        On linux there are currently problems with watch sizes.\r\n        See [this document][watches] for more info.\r\n\r\n        [watches]:https://github.com/atom/atom/blob/master/docs/build-instructions/linux.md#typeerror-unable-to-watch-path\\\r\n      `)\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/config-file.js","name":"ConfigFile.reload","start_line":102,"end_line":117,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js","name":"tryStatFile","line":17,"func_location":"FileRecoveryService.willSavePath","func_start_line":16,"func_end_line":41,"args":["path"],"code":"  async willSavePath (window, path) {\r\n    const stats = await tryStatFile(path)\r\n    if (!stats) return\r\n\r\n    const recoveryPath = Path.join(this.recoveryDirectory, RecoveryFile.fileNameForPath(path))\r\n    const recoveryFile =\r\n      this.recoveryFilesByFilePath.get(path) || new RecoveryFile(path, stats.mode, recoveryPath)\r\n\r\n    try {\r\n      await recoveryFile.retain()\r\n    } catch (err) {\r\n      console.log(`Couldn't retain ${recoveryFile.recoveryPath}. Code: ${err.code}. Message: ${err.message}`)\r\n      return\r\n    }\r\n\r\n    if (!this.recoveryFilesByWindow.has(window)) {\r\n      this.recoveryFilesByWindow.set(window, new Set())\r\n    }\r\n    if (!this.windowsByRecoveryFile.has(recoveryFile)) {\r\n      this.windowsByRecoveryFile.set(recoveryFile, new Set())\r\n    }\r\n\r\n    this.recoveryFilesByWindow.get(window).add(recoveryFile)\r\n    this.windowsByRecoveryFile.get(recoveryFile).add(window)\r\n    this.recoveryFilesByFilePath.set(path, recoveryFile)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js","name":"tryStatFile","start_line":141,"end_line":147,"comment":[],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js","name":"fileNameForPath","line":20,"func_location":"FileRecoveryService.willSavePath","func_start_line":16,"func_end_line":41,"args":[".recoveryDirectory",null],"code":"  async willSavePath (window, path) {\r\n    const stats = await tryStatFile(path)\r\n    if (!stats) return\r\n\r\n    const recoveryPath = Path.join(this.recoveryDirectory, RecoveryFile.fileNameForPath(path))\r\n    const recoveryFile =\r\n      this.recoveryFilesByFilePath.get(path) || new RecoveryFile(path, stats.mode, recoveryPath)\r\n\r\n    try {\r\n      await recoveryFile.retain()\r\n    } catch (err) {\r\n      console.log(`Couldn't retain ${recoveryFile.recoveryPath}. Code: ${err.code}. Message: ${err.message}`)\r\n      return\r\n    }\r\n\r\n    if (!this.recoveryFilesByWindow.has(window)) {\r\n      this.recoveryFilesByWindow.set(window, new Set())\r\n    }\r\n    if (!this.windowsByRecoveryFile.has(recoveryFile)) {\r\n      this.windowsByRecoveryFile.set(recoveryFile, new Set())\r\n    }\r\n\r\n    this.recoveryFilesByWindow.get(window).add(recoveryFile)\r\n    this.windowsByRecoveryFile.get(recoveryFile).add(window)\r\n    this.recoveryFilesByFilePath.set(path, recoveryFile)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js","name":"RecoveryFile.fileNameForPath","start_line":95,"end_line":100,"comment":[],"params":["path"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"killProcess","line":950,"func_location":"AtomApplication.windowDidClosePathWithWaitSession","func_start_line":943,"func_end_line":954,"args":["session.pid"],"code":"  windowDidClosePathWithWaitSession (window, initialPath) {\r\n    const waitSessions = this.waitSessionsByWindow.get(window)\r\n    if (!waitSessions) return\r\n    for (let i = waitSessions.length - 1; i >= 0; i--) {\r\n      const session = waitSessions[i]\r\n      session.remainingPaths.delete(initialPath)\r\n      if (session.remainingPaths.size === 0) {\r\n        this.killProcess(session.pid)\r\n        waitSessions.splice(i, 1)\r\n      }\r\n    }\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.killProcess","start_line":957,"end_line":966,"comment":[" Kill the process with the given pid."],"params":["pid"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"getAllWindows","line":733,"func_location":"AtomApplication.windowForPaths","func_start_line":732,"func_end_line":736,"args":[],"comment":[" Returns the {AtomWindow} for the given paths."],"code":"  windowForPaths (pathsToOpen, devMode) {\r\n    return this.getAllWindows().find(window =>\r\n      window.devMode === devMode && window.containsPaths(pathsToOpen)\r\n    )\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js","name":"AtomApplication.getAllWindows","start_line":321,"end_line":323,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"getNonWordCharacters","line":675,"func_location":"Cursor.wordRegExp","func_start_line":674,"func_end_line":681,"args":[null],"comment":[" Public: Get the RegExp used by the cursor to determine what a \"word\" is.",""," * `options` (optional) {Object} with the following keys:","   * `includeNonWordCharacters` A {Boolean} indicating whether to include","     non-word characters in the regex. (default: true)",""," Returns a {RegExp}."],"code":"  wordRegExp (options) {\r\n    const nonWordCharacters = _.escapeRegExp(this.getNonWordCharacters())\r\n    let source = `^[\\t ]*$|[^\\\\s${nonWordCharacters}]+`\r\n    if (!options || options.includeNonWordCharacters !== false) {\r\n      source += `|${`[${nonWordCharacters}]+`}`\r\n    }\r\n    return new RegExp(source, 'g')\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js","name":"Cursor.getNonWordCharacters","start_line":716,"end_line":718,"comment":["\r\n  Section: Private\r\n  "],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/clipboard.js","name":"md5","line":43,"func_location":"Clipboard.write","func_start_line":42,"func_end_line":46,"args":["text"],"comment":[" Public: Write the given text to the clipboard.",""," The metadata associated with the text is available by calling"," {::readWithMetadata}.",""," * `text` The {String} to store."," * `metadata` (optional) The additional info to associate with the text."],"code":"  write (text, metadata) {\r\n    this.signatureForMetadata = this.md5(text)\r\n    this.metadata = metadata\r\n    clipboard.writeText(text)\r\n  }\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/atom/src/clipboard.js","name":"Clipboard.md5","start_line":31,"end_line":33,"comment":[" Creates an `md5` hash of some text.",""," * `text` A {String} to hash.",""," Returns a hashed {String}."],"params":["text"]}}]