[{"func_info": {"comment": [" Private: Stop the native watcher and release any operating system resources associated with it.", "", " Has no effect if the watcher is not running."], "name": "NativeWatcher.stop", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js", "end_line": 142, "start_line": 130}, "call_info": {"func_end_line": 87, "code": "    return new Disposable(() => {\r\n      sub.dispose()\r\n      if (this.emitter.listenerCountForEventName('did-change') === 0) {\r\n        this.stop()\r\n      }\r\n    })\r", "name": "stop", "func_location": "NativeWatcher.onDidChange.(unnamed_function_1)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js", "line": 85, "func_start_line": 82}}, {"func_info": {"comment": [], "name": "AutoUpdateManager.setState", "params": ["state", "errorMessage"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "end_line": 108, "start_line": 103}, "call_info": {"func_end_line": 41, "code": "    autoUpdater.on('error', (event, message) => {\r\n      this.setState(ErrorState, message)\r\n      this.emitWindowEvent('update-error')\r\n      console.error(`Error Downloading Update: ${message}`)\r\n    })\r", "name": "setState", "func_location": "AutoUpdateManager.initialize.(unnamed_function_1)", "args": ["ErrorState", "message"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "line": 38, "func_start_line": 37}}, {"func_info": {"comment": [], "name": "AutoUpdateManager.emitWindowEvent", "params": ["eventName", "payload"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "end_line": 101, "start_line": 97}, "call_info": {"func_end_line": 41, "code": "    autoUpdater.on('error', (event, message) => {\r\n      this.setState(ErrorState, message)\r\n      this.emitWindowEvent('update-error')\r\n      console.error(`Error Downloading Update: ${message}`)\r\n    })\r", "name": "emitWindowEvent", "func_location": "AutoUpdateManager.initialize.(unnamed_function_1)", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "line": 39, "func_start_line": 37}}, {"func_info": {"comment": [], "name": "TitleBar.updateTitle", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/title-bar.js", "end_line": 42, "start_line": 40}, "call_info": {"func_end_line": 17, "code": "    this.workspace.onDidChangeWindowTitle(() => this.updateTitle())\r", "name": "updateTitle", "func_location": "TitleBar.constructor.(unnamed_function_1)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/title-bar.js", "line": 17, "func_start_line": 17}}, {"func_info": {"comment": [], "name": "Config.save", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 930, "start_line": 923}, "call_info": {"func_end_line": 437, "code": "    this.requestSave = _.debounce(() => this.save(), 1)\r", "name": "save", "func_location": "Config.clear.(unnamed_function_1)", "args": [null, {"type": "number"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 437, "func_start_line": 437}}, {"func_info": {"comment": [], "name": "ReopenProjectMenuManager.update", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js", "end_line": 51, "start_line": 45}, "call_info": {"func_end_line": 18, "code": "      config.onDidChange('core.reopenProjectMenuCount', ({oldValue, newValue}) => {\r\n        this.update()\r\n      }),\r", "name": "update", "func_location": "ReopenProjectMenuManager.constructor.(unnamed_function_1)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js", "line": 17, "func_start_line": 16}}, {"func_info": {"comment": [], "name": "StyleManager.removeStyleElement", "params": ["styleElement"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js", "end_line": 187, "start_line": 178}, "call_info": {"func_end_line": 156, "code": "    return new Disposable(() => { this.removeStyleElement(styleElement) })\r", "name": "removeStyleElement", "func_location": "StyleManager.addStyleSheet.(unnamed_function_1)", "args": ["styleElement"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js", "line": 156, "func_start_line": 156}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.retokenizeLines", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 263, "start_line": 253}, "call_info": {"func_end_line": 36, "code": "    this.disposables.add(this.grammar.onDidUpdate(() => this.retokenizeLines()))\r", "name": "retokenizeLines", "func_location": "TextMateLanguageMode.constructor.(unnamed_function_1)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 36, "func_start_line": 36}}, {"func_info": {"comment": [" Reread the index to update any values that have changed since the", " last time the index was read."], "name": "GitRepository.refreshIndex", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 536, "start_line": 534}, "call_info": {"func_end_line": 98, "code": "      const onWindowFocus = () => {\r\n        this.refreshIndex()\r\n        this.refreshStatus()\r\n      }\r", "name": "refreshIndex", "func_location": "GitRepository.constructor.onWindowFocus.(unnamed_function_1)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 96, "func_start_line": 95}}, {"func_info": {"comment": [" Refreshes the current git status in an outside process and asynchronously", " updates the relevant properties."], "name": "GitRepository.refreshStatus", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 594, "start_line": 540}, "call_info": {"func_end_line": 98, "code": "      const onWindowFocus = () => {\r\n        this.refreshIndex()\r\n        this.refreshStatus()\r\n      }\r", "name": "refreshStatus", "func_location": "GitRepository.constructor.onWindowFocus.(unnamed_function_1)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 97, "func_start_line": 95}}, {"func_info": {"comment": [" It's necessary to build the event handlers in this process, otherwise", " closures are dragged across processes and failed to be garbage collected", " appropriately."], "name": "ContextMenu.createClickHandlers", "params": ["template"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/context-menu.js", "end_line": 32, "start_line": 15}, "call_info": {"func_end_line": 31, "code": "    template.forEach(item => {\r\n      if (item.command) {\r\n        if (!item.commandDetail) item.commandDetail = {}\r\n        item.commandDetail.contextCommand = true\r\n        item.commandDetail.atomWindow = this.atomWindow\r\n        item.click = () => {\r\n          global.atomApplication.sendCommandToWindow(\r\n            item.command,\r\n            this.atomWindow,\r\n            item.commandDetail\r\n          )\r\n        }\r\n      } else if (item.submenu) {\r\n        this.createClickHandlers(item.submenu)\r\n      }\r\n    })\r", "name": "createClickHandlers", "func_location": "ContextMenu.createClickHandlers.(unnamed_function_1)", "args": ["item.submenu"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/context-menu.js", "line": 29, "func_start_line": 16}}, {"func_info": {"comment": [], "name": "StorageFolder.pathForKey", "params": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/storage-folder.js", "end_line": 44, "start_line": 42}, "call_info": {"func_end_line": 18, "code": "    return new Promise((resolve, reject) => {\r\n      if (!this.path) return resolve()\r\n      fs.writeFile(this.pathForKey(name), JSON.stringify(object), 'utf8', error =>\r\n        error ? reject(error) : resolve()\r\n      )\r\n    })\r", "name": "pathForKey", "func_location": "StorageFolder.store.(unnamed_function_1)", "args": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/storage-folder.js", "line": 15, "func_start_line": 13}}, {"func_info": {"comment": [], "name": "PaneElement.getActiveView", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js", "end_line": 207, "start_line": 205}, "call_info": {"func_end_line": 49, "code": "    const handleFocus = event => {\r\n      if (\r\n        !(\r\n          this.isActivating ||\r\n          this.model.isDestroyed() ||\r\n          this.contains(event.relatedTarget)\r\n        )\r\n      ) {\r\n        this.model.focus()\r\n      }\r\n      if (event.target !== this) return\r\n      const view = this.getActiveView()\r\n      if (view) {\r\n        view.focus()\r\n        event.stopPropagation()\r\n      }\r\n    }\r", "name": "getActiveView", "func_location": "PaneElement.subscribeToDOMEvents.handleFocus.(unnamed_function_1)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js", "line": 44, "func_start_line": 33}}, {"func_info": {"comment": [], "name": "cloneMenuItem", "params": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js", "end_line": 96, "start_line": 75}, "call_info": {"func_end_line": 93, "code": "    item.submenu = item.submenu.map(submenuItem => cloneMenuItem(submenuItem))\r", "name": "cloneMenuItem", "func_location": "cloneMenuItem.(unnamed_function_1)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js", "line": 93, "func_start_line": 93}}, {"func_info": {"comment": [], "name": "HistoryManager.addProject", "params": ["paths", "lastOpened"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "end_line": 68, "start_line": 55}, "call_info": {"func_end_line": 15, "code": "    this.disposables.add(project.onDidChangePaths((projectPaths) => this.addProject(projectPaths)))\r", "name": "addProject", "func_location": "HistoryManager.constructor.(unnamed_function_1)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "line": 15, "func_start_line": 15}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 36, "code": "    this.addEventListener('focus', (event) => this.getComponent().didFocus(event))\r", "name": "getComponent", "func_location": "TextEditorElement.createdCallback.(unnamed_function_1)", "args": [{"type": "string"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 36, "func_start_line": 36}}, {"func_info": {"comment": [], "name": "Package.loadStylesheets", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 490, "start_line": 486}, "call_info": {"func_end_line": 119, "code": "    this.measure('loadTime', () => {\r\n      this.path = path.join(this.packageManager.resourcePath, this.path)\r\n      ModuleCache.add(this.path, this.metadata)\r\n\r\n      this.loadStylesheets()\r\n      // Unfortunately some packages are accessing `@mainModulePath`, so we need\r\n      // to compute that variable eagerly also for preloaded packages.\r\n      this.getMainModulePath()\r\n    })\r", "name": "loadStylesheets", "func_location": "Package.finishLoading.(unnamed_function_1)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 115, "func_start_line": 111}}, {"func_info": {"comment": [], "name": "Package.getMainModulePath", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 803, "start_line": 786}, "call_info": {"func_end_line": 119, "code": "    this.measure('loadTime', () => {\r\n      this.path = path.join(this.packageManager.resourcePath, this.path)\r\n      ModuleCache.add(this.path, this.metadata)\r\n\r\n      this.loadStylesheets()\r\n      // Unfortunately some packages are accessing `@mainModulePath`, so we need\r\n      // to compute that variable eagerly also for preloaded packages.\r\n      this.getMainModulePath()\r\n    })\r", "name": "getMainModulePath", "func_location": "Package.finishLoading.(unnamed_function_1)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 118, "func_start_line": 111}}, {"func_info": {"comment": [], "name": "rejectSelector", "params": ["selector"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js", "end_line": 178, "start_line": 176}, "call_info": {"func_end_line": 96, "code": "    parser((parseResult) => {\r\n      for (let selectorNode of parseResult.nodes) {\r\n        let currentTable = null\r\n        let currentIndexValue = null\r\n\r\n        for (let i = selectorNode.nodes.length - 1; i >= 0; i--) {\r\n          const termNode = selectorNode.nodes[i]\r\n\r\n          switch (termNode.type) {\r\n            case 'tag':\r\n              if (!currentTable) currentTable = this.namedScopeTable\r\n              if (!currentTable[termNode.value]) currentTable[termNode.value] = {}\r\n              currentTable = currentTable[termNode.value]\r\n              if (currentIndexValue != null) {\r\n                if (!currentTable.indices) currentTable.indices = {}\r\n                if (!currentTable.indices[currentIndexValue]) currentTable.indices[currentIndexValue] = {}\r\n                currentTable = currentTable.indices[currentIndexValue]\r\n                currentIndexValue = null\r\n              }\r\n              break\r\n\r\n            case 'string':\r\n              if (!currentTable) currentTable = this.anonymousScopeTable\r\n              const value = termNode.value.slice(1, -1)\r\n              if (!currentTable[value]) currentTable[value] = {}\r\n              currentTable = currentTable[value]\r\n              if (currentIndexValue != null) {\r\n                if (!currentTable.indices) currentTable.indices = {}\r\n                if (!currentTable.indices[currentIndexValue]) currentTable.indices[currentIndexValue] = {}\r\n                currentTable = currentTable.indices[currentIndexValue]\r\n                currentIndexValue = null\r\n              }\r\n              break\r\n\r\n            case 'universal':\r\n              if (currentTable) {\r\n                if (!currentTable['*']) currentTable['*'] = {}\r\n                currentTable = currentTable['*']\r\n              } else {\r\n                if (!this.namedScopeTable['*']) {\r\n                  this.namedScopeTable['*'] = this.anonymousScopeTable['*'] = {}\r\n                }\r\n                currentTable = this.namedScopeTable['*']\r\n              }\r\n              if (currentIndexValue != null) {\r\n                if (!currentTable.indices) currentTable.indices = {}\r\n                if (!currentTable.indices[currentIndexValue]) currentTable.indices[currentIndexValue] = {}\r\n                currentTable = currentTable.indices[currentIndexValue]\r\n                currentIndexValue = null\r\n              }\r\n              break\r\n\r\n            case 'combinator':\r\n              if (currentIndexValue != null) {\r\n                rejectSelector(selector)\r\n              }\r\n\r\n              if (termNode.value === '>') {\r\n                if (!currentTable.parents) currentTable.parents = {}\r\n                currentTable = currentTable.parents\r\n              } else {\r\n                rejectSelector(selector)\r\n              }\r\n              break\r\n\r\n            case 'pseudo':\r\n              if (termNode.value === ':nth-child') {\r\n                currentIndexValue = termNode.nodes[0].nodes[0].value\r\n              } else {\r\n                rejectSelector(selector)\r\n              }\r\n              break\r\n\r\n            default:\r\n              rejectSelector(selector)\r\n          }\r\n        }\r\n\r\n        currentTable.result = result\r\n      }\r\n    }).process(selector)\r", "name": "rejectSelector", "func_location": "SyntaxScopeMap.addSelector.(unnamed_function_1)", "args": ["selector"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js", "line": 70, "func_start_line": 16}}, {"func_info": {"comment": [], "name": "rejectSelector", "params": ["selector"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js", "end_line": 178, "start_line": 176}, "call_info": {"func_end_line": 96, "code": "    parser((parseResult) => {\r\n      for (let selectorNode of parseResult.nodes) {\r\n        let currentTable = null\r\n        let currentIndexValue = null\r\n\r\n        for (let i = selectorNode.nodes.length - 1; i >= 0; i--) {\r\n          const termNode = selectorNode.nodes[i]\r\n\r\n          switch (termNode.type) {\r\n            case 'tag':\r\n              if (!currentTable) currentTable = this.namedScopeTable\r\n              if (!currentTable[termNode.value]) currentTable[termNode.value] = {}\r\n              currentTable = currentTable[termNode.value]\r\n              if (currentIndexValue != null) {\r\n                if (!currentTable.indices) currentTable.indices = {}\r\n                if (!currentTable.indices[currentIndexValue]) currentTable.indices[currentIndexValue] = {}\r\n                currentTable = currentTable.indices[currentIndexValue]\r\n                currentIndexValue = null\r\n              }\r\n              break\r\n\r\n            case 'string':\r\n              if (!currentTable) currentTable = this.anonymousScopeTable\r\n              const value = termNode.value.slice(1, -1)\r\n              if (!currentTable[value]) currentTable[value] = {}\r\n              currentTable = currentTable[value]\r\n              if (currentIndexValue != null) {\r\n                if (!currentTable.indices) currentTable.indices = {}\r\n                if (!currentTable.indices[currentIndexValue]) currentTable.indices[currentIndexValue] = {}\r\n                currentTable = currentTable.indices[currentIndexValue]\r\n                currentIndexValue = null\r\n              }\r\n              break\r\n\r\n            case 'universal':\r\n              if (currentTable) {\r\n                if (!currentTable['*']) currentTable['*'] = {}\r\n                currentTable = currentTable['*']\r\n              } else {\r\n                if (!this.namedScopeTable['*']) {\r\n                  this.namedScopeTable['*'] = this.anonymousScopeTable['*'] = {}\r\n                }\r\n                currentTable = this.namedScopeTable['*']\r\n              }\r\n              if (currentIndexValue != null) {\r\n                if (!currentTable.indices) currentTable.indices = {}\r\n                if (!currentTable.indices[currentIndexValue]) currentTable.indices[currentIndexValue] = {}\r\n                currentTable = currentTable.indices[currentIndexValue]\r\n                currentIndexValue = null\r\n              }\r\n              break\r\n\r\n            case 'combinator':\r\n              if (currentIndexValue != null) {\r\n                rejectSelector(selector)\r\n              }\r\n\r\n              if (termNode.value === '>') {\r\n                if (!currentTable.parents) currentTable.parents = {}\r\n                currentTable = currentTable.parents\r\n              } else {\r\n                rejectSelector(selector)\r\n              }\r\n              break\r\n\r\n            case 'pseudo':\r\n              if (termNode.value === ':nth-child') {\r\n                currentIndexValue = termNode.nodes[0].nodes[0].value\r\n              } else {\r\n                rejectSelector(selector)\r\n              }\r\n              break\r\n\r\n            default:\r\n              rejectSelector(selector)\r\n          }\r\n        }\r\n\r\n        currentTable.result = result\r\n      }\r\n    }).process(selector)\r", "name": "rejectSelector", "func_location": "SyntaxScopeMap.addSelector.(unnamed_function_1)", "args": ["selector"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js", "line": 77, "func_start_line": 16}}, {"func_info": {"comment": [], "name": "rejectSelector", "params": ["selector"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js", "end_line": 178, "start_line": 176}, "call_info": {"func_end_line": 96, "code": "    parser((parseResult) => {\r\n      for (let selectorNode of parseResult.nodes) {\r\n        let currentTable = null\r\n        let currentIndexValue = null\r\n\r\n        for (let i = selectorNode.nodes.length - 1; i >= 0; i--) {\r\n          const termNode = selectorNode.nodes[i]\r\n\r\n          switch (termNode.type) {\r\n            case 'tag':\r\n              if (!currentTable) currentTable = this.namedScopeTable\r\n              if (!currentTable[termNode.value]) currentTable[termNode.value] = {}\r\n              currentTable = currentTable[termNode.value]\r\n              if (currentIndexValue != null) {\r\n                if (!currentTable.indices) currentTable.indices = {}\r\n                if (!currentTable.indices[currentIndexValue]) currentTable.indices[currentIndexValue] = {}\r\n                currentTable = currentTable.indices[currentIndexValue]\r\n                currentIndexValue = null\r\n              }\r\n              break\r\n\r\n            case 'string':\r\n              if (!currentTable) currentTable = this.anonymousScopeTable\r\n              const value = termNode.value.slice(1, -1)\r\n              if (!currentTable[value]) currentTable[value] = {}\r\n              currentTable = currentTable[value]\r\n              if (currentIndexValue != null) {\r\n                if (!currentTable.indices) currentTable.indices = {}\r\n                if (!currentTable.indices[currentIndexValue]) currentTable.indices[currentIndexValue] = {}\r\n                currentTable = currentTable.indices[currentIndexValue]\r\n                currentIndexValue = null\r\n              }\r\n              break\r\n\r\n            case 'universal':\r\n              if (currentTable) {\r\n                if (!currentTable['*']) currentTable['*'] = {}\r\n                currentTable = currentTable['*']\r\n              } else {\r\n                if (!this.namedScopeTable['*']) {\r\n                  this.namedScopeTable['*'] = this.anonymousScopeTable['*'] = {}\r\n                }\r\n                currentTable = this.namedScopeTable['*']\r\n              }\r\n              if (currentIndexValue != null) {\r\n                if (!currentTable.indices) currentTable.indices = {}\r\n                if (!currentTable.indices[currentIndexValue]) currentTable.indices[currentIndexValue] = {}\r\n                currentTable = currentTable.indices[currentIndexValue]\r\n                currentIndexValue = null\r\n              }\r\n              break\r\n\r\n            case 'combinator':\r\n              if (currentIndexValue != null) {\r\n                rejectSelector(selector)\r\n              }\r\n\r\n              if (termNode.value === '>') {\r\n                if (!currentTable.parents) currentTable.parents = {}\r\n                currentTable = currentTable.parents\r\n              } else {\r\n                rejectSelector(selector)\r\n              }\r\n              break\r\n\r\n            case 'pseudo':\r\n              if (termNode.value === ':nth-child') {\r\n                currentIndexValue = termNode.nodes[0].nodes[0].value\r\n              } else {\r\n                rejectSelector(selector)\r\n              }\r\n              break\r\n\r\n            default:\r\n              rejectSelector(selector)\r\n          }\r\n        }\r\n\r\n        currentTable.result = result\r\n      }\r\n    }).process(selector)\r", "name": "rejectSelector", "func_location": "SyntaxScopeMap.addSelector.(unnamed_function_1)", "args": ["selector"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js", "line": 85, "func_start_line": 16}}, {"func_info": {"comment": [], "name": "rejectSelector", "params": ["selector"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js", "end_line": 178, "start_line": 176}, "call_info": {"func_end_line": 96, "code": "    parser((parseResult) => {\r\n      for (let selectorNode of parseResult.nodes) {\r\n        let currentTable = null\r\n        let currentIndexValue = null\r\n\r\n        for (let i = selectorNode.nodes.length - 1; i >= 0; i--) {\r\n          const termNode = selectorNode.nodes[i]\r\n\r\n          switch (termNode.type) {\r\n            case 'tag':\r\n              if (!currentTable) currentTable = this.namedScopeTable\r\n              if (!currentTable[termNode.value]) currentTable[termNode.value] = {}\r\n              currentTable = currentTable[termNode.value]\r\n              if (currentIndexValue != null) {\r\n                if (!currentTable.indices) currentTable.indices = {}\r\n                if (!currentTable.indices[currentIndexValue]) currentTable.indices[currentIndexValue] = {}\r\n                currentTable = currentTable.indices[currentIndexValue]\r\n                currentIndexValue = null\r\n              }\r\n              break\r\n\r\n            case 'string':\r\n              if (!currentTable) currentTable = this.anonymousScopeTable\r\n              const value = termNode.value.slice(1, -1)\r\n              if (!currentTable[value]) currentTable[value] = {}\r\n              currentTable = currentTable[value]\r\n              if (currentIndexValue != null) {\r\n                if (!currentTable.indices) currentTable.indices = {}\r\n                if (!currentTable.indices[currentIndexValue]) currentTable.indices[currentIndexValue] = {}\r\n                currentTable = currentTable.indices[currentIndexValue]\r\n                currentIndexValue = null\r\n              }\r\n              break\r\n\r\n            case 'universal':\r\n              if (currentTable) {\r\n                if (!currentTable['*']) currentTable['*'] = {}\r\n                currentTable = currentTable['*']\r\n              } else {\r\n                if (!this.namedScopeTable['*']) {\r\n                  this.namedScopeTable['*'] = this.anonymousScopeTable['*'] = {}\r\n                }\r\n                currentTable = this.namedScopeTable['*']\r\n              }\r\n              if (currentIndexValue != null) {\r\n                if (!currentTable.indices) currentTable.indices = {}\r\n                if (!currentTable.indices[currentIndexValue]) currentTable.indices[currentIndexValue] = {}\r\n                currentTable = currentTable.indices[currentIndexValue]\r\n                currentIndexValue = null\r\n              }\r\n              break\r\n\r\n            case 'combinator':\r\n              if (currentIndexValue != null) {\r\n                rejectSelector(selector)\r\n              }\r\n\r\n              if (termNode.value === '>') {\r\n                if (!currentTable.parents) currentTable.parents = {}\r\n                currentTable = currentTable.parents\r\n              } else {\r\n                rejectSelector(selector)\r\n              }\r\n              break\r\n\r\n            case 'pseudo':\r\n              if (termNode.value === ':nth-child') {\r\n                currentIndexValue = termNode.nodes[0].nodes[0].value\r\n              } else {\r\n                rejectSelector(selector)\r\n              }\r\n              break\r\n\r\n            default:\r\n              rejectSelector(selector)\r\n          }\r\n        }\r\n\r\n        currentTable.result = result\r\n      }\r\n    }).process(selector)\r", "name": "rejectSelector", "func_location": "SyntaxScopeMap.addSelector.(unnamed_function_1)", "args": ["selector"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js", "line": 90, "func_start_line": 16}}, {"func_info": {"comment": [" Sets the proper visible state the update menu items"], "name": "ApplicationMenu.showUpdateMenuItem", "params": ["state"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "end_line": 140, "start_line": 109}, "call_info": {"func_end_line": 16, "code": "    this.autoUpdateManager.on('state-changed', state => this.showUpdateMenuItem(state))\r", "name": "showUpdateMenuItem", "func_location": "ApplicationMenu.constructor.(unnamed_function_1)", "args": [{"type": "string"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "line": 16, "func_start_line": 16}}, {"func_info": {"comment": [], "name": "TooltipManager.add.hideTooltip", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip-manager.js", "end_line": 153, "start_line": 150}, "call_info": {"func_end_line": 174, "code": "    const disposable = new Disposable(() => {\r\n      window.removeEventListener('resize', hideTooltip)\r\n\r\n      hideTooltip()\r\n      tooltip.destroy()\r\n\r\n      if (this.tooltips.has(target)) {\r\n        const tooltipsForTarget = this.tooltips.get(target)\r\n        const index = tooltipsForTarget.indexOf(tooltip)\r\n        if (index !== -1) {\r\n          tooltipsForTarget.splice(index, 1)\r\n        }\r\n        if (tooltipsForTarget.length === 0) {\r\n          this.tooltips.delete(target)\r\n        }\r\n      }\r\n    })\r", "name": "hideTooltip", "func_location": "TooltipManager.add.disposable.(unnamed_function_1)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip-manager.js", "line": 161, "func_start_line": 158}}, {"func_info": {"comment": [], "name": "PanelContainerElement.hideAllPanelsExcept", "params": ["excludedPanel"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/panel-container-element.js", "end_line": 90, "start_line": 86}, "call_info": {"func_end_line": 55, "code": "      this.subscriptions.add(panel.onDidChangeVisible(visible => {\r\n        if (visible) { this.hideAllPanelsExcept(panel) }\r\n      }))\r", "name": "hideAllPanelsExcept", "func_location": "PanelContainerElement.panelAdded.(unnamed_function_1)", "args": ["panel"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/panel-container-element.js", "line": 54, "func_start_line": 53}}, {"func_info": {"comment": [" Spawn powershell.exe and callback when it completes"], "name": "spawnPowershell", "params": ["args", "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/win-powershell.js", "end_line": 28, "start_line": 13}, "call_info": {"func_end_line": 45, "name": "spawnPowershell", "func_location": "(unnamed_function_1)", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/win-powershell.js", "line": 37, "func_start_line": 36}}, {"func_info": {"comment": [" Extended: Show the dock without focusing it."], "name": "Dock.show", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 121, "start_line": 119}, "call_info": {"func_end_line": 63, "code": "      this.paneContainer.onDidActivatePane(() => {\r\n        this.show()\r\n        this.didActivate(this)\r\n      }),\r", "name": "show", "func_location": "Dock.constructor.(unnamed_function_1)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 61, "func_start_line": 60}}, {"func_info": {"comment": ["\r\n  Section: Event Subscription\r\n  ", " Essential: Invoke `callback` when style sheet changes associated with", " updating the list of active themes have completed.", "", " * `callback` {Function}", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "name": "ThemeManager.onDidChangeActiveThemes", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 57, "start_line": 55}, "call_info": {"func_end_line": 28, "code": "    this.packageManager.onDidActivateInitialPackages(() => {\r\n      this.onDidChangeActiveThemes(() => this.packageManager.reloadActivePackageStyleSheets())\r\n    })\r", "name": "onDidChangeActiveThemes", "func_location": "ThemeManager.constructor.(unnamed_function_1)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 27, "func_start_line": 26}}, {"func_info": {"comment": [], "name": "GrammarRegistry.removeGrammar", "params": ["grammar"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 478, "start_line": 472}, "call_info": {"func_end_line": 466, "code": "      return new Disposable(() => this.removeGrammar(grammar))\r", "name": "removeGrammar", "func_location": "GrammarRegistry.addGrammar.(unnamed_function_10)", "args": ["grammar"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 466, "func_start_line": 466}}, {"func_info": {"comment": ["\r\n  Section: Managing Settings\r\n  ", " Essential: Retrieves the setting for the given key.", "", " ### Examples", "", " You might want to know what themes are enabled, so check `core.themes`", "", " ```coffee", " atom.config.get('core.themes')", " ```", "", " With scope descriptors you can get settings within a specific editor", " scope. For example, you might want to know `editor.tabLength` for ruby", " files.", "", " ```coffee", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " ```", "", " This setting in ruby files might be different than the global tabLength setting", "", " ```coffee", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " ```", "", " You can get the language scope descriptor via", " {TextEditor::getRootScopeDescriptor}. This will get the setting specifically", " for the editor's language.", "", " ```coffee", " atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2", " ```", "", " Additionally, you can get the setting at the specific cursor position.", "", " ```coffee", " scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()", " atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2", " ```", "", " * `keyPath` The {String} name of the key to retrieve.", " * `options` (optional) {Object}", "   * `sources` (optional) {Array} of {String} source names. If provided, only", "     values that were associated with these sources during {::set} will be used.", "   * `excludeSources` (optional) {Array} of {String} source names. If provided,", "     values that  were associated with these sources during {::set} will not", "     be used.", "   * `scope` (optional) {ScopeDescriptor} describing a path from", "     the root of the syntax tree to a token. Get one by calling", "     {editor.getLastCursor().getScopeDescriptor()}", "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)", "     for more information.", "", " Returns the value from Atom's default settings, the user's configuration", " file in the type specified by the configuration schema."], "name": "Config.get", "params": ["args"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 602, "start_line": 585}, "call_info": {"func_end_line": 1055, "code": "    return this.emitter.on('did-change', () => {\r\n      const newValue = this.get(keyPath)\r\n      if (!_.isEqual(oldValue, newValue)) {\r\n        const event = {oldValue, newValue}\r\n        oldValue = newValue\r\n        return callback(event)\r\n      }\r\n    })\r", "name": "get", "func_location": "Config.onDidChangeKeyPath.(unnamed_function_10)", "args": ["keyPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1049, "func_start_line": 1048}}, {"func_info": {"comment": [], "name": "nodeContainsIndices", "params": ["node", "start", "end"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1198, "start_line": 1194}, "call_info": {"func_end_line": 406, "code": "    this._forEachTreeWithRange(range, (tree, grammar) => {\r\n      let node = tree.rootNode.descendantForIndex(startIndex, searchEndIndex)\r\n      while (node) {\r\n        if (nodeContainsIndices(node, startIndex, endIndex) && where(node, grammar)) {\r\n          if (nodeIsSmaller(node, smallestNode)) {\r\n            smallestNode = node\r\n            smallestNodeGrammar = grammar\r\n          }\r\n          break\r\n        }\r\n        node = node.parent\r\n      }\r\n    })\r", "name": "nodeContainsIndices", "func_location": "TreeSitterLanguageMode.getSyntaxNodeAndGrammarContainingRange.(unnamed_function_10)", "args": ["node", "startIndex", "endIndex"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 397, "func_start_line": 394}}, {"func_info": {"comment": [], "name": "nodeIsSmaller", "params": ["left", "right"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1204, "start_line": 1200}, "call_info": {"func_end_line": 406, "code": "    this._forEachTreeWithRange(range, (tree, grammar) => {\r\n      let node = tree.rootNode.descendantForIndex(startIndex, searchEndIndex)\r\n      while (node) {\r\n        if (nodeContainsIndices(node, startIndex, endIndex) && where(node, grammar)) {\r\n          if (nodeIsSmaller(node, smallestNode)) {\r\n            smallestNode = node\r\n            smallestNodeGrammar = grammar\r\n          }\r\n          break\r\n        }\r\n        node = node.parent\r\n      }\r\n    })\r", "name": "nodeIsSmaller", "func_location": "TreeSitterLanguageMode.getSyntaxNodeAndGrammarContainingRange.(unnamed_function_10)", "args": ["node", "smallestNode"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 398, "func_start_line": 394}}, {"func_info": {"comment": [], "name": "ApplicationMenu.focusedWindow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "end_line": 188, "start_line": 186}, "call_info": {"func_end_line": 167, "code": "          click: () => {\r\n            const window = this.focusedWindow()\r\n            if (window) window.close()\r\n          }\r", "name": "focusedWindow", "func_location": "submenu.click.(unnamed_function_10)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "line": 165, "func_start_line": 164}}, {"func_info": {"comment": [], "name": "ThemeManager.deactivateThemes", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 355, "start_line": 350}, "call_info": {"func_end_line": 346, "comment": [" @config.observe runs the callback once, then on subsequent changes."], "code": "      this.config.observe('core.themes', () => {\r\n        this.deactivateThemes().then(() => {\r\n          this.warnForNonExistentThemes()\r\n          this.refreshLessCache() // Update cache for packages in core.themes config\r\n\r\n          const promises = []\r\n          for (const themeName of this.getEnabledThemeNames()) {\r\n            if (this.packageManager.resolvePackagePath(themeName)) {\r\n              promises.push(this.packageManager.activatePackage(themeName))\r\n            } else {\r\n              console.warn(`Failed to activate theme '${themeName}' because it isn't installed.`)\r\n            }\r\n          }\r\n\r\n          return Promise.all(promises).then(() => {\r\n            this.addActiveThemeClasses()\r\n            this.refreshLessCache() // Update cache again now that @getActiveThemes() is populated\r\n            this.loadUserStylesheet()\r\n            this.reloadBaseStylesheets()\r\n            this.initialLoadComplete = true\r\n            this.emitter.emit('did-change-active-themes')\r\n            resolve()\r\n          })\r\n        })\r\n      })\r", "name": "deactivateThemes", "func_location": "ThemeManager.activateThemes.(unnamed_function_9).(unnamed_function_10)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 323, "func_start_line": 322}}, {"func_info": {"comment": [], "name": "AtomApplication.restart", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1370, "start_line": 1358}, "call_info": {"func_end_line": 1355, "code": "    }, response => { if (response === 0) this.restart() })\r", "name": "restart", "func_location": "AtomApplication.promptForRestart.(unnamed_function_100)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 1355, "func_start_line": 1355}}, {"func_info": {"comment": [], "name": "AtomApplication.getAllWindows", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 323, "start_line": 321}, "call_info": {"func_end_line": 1375, "code": "    const callback = () => {\r\n      this.getAllWindows().map(window => window.disableZoom())\r\n    }\r", "name": "getAllWindows", "func_location": "AtomApplication.disableZoomOnDisplayChange.callback.(unnamed_function_101)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 1374, "func_start_line": 1373}}, {"func_info": {"comment": [], "name": "GrammarRegistry.addGrammar", "params": ["grammar"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 470, "start_line": 456}, "call_info": {"func_end_line": 495, "code": "    this.readGrammar(grammarPath, (error, grammar) => {\r\n      if (error) return callback(error)\r\n      this.addGrammar(grammar)\r\n      callback(null, grammar)\r\n    })\r", "name": "addGrammar", "func_location": "GrammarRegistry.loadGrammar.(unnamed_function_11)", "args": ["grammar"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 493, "func_start_line": 491}}, {"func_info": {"comment": [], "name": "TextEditorComponent.updateOverlayToRender", "params": ["decoration"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1393, "start_line": 1362}, "call_info": {"func_end_line": 820, "code": "          didResize: (overlayComponent) => {\r\n            this.updateOverlayToRender(overlayProps)\r\n            overlayComponent.update(overlayProps)\r\n          }\r", "name": "updateOverlayToRender", "func_location": "didResize.(unnamed_function_11)", "args": ["overlayProps"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 818, "func_start_line": 817}}, {"func_info": {"comment": [], "name": "Config.setDefaults", "params": ["keyPath", "defaults"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1090, "start_line": 1070}, "call_info": {"func_end_line": 1081, "code": "      this.transact(() => {\r\n        const result = []\r\n        for (let key in defaults) {\r\n          const childValue = defaults[key]\r\n          if (!defaults.hasOwnProperty(key)) { continue }\r\n          result.push(this.setDefaults(keys.concat([key]).join('.'), childValue))\r\n        }\r\n        return result\r\n      })\r", "name": "setDefaults", "func_location": "Config.setDefaults.(unnamed_function_11)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1078, "func_start_line": 1073}}, {"func_info": {"comment": [], "name": "AtomWindow.prepareToUnload", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "end_line": 246, "start_line": 227}, "call_info": {"func_end_line": 175, "code": "    this.browserWindow.on('close', async event => {\r\n      if (!this.atomApplication.quitting && !this.unloading) {\r\n        event.preventDefault()\r\n        this.unloading = true\r\n        this.atomApplication.saveCurrentWindowOptions(false)\r\n        if (await this.prepareToUnload()) this.close()\r\n      }\r\n    })\r", "name": "prepareToUnload", "func_location": "AtomWindow.handleEvents.(unnamed_function_11)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "line": 173, "func_start_line": 168}}, {"func_info": {"comment": [], "name": "AtomWindow.close", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "end_line": 332, "start_line": 330}, "call_info": {"func_end_line": 175, "code": "    this.browserWindow.on('close', async event => {\r\n      if (!this.atomApplication.quitting && !this.unloading) {\r\n        event.preventDefault()\r\n        this.unloading = true\r\n        this.atomApplication.saveCurrentWindowOptions(false)\r\n        if (await this.prepareToUnload()) this.close()\r\n      }\r\n    })\r", "name": "close", "func_location": "AtomWindow.handleEvents.(unnamed_function_11)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "line": 173, "func_start_line": 168}}, {"func_info": {"comment": ["\r\n  Section: Pane Locations\r\n  ", " Essential: Get the {WorkspaceCenter} at the center of the editor window."], "name": "Workspace.getCenter", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1601, "start_line": 1599}, "call_info": {"func_end_line": 530, "code": "      dock.onDidChangeVisible(visible => {\r\n        if (visible) return\r\n        const {activeElement} = document\r\n        const dockElement = dock.getElement()\r\n        if (dockElement === activeElement || dockElement.contains(activeElement)) {\r\n          this.getCenter().activate()\r\n        }\r\n      })\r", "name": "getCenter", "func_location": "Workspace.subscribeToDockToggling.(unnamed_function_10).(unnamed_function_11)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 528, "func_start_line": 523}}, {"func_info": {"comment": [], "name": "ApplicationMenu.focusedWindow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "end_line": 188, "start_line": 186}, "call_info": {"func_end_line": 175, "code": "          click: () => {\r\n            const window = this.focusedWindow()\r\n            if (window) window.toggleDevTools()\r\n          }\r", "name": "focusedWindow", "func_location": "submenu.click.(unnamed_function_11)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "line": 173, "func_start_line": 172}}, {"func_info": {"comment": [" Public: Destroy the given item.", "", " If the item is active, the next item will be activated. If the item is the", " last item, the pane will be destroyed if the `core.destroyEmptyPanes` config", " setting is `true`.", "", " * `item` Item to destroy", " * `force` (optional) {Boolean} Destroy the item without prompting to save", "    it, even if the item's `isPermanentDockItem` method returns true.", "", " Returns a {Promise} that resolves with a {Boolean} indicating whether or not", " the item was destroyed."], "name": "Pane.destroyItem", "params": ["item", "force"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 782, "start_line": 757}, "call_info": {"func_end_line": 787, "code": "      this.getItems().map(item => this.destroyItem(item))\r", "name": "destroyItem", "func_location": "Pane.destroyItems.(unnamed_function_11)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 787, "func_start_line": 787}}, {"func_info": {"comment": ["\r\n  Section: Managing Enabled Themes\r\n  "], "name": "ThemeManager.warnForNonExistentThemes", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 112, "start_line": 104}, "call_info": {"func_end_line": 345, "code": "        this.deactivateThemes().then(() => {\r\n          this.warnForNonExistentThemes()\r\n          this.refreshLessCache() // Update cache for packages in core.themes config\r\n\r\n          const promises = []\r\n          for (const themeName of this.getEnabledThemeNames()) {\r\n            if (this.packageManager.resolvePackagePath(themeName)) {\r\n              promises.push(this.packageManager.activatePackage(themeName))\r\n            } else {\r\n              console.warn(`Failed to activate theme '${themeName}' because it isn't installed.`)\r\n            }\r\n          }\r\n\r\n          return Promise.all(promises).then(() => {\r\n            this.addActiveThemeClasses()\r\n            this.refreshLessCache() // Update cache again now that @getActiveThemes() is populated\r\n            this.loadUserStylesheet()\r\n            this.reloadBaseStylesheets()\r\n            this.initialLoadComplete = true\r\n            this.emitter.emit('did-change-active-themes')\r\n            resolve()\r\n          })\r\n        })\r", "name": "warnForNonExistentThemes", "func_location": "ThemeManager.activateThemes.(unnamed_function_9).(unnamed_function_10).(unnamed_function_11)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 324, "func_start_line": 323}}, {"func_info": {"comment": [], "name": "ThemeManager.refreshLessCache", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 379, "start_line": 377}, "call_info": {"func_end_line": 345, "code": "        this.deactivateThemes().then(() => {\r\n          this.warnForNonExistentThemes()\r\n          this.refreshLessCache() // Update cache for packages in core.themes config\r\n\r\n          const promises = []\r\n          for (const themeName of this.getEnabledThemeNames()) {\r\n            if (this.packageManager.resolvePackagePath(themeName)) {\r\n              promises.push(this.packageManager.activatePackage(themeName))\r\n            } else {\r\n              console.warn(`Failed to activate theme '${themeName}' because it isn't installed.`)\r\n            }\r\n          }\r\n\r\n          return Promise.all(promises).then(() => {\r\n            this.addActiveThemeClasses()\r\n            this.refreshLessCache() // Update cache again now that @getActiveThemes() is populated\r\n            this.loadUserStylesheet()\r\n            this.reloadBaseStylesheets()\r\n            this.initialLoadComplete = true\r\n            this.emitter.emit('did-change-active-themes')\r\n            resolve()\r\n          })\r\n        })\r", "name": "refreshLessCache", "func_location": "ThemeManager.activateThemes.(unnamed_function_9).(unnamed_function_10).(unnamed_function_11)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 325, "func_start_line": 323}}, {"func_info": {"comment": [" Public: Get the enabled theme names from the config.", "", " Returns an array of theme names in the order that they should be activated."], "name": "ThemeManager.getEnabledThemeNames", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 152, "start_line": 117}, "call_info": {"func_end_line": 345, "code": "        this.deactivateThemes().then(() => {\r\n          this.warnForNonExistentThemes()\r\n          this.refreshLessCache() // Update cache for packages in core.themes config\r\n\r\n          const promises = []\r\n          for (const themeName of this.getEnabledThemeNames()) {\r\n            if (this.packageManager.resolvePackagePath(themeName)) {\r\n              promises.push(this.packageManager.activatePackage(themeName))\r\n            } else {\r\n              console.warn(`Failed to activate theme '${themeName}' because it isn't installed.`)\r\n            }\r\n          }\r\n\r\n          return Promise.all(promises).then(() => {\r\n            this.addActiveThemeClasses()\r\n            this.refreshLessCache() // Update cache again now that @getActiveThemes() is populated\r\n            this.loadUserStylesheet()\r\n            this.reloadBaseStylesheets()\r\n            this.initialLoadComplete = true\r\n            this.emitter.emit('did-change-active-themes')\r\n            resolve()\r\n          })\r\n        })\r", "name": "getEnabledThemeNames", "func_location": "ThemeManager.activateThemes.(unnamed_function_9).(unnamed_function_10).(unnamed_function_11)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 328, "func_start_line": 323}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedStartRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2726, "start_line": 2720}, "call_info": {"func_end_line": 886, "code": "    this.linesToMeasure.forEach((screenLine, row) => {\r\n      if (row < this.getRenderedStartRow() || row >= this.getRenderedEndRow()) {\r\n        this.extraRenderedScreenLines.set(row, screenLine)\r\n      }\r\n    })\r", "name": "getRenderedStartRow", "func_location": "TextEditorComponent.queryExtraScreenLinesToRender.(unnamed_function_12)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 883, "func_start_line": 882}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedEndRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2737, "start_line": 2728}, "call_info": {"func_end_line": 886, "code": "    this.linesToMeasure.forEach((screenLine, row) => {\r\n      if (row < this.getRenderedStartRow() || row >= this.getRenderedEndRow()) {\r\n        this.extraRenderedScreenLines.set(row, screenLine)\r\n      }\r\n    })\r", "name": "getRenderedEndRow", "func_location": "TextEditorComponent.queryExtraScreenLinesToRender.(unnamed_function_12)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 883, "func_start_line": 882}}, {"func_info": {"comment": [], "name": "Config.deepClone", "params": ["object"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1102, "start_line": 1092}, "call_info": {"func_end_line": 1096, "code": "      return object.map(value => this.deepClone(value))\r", "name": "deepClone", "func_location": "Config.deepClone.(unnamed_function_12)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1096, "func_start_line": 1096}}, {"func_info": {"comment": [], "name": "PackageManager.getAvailablePackages", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 414, "start_line": 382}, "call_info": {"func_end_line": 546, "code": "    this.config.transact(() => {\r\n      for (const pack of this.getAvailablePackages()) {\r\n        this.loadAvailablePackage(pack, disabledPackageNames)\r\n      }\r\n    })\r", "name": "getAvailablePackages", "func_location": "PackageManager.loadPackages.(unnamed_function_12)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 543, "func_start_line": 542}}, {"func_info": {"comment": [], "name": "PackageManager.loadAvailablePackage", "params": ["availablePackage", "disabledPackageNames"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 635, "start_line": 571}, "call_info": {"func_end_line": 546, "code": "    this.config.transact(() => {\r\n      for (const pack of this.getAvailablePackages()) {\r\n        this.loadAvailablePackage(pack, disabledPackageNames)\r\n      }\r\n    })\r", "name": "loadAvailablePackage", "func_location": "PackageManager.loadPackages.(unnamed_function_12)", "args": ["pack", "disabledPackageNames"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 544, "func_start_line": 542}}, {"func_info": {"comment": [], "name": "AtomApplication.saveCurrentWindowOptions", "params": ["allowEmpty"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 981, "start_line": 968}, "call_info": {"func_end_line": 310, "name": "saveCurrentWindowOptions", "func_location": "AtomApplication.addWindow.blurHandler.(unnamed_function_12)", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 309, "func_start_line": 309}}, {"func_info": {"comment": [], "name": "ThemeManager.addActiveThemeClasses", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 368, "start_line": 361}, "call_info": {"func_end_line": 344, "code": "          return Promise.all(promises).then(() => {\r\n            this.addActiveThemeClasses()\r\n            this.refreshLessCache() // Update cache again now that @getActiveThemes() is populated\r\n            this.loadUserStylesheet()\r\n            this.reloadBaseStylesheets()\r\n            this.initialLoadComplete = true\r\n            this.emitter.emit('did-change-active-themes')\r\n            resolve()\r\n          })\r", "name": "addActiveThemeClasses", "func_location": "ThemeManager.activateThemes.(unnamed_function_9).(unnamed_function_10).(unnamed_function_11).(unnamed_function_12)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 337, "func_start_line": 336}}, {"func_info": {"comment": [], "name": "ThemeManager.refreshLessCache", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 379, "start_line": 377}, "call_info": {"func_end_line": 344, "code": "          return Promise.all(promises).then(() => {\r\n            this.addActiveThemeClasses()\r\n            this.refreshLessCache() // Update cache again now that @getActiveThemes() is populated\r\n            this.loadUserStylesheet()\r\n            this.reloadBaseStylesheets()\r\n            this.initialLoadComplete = true\r\n            this.emitter.emit('did-change-active-themes')\r\n            resolve()\r\n          })\r", "name": "refreshLessCache", "func_location": "ThemeManager.activateThemes.(unnamed_function_9).(unnamed_function_10).(unnamed_function_11).(unnamed_function_12)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 338, "func_start_line": 336}}, {"func_info": {"comment": [], "name": "ThemeManager.loadUserStylesheet", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 218, "start_line": 185}, "call_info": {"func_end_line": 344, "code": "          return Promise.all(promises).then(() => {\r\n            this.addActiveThemeClasses()\r\n            this.refreshLessCache() // Update cache again now that @getActiveThemes() is populated\r\n            this.loadUserStylesheet()\r\n            this.reloadBaseStylesheets()\r\n            this.initialLoadComplete = true\r\n            this.emitter.emit('did-change-active-themes')\r\n            resolve()\r\n          })\r", "name": "loadUserStylesheet", "func_location": "ThemeManager.activateThemes.(unnamed_function_9).(unnamed_function_10).(unnamed_function_11).(unnamed_function_12)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 339, "func_start_line": 336}}, {"func_info": {"comment": [], "name": "ThemeManager.reloadBaseStylesheets", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 226, "start_line": 224}, "call_info": {"func_end_line": 344, "code": "          return Promise.all(promises).then(() => {\r\n            this.addActiveThemeClasses()\r\n            this.refreshLessCache() // Update cache again now that @getActiveThemes() is populated\r\n            this.loadUserStylesheet()\r\n            this.reloadBaseStylesheets()\r\n            this.initialLoadComplete = true\r\n            this.emitter.emit('did-change-active-themes')\r\n            resolve()\r\n          })\r", "name": "reloadBaseStylesheets", "func_location": "ThemeManager.activateThemes.(unnamed_function_9).(unnamed_function_10).(unnamed_function_11).(unnamed_function_12)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 340, "func_start_line": 336}}, {"func_info": {"comment": [], "name": "GrammarRegistry.createGrammar", "params": ["grammarPath", "params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 547, "start_line": 538}, "call_info": {"func_end_line": 526, "code": "    CSON.readFile(grammarPath, (error, params = {}) => {\r\n      if (error) return callback(error)\r\n      try {\r\n        callback(null, this.createGrammar(grammarPath, params))\r\n      } catch (error) {\r\n        callback(error)\r\n      }\r\n    })\r", "name": "createGrammar", "func_location": "GrammarRegistry.readGrammar.(unnamed_function_13)", "args": [{"type": "object"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 522, "func_start_line": 519}}, {"func_info": {"comment": [], "name": "Config.deepClone", "params": ["object"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1102, "start_line": 1092}, "call_info": {"func_end_line": 1098, "code": "      return _.mapObject(object, (key, value) => [key, this.deepClone(value)])\r", "name": "deepClone", "func_location": "Config.deepClone.(unnamed_function_13)", "args": ["object", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1098, "func_start_line": 1098}}, {"func_info": {"comment": [], "name": "BufferedProcess.handleError", "params": ["error"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "end_line": 312, "start_line": 297}, "call_info": {"func_end_line": 294, "code": "    this.process.on('error', (error) => {\r\n      this.handleError(error)\r\n    })\r", "name": "handleError", "func_location": "BufferedProcess.handleEvents.(unnamed_function_13)", "args": ["error"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "line": 293, "func_start_line": 292}}, {"func_info": {"comment": [], "name": "PackageManager.unloadPackage", "params": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 653, "start_line": 641}, "call_info": {"func_end_line": 638, "code": "    _.keys(this.loadedPackages).forEach(name => this.unloadPackage(name))\r", "name": "unloadPackage", "func_location": "PackageManager.unloadPackages.(unnamed_function_13)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 638, "func_start_line": 638}}, {"func_info": {"comment": [" Public: Destroy the given item.", "", " If the item is active, the next item will be activated. If the item is the", " last item, the pane will be destroyed if the `core.destroyEmptyPanes` config", " setting is `true`.", "", " * `item` Item to destroy", " * `force` (optional) {Boolean} Destroy the item without prompting to save", "    it, even if the item's `isPermanentDockItem` method returns true.", "", " Returns a {Promise} that resolves with a {Boolean} indicating whether or not", " the item was destroyed."], "name": "Pane.destroyItem", "params": ["item", "force"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 782, "start_line": 757}, "call_info": {"func_end_line": 796, "name": "destroyItem", "func_location": "Pane.destroyInactiveItems.(unnamed_function_13)", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 796, "func_start_line": 796}}, {"func_info": {"comment": [" Private: Callback function invoked by the native watcher when a debounced group of filesystem events arrive.", " Normalize and re-broadcast them to any subscribers.", "", " * `events` An Array of filesystem events."], "name": "NativeWatcher.onEvents", "params": ["events"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js", "end_line": 159, "start_line": 157}, "call_info": {"func_end_line": 242, "code": "    this.subs.add(treeView.onFileCreated(async event => {\r\n      const realPath = await getRealPath(event.path)\r\n      if (!realPath) return\r\n\r\n      this.onEvents([{action: 'added', path: realPath}])\r\n    }))\r", "name": "onEvents", "func_location": "AtomNativeWatcher.doStart.(unnamed_function_14)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js", "line": 241, "func_start_line": 237}}, {"func_info": {"comment": [], "name": "TextEditorComponent.addDecorationToRender", "params": ["type", "decoration", "marker", "screenRange", "reversed"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1042, "start_line": 1011}, "call_info": {"func_end_line": 1006, "code": "    decorationsByMarker.forEach((decorations, marker) => {\r\n      const screenRange = marker.getScreenRange()\r\n      const reversed = marker.isReversed()\r\n      for (let i = 0; i < decorations.length; i++) {\r\n        const decoration = decorations[i]\r\n        this.addDecorationToRender(decoration.type, decoration, marker, screenRange, reversed)\r\n      }\r\n    })\r", "name": "addDecorationToRender", "func_location": "TextEditorComponent.queryDecorationsToRender.(unnamed_function_14)", "args": ["decoration.type", "decoration", "marker", "screenRange", "reversed"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1004, "func_start_line": 999}}, {"func_info": {"comment": [], "name": "Config.makeValueConformToSchema", "params": ["keyPath", "value", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1178, "start_line": 1164}, "call_info": {"func_end_line": 1193, "code": "    return this.transact(() => {\r\n      this.settings = this.makeValueConformToSchema(null, this.settings, {suppressException: true})\r\n      const selectorsAndSettings = this.scopedSettingsStore.propertiesForSource(source)\r\n      this.scopedSettingsStore.removePropertiesForSource(source)\r\n      for (let scopeSelector in selectorsAndSettings) {\r\n        let settings = selectorsAndSettings[scopeSelector]\r\n        settings = this.makeValueConformToSchema(null, settings, {suppressException: true})\r\n        this.setRawScopedValue(null, settings, source, scopeSelector)\r\n      }\r\n    })\r", "name": "makeValueConformToSchema", "func_location": "Config.resetSettingsForSchemaChange.(unnamed_function_14)", "args": [{"type": "object"}, ".settings", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1185, "func_start_line": 1184}}, {"func_info": {"comment": [], "name": "Config.makeValueConformToSchema", "params": ["keyPath", "value", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1178, "start_line": 1164}, "call_info": {"func_end_line": 1193, "code": "    return this.transact(() => {\r\n      this.settings = this.makeValueConformToSchema(null, this.settings, {suppressException: true})\r\n      const selectorsAndSettings = this.scopedSettingsStore.propertiesForSource(source)\r\n      this.scopedSettingsStore.removePropertiesForSource(source)\r\n      for (let scopeSelector in selectorsAndSettings) {\r\n        let settings = selectorsAndSettings[scopeSelector]\r\n        settings = this.makeValueConformToSchema(null, settings, {suppressException: true})\r\n        this.setRawScopedValue(null, settings, source, scopeSelector)\r\n      }\r\n    })\r", "name": "makeValueConformToSchema", "func_location": "Config.resetSettingsForSchemaChange.(unnamed_function_14)", "args": [{"type": "object"}, "settings", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1190, "func_start_line": 1184}}, {"func_info": {"comment": [], "name": "Config.setRawScopedValue", "params": ["keyPath", "value", "source", "selector", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1242, "start_line": 1231}, "call_info": {"func_end_line": 1193, "code": "    return this.transact(() => {\r\n      this.settings = this.makeValueConformToSchema(null, this.settings, {suppressException: true})\r\n      const selectorsAndSettings = this.scopedSettingsStore.propertiesForSource(source)\r\n      this.scopedSettingsStore.removePropertiesForSource(source)\r\n      for (let scopeSelector in selectorsAndSettings) {\r\n        let settings = selectorsAndSettings[scopeSelector]\r\n        settings = this.makeValueConformToSchema(null, settings, {suppressException: true})\r\n        this.setRawScopedValue(null, settings, source, scopeSelector)\r\n      }\r\n    })\r", "name": "setRawScopedValue", "func_location": "Config.resetSettingsForSchemaChange.(unnamed_function_14)", "args": [{"type": "object"}, "settings", "source", "scopeSelector"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1191, "func_start_line": 1184}}, {"func_info": {"comment": [], "name": "Package.registerViewProviders", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 537, "start_line": 526}, "call_info": {"func_end_line": 503, "code": "          deserialize: (state, atomEnvironment) => {\r\n            this.registerViewProviders()\r\n            this.requireMainModule()\r\n            this.initializeIfNeeded()\r\n            return this.mainModule[methodName](state, atomEnvironment)\r\n          }\r", "name": "registerViewProviders", "func_location": "deserialize.(unnamed_function_14)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 499, "func_start_line": 498}}, {"func_info": {"comment": [], "name": "Package.requireMainModule", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 784, "start_line": 755}, "call_info": {"func_end_line": 503, "code": "          deserialize: (state, atomEnvironment) => {\r\n            this.registerViewProviders()\r\n            this.requireMainModule()\r\n            this.initializeIfNeeded()\r\n            return this.mainModule[methodName](state, atomEnvironment)\r\n          }\r", "name": "requireMainModule", "func_location": "deserialize.(unnamed_function_14)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 500, "func_start_line": 498}}, {"func_info": {"comment": [], "name": "Package.initializeIfNeeded", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 187, "start_line": 170}, "call_info": {"func_end_line": 503, "code": "          deserialize: (state, atomEnvironment) => {\r\n            this.registerViewProviders()\r\n            this.requireMainModule()\r\n            this.initializeIfNeeded()\r\n            return this.mainModule[methodName](state, atomEnvironment)\r\n          }\r", "name": "initializeIfNeeded", "func_location": "deserialize.(unnamed_function_14)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 501, "func_start_line": 498}}, {"func_info": {"comment": [], "name": "PackageManager.triggerDeferredActivationHooks", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 734, "start_line": 724}, "call_info": {"func_end_line": 666, "code": "    return Promise.all(promises).then(() => {\r\n      this.triggerDeferredActivationHooks()\r\n      this.initialPackagesActivated = true\r\n      this.emitter.emit('did-activate-initial-packages')\r\n    })\r", "name": "triggerDeferredActivationHooks", "func_location": "PackageManager.activate.(unnamed_function_14)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 663, "func_start_line": 662}}, {"func_info": {"comment": [" Determine the accelerator for a given command.", "", " command - The name of the command.", " keystrokesByCommand - An Object where the keys are commands and the values", "                       are Arrays containing the keystroke.", "", " Returns a String containing the keystroke in a format that can be interpreted", "   by Electron to provide nice icons where available."], "name": "ApplicationMenu.acceleratorForCommand", "params": ["command", "keystrokesByCommand"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "end_line": 224, "start_line": 221}, "call_info": {"func_end_line": 209, "code": "    template.forEach(item => {\r\n      if (item.metadata == null) item.metadata = {}\r\n      if (item.command) {\r\n        item.accelerator = this.acceleratorForCommand(item.command, keystrokesByCommand)\r\n        item.click = () => global.atomApplication.sendCommand(item.command, item.commandDetail)\r\n        if (!/^application:/.test(item.command)) {\r\n          item.metadata.windowSpecific = true\r\n        }\r\n      }\r\n      if (item.submenu) this.translateTemplate(item.submenu, keystrokesByCommand)\r\n    })\r", "name": "acceleratorForCommand", "func_location": "ApplicationMenu.translateTemplate.(unnamed_function_14)", "args": ["item.command", "keystrokesByCommand"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "line": 202, "func_start_line": 199}}, {"func_info": {"comment": [" Combines a menu template with the appropriate keystroke.", "", " template - An Object conforming to atom-shell's menu api but lacking", "            accelerator and click properties.", " keystrokesByCommand - An Object where the keys are commands and the values", "                       are Arrays containing the keystroke.", "", " Returns a complete menu configuration object for atom-shell's menu API."], "name": "ApplicationMenu.translateTemplate", "params": ["template", "keystrokesByCommand"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "end_line": 211, "start_line": 198}, "call_info": {"func_end_line": 209, "code": "    template.forEach(item => {\r\n      if (item.metadata == null) item.metadata = {}\r\n      if (item.command) {\r\n        item.accelerator = this.acceleratorForCommand(item.command, keystrokesByCommand)\r\n        item.click = () => global.atomApplication.sendCommand(item.command, item.commandDetail)\r\n        if (!/^application:/.test(item.command)) {\r\n          item.metadata.windowSpecific = true\r\n        }\r\n      }\r\n      if (item.submenu) this.translateTemplate(item.submenu, keystrokesByCommand)\r\n    })\r", "name": "translateTemplate", "func_location": "ApplicationMenu.translateTemplate.(unnamed_function_14)", "args": ["item.submenu", "keystrokesByCommand"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "line": 208, "func_start_line": 199}}, {"func_info": {"comment": [" Private: Callback function invoked by the native watcher when a debounced group of filesystem events arrive.", " Normalize and re-broadcast them to any subscribers.", "", " * `events` An Array of filesystem events."], "name": "NativeWatcher.onEvents", "params": ["events"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js", "end_line": 159, "start_line": 157}, "call_info": {"func_end_line": 249, "code": "    this.subs.add(treeView.onEntryDeleted(async event => {\r\n      const realPath = await getRealPath(event.path)\r\n      if (!realPath || await isOpenInEditor(realPath)) return\r\n\r\n      this.onEvents([{action: 'deleted', path: realPath}])\r\n    }))\r", "name": "onEvents", "func_location": "AtomNativeWatcher.doStart.(unnamed_function_15)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js", "line": 248, "func_start_line": 244}}, {"func_info": {"comment": [], "name": "LanguageLayer._populateInjections", "params": ["range", "nodeRangeSet"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 781, "start_line": 701}, "call_info": {"func_end_line": 619, "code": "      this.currentParsePromise = this.currentParsePromise.then(async () => {\r\n        await this._populateInjections(MAX_RANGE, null)\r\n        this.currentParsePromise = null\r\n      })\r", "name": "_populateInjections", "func_location": "LanguageLayer.updateInjections.(unnamed_function_15)", "args": ["MAX_RANGE", {"type": "object"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 617, "func_start_line": 616}}, {"func_info": {"comment": [" Activate a single package by name"], "name": "PackageManager.activatePackage", "params": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 722, "start_line": 696}, "call_info": {"func_end_line": 689, "code": "    this.config.transactAsync(() => {\r\n      for (const pack of packages) {\r\n        const promise = this.activatePackage(pack.name)\r\n        if (!pack.activationShouldBeDeferred()) {\r\n          promises.push(promise)\r\n        }\r\n      }\r\n      return Promise.all(promises)\r\n    })\r", "name": "activatePackage", "func_location": "PackageManager.activatePackages.(unnamed_function_15)", "args": ["pack.name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 683, "func_start_line": 681}}, {"func_info": {"comment": [" Private: Callback function invoked by the native watcher when a debounced group of filesystem events arrive.", " Normalize and re-broadcast them to any subscribers.", "", " * `events` An Array of filesystem events."], "name": "NativeWatcher.onEvents", "params": ["events"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js", "end_line": 159, "start_line": 157}, "call_info": {"func_end_line": 259, "code": "    this.subs.add(treeView.onEntryMoved(async event => {\r\n      const [realNewPath, realOldPath] = await Promise.all([\r\n        getRealPath(event.newPath),\r\n        getRealPath(event.initialPath)\r\n      ])\r\n      if (!realNewPath || !realOldPath || await isOpenInEditor(realNewPath) || await isOpenInEditor(realOldPath)) return\r\n\r\n      this.onEvents([{action: 'renamed', path: realNewPath, oldPath: realOldPath}])\r\n    }))\r", "name": "onEvents", "func_location": "AtomNativeWatcher.doStart.(unnamed_function_16)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js", "line": 258, "func_start_line": 251}}, {"func_info": {"comment": ["\r\n  Section: Managing Settings\r\n  ", " Essential: Retrieves the setting for the given key.", "", " ### Examples", "", " You might want to know what themes are enabled, so check `core.themes`", "", " ```coffee", " atom.config.get('core.themes')", " ```", "", " With scope descriptors you can get settings within a specific editor", " scope. For example, you might want to know `editor.tabLength` for ruby", " files.", "", " ```coffee", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " ```", "", " This setting in ruby files might be different than the global tabLength setting", "", " ```coffee", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " ```", "", " You can get the language scope descriptor via", " {TextEditor::getRootScopeDescriptor}. This will get the setting specifically", " for the editor's language.", "", " ```coffee", " atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2", " ```", "", " Additionally, you can get the setting at the specific cursor position.", "", " ```coffee", " scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()", " atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2", " ```", "", " * `keyPath` The {String} name of the key to retrieve.", " * `options` (optional) {Object}", "   * `sources` (optional) {Array} of {String} source names. If provided, only", "     values that were associated with these sources during {::set} will be used.", "   * `excludeSources` (optional) {Array} of {String} source names. If provided,", "     values that  were associated with these sources during {::set} will not", "     be used.", "   * `scope` (optional) {ScopeDescriptor} describing a path from", "     the root of the syntax tree to a token. Get one by calling", "     {editor.getLastCursor().getScopeDescriptor()}", "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)", "     for more information.", "", " Returns the value from Atom's default settings, the user's configuration", " file in the type specified by the configuration schema."], "name": "Config.get", "params": ["args"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 602, "start_line": 585}, "call_info": {"func_end_line": 1278, "code": "    return this.emitter.on('did-change', () => {\r\n      const newValue = this.get(keyPath, {scope})\r\n      if (!_.isEqual(oldValue, newValue)) {\r\n        const event = {oldValue, newValue}\r\n        oldValue = newValue\r\n        callback(event)\r\n      }\r\n    })\r", "name": "get", "func_location": "Config.onDidChangeScopedKeyPath.(unnamed_function_16)", "args": ["keyPath", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1272, "func_start_line": 1271}}, {"func_info": {"comment": [], "name": "Package.initializeIfNeeded", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 187, "start_line": 170}, "call_info": {"func_end_line": 533, "code": "        this.viewRegistry.addViewProvider(model => {\r\n          this.initializeIfNeeded()\r\n          return this.mainModule[methodName](model)\r\n        })\r", "name": "initializeIfNeeded", "func_location": "Package.registerViewProviders.(unnamed_function_15).(unnamed_function_16)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 531, "func_start_line": 530}}, {"func_info": {"comment": [], "name": "AtomApplication.openWithOptions", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 281, "start_line": 207}, "call_info": {"func_end_line": 341, "code": "      connection.on('end', () => this.openWithOptions(JSON.parse(data)))\r", "name": "openWithOptions", "func_location": "AtomApplication.listenForArgumentsFromNewProcess.server.(unnamed_function_14).(unnamed_function_16)", "args": [{"type": "string"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 341, "func_start_line": 341}}, {"func_info": {"comment": [" Private: Callback function invoked by the native watcher when a debounced group of filesystem events arrive.", " Normalize and re-broadcast them to any subscribers.", "", " * `events` An Array of filesystem events."], "name": "NativeWatcher.onEvents", "params": ["events"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js", "end_line": 159, "start_line": 157}, "call_info": {"func_end_line": 280, "name": "onEvents", "func_location": "NSFWNativeWatcher.doStart.handler.(unnamed_function_17)", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js", "line": 267, "func_start_line": 266}}, {"func_info": {"comment": ["\r\n  Section: Managing The Atom Window\r\n  ", " Essential: Open a new Atom window using the given options.", "", " Calling this method without an options parameter will open a prompt to pick", " a file/folder to open in the new window.", "", " * `params` An {Object} with the following keys:", "   * `pathsToOpen`  An {Array} of {String} paths to open.", "   * `newWindow` A {Boolean}, true to always open a new window instead of", "     reusing existing windows depending on the paths to open.", "   * `devMode` A {Boolean}, true to open the window in development mode.", "     Development mode loads the Atom source from the locally cloned", "     repository and also loads all the packages in ~/.atom/dev/packages", "   * `safeMode` A {Boolean}, true to open the window in safe mode. Safe", "     mode prevents all packages installed to ~/.atom/packages from loading."], "name": "AtomEnvironment.open", "params": ["params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 549, "start_line": 547}, "call_info": {"func_end_line": 863, "name": "open", "func_location": "open.(unnamed_function_17)", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 862, "func_start_line": 862}}, {"func_info": {"comment": [], "name": "Pane.getMessageForErrorCode", "params": ["errorCode"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 1259, "start_line": 1246}, "call_info": {"func_end_line": 837, "code": "              return saveFn(item, error => {\r\n                if (error instanceof SaveCancelledError) {\r\n                  resolve(false)\r\n                } else if (error) {\r\n                  saveDialog(\r\n                    'Save as',\r\n                    this.saveItemAs,\r\n                    `'${title}' could not be saved.\\nError: ${this.getMessageForErrorCode(error.code)}`\r\n                  )\r\n                } else {\r\n                  resolve(true)\r\n                }\r\n              })\r", "name": "getMessageForErrorCode", "func_location": "Pane.promptToSaveItem.(unnamed_function_14).saveDialog.(unnamed_function_15).(unnamed_function_16).(unnamed_function_17)", "args": ["error.code"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 832, "func_start_line": 825}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelPositionAfterBlocksForRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2366, "start_line": 2364}, "call_info": {"func_end_line": 1359, "code": "    this.decorationsToMeasure.cursors.forEach((cursor) => {\r\n      const {screenPosition, className, style} = cursor\r\n      const {row, column} = screenPosition\r\n\r\n      const pixelTop = this.pixelPositionAfterBlocksForRow(row)\r\n      const pixelLeft = this.pixelLeftForRowAndColumn(row, column)\r\n      let pixelWidth\r\n      if (cursor.columnWidth === 0) {\r\n        pixelWidth = this.getBaseCharacterWidth()\r\n      } else {\r\n        pixelWidth = this.pixelLeftForRowAndColumn(row, column + 1) - pixelLeft\r\n      }\r\n\r\n      const cursorPosition = {pixelTop, pixelLeft, pixelWidth, className, style}\r\n      this.decorationsToRender.cursors.push(cursorPosition)\r\n      if (cursor.isLastCursor) this.hiddenInputPosition = cursorPosition\r\n    })\r", "name": "pixelPositionAfterBlocksForRow", "func_location": "TextEditorComponent.updateCursorsToRender.(unnamed_function_18)", "args": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1347, "func_start_line": 1343}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelLeftForRowAndColumn", "params": ["row", "column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2377, "start_line": 2368}, "call_info": {"func_end_line": 1359, "code": "    this.decorationsToMeasure.cursors.forEach((cursor) => {\r\n      const {screenPosition, className, style} = cursor\r\n      const {row, column} = screenPosition\r\n\r\n      const pixelTop = this.pixelPositionAfterBlocksForRow(row)\r\n      const pixelLeft = this.pixelLeftForRowAndColumn(row, column)\r\n      let pixelWidth\r\n      if (cursor.columnWidth === 0) {\r\n        pixelWidth = this.getBaseCharacterWidth()\r\n      } else {\r\n        pixelWidth = this.pixelLeftForRowAndColumn(row, column + 1) - pixelLeft\r\n      }\r\n\r\n      const cursorPosition = {pixelTop, pixelLeft, pixelWidth, className, style}\r\n      this.decorationsToRender.cursors.push(cursorPosition)\r\n      if (cursor.isLastCursor) this.hiddenInputPosition = cursorPosition\r\n    })\r", "name": "pixelLeftForRowAndColumn", "func_location": "TextEditorComponent.updateCursorsToRender.(unnamed_function_18)", "args": ["row", "column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1348, "func_start_line": 1343}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getBaseCharacterWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2606, "start_line": 2604}, "call_info": {"func_end_line": 1359, "code": "    this.decorationsToMeasure.cursors.forEach((cursor) => {\r\n      const {screenPosition, className, style} = cursor\r\n      const {row, column} = screenPosition\r\n\r\n      const pixelTop = this.pixelPositionAfterBlocksForRow(row)\r\n      const pixelLeft = this.pixelLeftForRowAndColumn(row, column)\r\n      let pixelWidth\r\n      if (cursor.columnWidth === 0) {\r\n        pixelWidth = this.getBaseCharacterWidth()\r\n      } else {\r\n        pixelWidth = this.pixelLeftForRowAndColumn(row, column + 1) - pixelLeft\r\n      }\r\n\r\n      const cursorPosition = {pixelTop, pixelLeft, pixelWidth, className, style}\r\n      this.decorationsToRender.cursors.push(cursorPosition)\r\n      if (cursor.isLastCursor) this.hiddenInputPosition = cursorPosition\r\n    })\r", "name": "getBaseCharacterWidth", "func_location": "TextEditorComponent.updateCursorsToRender.(unnamed_function_18)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1351, "func_start_line": 1343}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelLeftForRowAndColumn", "params": ["row", "column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2377, "start_line": 2368}, "call_info": {"func_end_line": 1359, "code": "    this.decorationsToMeasure.cursors.forEach((cursor) => {\r\n      const {screenPosition, className, style} = cursor\r\n      const {row, column} = screenPosition\r\n\r\n      const pixelTop = this.pixelPositionAfterBlocksForRow(row)\r\n      const pixelLeft = this.pixelLeftForRowAndColumn(row, column)\r\n      let pixelWidth\r\n      if (cursor.columnWidth === 0) {\r\n        pixelWidth = this.getBaseCharacterWidth()\r\n      } else {\r\n        pixelWidth = this.pixelLeftForRowAndColumn(row, column + 1) - pixelLeft\r\n      }\r\n\r\n      const cursorPosition = {pixelTop, pixelLeft, pixelWidth, className, style}\r\n      this.decorationsToRender.cursors.push(cursorPosition)\r\n      if (cursor.isLastCursor) this.hiddenInputPosition = cursorPosition\r\n    })\r", "name": "pixelLeftForRowAndColumn", "func_location": "TextEditorComponent.updateCursorsToRender.(unnamed_function_18)", "args": ["row", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1353, "func_start_line": 1343}}, {"func_info": {"comment": ["\r\n  Section: Managing the Dev Tools\r\n  ", " Extended: Open the dev tools for the current window.", "", " Returns a {Promise} that resolves when the DevTools have been opened."], "name": "AtomEnvironment.openDevTools", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1057, "start_line": 1055}, "call_info": {"func_end_line": 944, "code": "    this.window.onerror = (message, url, line, column, originalError) => {\r\n      const mapping = mapSourcePosition({source: url, line, column})\r\n      line = mapping.line\r\n      column = mapping.column\r\n      if (url === '<embedded>') url = mapping.source\r\n\r\n      const eventObject = {message, url, line, column, originalError}\r\n\r\n      let openDevTools = true\r\n      eventObject.preventDefault = () => { openDevTools = false }\r\n\r\n      this.emitter.emit('will-throw-error', eventObject)\r\n\r\n      if (openDevTools) {\r\n        this.openDevTools().then(() =>\r\n          this.executeJavaScriptInDevTools('DevToolsAPI.showPanel(\"console\")')\r\n        )\r\n      }\r\n\r\n      this.emitter.emit('did-throw-error', {message, url, line, column, originalError})\r\n    }\r", "name": "openDevTools", "func_location": "AtomEnvironment.installUncaughtErrorHandler.(unnamed_function_18)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 938, "func_start_line": 924}}, {"func_info": {"comment": ["\r\n  Section: Accessing loaded packages\r\n  ", " Public: Get an {Array} of all the loaded {Package}s"], "name": "PackageManager.getLoadedPackages", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 325, "start_line": 323}, "call_info": {"func_end_line": 773, "code": "    await this.config.transactAsync(() =>\r\n      Promise.all(this.getLoadedPackages().map(pack => this.deactivatePackage(pack.name, true)))\r\n    )\r", "name": "getLoadedPackages", "func_location": "PackageManager.deactivatePackages.(unnamed_function_18)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 772, "func_start_line": 771}}, {"func_info": {"comment": [" Public: Returns the currently focused {AtomWindow} or undefined if none."], "name": "AtomApplication.focusedWindow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 750, "start_line": 748}, "call_info": {"func_end_line": 368, "code": "    const getLoadSettings = () => {\r\n      const window = this.focusedWindow()\r\n      return {devMode: window && window.devMode, safeMode: window && window.safeMode}\r\n    }\r", "name": "focusedWindow", "func_location": "AtomApplication.handleEvents.getLoadSettings.(unnamed_function_18)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 366, "func_start_line": 365}}, {"func_info": {"comment": [], "name": "TextEditorComponent.didShow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1465, "start_line": 1456}, "call_info": {"func_end_line": 1415, "code": "      this.intersectionObserver = new IntersectionObserver((entries) => {\r\n        const {intersectionRect} = entries[entries.length - 1]\r\n        if (intersectionRect.width > 0 || intersectionRect.height > 0) {\r\n          this.didShow()\r\n        } else {\r\n          this.didHide()\r\n        }\r\n      })\r", "name": "didShow", "func_location": "TextEditorComponent.didAttach.(unnamed_function_19)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1411, "func_start_line": 1408}}, {"func_info": {"comment": [], "name": "TextEditorComponent.didHide", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1472, "start_line": 1467}, "call_info": {"func_end_line": 1415, "code": "      this.intersectionObserver = new IntersectionObserver((entries) => {\r\n        const {intersectionRect} = entries[entries.length - 1]\r\n        if (intersectionRect.width > 0 || intersectionRect.height > 0) {\r\n          this.didShow()\r\n        } else {\r\n          this.didHide()\r\n        }\r\n      })\r", "name": "didHide", "func_location": "TextEditorComponent.didAttach.(unnamed_function_19)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1413, "func_start_line": 1408}}, {"func_info": {"comment": [" Deactivate the package with the given name"], "name": "PackageManager.deactivatePackage", "params": ["name", "suppressSerialization"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 797, "start_line": 779}, "call_info": {"func_end_line": 772, "code": "      Promise.all(this.getLoadedPackages().map(pack => this.deactivatePackage(pack.name, true)))\r", "name": "deactivatePackage", "func_location": "PackageManager.deactivatePackages.(unnamed_function_18).(unnamed_function_19)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 772, "func_start_line": 772}}, {"func_info": {"comment": [" Extended: Remove any language mode override that has been set for the", " given {TextBuffer}. This will assign to the buffer the best language", " mode available.", "", " * `buffer` The {TextBuffer}."], "name": "GrammarRegistry.autoAssignLanguageMode", "params": ["buffer"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 168, "start_line": 158}, "call_info": {"func_end_line": 47, "code": "      this.grammarScoresByBuffer.forEach((score, buffer) => {\r\n        if (!this.languageOverridesByBufferId.has(buffer.id)) {\r\n          this.autoAssignLanguageMode(buffer)\r\n        }\r\n      })\r", "name": "autoAssignLanguageMode", "func_location": "GrammarRegistry.clear.(unnamed_function_1).(unnamed_function_2)", "args": ["buffer"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 45, "func_start_line": 43}}, {"func_info": {"comment": [], "name": "AutoUpdateManager.setState", "params": ["state", "errorMessage"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "end_line": 108, "start_line": 103}, "call_info": {"func_end_line": 48, "code": "    autoUpdater.on('checking-for-update', () => {\r\n      this.setState(CheckingState)\r\n      this.emitWindowEvent('checking-for-update')\r\n    })\r", "name": "setState", "func_location": "AutoUpdateManager.initialize.(unnamed_function_2)", "args": ["CheckingState"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "line": 46, "func_start_line": 45}}, {"func_info": {"comment": [], "name": "AutoUpdateManager.emitWindowEvent", "params": ["eventName", "payload"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "end_line": 101, "start_line": 97}, "call_info": {"func_end_line": 48, "code": "    autoUpdater.on('checking-for-update', () => {\r\n      this.setState(CheckingState)\r\n      this.emitWindowEvent('checking-for-update')\r\n    })\r", "name": "emitWindowEvent", "func_location": "AutoUpdateManager.initialize.(unnamed_function_2)", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "line": 47, "func_start_line": 45}}, {"func_info": {"comment": [], "name": "TitleBar.updateWindowSheetOffset", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/title-bar.js", "end_line": 46, "start_line": 44}, "call_info": {"func_end_line": 18, "code": "    this.themes.onDidChangeActiveThemes(() => this.updateWindowSheetOffset())\r", "name": "updateWindowSheetOffset", "func_location": "TitleBar.constructor.(unnamed_function_2)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/title-bar.js", "line": 18, "func_start_line": 18}}, {"func_info": {"comment": [" Essential: Sets the value for a configuration setting.", "", " This value is stored in Atom's internal configuration file.", "", " ### Examples", "", " You might want to change the themes programmatically:", "", " ```coffee", " atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])", " ```", "", " You can also set scoped settings. For example, you might want change the", " `editor.tabLength` only for ruby files.", "", " ```coffee", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4", " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4", "", " # Set ruby to 2", " atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true", "", " # Notice it's only set to 2 in the case of ruby", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4", " ```", "", " * `keyPath` The {String} name of the key.", " * `value` The value of the setting. Passing `undefined` will revert the", "   setting to the default value.", " * `options` (optional) {Object}", "   * `scopeSelector` (optional) {String}. eg. '.source.ruby'", "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)", "     for more information.", "   * `source` (optional) {String} The name of a file with which the setting", "     is associated. Defaults to the user's config file.", "", " Returns a {Boolean}", " * `true` if the value was set.", " * `false` if the value was not able to be coerced to the type specified in the setting's schema."], "name": "Config.set", "params": ["args"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 722, "start_line": 687}, "call_info": {"func_end_line": 691, "code": "      this.pendingOperations.push(() => this.set(keyPath, value, options))\r", "name": "set", "func_location": "Config.set.(unnamed_function_2)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 691, "func_start_line": 691}}, {"func_info": {"comment": [], "name": "BufferedProcess.isExplorerCommand", "params": ["command"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "end_line": 220, "start_line": 212}, "call_info": {"func_end_line": 93, "code": "        .map((arg) => {\r\n          if (this.isExplorerCommand(command) && /^\\/[a-zA-Z]+,.*$/.test(arg)) {\r\n            // Don't wrap /root,C:\\folder style arguments to explorer calls in\r\n            // quotes since they will not be interpreted correctly if they are\r\n            return arg\r\n          } else {\r\n            // Escape double quotes by putting a backslash in front of them\r\n            return `\\\"${arg.toString().replace(/\"/g, '\\\\\"')}\\\"`\r\n          }\r\n        })\r", "name": "isExplorerCommand", "func_location": "BufferedProcess.spawnWithEscapedWindowsArgs.(unnamed_function_2)", "args": ["command"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "line": 85, "func_start_line": 84}}, {"func_info": {"comment": [], "name": "HistoryProject.constructor", "params": ["paths", "lastOpened"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "end_line": 121, "start_line": 118}, "call_info": {"func_end_line": 26, "code": "    return this.projects.map(p => new HistoryProject(p.paths, p.lastOpened))\r", "name": "constructor", "func_location": "HistoryManager.getProjects.(unnamed_function_2)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "line": 26, "func_start_line": 26}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 37, "code": "    this.addEventListener('blur', (event) => this.getComponent().didBlur(event))\r", "name": "getComponent", "func_location": "TextEditorElement.createdCallback.(unnamed_function_2)", "args": [{"type": "string"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 37, "func_start_line": 37}}, {"func_info": {"comment": [], "name": "Package.loadKeymaps", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 451, "start_line": 438}, "call_info": {"func_end_line": 142, "code": "    this.measure('loadTime', () => {\r\n      try {\r\n        ModuleCache.add(this.path, this.metadata)\r\n\r\n        this.loadKeymaps()\r\n        this.loadMenus()\r\n        this.loadStylesheets()\r\n        this.registerDeserializerMethods()\r\n        this.activateCoreStartupServices()\r\n        this.registerURIHandler()\r\n        this.registerTranspilerConfig()\r\n        this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n        this.settingsPromise = this.loadSettings()\r\n        if (this.shouldRequireMainModuleOnLoad() && (this.mainModule == null)) {\r\n          this.requireMainModule()\r\n        }\r\n      } catch (error) {\r\n        this.handleError(`Failed to load the ${this.name} package`, error)\r\n      }\r\n    })\r", "name": "loadKeymaps", "func_location": "Package.load.(unnamed_function_2)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 127, "func_start_line": 123}}, {"func_info": {"comment": [], "name": "Package.loadMenus", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 466, "start_line": 453}, "call_info": {"func_end_line": 142, "code": "    this.measure('loadTime', () => {\r\n      try {\r\n        ModuleCache.add(this.path, this.metadata)\r\n\r\n        this.loadKeymaps()\r\n        this.loadMenus()\r\n        this.loadStylesheets()\r\n        this.registerDeserializerMethods()\r\n        this.activateCoreStartupServices()\r\n        this.registerURIHandler()\r\n        this.registerTranspilerConfig()\r\n        this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n        this.settingsPromise = this.loadSettings()\r\n        if (this.shouldRequireMainModuleOnLoad() && (this.mainModule == null)) {\r\n          this.requireMainModule()\r\n        }\r\n      } catch (error) {\r\n        this.handleError(`Failed to load the ${this.name} package`, error)\r\n      }\r\n    })\r", "name": "loadMenus", "func_location": "Package.load.(unnamed_function_2)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 128, "func_start_line": 123}}, {"func_info": {"comment": [], "name": "Package.loadStylesheets", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 490, "start_line": 486}, "call_info": {"func_end_line": 142, "code": "    this.measure('loadTime', () => {\r\n      try {\r\n        ModuleCache.add(this.path, this.metadata)\r\n\r\n        this.loadKeymaps()\r\n        this.loadMenus()\r\n        this.loadStylesheets()\r\n        this.registerDeserializerMethods()\r\n        this.activateCoreStartupServices()\r\n        this.registerURIHandler()\r\n        this.registerTranspilerConfig()\r\n        this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n        this.settingsPromise = this.loadSettings()\r\n        if (this.shouldRequireMainModuleOnLoad() && (this.mainModule == null)) {\r\n          this.requireMainModule()\r\n        }\r\n      } catch (error) {\r\n        this.handleError(`Failed to load the ${this.name} package`, error)\r\n      }\r\n    })\r", "name": "loadStylesheets", "func_location": "Package.load.(unnamed_function_2)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 129, "func_start_line": 123}}, {"func_info": {"comment": [], "name": "Package.registerDeserializerMethods", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 507, "start_line": 492}, "call_info": {"func_end_line": 142, "code": "    this.measure('loadTime', () => {\r\n      try {\r\n        ModuleCache.add(this.path, this.metadata)\r\n\r\n        this.loadKeymaps()\r\n        this.loadMenus()\r\n        this.loadStylesheets()\r\n        this.registerDeserializerMethods()\r\n        this.activateCoreStartupServices()\r\n        this.registerURIHandler()\r\n        this.registerTranspilerConfig()\r\n        this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n        this.settingsPromise = this.loadSettings()\r\n        if (this.shouldRequireMainModuleOnLoad() && (this.mainModule == null)) {\r\n          this.requireMainModule()\r\n        }\r\n      } catch (error) {\r\n        this.handleError(`Failed to load the ${this.name} package`, error)\r\n      }\r\n    })\r", "name": "registerDeserializerMethods", "func_location": "Package.load.(unnamed_function_2)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 130, "func_start_line": 123}}, {"func_info": {"comment": [], "name": "Package.activateCoreStartupServices", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 524, "start_line": 509}, "call_info": {"func_end_line": 142, "code": "    this.measure('loadTime', () => {\r\n      try {\r\n        ModuleCache.add(this.path, this.metadata)\r\n\r\n        this.loadKeymaps()\r\n        this.loadMenus()\r\n        this.loadStylesheets()\r\n        this.registerDeserializerMethods()\r\n        this.activateCoreStartupServices()\r\n        this.registerURIHandler()\r\n        this.registerTranspilerConfig()\r\n        this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n        this.settingsPromise = this.loadSettings()\r\n        if (this.shouldRequireMainModuleOnLoad() && (this.mainModule == null)) {\r\n          this.requireMainModule()\r\n        }\r\n      } catch (error) {\r\n        this.handleError(`Failed to load the ${this.name} package`, error)\r\n      }\r\n    })\r", "name": "activateCoreStartupServices", "func_location": "Package.load.(unnamed_function_2)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 131, "func_start_line": 123}}, {"func_info": {"comment": [], "name": "Package.registerURIHandler", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 413, "start_line": 405}, "call_info": {"func_end_line": 142, "code": "    this.measure('loadTime', () => {\r\n      try {\r\n        ModuleCache.add(this.path, this.metadata)\r\n\r\n        this.loadKeymaps()\r\n        this.loadMenus()\r\n        this.loadStylesheets()\r\n        this.registerDeserializerMethods()\r\n        this.activateCoreStartupServices()\r\n        this.registerURIHandler()\r\n        this.registerTranspilerConfig()\r\n        this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n        this.settingsPromise = this.loadSettings()\r\n        if (this.shouldRequireMainModuleOnLoad() && (this.mainModule == null)) {\r\n          this.requireMainModule()\r\n        }\r\n      } catch (error) {\r\n        this.handleError(`Failed to load the ${this.name} package`, error)\r\n      }\r\n    })\r", "name": "registerURIHandler", "func_location": "Package.load.(unnamed_function_2)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 132, "func_start_line": 123}}, {"func_info": {"comment": [], "name": "Package.registerTranspilerConfig", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 430, "start_line": 426}, "call_info": {"func_end_line": 142, "code": "    this.measure('loadTime', () => {\r\n      try {\r\n        ModuleCache.add(this.path, this.metadata)\r\n\r\n        this.loadKeymaps()\r\n        this.loadMenus()\r\n        this.loadStylesheets()\r\n        this.registerDeserializerMethods()\r\n        this.activateCoreStartupServices()\r\n        this.registerURIHandler()\r\n        this.registerTranspilerConfig()\r\n        this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n        this.settingsPromise = this.loadSettings()\r\n        if (this.shouldRequireMainModuleOnLoad() && (this.mainModule == null)) {\r\n          this.requireMainModule()\r\n        }\r\n      } catch (error) {\r\n        this.handleError(`Failed to load the ${this.name} package`, error)\r\n      }\r\n    })\r", "name": "registerTranspilerConfig", "func_location": "Package.load.(unnamed_function_2)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 133, "func_start_line": 123}}, {"func_info": {"comment": [], "name": "Package.registerConfigSchemaFromMetadata", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 246, "start_line": 238}, "call_info": {"func_end_line": 142, "code": "    this.measure('loadTime', () => {\r\n      try {\r\n        ModuleCache.add(this.path, this.metadata)\r\n\r\n        this.loadKeymaps()\r\n        this.loadMenus()\r\n        this.loadStylesheets()\r\n        this.registerDeserializerMethods()\r\n        this.activateCoreStartupServices()\r\n        this.registerURIHandler()\r\n        this.registerTranspilerConfig()\r\n        this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n        this.settingsPromise = this.loadSettings()\r\n        if (this.shouldRequireMainModuleOnLoad() && (this.mainModule == null)) {\r\n          this.requireMainModule()\r\n        }\r\n      } catch (error) {\r\n        this.handleError(`Failed to load the ${this.name} package`, error)\r\n      }\r\n    })\r", "name": "registerConfigSchemaFromMetadata", "func_location": "Package.load.(unnamed_function_2)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 134, "func_start_line": 123}}, {"func_info": {"comment": [], "name": "Package.loadSettings", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 671, "start_line": 634}, "call_info": {"func_end_line": 142, "code": "    this.measure('loadTime', () => {\r\n      try {\r\n        ModuleCache.add(this.path, this.metadata)\r\n\r\n        this.loadKeymaps()\r\n        this.loadMenus()\r\n        this.loadStylesheets()\r\n        this.registerDeserializerMethods()\r\n        this.activateCoreStartupServices()\r\n        this.registerURIHandler()\r\n        this.registerTranspilerConfig()\r\n        this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n        this.settingsPromise = this.loadSettings()\r\n        if (this.shouldRequireMainModuleOnLoad() && (this.mainModule == null)) {\r\n          this.requireMainModule()\r\n        }\r\n      } catch (error) {\r\n        this.handleError(`Failed to load the ${this.name} package`, error)\r\n      }\r\n    })\r", "name": "loadSettings", "func_location": "Package.load.(unnamed_function_2)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 135, "func_start_line": 123}}, {"func_info": {"comment": [], "name": "Package.shouldRequireMainModuleOnLoad", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 158, "start_line": 150}, "call_info": {"func_end_line": 142, "code": "    this.measure('loadTime', () => {\r\n      try {\r\n        ModuleCache.add(this.path, this.metadata)\r\n\r\n        this.loadKeymaps()\r\n        this.loadMenus()\r\n        this.loadStylesheets()\r\n        this.registerDeserializerMethods()\r\n        this.activateCoreStartupServices()\r\n        this.registerURIHandler()\r\n        this.registerTranspilerConfig()\r\n        this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n        this.settingsPromise = this.loadSettings()\r\n        if (this.shouldRequireMainModuleOnLoad() && (this.mainModule == null)) {\r\n          this.requireMainModule()\r\n        }\r\n      } catch (error) {\r\n        this.handleError(`Failed to load the ${this.name} package`, error)\r\n      }\r\n    })\r", "name": "shouldRequireMainModuleOnLoad", "func_location": "Package.load.(unnamed_function_2)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 136, "func_start_line": 123}}, {"func_info": {"comment": [], "name": "Package.requireMainModule", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 784, "start_line": 755}, "call_info": {"func_end_line": 142, "code": "    this.measure('loadTime', () => {\r\n      try {\r\n        ModuleCache.add(this.path, this.metadata)\r\n\r\n        this.loadKeymaps()\r\n        this.loadMenus()\r\n        this.loadStylesheets()\r\n        this.registerDeserializerMethods()\r\n        this.activateCoreStartupServices()\r\n        this.registerURIHandler()\r\n        this.registerTranspilerConfig()\r\n        this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n        this.settingsPromise = this.loadSettings()\r\n        if (this.shouldRequireMainModuleOnLoad() && (this.mainModule == null)) {\r\n          this.requireMainModule()\r\n        }\r\n      } catch (error) {\r\n        this.handleError(`Failed to load the ${this.name} package`, error)\r\n      }\r\n    })\r", "name": "requireMainModule", "func_location": "Package.load.(unnamed_function_2)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 137, "func_start_line": 123}}, {"func_info": {"comment": [], "name": "Package.handleError", "params": ["message", "error"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 1105, "start_line": 1085}, "call_info": {"func_end_line": 142, "code": "    this.measure('loadTime', () => {\r\n      try {\r\n        ModuleCache.add(this.path, this.metadata)\r\n\r\n        this.loadKeymaps()\r\n        this.loadMenus()\r\n        this.loadStylesheets()\r\n        this.registerDeserializerMethods()\r\n        this.activateCoreStartupServices()\r\n        this.registerURIHandler()\r\n        this.registerTranspilerConfig()\r\n        this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n        this.settingsPromise = this.loadSettings()\r\n        if (this.shouldRequireMainModuleOnLoad() && (this.mainModule == null)) {\r\n          this.requireMainModule()\r\n        }\r\n      } catch (error) {\r\n        this.handleError(`Failed to load the ${this.name} package`, error)\r\n      }\r\n    })\r", "name": "handleError", "func_location": "Package.load.(unnamed_function_2)", "args": [null, "error"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 140, "func_start_line": 123}}, {"func_info": {"comment": [" Private: Parse a selector into parts.", "          If already parsed, returns the selector unmodified.", "", " * `selector` a {String|Array<String>} specifying what to match", " Returns selector parts, an {Array<String>}."], "name": "parse", "params": ["selector"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selectors.js", "end_line": 14, "start_line": 10}, "call_info": {"func_end_line": 28, "name": "parse", "func_location": "matcherForSelector.(unnamed_function_2)", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selectors.js", "line": 27, "func_start_line": 27}}, {"func_info": {"comment": [], "name": "AutoUpdater.installUpdate", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-updater-win32.js", "end_line": 39, "start_line": 37}, "call_info": {"func_end_line": 84, "name": "installUpdate", "func_location": "AutoUpdater.checkForUpdates.(unnamed_function_2)", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-updater-win32.js", "line": 68, "func_start_line": 55}}, {"func_info": {"comment": [" Remove a `TextEditor`.", "", " * `editor` The editor to remove.", "", " Returns a {Boolean} indicating whether the editor was successfully removed."], "name": "TextEditorRegistry.remove", "params": ["editor"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js", "end_line": 126, "start_line": 122}, "call_info": {"func_end_line": 98, "code": "    return new Disposable(() => this.remove(editor))\r", "name": "remove", "func_location": "TextEditorRegistry.add.(unnamed_function_2)", "args": ["editor"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js", "line": 98, "func_start_line": 98}}, {"func_info": {"comment": [" Essential: Destroy this marker decoration.", "", " You can also destroy the marker if you own it, which will destroy this", " decoration."], "name": "Decoration.destroy", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration.js", "end_line": 96, "start_line": 88}, "call_info": {"func_end_line": 81, "code": "    this.markerDestroyDisposable = this.marker.onDidDestroy(() => this.destroy())\r", "name": "destroy", "func_location": "Decoration.constructor.(unnamed_function_2)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration.js", "line": 81, "func_start_line": 81}}, {"func_info": {"comment": [], "name": "ApplicationMenu.setActiveTemplate", "params": ["template"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "end_line": 40, "start_line": 32}, "call_info": {"func_end_line": 50, "code": "    const focusHandler = () => {\r\n      this.lastFocusedWindow = window\r\n      const template = this.windowTemplates.get(window)\r\n      if (template) this.setActiveTemplate(template)\r\n    }\r", "name": "setActiveTemplate", "func_location": "ApplicationMenu.addWindow.focusHandler.(unnamed_function_2)", "args": ["template"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "line": 49, "func_start_line": 46}}, {"func_info": {"comment": [" Public: Set the paths of the project's directories.", "", " * `projectPaths` {Array} of {String} paths.", " * `options` An optional {Object} that may contain the following keys:", "   * `mustExist` If `true`, throw an Error if any `projectPaths` do not exist. Any remaining `projectPaths` that", "     do exist will still be added to the project. Default: `false`.", "   * `exact` If `true`, only add a `projectPath` if it names an existing directory. If `false` and any `projectPath`", "     is a file or does not exist, its parent directory will be added instead. Default: `false`."], "name": "Project.setPaths", "params": ["projectPaths", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 371, "start_line": 339}, "call_info": {"func_end_line": 614, "code": "      provider => {\r\n        this.repositoryProviders.unshift(provider)\r\n        if (this.repositories.includes(null)) { this.setPaths(this.getPaths()) }\r\n        return new Disposable(() => {\r\n          return this.repositoryProviders.splice(this.repositoryProviders.indexOf(provider), 1)\r\n        })\r\n      })\r", "name": "setPaths", "func_location": "Project.consumeServices.(unnamed_function_20)", "args": [{"type": "object"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 610, "func_start_line": 608}}, {"func_info": {"comment": ["\r\n  Section: Managing Paths\r\n  ", " Public: Get an {Array} of {String}s containing the paths of the project's", " directories."], "name": "Project.getPaths", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 329, "start_line": 327}, "call_info": {"func_end_line": 614, "code": "      provider => {\r\n        this.repositoryProviders.unshift(provider)\r\n        if (this.repositories.includes(null)) { this.setPaths(this.getPaths()) }\r\n        return new Disposable(() => {\r\n          return this.repositoryProviders.splice(this.repositoryProviders.indexOf(provider), 1)\r\n        })\r\n      })\r", "name": "getPaths", "func_location": "Project.consumeServices.(unnamed_function_20)", "args": [{"type": "object"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 610, "func_start_line": 608}}, {"func_info": {"comment": [" Extended: Execute code in dev tools."], "name": "AtomEnvironment.executeJavaScriptInDevTools", "params": ["code"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1070, "start_line": 1068}, "call_info": {"func_end_line": 940, "code": "        this.openDevTools().then(() =>\r\n          this.executeJavaScriptInDevTools('DevToolsAPI.showPanel(\"console\")')\r\n        )\r", "name": "executeJavaScriptInDevTools", "func_location": "AtomEnvironment.installUncaughtErrorHandler.(unnamed_function_18).(unnamed_function_20)", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 939, "func_start_line": 938}}, {"func_info": {"comment": [" Public: Opens a single path, in an existing window if possible.", "", " options -", "   :pathToOpen - The file path to open", "   :pidToKillWhenClosed - The integer of the pid to kill", "   :newWindow - Boolean of whether this should be opened in a new window.", "   :devMode - Boolean to control the opened window's dev mode.", "   :safeMode - Boolean to control the opened window's safe mode.", "   :profileStartup - Boolean to control creating a profile of the startup time.", "   :window - {AtomWindow} to open file paths in.", "   :addToLastWindow - Boolean of whether this should be opened in last focused window."], "name": "AtomApplication.openPath", "params": [["initialPaths", "pathToOpen", "pidToKillWhenClosed", "newWindow", "devMode", "safeMode", "profileStartup", "window", "clearWindowState", "addToLastWindow", "env"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 812, "start_line": 786}, "call_info": {"func_end_line": 371, "code": "    this.on('application:new-window', () => this.openPath(getLoadSettings()))\r", "name": "openPath", "func_location": "AtomApplication.handleEvents.(unnamed_function_20)", "args": [{"type": "string"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 371, "func_start_line": 371}}, {"func_info": {"comment": [], "name": "Pane.handleSaveError", "params": ["error", "item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 1244, "start_line": 1221}, "call_info": {"func_end_line": 897, "code": "          .catch(error => {\r\n            if (nextAction) {\r\n              nextAction(error)\r\n            } else {\r\n              this.handleSaveError(error, item)\r\n            }\r\n          })\r", "name": "handleSaveError", "func_location": "Pane.saveItem.(unnamed_function_20)", "args": ["error", "item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 895, "func_start_line": 891}}, {"func_info": {"comment": [" Extended: Prompt the user to select one or more folders.", "", " * `callback` A {Function} to call once the user has confirmed the selection.", "   * `paths` An {Array} of {String} paths that the user selected, or `null`", "     if the user dismissed the dialog."], "name": "AtomEnvironment.pickFolder", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 558, "start_line": 556}, "call_info": {"func_end_line": 1117, "name": "pickFolder", "func_location": "AtomEnvironment.addProjectFolder.(unnamed_function_21)", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 1114, "func_start_line": 1113}}, {"func_info": {"comment": [" Public: Returns the currently focused {AtomWindow} or undefined if none."], "name": "AtomApplication.focusedWindow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 750, "start_line": 748}, "call_info": {"func_end_line": 372, "code": "    this.on('application:new-file', () => (this.focusedWindow() || this).openPath())\r", "name": "focusedWindow", "func_location": "AtomApplication.handleEvents.(unnamed_function_21)", "args": [{"type": "string"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 372, "func_start_line": 372}}, {"func_info": {"comment": [], "name": "AtomEnvironment.addToProject", "params": ["projectPaths"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1127, "start_line": 1120}, "call_info": {"func_end_line": 1116, "code": "      this.pickFolder((selectedPaths) => {\r\n        this.addToProject(selectedPaths || []).then(resolve)\r\n      })\r", "name": "addToProject", "func_location": "AtomEnvironment.addProjectFolder.(unnamed_function_21).(unnamed_function_22)", "args": ["resolve"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 1115, "func_start_line": 1114}}, {"func_info": {"comment": [" Opens a native dialog to prompt the user for a path.", "", " Once paths are selected, they're opened in a new or existing {AtomWindow}s.", "", " options -", "   :type - A String which specifies the type of the dialog, could be 'file',", "           'folder' or 'all'. The 'all' is only available on macOS.", "   :devMode - A Boolean which controls whether any newly opened windows", "              should be in dev mode or not.", "   :safeMode - A Boolean which controls whether any newly opened windows", "               should be in safe mode or not.", "   :window - An {AtomWindow} to use for opening a selected file path.", "   :path - An optional String which controls the default path to which the", "           file dialog opens."], "name": "AtomApplication.promptForPathToOpen", "params": ["type", ["devMode", "safeMode", "window"], "path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1317, "start_line": 1309}, "call_info": {"func_end_line": 373, "code": "    this.on('application:open-dev', () => this.promptForPathToOpen('all', {devMode: true}))\r", "name": "promptForPathToOpen", "func_location": "AtomApplication.handleEvents.(unnamed_function_22)", "args": [{"type": "string"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 373, "func_start_line": 373}}, {"func_info": {"comment": [], "name": "promisify", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 1268, "start_line": 1262}, "call_info": {"func_end_line": 951, "code": "    this.applicationDelegate.showSaveDialog(saveOptions, newItemPath => {\r\n      if (newItemPath) {\r\n        promisify(() => item.saveAs(newItemPath))\r\n          .then(() => {\r\n            if (nextAction) {\r\n              resolveSaveDialogPromise(nextAction())\r\n            } else {\r\n              resolveSaveDialogPromise()\r\n            }\r\n          })\r\n          .catch(error => {\r\n            if (nextAction) {\r\n              resolveSaveDialogPromise(nextAction(error))\r\n            } else {\r\n              this.handleSaveError(error, item)\r\n              resolveSaveDialogPromise()\r\n            }\r\n          })\r\n      } else if (nextAction) {\r\n        resolveSaveDialogPromise(nextAction(new SaveCancelledError('Save Cancelled')))\r\n      } else {\r\n        resolveSaveDialogPromise()\r\n      }\r\n    })\r", "name": "promisify", "func_location": "Pane.saveItemAs.(unnamed_function_22)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 930, "func_start_line": 928}}, {"func_info": {"comment": [" Opens a native dialog to prompt the user for a path.", "", " Once paths are selected, they're opened in a new or existing {AtomWindow}s.", "", " options -", "   :type - A String which specifies the type of the dialog, could be 'file',", "           'folder' or 'all'. The 'all' is only available on macOS.", "   :devMode - A Boolean which controls whether any newly opened windows", "              should be in dev mode or not.", "   :safeMode - A Boolean which controls whether any newly opened windows", "               should be in safe mode or not.", "   :window - An {AtomWindow} to use for opening a selected file path.", "   :path - An optional String which controls the default path to which the", "           file dialog opens."], "name": "AtomApplication.promptForPathToOpen", "params": ["type", ["devMode", "safeMode", "window"], "path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1317, "start_line": 1309}, "call_info": {"func_end_line": 374, "code": "    this.on('application:open-safe', () => this.promptForPathToOpen('all', {safeMode: true}))\r", "name": "promptForPathToOpen", "func_location": "AtomApplication.handleEvents.(unnamed_function_23)", "args": [{"type": "string"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 374, "func_start_line": 374}}, {"func_info": {"comment": [" Public: Returns the currently focused {AtomWindow} or undefined if none."], "name": "AtomApplication.focusedWindow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 750, "start_line": 748}, "call_info": {"func_end_line": 378, "code": "    this.on('application:inspect', ({x, y, atomWindow}) => {\r\n      if (!atomWindow) atomWindow = this.focusedWindow()\r\n      if (atomWindow) atomWindow.browserWindow.inspectElement(x, y)\r\n    })\r", "name": "focusedWindow", "func_location": "AtomApplication.handleEvents.(unnamed_function_24)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 376, "func_start_line": 375}}, {"func_info": {"comment": [" Private: Attach another {Function} to be called with each batch of filesystem events. See {watchPath} for the", " spec of the callback's argument.", "", " * `callback` {Function} to be called with each batch of filesystem events.", "", " Returns a {Disposable} that will stop the underlying watcher when all callbacks mapped to it have been disposed."], "name": "PathWatcher.onDidChange", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js", "end_line": 443, "start_line": 425}, "call_info": {"func_end_line": 435, "comment": [" Attach to a new native listener and retry"], "code": "      this.nativeWatcherRegistry.attach(this).then(() => {\r\n        this.onDidChange(callback)\r\n      })\r", "name": "onDidChange", "func_location": "PathWatcher.onDidChange.(unnamed_function_25)", "args": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js", "line": 434, "func_start_line": 433}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getHiddenInput", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2962, "start_line": 2960}, "call_info": {"func_end_line": 1726, "code": "      process.nextTick(() => {\r\n        // Disabling the hidden input makes it lose focus as well, so we have to\r\n        // re-enable and re-focus it.\r\n        this.getHiddenInput().disabled = false\r\n        this.getHiddenInput().focus()\r\n      })\r", "name": "getHiddenInput", "func_location": "TextEditorComponent.didCompositionStart.(unnamed_function_25)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1724, "func_start_line": 1721}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getHiddenInput", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2962, "start_line": 2960}, "call_info": {"func_end_line": 1726, "code": "      process.nextTick(() => {\r\n        // Disabling the hidden input makes it lose focus as well, so we have to\r\n        // re-enable and re-focus it.\r\n        this.getHiddenInput().disabled = false\r\n        this.getHiddenInput().focus()\r\n      })\r", "name": "getHiddenInput", "func_location": "TextEditorComponent.didCompositionStart.(unnamed_function_25)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1725, "func_start_line": 1721}}, {"func_info": {"comment": [], "name": "Pane.handleSaveError", "params": ["error", "item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 1244, "start_line": 1221}, "call_info": {"func_end_line": 945, "code": "          .catch(error => {\r\n            if (nextAction) {\r\n              resolveSaveDialogPromise(nextAction(error))\r\n            } else {\r\n              this.handleSaveError(error, item)\r\n              resolveSaveDialogPromise()\r\n            }\r\n          })\r", "name": "handleSaveError", "func_location": "Pane.saveItemAs.(unnamed_function_22).(unnamed_function_25)", "args": ["error", "item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 942, "func_start_line": 938}}, {"func_info": {"comment": [], "name": "TextEditorComponent.autoscrollOnMouseDrag", "params": [["clientX", "clientY"], "verticalOnly"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1959, "start_line": 1922}, "call_info": {"func_end_line": 1819, "code": "      didDrag: (event) => {\r\n        this.autoscrollOnMouseDrag(event)\r\n        const screenPosition = this.screenPositionForMouseEvent(event)\r\n        model.selectToScreenPosition(screenPosition, {suppressSelectionMerge: true, autoscroll: false})\r\n        this.updateSync()\r\n      },\r", "name": "autoscrollOnMouseDrag", "func_location": "didDrag.(unnamed_function_26)", "args": ["event"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1815, "func_start_line": 1814}}, {"func_info": {"comment": [], "name": "TextEditorComponent.screenPositionForMouseEvent", "params": ["event"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1963, "start_line": 1961}, "call_info": {"func_end_line": 1819, "code": "      didDrag: (event) => {\r\n        this.autoscrollOnMouseDrag(event)\r\n        const screenPosition = this.screenPositionForMouseEvent(event)\r\n        model.selectToScreenPosition(screenPosition, {suppressSelectionMerge: true, autoscroll: false})\r\n        this.updateSync()\r\n      },\r", "name": "screenPositionForMouseEvent", "func_location": "didDrag.(unnamed_function_26)", "args": ["event"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1816, "func_start_line": 1814}}, {"func_info": {"comment": [], "name": "TextEditorComponent.updateSync", "params": ["useScheduler"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 289, "start_line": 221}, "call_info": {"func_end_line": 1819, "code": "      didDrag: (event) => {\r\n        this.autoscrollOnMouseDrag(event)\r\n        const screenPosition = this.screenPositionForMouseEvent(event)\r\n        model.selectToScreenPosition(screenPosition, {suppressSelectionMerge: true, autoscroll: false})\r\n        this.updateSync()\r\n      },\r", "name": "updateSync", "func_location": "didDrag.(unnamed_function_26)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1818, "func_start_line": 1814}}, {"func_info": {"comment": [], "name": "SettingsFile.load", "params": ["path", "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 1117, "start_line": 1109}, "call_info": {"func_end_line": 649, "name": "load", "func_location": "Package.loadSettings.loadSettingsFile.(unnamed_function_26)", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 638, "func_start_line": 637}}, {"func_info": {"comment": [], "name": "TextEditorComponent.updateSync", "params": ["useScheduler"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 289, "start_line": 221}, "call_info": {"func_end_line": 1824, "code": "      didStopDragging: () => {\r\n        model.finalizeSelections()\r\n        model.mergeIntersectingSelections()\r\n        this.updateSync()\r\n      }\r", "name": "updateSync", "func_location": "didStopDragging.(unnamed_function_27)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1823, "func_start_line": 1820}}, {"func_info": {"comment": ["\r\n  Section: Managing The Atom Window\r\n  ", " Essential: Open a new Atom window using the given options.", "", " Calling this method without an options parameter will open a prompt to pick", " a file/folder to open in the new window.", "", " * `params` An {Object} with the following keys:", "   * `pathsToOpen`  An {Array} of {String} paths to open.", "   * `newWindow` A {Boolean}, true to always open a new window instead of", "     reusing existing windows depending on the paths to open.", "   * `devMode` A {Boolean}, true to open the window in development mode.", "     Development mode loads the Atom source from the locally cloned", "     repository and also loads all the packages in ~/.atom/dev/packages", "   * `safeMode` A {Boolean}, true to open the window in safe mode. Safe", "     mode prevents all packages installed to ~/.atom/packages from loading."], "name": "AtomEnvironment.open", "params": ["params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 549, "start_line": 547}, "call_info": {"func_end_line": 1177, "name": "open", "func_location": "AtomEnvironment.attemptRestoreProjectStateForPaths.(unnamed_function_27)", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 1164, "func_start_line": 1162}}, {"func_info": {"comment": ["\r\n  Section: Atom Details\r\n  ", " Public: Returns a {Boolean} that is `true` if the current window is in development mode."], "name": "AtomEnvironment.inDevMode", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 459, "start_line": 456}, "call_info": {"func_end_line": 1177, "code": "      }, response => {\r\n        if (response === 0) {\r\n          this.open({\r\n            pathsToOpen: projectPaths.concat(filesToOpen),\r\n            newWindow: true,\r\n            devMode: this.inDevMode(),\r\n            safeMode: this.inSafeMode()\r\n          })\r\n          resolveDiscardStatePromise(Promise.resolve(null))\r\n        } else if (response === 1) {\r\n          for (let selectedPath of projectPaths) {\r\n            this.project.addPath(selectedPath)\r\n          }\r\n          resolveDiscardStatePromise(Promise.all(filesToOpen.map(file => this.workspace.open(file))))\r\n        }\r\n      })\r", "name": "inDevMode", "func_location": "AtomEnvironment.attemptRestoreProjectStateForPaths.(unnamed_function_27)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 1167, "func_start_line": 1162}}, {"func_info": {"comment": [" Public: Returns a {Boolean} that is `true` if the current window is in safe mode."], "name": "AtomEnvironment.inSafeMode", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 465, "start_line": 462}, "call_info": {"func_end_line": 1177, "code": "      }, response => {\r\n        if (response === 0) {\r\n          this.open({\r\n            pathsToOpen: projectPaths.concat(filesToOpen),\r\n            newWindow: true,\r\n            devMode: this.inDevMode(),\r\n            safeMode: this.inSafeMode()\r\n          })\r\n          resolveDiscardStatePromise(Promise.resolve(null))\r\n        } else if (response === 1) {\r\n          for (let selectedPath of projectPaths) {\r\n            this.project.addPath(selectedPath)\r\n          }\r\n          resolveDiscardStatePromise(Promise.all(filesToOpen.map(file => this.workspace.open(file))))\r\n        }\r\n      })\r", "name": "inSafeMode", "func_location": "AtomEnvironment.attemptRestoreProjectStateForPaths.(unnamed_function_27)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 1168, "func_start_line": 1162}}, {"func_info": {"comment": [], "name": "Pane.promptToSaveItem", "params": ["item", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 848, "start_line": 800}, "call_info": {"func_end_line": 1215, "code": "    return Promise.all(this.getItems().map(item => this.promptToSaveItem(item)))\r", "name": "promptToSaveItem", "func_location": "Pane.close.(unnamed_function_27)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 1215, "func_start_line": 1215}}, {"func_info": {"comment": [], "name": "TextEditorComponent.autoscrollOnMouseDrag", "params": [["clientX", "clientY"], "verticalOnly"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1959, "start_line": 1922}, "call_info": {"func_end_line": 1878, "code": "      didDrag: (event) => {\r\n        this.autoscrollOnMouseDrag(event, true)\r\n        const dragRow = this.screenPositionForMouseEvent(event).row\r\n        const draggedLineScreenRange = Range(Point(dragRow, 0), Point(dragRow + 1, 0))\r\n        model.getLastSelection().setScreenRange(draggedLineScreenRange.union(initialScreenRange), {\r\n          reversed: dragRow < initialScreenRange.start.row,\r\n          autoscroll: false,\r\n          preserveFolds: true\r\n        })\r\n        this.updateSync()\r\n      },\r", "name": "autoscrollOnMouseDrag", "func_location": "didDrag.(unnamed_function_28)", "args": ["event", {"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1869, "func_start_line": 1868}}, {"func_info": {"comment": [], "name": "TextEditorComponent.screenPositionForMouseEvent", "params": ["event"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1963, "start_line": 1961}, "call_info": {"func_end_line": 1878, "code": "      didDrag: (event) => {\r\n        this.autoscrollOnMouseDrag(event, true)\r\n        const dragRow = this.screenPositionForMouseEvent(event).row\r\n        const draggedLineScreenRange = Range(Point(dragRow, 0), Point(dragRow + 1, 0))\r\n        model.getLastSelection().setScreenRange(draggedLineScreenRange.union(initialScreenRange), {\r\n          reversed: dragRow < initialScreenRange.start.row,\r\n          autoscroll: false,\r\n          preserveFolds: true\r\n        })\r\n        this.updateSync()\r\n      },\r", "name": "screenPositionForMouseEvent", "func_location": "didDrag.(unnamed_function_28)", "args": ["event"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1870, "func_start_line": 1868}}, {"func_info": {"comment": [], "name": "TextEditorComponent.updateSync", "params": ["useScheduler"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 289, "start_line": 221}, "call_info": {"func_end_line": 1878, "code": "      didDrag: (event) => {\r\n        this.autoscrollOnMouseDrag(event, true)\r\n        const dragRow = this.screenPositionForMouseEvent(event).row\r\n        const draggedLineScreenRange = Range(Point(dragRow, 0), Point(dragRow + 1, 0))\r\n        model.getLastSelection().setScreenRange(draggedLineScreenRange.union(initialScreenRange), {\r\n          reversed: dragRow < initialScreenRange.start.row,\r\n          autoscroll: false,\r\n          preserveFolds: true\r\n        })\r\n        this.updateSync()\r\n      },\r", "name": "updateSync", "func_location": "didDrag.(unnamed_function_28)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1877, "func_start_line": 1868}}, {"func_info": {"comment": [" Public: Close the pane and destroy all its items.", "", " If this is the last pane, all the items will be destroyed but the pane", " itself will not be destroyed."], "name": "Pane.destroy", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 1039, "start_line": 1022}, "call_info": {"func_end_line": 1218, "code": "      .then(results => {\r\n        if (!results.includes(false)) return this.destroy()\r\n      })\r", "name": "destroy", "func_location": "Pane.close.(unnamed_function_28)", "args": [{"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 1217, "func_start_line": 1216}}, {"func_info": {"comment": [], "name": "TextEditorComponent.updateSync", "params": ["useScheduler"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 289, "start_line": 221}, "call_info": {"func_end_line": 1882, "code": "      didStopDragging: () => {\r\n        model.mergeIntersectingSelections()\r\n        this.updateSync()\r\n      }\r", "name": "updateSync", "func_location": "didStopDragging.(unnamed_function_29)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1881, "func_start_line": 1879}}, {"func_info": {"comment": [], "name": "AutoUpdateManager.setState", "params": ["state", "errorMessage"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "end_line": 108, "start_line": 103}, "call_info": {"func_end_line": 53, "code": "    autoUpdater.on('update-not-available', () => {\r\n      this.setState(NoUpdateAvailableState)\r\n      this.emitWindowEvent('update-not-available')\r\n    })\r", "name": "setState", "func_location": "AutoUpdateManager.initialize.(unnamed_function_3)", "args": ["NoUpdateAvailableState"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "line": 51, "func_start_line": 50}}, {"func_info": {"comment": [], "name": "AutoUpdateManager.emitWindowEvent", "params": ["eventName", "payload"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "end_line": 101, "start_line": 97}, "call_info": {"func_end_line": 53, "code": "    autoUpdater.on('update-not-available', () => {\r\n      this.setState(NoUpdateAvailableState)\r\n      this.emitWindowEvent('update-not-available')\r\n    })\r", "name": "emitWindowEvent", "func_location": "AutoUpdateManager.initialize.(unnamed_function_3)", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "line": 52, "func_start_line": 50}}, {"func_info": {"comment": [], "name": "TextEditorComponent.updateSync", "params": ["useScheduler"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 289, "start_line": 221}, "call_info": {"func_end_line": 217, "code": "      etch.getScheduler().updateDocument(() => {\r\n        if (this.updateScheduled) this.updateSync(true)\r\n      })\r", "name": "updateSync", "func_location": "TextEditorComponent.scheduleUpdate.(unnamed_function_3)", "args": [{"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 216, "func_start_line": 215}}, {"func_info": {"comment": [], "name": "Selection.isLastSelection", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 31, "start_line": 29}, "call_info": {"func_end_line": 103, "code": "    this.modifySelection(() => {\r\n      const needsFlash = options.flash\r\n      options.flash = null\r\n      this.marker.setBufferRange(bufferRange, options)\r\n      const autoscroll = options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n      if (autoscroll) this.autoscroll()\r\n      if (needsFlash) this.decoration.flash('flash', this.editor.selectionFlashDuration)\r\n    })\r", "name": "isLastSelection", "func_location": "Selection.setBufferRange.(unnamed_function_3)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 100, "func_start_line": 96}}, {"func_info": {"comment": [" Essential: Restore the setting at `keyPath` to its default value.", "", " * `keyPath` The {String} name of the key.", " * `options` (optional) {Object}", "   * `scopeSelector` (optional) {String}. See {::set}", "   * `source` (optional) {String}. See {::set}"], "name": "Config.unset", "params": ["keyPath", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 766, "start_line": 730}, "call_info": {"func_end_line": 732, "code": "      this.pendingOperations.push(() => this.unset(keyPath, options))\r", "name": "unset", "func_location": "Config.unset.(unnamed_function_3)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 732, "func_start_line": 732}}, {"func_info": {"comment": [], "name": "ReopenProjectMenuManager.betterBaseName", "params": ["directory"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js", "end_line": 145, "start_line": 141}, "call_info": {"func_end_line": 54, "code": "    return paths.map(path => `${ReopenProjectMenuManager.betterBaseName(path)} (${path})`).join(' ')\r", "name": "betterBaseName", "func_location": "ReopenProjectMenuManager.taskDescription.(unnamed_function_3)", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js", "line": 54, "func_start_line": 54}}, {"func_info": {"comment": [], "name": "ReopenProjectListView.cancel", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js", "end_line": 50, "start_line": 40}, "call_info": {"func_end_line": 23, "code": "      didConfirmSelection: (project) => {\r\n        this.cancel()\r\n        this.callback(project.value)\r\n      },\r", "name": "cancel", "func_location": "didConfirmSelection.(unnamed_function_3)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js", "line": 21, "func_start_line": 20}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.isAlive", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 49, "start_line": 47}, "call_info": {"func_end_line": 279, "code": "    _.defer(() => {\r\n      this.pendingChunk = false\r\n      if (this.isAlive() && this.buffer.isAlive()) this.tokenizeNextChunk()\r\n    })\r", "name": "isAlive", "func_location": "TextMateLanguageMode.tokenizeInBackground.(unnamed_function_3)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 278, "func_start_line": 276}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.tokenizeNextChunk", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 319, "start_line": 282}, "call_info": {"func_end_line": 279, "code": "    _.defer(() => {\r\n      this.pendingChunk = false\r\n      if (this.isAlive() && this.buffer.isAlive()) this.tokenizeNextChunk()\r\n    })\r", "name": "tokenizeNextChunk", "func_location": "TextMateLanguageMode.tokenizeInBackground.(unnamed_function_3)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 278, "func_start_line": 276}}, {"func_info": {"comment": ["\r\n  Section: Private\r\n  ", " Subscribes to buffer events."], "name": "GitRepository.subscribeToBuffer", "params": ["buffer"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 511, "start_line": 495}, "call_info": {"func_end_line": 105, "code": "      this.project.getBuffers().forEach(buffer => this.subscribeToBuffer(buffer))\r", "name": "subscribeToBuffer", "func_location": "GitRepository.constructor.(unnamed_function_3)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 105, "func_start_line": 105}}, {"func_info": {"comment": [], "name": "PackageTranspilationRegistry.getPackageTranspilerSpecForFilePath", "params": ["filePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js", "end_line": 110, "start_line": 78}, "call_info": {"func_end_line": 53, "code": "      getCachePath: (sourceCode, filePath) => {\r\n        const spec = this.getPackageTranspilerSpecForFilePath(filePath)\r\n        if (spec) {\r\n          return this.getCachePath(sourceCode, filePath, spec)\r\n        }\r\n\r\n        return transpiler.getCachePath(sourceCode, filePath)\r\n      },\r", "name": "getPackageTranspilerSpecForFilePath", "func_location": "getCachePath.(unnamed_function_3)", "args": ["filePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js", "line": 47, "func_start_line": 46}}, {"func_info": {"comment": [], "name": "PackageTranspilationRegistry.getCachePath", "params": ["sourceCode", "filePath", "spec"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js", "end_line": 131, "start_line": 112}, "call_info": {"func_end_line": 53, "code": "      getCachePath: (sourceCode, filePath) => {\r\n        const spec = this.getPackageTranspilerSpecForFilePath(filePath)\r\n        if (spec) {\r\n          return this.getCachePath(sourceCode, filePath, spec)\r\n        }\r\n\r\n        return transpiler.getCachePath(sourceCode, filePath)\r\n      },\r", "name": "getCachePath", "func_location": "getCachePath.(unnamed_function_3)", "args": ["sourceCode", "filePath", "spec"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js", "line": 49, "func_start_line": 46}}, {"func_info": {"comment": [], "name": "StorageFolder.pathForKey", "params": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/storage-folder.js", "end_line": 44, "start_line": 42}, "call_info": {"func_end_line": 39, "code": "    return new Promise(resolve => {\r\n      if (!this.path) return resolve(null)\r\n      const statePath = this.pathForKey(name)\r\n      fs.readFile(statePath, 'utf8', (error, stateString) => {\r\n        if (error && error.code !== 'ENOENT') {\r\n          console.warn(`Error reading state file: ${statePath}`, error.stack, error)\r\n        }\r\n\r\n        if (!stateString) return resolve(null)\r\n\r\n        try {\r\n          resolve(JSON.parse(stateString))\r\n        } catch (error) {\r\n          console.warn(`Error parsing state file: ${statePath}`, error.stack, error)\r\n          resolve(null)\r\n        }\r\n      })\r\n    })\r", "name": "pathForKey", "func_location": "StorageFolder.load.(unnamed_function_3)", "args": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/storage-folder.js", "line": 24, "func_start_line": 22}}, {"func_info": {"comment": [], "name": "Package.requireMainModule", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 784, "start_line": 755}, "call_info": {"func_end_line": 186, "code": "    this.measure('initializeTime', () => {\r\n      try {\r\n        // The main module's `initialize()` method is guaranteed to be called\r\n        // before its `activate()`. This gives you a chance to handle the\r\n        // serialized package state before the package's derserializers and view\r\n        // providers are used.\r\n        if (!this.mainModule) this.requireMainModule()\r\n        if (typeof this.mainModule.initialize === 'function') {\r\n          this.mainModule.initialize(this.packageManager.getPackageState(this.name) || {})\r\n        }\r\n        this.mainInitialized = true\r\n      } catch (error) {\r\n        this.handleError(`Failed to initialize the ${this.name} package`, error)\r\n      }\r\n    })\r", "name": "requireMainModule", "func_location": "Package.initializeIfNeeded.(unnamed_function_3)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 178, "func_start_line": 172}}, {"func_info": {"comment": [], "name": "Package.handleError", "params": ["message", "error"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 1105, "start_line": 1085}, "call_info": {"func_end_line": 186, "code": "    this.measure('initializeTime', () => {\r\n      try {\r\n        // The main module's `initialize()` method is guaranteed to be called\r\n        // before its `activate()`. This gives you a chance to handle the\r\n        // serialized package state before the package's derserializers and view\r\n        // providers are used.\r\n        if (!this.mainModule) this.requireMainModule()\r\n        if (typeof this.mainModule.initialize === 'function') {\r\n          this.mainModule.initialize(this.packageManager.getPackageState(this.name) || {})\r\n        }\r\n        this.mainInitialized = true\r\n      } catch (error) {\r\n        this.handleError(`Failed to initialize the ${this.name} package`, error)\r\n      }\r\n    })\r", "name": "handleError", "func_location": "Package.initializeIfNeeded.(unnamed_function_3)", "args": [null, "error"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 184, "func_start_line": 172}}, {"func_info": {"comment": [], "name": "AtomApplication.constructor", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 136, "start_line": 91}, "call_info": {"func_end_line": 84, "code": "    client.on('error', () => new AtomApplication(options).initialize(options))\r", "name": "constructor", "func_location": "AtomApplication.open.(unnamed_function_3)", "args": [{"type": "string"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 84, "func_start_line": 84}}, {"func_info": {"comment": [" This stuff was previously done in the constructor, but we want to be able to construct this object", " for testing purposes without booting up the world. As you add tests, feel free to move instantiation", " of these various sub-objects into the constructor, but you'll need to remove the side-effects they", " perform during their construction, adding an initialize method that you call here."], "name": "AtomApplication.initialize", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 161, "start_line": 142}, "call_info": {"func_end_line": 84, "code": "    client.on('error', () => new AtomApplication(options).initialize(options))\r", "name": "initialize", "func_location": "AtomApplication.open.(unnamed_function_3)", "args": [{"type": "string"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 84, "func_start_line": 84}}, {"func_info": {"comment": [], "name": "TextEditorRegistry.updateAndMonitorEditorSettings", "params": ["editor", "oldLanguageMode"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js", "end_line": 222, "start_line": 218}, "call_info": {"func_end_line": 154, "code": "    const languageChangeSubscription = editor.buffer.onDidChangeLanguageMode((newLanguageMode, oldLanguageMode) => {\r\n      this.updateAndMonitorEditorSettings(editor, oldLanguageMode)\r\n    })\r", "name": "updateAndMonitorEditorSettings", "func_location": "TextEditorRegistry.maintainConfig.languageChangeSubscription.(unnamed_function_3)", "args": ["editor", "oldLanguageMode"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js", "line": 153, "func_start_line": 152}}, {"func_info": {"comment": [], "name": "CommandInstaller.installApmCommand", "params": ["askForPrivilege", "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js", "end_line": 72, "start_line": 65}, "call_info": {"func_end_line": 39, "name": "installApmCommand", "func_location": "CommandInstaller.installShellCommandsInteractively.(unnamed_function_3)", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js", "line": 32, "func_start_line": 30}}, {"func_info": {"comment": [], "name": "ConfigFile.reload", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config-file.js", "end_line": 117, "start_line": 102}, "call_info": {"func_end_line": 53, "code": "    this.requestLoad = _.debounce(() => this.reload(), 200)\r", "name": "reload", "func_location": "ConfigFile.constructor.(unnamed_function_3)", "args": [null, {"type": "number"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config-file.js", "line": 53, "func_start_line": 53}}, {"func_info": {"comment": [" Removes a {TextBuffer} association from the project.", "", " Returns the removed {TextBuffer}."], "name": "Project.removeBuffer", "params": ["buffer"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 742, "start_line": 739}, "call_info": {"func_end_line": 765, "code": "    buffer.onDidDestroy(() => this.removeBuffer(buffer))\r", "name": "removeBuffer", "func_location": "Project.subscribeToBuffer.(unnamed_function_30)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 765, "func_start_line": 765}}, {"func_info": {"comment": ["\r\n  Section: Managing Paths\r\n  ", " Public: Get an {Array} of {String}s containing the paths of the project's", " directories."], "name": "Project.getPaths", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 329, "start_line": 327}, "call_info": {"func_end_line": 770, "code": "    buffer.onDidChangePath(() => {\r\n      if (!(this.getPaths().length > 0)) {\r\n        this.setPaths([path.dirname(buffer.getPath())])\r\n      }\r\n    })\r", "name": "getPaths", "func_location": "Project.subscribeToBuffer.(unnamed_function_31)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 767, "func_start_line": 766}}, {"func_info": {"comment": [" Public: Set the paths of the project's directories.", "", " * `projectPaths` {Array} of {String} paths.", " * `options` An optional {Object} that may contain the following keys:", "   * `mustExist` If `true`, throw an Error if any `projectPaths` do not exist. Any remaining `projectPaths` that", "     do exist will still be added to the project. Default: `false`.", "   * `exact` If `true`, only add a `projectPath` if it names an existing directory. If `false` and any `projectPath`", "     is a file or does not exist, its parent directory will be added instead. Default: `false`."], "name": "Project.setPaths", "params": ["projectPaths", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 371, "start_line": 339}, "call_info": {"func_end_line": 770, "code": "    buffer.onDidChangePath(() => {\r\n      if (!(this.getPaths().length > 0)) {\r\n        this.setPaths([path.dirname(buffer.getPath())])\r\n      }\r\n    })\r", "name": "setPaths", "func_location": "Project.subscribeToBuffer.(unnamed_function_31)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 768, "func_start_line": 766}}, {"func_info": {"comment": [], "name": "TextEditorComponent.scheduleUpdate", "params": ["nextUpdateOnlyBlinksCursors"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 219, "start_line": 204}, "call_info": {"func_end_line": 2006, "code": "      this.cursorBlinkIntervalHandle = window.setInterval(() => {\r\n        this.cursorsBlinkedOff = !this.cursorsBlinkedOff\r\n        this.scheduleUpdate(true)\r\n      }, (this.props.cursorBlinkPeriod || CURSOR_BLINK_PERIOD) / 2)\r", "name": "scheduleUpdate", "func_location": "TextEditorComponent.startCursorBlinking.(unnamed_function_32)", "args": [{"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2005, "func_start_line": 2003}}, {"func_info": {"comment": [], "name": "TextEditorComponent.renderedScreenLineForRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 961, "start_line": 956}, "call_info": {"func_end_line": 2290, "code": "    this.horizontalPositionsToMeasure.forEach((columnsToMeasure, row) => {\r\n      columnsToMeasure.sort((a, b) => a - b)\r\n\r\n      const screenLine = this.renderedScreenLineForRow(row)\r\n      const lineComponent = this.lineComponentsByScreenLineId.get(screenLine.id)\r\n\r\n      if (!lineComponent) {\r\n        const error = new Error('Requested measurement of a line component that is not currently rendered')\r\n        error.metadata = {\r\n          row,\r\n          columnsToMeasure,\r\n          renderedScreenLineIds: this.renderedScreenLines.map((line) => line.id),\r\n          extraRenderedScreenLineIds: Array.from(this.extraRenderedScreenLines.keys()),\r\n          lineComponentScreenLineIds: Array.from(this.lineComponentsByScreenLineId.keys()),\r\n          renderedStartRow: this.getRenderedStartRow(),\r\n          renderedEndRow: this.getRenderedEndRow(),\r\n          requestedScreenLineId: screenLine.id\r\n        }\r\n        throw error\r\n      }\r\n\r\n      const lineNode = lineComponent.element\r\n      const textNodes = lineComponent.textNodes\r\n      let positionsForLine = this.horizontalPixelPositionsByScreenLineId.get(screenLine.id)\r\n      if (positionsForLine == null) {\r\n        positionsForLine = new Map()\r\n        this.horizontalPixelPositionsByScreenLineId.set(screenLine.id, positionsForLine)\r\n      }\r\n\r\n      this.measureHorizontalPositionsOnLine(lineNode, textNodes, columnsToMeasure, positionsForLine)\r\n    })\r", "name": "renderedScreenLineForRow", "func_location": "TextEditorComponent.measureHorizontalPositions.(unnamed_function_33)", "args": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2263, "func_start_line": 2260}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedStartRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2726, "start_line": 2720}, "call_info": {"func_end_line": 2290, "code": "    this.horizontalPositionsToMeasure.forEach((columnsToMeasure, row) => {\r\n      columnsToMeasure.sort((a, b) => a - b)\r\n\r\n      const screenLine = this.renderedScreenLineForRow(row)\r\n      const lineComponent = this.lineComponentsByScreenLineId.get(screenLine.id)\r\n\r\n      if (!lineComponent) {\r\n        const error = new Error('Requested measurement of a line component that is not currently rendered')\r\n        error.metadata = {\r\n          row,\r\n          columnsToMeasure,\r\n          renderedScreenLineIds: this.renderedScreenLines.map((line) => line.id),\r\n          extraRenderedScreenLineIds: Array.from(this.extraRenderedScreenLines.keys()),\r\n          lineComponentScreenLineIds: Array.from(this.lineComponentsByScreenLineId.keys()),\r\n          renderedStartRow: this.getRenderedStartRow(),\r\n          renderedEndRow: this.getRenderedEndRow(),\r\n          requestedScreenLineId: screenLine.id\r\n        }\r\n        throw error\r\n      }\r\n\r\n      const lineNode = lineComponent.element\r\n      const textNodes = lineComponent.textNodes\r\n      let positionsForLine = this.horizontalPixelPositionsByScreenLineId.get(screenLine.id)\r\n      if (positionsForLine == null) {\r\n        positionsForLine = new Map()\r\n        this.horizontalPixelPositionsByScreenLineId.set(screenLine.id, positionsForLine)\r\n      }\r\n\r\n      this.measureHorizontalPositionsOnLine(lineNode, textNodes, columnsToMeasure, positionsForLine)\r\n    })\r", "name": "getRenderedStartRow", "func_location": "TextEditorComponent.measureHorizontalPositions.(unnamed_function_33)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2274, "func_start_line": 2260}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedEndRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2737, "start_line": 2728}, "call_info": {"func_end_line": 2290, "code": "    this.horizontalPositionsToMeasure.forEach((columnsToMeasure, row) => {\r\n      columnsToMeasure.sort((a, b) => a - b)\r\n\r\n      const screenLine = this.renderedScreenLineForRow(row)\r\n      const lineComponent = this.lineComponentsByScreenLineId.get(screenLine.id)\r\n\r\n      if (!lineComponent) {\r\n        const error = new Error('Requested measurement of a line component that is not currently rendered')\r\n        error.metadata = {\r\n          row,\r\n          columnsToMeasure,\r\n          renderedScreenLineIds: this.renderedScreenLines.map((line) => line.id),\r\n          extraRenderedScreenLineIds: Array.from(this.extraRenderedScreenLines.keys()),\r\n          lineComponentScreenLineIds: Array.from(this.lineComponentsByScreenLineId.keys()),\r\n          renderedStartRow: this.getRenderedStartRow(),\r\n          renderedEndRow: this.getRenderedEndRow(),\r\n          requestedScreenLineId: screenLine.id\r\n        }\r\n        throw error\r\n      }\r\n\r\n      const lineNode = lineComponent.element\r\n      const textNodes = lineComponent.textNodes\r\n      let positionsForLine = this.horizontalPixelPositionsByScreenLineId.get(screenLine.id)\r\n      if (positionsForLine == null) {\r\n        positionsForLine = new Map()\r\n        this.horizontalPixelPositionsByScreenLineId.set(screenLine.id, positionsForLine)\r\n      }\r\n\r\n      this.measureHorizontalPositionsOnLine(lineNode, textNodes, columnsToMeasure, positionsForLine)\r\n    })\r", "name": "getRenderedEndRow", "func_location": "TextEditorComponent.measureHorizontalPositions.(unnamed_function_33)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2275, "func_start_line": 2260}}, {"func_info": {"comment": [], "name": "TextEditorComponent.measureHorizontalPositionsOnLine", "params": ["lineNode", "textNodes", "columnsToMeasure", "positions"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2344, "start_line": 2294}, "call_info": {"func_end_line": 2290, "code": "    this.horizontalPositionsToMeasure.forEach((columnsToMeasure, row) => {\r\n      columnsToMeasure.sort((a, b) => a - b)\r\n\r\n      const screenLine = this.renderedScreenLineForRow(row)\r\n      const lineComponent = this.lineComponentsByScreenLineId.get(screenLine.id)\r\n\r\n      if (!lineComponent) {\r\n        const error = new Error('Requested measurement of a line component that is not currently rendered')\r\n        error.metadata = {\r\n          row,\r\n          columnsToMeasure,\r\n          renderedScreenLineIds: this.renderedScreenLines.map((line) => line.id),\r\n          extraRenderedScreenLineIds: Array.from(this.extraRenderedScreenLines.keys()),\r\n          lineComponentScreenLineIds: Array.from(this.lineComponentsByScreenLineId.keys()),\r\n          renderedStartRow: this.getRenderedStartRow(),\r\n          renderedEndRow: this.getRenderedEndRow(),\r\n          requestedScreenLineId: screenLine.id\r\n        }\r\n        throw error\r\n      }\r\n\r\n      const lineNode = lineComponent.element\r\n      const textNodes = lineComponent.textNodes\r\n      let positionsForLine = this.horizontalPixelPositionsByScreenLineId.get(screenLine.id)\r\n      if (positionsForLine == null) {\r\n        positionsForLine = new Map()\r\n        this.horizontalPixelPositionsByScreenLineId.set(screenLine.id, positionsForLine)\r\n      }\r\n\r\n      this.measureHorizontalPositionsOnLine(lineNode, textNodes, columnsToMeasure, positionsForLine)\r\n    })\r", "name": "measureHorizontalPositionsOnLine", "func_location": "TextEditorComponent.measureHorizontalPositions.(unnamed_function_33)", "args": ["lineNode", "textNodes", "columnsToMeasure", "positionsForLine"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2289, "func_start_line": 2260}}, {"func_info": {"comment": [], "name": "Package.activateNow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 236, "start_line": 212}, "call_info": {"func_end_line": 864, "code": "          this.activationCommandSubscriptions.add(this.commandRegistry.onWillDispatch(event => {\r\n            if (event.type !== command) return\r\n            let currentTarget = event.target\r\n            while (currentTarget) {\r\n              if (currentTarget.webkitMatchesSelector(selector)) {\r\n                this.activationCommandSubscriptions.dispose()\r\n                this.activateNow()\r\n                break\r\n              }\r\n              currentTarget = currentTarget.parentElement\r\n            }\r\n          }))\r", "name": "activateNow", "func_location": "Package.subscribeToActivationCommands.(unnamed_function_33).(unnamed_function_35)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 859, "func_start_line": 853}}, {"func_info": {"comment": [], "name": "Package.activateNow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 236, "start_line": 212}, "call_info": {"func_end_line": 895, "code": "          this.packageManager.onDidTriggerActivationHook(hook, () => this.activateNow())\r", "name": "activateNow", "func_location": "Package.subscribeToActivationHooks.(unnamed_function_36)", "args": ["hook", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 895, "func_start_line": 895}}, {"func_info": {"comment": [], "name": "TextEditorComponent.scheduleUpdate", "params": ["nextUpdateOnlyBlinksCursors"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 219, "start_line": 204}, "call_info": {"func_end_line": 2543, "code": "      const didUpdateDisposable = marker.bufferMarker.onDidChange(({textChanged}) => {\r\n        const isValid = marker.isValid()\r\n        if (wasValid && !isValid) {\r\n          wasValid = false\r\n          this.blockDecorationsToMeasure.delete(decoration)\r\n          this.heightsByBlockDecoration.delete(decoration)\r\n          this.blockDecorationsByElement.delete(element)\r\n          this.blockDecorationResizeObserver.unobserve(element)\r\n          this.lineTopIndex.removeBlock(decoration)\r\n          this.scheduleUpdate()\r\n        } else if (!wasValid && isValid) {\r\n          wasValid = true\r\n          this.addBlockDecoration(decoration, false)\r\n        } else if (isValid && !textChanged) {\r\n          this.lineTopIndex.moveBlock(decoration, marker.getHeadScreenPosition().row)\r\n          this.scheduleUpdate()\r\n        }\r\n      })\r", "name": "scheduleUpdate", "func_location": "TextEditorComponent.addBlockDecoration.didUpdateDisposable.(unnamed_function_37)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2535, "func_start_line": 2526}}, {"func_info": {"comment": [], "name": "TextEditorComponent.addBlockDecoration", "params": ["decoration", "subscribeToChanges"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2560, "start_line": 2508}, "call_info": {"func_end_line": 2543, "code": "      const didUpdateDisposable = marker.bufferMarker.onDidChange(({textChanged}) => {\r\n        const isValid = marker.isValid()\r\n        if (wasValid && !isValid) {\r\n          wasValid = false\r\n          this.blockDecorationsToMeasure.delete(decoration)\r\n          this.heightsByBlockDecoration.delete(decoration)\r\n          this.blockDecorationsByElement.delete(element)\r\n          this.blockDecorationResizeObserver.unobserve(element)\r\n          this.lineTopIndex.removeBlock(decoration)\r\n          this.scheduleUpdate()\r\n        } else if (!wasValid && isValid) {\r\n          wasValid = true\r\n          this.addBlockDecoration(decoration, false)\r\n        } else if (isValid && !textChanged) {\r\n          this.lineTopIndex.moveBlock(decoration, marker.getHeadScreenPosition().row)\r\n          this.scheduleUpdate()\r\n        }\r\n      })\r", "name": "addBlockDecoration", "func_location": "TextEditorComponent.addBlockDecoration.didUpdateDisposable.(unnamed_function_37)", "args": ["decoration", {"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2538, "func_start_line": 2526}}, {"func_info": {"comment": [], "name": "TextEditorComponent.scheduleUpdate", "params": ["nextUpdateOnlyBlinksCursors"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 219, "start_line": 204}, "call_info": {"func_end_line": 2543, "code": "      const didUpdateDisposable = marker.bufferMarker.onDidChange(({textChanged}) => {\r\n        const isValid = marker.isValid()\r\n        if (wasValid && !isValid) {\r\n          wasValid = false\r\n          this.blockDecorationsToMeasure.delete(decoration)\r\n          this.heightsByBlockDecoration.delete(decoration)\r\n          this.blockDecorationsByElement.delete(element)\r\n          this.blockDecorationResizeObserver.unobserve(element)\r\n          this.lineTopIndex.removeBlock(decoration)\r\n          this.scheduleUpdate()\r\n        } else if (!wasValid && isValid) {\r\n          wasValid = true\r\n          this.addBlockDecoration(decoration, false)\r\n        } else if (isValid && !textChanged) {\r\n          this.lineTopIndex.moveBlock(decoration, marker.getHeadScreenPosition().row)\r\n          this.scheduleUpdate()\r\n        }\r\n      })\r", "name": "scheduleUpdate", "func_location": "TextEditorComponent.addBlockDecoration.didUpdateDisposable.(unnamed_function_37)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2541, "func_start_line": 2526}}, {"func_info": {"comment": [" Does the given module path contain native code?"], "name": "Package.isNativeModule", "params": ["modulePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 930, "start_line": 924}, "call_info": {"func_end_line": 958, "code": "    var traversePath = nodeModulesPath => {\r\n      try {\r\n        for (let modulePath of fs.listSync(nodeModulesPath)) {\r\n          if (this.isNativeModule(modulePath)) nativeModulePaths.push(modulePath)\r\n          traversePath(path.join(modulePath, 'node_modules'))\r\n        }\r\n      } catch (error) {}\r\n    }\r", "name": "isNativeModule", "func_location": "Package.getNativeModuleDependencyPaths.traversePath.(unnamed_function_37)", "args": ["modulePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 954, "func_start_line": 951}}, {"func_info": {"comment": [], "name": "TextEditorComponent.scheduleUpdate", "params": ["nextUpdateOnlyBlinksCursors"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 219, "start_line": 204}, "call_info": {"func_end_line": 2558, "code": "      const didDestroyDisposable = decoration.onDidDestroy(() => {\r\n        didUpdateDisposable.dispose()\r\n        didDestroyDisposable.dispose()\r\n\r\n        if (wasValid) {\r\n          wasValid = false\r\n          this.blockDecorationsToMeasure.delete(decoration)\r\n          this.heightsByBlockDecoration.delete(decoration)\r\n          this.blockDecorationsByElement.delete(element)\r\n          this.blockDecorationResizeObserver.unobserve(element)\r\n          this.lineTopIndex.removeBlock(decoration)\r\n          this.scheduleUpdate()\r\n        }\r\n      })\r", "name": "scheduleUpdate", "func_location": "TextEditorComponent.addBlockDecoration.didDestroyDisposable.(unnamed_function_38)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2556, "func_start_line": 2545}}, {"func_info": {"comment": [], "name": "Package.runRebuildProcess", "params": ["done"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 1030, "start_line": 1019}, "call_info": {"func_end_line": 1009, "name": "runRebuildProcess", "func_location": "Package.rebuild.(unnamed_function_38)", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 999, "func_start_line": 998}}, {"func_info": {"comment": [], "name": "Package.getBuildFailureOutputStorageKey", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 1034, "start_line": 1032}, "call_info": {"func_end_line": 1008, "code": "      this.runRebuildProcess(result => {\r\n        if (result.code === 0) {\r\n          global.localStorage.removeItem(this.getBuildFailureOutputStorageKey())\r\n        } else {\r\n          this.compatible = false\r\n          global.localStorage.setItem(this.getBuildFailureOutputStorageKey(), result.stderr)\r\n        }\r\n        global.localStorage.setItem(this.getIncompatibleNativeModulesStorageKey(), '[]')\r\n        resolve(result)\r\n      })\r", "name": "getBuildFailureOutputStorageKey", "func_location": "Package.rebuild.(unnamed_function_38).(unnamed_function_39)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 1001, "func_start_line": 999}}, {"func_info": {"comment": [], "name": "Package.getBuildFailureOutputStorageKey", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 1034, "start_line": 1032}, "call_info": {"func_end_line": 1008, "code": "      this.runRebuildProcess(result => {\r\n        if (result.code === 0) {\r\n          global.localStorage.removeItem(this.getBuildFailureOutputStorageKey())\r\n        } else {\r\n          this.compatible = false\r\n          global.localStorage.setItem(this.getBuildFailureOutputStorageKey(), result.stderr)\r\n        }\r\n        global.localStorage.setItem(this.getIncompatibleNativeModulesStorageKey(), '[]')\r\n        resolve(result)\r\n      })\r", "name": "getBuildFailureOutputStorageKey", "func_location": "Package.rebuild.(unnamed_function_38).(unnamed_function_39)", "args": [null, "result.stderr"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 1004, "func_start_line": 999}}, {"func_info": {"comment": [], "name": "Package.getIncompatibleNativeModulesStorageKey", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 1039, "start_line": 1036}, "call_info": {"func_end_line": 1008, "code": "      this.runRebuildProcess(result => {\r\n        if (result.code === 0) {\r\n          global.localStorage.removeItem(this.getBuildFailureOutputStorageKey())\r\n        } else {\r\n          this.compatible = false\r\n          global.localStorage.setItem(this.getBuildFailureOutputStorageKey(), result.stderr)\r\n        }\r\n        global.localStorage.setItem(this.getIncompatibleNativeModulesStorageKey(), '[]')\r\n        resolve(result)\r\n      })\r", "name": "getIncompatibleNativeModulesStorageKey", "func_location": "Package.rebuild.(unnamed_function_38).(unnamed_function_39)", "args": [null, {"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 1006, "func_start_line": 999}}, {"func_info": {"comment": [" Public: Returns the currently focused {AtomWindow} or undefined if none."], "name": "AtomApplication.focusedWindow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 750, "start_line": 748}, "call_info": {"func_end_line": 405, "code": "      this.on('application:minimize', () => {\r\n        const window = this.focusedWindow()\r\n        if (window) window.minimize()\r\n      })\r", "name": "focusedWindow", "func_location": "AtomApplication.handleEvents.(unnamed_function_39)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 403, "func_start_line": 402}}, {"func_info": {"comment": [" Extended: Remove any language mode override that has been set for the", " given {TextBuffer}. This will assign to the buffer the best language", " mode available.", "", " * `buffer` The {TextBuffer}."], "name": "GrammarRegistry.autoAssignLanguageMode", "params": ["buffer"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 168, "start_line": 158}, "call_info": {"func_end_line": 95, "code": "    const pathChangeSubscription = buffer.onDidChangePath(() => {\r\n      this.grammarScoresByBuffer.delete(buffer)\r\n      if (!this.languageOverridesByBufferId.has(buffer.id)) {\r\n        this.autoAssignLanguageMode(buffer)\r\n      }\r\n    })\r", "name": "autoAssignLanguageMode", "func_location": "GrammarRegistry.maintainLanguageMode.pathChangeSubscription.(unnamed_function_4)", "args": ["buffer"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 93, "func_start_line": 90}}, {"func_info": {"comment": [], "name": "AutoUpdateManager.setState", "params": ["state", "errorMessage"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "end_line": 108, "start_line": 103}, "call_info": {"func_end_line": 63, "code": "    autoUpdater.on('update-available', () => {\r\n      this.setState(DownloadingState)\r\n      // We use sendMessage to send an event called 'update-available' in 'update-downloaded'\r\n      // once the update download is complete. This mismatch between the electron\r\n      // autoUpdater events is unfortunate but in the interest of not changing the\r\n      // one existing event handled by applicationDelegate\r\n      this.emitWindowEvent('did-begin-downloading-update')\r\n      this.emit('did-begin-download')\r\n    })\r", "name": "setState", "func_location": "AutoUpdateManager.initialize.(unnamed_function_4)", "args": ["DownloadingState"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "line": 56, "func_start_line": 55}}, {"func_info": {"comment": [], "name": "AutoUpdateManager.emitWindowEvent", "params": ["eventName", "payload"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "end_line": 101, "start_line": 97}, "call_info": {"func_end_line": 63, "code": "    autoUpdater.on('update-available', () => {\r\n      this.setState(DownloadingState)\r\n      // We use sendMessage to send an event called 'update-available' in 'update-downloaded'\r\n      // once the update download is complete. This mismatch between the electron\r\n      // autoUpdater events is unfortunate but in the interest of not changing the\r\n      // one existing event handled by applicationDelegate\r\n      this.emitWindowEvent('did-begin-downloading-update')\r\n      this.emit('did-begin-download')\r\n    })\r", "name": "emitWindowEvent", "func_location": "AutoUpdateManager.initialize.(unnamed_function_4)", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "line": 61, "func_start_line": 55}}, {"func_info": {"comment": [], "name": "WorkspaceElement.checkCleanupDockHoverEvents", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 208, "start_line": 204}, "call_info": {"func_end_line": 101, "code": "        .map(dock => dock.onDidChangeHovered(hovered => {\r\n          if (hovered) this.hoveredDock = dock\r\n          else if (dock === this.hoveredDock) this.hoveredDock = null\r\n          this.checkCleanupDockHoverEvents()\r\n        }))\r", "name": "checkCleanupDockHoverEvents", "func_location": "WorkspaceElement.initialize.(unnamed_function_3).(unnamed_function_4)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 100, "func_start_line": 97}}, {"func_info": {"comment": [], "name": "TextEditorComponent.measureContentDuringUpdateSync", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 424, "start_line": 389}, "call_info": {"func_end_line": 278, "code": "      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r", "name": "measureContentDuringUpdateSync", "func_location": "TextEditorComponent.updateSync.(unnamed_function_4)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 270, "func_start_line": 269}}, {"func_info": {"comment": [" Public: Expands the newest selection to include the entire line on which", " the cursor currently rests.", "", " It also includes the newline character."], "name": "Selection.expandOverLine", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 408, "start_line": 403}, "call_info": {"func_end_line": 230, "code": "    this.modifySelection(() => {\r\n      if (this.initialScreenRange) {\r\n        if (position.isLessThan(this.initialScreenRange.start)) {\r\n          this.marker.setScreenRange([position, this.initialScreenRange.end], {reversed: true})\r\n        } else {\r\n          this.marker.setScreenRange([this.initialScreenRange.start, position], {reversed: false})\r\n        }\r\n      } else {\r\n        this.cursor.setScreenPosition(position, options)\r\n      }\r\n\r\n      if (this.linewise) {\r\n        this.expandOverLine(options)\r\n      } else if (this.wordwise) {\r\n        this.expandOverWord(options)\r\n      }\r\n    })\r", "name": "expandOverLine", "func_location": "Selection.selectToScreenPosition.(unnamed_function_4)", "args": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 226, "func_start_line": 214}}, {"func_info": {"comment": [" Public: Expands the newest selection to include the entire word on which", " the cursors rests."], "name": "Selection.expandOverWord", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 380, "start_line": 376}, "call_info": {"func_end_line": 230, "code": "    this.modifySelection(() => {\r\n      if (this.initialScreenRange) {\r\n        if (position.isLessThan(this.initialScreenRange.start)) {\r\n          this.marker.setScreenRange([position, this.initialScreenRange.end], {reversed: true})\r\n        } else {\r\n          this.marker.setScreenRange([this.initialScreenRange.start, position], {reversed: false})\r\n        }\r\n      } else {\r\n        this.cursor.setScreenPosition(position, options)\r\n      }\r\n\r\n      if (this.linewise) {\r\n        this.expandOverLine(options)\r\n      } else if (this.wordwise) {\r\n        this.expandOverWord(options)\r\n      }\r\n    })\r", "name": "expandOverWord", "func_location": "Selection.selectToScreenPosition.(unnamed_function_4)", "args": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 228, "func_start_line": 214}}, {"func_info": {"comment": [], "name": "AtomWindow.disableZoom", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "end_line": 446, "start_line": 444}, "call_info": {"func_end_line": 110, "code": "    this.browserWindow.on('window:loaded', () => {\r\n      this.disableZoom()\r\n      this.emit('window:loaded')\r\n      this.resolveLoadedPromise()\r\n    })\r", "name": "disableZoom", "func_location": "AtomWindow.constructor.(unnamed_function_4)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "line": 107, "func_start_line": 106}}, {"func_info": {"comment": [], "name": "ReopenProjectListView.cancel", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js", "end_line": 50, "start_line": 40}, "call_info": {"func_end_line": 26, "code": "      didCancelSelection: () => {\r\n        this.cancel()\r\n      }\r", "name": "cancel", "func_location": "didCancelSelection.(unnamed_function_4)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js", "line": 25, "func_start_line": 24}}, {"func_info": {"comment": ["\r\n  Section: Private\r\n  ", " Subscribes to buffer events."], "name": "GitRepository.subscribeToBuffer", "params": ["buffer"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 511, "start_line": 495}, "call_info": {"func_end_line": 106, "code": "      this.subscriptions.add(this.project.onDidAddBuffer(buffer => this.subscribeToBuffer(buffer)))\r", "name": "subscribeToBuffer", "func_location": "GitRepository.constructor.(unnamed_function_4)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 106, "func_start_line": 106}}, {"func_info": {"comment": [], "name": "PackageTranspilationRegistry.getPackageTranspilerSpecForFilePath", "params": ["filePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js", "end_line": 110, "start_line": 78}, "call_info": {"func_end_line": 62, "code": "      compile: (sourceCode, filePath) => {\r\n        const spec = this.getPackageTranspilerSpecForFilePath(filePath)\r\n        if (spec) {\r\n          return this.transpileWithPackageTranspiler(sourceCode, filePath, spec)\r\n        }\r\n\r\n        return transpiler.compile(sourceCode, filePath)\r\n      },\r", "name": "getPackageTranspilerSpecForFilePath", "func_location": "compile.(unnamed_function_4)", "args": ["filePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js", "line": 56, "func_start_line": 55}}, {"func_info": {"comment": [], "name": "PackageTranspilationRegistry.transpileWithPackageTranspiler", "params": ["sourceCode", "filePath", "spec"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js", "end_line": 150, "start_line": 133}, "call_info": {"func_end_line": 62, "code": "      compile: (sourceCode, filePath) => {\r\n        const spec = this.getPackageTranspilerSpecForFilePath(filePath)\r\n        if (spec) {\r\n          return this.transpileWithPackageTranspiler(sourceCode, filePath, spec)\r\n        }\r\n\r\n        return transpiler.compile(sourceCode, filePath)\r\n      },\r", "name": "transpileWithPackageTranspiler", "func_location": "compile.(unnamed_function_4)", "args": ["sourceCode", "filePath", "spec"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js", "line": 58, "func_start_line": 55}}, {"func_info": {"comment": [], "name": "PaneElement.getModel", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js", "end_line": 109, "start_line": 107}, "call_info": {"func_end_line": 67, "code": "    const handleDrop = event => {\r\n      event.preventDefault()\r\n      event.stopPropagation()\r\n      this.getModel().activate()\r\n      const pathsToOpen = [...event.dataTransfer.files].map(file => file.path)\r\n      if (pathsToOpen.length > 0) {\r\n        this.applicationDelegate.open({pathsToOpen})\r\n      }\r\n    }\r", "name": "getModel", "func_location": "PaneElement.subscribeToDOMEvents.handleDrop.(unnamed_function_4)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js", "line": 62, "func_start_line": 59}}, {"func_info": {"comment": [], "name": "ProtocolHandlerInstaller.setAsDefaultProtocolClient", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js", "end_line": 22, "start_line": 18}, "call_info": {"func_end_line": 67, "code": "    const accept = () => {\r\n      notification.dismiss()\r\n      this.setAsDefaultProtocolClient()\r\n    }\r", "name": "setAsDefaultProtocolClient", "func_location": "ProtocolHandlerInstaller.promptToBecomeProtocolClient.accept.(unnamed_function_4)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js", "line": 66, "func_start_line": 64}}, {"func_info": {"comment": [], "name": "Package.measure", "params": ["key", "fn"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 85, "start_line": 80}, "call_info": {"func_end_line": 206, "name": "measure", "func_location": "Package.activate.(unnamed_function_4)", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 194, "func_start_line": 192}}, {"func_info": {"comment": [], "name": "AutoUpdater.quitAndInstall", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-updater-win32.js", "end_line": 15, "start_line": 9}, "call_info": {"func_end_line": 82, "name": "quitAndInstall", "func_location": "AutoUpdater.checkForUpdates.(unnamed_function_2).(unnamed_function_3).(unnamed_function_4)", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-updater-win32.js", "line": 81, "func_start_line": 81}}, {"func_info": {"comment": [], "name": "shouldEditorUseSoftTabs", "params": ["editor", "tabType", "softTabs"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js", "end_line": 314, "start_line": 298}, "call_info": {"func_end_line": 164, "name": "shouldEditorUseSoftTabs", "func_location": "TextEditorRegistry.maintainConfig.updateTabTypes.(unnamed_function_4)", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js", "line": 159, "func_start_line": 157}}, {"func_info": {"comment": [], "name": "SettingsFile.constructor", "params": ["path", "properties"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 1122, "start_line": 1119}, "call_info": {"func_end_line": 1116, "code": "    CSON.readFile(path, (error, properties = {}) => {\r\n      if (error) {\r\n        callback(error)\r\n      } else {\r\n        callback(null, new SettingsFile(path, properties))\r\n      }\r\n    })\r", "name": "constructor", "func_location": "SettingsFile.load.(unnamed_function_40)", "args": [{"type": "object"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 1114, "func_start_line": 1110}}, {"func_info": {"comment": [], "name": "AtomApplication.getAllWindows", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 323, "start_line": 321}, "call_info": {"func_end_line": 426, "code": "    this.configFile.onDidChange(settings => {\r\n      for (let window of this.getAllWindows()) {\r\n        window.didChangeUserSettings(settings)\r\n      }\r\n      this.config.resetUserSettings(settings)\r\n    })\r", "name": "getAllWindows", "func_location": "AtomApplication.handleEvents.(unnamed_function_41)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 422, "func_start_line": 421}}, {"func_info": {"comment": [" Public: Returns the currently focused {AtomWindow} or undefined if none."], "name": "AtomApplication.focusedWindow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 750, "start_line": 748}, "call_info": {"func_end_line": 431, "code": "    this.configFile.onDidError(message => {\r\n      const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n      if (window) window.didFailToReadUserSettings(message)\r\n    })\r", "name": "focusedWindow", "func_location": "AtomApplication.handleEvents.(unnamed_function_42)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 429, "func_start_line": 428}}, {"func_info": {"comment": [], "name": "AtomApplication.getLastFocusedWindow", "params": ["predicate"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 327, "start_line": 325}, "call_info": {"func_end_line": 431, "code": "    this.configFile.onDidError(message => {\r\n      const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n      if (window) window.didFailToReadUserSettings(message)\r\n    })\r", "name": "getLastFocusedWindow", "func_location": "AtomApplication.handleEvents.(unnamed_function_42)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 429, "func_start_line": 428}}, {"func_info": {"comment": [], "name": "GutterContainerComponent.renderLineNumberGutter", "params": ["gutter"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 3186, "start_line": 3131}, "call_info": {"func_end_line": 3126, "code": "        guttersToRender.map((gutter) => {\r\n          if (gutter.type === 'line-number') {\r\n            return this.renderLineNumberGutter(gutter)\r\n          } else {\r\n            return $(CustomGutterComponent, {\r\n              key: gutter,\r\n              element: gutter.getElement(),\r\n              name: gutter.name,\r\n              visible: gutter.isVisible(),\r\n              height: scrollHeight,\r\n              decorations: decorationsToRender.customGutter.get(gutter.name)\r\n            })\r\n          }\r\n        })\r", "name": "renderLineNumberGutter", "func_location": "GutterContainerComponent.render.(unnamed_function_43)", "args": ["gutter"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3115, "func_start_line": 3113}}, {"func_info": {"comment": [], "name": "AtomApplication.getAllWindows", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 323, "start_line": 321}, "call_info": {"func_end_line": 457, "code": "    this.disposable.add(ipcHelpers.on(app, 'before-quit', async event => {\r\n      let resolveBeforeQuitPromise\r\n      this.lastBeforeQuitPromise = new Promise(resolve => { resolveBeforeQuitPromise = resolve })\r\n\r\n      if (!this.quitting) {\r\n        this.quitting = true\r\n        event.preventDefault()\r\n        const windowUnloadPromises = this.getAllWindows().map(async window => {\r\n          const unloaded = await window.prepareToUnload()\r\n          if (unloaded) {\r\n            window.close()\r\n            await window.closedPromise\r\n          }\r\n          return unloaded\r\n        })\r\n        const windowUnloadedResults = await Promise.all(windowUnloadPromises)\r\n        if (windowUnloadedResults.every(Boolean)) {\r\n          app.quit()\r\n        } else {\r\n          this.quitting = false\r\n        }\r\n      }\r\n\r\n      resolveBeforeQuitPromise()\r\n    }))\r", "name": "getAllWindows", "func_location": "AtomApplication.handleEvents.(unnamed_function_43)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 440, "func_start_line": 433}}, {"func_info": {"comment": [], "name": "arraysEqual", "params": ["a", "b"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4362, "start_line": 4356}, "call_info": {"func_end_line": 3344, "code": "        oldTileBlockDecorations.forEach((oldDecorations, screenLineId) => {\r\n          if (!blockDecorationsChanged) {\r\n            const newDecorations = newTileBlockDecorations.get(screenLineId)\r\n            blockDecorationsChanged = (newDecorations == null || !arraysEqual(oldDecorations, newDecorations))\r\n          }\r\n        })\r", "name": "arraysEqual", "func_location": "LineNumberGutterComponent.shouldUpdate.(unnamed_function_44)", "args": ["oldDecorations", "newDecorations"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3342, "func_start_line": 3339}}, {"func_info": {"comment": [" Kill all processes associated with opened windows."], "name": "AtomApplication.killAllProcesses", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 932, "start_line": 928}, "call_info": {"func_end_line": 462, "code": "    this.disposable.add(ipcHelpers.on(app, 'will-quit', () => {\r\n      this.killAllProcesses()\r\n      this.deleteSocketFile()\r\n    }))\r", "name": "killAllProcesses", "func_location": "AtomApplication.handleEvents.(unnamed_function_46)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 460, "func_start_line": 459}}, {"func_info": {"comment": [], "name": "AtomApplication.deleteSocketFile", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 361, "start_line": 348}, "call_info": {"func_end_line": 462, "code": "    this.disposable.add(ipcHelpers.on(app, 'will-quit', () => {\r\n      this.killAllProcesses()\r\n      this.deleteSocketFile()\r\n    }))\r", "name": "deleteSocketFile", "func_location": "AtomApplication.handleEvents.(unnamed_function_46)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 461, "func_start_line": 459}}, {"func_info": {"comment": [" Public: Opens a single path, in an existing window if possible.", "", " options -", "   :pathToOpen - The file path to open", "   :pidToKillWhenClosed - The integer of the pid to kill", "   :newWindow - Boolean of whether this should be opened in a new window.", "   :devMode - Boolean to control the opened window's dev mode.", "   :safeMode - Boolean to control the opened window's safe mode.", "   :profileStartup - Boolean to control creating a profile of the startup time.", "   :window - {AtomWindow} to open file paths in.", "   :addToLastWindow - Boolean of whether this should be opened in last focused window."], "name": "AtomApplication.openPath", "params": [["initialPaths", "pathToOpen", "pidToKillWhenClosed", "newWindow", "devMode", "safeMode", "profileStartup", "window", "clearWindowState", "addToLastWindow", "env"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 812, "start_line": 786}, "call_info": {"func_end_line": 467, "code": "    this.disposable.add(ipcHelpers.on(app, 'open-file', (event, pathToOpen) => {\r\n      event.preventDefault()\r\n      this.openPath({pathToOpen})\r\n    }))\r", "name": "openPath", "func_location": "AtomApplication.handleEvents.(unnamed_function_47)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 466, "func_start_line": 464}}, {"func_info": {"comment": [" Open an atom:// url.", "", " The host of the URL being opened is assumed to be the package name", " responsible for opening the URL.  A new window will be created with", " that package's `urlMain` as the bootstrap script.", "", " options -", "   :urlToOpen - The atom:// url to open.", "   :devMode - Boolean to control the opened window's dev mode.", "   :safeMode - Boolean to control the opened window's safe mode."], "name": "AtomApplication.openUrl", "params": [["urlToOpen", "devMode", "safeMode", "env"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1025, "start_line": 1008}, "call_info": {"func_end_line": 472, "code": "    this.disposable.add(ipcHelpers.on(app, 'open-url', (event, urlToOpen) => {\r\n      event.preventDefault()\r\n      this.openUrl({urlToOpen, devMode: this.devMode, safeMode: this.safeMode})\r\n    }))\r", "name": "openUrl", "func_location": "AtomApplication.handleEvents.(unnamed_function_48)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 471, "func_start_line": 469}}, {"func_info": {"comment": [], "name": "arraysEqual", "params": ["a", "b"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4362, "start_line": 4356}, "call_info": {"func_end_line": 3903, "code": "      oldProps.blockDecorations.forEach((oldDecorations, screenLineId) => {\r\n        if (!blockDecorationsChanged) {\r\n          const newDecorations = newProps.blockDecorations.get(screenLineId)\r\n          blockDecorationsChanged = (newDecorations == null || !arraysEqual(oldDecorations, newDecorations))\r\n        }\r\n      })\r", "name": "arraysEqual", "func_location": "LinesTileComponent.shouldUpdate.(unnamed_function_49)", "args": ["oldDecorations", "newDecorations"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3901, "func_start_line": 3898}}, {"func_info": {"comment": [], "name": "AutoUpdateManager.setState", "params": ["state", "errorMessage"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "end_line": 108, "start_line": 103}, "call_info": {"func_end_line": 69, "code": "    autoUpdater.on('update-downloaded', (event, releaseNotes, releaseVersion) => {\r\n      this.releaseVersion = releaseVersion\r\n      this.setState(UpdateAvailableState)\r\n      this.emitUpdateAvailableEvent()\r\n    })\r", "name": "setState", "func_location": "AutoUpdateManager.initialize.(unnamed_function_5)", "args": ["UpdateAvailableState"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "line": 67, "func_start_line": 65}}, {"func_info": {"comment": [], "name": "AutoUpdateManager.emitUpdateAvailableEvent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "end_line": 95, "start_line": 92}, "call_info": {"func_end_line": 69, "code": "    autoUpdater.on('update-downloaded', (event, releaseNotes, releaseVersion) => {\r\n      this.releaseVersion = releaseVersion\r\n      this.setState(UpdateAvailableState)\r\n      this.emitUpdateAvailableEvent()\r\n    })\r", "name": "emitUpdateAvailableEvent", "func_location": "AutoUpdateManager.initialize.(unnamed_function_5)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "line": 68, "func_start_line": 65}}, {"func_info": {"comment": ["\r\n  Section: File Details\r\n  ", " Essential: Get the editor's title for display in other parts of the", " UI such as the tabs.", "", " If the editor's buffer is saved, its title is the file name. If it is", " unsaved, its title is \"untitled\".", "", " Returns a {String}."], "name": "TextEditor.getTitle", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 1092, "start_line": 1090}, "call_info": {"func_end_line": 587, "code": "    this.disposables.add(this.buffer.onDidChangePath(() => {\r\n      this.emitter.emit('did-change-title', this.getTitle())\r\n      this.emitter.emit('did-change-path', this.getPath())\r\n    }))\r", "name": "getTitle", "func_location": "TextEditor.subscribeToBuffer.(unnamed_function_5)", "args": [{"type": "string"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 585, "func_start_line": 584}}, {"func_info": {"comment": [" Essential: Returns the {String} path of this editor's text buffer."], "name": "TextEditor.getPath", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 1138, "start_line": 1136}, "call_info": {"func_end_line": 587, "code": "    this.disposables.add(this.buffer.onDidChangePath(() => {\r\n      this.emitter.emit('did-change-title', this.getTitle())\r\n      this.emitter.emit('did-change-path', this.getPath())\r\n    }))\r", "name": "getPath", "func_location": "TextEditor.subscribeToBuffer.(unnamed_function_5)", "args": [{"type": "string"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 586, "func_start_line": 584}}, {"func_info": {"comment": [], "name": "TextEditorComponent.updateSync", "params": ["useScheduler"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 289, "start_line": 221}, "call_info": {"func_end_line": 277, "code": "        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r", "name": "updateSync", "func_location": "TextEditorComponent.updateSync.(unnamed_function_4).(unnamed_function_5)", "args": [{"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 273, "func_start_line": 271}}, {"func_info": {"comment": [], "name": "TextEditorComponent.updateSyncAfterMeasuringContent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 449, "start_line": 426}, "call_info": {"func_end_line": 277, "code": "        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r", "name": "updateSyncAfterMeasuringContent", "func_location": "TextEditorComponent.updateSync.(unnamed_function_4).(unnamed_function_5)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 275, "func_start_line": 271}}, {"func_info": {"comment": [], "name": "Config.endTransaction", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 869, "start_line": 866}, "call_info": {"func_end_line": 851, "code": "      endTransaction = fn => (...args) => {\r\n        this.endTransaction()\r\n        return fn(...args)\r\n      }\r", "name": "endTransaction", "func_location": "Config.transactAsync.(unnamed_function_4).(unnamed_function_5)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 849, "func_start_line": 848}}, {"func_info": {"comment": [], "name": "ReopenProjectMenuManager.taskDescription", "params": ["paths"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js", "end_line": 55, "start_line": 53}, "call_info": {"func_end_line": 95, "code": "        items: this.projects.map(project =>\r\n          ({\r\n            type: 'task',\r\n            title: project.paths.map(ReopenProjectMenuManager.betterBaseName).join(', '),\r\n            description: ReopenProjectMenuManager.taskDescription(project.paths),\r\n            program: process.execPath,\r\n            args: project.paths.map(path => `\"${path}\"`).join(' '),\r\n            iconPath: path.join(path.dirname(process.execPath), 'resources', 'cli', 'folder.ico'),\r\n            iconIndex: 0\r\n          })\r\n        )\r", "name": "taskDescription", "func_location": "items.(unnamed_function_5)", "args": ["project.paths"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js", "line": 89, "func_start_line": 85}}, {"func_info": {"comment": [], "name": "ReopenProjectListView.makeName", "params": ["paths"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js", "end_line": 74, "start_line": 72}, "call_info": {"func_end_line": 66, "code": "      const projects = atom.history.getProjects().map(p => ({ name: this.makeName(p.paths), value: p.paths }))\r", "name": "makeName", "func_location": "ReopenProjectListView.toggle.projects.(unnamed_function_5)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js", "line": 66, "func_start_line": 66}}, {"func_info": {"comment": [" Public: Get the status of a single path in the repository.", "", " * `path` A {String} repository-relative path.", "", " Returns a {Number} representing the status. This value can be passed to", " {::isStatusModified} or {::isStatusNew} to get more information."], "name": "GitRepository.getPathStatus", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 390, "start_line": 374}, "call_info": {"func_end_line": 499, "code": "    const getBufferPathStatus = () => {\r\n      const bufferPath = buffer.getPath()\r\n      if (bufferPath) this.getPathStatus(bufferPath)\r\n    }\r", "name": "getPathStatus", "func_location": "GitRepository.subscribeToBuffer.getBufferPathStatus.(unnamed_function_5)", "args": ["bufferPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 498, "func_start_line": 496}}, {"func_info": {"comment": [], "name": "PackageTranspilationRegistry.getPackageTranspilerSpecForFilePath", "params": ["filePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js", "end_line": 110, "start_line": 78}, "call_info": {"func_end_line": 74, "code": "      shouldCompile: (sourceCode, filePath) => {\r\n        if (this.transpilerPaths[filePath]) {\r\n          return false\r\n        }\r\n        const spec = this.getPackageTranspilerSpecForFilePath(filePath)\r\n        if (spec) {\r\n          return true\r\n        }\r\n\r\n        return transpiler.shouldCompile(sourceCode, filePath)\r\n      }\r", "name": "getPackageTranspilerSpecForFilePath", "func_location": "shouldCompile.(unnamed_function_5)", "args": ["filePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js", "line": 68, "func_start_line": 64}}, {"func_info": {"comment": [], "name": "HistoryProject.constructor", "params": ["paths", "lastOpened"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "end_line": 121, "start_line": 118}, "call_info": {"func_end_line": 96, "code": "      this.projects = history.projects.filter(p => Array.isArray(p.paths) && p.paths.length > 0).map(p => new HistoryProject(p.paths, new Date(p.lastOpened)))\r", "name": "constructor", "func_location": "HistoryManager.loadState.(unnamed_function_5)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "line": 96, "func_start_line": 96}}, {"func_info": {"comment": [], "name": "Project.subscribeToBuffer", "params": ["buffer"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 781, "start_line": 762}, "call_info": {"func_end_line": 142, "code": "    return Promise.all(bufferPromises).then(buffers => {\r\n      this.buffers = buffers.filter(Boolean)\r\n      for (let buffer of this.buffers) {\r\n        this.grammarRegistry.maintainLanguageMode(buffer)\r\n        this.subscribeToBuffer(buffer)\r\n      }\r\n      this.setPaths(state.paths || [], {mustExist: true, exact: true})\r\n    })\r", "name": "subscribeToBuffer", "func_location": "Project.deserialize.(unnamed_function_5)", "args": ["buffer"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 139, "func_start_line": 135}}, {"func_info": {"comment": [" Public: Set the paths of the project's directories.", "", " * `projectPaths` {Array} of {String} paths.", " * `options` An optional {Object} that may contain the following keys:", "   * `mustExist` If `true`, throw an Error if any `projectPaths` do not exist. Any remaining `projectPaths` that", "     do exist will still be added to the project. Default: `false`.", "   * `exact` If `true`, only add a `projectPath` if it names an existing directory. If `false` and any `projectPath`", "     is a file or does not exist, its parent directory will be added instead. Default: `false`."], "name": "Project.setPaths", "params": ["projectPaths", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 371, "start_line": 339}, "call_info": {"func_end_line": 142, "code": "    return Promise.all(bufferPromises).then(buffers => {\r\n      this.buffers = buffers.filter(Boolean)\r\n      for (let buffer of this.buffers) {\r\n        this.grammarRegistry.maintainLanguageMode(buffer)\r\n        this.subscribeToBuffer(buffer)\r\n      }\r\n      this.setPaths(state.paths || [], {mustExist: true, exact: true})\r\n    })\r", "name": "setPaths", "func_location": "Project.deserialize.(unnamed_function_5)", "args": [null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 141, "func_start_line": 135}}, {"func_info": {"comment": [], "name": "TreeSitterLanguageMode.getFoldableRangeForNode", "params": ["node", "grammar", "existenceOnly"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 377, "start_line": 318}, "call_info": {"func_end_line": 296, "code": "    this._forEachTreeWithRange(new Range(point, point), (tree, grammar) => {\r\n      let node = tree.rootNode.descendantForPosition(this.buffer.clipPosition(point))\r\n      while (node) {\r\n        if (existenceOnly && node.startPosition.row < point.row) return\r\n        if (node.endPosition.row > point.row) {\r\n          const range = this.getFoldableRangeForNode(node, grammar)\r\n          if (range && rangeIsSmaller(range, smallestRange)) {\r\n            smallestRange = range\r\n            return\r\n          }\r\n        }\r\n        node = node.parent\r\n      }\r\n    })\r", "name": "getFoldableRangeForNode", "func_location": "TreeSitterLanguageMode.getFoldableRangeContainingPoint.(unnamed_function_5)", "args": ["node", "grammar"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 288, "func_start_line": 283}}, {"func_info": {"comment": [" Return true iff `mouse` is smaller than `house`. Only correct if", " mouse and house overlap.", "", " * `mouse` {Range}", " * `house` {Range}"], "name": "rangeIsSmaller", "params": ["mouse", "house"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1184, "start_line": 1179}, "call_info": {"func_end_line": 296, "code": "    this._forEachTreeWithRange(new Range(point, point), (tree, grammar) => {\r\n      let node = tree.rootNode.descendantForPosition(this.buffer.clipPosition(point))\r\n      while (node) {\r\n        if (existenceOnly && node.startPosition.row < point.row) return\r\n        if (node.endPosition.row > point.row) {\r\n          const range = this.getFoldableRangeForNode(node, grammar)\r\n          if (range && rangeIsSmaller(range, smallestRange)) {\r\n            smallestRange = range\r\n            return\r\n          }\r\n        }\r\n        node = node.parent\r\n      }\r\n    })\r", "name": "rangeIsSmaller", "func_location": "TreeSitterLanguageMode.getFoldableRangeContainingPoint.(unnamed_function_5)", "args": ["range", "smallestRange"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 289, "func_start_line": 283}}, {"func_info": {"comment": [], "name": "AtomEnvironment.saveState", "params": ["options", "storageKey"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1208, "start_line": 1198}, "call_info": {"func_end_line": 284, "code": "      this.window.requestIdleCallback(() => {\r\n        if (!this.unloading) this.saveState({isUnloading: false})\r\n      })\r", "name": "saveState", "func_location": "AtomEnvironment.attachSaveStateListeners.saveState.(unnamed_function_4).(unnamed_function_5)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 283, "func_start_line": 282}}, {"func_info": {"comment": [], "name": "Package.activateResources", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 324, "start_line": 297}, "call_info": {"func_end_line": 205, "code": "        this.measure('activateTime', () => {\r\n          try {\r\n            this.activateResources()\r\n            if (this.activationShouldBeDeferred()) {\r\n              return this.subscribeToDeferredActivation()\r\n            } else {\r\n              return this.activateNow()\r\n            }\r\n          } catch (error) {\r\n            return this.handleError(`Failed to activate the ${this.name} package`, error)\r\n          }\r\n        })\r", "name": "activateResources", "func_location": "Package.activate.(unnamed_function_4).(unnamed_function_5)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 196, "func_start_line": 194}}, {"func_info": {"comment": [], "name": "Package.activationShouldBeDeferred", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 807, "start_line": 805}, "call_info": {"func_end_line": 205, "code": "        this.measure('activateTime', () => {\r\n          try {\r\n            this.activateResources()\r\n            if (this.activationShouldBeDeferred()) {\r\n              return this.subscribeToDeferredActivation()\r\n            } else {\r\n              return this.activateNow()\r\n            }\r\n          } catch (error) {\r\n            return this.handleError(`Failed to activate the ${this.name} package`, error)\r\n          }\r\n        })\r", "name": "activationShouldBeDeferred", "func_location": "Package.activate.(unnamed_function_4).(unnamed_function_5)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 197, "func_start_line": 194}}, {"func_info": {"comment": [], "name": "Package.subscribeToDeferredActivation", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 831, "start_line": 828}, "call_info": {"func_end_line": 205, "code": "        this.measure('activateTime', () => {\r\n          try {\r\n            this.activateResources()\r\n            if (this.activationShouldBeDeferred()) {\r\n              return this.subscribeToDeferredActivation()\r\n            } else {\r\n              return this.activateNow()\r\n            }\r\n          } catch (error) {\r\n            return this.handleError(`Failed to activate the ${this.name} package`, error)\r\n          }\r\n        })\r", "name": "subscribeToDeferredActivation", "func_location": "Package.activate.(unnamed_function_4).(unnamed_function_5)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 198, "func_start_line": 194}}, {"func_info": {"comment": [], "name": "Package.activateNow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 236, "start_line": 212}, "call_info": {"func_end_line": 205, "code": "        this.measure('activateTime', () => {\r\n          try {\r\n            this.activateResources()\r\n            if (this.activationShouldBeDeferred()) {\r\n              return this.subscribeToDeferredActivation()\r\n            } else {\r\n              return this.activateNow()\r\n            }\r\n          } catch (error) {\r\n            return this.handleError(`Failed to activate the ${this.name} package`, error)\r\n          }\r\n        })\r", "name": "activateNow", "func_location": "Package.activate.(unnamed_function_4).(unnamed_function_5)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 200, "func_start_line": 194}}, {"func_info": {"comment": [], "name": "Package.handleError", "params": ["message", "error"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 1105, "start_line": 1085}, "call_info": {"func_end_line": 205, "code": "        this.measure('activateTime', () => {\r\n          try {\r\n            this.activateResources()\r\n            if (this.activationShouldBeDeferred()) {\r\n              return this.subscribeToDeferredActivation()\r\n            } else {\r\n              return this.activateNow()\r\n            }\r\n          } catch (error) {\r\n            return this.handleError(`Failed to activate the ${this.name} package`, error)\r\n          }\r\n        })\r", "name": "handleError", "func_location": "Package.activate.(unnamed_function_4).(unnamed_function_5)", "args": [null, "error"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 203, "func_start_line": 194}}, {"func_info": {"comment": [], "name": "AtomApplication.restart", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1370, "start_line": 1358}, "call_info": {"func_end_line": 482, "code": "    this.disposable.add(ipcHelpers.on(ipcMain, 'restart-application', () => {\r\n      this.restart()\r\n    }))\r", "name": "restart", "func_location": "AtomApplication.handleEvents.(unnamed_function_50)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 481, "func_start_line": 480}}, {"func_info": {"comment": [], "name": "AtomApplication.getAllWindows", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 323, "start_line": 321}, "call_info": {"func_end_line": 495, "code": "    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-history-manager', event => {\r\n      for (let atomWindow of this.getAllWindows()) {\r\n        const {webContents} = atomWindow.browserWindow\r\n        if (webContents !== event.sender) webContents.send('did-change-history-manager')\r\n      }\r\n    }))\r", "name": "getAllWindows", "func_location": "AtomApplication.handleEvents.(unnamed_function_53)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 491, "func_start_line": 490}}, {"func_info": {"comment": [], "name": "HighlightComponent.performFlash", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4190, "start_line": 4172}, "call_info": {"func_end_line": 4183, "code": "      requestAnimationFrame(() => this.performFlash())\r", "name": "performFlash", "func_location": "HighlightComponent.performFlash.(unnamed_function_54)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 4183, "func_start_line": 4183}}, {"func_info": {"comment": [" Returns the {AtomWindow} for the given ipcMain event."], "name": "AtomApplication.atomWindowForEvent", "params": [["sender"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 741, "start_line": 739}, "call_info": {"func_end_line": 514, "comment": [" A request from the associated render process to open a new render process."], "code": "    this.disposable.add(ipcHelpers.on(ipcMain, 'open', (event, options) => {\r\n      const window = this.atomWindowForEvent(event)\r\n      if (options) {\r\n        if (typeof options.pathsToOpen === 'string') {\r\n          options.pathsToOpen = [options.pathsToOpen]\r\n        }\r\n\r\n        if (options.pathsToOpen && options.pathsToOpen.length > 0) {\r\n          options.window = window\r\n          this.openPaths(options)\r\n        } else {\r\n          this.addWindow(new AtomWindow(this, this.fileRecoveryService, options))\r\n        }\r\n      } else {\r\n        this.promptForPathToOpen('all', {window})\r\n      }\r\n    }))\r", "name": "atomWindowForEvent", "func_location": "AtomApplication.handleEvents.(unnamed_function_54)", "args": ["event"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 499, "func_start_line": 498}}, {"func_info": {"comment": [" Public: Opens multiple paths, in existing windows if possible.", "", " options -", "   :pathsToOpen - The array of file paths to open", "   :pidToKillWhenClosed - The integer of the pid to kill", "   :newWindow - Boolean of whether this should be opened in a new window.", "   :devMode - Boolean to control the opened window's dev mode.", "   :safeMode - Boolean to control the opened window's safe mode.", "   :windowDimensions - Object with height and width keys.", "   :window - {AtomWindow} to open file paths in.", "   :addToLastWindow - Boolean of whether this should be opened in last focused window."], "name": "AtomApplication.openPaths", "params": [["initialPaths", "pathsToOpen", "executedFrom", "pidToKillWhenClosed", "newWindow", "devMode", "safeMode", "windowDimensions", "profileStartup", "window", "clearWindowState", "addToLastWindow", "env"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 925, "start_line": 825}, "call_info": {"func_end_line": 514, "comment": [" A request from the associated render process to open a new render process."], "code": "    this.disposable.add(ipcHelpers.on(ipcMain, 'open', (event, options) => {\r\n      const window = this.atomWindowForEvent(event)\r\n      if (options) {\r\n        if (typeof options.pathsToOpen === 'string') {\r\n          options.pathsToOpen = [options.pathsToOpen]\r\n        }\r\n\r\n        if (options.pathsToOpen && options.pathsToOpen.length > 0) {\r\n          options.window = window\r\n          this.openPaths(options)\r\n        } else {\r\n          this.addWindow(new AtomWindow(this, this.fileRecoveryService, options))\r\n        }\r\n      } else {\r\n        this.promptForPathToOpen('all', {window})\r\n      }\r\n    }))\r", "name": "openPaths", "func_location": "AtomApplication.handleEvents.(unnamed_function_54)", "args": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 507, "func_start_line": 498}}, {"func_info": {"comment": [" Public: Adds the {AtomWindow} to the global window list."], "name": "AtomApplication.addWindow", "params": ["window"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 319, "start_line": 299}, "call_info": {"func_end_line": 514, "comment": [" A request from the associated render process to open a new render process."], "code": "    this.disposable.add(ipcHelpers.on(ipcMain, 'open', (event, options) => {\r\n      const window = this.atomWindowForEvent(event)\r\n      if (options) {\r\n        if (typeof options.pathsToOpen === 'string') {\r\n          options.pathsToOpen = [options.pathsToOpen]\r\n        }\r\n\r\n        if (options.pathsToOpen && options.pathsToOpen.length > 0) {\r\n          options.window = window\r\n          this.openPaths(options)\r\n        } else {\r\n          this.addWindow(new AtomWindow(this, this.fileRecoveryService, options))\r\n        }\r\n      } else {\r\n        this.promptForPathToOpen('all', {window})\r\n      }\r\n    }))\r", "name": "addWindow", "func_location": "AtomApplication.handleEvents.(unnamed_function_54)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 509, "func_start_line": 498}}, {"func_info": {"comment": [" Opens a native dialog to prompt the user for a path.", "", " Once paths are selected, they're opened in a new or existing {AtomWindow}s.", "", " options -", "   :type - A String which specifies the type of the dialog, could be 'file',", "           'folder' or 'all'. The 'all' is only available on macOS.", "   :devMode - A Boolean which controls whether any newly opened windows", "              should be in dev mode or not.", "   :safeMode - A Boolean which controls whether any newly opened windows", "               should be in safe mode or not.", "   :window - An {AtomWindow} to use for opening a selected file path.", "   :path - An optional String which controls the default path to which the", "           file dialog opens."], "name": "AtomApplication.promptForPathToOpen", "params": ["type", ["devMode", "safeMode", "window"], "path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1317, "start_line": 1309}, "call_info": {"func_end_line": 514, "comment": [" A request from the associated render process to open a new render process."], "code": "    this.disposable.add(ipcHelpers.on(ipcMain, 'open', (event, options) => {\r\n      const window = this.atomWindowForEvent(event)\r\n      if (options) {\r\n        if (typeof options.pathsToOpen === 'string') {\r\n          options.pathsToOpen = [options.pathsToOpen]\r\n        }\r\n\r\n        if (options.pathsToOpen && options.pathsToOpen.length > 0) {\r\n          options.window = window\r\n          this.openPaths(options)\r\n        } else {\r\n          this.addWindow(new AtomWindow(this, this.fileRecoveryService, options))\r\n        }\r\n      } else {\r\n        this.promptForPathToOpen('all', {window})\r\n      }\r\n    }))\r", "name": "promptForPathToOpen", "func_location": "AtomApplication.handleEvents.(unnamed_function_54)", "args": [{"type": "string"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 512, "func_start_line": 498}}, {"func_info": {"comment": [" Opens up a new {AtomWindow} to run specs within.", "", " options -", "   :headless - A Boolean that, if true, will close the window upon", "                   completion.", "   :resourcePath - The path to include specs from.", "   :specPath - The directory to load specs from.", "   :safeMode - A Boolean that, if true, won't run specs from ~/.atom/packages", "               and ~/.atom/dev/packages, defaults to false."], "name": "AtomApplication.runTests", "params": [["headless", "resourcePath", "executedFrom", "pathsToOpen", "logFile", "safeMode", "timeout", "env"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1179, "start_line": 1117}, "call_info": {"func_end_line": 527, "name": "runTests", "func_location": "AtomApplication.handleEvents.(unnamed_function_56)", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 522, "func_start_line": 521}}, {"func_info": {"comment": [], "name": "AtomApplication.runBenchmarks", "params": [["headless", "test", "resourcePath", "executedFrom", "pathsToOpen", "env"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1225, "start_line": 1181}, "call_info": {"func_end_line": 536, "name": "runBenchmarks", "func_location": "AtomApplication.handleEvents.(unnamed_function_57)", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 530, "func_start_line": 529}}, {"func_info": {"comment": [" Opens a native dialog to prompt the user for a path.", "", " Once paths are selected, they're opened in a new or existing {AtomWindow}s.", "", " options -", "   :type - A String which specifies the type of the dialog, could be 'file',", "           'folder' or 'all'. The 'all' is only available on macOS.", "   :devMode - A Boolean which controls whether any newly opened windows", "              should be in dev mode or not.", "   :safeMode - A Boolean which controls whether any newly opened windows", "               should be in safe mode or not.", "   :window - An {AtomWindow} to use for opening a selected file path.", "   :path - An optional String which controls the default path to which the", "           file dialog opens."], "name": "AtomApplication.promptForPathToOpen", "params": ["type", ["devMode", "safeMode", "window"], "path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1317, "start_line": 1309}, "call_info": {"func_end_line": 553, "code": "    this.disposable.add(ipcHelpers.on(ipcMain, 'open-command', (event, command, defaultPath) => {\r\n      switch (command) {\r\n        case 'application:open':\r\n          return this.promptForPathToOpen('all', getLoadSettings(), defaultPath)\r\n        case 'application:open-file':\r\n          return this.promptForPathToOpen('file', getLoadSettings(), defaultPath)\r\n        case 'application:open-folder':\r\n          return this.promptForPathToOpen('folder', getLoadSettings(), defaultPath)\r\n        default:\r\n          return console.log(`Invalid open-command received: ${command}`)\r\n      }\r\n    }))\r", "name": "promptForPathToOpen", "func_location": "AtomApplication.handleEvents.(unnamed_function_59)", "args": [{"type": "string"}, null, "defaultPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 545, "func_start_line": 542}}, {"func_info": {"comment": [" Opens a native dialog to prompt the user for a path.", "", " Once paths are selected, they're opened in a new or existing {AtomWindow}s.", "", " options -", "   :type - A String which specifies the type of the dialog, could be 'file',", "           'folder' or 'all'. The 'all' is only available on macOS.", "   :devMode - A Boolean which controls whether any newly opened windows", "              should be in dev mode or not.", "   :safeMode - A Boolean which controls whether any newly opened windows", "               should be in safe mode or not.", "   :window - An {AtomWindow} to use for opening a selected file path.", "   :path - An optional String which controls the default path to which the", "           file dialog opens."], "name": "AtomApplication.promptForPathToOpen", "params": ["type", ["devMode", "safeMode", "window"], "path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1317, "start_line": 1309}, "call_info": {"func_end_line": 553, "code": "    this.disposable.add(ipcHelpers.on(ipcMain, 'open-command', (event, command, defaultPath) => {\r\n      switch (command) {\r\n        case 'application:open':\r\n          return this.promptForPathToOpen('all', getLoadSettings(), defaultPath)\r\n        case 'application:open-file':\r\n          return this.promptForPathToOpen('file', getLoadSettings(), defaultPath)\r\n        case 'application:open-folder':\r\n          return this.promptForPathToOpen('folder', getLoadSettings(), defaultPath)\r\n        default:\r\n          return console.log(`Invalid open-command received: ${command}`)\r\n      }\r\n    }))\r", "name": "promptForPathToOpen", "func_location": "AtomApplication.handleEvents.(unnamed_function_59)", "args": [{"type": "string"}, null, "defaultPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 547, "func_start_line": 542}}, {"func_info": {"comment": [" Opens a native dialog to prompt the user for a path.", "", " Once paths are selected, they're opened in a new or existing {AtomWindow}s.", "", " options -", "   :type - A String which specifies the type of the dialog, could be 'file',", "           'folder' or 'all'. The 'all' is only available on macOS.", "   :devMode - A Boolean which controls whether any newly opened windows", "              should be in dev mode or not.", "   :safeMode - A Boolean which controls whether any newly opened windows", "               should be in safe mode or not.", "   :window - An {AtomWindow} to use for opening a selected file path.", "   :path - An optional String which controls the default path to which the", "           file dialog opens."], "name": "AtomApplication.promptForPathToOpen", "params": ["type", ["devMode", "safeMode", "window"], "path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1317, "start_line": 1309}, "call_info": {"func_end_line": 553, "code": "    this.disposable.add(ipcHelpers.on(ipcMain, 'open-command', (event, command, defaultPath) => {\r\n      switch (command) {\r\n        case 'application:open':\r\n          return this.promptForPathToOpen('all', getLoadSettings(), defaultPath)\r\n        case 'application:open-file':\r\n          return this.promptForPathToOpen('file', getLoadSettings(), defaultPath)\r\n        case 'application:open-folder':\r\n          return this.promptForPathToOpen('folder', getLoadSettings(), defaultPath)\r\n        default:\r\n          return console.log(`Invalid open-command received: ${command}`)\r\n      }\r\n    }))\r", "name": "promptForPathToOpen", "func_location": "AtomApplication.handleEvents.(unnamed_function_59)", "args": [{"type": "string"}, null, "defaultPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 549, "func_start_line": 542}}, {"func_info": {"comment": [" Private: Callback function invoked by the native watcher when a debounced group of filesystem events arrive.", " Normalize and re-broadcast them to any subscribers.", "", " * `events` An Array of filesystem events."], "name": "NativeWatcher.onEvents", "params": ["events"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js", "end_line": 159, "start_line": 157}, "call_info": {"func_end_line": 195, "code": "      const announce = (action, oldPath) => {\r\n        const payload = {action, path: realPath}\r\n        if (oldPath) payload.oldPath = oldPath\r\n        this.onEvents([payload])\r\n      }\r", "name": "onEvents", "func_location": "AtomNativeWatcher.doStart.(unnamed_function_5).announce.(unnamed_function_6)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js", "line": 194, "func_start_line": 191}}, {"func_info": {"comment": [], "name": "AutoUpdateManager.scheduleUpdateCheck", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "end_line": 127, "start_line": 118}, "call_info": {"func_end_line": 77, "code": "    this.config.onDidChange('core.automaticallyUpdate', ({newValue}) => {\r\n      if (newValue) {\r\n        this.scheduleUpdateCheck()\r\n      } else {\r\n        this.cancelScheduledUpdateCheck()\r\n      }\r\n    })\r", "name": "scheduleUpdateCheck", "func_location": "AutoUpdateManager.initialize.(unnamed_function_6)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "line": 73, "func_start_line": 71}}, {"func_info": {"comment": [], "name": "AutoUpdateManager.cancelScheduledUpdateCheck", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "end_line": 134, "start_line": 129}, "call_info": {"func_end_line": 77, "code": "    this.config.onDidChange('core.automaticallyUpdate', ({newValue}) => {\r\n      if (newValue) {\r\n        this.scheduleUpdateCheck()\r\n      } else {\r\n        this.cancelScheduledUpdateCheck()\r\n      }\r\n    })\r", "name": "cancelScheduledUpdateCheck", "func_location": "AutoUpdateManager.initialize.(unnamed_function_6)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "line": 75, "func_start_line": 71}}, {"func_info": {"comment": [" Extended: Returns the {String} character set encoding of this editor's text", " buffer."], "name": "TextEditor.getEncoding", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 1152, "start_line": 1152}, "call_info": {"func_end_line": 590, "code": "    this.disposables.add(this.buffer.onDidChangeEncoding(() => {\r\n      this.emitter.emit('did-change-encoding', this.getEncoding())\r\n    }))\r", "name": "getEncoding", "func_location": "TextEditor.subscribeToBuffer.(unnamed_function_6)", "args": [{"type": "string"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 589, "func_start_line": 588}}, {"func_info": {"comment": [], "name": "hasMatchingFoldSpec", "params": ["specs", "node"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1212, "start_line": 1210}, "call_info": {"func_end_line": 335, "code": "          foldStartNode = children.find(child => hasMatchingFoldSpec(startEntry.matchers, child))\r", "name": "hasMatchingFoldSpec", "func_location": "TreeSitterLanguageMode.getFoldableRangeForNode.(unnamed_function_6)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 335, "func_start_line": 335}}, {"func_info": {"comment": [], "name": "Package.handleURI", "params": ["methodName", "args"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 424, "start_line": 419}, "call_info": {"func_end_line": 411, "code": "      this.uriHandlerSubscription = this.packageManager.registerURIHandlerForPackage(this.name, (...args) =>\r\n        this.handleURI(methodName, args)\r\n      )\r", "name": "handleURI", "func_location": "Package.registerURIHandler.(unnamed_function_6)", "args": ["methodName", "args"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 410, "func_start_line": 409}}, {"func_info": {"comment": [" Public: Get the active {Package} with the given name.", "", " * `name` - The {String} package name.", "", " Returns a {Package} or undefined."], "name": "PackageManager.getActivePackage", "params": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 302, "start_line": 300}, "call_info": {"func_end_line": 452, "code": "      packagesToDisable.forEach(name => { if (this.getActivePackage(name)) this.deactivatePackage(name) })\r", "name": "getActivePackage", "func_location": "PackageManager.observeDisabledPackages.(unnamed_function_5).(unnamed_function_6)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 452, "func_start_line": 452}}, {"func_info": {"comment": [" Deactivate the package with the given name"], "name": "PackageManager.deactivatePackage", "params": ["name", "suppressSerialization"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 797, "start_line": 779}, "call_info": {"func_end_line": 452, "code": "      packagesToDisable.forEach(name => { if (this.getActivePackage(name)) this.deactivatePackage(name) })\r", "name": "deactivatePackage", "func_location": "PackageManager.observeDisabledPackages.(unnamed_function_5).(unnamed_function_6)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 452, "func_start_line": 452}}, {"func_info": {"comment": [], "name": "AtomApplication.promptForRestart", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1356, "start_line": 1349}, "call_info": {"func_end_line": 176, "code": "      this.config.onDidChange('core.titleBar', () => this.promptForRestart())\r", "name": "promptForRestart", "func_location": "AtomApplication.launch.(unnamed_function_6)", "args": [{"type": "string"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 176, "func_start_line": 176}}, {"func_info": {"comment": [], "name": "PaneAxis.removeChild", "params": ["child", "replacing"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js", "end_line": 149, "start_line": 137}, "call_info": {"func_end_line": 181, "code": "    const subscription = child.onDidDestroy(() => this.removeChild(child))\r", "name": "removeChild", "func_location": "PaneAxis.subscribeToChild.subscription.(unnamed_function_6)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js", "line": 181, "func_start_line": 181}}, {"func_info": {"comment": [], "name": "CommandInstaller.createSymlink", "params": ["fs", "sourcePath", "destinationPath", "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js", "end_line": 101, "start_line": 93}, "call_info": {"func_end_line": 90, "name": "createSymlink", "func_location": "CommandInstaller.installCommand.(unnamed_function_6)", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js", "line": 82, "func_start_line": 79}}, {"func_info": {"comment": [], "name": "AtomApplication.atomWindowForBrowserWindow", "params": ["browserWindow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 745, "start_line": 743}, "call_info": {"func_end_line": 563, "code": "    this.disposable.add(ipcHelpers.respondTo('window-method', (browserWindow, method, ...args) => {\r\n      const window = this.atomWindowForBrowserWindow(browserWindow)\r\n      if (window) window[method](...args)\r\n    }))\r", "name": "atomWindowForBrowserWindow", "func_location": "AtomApplication.handleEvents.(unnamed_function_61)", "args": ["browserWindow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 561, "func_start_line": 560}}, {"func_info": {"comment": [], "name": "AtomApplication.promptForPath", "params": ["type", "callback", "path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1347, "start_line": 1319}, "call_info": {"func_end_line": 567, "code": "    this.disposable.add(ipcHelpers.on(ipcMain, 'pick-folder', (event, responseChannel) => {\r\n      this.promptForPath('folder', paths => event.sender.send(responseChannel, paths))\r\n    }))\r", "name": "promptForPath", "func_location": "AtomApplication.handleEvents.(unnamed_function_62)", "args": [{"type": "string"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 566, "func_start_line": 565}}, {"func_info": {"comment": [" Extended: Returns a {Number} representing how well the grammar matches the", " `filePath` and `contents`."], "name": "GrammarRegistry.getGrammarScore", "params": ["grammar", "filePath", "contents"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 242, "start_line": 206}, "call_info": {"func_end_line": 200, "code": "    this.forEachGrammar(grammar => {\r\n      const score = this.getGrammarScore(grammar, filePath, fileContents)\r\n      if (score > highestScore || bestMatch == null) {\r\n        bestMatch = grammar\r\n        highestScore = score\r\n      }\r\n    })\r", "name": "getGrammarScore", "func_location": "GrammarRegistry.selectGrammarWithScore.(unnamed_function_7)", "args": ["grammar", "filePath", "fileContents"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 195, "func_start_line": 194}}, {"func_info": {"comment": [], "name": "AutoUpdateManager.check", "params": [["hidePopups"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "end_line": 143, "start_line": 136}, "call_info": {"func_end_line": 123, "name": "check", "func_location": "AutoUpdateManager.scheduleUpdateCheck.checkForUpdates.(unnamed_function_7)", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "line": 122, "func_start_line": 122}}, {"func_info": {"comment": [], "name": "TextEditor.destroy", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 636, "start_line": 621}, "call_info": {"func_end_line": 591, "code": "    this.disposables.add(this.buffer.onDidDestroy(() => this.destroy()))\r", "name": "destroy", "func_location": "TextEditor.subscribeToBuffer.(unnamed_function_7)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 591, "func_start_line": 591}}, {"func_info": {"comment": [], "name": "Config.setDefaults", "params": ["keyPath", "defaults"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1090, "start_line": 1070}, "call_info": {"func_end_line": 920, "code": "    this.transact(() => {\r\n      this.setDefaults(keyPath, this.extractDefaultsFromSchema(schema))\r\n      this.setScopedDefaultsFromSchema(keyPath, schema)\r\n      this.resetSettingsForSchemaChange()\r\n    })\r", "name": "setDefaults", "func_location": "Config.setSchema.(unnamed_function_7)", "args": ["keyPath", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 917, "func_start_line": 916}}, {"func_info": {"comment": [], "name": "Config.extractDefaultsFromSchema", "params": ["schema"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1162, "start_line": 1153}, "call_info": {"func_end_line": 920, "code": "    this.transact(() => {\r\n      this.setDefaults(keyPath, this.extractDefaultsFromSchema(schema))\r\n      this.setScopedDefaultsFromSchema(keyPath, schema)\r\n      this.resetSettingsForSchemaChange()\r\n    })\r", "name": "extractDefaultsFromSchema", "func_location": "Config.setSchema.(unnamed_function_7)", "args": ["keyPath", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 917, "func_start_line": 916}}, {"func_info": {"comment": [" `schema` will look something like this", "", " ```coffee", " type: 'string'", " default: 'ok'", " scopes:", "   '.source.js':", "     default: 'omg'", " ```"], "name": "Config.setScopedDefaultsFromSchema", "params": ["keyPath", "schema"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1151, "start_line": 1131}, "call_info": {"func_end_line": 920, "code": "    this.transact(() => {\r\n      this.setDefaults(keyPath, this.extractDefaultsFromSchema(schema))\r\n      this.setScopedDefaultsFromSchema(keyPath, schema)\r\n      this.resetSettingsForSchemaChange()\r\n    })\r", "name": "setScopedDefaultsFromSchema", "func_location": "Config.setSchema.(unnamed_function_7)", "args": ["keyPath", "schema"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 918, "func_start_line": 916}}, {"func_info": {"comment": [" When the schema is changed / added, there may be values set in the config", " that do not conform to the schema. This will reset make them conform."], "name": "Config.resetSettingsForSchemaChange", "params": ["source"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1194, "start_line": 1182}, "call_info": {"func_end_line": 920, "code": "    this.transact(() => {\r\n      this.setDefaults(keyPath, this.extractDefaultsFromSchema(schema))\r\n      this.setScopedDefaultsFromSchema(keyPath, schema)\r\n      this.resetSettingsForSchemaChange()\r\n    })\r", "name": "resetSettingsForSchemaChange", "func_location": "Config.setSchema.(unnamed_function_7)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 919, "func_start_line": 916}}, {"func_info": {"comment": [], "name": "ReopenProjectMenuManager.createLabel", "params": ["project"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js", "end_line": 139, "start_line": 135}, "call_info": {"func_end_line": 129, "code": "          submenu: projects.map((project, index) => ({\r\n            label: this.createLabel(project),\r\n            command: 'application:reopen-project',\r\n            commandDetail: {index: index}\r\n          }))\r", "name": "createLabel", "func_location": "submenu.submenu.(unnamed_function_7)", "args": ["project"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js", "line": 126, "func_start_line": 125}}, {"func_info": {"comment": [], "name": "ShellOption.register", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/win-shell.js", "end_line": 31, "start_line": 25}, "call_info": {"func_end_line": 51, "code": "      .get(this.parts[0].name, (err, val) => {\r\n        if ((err != null) || (val == null)) {\r\n          callback(err)\r\n        } else {\r\n          this.register(callback)\r\n        }\r\n      })\r", "name": "register", "func_location": "ShellOption.update.(unnamed_function_7)", "args": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/win-shell.js", "line": 49, "func_start_line": 45}}, {"func_info": {"comment": [" Public: Makes a path relative to the repository's working directory."], "name": "GitRepository.relativize", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 210, "start_line": 208}, "call_info": {"func_end_line": 545, "name": "relativize", "func_location": "GitRepository.refreshStatus.relativeProjectPaths.(unnamed_function_7)", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 545, "func_start_line": 545}}, {"func_info": {"comment": [], "name": "BufferedProcess.killProcess", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "end_line": 210, "start_line": 207}, "call_info": {"func_end_line": 204, "code": "    wmicProcess.stdout.on('close', () => {\r\n      for (let pid of output.split(/\\s+/)) {\r\n        if (!/^\\d{1,10}$/.test(pid)) continue\r\n        pid = parseInt(pid, 10)\r\n\r\n        if (!pid || pid === parentPid) continue\r\n\r\n        try {\r\n          process.kill(pid)\r\n        } catch (error) {}\r\n      }\r\n\r\n      this.killProcess()\r\n    })\r", "name": "killProcess", "func_location": "BufferedProcess.killOnWindows.(unnamed_function_7)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "line": 203, "func_start_line": 191}}, {"func_info": {"comment": [], "name": "hasMatchingFoldSpec", "params": ["specs", "node"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1212, "start_line": 1210}, "call_info": {"func_end_line": 352, "code": "          foldEndNode = children.find(child => hasMatchingFoldSpec(endEntry.matchers, child))\r", "name": "hasMatchingFoldSpec", "func_location": "TreeSitterLanguageMode.getFoldableRangeForNode.(unnamed_function_7)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 352, "func_start_line": 352}}, {"func_info": {"comment": [], "name": "AtomEnvironment.getUserInitScriptPath", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1296, "start_line": 1293}, "call_info": {"func_end_line": 321, "code": "    this.workspace.addOpener(uri => {\r\n      switch (uri) {\r\n        case 'atom://.atom/stylesheet':\r\n          return this.workspace.openTextFile(this.styles.getUserStyleSheetPath())\r\n        case 'atom://.atom/keymap':\r\n          return this.workspace.openTextFile(this.keymaps.getUserKeymapPath())\r\n        case 'atom://.atom/config':\r\n          return this.workspace.openTextFile(this.config.getUserConfigPath())\r\n        case 'atom://.atom/init-script':\r\n          return this.workspace.openTextFile(this.getUserInitScriptPath())\r\n      }\r\n    })\r", "name": "getUserInitScriptPath", "func_location": "AtomEnvironment.registerDefaultOpeners.(unnamed_function_7)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 319, "func_start_line": 310}}, {"func_info": {"comment": [" Activate a single package by name"], "name": "PackageManager.activatePackage", "params": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 722, "start_line": 696}, "call_info": {"func_end_line": 453, "code": "      packagesToEnable.forEach(name => this.activatePackage(name))\r", "name": "activatePackage", "func_location": "PackageManager.observeDisabledPackages.(unnamed_function_5).(unnamed_function_7)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 453, "func_start_line": 453}}, {"func_info": {"comment": [], "name": "AtomApplication.promptForRestart", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1356, "start_line": 1349}, "call_info": {"func_end_line": 177, "code": "      this.config.onDidChange('core.colorProfile', () => this.promptForRestart())\r", "name": "promptForRestart", "func_location": "AtomApplication.launch.(unnamed_function_7)", "args": [{"type": "string"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 177, "func_start_line": 177}}, {"func_info": {"comment": [], "name": "CommandInstaller.createSymlink", "params": ["fs", "sourcePath", "destinationPath", "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js", "end_line": 101, "start_line": 93}, "call_info": {"func_end_line": 89, "code": "      this.createSymlink(fs, commandPath, destinationPath, error => {\r\n        if (error && error.code === 'EACCES' && askForPrivilege) {\r\n          const fsAdmin = require('fs-admin')\r\n          this.createSymlink(fsAdmin, commandPath, destinationPath, (error) => { callback(error, commandName) })\r\n        } else {\r\n          callback(error)\r\n        }\r\n      })\r", "name": "createSymlink", "func_location": "CommandInstaller.installCommand.(unnamed_function_6).(unnamed_function_7)", "args": ["fsAdmin", "commandPath", "destinationPath", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js", "line": 85, "func_start_line": 82}}, {"func_info": {"comment": [], "name": "GrammarRegistry.grammarForId", "params": ["languageId"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 326, "start_line": 313}, "call_info": {"func_end_line": 387, "code": "    this.grammarScoresByBuffer.forEach((score, buffer) => {\r\n      const languageMode = buffer.getLanguageMode()\r\n      const languageOverride = this.languageOverridesByBufferId.get(buffer.id)\r\n\r\n      if (grammar === buffer.getLanguageMode().grammar ||\r\n          grammar === this.grammarForId(languageOverride)) {\r\n        buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(grammar, buffer))\r\n        return\r\n      } else if (!languageOverride) {\r\n        const score = this.getGrammarScore(grammar, buffer.getPath(), getGrammarSelectionContent(buffer))\r\n        const currentScore = this.grammarScoresByBuffer.get(buffer)\r\n        if (currentScore == null || score > currentScore) {\r\n          buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(grammar, buffer))\r\n          this.grammarScoresByBuffer.set(buffer, score)\r\n          return\r\n        }\r\n      }\r\n\r\n      languageMode.updateForInjection(grammar)\r\n    })\r", "name": "grammarForId", "func_location": "GrammarRegistry.grammarAddedOrUpdated.(unnamed_function_8)", "args": ["languageOverride"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 373, "func_start_line": 368}}, {"func_info": {"comment": [], "name": "GrammarRegistry.languageModeForGrammarAndBuffer", "params": ["grammar", "buffer"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 176, "start_line": 170}, "call_info": {"func_end_line": 387, "code": "    this.grammarScoresByBuffer.forEach((score, buffer) => {\r\n      const languageMode = buffer.getLanguageMode()\r\n      const languageOverride = this.languageOverridesByBufferId.get(buffer.id)\r\n\r\n      if (grammar === buffer.getLanguageMode().grammar ||\r\n          grammar === this.grammarForId(languageOverride)) {\r\n        buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(grammar, buffer))\r\n        return\r\n      } else if (!languageOverride) {\r\n        const score = this.getGrammarScore(grammar, buffer.getPath(), getGrammarSelectionContent(buffer))\r\n        const currentScore = this.grammarScoresByBuffer.get(buffer)\r\n        if (currentScore == null || score > currentScore) {\r\n          buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(grammar, buffer))\r\n          this.grammarScoresByBuffer.set(buffer, score)\r\n          return\r\n        }\r\n      }\r\n\r\n      languageMode.updateForInjection(grammar)\r\n    })\r", "name": "languageModeForGrammarAndBuffer", "func_location": "GrammarRegistry.grammarAddedOrUpdated.(unnamed_function_8)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 374, "func_start_line": 368}}, {"func_info": {"comment": [" Extended: Returns a {Number} representing how well the grammar matches the", " `filePath` and `contents`."], "name": "GrammarRegistry.getGrammarScore", "params": ["grammar", "filePath", "contents"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 242, "start_line": 206}, "call_info": {"func_end_line": 387, "code": "    this.grammarScoresByBuffer.forEach((score, buffer) => {\r\n      const languageMode = buffer.getLanguageMode()\r\n      const languageOverride = this.languageOverridesByBufferId.get(buffer.id)\r\n\r\n      if (grammar === buffer.getLanguageMode().grammar ||\r\n          grammar === this.grammarForId(languageOverride)) {\r\n        buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(grammar, buffer))\r\n        return\r\n      } else if (!languageOverride) {\r\n        const score = this.getGrammarScore(grammar, buffer.getPath(), getGrammarSelectionContent(buffer))\r\n        const currentScore = this.grammarScoresByBuffer.get(buffer)\r\n        if (currentScore == null || score > currentScore) {\r\n          buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(grammar, buffer))\r\n          this.grammarScoresByBuffer.set(buffer, score)\r\n          return\r\n        }\r\n      }\r\n\r\n      languageMode.updateForInjection(grammar)\r\n    })\r", "name": "getGrammarScore", "func_location": "GrammarRegistry.grammarAddedOrUpdated.(unnamed_function_8)", "args": ["grammar", null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 377, "func_start_line": 368}}, {"func_info": {"comment": [], "name": "getGrammarSelectionContent", "params": ["buffer"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 592, "start_line": 587}, "call_info": {"func_end_line": 387, "code": "    this.grammarScoresByBuffer.forEach((score, buffer) => {\r\n      const languageMode = buffer.getLanguageMode()\r\n      const languageOverride = this.languageOverridesByBufferId.get(buffer.id)\r\n\r\n      if (grammar === buffer.getLanguageMode().grammar ||\r\n          grammar === this.grammarForId(languageOverride)) {\r\n        buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(grammar, buffer))\r\n        return\r\n      } else if (!languageOverride) {\r\n        const score = this.getGrammarScore(grammar, buffer.getPath(), getGrammarSelectionContent(buffer))\r\n        const currentScore = this.grammarScoresByBuffer.get(buffer)\r\n        if (currentScore == null || score > currentScore) {\r\n          buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(grammar, buffer))\r\n          this.grammarScoresByBuffer.set(buffer, score)\r\n          return\r\n        }\r\n      }\r\n\r\n      languageMode.updateForInjection(grammar)\r\n    })\r", "name": "getGrammarSelectionContent", "func_location": "GrammarRegistry.grammarAddedOrUpdated.(unnamed_function_8)", "args": ["grammar", null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 377, "func_start_line": 368}}, {"func_info": {"comment": [], "name": "GrammarRegistry.languageModeForGrammarAndBuffer", "params": ["grammar", "buffer"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 176, "start_line": 170}, "call_info": {"func_end_line": 387, "code": "    this.grammarScoresByBuffer.forEach((score, buffer) => {\r\n      const languageMode = buffer.getLanguageMode()\r\n      const languageOverride = this.languageOverridesByBufferId.get(buffer.id)\r\n\r\n      if (grammar === buffer.getLanguageMode().grammar ||\r\n          grammar === this.grammarForId(languageOverride)) {\r\n        buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(grammar, buffer))\r\n        return\r\n      } else if (!languageOverride) {\r\n        const score = this.getGrammarScore(grammar, buffer.getPath(), getGrammarSelectionContent(buffer))\r\n        const currentScore = this.grammarScoresByBuffer.get(buffer)\r\n        if (currentScore == null || score > currentScore) {\r\n          buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(grammar, buffer))\r\n          this.grammarScoresByBuffer.set(buffer, score)\r\n          return\r\n        }\r\n      }\r\n\r\n      languageMode.updateForInjection(grammar)\r\n    })\r", "name": "languageModeForGrammarAndBuffer", "func_location": "GrammarRegistry.grammarAddedOrUpdated.(unnamed_function_8)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 380, "func_start_line": 368}}, {"func_info": {"comment": [], "name": "TextEditor.terminatePendingState", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 600, "start_line": 597}, "call_info": {"func_end_line": 594, "code": "    this.disposables.add(this.buffer.onDidChangeModified(() => {\r\n      if (!this.hasTerminatedPendingState && this.buffer.isModified()) this.terminatePendingState()\r\n    }))\r", "name": "terminatePendingState", "func_location": "TextEditor.subscribeToBuffer.(unnamed_function_8)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 593, "func_start_line": 592}}, {"func_info": {"comment": [], "name": "WorkspaceElement.boundingBoxForPaneView", "params": ["paneView"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 311, "start_line": 302}, "call_info": {"func_end_line": 288, "code": "      .filter(otherPaneView => {\r\n        const otherBox = this.boundingBoxForPaneView(otherPaneView)\r\n        switch (direction) {\r\n          case 'left': return otherBox.right.x <= box.left.x\r\n          case 'right': return otherBox.left.x >= box.right.x\r\n          case 'above': return otherBox.bottom.y <= box.top.y\r\n          case 'below': return otherBox.top.y >= box.bottom.y\r\n        }\r\n      }).sort((paneViewA, paneViewB) => {\r", "name": "boundingBoxForPaneView", "func_location": "WorkspaceElement.nearestVisiblePaneInDirection.paneViews.(unnamed_function_8)", "args": ["otherPaneView"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 281, "func_start_line": 280}}, {"func_info": {"comment": [], "name": "Config._clearUnscopedSettingsForSource", "params": ["source"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 975, "start_line": 969}, "call_info": {"func_end_line": 966, "code": "    return this.transact(() => {\r\n      this._clearUnscopedSettingsForSource(source)\r\n      this.settingsLoaded = true\r\n      for (let key in newSettings) {\r\n        const value = newSettings[key]\r\n        this.set(key, value, {save: false, source})\r\n      }\r\n      if (this.pendingOperations.length) {\r\n        for (let op of this.pendingOperations) { op() }\r\n        this.pendingOperations = []\r\n      }\r\n    })\r", "name": "_clearUnscopedSettingsForSource", "func_location": "Config._resetSettings.(unnamed_function_8)", "args": ["source"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 956, "func_start_line": 955}}, {"func_info": {"comment": [" Essential: Sets the value for a configuration setting.", "", " This value is stored in Atom's internal configuration file.", "", " ### Examples", "", " You might want to change the themes programmatically:", "", " ```coffee", " atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])", " ```", "", " You can also set scoped settings. For example, you might want change the", " `editor.tabLength` only for ruby files.", "", " ```coffee", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4", " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4", "", " # Set ruby to 2", " atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true", "", " # Notice it's only set to 2 in the case of ruby", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4", " ```", "", " * `keyPath` The {String} name of the key.", " * `value` The value of the setting. Passing `undefined` will revert the", "   setting to the default value.", " * `options` (optional) {Object}", "   * `scopeSelector` (optional) {String}. eg. '.source.ruby'", "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)", "     for more information.", "   * `source` (optional) {String} The name of a file with which the setting", "     is associated. Defaults to the user's config file.", "", " Returns a {Boolean}", " * `true` if the value was set.", " * `false` if the value was not able to be coerced to the type specified in the setting's schema."], "name": "Config.set", "params": ["args"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 722, "start_line": 687}, "call_info": {"func_end_line": 966, "code": "    return this.transact(() => {\r\n      this._clearUnscopedSettingsForSource(source)\r\n      this.settingsLoaded = true\r\n      for (let key in newSettings) {\r\n        const value = newSettings[key]\r\n        this.set(key, value, {save: false, source})\r\n      }\r\n      if (this.pendingOperations.length) {\r\n        for (let op of this.pendingOperations) { op() }\r\n        this.pendingOperations = []\r\n      }\r\n    })\r", "name": "set", "func_location": "Config._resetSettings.(unnamed_function_8)", "args": ["key", "value", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 960, "func_start_line": 955}}, {"func_info": {"comment": [], "name": "BufferedProcess.handleError", "params": ["error"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "end_line": 312, "start_line": 297}, "call_info": {"func_end_line": 248, "code": "      process.nextTick(() => this.handleError(spawnError))\r", "name": "handleError", "func_location": "BufferedProcess.spawn.(unnamed_function_8)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "line": 248, "func_start_line": 248}}, {"func_info": {"comment": [], "name": "AtomEnvironment.setAutoHideMenuBar", "params": ["autoHide"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1333, "start_line": 1330}, "call_info": {"func_end_line": 331, "code": "    this.disposables.add(this.config.onDidChange('core.autoHideMenuBar', ({newValue}) => {\r\n      this.setAutoHideMenuBar(newValue)\r\n    }))\r", "name": "setAutoHideMenuBar", "func_location": "AtomEnvironment.observeAutoHideMenuBar.(unnamed_function_8)", "args": ["newValue"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 330, "func_start_line": 329}}, {"func_info": {"comment": [" Public: Get the loaded {Package} with the given name.", "", " * `name` - The {String} package name.", "", " Returns a {Package} or undefined."], "name": "PackageManager.getLoadedPackage", "params": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 341, "start_line": 339}, "call_info": {"func_end_line": 479, "code": "    const performOnLoadedActivePackages = (packageNames, disabledPackageNames, action) => {\r\n      for (const packageName of packageNames) {\r\n        if (!disabledPackageNames.has(packageName)) {\r\n          var pack = this.getLoadedPackage(packageName)\r\n          if (pack != null) {\r\n            action(pack)\r\n          }\r\n        }\r\n      }\r\n    }\r", "name": "getLoadedPackage", "func_location": "PackageManager.observePackagesWithKeymapsDisabled.performOnLoadedActivePackages.(unnamed_function_8)", "args": ["packageName"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 473, "func_start_line": 470}}, {"func_info": {"comment": [], "name": "AtomApplication.openWithOptions", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 281, "start_line": 207}, "call_info": {"func_end_line": 204, "code": "    return optionsForWindowsToOpen.map(options => this.openWithOptions(options))\r", "name": "openWithOptions", "func_location": "AtomApplication.launch.(unnamed_function_8)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 204, "func_start_line": 204}}, {"func_info": {"comment": [], "name": "Pane.removeItem", "params": ["item", "moved"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 705, "start_line": 684}, "call_info": {"func_end_line": 620, "code": "      itemSubscriptions.add(item.onDidDestroy(() => this.removeItem(item, false)))\r", "name": "removeItem", "func_location": "Pane.addItem.(unnamed_function_8)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 620, "func_start_line": 620}}, {"func_info": {"comment": [], "name": "ThemeManager.loadUserStylesheet", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 218, "start_line": 185}, "call_info": {"func_end_line": 195, "name": "loadUserStylesheet", "func_location": "ThemeManager.loadUserStylesheet.reloadStylesheet.(unnamed_function_8)", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 194, "func_start_line": 194}}, {"func_info": {"comment": [], "name": "AtomApplication.saveCurrentWindowOptions", "params": ["allowEmpty"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 981, "start_line": 968}, "call_info": {"func_end_line": 631, "code": "    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-paths', () =>\r\n      this.saveCurrentWindowOptions(false)\r\n    ))\r", "name": "saveCurrentWindowOptions", "func_location": "AtomApplication.handleEvents.(unnamed_function_82)", "args": [{"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 630, "func_start_line": 629}}, {"func_info": {"comment": [" Public: Returns the currently focused {AtomWindow} or undefined if none."], "name": "AtomApplication.focusedWindow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 750, "start_line": 748}, "call_info": {"func_end_line": 728, "code": "    this.on(eventName, () => {\r\n      const window = this.focusedWindow()\r\n      if (window) {\r\n        return window.openPath(pathToOpen)\r\n      } else {\r\n        return this.openPath({pathToOpen})\r\n      }\r\n    })\r", "name": "focusedWindow", "func_location": "AtomApplication.openPathOnEvent.(unnamed_function_84)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 722, "func_start_line": 721}}, {"func_info": {"comment": [" Public: Opens a single path, in an existing window if possible.", "", " options -", "   :pathToOpen - The file path to open", "   :pidToKillWhenClosed - The integer of the pid to kill", "   :newWindow - Boolean of whether this should be opened in a new window.", "   :devMode - Boolean to control the opened window's dev mode.", "   :safeMode - Boolean to control the opened window's safe mode.", "   :profileStartup - Boolean to control creating a profile of the startup time.", "   :window - {AtomWindow} to open file paths in.", "   :addToLastWindow - Boolean of whether this should be opened in last focused window."], "name": "AtomApplication.openPath", "params": [["initialPaths", "pathToOpen", "pidToKillWhenClosed", "newWindow", "devMode", "safeMode", "profileStartup", "window", "clearWindowState", "addToLastWindow", "env"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 812, "start_line": 786}, "call_info": {"func_end_line": 728, "code": "    this.on(eventName, () => {\r\n      const window = this.focusedWindow()\r\n      if (window) {\r\n        return window.openPath(pathToOpen)\r\n      } else {\r\n        return this.openPath({pathToOpen})\r\n      }\r\n    })\r", "name": "openPath", "func_location": "AtomApplication.openPathOnEvent.(unnamed_function_84)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 726, "func_start_line": 721}}, {"func_info": {"comment": [], "name": "WorkspaceElement.boundingBoxForPaneView", "params": ["paneView"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 311, "start_line": 302}, "call_info": {"func_end_line": 297, "code": "      }).sort((paneViewA, paneViewB) => {\r\n        const boxA = this.boundingBoxForPaneView(paneViewA)\r\n        const boxB = this.boundingBoxForPaneView(paneViewB)\r\n        switch (direction) {\r\n          case 'left': return distance(box.left, boxA.right) - distance(box.left, boxB.right)\r\n          case 'right': return distance(box.right, boxA.left) - distance(box.right, boxB.left)\r\n          case 'above': return distance(box.top, boxA.bottom) - distance(box.top, boxB.bottom)\r\n          case 'below': return distance(box.bottom, boxA.top) - distance(box.bottom, boxB.top)\r\n        }\r\n      })\r", "name": "boundingBoxForPaneView", "func_location": "WorkspaceElement.nearestVisiblePaneInDirection.paneViews.(unnamed_function_9)", "args": ["paneViewA"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 289, "func_start_line": 288}}, {"func_info": {"comment": [], "name": "WorkspaceElement.boundingBoxForPaneView", "params": ["paneView"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 311, "start_line": 302}, "call_info": {"func_end_line": 297, "code": "      }).sort((paneViewA, paneViewB) => {\r\n        const boxA = this.boundingBoxForPaneView(paneViewA)\r\n        const boxB = this.boundingBoxForPaneView(paneViewB)\r\n        switch (direction) {\r\n          case 'left': return distance(box.left, boxA.right) - distance(box.left, boxB.right)\r\n          case 'right': return distance(box.right, boxA.left) - distance(box.right, boxB.left)\r\n          case 'above': return distance(box.top, boxA.bottom) - distance(box.top, boxB.bottom)\r\n          case 'below': return distance(box.bottom, boxA.top) - distance(box.bottom, boxB.top)\r\n        }\r\n      })\r", "name": "boundingBoxForPaneView", "func_location": "WorkspaceElement.nearestVisiblePaneInDirection.paneViews.(unnamed_function_9)", "args": ["paneViewB"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 290, "func_start_line": 288}}, {"func_info": {"comment": [], "name": "WorkspaceElement.nearestVisiblePaneInDirection.distance", "params": ["pointA", "pointB"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 273, "start_line": 269}, "call_info": {"func_end_line": 297, "code": "      }).sort((paneViewA, paneViewB) => {\r\n        const boxA = this.boundingBoxForPaneView(paneViewA)\r\n        const boxB = this.boundingBoxForPaneView(paneViewB)\r\n        switch (direction) {\r\n          case 'left': return distance(box.left, boxA.right) - distance(box.left, boxB.right)\r\n          case 'right': return distance(box.right, boxA.left) - distance(box.right, boxB.left)\r\n          case 'above': return distance(box.top, boxA.bottom) - distance(box.top, boxB.bottom)\r\n          case 'below': return distance(box.bottom, boxA.top) - distance(box.bottom, boxB.top)\r\n        }\r\n      })\r", "name": "distance", "func_location": "WorkspaceElement.nearestVisiblePaneInDirection.paneViews.(unnamed_function_9)", "args": ["box.left", "boxA.right"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 292, "func_start_line": 288}}, {"func_info": {"comment": [], "name": "WorkspaceElement.nearestVisiblePaneInDirection.distance", "params": ["pointA", "pointB"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 273, "start_line": 269}, "call_info": {"func_end_line": 297, "code": "      }).sort((paneViewA, paneViewB) => {\r\n        const boxA = this.boundingBoxForPaneView(paneViewA)\r\n        const boxB = this.boundingBoxForPaneView(paneViewB)\r\n        switch (direction) {\r\n          case 'left': return distance(box.left, boxA.right) - distance(box.left, boxB.right)\r\n          case 'right': return distance(box.right, boxA.left) - distance(box.right, boxB.left)\r\n          case 'above': return distance(box.top, boxA.bottom) - distance(box.top, boxB.bottom)\r\n          case 'below': return distance(box.bottom, boxA.top) - distance(box.bottom, boxB.top)\r\n        }\r\n      })\r", "name": "distance", "func_location": "WorkspaceElement.nearestVisiblePaneInDirection.paneViews.(unnamed_function_9)", "args": ["box.left", "boxA.right"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 292, "func_start_line": 288}}, {"func_info": {"comment": [], "name": "WorkspaceElement.nearestVisiblePaneInDirection.distance", "params": ["pointA", "pointB"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 273, "start_line": 269}, "call_info": {"func_end_line": 297, "code": "      }).sort((paneViewA, paneViewB) => {\r\n        const boxA = this.boundingBoxForPaneView(paneViewA)\r\n        const boxB = this.boundingBoxForPaneView(paneViewB)\r\n        switch (direction) {\r\n          case 'left': return distance(box.left, boxA.right) - distance(box.left, boxB.right)\r\n          case 'right': return distance(box.right, boxA.left) - distance(box.right, boxB.left)\r\n          case 'above': return distance(box.top, boxA.bottom) - distance(box.top, boxB.bottom)\r\n          case 'below': return distance(box.bottom, boxA.top) - distance(box.bottom, boxB.top)\r\n        }\r\n      })\r", "name": "distance", "func_location": "WorkspaceElement.nearestVisiblePaneInDirection.paneViews.(unnamed_function_9)", "args": ["box.right", "boxA.left"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 293, "func_start_line": 288}}, {"func_info": {"comment": [], "name": "WorkspaceElement.nearestVisiblePaneInDirection.distance", "params": ["pointA", "pointB"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 273, "start_line": 269}, "call_info": {"func_end_line": 297, "code": "      }).sort((paneViewA, paneViewB) => {\r\n        const boxA = this.boundingBoxForPaneView(paneViewA)\r\n        const boxB = this.boundingBoxForPaneView(paneViewB)\r\n        switch (direction) {\r\n          case 'left': return distance(box.left, boxA.right) - distance(box.left, boxB.right)\r\n          case 'right': return distance(box.right, boxA.left) - distance(box.right, boxB.left)\r\n          case 'above': return distance(box.top, boxA.bottom) - distance(box.top, boxB.bottom)\r\n          case 'below': return distance(box.bottom, boxA.top) - distance(box.bottom, boxB.top)\r\n        }\r\n      })\r", "name": "distance", "func_location": "WorkspaceElement.nearestVisiblePaneInDirection.paneViews.(unnamed_function_9)", "args": ["box.right", "boxA.left"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 293, "func_start_line": 288}}, {"func_info": {"comment": [], "name": "WorkspaceElement.nearestVisiblePaneInDirection.distance", "params": ["pointA", "pointB"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 273, "start_line": 269}, "call_info": {"func_end_line": 297, "code": "      }).sort((paneViewA, paneViewB) => {\r\n        const boxA = this.boundingBoxForPaneView(paneViewA)\r\n        const boxB = this.boundingBoxForPaneView(paneViewB)\r\n        switch (direction) {\r\n          case 'left': return distance(box.left, boxA.right) - distance(box.left, boxB.right)\r\n          case 'right': return distance(box.right, boxA.left) - distance(box.right, boxB.left)\r\n          case 'above': return distance(box.top, boxA.bottom) - distance(box.top, boxB.bottom)\r\n          case 'below': return distance(box.bottom, boxA.top) - distance(box.bottom, boxB.top)\r\n        }\r\n      })\r", "name": "distance", "func_location": "WorkspaceElement.nearestVisiblePaneInDirection.paneViews.(unnamed_function_9)", "args": ["box.top", "boxA.bottom"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 294, "func_start_line": 288}}, {"func_info": {"comment": [], "name": "WorkspaceElement.nearestVisiblePaneInDirection.distance", "params": ["pointA", "pointB"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 273, "start_line": 269}, "call_info": {"func_end_line": 297, "code": "      }).sort((paneViewA, paneViewB) => {\r\n        const boxA = this.boundingBoxForPaneView(paneViewA)\r\n        const boxB = this.boundingBoxForPaneView(paneViewB)\r\n        switch (direction) {\r\n          case 'left': return distance(box.left, boxA.right) - distance(box.left, boxB.right)\r\n          case 'right': return distance(box.right, boxA.left) - distance(box.right, boxB.left)\r\n          case 'above': return distance(box.top, boxA.bottom) - distance(box.top, boxB.bottom)\r\n          case 'below': return distance(box.bottom, boxA.top) - distance(box.bottom, boxB.top)\r\n        }\r\n      })\r", "name": "distance", "func_location": "WorkspaceElement.nearestVisiblePaneInDirection.paneViews.(unnamed_function_9)", "args": ["box.top", "boxA.bottom"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 294, "func_start_line": 288}}, {"func_info": {"comment": [], "name": "WorkspaceElement.nearestVisiblePaneInDirection.distance", "params": ["pointA", "pointB"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 273, "start_line": 269}, "call_info": {"func_end_line": 297, "code": "      }).sort((paneViewA, paneViewB) => {\r\n        const boxA = this.boundingBoxForPaneView(paneViewA)\r\n        const boxB = this.boundingBoxForPaneView(paneViewB)\r\n        switch (direction) {\r\n          case 'left': return distance(box.left, boxA.right) - distance(box.left, boxB.right)\r\n          case 'right': return distance(box.right, boxA.left) - distance(box.right, boxB.left)\r\n          case 'above': return distance(box.top, boxA.bottom) - distance(box.top, boxB.bottom)\r\n          case 'below': return distance(box.bottom, boxA.top) - distance(box.bottom, boxB.top)\r\n        }\r\n      })\r", "name": "distance", "func_location": "WorkspaceElement.nearestVisiblePaneInDirection.paneViews.(unnamed_function_9)", "args": ["box.bottom", "boxA.top"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 295, "func_start_line": 288}}, {"func_info": {"comment": [], "name": "WorkspaceElement.nearestVisiblePaneInDirection.distance", "params": ["pointA", "pointB"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 273, "start_line": 269}, "call_info": {"func_end_line": 297, "code": "      }).sort((paneViewA, paneViewB) => {\r\n        const boxA = this.boundingBoxForPaneView(paneViewA)\r\n        const boxB = this.boundingBoxForPaneView(paneViewB)\r\n        switch (direction) {\r\n          case 'left': return distance(box.left, boxA.right) - distance(box.left, boxB.right)\r\n          case 'right': return distance(box.right, boxA.left) - distance(box.right, boxB.left)\r\n          case 'above': return distance(box.top, boxA.bottom) - distance(box.top, boxB.bottom)\r\n          case 'below': return distance(box.bottom, boxA.top) - distance(box.bottom, boxB.top)\r\n        }\r\n      })\r", "name": "distance", "func_location": "WorkspaceElement.nearestVisiblePaneInDirection.paneViews.(unnamed_function_9)", "args": ["box.bottom", "boxA.top"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 295, "func_start_line": 288}}, {"func_info": {"comment": [], "name": "AtomWindow.containsPath", "params": ["pathToCheck"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "end_line": 165, "start_line": 156}, "call_info": {"func_end_line": 153, "code": "    return paths.every(p => this.containsPath(p))\r", "name": "containsPath", "func_location": "AtomWindow.containsPaths.(unnamed_function_9)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "line": 153, "func_start_line": 153}}, {"func_info": {"comment": [" Restore the window to its previous dimensions and show it.", "", " Restores the full screen and maximized state after the window has resized to", " prevent resize glitches."], "name": "AtomEnvironment.displayWindow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 673, "start_line": 659}, "call_info": {"func_end_line": 854, "code": "    const loadStatePromise = this.loadState().then(async state => {\r\n      this.windowDimensions = state && state.windowDimensions\r\n      await this.displayWindow()\r\n      this.commandInstaller.installAtomCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n      this.commandInstaller.installApmCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidChangeUserSettings(settings =>\r\n        this.config.resetUserSettings(settings)\r\n      ))\r\n      this.disposables.add(this.applicationDelegate.onDidFailToReadUserSettings(message =>\r\n        this.notifications.addError(message)\r\n      ))\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidOpenLocations(this.openLocations.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onApplicationMenuCommand(this.dispatchApplicationMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onContextMenuCommand(this.dispatchContextMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onURIMessage(this.dispatchURIMessage.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onDidRequestUnload(this.prepareToUnloadEditorWindow.bind(this)))\r\n\r\n      this.listenForUpdates()\r\n\r\n      this.registerDefaultTargetForKeymaps()\r\n\r\n      this.packages.loadPackages()\r\n\r\n      const startTime = Date.now()\r\n      await this.deserialize(state)\r\n      this.deserializeTimings.atom = Date.now() - startTime\r\n\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom-inset') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-inset-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'hidden') {\r\n        this.document.body.classList.add('hidden-title-bar')\r\n      }\r\n\r\n      this.document.body.appendChild(this.workspace.getElement())\r\n      if (this.backgroundStylesheet) this.backgroundStylesheet.remove()\r\n\r\n      let previousProjectPaths = this.project.getPaths()\r\n      this.disposables.add(this.project.onDidChangePaths(newPaths => {\r\n        for (let path of previousProjectPaths) {\r\n          if (this.pathsWithWaitSessions.has(path) && !newPaths.includes(path)) {\r\n            this.applicationDelegate.didClosePathWithWaitSession(path)\r\n          }\r\n        }\r\n        previousProjectPaths = newPaths\r\n        this.applicationDelegate.setRepresentedDirectoryPaths(newPaths)\r\n      }))\r\n      this.disposables.add(this.workspace.onDidDestroyPaneItem(({item}) => {\r\n        const path = item.getPath && item.getPath()\r\n        if (this.pathsWithWaitSessions.has(path)) {\r\n          this.applicationDelegate.didClosePathWithWaitSession(path)\r\n        }\r\n      }))\r\n\r\n      this.packages.activate()\r\n      this.keymaps.loadUserKeymap()\r\n      if (!this.getLoadSettings().safeMode) this.requireUserInitScript()\r\n\r\n      this.menu.update()\r\n\r\n      await this.openInitialEmptyEditorIfNecessary()\r\n    })\r", "name": "displayWindow", "func_location": "AtomEnvironment.startEditorWindow.loadStatePromise.(unnamed_function_9)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 784, "func_start_line": 782}}, {"func_info": {"comment": [], "name": "AtomEnvironment.listenForUpdates", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1324, "start_line": 1321}, "call_info": {"func_end_line": 854, "code": "    const loadStatePromise = this.loadState().then(async state => {\r\n      this.windowDimensions = state && state.windowDimensions\r\n      await this.displayWindow()\r\n      this.commandInstaller.installAtomCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n      this.commandInstaller.installApmCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidChangeUserSettings(settings =>\r\n        this.config.resetUserSettings(settings)\r\n      ))\r\n      this.disposables.add(this.applicationDelegate.onDidFailToReadUserSettings(message =>\r\n        this.notifications.addError(message)\r\n      ))\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidOpenLocations(this.openLocations.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onApplicationMenuCommand(this.dispatchApplicationMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onContextMenuCommand(this.dispatchContextMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onURIMessage(this.dispatchURIMessage.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onDidRequestUnload(this.prepareToUnloadEditorWindow.bind(this)))\r\n\r\n      this.listenForUpdates()\r\n\r\n      this.registerDefaultTargetForKeymaps()\r\n\r\n      this.packages.loadPackages()\r\n\r\n      const startTime = Date.now()\r\n      await this.deserialize(state)\r\n      this.deserializeTimings.atom = Date.now() - startTime\r\n\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom-inset') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-inset-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'hidden') {\r\n        this.document.body.classList.add('hidden-title-bar')\r\n      }\r\n\r\n      this.document.body.appendChild(this.workspace.getElement())\r\n      if (this.backgroundStylesheet) this.backgroundStylesheet.remove()\r\n\r\n      let previousProjectPaths = this.project.getPaths()\r\n      this.disposables.add(this.project.onDidChangePaths(newPaths => {\r\n        for (let path of previousProjectPaths) {\r\n          if (this.pathsWithWaitSessions.has(path) && !newPaths.includes(path)) {\r\n            this.applicationDelegate.didClosePathWithWaitSession(path)\r\n          }\r\n        }\r\n        previousProjectPaths = newPaths\r\n        this.applicationDelegate.setRepresentedDirectoryPaths(newPaths)\r\n      }))\r\n      this.disposables.add(this.workspace.onDidDestroyPaneItem(({item}) => {\r\n        const path = item.getPath && item.getPath()\r\n        if (this.pathsWithWaitSessions.has(path)) {\r\n          this.applicationDelegate.didClosePathWithWaitSession(path)\r\n        }\r\n      }))\r\n\r\n      this.packages.activate()\r\n      this.keymaps.loadUserKeymap()\r\n      if (!this.getLoadSettings().safeMode) this.requireUserInitScript()\r\n\r\n      this.menu.update()\r\n\r\n      await this.openInitialEmptyEditorIfNecessary()\r\n    })\r", "name": "listenForUpdates", "func_location": "AtomEnvironment.startEditorWindow.loadStatePromise.(unnamed_function_9)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 805, "func_start_line": 782}}, {"func_info": {"comment": [], "name": "AtomEnvironment.registerDefaultTargetForKeymaps", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 326, "start_line": 324}, "call_info": {"func_end_line": 854, "code": "    const loadStatePromise = this.loadState().then(async state => {\r\n      this.windowDimensions = state && state.windowDimensions\r\n      await this.displayWindow()\r\n      this.commandInstaller.installAtomCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n      this.commandInstaller.installApmCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidChangeUserSettings(settings =>\r\n        this.config.resetUserSettings(settings)\r\n      ))\r\n      this.disposables.add(this.applicationDelegate.onDidFailToReadUserSettings(message =>\r\n        this.notifications.addError(message)\r\n      ))\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidOpenLocations(this.openLocations.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onApplicationMenuCommand(this.dispatchApplicationMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onContextMenuCommand(this.dispatchContextMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onURIMessage(this.dispatchURIMessage.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onDidRequestUnload(this.prepareToUnloadEditorWindow.bind(this)))\r\n\r\n      this.listenForUpdates()\r\n\r\n      this.registerDefaultTargetForKeymaps()\r\n\r\n      this.packages.loadPackages()\r\n\r\n      const startTime = Date.now()\r\n      await this.deserialize(state)\r\n      this.deserializeTimings.atom = Date.now() - startTime\r\n\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom-inset') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-inset-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'hidden') {\r\n        this.document.body.classList.add('hidden-title-bar')\r\n      }\r\n\r\n      this.document.body.appendChild(this.workspace.getElement())\r\n      if (this.backgroundStylesheet) this.backgroundStylesheet.remove()\r\n\r\n      let previousProjectPaths = this.project.getPaths()\r\n      this.disposables.add(this.project.onDidChangePaths(newPaths => {\r\n        for (let path of previousProjectPaths) {\r\n          if (this.pathsWithWaitSessions.has(path) && !newPaths.includes(path)) {\r\n            this.applicationDelegate.didClosePathWithWaitSession(path)\r\n          }\r\n        }\r\n        previousProjectPaths = newPaths\r\n        this.applicationDelegate.setRepresentedDirectoryPaths(newPaths)\r\n      }))\r\n      this.disposables.add(this.workspace.onDidDestroyPaneItem(({item}) => {\r\n        const path = item.getPath && item.getPath()\r\n        if (this.pathsWithWaitSessions.has(path)) {\r\n          this.applicationDelegate.didClosePathWithWaitSession(path)\r\n        }\r\n      }))\r\n\r\n      this.packages.activate()\r\n      this.keymaps.loadUserKeymap()\r\n      if (!this.getLoadSettings().safeMode) this.requireUserInitScript()\r\n\r\n      this.menu.update()\r\n\r\n      await this.openInitialEmptyEditorIfNecessary()\r\n    })\r", "name": "registerDefaultTargetForKeymaps", "func_location": "AtomEnvironment.startEditorWindow.loadStatePromise.(unnamed_function_9)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 807, "func_start_line": 782}}, {"func_info": {"comment": [], "name": "AtomEnvironment.deserialize", "params": ["state"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1277, "start_line": 1223}, "call_info": {"func_end_line": 854, "code": "    const loadStatePromise = this.loadState().then(async state => {\r\n      this.windowDimensions = state && state.windowDimensions\r\n      await this.displayWindow()\r\n      this.commandInstaller.installAtomCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n      this.commandInstaller.installApmCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidChangeUserSettings(settings =>\r\n        this.config.resetUserSettings(settings)\r\n      ))\r\n      this.disposables.add(this.applicationDelegate.onDidFailToReadUserSettings(message =>\r\n        this.notifications.addError(message)\r\n      ))\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidOpenLocations(this.openLocations.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onApplicationMenuCommand(this.dispatchApplicationMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onContextMenuCommand(this.dispatchContextMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onURIMessage(this.dispatchURIMessage.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onDidRequestUnload(this.prepareToUnloadEditorWindow.bind(this)))\r\n\r\n      this.listenForUpdates()\r\n\r\n      this.registerDefaultTargetForKeymaps()\r\n\r\n      this.packages.loadPackages()\r\n\r\n      const startTime = Date.now()\r\n      await this.deserialize(state)\r\n      this.deserializeTimings.atom = Date.now() - startTime\r\n\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom-inset') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-inset-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'hidden') {\r\n        this.document.body.classList.add('hidden-title-bar')\r\n      }\r\n\r\n      this.document.body.appendChild(this.workspace.getElement())\r\n      if (this.backgroundStylesheet) this.backgroundStylesheet.remove()\r\n\r\n      let previousProjectPaths = this.project.getPaths()\r\n      this.disposables.add(this.project.onDidChangePaths(newPaths => {\r\n        for (let path of previousProjectPaths) {\r\n          if (this.pathsWithWaitSessions.has(path) && !newPaths.includes(path)) {\r\n            this.applicationDelegate.didClosePathWithWaitSession(path)\r\n          }\r\n        }\r\n        previousProjectPaths = newPaths\r\n        this.applicationDelegate.setRepresentedDirectoryPaths(newPaths)\r\n      }))\r\n      this.disposables.add(this.workspace.onDidDestroyPaneItem(({item}) => {\r\n        const path = item.getPath && item.getPath()\r\n        if (this.pathsWithWaitSessions.has(path)) {\r\n          this.applicationDelegate.didClosePathWithWaitSession(path)\r\n        }\r\n      }))\r\n\r\n      this.packages.activate()\r\n      this.keymaps.loadUserKeymap()\r\n      if (!this.getLoadSettings().safeMode) this.requireUserInitScript()\r\n\r\n      this.menu.update()\r\n\r\n      await this.openInitialEmptyEditorIfNecessary()\r\n    })\r", "name": "deserialize", "func_location": "AtomEnvironment.startEditorWindow.loadStatePromise.(unnamed_function_9)", "args": ["state"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 812, "func_start_line": 782}}, {"func_info": {"comment": [" Public: Get the load settings for the current window.", "", " Returns an {Object} containing all the load setting key/value pairs."], "name": "AtomEnvironment.getLoadSettings", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 527, "start_line": 525}, "call_info": {"func_end_line": 854, "code": "    const loadStatePromise = this.loadState().then(async state => {\r\n      this.windowDimensions = state && state.windowDimensions\r\n      await this.displayWindow()\r\n      this.commandInstaller.installAtomCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n      this.commandInstaller.installApmCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidChangeUserSettings(settings =>\r\n        this.config.resetUserSettings(settings)\r\n      ))\r\n      this.disposables.add(this.applicationDelegate.onDidFailToReadUserSettings(message =>\r\n        this.notifications.addError(message)\r\n      ))\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidOpenLocations(this.openLocations.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onApplicationMenuCommand(this.dispatchApplicationMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onContextMenuCommand(this.dispatchContextMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onURIMessage(this.dispatchURIMessage.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onDidRequestUnload(this.prepareToUnloadEditorWindow.bind(this)))\r\n\r\n      this.listenForUpdates()\r\n\r\n      this.registerDefaultTargetForKeymaps()\r\n\r\n      this.packages.loadPackages()\r\n\r\n      const startTime = Date.now()\r\n      await this.deserialize(state)\r\n      this.deserializeTimings.atom = Date.now() - startTime\r\n\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom-inset') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-inset-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'hidden') {\r\n        this.document.body.classList.add('hidden-title-bar')\r\n      }\r\n\r\n      this.document.body.appendChild(this.workspace.getElement())\r\n      if (this.backgroundStylesheet) this.backgroundStylesheet.remove()\r\n\r\n      let previousProjectPaths = this.project.getPaths()\r\n      this.disposables.add(this.project.onDidChangePaths(newPaths => {\r\n        for (let path of previousProjectPaths) {\r\n          if (this.pathsWithWaitSessions.has(path) && !newPaths.includes(path)) {\r\n            this.applicationDelegate.didClosePathWithWaitSession(path)\r\n          }\r\n        }\r\n        previousProjectPaths = newPaths\r\n        this.applicationDelegate.setRepresentedDirectoryPaths(newPaths)\r\n      }))\r\n      this.disposables.add(this.workspace.onDidDestroyPaneItem(({item}) => {\r\n        const path = item.getPath && item.getPath()\r\n        if (this.pathsWithWaitSessions.has(path)) {\r\n          this.applicationDelegate.didClosePathWithWaitSession(path)\r\n        }\r\n      }))\r\n\r\n      this.packages.activate()\r\n      this.keymaps.loadUserKeymap()\r\n      if (!this.getLoadSettings().safeMode) this.requireUserInitScript()\r\n\r\n      this.menu.update()\r\n\r\n      await this.openInitialEmptyEditorIfNecessary()\r\n    })\r", "name": "getLoadSettings", "func_location": "AtomEnvironment.startEditorWindow.loadStatePromise.(unnamed_function_9)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 849, "func_start_line": 782}}, {"func_info": {"comment": [], "name": "AtomEnvironment.requireUserInitScript", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1310, "start_line": 1298}, "call_info": {"func_end_line": 854, "code": "    const loadStatePromise = this.loadState().then(async state => {\r\n      this.windowDimensions = state && state.windowDimensions\r\n      await this.displayWindow()\r\n      this.commandInstaller.installAtomCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n      this.commandInstaller.installApmCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidChangeUserSettings(settings =>\r\n        this.config.resetUserSettings(settings)\r\n      ))\r\n      this.disposables.add(this.applicationDelegate.onDidFailToReadUserSettings(message =>\r\n        this.notifications.addError(message)\r\n      ))\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidOpenLocations(this.openLocations.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onApplicationMenuCommand(this.dispatchApplicationMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onContextMenuCommand(this.dispatchContextMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onURIMessage(this.dispatchURIMessage.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onDidRequestUnload(this.prepareToUnloadEditorWindow.bind(this)))\r\n\r\n      this.listenForUpdates()\r\n\r\n      this.registerDefaultTargetForKeymaps()\r\n\r\n      this.packages.loadPackages()\r\n\r\n      const startTime = Date.now()\r\n      await this.deserialize(state)\r\n      this.deserializeTimings.atom = Date.now() - startTime\r\n\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom-inset') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-inset-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'hidden') {\r\n        this.document.body.classList.add('hidden-title-bar')\r\n      }\r\n\r\n      this.document.body.appendChild(this.workspace.getElement())\r\n      if (this.backgroundStylesheet) this.backgroundStylesheet.remove()\r\n\r\n      let previousProjectPaths = this.project.getPaths()\r\n      this.disposables.add(this.project.onDidChangePaths(newPaths => {\r\n        for (let path of previousProjectPaths) {\r\n          if (this.pathsWithWaitSessions.has(path) && !newPaths.includes(path)) {\r\n            this.applicationDelegate.didClosePathWithWaitSession(path)\r\n          }\r\n        }\r\n        previousProjectPaths = newPaths\r\n        this.applicationDelegate.setRepresentedDirectoryPaths(newPaths)\r\n      }))\r\n      this.disposables.add(this.workspace.onDidDestroyPaneItem(({item}) => {\r\n        const path = item.getPath && item.getPath()\r\n        if (this.pathsWithWaitSessions.has(path)) {\r\n          this.applicationDelegate.didClosePathWithWaitSession(path)\r\n        }\r\n      }))\r\n\r\n      this.packages.activate()\r\n      this.keymaps.loadUserKeymap()\r\n      if (!this.getLoadSettings().safeMode) this.requireUserInitScript()\r\n\r\n      this.menu.update()\r\n\r\n      await this.openInitialEmptyEditorIfNecessary()\r\n    })\r", "name": "requireUserInitScript", "func_location": "AtomEnvironment.startEditorWindow.loadStatePromise.(unnamed_function_9)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 849, "func_start_line": 782}}, {"func_info": {"comment": [], "name": "AtomEnvironment.openInitialEmptyEditorIfNecessary", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 920, "start_line": 914}, "call_info": {"func_end_line": 854, "code": "    const loadStatePromise = this.loadState().then(async state => {\r\n      this.windowDimensions = state && state.windowDimensions\r\n      await this.displayWindow()\r\n      this.commandInstaller.installAtomCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n      this.commandInstaller.installApmCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidChangeUserSettings(settings =>\r\n        this.config.resetUserSettings(settings)\r\n      ))\r\n      this.disposables.add(this.applicationDelegate.onDidFailToReadUserSettings(message =>\r\n        this.notifications.addError(message)\r\n      ))\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidOpenLocations(this.openLocations.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onApplicationMenuCommand(this.dispatchApplicationMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onContextMenuCommand(this.dispatchContextMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onURIMessage(this.dispatchURIMessage.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onDidRequestUnload(this.prepareToUnloadEditorWindow.bind(this)))\r\n\r\n      this.listenForUpdates()\r\n\r\n      this.registerDefaultTargetForKeymaps()\r\n\r\n      this.packages.loadPackages()\r\n\r\n      const startTime = Date.now()\r\n      await this.deserialize(state)\r\n      this.deserializeTimings.atom = Date.now() - startTime\r\n\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom-inset') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-inset-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'hidden') {\r\n        this.document.body.classList.add('hidden-title-bar')\r\n      }\r\n\r\n      this.document.body.appendChild(this.workspace.getElement())\r\n      if (this.backgroundStylesheet) this.backgroundStylesheet.remove()\r\n\r\n      let previousProjectPaths = this.project.getPaths()\r\n      this.disposables.add(this.project.onDidChangePaths(newPaths => {\r\n        for (let path of previousProjectPaths) {\r\n          if (this.pathsWithWaitSessions.has(path) && !newPaths.includes(path)) {\r\n            this.applicationDelegate.didClosePathWithWaitSession(path)\r\n          }\r\n        }\r\n        previousProjectPaths = newPaths\r\n        this.applicationDelegate.setRepresentedDirectoryPaths(newPaths)\r\n      }))\r\n      this.disposables.add(this.workspace.onDidDestroyPaneItem(({item}) => {\r\n        const path = item.getPath && item.getPath()\r\n        if (this.pathsWithWaitSessions.has(path)) {\r\n          this.applicationDelegate.didClosePathWithWaitSession(path)\r\n        }\r\n      }))\r\n\r\n      this.packages.activate()\r\n      this.keymaps.loadUserKeymap()\r\n      if (!this.getLoadSettings().safeMode) this.requireUserInitScript()\r\n\r\n      this.menu.update()\r\n\r\n      await this.openInitialEmptyEditorIfNecessary()\r\n    })\r", "name": "openInitialEmptyEditorIfNecessary", "func_location": "AtomEnvironment.startEditorWindow.loadStatePromise.(unnamed_function_9)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 853, "func_start_line": 782}}, {"func_info": {"comment": [" Open an atom:// url.", "", " The host of the URL being opened is assumed to be the package name", " responsible for opening the URL.  A new window will be created with", " that package's `urlMain` as the bootstrap script.", "", " options -", "   :urlToOpen - The atom:// url to open.", "   :devMode - Boolean to control the opened window's dev mode.", "   :safeMode - Boolean to control the opened window's safe mode."], "name": "AtomApplication.openUrl", "params": [["urlToOpen", "devMode", "safeMode", "env"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1025, "start_line": 1008}, "call_info": {"func_end_line": 266, "code": "      return urlsToOpen.map(urlToOpen => this.openUrl({urlToOpen, devMode, safeMode, env}))\r", "name": "openUrl", "func_location": "AtomApplication.openWithOptions.(unnamed_function_9)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 266, "func_start_line": 266}}, {"func_info": {"comment": [], "name": "shouldEditorUseSoftTabs", "params": ["editor", "tabType", "softTabs"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js", "end_line": 314, "start_line": 298}, "call_info": {"func_end_line": 278, "code": "        this.editorsWithMaintainedConfig.forEach((editor) => {\r\n          if (editor.getRootScopeDescriptor().isEqual(scopeDescriptor)) {\r\n            editor.setSoftTabs(shouldEditorUseSoftTabs(editor, tabType, softTabs))\r\n          }\r\n        })\r", "name": "shouldEditorUseSoftTabs", "func_location": "TextEditorRegistry.subscribeToSettingsForEditorScope.updateTabTypes.(unnamed_function_8).(unnamed_function_9)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js", "line": 276, "func_start_line": 274}}, {"func_info": {"comment": [], "name": "ApplicationMenu.focusedWindow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "end_line": 188, "start_line": 186}, "call_info": {"func_end_line": 159, "code": "          click: () => {\r\n            const window = this.focusedWindow()\r\n            if (window) window.reload()\r\n          }\r", "name": "focusedWindow", "func_location": "submenu.click.(unnamed_function_9)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "line": 157, "func_start_line": 156}}, {"func_info": {"comment": [], "name": "Pane.getPendingItem", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 656, "start_line": 654}, "call_info": {"func_end_line": 625, "code": "      itemSubscriptions.add(item.onDidTerminatePendingState(() => {\r\n        if (this.getPendingItem() === item) this.clearPendingItem()\r\n      }))\r", "name": "getPendingItem", "func_location": "Pane.addItem.(unnamed_function_9)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 624, "func_start_line": 623}}, {"func_info": {"comment": [], "name": "Pane.clearPendingItem", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 660, "start_line": 658}, "call_info": {"func_end_line": 625, "code": "      itemSubscriptions.add(item.onDidTerminatePendingState(() => {\r\n        if (this.getPendingItem() === item) this.clearPendingItem()\r\n      }))\r", "name": "clearPendingItem", "func_location": "Pane.addItem.(unnamed_function_9)", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 624, "func_start_line": 623}}, {"func_info": {"comment": [], "name": "AtomApplication.killProcessesForWindow", "params": ["window"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 941, "start_line": 934}, "call_info": {"func_end_line": 923, "code": "    openedWindow.browserWindow.once('closed', () => this.killProcessesForWindow(openedWindow))\r", "name": "killProcessesForWindow", "func_location": "AtomApplication.openPaths.(unnamed_function_90)", "args": [{"type": "string"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 923, "func_start_line": 923}}, {"func_info": {"comment": [" Public: Opens multiple paths, in existing windows if possible.", "", " options -", "   :pathsToOpen - The array of file paths to open", "   :pidToKillWhenClosed - The integer of the pid to kill", "   :newWindow - Boolean of whether this should be opened in a new window.", "   :devMode - Boolean to control the opened window's dev mode.", "   :safeMode - Boolean to control the opened window's safe mode.", "   :windowDimensions - Object with height and width keys.", "   :window - {AtomWindow} to open file paths in.", "   :addToLastWindow - Boolean of whether this should be opened in last focused window."], "name": "AtomApplication.openPaths", "params": [["initialPaths", "pathsToOpen", "executedFrom", "pidToKillWhenClosed", "newWindow", "devMode", "safeMode", "windowDimensions", "profileStartup", "window", "clearWindowState", "addToLastWindow", "env"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 925, "start_line": 825}, "call_info": {"func_end_line": 1314, "code": "      pathsToOpen => {\r\n        return this.openPaths({pathsToOpen, devMode, safeMode, window})\r\n      },\r", "name": "openPaths", "func_location": "AtomApplication.promptForPathToOpen.(unnamed_function_97)", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 1313, "func_start_line": 1312}}, {"func_info": {"comment": [], "name": "computeHash", "params": ["contents"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/native-compile-cache.js", "end_line": 8, "start_line": 6}, "call_info": {"func_end_line": 88, "comment": [" Here we override Node's module.js", " (https://github.com/atom/node/blob/atom/lib/module.js#L378), changing", " only the bits that affect compilation in order to use the cached one."], "code": "    Module.prototype._compile = function (content, filename) {\r\n      let moduleSelf = this\r\n      // remove shebang\r\n      content = content.replace(/^#!.*/, '')\r\n      function require (path) {\r\n        return moduleSelf.require(path)\r\n      }\r\n      require.resolve = function (request) {\r\n        return Module._resolveFilename(request, moduleSelf)\r\n      }\r\n      require.main = process.mainModule\r\n\r\n      // Enable support to add extra extension types\r\n      require.extensions = Module._extensions\r\n      require.cache = Module._cache\r\n\r\n      let dirname = path.dirname(filename)\r\n\r\n      // create wrapper function\r\n      let wrapper = Module.wrap(content)\r\n\r\n      let cacheKey = computeHash(wrapper + self.v8Version)\r\n      let compiledWrapper = null\r\n      if (self.cacheStore.has(cacheKey)) {\r\n        let buffer = self.cacheStore.get(cacheKey)\r\n        let compilationResult = cachedVm.runInThisContextCached(wrapper, filename, buffer)\r\n        compiledWrapper = compilationResult.result\r\n        if (compilationResult.wasRejected) {\r\n          self.cacheStore.delete(cacheKey)\r\n        }\r\n      } else {\r\n        let compilationResult\r\n        try {\r\n          compilationResult = cachedVm.runInThisContext(wrapper, filename)\r\n        } catch (err) {\r\n          console.error(`Error running script ${filename}`)\r\n          throw err\r\n        }\r\n        if (compilationResult.cacheBuffer) {\r\n          self.cacheStore.set(cacheKey, compilationResult.cacheBuffer)\r\n        }\r\n        compiledWrapper = compilationResult.result\r\n      }\r\n\r\n      let args = [moduleSelf.exports, require, moduleSelf, filename, dirname, process, global, Buffer]\r\n      return compiledWrapper.apply(moduleSelf.exports, args)\r\n    }\r", "name": "computeHash", "func_location": "Module.prototype._compile", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/native-compile-cache.js", "line": 63, "func_start_line": 42}}, {"func_info": {"comment": [], "name": "LayerHighlightIterator._currentScopeId", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1062, "start_line": 1052}, "call_info": {"func_end_line": 1040, "code": "  _moveDown () {\r\n    let result = false\r\n    const {startIndex} = this.treeCursor\r\n\r\n    // Once the iterator has found a scope boundary, it needs to stay at the same\r\n    // position, so it should not move down if the first child node starts later than the\r\n    // current node.\r\n    while (this.treeCursor.gotoFirstChild()) {\r\n      if ((this.closeTags.length || this.openTags.length) &&\r\n          this.treeCursor.startIndex > startIndex) {\r\n        this.treeCursor.gotoParent()\r\n        break\r\n      }\r\n\r\n      result = true\r\n      this.containingNodeTypes.push(this.treeCursor.nodeType)\r\n      this.containingNodeChildIndices.push(0)\r\n      this.containingNodeEndIndices.push(this.treeCursor.endIndex)\r\n\r\n      const scopeId = this._currentScopeId()\r\n      if (scopeId) this.openTags.push(scopeId)\r\n    }\r\n\r\n    return result\r\n  }\r", "name": "_currentScopeId", "func_location": "LayerHighlightIterator._moveDown", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 1035, "func_start_line": 1016}}, {"func_info": {"comment": [], "name": "LayerHighlightIterator._currentScopeId", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1062, "start_line": 1052}, "call_info": {"func_end_line": 1014, "comment": [" Private methods"], "code": "  _moveUp (atLastChild) {\r\n    let result = false\r\n    const {endIndex} = this.treeCursor\r\n    let depth = this.containingNodeEndIndices.length\r\n\r\n    // The iterator should not move up until it has visited all of the children of this node.\r\n    while (depth > 1 && (atLastChild || this.containingNodeEndIndices[depth - 2] === endIndex)) {\r\n      atLastChild = false\r\n      result = true\r\n      this.treeCursor.gotoParent()\r\n      this.containingNodeTypes.pop()\r\n      this.containingNodeChildIndices.pop()\r\n      this.containingNodeEndIndices.pop()\r\n      --depth\r\n      const scopeId = this._currentScopeId()\r\n      if (scopeId) this.closeTags.push(scopeId)\r\n    }\r\n    return result\r\n  }\r", "name": "_currentScopeId", "func_location": "LayerHighlightIterator._moveUp", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 1010, "func_start_line": 996}}, {"func_info": {"comment": [], "name": "LanguageLayer._treeEditForBufferChange", "params": ["start", "oldEnd", "newEnd", "oldText", "newText"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 793, "start_line": 783}, "call_info": {"func_end_line": 699, "name": "_treeEditForBufferChange", "func_location": "LanguageLayer._performUpdate", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 652, "func_start_line": 623}}, {"func_info": {"comment": [], "name": "rangeForNode", "params": ["node"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1192, "start_line": 1190}, "call_info": {"func_end_line": 699, "code": "  async _performUpdate (nodeRangeSet, params) {\r\n    let includedRanges = null\r\n    if (nodeRangeSet) {\r\n      includedRanges = nodeRangeSet.getRanges()\r\n      if (includedRanges.length === 0) {\r\n        this.tree = null\r\n        this.destroyed = true\r\n        return\r\n      }\r\n    }\r\n\r\n    let affectedRange = this.editedRange\r\n    this.editedRange = null\r\n\r\n    this.patchSinceCurrentParseStarted = new Patch()\r\n    let tree = this.languageMode.parse(\r\n      this.grammar.languageModule,\r\n      this.tree,\r\n      includedRanges\r\n    )\r\n    if (tree.then) {\r\n      params.async = true\r\n      tree = await tree\r\n    }\r\n\r\n    const changes = this.patchSinceCurrentParseStarted.getChanges()\r\n    this.patchSinceCurrentParseStarted = null\r\n    for (const {oldStart, newStart, oldEnd, newEnd, oldText, newText} of changes) {\r\n      const newExtent = Point.fromObject(newEnd).traversalFrom(newStart)\r\n      tree.edit(this._treeEditForBufferChange(\r\n        newStart,\r\n        oldEnd,\r\n        Point.fromObject(oldStart).traverse(newExtent),\r\n        oldText,\r\n        newText\r\n      ))\r\n    }\r\n\r\n    if (this.tree) {\r\n      const rangesWithSyntaxChanges = this.tree.getChangedRanges(tree)\r\n      this.tree = tree\r\n\r\n      if (rangesWithSyntaxChanges.length > 0) {\r\n        for (const range of rangesWithSyntaxChanges) {\r\n          this.languageMode.emitRangeUpdate(rangeForNode(range))\r\n        }\r\n\r\n        const combinedRangeWithSyntaxChange = new Range(\r\n          rangesWithSyntaxChanges[0].startPosition,\r\n          last(rangesWithSyntaxChanges).endPosition\r\n        )\r\n\r\n        if (affectedRange) {\r\n          this.languageMode.emitRangeUpdate(affectedRange)\r\n          affectedRange = affectedRange.union(combinedRangeWithSyntaxChange)\r\n        } else {\r\n          affectedRange = combinedRangeWithSyntaxChange\r\n        }\r\n      }\r\n    } else {\r\n      this.tree = tree\r\n      this.languageMode.emitRangeUpdate(rangeForNode(tree.rootNode))\r\n      if (includedRanges) {\r\n        affectedRange = new Range(includedRanges[0].startPosition, last(includedRanges).endPosition)\r\n      } else {\r\n        affectedRange = MAX_RANGE\r\n      }\r\n    }\r\n\r\n    if (affectedRange) {\r\n      const injectionPromise = this._populateInjections(affectedRange, nodeRangeSet)\r\n      if (injectionPromise) {\r\n        params.async = true\r\n        return injectionPromise\r\n      }\r\n    }\r\n  }\r", "name": "rangeForNode", "func_location": "LanguageLayer._performUpdate", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 667, "func_start_line": 623}}, {"func_info": {"comment": [], "name": "last", "params": ["array"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1208, "start_line": 1206}, "call_info": {"func_end_line": 699, "code": "  async _performUpdate (nodeRangeSet, params) {\r\n    let includedRanges = null\r\n    if (nodeRangeSet) {\r\n      includedRanges = nodeRangeSet.getRanges()\r\n      if (includedRanges.length === 0) {\r\n        this.tree = null\r\n        this.destroyed = true\r\n        return\r\n      }\r\n    }\r\n\r\n    let affectedRange = this.editedRange\r\n    this.editedRange = null\r\n\r\n    this.patchSinceCurrentParseStarted = new Patch()\r\n    let tree = this.languageMode.parse(\r\n      this.grammar.languageModule,\r\n      this.tree,\r\n      includedRanges\r\n    )\r\n    if (tree.then) {\r\n      params.async = true\r\n      tree = await tree\r\n    }\r\n\r\n    const changes = this.patchSinceCurrentParseStarted.getChanges()\r\n    this.patchSinceCurrentParseStarted = null\r\n    for (const {oldStart, newStart, oldEnd, newEnd, oldText, newText} of changes) {\r\n      const newExtent = Point.fromObject(newEnd).traversalFrom(newStart)\r\n      tree.edit(this._treeEditForBufferChange(\r\n        newStart,\r\n        oldEnd,\r\n        Point.fromObject(oldStart).traverse(newExtent),\r\n        oldText,\r\n        newText\r\n      ))\r\n    }\r\n\r\n    if (this.tree) {\r\n      const rangesWithSyntaxChanges = this.tree.getChangedRanges(tree)\r\n      this.tree = tree\r\n\r\n      if (rangesWithSyntaxChanges.length > 0) {\r\n        for (const range of rangesWithSyntaxChanges) {\r\n          this.languageMode.emitRangeUpdate(rangeForNode(range))\r\n        }\r\n\r\n        const combinedRangeWithSyntaxChange = new Range(\r\n          rangesWithSyntaxChanges[0].startPosition,\r\n          last(rangesWithSyntaxChanges).endPosition\r\n        )\r\n\r\n        if (affectedRange) {\r\n          this.languageMode.emitRangeUpdate(affectedRange)\r\n          affectedRange = affectedRange.union(combinedRangeWithSyntaxChange)\r\n        } else {\r\n          affectedRange = combinedRangeWithSyntaxChange\r\n        }\r\n      }\r\n    } else {\r\n      this.tree = tree\r\n      this.languageMode.emitRangeUpdate(rangeForNode(tree.rootNode))\r\n      if (includedRanges) {\r\n        affectedRange = new Range(includedRanges[0].startPosition, last(includedRanges).endPosition)\r\n      } else {\r\n        affectedRange = MAX_RANGE\r\n      }\r\n    }\r\n\r\n    if (affectedRange) {\r\n      const injectionPromise = this._populateInjections(affectedRange, nodeRangeSet)\r\n      if (injectionPromise) {\r\n        params.async = true\r\n        return injectionPromise\r\n      }\r\n    }\r\n  }\r", "name": "last", "func_location": "LanguageLayer._performUpdate", "args": ["rangesWithSyntaxChanges"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 672, "func_start_line": 623}}, {"func_info": {"comment": [], "name": "rangeForNode", "params": ["node"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1192, "start_line": 1190}, "call_info": {"func_end_line": 699, "code": "  async _performUpdate (nodeRangeSet, params) {\r\n    let includedRanges = null\r\n    if (nodeRangeSet) {\r\n      includedRanges = nodeRangeSet.getRanges()\r\n      if (includedRanges.length === 0) {\r\n        this.tree = null\r\n        this.destroyed = true\r\n        return\r\n      }\r\n    }\r\n\r\n    let affectedRange = this.editedRange\r\n    this.editedRange = null\r\n\r\n    this.patchSinceCurrentParseStarted = new Patch()\r\n    let tree = this.languageMode.parse(\r\n      this.grammar.languageModule,\r\n      this.tree,\r\n      includedRanges\r\n    )\r\n    if (tree.then) {\r\n      params.async = true\r\n      tree = await tree\r\n    }\r\n\r\n    const changes = this.patchSinceCurrentParseStarted.getChanges()\r\n    this.patchSinceCurrentParseStarted = null\r\n    for (const {oldStart, newStart, oldEnd, newEnd, oldText, newText} of changes) {\r\n      const newExtent = Point.fromObject(newEnd).traversalFrom(newStart)\r\n      tree.edit(this._treeEditForBufferChange(\r\n        newStart,\r\n        oldEnd,\r\n        Point.fromObject(oldStart).traverse(newExtent),\r\n        oldText,\r\n        newText\r\n      ))\r\n    }\r\n\r\n    if (this.tree) {\r\n      const rangesWithSyntaxChanges = this.tree.getChangedRanges(tree)\r\n      this.tree = tree\r\n\r\n      if (rangesWithSyntaxChanges.length > 0) {\r\n        for (const range of rangesWithSyntaxChanges) {\r\n          this.languageMode.emitRangeUpdate(rangeForNode(range))\r\n        }\r\n\r\n        const combinedRangeWithSyntaxChange = new Range(\r\n          rangesWithSyntaxChanges[0].startPosition,\r\n          last(rangesWithSyntaxChanges).endPosition\r\n        )\r\n\r\n        if (affectedRange) {\r\n          this.languageMode.emitRangeUpdate(affectedRange)\r\n          affectedRange = affectedRange.union(combinedRangeWithSyntaxChange)\r\n        } else {\r\n          affectedRange = combinedRangeWithSyntaxChange\r\n        }\r\n      }\r\n    } else {\r\n      this.tree = tree\r\n      this.languageMode.emitRangeUpdate(rangeForNode(tree.rootNode))\r\n      if (includedRanges) {\r\n        affectedRange = new Range(includedRanges[0].startPosition, last(includedRanges).endPosition)\r\n      } else {\r\n        affectedRange = MAX_RANGE\r\n      }\r\n    }\r\n\r\n    if (affectedRange) {\r\n      const injectionPromise = this._populateInjections(affectedRange, nodeRangeSet)\r\n      if (injectionPromise) {\r\n        params.async = true\r\n        return injectionPromise\r\n      }\r\n    }\r\n  }\r", "name": "rangeForNode", "func_location": "LanguageLayer._performUpdate", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 684, "func_start_line": 623}}, {"func_info": {"comment": [], "name": "last", "params": ["array"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1208, "start_line": 1206}, "call_info": {"func_end_line": 699, "code": "  async _performUpdate (nodeRangeSet, params) {\r\n    let includedRanges = null\r\n    if (nodeRangeSet) {\r\n      includedRanges = nodeRangeSet.getRanges()\r\n      if (includedRanges.length === 0) {\r\n        this.tree = null\r\n        this.destroyed = true\r\n        return\r\n      }\r\n    }\r\n\r\n    let affectedRange = this.editedRange\r\n    this.editedRange = null\r\n\r\n    this.patchSinceCurrentParseStarted = new Patch()\r\n    let tree = this.languageMode.parse(\r\n      this.grammar.languageModule,\r\n      this.tree,\r\n      includedRanges\r\n    )\r\n    if (tree.then) {\r\n      params.async = true\r\n      tree = await tree\r\n    }\r\n\r\n    const changes = this.patchSinceCurrentParseStarted.getChanges()\r\n    this.patchSinceCurrentParseStarted = null\r\n    for (const {oldStart, newStart, oldEnd, newEnd, oldText, newText} of changes) {\r\n      const newExtent = Point.fromObject(newEnd).traversalFrom(newStart)\r\n      tree.edit(this._treeEditForBufferChange(\r\n        newStart,\r\n        oldEnd,\r\n        Point.fromObject(oldStart).traverse(newExtent),\r\n        oldText,\r\n        newText\r\n      ))\r\n    }\r\n\r\n    if (this.tree) {\r\n      const rangesWithSyntaxChanges = this.tree.getChangedRanges(tree)\r\n      this.tree = tree\r\n\r\n      if (rangesWithSyntaxChanges.length > 0) {\r\n        for (const range of rangesWithSyntaxChanges) {\r\n          this.languageMode.emitRangeUpdate(rangeForNode(range))\r\n        }\r\n\r\n        const combinedRangeWithSyntaxChange = new Range(\r\n          rangesWithSyntaxChanges[0].startPosition,\r\n          last(rangesWithSyntaxChanges).endPosition\r\n        )\r\n\r\n        if (affectedRange) {\r\n          this.languageMode.emitRangeUpdate(affectedRange)\r\n          affectedRange = affectedRange.union(combinedRangeWithSyntaxChange)\r\n        } else {\r\n          affectedRange = combinedRangeWithSyntaxChange\r\n        }\r\n      }\r\n    } else {\r\n      this.tree = tree\r\n      this.languageMode.emitRangeUpdate(rangeForNode(tree.rootNode))\r\n      if (includedRanges) {\r\n        affectedRange = new Range(includedRanges[0].startPosition, last(includedRanges).endPosition)\r\n      } else {\r\n        affectedRange = MAX_RANGE\r\n      }\r\n    }\r\n\r\n    if (affectedRange) {\r\n      const injectionPromise = this._populateInjections(affectedRange, nodeRangeSet)\r\n      if (injectionPromise) {\r\n        params.async = true\r\n        return injectionPromise\r\n      }\r\n    }\r\n  }\r", "name": "last", "func_location": "LanguageLayer._performUpdate", "args": ["includedRanges"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 686, "func_start_line": 623}}, {"func_info": {"comment": [], "name": "LanguageLayer._populateInjections", "params": ["range", "nodeRangeSet"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 781, "start_line": 701}, "call_info": {"func_end_line": 699, "code": "  async _performUpdate (nodeRangeSet, params) {\r\n    let includedRanges = null\r\n    if (nodeRangeSet) {\r\n      includedRanges = nodeRangeSet.getRanges()\r\n      if (includedRanges.length === 0) {\r\n        this.tree = null\r\n        this.destroyed = true\r\n        return\r\n      }\r\n    }\r\n\r\n    let affectedRange = this.editedRange\r\n    this.editedRange = null\r\n\r\n    this.patchSinceCurrentParseStarted = new Patch()\r\n    let tree = this.languageMode.parse(\r\n      this.grammar.languageModule,\r\n      this.tree,\r\n      includedRanges\r\n    )\r\n    if (tree.then) {\r\n      params.async = true\r\n      tree = await tree\r\n    }\r\n\r\n    const changes = this.patchSinceCurrentParseStarted.getChanges()\r\n    this.patchSinceCurrentParseStarted = null\r\n    for (const {oldStart, newStart, oldEnd, newEnd, oldText, newText} of changes) {\r\n      const newExtent = Point.fromObject(newEnd).traversalFrom(newStart)\r\n      tree.edit(this._treeEditForBufferChange(\r\n        newStart,\r\n        oldEnd,\r\n        Point.fromObject(oldStart).traverse(newExtent),\r\n        oldText,\r\n        newText\r\n      ))\r\n    }\r\n\r\n    if (this.tree) {\r\n      const rangesWithSyntaxChanges = this.tree.getChangedRanges(tree)\r\n      this.tree = tree\r\n\r\n      if (rangesWithSyntaxChanges.length > 0) {\r\n        for (const range of rangesWithSyntaxChanges) {\r\n          this.languageMode.emitRangeUpdate(rangeForNode(range))\r\n        }\r\n\r\n        const combinedRangeWithSyntaxChange = new Range(\r\n          rangesWithSyntaxChanges[0].startPosition,\r\n          last(rangesWithSyntaxChanges).endPosition\r\n        )\r\n\r\n        if (affectedRange) {\r\n          this.languageMode.emitRangeUpdate(affectedRange)\r\n          affectedRange = affectedRange.union(combinedRangeWithSyntaxChange)\r\n        } else {\r\n          affectedRange = combinedRangeWithSyntaxChange\r\n        }\r\n      }\r\n    } else {\r\n      this.tree = tree\r\n      this.languageMode.emitRangeUpdate(rangeForNode(tree.rootNode))\r\n      if (includedRanges) {\r\n        affectedRange = new Range(includedRanges[0].startPosition, last(includedRanges).endPosition)\r\n      } else {\r\n        affectedRange = MAX_RANGE\r\n      }\r\n    }\r\n\r\n    if (affectedRange) {\r\n      const injectionPromise = this._populateInjections(affectedRange, nodeRangeSet)\r\n      if (injectionPromise) {\r\n        params.async = true\r\n        return injectionPromise\r\n      }\r\n    }\r\n  }\r", "name": "_populateInjections", "func_location": "LanguageLayer._performUpdate", "args": ["affectedRange", "nodeRangeSet"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 693, "func_start_line": 623}}, {"func_info": {"comment": [], "name": "last", "params": ["array"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1208, "start_line": 1206}, "call_info": {"func_end_line": 781, "code": "  _populateInjections (range, nodeRangeSet) {\r\n    const existingInjectionMarkers = this.languageMode.injectionsMarkerLayer\r\n      .findMarkers({intersectsRange: range})\r\n      .filter(marker => marker.parentLanguageLayer === this)\r\n\r\n    if (existingInjectionMarkers.length > 0) {\r\n      range = range.union(new Range(\r\n        existingInjectionMarkers[0].getRange().start,\r\n        last(existingInjectionMarkers).getRange().end\r\n      ))\r\n    }\r\n\r\n    const markersToUpdate = new Map()\r\n    const nodes = this.tree.rootNode.descendantsOfType(\r\n      Object.keys(this.grammar.injectionPointsByType),\r\n      range.start,\r\n      range.end\r\n    )\r\n\r\n    let existingInjectionMarkerIndex = 0\r\n    for (const node of nodes) {\r\n      for (const injectionPoint of this.grammar.injectionPointsByType[node.type]) {\r\n        const languageName = injectionPoint.language(node)\r\n        if (!languageName) continue\r\n\r\n        const grammar = this.languageMode.grammarForLanguageString(languageName)\r\n        if (!grammar) continue\r\n\r\n        const contentNodes = injectionPoint.content(node)\r\n        if (!contentNodes) continue\r\n\r\n        const injectionNodes = [].concat(contentNodes)\r\n        if (!injectionNodes.length) continue\r\n\r\n        const injectionRange = rangeForNode(node)\r\n\r\n        let marker\r\n        for (let i = existingInjectionMarkerIndex, n = existingInjectionMarkers.length; i < n; i++) {\r\n          const existingMarker = existingInjectionMarkers[i]\r\n          const comparison = existingMarker.getRange().compare(injectionRange)\r\n          if (comparison > 0) {\r\n            break\r\n          } else if (comparison === 0) {\r\n            existingInjectionMarkerIndex = i\r\n            if (existingMarker.languageLayer.grammar === grammar) {\r\n              marker = existingMarker\r\n              marker.id === node.id\r\n              break\r\n            }\r\n          } else {\r\n            existingInjectionMarkerIndex = i\r\n          }\r\n        }\r\n\r\n        if (!marker) {\r\n          marker = this.languageMode.injectionsMarkerLayer.markRange(injectionRange)\r\n          marker.languageLayer = new LanguageLayer(this.languageMode, grammar, injectionPoint.contentChildTypes)\r\n          marker.parentLanguageLayer = this\r\n        }\r\n\r\n        markersToUpdate.set(marker, new NodeRangeSet(nodeRangeSet, injectionNodes))\r\n      }\r\n    }\r\n\r\n    for (const marker of existingInjectionMarkers) {\r\n      if (!markersToUpdate.has(marker)) {\r\n        marker.languageLayer.destroy()\r\n        this.languageMode.emitRangeUpdate(marker.getRange())\r\n        marker.destroy()\r\n      }\r\n    }\r\n\r\n    if (markersToUpdate.size > 0) {\r\n      this.lastUpdateWasAsync = true\r\n      const promises = []\r\n      for (const [marker, nodeRangeSet] of markersToUpdate) {\r\n        promises.push(marker.languageLayer.update(nodeRangeSet))\r\n      }\r\n      return Promise.all(promises)\r\n    }\r\n  }\r", "name": "last", "func_location": "LanguageLayer._populateInjections", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 709, "func_start_line": 701}}, {"func_info": {"comment": [], "name": "rangeForNode", "params": ["node"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1192, "start_line": 1190}, "call_info": {"func_end_line": 781, "code": "  _populateInjections (range, nodeRangeSet) {\r\n    const existingInjectionMarkers = this.languageMode.injectionsMarkerLayer\r\n      .findMarkers({intersectsRange: range})\r\n      .filter(marker => marker.parentLanguageLayer === this)\r\n\r\n    if (existingInjectionMarkers.length > 0) {\r\n      range = range.union(new Range(\r\n        existingInjectionMarkers[0].getRange().start,\r\n        last(existingInjectionMarkers).getRange().end\r\n      ))\r\n    }\r\n\r\n    const markersToUpdate = new Map()\r\n    const nodes = this.tree.rootNode.descendantsOfType(\r\n      Object.keys(this.grammar.injectionPointsByType),\r\n      range.start,\r\n      range.end\r\n    )\r\n\r\n    let existingInjectionMarkerIndex = 0\r\n    for (const node of nodes) {\r\n      for (const injectionPoint of this.grammar.injectionPointsByType[node.type]) {\r\n        const languageName = injectionPoint.language(node)\r\n        if (!languageName) continue\r\n\r\n        const grammar = this.languageMode.grammarForLanguageString(languageName)\r\n        if (!grammar) continue\r\n\r\n        const contentNodes = injectionPoint.content(node)\r\n        if (!contentNodes) continue\r\n\r\n        const injectionNodes = [].concat(contentNodes)\r\n        if (!injectionNodes.length) continue\r\n\r\n        const injectionRange = rangeForNode(node)\r\n\r\n        let marker\r\n        for (let i = existingInjectionMarkerIndex, n = existingInjectionMarkers.length; i < n; i++) {\r\n          const existingMarker = existingInjectionMarkers[i]\r\n          const comparison = existingMarker.getRange().compare(injectionRange)\r\n          if (comparison > 0) {\r\n            break\r\n          } else if (comparison === 0) {\r\n            existingInjectionMarkerIndex = i\r\n            if (existingMarker.languageLayer.grammar === grammar) {\r\n              marker = existingMarker\r\n              marker.id === node.id\r\n              break\r\n            }\r\n          } else {\r\n            existingInjectionMarkerIndex = i\r\n          }\r\n        }\r\n\r\n        if (!marker) {\r\n          marker = this.languageMode.injectionsMarkerLayer.markRange(injectionRange)\r\n          marker.languageLayer = new LanguageLayer(this.languageMode, grammar, injectionPoint.contentChildTypes)\r\n          marker.parentLanguageLayer = this\r\n        }\r\n\r\n        markersToUpdate.set(marker, new NodeRangeSet(nodeRangeSet, injectionNodes))\r\n      }\r\n    }\r\n\r\n    for (const marker of existingInjectionMarkers) {\r\n      if (!markersToUpdate.has(marker)) {\r\n        marker.languageLayer.destroy()\r\n        this.languageMode.emitRangeUpdate(marker.getRange())\r\n        marker.destroy()\r\n      }\r\n    }\r\n\r\n    if (markersToUpdate.size > 0) {\r\n      this.lastUpdateWasAsync = true\r\n      const promises = []\r\n      for (const [marker, nodeRangeSet] of markersToUpdate) {\r\n        promises.push(marker.languageLayer.update(nodeRangeSet))\r\n      }\r\n      return Promise.all(promises)\r\n    }\r\n  }\r", "name": "rangeForNode", "func_location": "LanguageLayer._populateInjections", "args": ["node"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 735, "func_start_line": 701}}, {"func_info": {"comment": [], "name": "LanguageLayer.constructor", "params": ["languageMode", "grammar", "contentChildTypes"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 552, "start_line": 545}, "call_info": {"func_end_line": 781, "name": "constructor", "func_location": "LanguageLayer._populateInjections", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 757, "func_start_line": 701}}, {"func_info": {"comment": [], "name": "NodeRangeSet.constructor", "params": ["previous", "nodes"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1107, "start_line": 1104}, "call_info": {"func_end_line": 781, "code": "  _populateInjections (range, nodeRangeSet) {\r\n    const existingInjectionMarkers = this.languageMode.injectionsMarkerLayer\r\n      .findMarkers({intersectsRange: range})\r\n      .filter(marker => marker.parentLanguageLayer === this)\r\n\r\n    if (existingInjectionMarkers.length > 0) {\r\n      range = range.union(new Range(\r\n        existingInjectionMarkers[0].getRange().start,\r\n        last(existingInjectionMarkers).getRange().end\r\n      ))\r\n    }\r\n\r\n    const markersToUpdate = new Map()\r\n    const nodes = this.tree.rootNode.descendantsOfType(\r\n      Object.keys(this.grammar.injectionPointsByType),\r\n      range.start,\r\n      range.end\r\n    )\r\n\r\n    let existingInjectionMarkerIndex = 0\r\n    for (const node of nodes) {\r\n      for (const injectionPoint of this.grammar.injectionPointsByType[node.type]) {\r\n        const languageName = injectionPoint.language(node)\r\n        if (!languageName) continue\r\n\r\n        const grammar = this.languageMode.grammarForLanguageString(languageName)\r\n        if (!grammar) continue\r\n\r\n        const contentNodes = injectionPoint.content(node)\r\n        if (!contentNodes) continue\r\n\r\n        const injectionNodes = [].concat(contentNodes)\r\n        if (!injectionNodes.length) continue\r\n\r\n        const injectionRange = rangeForNode(node)\r\n\r\n        let marker\r\n        for (let i = existingInjectionMarkerIndex, n = existingInjectionMarkers.length; i < n; i++) {\r\n          const existingMarker = existingInjectionMarkers[i]\r\n          const comparison = existingMarker.getRange().compare(injectionRange)\r\n          if (comparison > 0) {\r\n            break\r\n          } else if (comparison === 0) {\r\n            existingInjectionMarkerIndex = i\r\n            if (existingMarker.languageLayer.grammar === grammar) {\r\n              marker = existingMarker\r\n              marker.id === node.id\r\n              break\r\n            }\r\n          } else {\r\n            existingInjectionMarkerIndex = i\r\n          }\r\n        }\r\n\r\n        if (!marker) {\r\n          marker = this.languageMode.injectionsMarkerLayer.markRange(injectionRange)\r\n          marker.languageLayer = new LanguageLayer(this.languageMode, grammar, injectionPoint.contentChildTypes)\r\n          marker.parentLanguageLayer = this\r\n        }\r\n\r\n        markersToUpdate.set(marker, new NodeRangeSet(nodeRangeSet, injectionNodes))\r\n      }\r\n    }\r\n\r\n    for (const marker of existingInjectionMarkers) {\r\n      if (!markersToUpdate.has(marker)) {\r\n        marker.languageLayer.destroy()\r\n        this.languageMode.emitRangeUpdate(marker.getRange())\r\n        marker.destroy()\r\n      }\r\n    }\r\n\r\n    if (markersToUpdate.size > 0) {\r\n      this.lastUpdateWasAsync = true\r\n      const promises = []\r\n      for (const [marker, nodeRangeSet] of markersToUpdate) {\r\n        promises.push(marker.languageLayer.update(nodeRangeSet))\r\n      }\r\n      return Promise.all(promises)\r\n    }\r\n  }\r", "name": "constructor", "func_location": "LanguageLayer._populateInjections", "args": ["marker", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 761, "func_start_line": 701}}, {"func_info": {"comment": [], "name": "Config.resetScopedSettings", "params": ["newScopedSettings", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1229, "start_line": 1215}, "call_info": {"func_end_line": 967, "code": "  _resetSettings (newSettings, options = {}) {\r\n    const source = options.source\r\n    newSettings = Object.assign({}, newSettings)\r\n    if (newSettings.global != null) {\r\n      newSettings['*'] = newSettings.global\r\n      delete newSettings.global\r\n    }\r\n\r\n    if (newSettings['*'] != null) {\r\n      const scopedSettings = newSettings\r\n      newSettings = newSettings['*']\r\n      delete scopedSettings['*']\r\n      this.resetScopedSettings(scopedSettings, {source})\r\n    }\r\n\r\n    return this.transact(() => {\r\n      this._clearUnscopedSettingsForSource(source)\r\n      this.settingsLoaded = true\r\n      for (let key in newSettings) {\r\n        const value = newSettings[key]\r\n        this.set(key, value, {save: false, source})\r\n      }\r\n      if (this.pendingOperations.length) {\r\n        for (let op of this.pendingOperations) { op() }\r\n        this.pendingOperations = []\r\n      }\r\n    })\r\n  }\r", "name": "resetScopedSettings", "func_location": "Config._resetSettings", "args": ["scopedSettings", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 952, "func_start_line": 940}}, {"func_info": {"comment": [" Extended: Suppress calls to handler functions registered with {::onDidChange}", " and {::observe} for the duration of `callback`. After `callback` executes,", " handlers will be called once if the value for their key-path has changed.", "", " * `callback` {Function} to execute while suppressing calls to handlers."], "name": "Config.transact", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 823, "start_line": 816}, "call_info": {"func_end_line": 967, "name": "transact", "func_location": "Config._resetSettings", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 955, "func_start_line": 940}}, {"func_info": {"comment": [], "name": "resolveModulePath", "params": ["relativePath", "parentModule"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js", "end_line": 227, "start_line": 197}, "call_info": {"func_end_line": 284, "code": "  Module._resolveFilename = function (relativePath, parentModule) {\r\n    let resolvedPath = resolveModulePath(relativePath, parentModule)\r\n    if (!resolvedPath) {\r\n      resolvedPath = resolveFilePath(relativePath, parentModule)\r\n    }\r\n    return resolvedPath || originalResolveFilename(relativePath, parentModule)\r\n  }\r", "name": "resolveModulePath", "func_location": "Module._resolveFilename", "args": ["relativePath", "parentModule"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js", "line": 279, "func_start_line": 278}}, {"func_info": {"comment": [], "name": "resolveFilePath", "params": ["relativePath", "parentModule"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js", "end_line": 195, "start_line": 175}, "call_info": {"func_end_line": 284, "code": "  Module._resolveFilename = function (relativePath, parentModule) {\r\n    let resolvedPath = resolveModulePath(relativePath, parentModule)\r\n    if (!resolvedPath) {\r\n      resolvedPath = resolveFilePath(relativePath, parentModule)\r\n    }\r\n    return resolvedPath || originalResolveFilename(relativePath, parentModule)\r\n  }\r", "name": "resolveFilePath", "func_location": "Module._resolveFilename", "args": ["relativePath", "parentModule"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js", "line": 281, "func_start_line": 278}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.increaseIndentRegexForScopeDescriptor", "params": ["scope"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 699, "start_line": 697}, "call_info": {"func_end_line": 179, "code": "  _suggestedIndentForLineWithScopeAtBufferRow (bufferRow, line, scopeDescriptor, tabLength, options) {\r\n    const increaseIndentRegex = this.increaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    const decreaseIndentRegex = this.decreaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    const decreaseNextIndentRegex = this.decreaseNextIndentRegexForScopeDescriptor(scopeDescriptor)\r\n\r\n    let precedingRow\r\n    if (!options || options.skipBlankLines !== false) {\r\n      precedingRow = this.buffer.previousNonBlankRow(bufferRow)\r\n      if (precedingRow == null) return 0\r\n    } else {\r\n      precedingRow = bufferRow - 1\r\n      if (precedingRow < 0) return 0\r\n    }\r\n\r\n    const precedingLine = this.buffer.lineForRow(precedingRow)\r\n    let desiredIndentLevel = this.indentLevelForLine(precedingLine, tabLength)\r\n    if (!increaseIndentRegex) return desiredIndentLevel\r\n\r\n    if (!this.isRowCommented(precedingRow)) {\r\n      if (increaseIndentRegex && increaseIndentRegex.testSync(precedingLine)) desiredIndentLevel += 1\r\n      if (decreaseNextIndentRegex && decreaseNextIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    if (!this.buffer.isRowBlank(precedingRow)) {\r\n      if (decreaseIndentRegex && decreaseIndentRegex.testSync(line)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    return Math.max(desiredIndentLevel, 0)\r\n  }\r", "name": "increaseIndentRegexForScopeDescriptor", "func_location": "TextMateLanguageMode._suggestedIndentForLineWithScopeAtBufferRow", "args": ["scopeDescriptor"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 152, "func_start_line": 151}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.decreaseIndentRegexForScopeDescriptor", "params": ["scope"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 703, "start_line": 701}, "call_info": {"func_end_line": 179, "code": "  _suggestedIndentForLineWithScopeAtBufferRow (bufferRow, line, scopeDescriptor, tabLength, options) {\r\n    const increaseIndentRegex = this.increaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    const decreaseIndentRegex = this.decreaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    const decreaseNextIndentRegex = this.decreaseNextIndentRegexForScopeDescriptor(scopeDescriptor)\r\n\r\n    let precedingRow\r\n    if (!options || options.skipBlankLines !== false) {\r\n      precedingRow = this.buffer.previousNonBlankRow(bufferRow)\r\n      if (precedingRow == null) return 0\r\n    } else {\r\n      precedingRow = bufferRow - 1\r\n      if (precedingRow < 0) return 0\r\n    }\r\n\r\n    const precedingLine = this.buffer.lineForRow(precedingRow)\r\n    let desiredIndentLevel = this.indentLevelForLine(precedingLine, tabLength)\r\n    if (!increaseIndentRegex) return desiredIndentLevel\r\n\r\n    if (!this.isRowCommented(precedingRow)) {\r\n      if (increaseIndentRegex && increaseIndentRegex.testSync(precedingLine)) desiredIndentLevel += 1\r\n      if (decreaseNextIndentRegex && decreaseNextIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    if (!this.buffer.isRowBlank(precedingRow)) {\r\n      if (decreaseIndentRegex && decreaseIndentRegex.testSync(line)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    return Math.max(desiredIndentLevel, 0)\r\n  }\r", "name": "decreaseIndentRegexForScopeDescriptor", "func_location": "TextMateLanguageMode._suggestedIndentForLineWithScopeAtBufferRow", "args": ["scopeDescriptor"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 153, "func_start_line": 151}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.decreaseNextIndentRegexForScopeDescriptor", "params": ["scope"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 707, "start_line": 705}, "call_info": {"func_end_line": 179, "code": "  _suggestedIndentForLineWithScopeAtBufferRow (bufferRow, line, scopeDescriptor, tabLength, options) {\r\n    const increaseIndentRegex = this.increaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    const decreaseIndentRegex = this.decreaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    const decreaseNextIndentRegex = this.decreaseNextIndentRegexForScopeDescriptor(scopeDescriptor)\r\n\r\n    let precedingRow\r\n    if (!options || options.skipBlankLines !== false) {\r\n      precedingRow = this.buffer.previousNonBlankRow(bufferRow)\r\n      if (precedingRow == null) return 0\r\n    } else {\r\n      precedingRow = bufferRow - 1\r\n      if (precedingRow < 0) return 0\r\n    }\r\n\r\n    const precedingLine = this.buffer.lineForRow(precedingRow)\r\n    let desiredIndentLevel = this.indentLevelForLine(precedingLine, tabLength)\r\n    if (!increaseIndentRegex) return desiredIndentLevel\r\n\r\n    if (!this.isRowCommented(precedingRow)) {\r\n      if (increaseIndentRegex && increaseIndentRegex.testSync(precedingLine)) desiredIndentLevel += 1\r\n      if (decreaseNextIndentRegex && decreaseNextIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    if (!this.buffer.isRowBlank(precedingRow)) {\r\n      if (decreaseIndentRegex && decreaseIndentRegex.testSync(line)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    return Math.max(desiredIndentLevel, 0)\r\n  }\r", "name": "decreaseNextIndentRegexForScopeDescriptor", "func_location": "TextMateLanguageMode._suggestedIndentForLineWithScopeAtBufferRow", "args": ["scopeDescriptor"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 154, "func_start_line": 151}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.indentLevelForLine", "params": ["line", "tabLength"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 505, "start_line": 492}, "call_info": {"func_end_line": 179, "code": "  _suggestedIndentForLineWithScopeAtBufferRow (bufferRow, line, scopeDescriptor, tabLength, options) {\r\n    const increaseIndentRegex = this.increaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    const decreaseIndentRegex = this.decreaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    const decreaseNextIndentRegex = this.decreaseNextIndentRegexForScopeDescriptor(scopeDescriptor)\r\n\r\n    let precedingRow\r\n    if (!options || options.skipBlankLines !== false) {\r\n      precedingRow = this.buffer.previousNonBlankRow(bufferRow)\r\n      if (precedingRow == null) return 0\r\n    } else {\r\n      precedingRow = bufferRow - 1\r\n      if (precedingRow < 0) return 0\r\n    }\r\n\r\n    const precedingLine = this.buffer.lineForRow(precedingRow)\r\n    let desiredIndentLevel = this.indentLevelForLine(precedingLine, tabLength)\r\n    if (!increaseIndentRegex) return desiredIndentLevel\r\n\r\n    if (!this.isRowCommented(precedingRow)) {\r\n      if (increaseIndentRegex && increaseIndentRegex.testSync(precedingLine)) desiredIndentLevel += 1\r\n      if (decreaseNextIndentRegex && decreaseNextIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    if (!this.buffer.isRowBlank(precedingRow)) {\r\n      if (decreaseIndentRegex && decreaseIndentRegex.testSync(line)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    return Math.max(desiredIndentLevel, 0)\r\n  }\r", "name": "indentLevelForLine", "func_location": "TextMateLanguageMode._suggestedIndentForLineWithScopeAtBufferRow", "args": ["precedingLine", "tabLength"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 166, "func_start_line": 151}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.isRowCommented", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 602, "start_line": 600}, "call_info": {"func_end_line": 179, "code": "  _suggestedIndentForLineWithScopeAtBufferRow (bufferRow, line, scopeDescriptor, tabLength, options) {\r\n    const increaseIndentRegex = this.increaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    const decreaseIndentRegex = this.decreaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    const decreaseNextIndentRegex = this.decreaseNextIndentRegexForScopeDescriptor(scopeDescriptor)\r\n\r\n    let precedingRow\r\n    if (!options || options.skipBlankLines !== false) {\r\n      precedingRow = this.buffer.previousNonBlankRow(bufferRow)\r\n      if (precedingRow == null) return 0\r\n    } else {\r\n      precedingRow = bufferRow - 1\r\n      if (precedingRow < 0) return 0\r\n    }\r\n\r\n    const precedingLine = this.buffer.lineForRow(precedingRow)\r\n    let desiredIndentLevel = this.indentLevelForLine(precedingLine, tabLength)\r\n    if (!increaseIndentRegex) return desiredIndentLevel\r\n\r\n    if (!this.isRowCommented(precedingRow)) {\r\n      if (increaseIndentRegex && increaseIndentRegex.testSync(precedingLine)) desiredIndentLevel += 1\r\n      if (decreaseNextIndentRegex && decreaseNextIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    if (!this.buffer.isRowBlank(precedingRow)) {\r\n      if (decreaseIndentRegex && decreaseIndentRegex.testSync(line)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    return Math.max(desiredIndentLevel, 0)\r\n  }\r", "name": "isRowCommented", "func_location": "TextMateLanguageMode._suggestedIndentForLineWithScopeAtBufferRow", "args": ["precedingRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 169, "func_start_line": 151}}, {"func_info": {"comment": [" Extended: Get the active {Pane}.", "", " Returns a {Pane}."], "name": "WorkspaceCenter.getActivePane", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js", "end_line": 308, "start_line": 306}, "call_info": {"func_end_line": 36, "code": "  activate () {\r\n    this.getActivePane().activate()\r\n  }\r", "name": "getActivePane", "func_location": "WorkspaceCenter.activate", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js", "line": 35, "func_start_line": 34}}, {"func_info": {"comment": [], "name": "Package.loadGrammars", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 632, "start_line": 594}, "call_info": {"func_end_line": 210, "code": "  activate () {\r\n    if (!this.grammarsPromise) this.grammarsPromise = this.loadGrammars()\r\n    if (!this.activationPromise) {\r\n      this.activationPromise = new Promise((resolve, reject) => {\r\n        this.resolveActivationPromise = resolve\r\n        this.measure('activateTime', () => {\r\n          try {\r\n            this.activateResources()\r\n            if (this.activationShouldBeDeferred()) {\r\n              return this.subscribeToDeferredActivation()\r\n            } else {\r\n              return this.activateNow()\r\n            }\r\n          } catch (error) {\r\n            return this.handleError(`Failed to activate the ${this.name} package`, error)\r\n          }\r\n        })\r\n      })\r\n    }\r\n\r\n    return Promise.all([this.grammarsPromise, this.settingsPromise, this.activationPromise])\r\n  }\r", "name": "loadGrammars", "func_location": "Package.activate", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 190, "func_start_line": 189}}, {"func_info": {"comment": [" Get packages for a certain package type", "", " * `types` an {Array} of {String}s like ['atom', 'textmate']."], "name": "PackageManager.getLoadedPackagesForTypes", "params": ["types"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 332, "start_line": 330}, "call_info": {"func_end_line": 667, "comment": [" Activate all the packages that should be activated."], "code": "  activate () {\r\n    let promises = []\r\n    for (let [activator, types] of this.packageActivators) {\r\n      const packages = this.getLoadedPackagesForTypes(types)\r\n      promises = promises.concat(activator.activatePackages(packages))\r\n    }\r\n    return Promise.all(promises).then(() => {\r\n      this.triggerDeferredActivationHooks()\r\n      this.initialPackagesActivated = true\r\n      this.emitter.emit('did-activate-initial-packages')\r\n    })\r\n  }\r", "name": "getLoadedPackagesForTypes", "func_location": "PackageManager.activate", "args": ["types"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 659, "func_start_line": 656}}, {"func_info": {"comment": [" Extended: Get the active {Pane}.", "", " Returns a {Pane}."], "name": "Dock.getActivePane", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 689, "start_line": 687}, "call_info": {"func_end_line": 116, "comment": [" Extended: Show the dock and focus its active {Pane}."], "code": "  activate () {\r\n    this.getActivePane().activate()\r\n  }\r", "name": "getActivePane", "func_location": "Dock.activate", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 115, "func_start_line": 114}}, {"func_info": {"comment": [" Public: Determine whether this pane has been destroyed.", "", " Returns a {Boolean}."], "name": "Pane.isDestroyed", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 1046, "start_line": 1046}, "call_info": {"func_end_line": 1016, "comment": [" Public: Makes this pane the *active* pane, causing it to gain focus."], "code": "  activate () {\r\n    if (this.isDestroyed()) throw new Error('Pane has been destroyed')\r\n    if (this.container) this.container.didActivatePane(this)\r\n    this.emitter.emit('did-activate')\r\n  }\r", "name": "isDestroyed", "func_location": "Pane.activate", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 1013, "func_start_line": 1012}}, {"func_info": {"comment": [], "name": "Package.requireMainModule", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 784, "start_line": 755}, "call_info": {"func_end_line": 263, "comment": [" TODO: Remove. Settings view calls this method currently."], "code": "  activateConfig () {\r\n    if (this.configSchemaRegisteredOnLoad) return\r\n    this.requireMainModule()\r\n    this.registerConfigSchemaFromMainModule()\r\n  }\r", "name": "requireMainModule", "func_location": "Package.activateConfig", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 261, "func_start_line": 259}}, {"func_info": {"comment": [], "name": "Package.registerConfigSchemaFromMainModule", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 256, "start_line": 248}, "call_info": {"func_end_line": 263, "comment": [" TODO: Remove. Settings view calls this method currently."], "code": "  activateConfig () {\r\n    if (this.configSchemaRegisteredOnLoad) return\r\n    this.requireMainModule()\r\n    this.registerConfigSchemaFromMainModule()\r\n  }\r", "name": "registerConfigSchemaFromMainModule", "func_location": "Package.activateConfig", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 262, "func_start_line": 259}}, {"func_info": {"comment": [], "name": "Package.requireMainModule", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 784, "start_line": 755}, "call_info": {"func_end_line": 524, "code": "  activateCoreStartupServices () {\r\n    const directoryProviderService =\r\n      this.metadata.providedServices &&\r\n      this.metadata.providedServices['atom.directory-provider']\r\n    if (directoryProviderService) {\r\n      this.requireMainModule()\r\n      const servicesByVersion = {}\r\n      for (let version in directoryProviderService.versions) {\r\n        const methodName = directoryProviderService.versions[version]\r\n        if (typeof this.mainModule[methodName] === 'function') {\r\n          servicesByVersion[version] = this.mainModule[methodName]()\r\n        }\r\n      }\r\n      this.packageManager.serviceHub.provide('atom.directory-provider', servicesByVersion)\r\n    }\r\n  }\r", "name": "requireMainModule", "func_location": "Package.activateCoreStartupServices", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 514, "func_start_line": 509}}, {"func_info": {"comment": [], "name": "PaneElement.hasFocus", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js", "end_line": 213, "start_line": 209}, "call_info": {"func_end_line": 118, "code": "  activated () {\r\n    this.isActivating = true\r\n    if (!this.hasFocus()) {\r\n      // Don't steal focus from children.\r\n      this.focus()\r\n    }\r\n    this.isActivating = false\r\n  }\r", "name": "hasFocus", "func_location": "PaneElement.activated", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js", "line": 113, "func_start_line": 111}}, {"func_info": {"comment": [], "name": "Pane.getPendingItem", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 656, "start_line": 654}, "call_info": {"func_end_line": 581, "comment": [" Public: Make the given item *active*, causing it to be displayed by", " the pane's view.", "", " * `item` The item to activate", " * `options` (optional) {Object}", "   * `pending` (optional) {Boolean} indicating that the item should be added", "     in a pending state if it does not yet exist in the pane. Existing pending", "     items in a pane are replaced with new pending items when they are opened."], "code": "  activateItem (item, options = {}) {\r\n    if (item) {\r\n      const index = (this.getPendingItem() === this.activeItem)\r\n        ? this.getActiveItemIndex()\r\n        : this.getActiveItemIndex() + 1\r\n      this.addItem(item, Object.assign({}, options, {index}))\r\n      this.setActiveItem(item)\r\n    }\r\n  }\r", "name": "getPendingItem", "func_location": "Pane.activateItem", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 575, "func_start_line": 573}}, {"func_info": {"comment": [" Public: Get the index of the active item.", "", " Returns a {Number}."], "name": "Pane.getActiveItemIndex", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 555, "start_line": 553}, "call_info": {"func_end_line": 581, "comment": [" Public: Make the given item *active*, causing it to be displayed by", " the pane's view.", "", " * `item` The item to activate", " * `options` (optional) {Object}", "   * `pending` (optional) {Boolean} indicating that the item should be added", "     in a pending state if it does not yet exist in the pane. Existing pending", "     items in a pane are replaced with new pending items when they are opened."], "code": "  activateItem (item, options = {}) {\r\n    if (item) {\r\n      const index = (this.getPendingItem() === this.activeItem)\r\n        ? this.getActiveItemIndex()\r\n        : this.getActiveItemIndex() + 1\r\n      this.addItem(item, Object.assign({}, options, {index}))\r\n      this.setActiveItem(item)\r\n    }\r\n  }\r", "name": "getActiveItemIndex", "func_location": "Pane.activateItem", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 576, "func_start_line": 573}}, {"func_info": {"comment": [" Public: Get the index of the active item.", "", " Returns a {Number}."], "name": "Pane.getActiveItemIndex", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 555, "start_line": 553}, "call_info": {"func_end_line": 581, "comment": [" Public: Make the given item *active*, causing it to be displayed by", " the pane's view.", "", " * `item` The item to activate", " * `options` (optional) {Object}", "   * `pending` (optional) {Boolean} indicating that the item should be added", "     in a pending state if it does not yet exist in the pane. Existing pending", "     items in a pane are replaced with new pending items when they are opened."], "code": "  activateItem (item, options = {}) {\r\n    if (item) {\r\n      const index = (this.getPendingItem() === this.activeItem)\r\n        ? this.getActiveItemIndex()\r\n        : this.getActiveItemIndex() + 1\r\n      this.addItem(item, Object.assign({}, options, {index}))\r\n      this.setActiveItem(item)\r\n    }\r\n  }\r", "name": "getActiveItemIndex", "func_location": "Pane.activateItem", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 577, "func_start_line": 573}}, {"func_info": {"comment": [" Public: Add the given item to the pane.", "", " * `item` The item to add. It can be a model with an associated view or a", "   view.", " * `options` (optional) {Object}", "   * `index` (optional) {Number} indicating the index at which to add the item.", "     If omitted, the item is added after the current active item.", "   * `pending` (optional) {Boolean} indicating that the item should be", "     added in a pending state. Existing pending items in a pane are replaced with", "     new pending items when they are opened.", "", " Returns the added item."], "name": "Pane.addItem", "params": ["item", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 642, "start_line": 595}, "call_info": {"func_end_line": 581, "comment": [" Public: Make the given item *active*, causing it to be displayed by", " the pane's view.", "", " * `item` The item to activate", " * `options` (optional) {Object}", "   * `pending` (optional) {Boolean} indicating that the item should be added", "     in a pending state if it does not yet exist in the pane. Existing pending", "     items in a pane are replaced with new pending items when they are opened."], "code": "  activateItem (item, options = {}) {\r\n    if (item) {\r\n      const index = (this.getPendingItem() === this.activeItem)\r\n        ? this.getActiveItemIndex()\r\n        : this.getActiveItemIndex() + 1\r\n      this.addItem(item, Object.assign({}, options, {index}))\r\n      this.setActiveItem(item)\r\n    }\r\n  }\r", "name": "addItem", "func_location": "Pane.activateItem", "args": ["item", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 578, "func_start_line": 573}}, {"func_info": {"comment": [], "name": "Pane.setActiveItem", "params": ["activeItem", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 443, "start_line": 434}, "call_info": {"func_end_line": 581, "comment": [" Public: Make the given item *active*, causing it to be displayed by", " the pane's view.", "", " * `item` The item to activate", " * `options` (optional) {Object}", "   * `pending` (optional) {Boolean} indicating that the item should be added", "     in a pending state if it does not yet exist in the pane. Existing pending", "     items in a pane are replaced with new pending items when they are opened."], "code": "  activateItem (item, options = {}) {\r\n    if (item) {\r\n      const index = (this.getPendingItem() === this.activeItem)\r\n        ? this.getActiveItemIndex()\r\n        : this.getActiveItemIndex() + 1\r\n      this.addItem(item, Object.assign({}, options, {index}))\r\n      this.setActiveItem(item)\r\n    }\r\n  }\r", "name": "setActiveItem", "func_location": "Pane.activateItem", "args": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 579, "func_start_line": 573}}, {"func_info": {"comment": [" Public: Return the item at the given index.", "", " * `index` {Number}", "", " Returns an item or `null` if no item exists at the given index."], "name": "Pane.itemAtIndex", "params": ["index"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 478, "start_line": 476}, "call_info": {"func_end_line": 563, "comment": [" Public: Activate the item at the given index.", "", " * `index` {Number}"], "code": "  activateItemAtIndex (index) {\r\n    const item = this.itemAtIndex(index) || this.getActiveItem()\r\n    return this.setActiveItem(item)\r\n  }\r", "name": "itemAtIndex", "func_location": "Pane.activateItemAtIndex", "args": ["index"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 561, "func_start_line": 560}}, {"func_info": {"comment": [" Public: Get the active pane item in this pane.", "", " Returns a pane item."], "name": "Pane.getActiveItem", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 432, "start_line": 432}, "call_info": {"func_end_line": 563, "comment": [" Public: Activate the item at the given index.", "", " * `index` {Number}"], "code": "  activateItemAtIndex (index) {\r\n    const item = this.itemAtIndex(index) || this.getActiveItem()\r\n    return this.setActiveItem(item)\r\n  }\r", "name": "getActiveItem", "func_location": "Pane.activateItemAtIndex", "args": ["index"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 561, "func_start_line": 560}}, {"func_info": {"comment": [], "name": "Pane.setActiveItem", "params": ["activeItem", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 443, "start_line": 434}, "call_info": {"func_end_line": 563, "comment": [" Public: Activate the item at the given index.", "", " * `index` {Number}"], "code": "  activateItemAtIndex (index) {\r\n    const item = this.itemAtIndex(index) || this.getActiveItem()\r\n    return this.setActiveItem(item)\r\n  }\r", "name": "setActiveItem", "func_location": "Pane.activateItemAtIndex", "args": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 562, "func_start_line": 560}}, {"func_info": {"comment": [" Public: Return the first item that matches the given URI or undefined if", " none exists.", "", " * `uri` {String} containing a URI."], "name": "Pane.itemForURI", "params": ["uri"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 977, "start_line": 969}, "call_info": {"func_end_line": 992, "comment": [" Public: Activate the first item that matches the given URI.", "", " * `uri` {String} containing a URI.", "", " Returns a {Boolean} indicating whether an item matching the URI was found."], "code": "  activateItemForURI (uri) {\r\n    const item = this.itemForURI(uri)\r\n    if (item) {\r\n      this.activateItem(item)\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r", "name": "itemForURI", "func_location": "Pane.activateItemForURI", "args": ["uri"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 985, "func_start_line": 984}}, {"func_info": {"comment": [" Public: Make the given item *active*, causing it to be displayed by", " the pane's view.", "", " * `item` The item to activate", " * `options` (optional) {Object}", "   * `pending` (optional) {Boolean} indicating that the item should be added", "     in a pending state if it does not yet exist in the pane. Existing pending", "     items in a pane are replaced with new pending items when they are opened."], "name": "Pane.activateItem", "params": ["item", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 581, "start_line": 573}, "call_info": {"func_end_line": 992, "comment": [" Public: Activate the first item that matches the given URI.", "", " * `uri` {String} containing a URI.", "", " Returns a {Boolean} indicating whether an item matching the URI was found."], "code": "  activateItemForURI (uri) {\r\n    const item = this.itemForURI(uri)\r\n    if (item) {\r\n      this.activateItem(item)\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r", "name": "activateItem", "func_location": "Pane.activateItemForURI", "args": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 987, "func_start_line": 984}}, {"func_info": {"comment": [" Public: Activate the item at the given index.", "", " * `index` {Number}"], "name": "Pane.activateItemAtIndex", "params": ["index"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 563, "start_line": 560}, "call_info": {"func_end_line": 534, "code": "  activateLastItem () {\r\n    this.activateItemAtIndex(this.items.length - 1)\r\n  }\r", "name": "activateItemAtIndex", "func_location": "Pane.activateLastItem", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 533, "func_start_line": 532}}, {"func_info": {"comment": [" Public: Get the index of the active item.", "", " Returns a {Number}."], "name": "Pane.getActiveItemIndex", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 555, "start_line": 553}, "call_info": {"func_end_line": 520, "comment": [" Public: Makes the next item active."], "code": "  activateNextItem () {\r\n    const index = this.getActiveItemIndex()\r\n    if (index < (this.items.length - 1)) {\r\n      this.activateItemAtIndex(index + 1)\r\n    } else {\r\n      this.activateItemAtIndex(0)\r\n    }\r\n  }\r", "name": "getActiveItemIndex", "func_location": "Pane.activateNextItem", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 514, "func_start_line": 513}}, {"func_info": {"comment": [" Public: Activate the item at the given index.", "", " * `index` {Number}"], "name": "Pane.activateItemAtIndex", "params": ["index"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 563, "start_line": 560}, "call_info": {"func_end_line": 520, "comment": [" Public: Makes the next item active."], "code": "  activateNextItem () {\r\n    const index = this.getActiveItemIndex()\r\n    if (index < (this.items.length - 1)) {\r\n      this.activateItemAtIndex(index + 1)\r\n    } else {\r\n      this.activateItemAtIndex(0)\r\n    }\r\n  }\r", "name": "activateItemAtIndex", "func_location": "Pane.activateNextItem", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 516, "func_start_line": 513}}, {"func_info": {"comment": [" Public: Activate the item at the given index.", "", " * `index` {Number}"], "name": "Pane.activateItemAtIndex", "params": ["index"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 563, "start_line": 560}, "call_info": {"func_end_line": 520, "comment": [" Public: Makes the next item active."], "code": "  activateNextItem () {\r\n    const index = this.getActiveItemIndex()\r\n    if (index < (this.items.length - 1)) {\r\n      this.activateItemAtIndex(index + 1)\r\n    } else {\r\n      this.activateItemAtIndex(0)\r\n    }\r\n  }\r", "name": "activateItemAtIndex", "func_location": "Pane.activateNextItem", "args": [{"type": "number"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 518, "func_start_line": 513}}, {"func_info": {"comment": [], "name": "PaneContainer.getPanes", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 152, "start_line": 146}, "call_info": {"func_end_line": 198, "code": "  activateNextPane () {\r\n    const panes = this.getPanes()\r\n    if (panes.length > 1) {\r\n      const currentIndex = panes.indexOf(this.activePane)\r\n      const nextIndex = (currentIndex + 1) % panes.length\r\n      panes[nextIndex].activate()\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r", "name": "getPanes", "func_location": "PaneContainer.activateNextPane", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 189, "func_start_line": 188}}, {"func_info": {"comment": ["\r\n  Section: Panes\r\n  ", " Extended: Get the most recently focused pane container.", "", " Returns a {Dock} or the {WorkspaceCenter}."], "name": "Workspace.getActivePaneContainer", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1426, "start_line": 1424}, "call_info": {"func_end_line": 1449, "comment": [" Extended: Make the next pane active."], "code": "  activateNextPane () {\r\n    return this.getActivePaneContainer().activateNextPane()\r\n  }\r", "name": "getActivePaneContainer", "func_location": "Workspace.activateNextPane", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1448, "func_start_line": 1447}}, {"func_info": {"comment": [], "name": "Pane.setActiveItem", "params": ["activeItem", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 443, "start_line": 434}, "call_info": {"func_end_line": 490, "comment": [" Makes the next item in the itemStack active."], "code": "  activateNextRecentlyUsedItem () {\r\n    if (this.items.length > 1) {\r\n      if (this.itemStackIndex == null) this.itemStackIndex = this.itemStack.length - 1\r\n      if (this.itemStackIndex === 0) this.itemStackIndex = this.itemStack.length\r\n      this.itemStackIndex--\r\n      const nextRecentlyUsedItem = this.itemStack[this.itemStackIndex]\r\n      this.emitter.emit('choose-next-mru-item', nextRecentlyUsedItem)\r\n      this.setActiveItem(nextRecentlyUsedItem, {modifyStack: false})\r\n    }\r\n  }\r", "name": "setActiveItem", "func_location": "Pane.activateNextRecentlyUsedItem", "args": ["nextRecentlyUsedItem", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 488, "func_start_line": 481}}, {"func_info": {"comment": [], "name": "Package.requireMainModule", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 784, "start_line": 755}, "call_info": {"func_end_line": 236, "code": "  activateNow () {\r\n    try {\r\n      if (!this.mainModule) this.requireMainModule()\r\n      this.configSchemaRegisteredOnActivate = this.registerConfigSchemaFromMainModule()\r\n      this.registerViewProviders()\r\n      this.activateStylesheets()\r\n      if (this.mainModule && !this.mainActivated) {\r\n        this.initializeIfNeeded()\r\n        if (typeof this.mainModule.activateConfig === 'function') {\r\n          this.mainModule.activateConfig()\r\n        }\r\n        if (typeof this.mainModule.activate === 'function') {\r\n          this.mainModule.activate(this.packageManager.getPackageState(this.name) || {})\r\n        }\r\n        this.mainActivated = true\r\n        this.activateServices()\r\n      }\r\n      if (this.activationCommandSubscriptions) this.activationCommandSubscriptions.dispose()\r\n      if (this.activationHookSubscriptions) this.activationHookSubscriptions.dispose()\r\n    } catch (error) {\r\n      this.handleError(`Failed to activate the ${this.name} package`, error)\r\n    }\r\n\r\n    if (typeof this.resolveActivationPromise === 'function') this.resolveActivationPromise()\r\n  }\r", "name": "requireMainModule", "func_location": "Package.activateNow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 214, "func_start_line": 212}}, {"func_info": {"comment": [], "name": "Package.registerConfigSchemaFromMainModule", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 256, "start_line": 248}, "call_info": {"func_end_line": 236, "code": "  activateNow () {\r\n    try {\r\n      if (!this.mainModule) this.requireMainModule()\r\n      this.configSchemaRegisteredOnActivate = this.registerConfigSchemaFromMainModule()\r\n      this.registerViewProviders()\r\n      this.activateStylesheets()\r\n      if (this.mainModule && !this.mainActivated) {\r\n        this.initializeIfNeeded()\r\n        if (typeof this.mainModule.activateConfig === 'function') {\r\n          this.mainModule.activateConfig()\r\n        }\r\n        if (typeof this.mainModule.activate === 'function') {\r\n          this.mainModule.activate(this.packageManager.getPackageState(this.name) || {})\r\n        }\r\n        this.mainActivated = true\r\n        this.activateServices()\r\n      }\r\n      if (this.activationCommandSubscriptions) this.activationCommandSubscriptions.dispose()\r\n      if (this.activationHookSubscriptions) this.activationHookSubscriptions.dispose()\r\n    } catch (error) {\r\n      this.handleError(`Failed to activate the ${this.name} package`, error)\r\n    }\r\n\r\n    if (typeof this.resolveActivationPromise === 'function') this.resolveActivationPromise()\r\n  }\r", "name": "registerConfigSchemaFromMainModule", "func_location": "Package.activateNow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 215, "func_start_line": 212}}, {"func_info": {"comment": [], "name": "Package.registerViewProviders", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 537, "start_line": 526}, "call_info": {"func_end_line": 236, "code": "  activateNow () {\r\n    try {\r\n      if (!this.mainModule) this.requireMainModule()\r\n      this.configSchemaRegisteredOnActivate = this.registerConfigSchemaFromMainModule()\r\n      this.registerViewProviders()\r\n      this.activateStylesheets()\r\n      if (this.mainModule && !this.mainActivated) {\r\n        this.initializeIfNeeded()\r\n        if (typeof this.mainModule.activateConfig === 'function') {\r\n          this.mainModule.activateConfig()\r\n        }\r\n        if (typeof this.mainModule.activate === 'function') {\r\n          this.mainModule.activate(this.packageManager.getPackageState(this.name) || {})\r\n        }\r\n        this.mainActivated = true\r\n        this.activateServices()\r\n      }\r\n      if (this.activationCommandSubscriptions) this.activationCommandSubscriptions.dispose()\r\n      if (this.activationHookSubscriptions) this.activationHookSubscriptions.dispose()\r\n    } catch (error) {\r\n      this.handleError(`Failed to activate the ${this.name} package`, error)\r\n    }\r\n\r\n    if (typeof this.resolveActivationPromise === 'function') this.resolveActivationPromise()\r\n  }\r", "name": "registerViewProviders", "func_location": "Package.activateNow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 216, "func_start_line": 212}}, {"func_info": {"comment": [], "name": "Package.activateStylesheets", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 295, "start_line": 265}, "call_info": {"func_end_line": 236, "code": "  activateNow () {\r\n    try {\r\n      if (!this.mainModule) this.requireMainModule()\r\n      this.configSchemaRegisteredOnActivate = this.registerConfigSchemaFromMainModule()\r\n      this.registerViewProviders()\r\n      this.activateStylesheets()\r\n      if (this.mainModule && !this.mainActivated) {\r\n        this.initializeIfNeeded()\r\n        if (typeof this.mainModule.activateConfig === 'function') {\r\n          this.mainModule.activateConfig()\r\n        }\r\n        if (typeof this.mainModule.activate === 'function') {\r\n          this.mainModule.activate(this.packageManager.getPackageState(this.name) || {})\r\n        }\r\n        this.mainActivated = true\r\n        this.activateServices()\r\n      }\r\n      if (this.activationCommandSubscriptions) this.activationCommandSubscriptions.dispose()\r\n      if (this.activationHookSubscriptions) this.activationHookSubscriptions.dispose()\r\n    } catch (error) {\r\n      this.handleError(`Failed to activate the ${this.name} package`, error)\r\n    }\r\n\r\n    if (typeof this.resolveActivationPromise === 'function') this.resolveActivationPromise()\r\n  }\r", "name": "activateStylesheets", "func_location": "Package.activateNow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 217, "func_start_line": 212}}, {"func_info": {"comment": [], "name": "Package.initializeIfNeeded", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 187, "start_line": 170}, "call_info": {"func_end_line": 236, "code": "  activateNow () {\r\n    try {\r\n      if (!this.mainModule) this.requireMainModule()\r\n      this.configSchemaRegisteredOnActivate = this.registerConfigSchemaFromMainModule()\r\n      this.registerViewProviders()\r\n      this.activateStylesheets()\r\n      if (this.mainModule && !this.mainActivated) {\r\n        this.initializeIfNeeded()\r\n        if (typeof this.mainModule.activateConfig === 'function') {\r\n          this.mainModule.activateConfig()\r\n        }\r\n        if (typeof this.mainModule.activate === 'function') {\r\n          this.mainModule.activate(this.packageManager.getPackageState(this.name) || {})\r\n        }\r\n        this.mainActivated = true\r\n        this.activateServices()\r\n      }\r\n      if (this.activationCommandSubscriptions) this.activationCommandSubscriptions.dispose()\r\n      if (this.activationHookSubscriptions) this.activationHookSubscriptions.dispose()\r\n    } catch (error) {\r\n      this.handleError(`Failed to activate the ${this.name} package`, error)\r\n    }\r\n\r\n    if (typeof this.resolveActivationPromise === 'function') this.resolveActivationPromise()\r\n  }\r", "name": "initializeIfNeeded", "func_location": "Package.activateNow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 219, "func_start_line": 212}}, {"func_info": {"comment": [], "name": "Package.activateServices", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 403, "start_line": 380}, "call_info": {"func_end_line": 236, "code": "  activateNow () {\r\n    try {\r\n      if (!this.mainModule) this.requireMainModule()\r\n      this.configSchemaRegisteredOnActivate = this.registerConfigSchemaFromMainModule()\r\n      this.registerViewProviders()\r\n      this.activateStylesheets()\r\n      if (this.mainModule && !this.mainActivated) {\r\n        this.initializeIfNeeded()\r\n        if (typeof this.mainModule.activateConfig === 'function') {\r\n          this.mainModule.activateConfig()\r\n        }\r\n        if (typeof this.mainModule.activate === 'function') {\r\n          this.mainModule.activate(this.packageManager.getPackageState(this.name) || {})\r\n        }\r\n        this.mainActivated = true\r\n        this.activateServices()\r\n      }\r\n      if (this.activationCommandSubscriptions) this.activationCommandSubscriptions.dispose()\r\n      if (this.activationHookSubscriptions) this.activationHookSubscriptions.dispose()\r\n    } catch (error) {\r\n      this.handleError(`Failed to activate the ${this.name} package`, error)\r\n    }\r\n\r\n    if (typeof this.resolveActivationPromise === 'function') this.resolveActivationPromise()\r\n  }\r", "name": "activateServices", "func_location": "Package.activateNow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 227, "func_start_line": 212}}, {"func_info": {"comment": [], "name": "Package.handleError", "params": ["message", "error"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 1105, "start_line": 1085}, "call_info": {"func_end_line": 236, "code": "  activateNow () {\r\n    try {\r\n      if (!this.mainModule) this.requireMainModule()\r\n      this.configSchemaRegisteredOnActivate = this.registerConfigSchemaFromMainModule()\r\n      this.registerViewProviders()\r\n      this.activateStylesheets()\r\n      if (this.mainModule && !this.mainActivated) {\r\n        this.initializeIfNeeded()\r\n        if (typeof this.mainModule.activateConfig === 'function') {\r\n          this.mainModule.activateConfig()\r\n        }\r\n        if (typeof this.mainModule.activate === 'function') {\r\n          this.mainModule.activate(this.packageManager.getPackageState(this.name) || {})\r\n        }\r\n        this.mainActivated = true\r\n        this.activateServices()\r\n      }\r\n      if (this.activationCommandSubscriptions) this.activationCommandSubscriptions.dispose()\r\n      if (this.activationHookSubscriptions) this.activationHookSubscriptions.dispose()\r\n    } catch (error) {\r\n      this.handleError(`Failed to activate the ${this.name} package`, error)\r\n    }\r\n\r\n    if (typeof this.resolveActivationPromise === 'function') this.resolveActivationPromise()\r\n  }\r", "name": "handleError", "func_location": "Package.activateNow", "args": [null, "error"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 232, "func_start_line": 212}}, {"func_info": {"comment": [" Public: Get the active {Package} with the given name.", "", " * `name` - The {String} package name.", "", " Returns a {Package} or undefined."], "name": "PackageManager.getActivePackage", "params": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 302, "start_line": 300}, "call_info": {"func_end_line": 722, "comment": [" Activate a single package by name"], "code": "  activatePackage (name) {\r\n    let pack = this.getActivePackage(name)\r\n    if (pack) {\r\n      return Promise.resolve(pack)\r\n    }\r\n\r\n    pack = this.loadPackage(name)\r\n    if (!pack) {\r\n      return Promise.reject(new Error(`Failed to load package '${name}'`))\r\n    }\r\n\r\n    this.activatingPackages[pack.name] = pack\r\n    const activationPromise = pack.activate().then(() => {\r\n      if (this.activatingPackages[pack.name] != null) {\r\n        delete this.activatingPackages[pack.name]\r\n        this.activePackages[pack.name] = pack\r\n        this.emitter.emit('did-activate-package', pack)\r\n      }\r\n      return pack\r\n    })\r\n\r\n    if (this.deferredActivationHooks == null) {\r\n      this.triggeredActivationHooks.forEach(hook => this.activationHookEmitter.emit(hook))\r\n    }\r\n\r\n    return activationPromise\r\n  }\r", "name": "getActivePackage", "func_location": "PackageManager.activatePackage", "args": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 697, "func_start_line": 696}}, {"func_info": {"comment": [], "name": "PackageManager.loadPackage", "params": ["nameOrPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 569, "start_line": 551}, "call_info": {"func_end_line": 722, "comment": [" Activate a single package by name"], "code": "  activatePackage (name) {\r\n    let pack = this.getActivePackage(name)\r\n    if (pack) {\r\n      return Promise.resolve(pack)\r\n    }\r\n\r\n    pack = this.loadPackage(name)\r\n    if (!pack) {\r\n      return Promise.reject(new Error(`Failed to load package '${name}'`))\r\n    }\r\n\r\n    this.activatingPackages[pack.name] = pack\r\n    const activationPromise = pack.activate().then(() => {\r\n      if (this.activatingPackages[pack.name] != null) {\r\n        delete this.activatingPackages[pack.name]\r\n        this.activePackages[pack.name] = pack\r\n        this.emitter.emit('did-activate-package', pack)\r\n      }\r\n      return pack\r\n    })\r\n\r\n    if (this.deferredActivationHooks == null) {\r\n      this.triggeredActivationHooks.forEach(hook => this.activationHookEmitter.emit(hook))\r\n    }\r\n\r\n    return activationPromise\r\n  }\r", "name": "loadPackage", "func_location": "PackageManager.activatePackage", "args": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 702, "func_start_line": 696}}, {"func_info": {"comment": [], "name": "PackageManager.observeDisabledPackages", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 456, "start_line": 444}, "call_info": {"func_end_line": 693, "code": "  activatePackages (packages) {\r\n    const promises = []\r\n    this.config.transactAsync(() => {\r\n      for (const pack of packages) {\r\n        const promise = this.activatePackage(pack.name)\r\n        if (!pack.activationShouldBeDeferred()) {\r\n          promises.push(promise)\r\n        }\r\n      }\r\n      return Promise.all(promises)\r\n    })\r\n    this.observeDisabledPackages()\r\n    this.observePackagesWithKeymapsDisabled()\r\n    return promises\r\n  }\r", "name": "observeDisabledPackages", "func_location": "PackageManager.activatePackages", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 690, "func_start_line": 679}}, {"func_info": {"comment": [], "name": "PackageManager.observePackagesWithKeymapsDisabled", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 490, "start_line": 465}, "call_info": {"func_end_line": 693, "code": "  activatePackages (packages) {\r\n    const promises = []\r\n    this.config.transactAsync(() => {\r\n      for (const pack of packages) {\r\n        const promise = this.activatePackage(pack.name)\r\n        if (!pack.activationShouldBeDeferred()) {\r\n          promises.push(promise)\r\n        }\r\n      }\r\n      return Promise.all(promises)\r\n    })\r\n    this.observeDisabledPackages()\r\n    this.observePackagesWithKeymapsDisabled()\r\n    return promises\r\n  }\r", "name": "observePackagesWithKeymapsDisabled", "func_location": "PackageManager.activatePackages", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 691, "func_start_line": 679}}, {"func_info": {"comment": [], "name": "ThemeManager.activateThemes", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 348, "start_line": 319}, "call_info": {"func_end_line": 98, "code": "  activatePackages () {\r\n    return this.activateThemes()\r\n  }\r", "name": "activateThemes", "func_location": "ThemeManager.activatePackages", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 97, "func_start_line": 96}}, {"func_info": {"comment": [" Public: Get the index of the active item.", "", " Returns a {Number}."], "name": "Pane.getActiveItemIndex", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 555, "start_line": 553}, "call_info": {"func_end_line": 530, "comment": [" Public: Makes the previous item active."], "code": "  activatePreviousItem () {\r\n    const index = this.getActiveItemIndex()\r\n    if (index > 0) {\r\n      this.activateItemAtIndex(index - 1)\r\n    } else {\r\n      this.activateItemAtIndex(this.items.length - 1)\r\n    }\r\n  }\r", "name": "getActiveItemIndex", "func_location": "Pane.activatePreviousItem", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 524, "func_start_line": 523}}, {"func_info": {"comment": [" Public: Activate the item at the given index.", "", " * `index` {Number}"], "name": "Pane.activateItemAtIndex", "params": ["index"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 563, "start_line": 560}, "call_info": {"func_end_line": 530, "comment": [" Public: Makes the previous item active."], "code": "  activatePreviousItem () {\r\n    const index = this.getActiveItemIndex()\r\n    if (index > 0) {\r\n      this.activateItemAtIndex(index - 1)\r\n    } else {\r\n      this.activateItemAtIndex(this.items.length - 1)\r\n    }\r\n  }\r", "name": "activateItemAtIndex", "func_location": "Pane.activatePreviousItem", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 526, "func_start_line": 523}}, {"func_info": {"comment": [" Public: Activate the item at the given index.", "", " * `index` {Number}"], "name": "Pane.activateItemAtIndex", "params": ["index"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 563, "start_line": 560}, "call_info": {"func_end_line": 530, "comment": [" Public: Makes the previous item active."], "code": "  activatePreviousItem () {\r\n    const index = this.getActiveItemIndex()\r\n    if (index > 0) {\r\n      this.activateItemAtIndex(index - 1)\r\n    } else {\r\n      this.activateItemAtIndex(this.items.length - 1)\r\n    }\r\n  }\r", "name": "activateItemAtIndex", "func_location": "Pane.activatePreviousItem", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 528, "func_start_line": 523}}, {"func_info": {"comment": [], "name": "PaneContainer.getPanes", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 152, "start_line": 146}, "call_info": {"func_end_line": 211, "code": "  activatePreviousPane () {\r\n    const panes = this.getPanes()\r\n    if (panes.length > 1) {\r\n      const currentIndex = panes.indexOf(this.activePane)\r\n      let previousIndex = currentIndex - 1\r\n      if (previousIndex < 0) { previousIndex = panes.length - 1 }\r\n      panes[previousIndex].activate()\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r", "name": "getPanes", "func_location": "PaneContainer.activatePreviousPane", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 201, "func_start_line": 200}}, {"func_info": {"comment": ["\r\n  Section: Panes\r\n  ", " Extended: Get the most recently focused pane container.", "", " Returns a {Dock} or the {WorkspaceCenter}."], "name": "Workspace.getActivePaneContainer", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1426, "start_line": 1424}, "call_info": {"func_end_line": 1454, "comment": [" Extended: Make the previous pane active."], "code": "  activatePreviousPane () {\r\n    return this.getActivePaneContainer().activatePreviousPane()\r\n  }\r", "name": "getActivePaneContainer", "func_location": "Workspace.activatePreviousPane", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1453, "func_start_line": 1452}}, {"func_info": {"comment": [], "name": "Pane.setActiveItem", "params": ["activeItem", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 443, "start_line": 434}, "call_info": {"func_end_line": 503, "comment": [" Makes the previous item in the itemStack active."], "code": "  activatePreviousRecentlyUsedItem () {\r\n    if (this.items.length > 1) {\r\n      if (this.itemStackIndex + 1 === this.itemStack.length || this.itemStackIndex == null) {\r\n        this.itemStackIndex = -1\r\n      }\r\n      this.itemStackIndex++\r\n      const previousRecentlyUsedItem = this.itemStack[this.itemStackIndex]\r\n      this.emitter.emit('choose-last-mru-item', previousRecentlyUsedItem)\r\n      this.setActiveItem(previousRecentlyUsedItem, {modifyStack: false})\r\n    }\r\n  }\r", "name": "setActiveItem", "func_location": "Pane.activatePreviousRecentlyUsedItem", "args": ["previousRecentlyUsedItem", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 501, "func_start_line": 493}}, {"func_info": {"comment": [], "name": "Package.deactivateKeymaps", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 347, "start_line": 340}, "call_info": {"func_end_line": 324, "code": "  activateResources () {\r\n    if (!this.activationDisposables) this.activationDisposables = new CompositeDisposable()\r\n\r\n    const packagesWithKeymapsDisabled = this.config.get('core.packagesWithKeymapsDisabled')\r\n    if (packagesWithKeymapsDisabled && packagesWithKeymapsDisabled.includes(this.name)) {\r\n      this.deactivateKeymaps()\r\n    } else if (!this.keymapActivated) {\r\n      this.activateKeymaps()\r\n    }\r\n\r\n    if (!this.menusActivated) {\r\n      this.activateMenus()\r\n    }\r\n\r\n    if (!this.grammarsActivated) {\r\n      for (let grammar of this.grammars) {\r\n        grammar.activate()\r\n      }\r\n      this.grammarsActivated = true\r\n    }\r\n\r\n    if (!this.settingsActivated) {\r\n      for (let settings of this.settings) {\r\n        settings.activate(this.config)\r\n      }\r\n      this.settingsActivated = true\r\n    }\r\n  }\r", "name": "deactivateKeymaps", "func_location": "Package.activateResources", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 302, "func_start_line": 297}}, {"func_info": {"comment": [], "name": "Package.activateKeymaps", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 338, "start_line": 326}, "call_info": {"func_end_line": 324, "code": "  activateResources () {\r\n    if (!this.activationDisposables) this.activationDisposables = new CompositeDisposable()\r\n\r\n    const packagesWithKeymapsDisabled = this.config.get('core.packagesWithKeymapsDisabled')\r\n    if (packagesWithKeymapsDisabled && packagesWithKeymapsDisabled.includes(this.name)) {\r\n      this.deactivateKeymaps()\r\n    } else if (!this.keymapActivated) {\r\n      this.activateKeymaps()\r\n    }\r\n\r\n    if (!this.menusActivated) {\r\n      this.activateMenus()\r\n    }\r\n\r\n    if (!this.grammarsActivated) {\r\n      for (let grammar of this.grammars) {\r\n        grammar.activate()\r\n      }\r\n      this.grammarsActivated = true\r\n    }\r\n\r\n    if (!this.settingsActivated) {\r\n      for (let settings of this.settings) {\r\n        settings.activate(this.config)\r\n      }\r\n      this.settingsActivated = true\r\n    }\r\n  }\r", "name": "activateKeymaps", "func_location": "Package.activateResources", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 304, "func_start_line": 297}}, {"func_info": {"comment": [], "name": "Package.activateMenus", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 378, "start_line": 356}, "call_info": {"func_end_line": 324, "code": "  activateResources () {\r\n    if (!this.activationDisposables) this.activationDisposables = new CompositeDisposable()\r\n\r\n    const packagesWithKeymapsDisabled = this.config.get('core.packagesWithKeymapsDisabled')\r\n    if (packagesWithKeymapsDisabled && packagesWithKeymapsDisabled.includes(this.name)) {\r\n      this.deactivateKeymaps()\r\n    } else if (!this.keymapActivated) {\r\n      this.activateKeymaps()\r\n    }\r\n\r\n    if (!this.menusActivated) {\r\n      this.activateMenus()\r\n    }\r\n\r\n    if (!this.grammarsActivated) {\r\n      for (let grammar of this.grammars) {\r\n        grammar.activate()\r\n      }\r\n      this.grammarsActivated = true\r\n    }\r\n\r\n    if (!this.settingsActivated) {\r\n      for (let settings of this.settings) {\r\n        settings.activate(this.config)\r\n      }\r\n      this.settingsActivated = true\r\n    }\r\n  }\r", "name": "activateMenus", "func_location": "Package.activateResources", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 308, "func_start_line": 297}}, {"func_info": {"comment": [], "name": "Package.getStyleSheetPriority", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 89, "start_line": 89}, "call_info": {"func_end_line": 295, "code": "  activateStylesheets () {\r\n    if (this.stylesheetsActivated) return\r\n\r\n    this.stylesheetDisposables = new CompositeDisposable()\r\n\r\n    const priority = this.getStyleSheetPriority()\r\n    for (let [sourcePath, source] of this.stylesheets) {\r\n      const match = path.basename(sourcePath).match(/[^.]*\\.([^.]*)\\./)\r\n\r\n      let context\r\n      if (match) {\r\n        context = match[1]\r\n      } else if (this.metadata.theme === 'syntax') {\r\n        context = 'atom-text-editor'\r\n      }\r\n\r\n      this.stylesheetDisposables.add(\r\n        this.styleManager.addStyleSheet(\r\n          source,\r\n          {\r\n            sourcePath,\r\n            priority,\r\n            context,\r\n            skipDeprecatedSelectorsTransformation: this.bundledPackage\r\n          }\r\n        )\r\n      )\r\n    }\r\n\r\n    this.stylesheetsActivated = true\r\n  }\r", "name": "getStyleSheetPriority", "func_location": "Package.activateStylesheets", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 270, "func_start_line": 265}}, {"func_info": {"comment": [], "name": "Package.hasActivationCommands", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 821, "start_line": 814}, "call_info": {"func_end_line": 807, "code": "  activationShouldBeDeferred () {\r\n    return this.hasActivationCommands() || this.hasActivationHooks() || this.hasDeferredURIHandler()\r\n  }\r", "name": "hasActivationCommands", "func_location": "Package.activationShouldBeDeferred", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 806, "func_start_line": 805}}, {"func_info": {"comment": [], "name": "Package.hasActivationHooks", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 812, "start_line": 809}, "call_info": {"func_end_line": 807, "code": "  activationShouldBeDeferred () {\r\n    return this.hasActivationCommands() || this.hasActivationHooks() || this.hasDeferredURIHandler()\r\n  }\r", "name": "hasActivationHooks", "func_location": "Package.activationShouldBeDeferred", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 806, "func_start_line": 805}}, {"func_info": {"comment": [], "name": "Package.hasDeferredURIHandler", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 826, "start_line": 823}, "call_info": {"func_end_line": 807, "code": "  activationShouldBeDeferred () {\r\n    return this.hasActivationCommands() || this.hasActivationHooks() || this.hasDeferredURIHandler()\r\n  }\r", "name": "hasDeferredURIHandler", "func_location": "Package.activationShouldBeDeferred", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 806, "func_start_line": 805}}, {"func_info": {"comment": [], "name": "PaneElement.hasFocus", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js", "end_line": 213, "start_line": 209}, "call_info": {"func_end_line": 166, "code": "  activeItemChanged (item) {\r\n    delete this.dataset.activeItemName\r\n    delete this.dataset.activeItemPath\r\n    if (this.changePathDisposable != null) {\r\n      this.changePathDisposable.dispose()\r\n    }\r\n    if (item == null) {\r\n      return\r\n    }\r\n    const hasFocus = this.hasFocus()\r\n    const itemView = this.views.getView(item)\r\n    const itemPath = typeof item.getPath === 'function' ? item.getPath() : null\r\n    if (itemPath) {\r\n      this.dataset.activeItemName = path.basename(itemPath)\r\n      this.dataset.activeItemPath = itemPath\r\n      if (item.onDidChangePath != null) {\r\n        this.changePathDisposable = item.onDidChangePath(() => {\r\n          const itemPath = item.getPath()\r\n          this.dataset.activeItemName = path.basename(itemPath)\r\n          this.dataset.activeItemPath = itemPath\r\n        })\r\n      }\r\n    }\r\n    if (!this.itemViews.contains(itemView)) {\r\n      this.itemViews.appendChild(itemView)\r\n    }\r\n    for (const child of this.itemViews.children) {\r\n      if (child === itemView) {\r\n        if (this.attached) {\r\n          this.showItemView(child)\r\n        }\r\n      } else {\r\n        this.hideItemView(child)\r\n      }\r\n    }\r\n    if (hasFocus) {\r\n      itemView.focus()\r\n    }\r\n  }\r", "name": "hasFocus", "func_location": "PaneElement.activeItemChanged", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js", "line": 137, "func_start_line": 128}}, {"func_info": {"comment": [], "name": "PaneElement.showItemView", "params": ["itemView"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js", "end_line": 175, "start_line": 168}, "call_info": {"func_end_line": 166, "code": "  activeItemChanged (item) {\r\n    delete this.dataset.activeItemName\r\n    delete this.dataset.activeItemPath\r\n    if (this.changePathDisposable != null) {\r\n      this.changePathDisposable.dispose()\r\n    }\r\n    if (item == null) {\r\n      return\r\n    }\r\n    const hasFocus = this.hasFocus()\r\n    const itemView = this.views.getView(item)\r\n    const itemPath = typeof item.getPath === 'function' ? item.getPath() : null\r\n    if (itemPath) {\r\n      this.dataset.activeItemName = path.basename(itemPath)\r\n      this.dataset.activeItemPath = itemPath\r\n      if (item.onDidChangePath != null) {\r\n        this.changePathDisposable = item.onDidChangePath(() => {\r\n          const itemPath = item.getPath()\r\n          this.dataset.activeItemName = path.basename(itemPath)\r\n          this.dataset.activeItemPath = itemPath\r\n        })\r\n      }\r\n    }\r\n    if (!this.itemViews.contains(itemView)) {\r\n      this.itemViews.appendChild(itemView)\r\n    }\r\n    for (const child of this.itemViews.children) {\r\n      if (child === itemView) {\r\n        if (this.attached) {\r\n          this.showItemView(child)\r\n        }\r\n      } else {\r\n        this.hideItemView(child)\r\n      }\r\n    }\r\n    if (hasFocus) {\r\n      itemView.focus()\r\n    }\r\n  }\r", "name": "showItemView", "func_location": "PaneElement.activeItemChanged", "args": ["child"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js", "line": 157, "func_start_line": 128}}, {"func_info": {"comment": [], "name": "PaneElement.hideItemView", "params": ["itemView"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js", "end_line": 185, "start_line": 177}, "call_info": {"func_end_line": 166, "code": "  activeItemChanged (item) {\r\n    delete this.dataset.activeItemName\r\n    delete this.dataset.activeItemPath\r\n    if (this.changePathDisposable != null) {\r\n      this.changePathDisposable.dispose()\r\n    }\r\n    if (item == null) {\r\n      return\r\n    }\r\n    const hasFocus = this.hasFocus()\r\n    const itemView = this.views.getView(item)\r\n    const itemPath = typeof item.getPath === 'function' ? item.getPath() : null\r\n    if (itemPath) {\r\n      this.dataset.activeItemName = path.basename(itemPath)\r\n      this.dataset.activeItemPath = itemPath\r\n      if (item.onDidChangePath != null) {\r\n        this.changePathDisposable = item.onDidChangePath(() => {\r\n          const itemPath = item.getPath()\r\n          this.dataset.activeItemName = path.basename(itemPath)\r\n          this.dataset.activeItemPath = itemPath\r\n        })\r\n      }\r\n    }\r\n    if (!this.itemViews.contains(itemView)) {\r\n      this.itemViews.appendChild(itemView)\r\n    }\r\n    for (const child of this.itemViews.children) {\r\n      if (child === itemView) {\r\n        if (this.attached) {\r\n          this.showItemView(child)\r\n        }\r\n      } else {\r\n        this.hideItemView(child)\r\n      }\r\n    }\r\n    if (hasFocus) {\r\n      itemView.focus()\r\n    }\r\n  }\r", "name": "hideItemView", "func_location": "PaneElement.activeItemChanged", "args": ["child"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js", "line": 160, "func_start_line": 128}}, {"func_info": {"comment": [" Public: Add one or more command listeners associated with a selector.", "", " ## Arguments: Registering One Command", "", " * `target` A {String} containing a CSS selector or a DOM element. If you", "   pass a selector, the command will be globally associated with all matching", "   elements. The `,` combinator is not currently supported. If you pass a", "   DOM element, the command will be associated with just that element.", " * `commandName` A {String} containing the name of a command you want to", "   handle such as `user:insert-date`.", " * `listener` A listener which handles the event.  Either a {Function} to", "   call when the given command is invoked on an element matching the", "   selector, or an {Object} with a `didDispatch` property which is such a", "   function.", "", "   The function (`listener` itself if it is a function, or the `didDispatch`", "   method if `listener` is an object) will be called with `this` referencing", "   the matching DOM node and the following argument:", "     * `event`: A standard DOM event instance. Call `stopPropagation` or", "       `stopImmediatePropagation` to terminate bubbling early.", "", "   Additionally, `listener` may have additional properties which are returned", "   to those who query using `atom.commands.findCommands`, as well as several", "   meaningful metadata properties:", "     * `displayName`: Overrides any generated `displayName` that would", "       otherwise be generated from the event name.", "     * `description`: Used by consumers to display detailed information about", "       the command.", "     * `hiddenInCommandPalette`: If `true`, this command will not appear in", "       the bundled command palette by default, but can still be shown with.", "       the `Command Palette: Show Hidden Commands` command. This is a good", "       option when you need to register large numbers of commands that don't", "       make sense to be executed from the command palette. Please use this", "       option conservatively, as it could reduce the discoverability of your", "       package's commands.", "", " ## Arguments: Registering Multiple Commands", "", " * `target` A {String} containing a CSS selector or a DOM element. If you", "   pass a selector, the commands will be globally associated with all", "   matching elements. The `,` combinator is not currently supported.", "   If you pass a DOM element, the command will be associated with just that", "   element.", " * `commands` An {Object} mapping command names like `user:insert-date` to", "   listener {Function}s.", "", " Returns a {Disposable} on which `.dispose()` can be called to remove the", " added command handler(s)."], "name": "CommandRegistry.add", "params": ["target", "commandName", "listener", "throwOnInvalidSelector"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js", "end_line": 163, "start_line": 130}, "call_info": {"func_end_line": 163, "comment": [" Public: Add one or more command listeners associated with a selector.", "", " ## Arguments: Registering One Command", "", " * `target` A {String} containing a CSS selector or a DOM element. If you", "   pass a selector, the command will be globally associated with all matching", "   elements. The `,` combinator is not currently supported. If you pass a", "   DOM element, the command will be associated with just that element.", " * `commandName` A {String} containing the name of a command you want to", "   handle such as `user:insert-date`.", " * `listener` A listener which handles the event.  Either a {Function} to", "   call when the given command is invoked on an element matching the", "   selector, or an {Object} with a `didDispatch` property which is such a", "   function.", "", "   The function (`listener` itself if it is a function, or the `didDispatch`", "   method if `listener` is an object) will be called with `this` referencing", "   the matching DOM node and the following argument:", "     * `event`: A standard DOM event instance. Call `stopPropagation` or", "       `stopImmediatePropagation` to terminate bubbling early.", "", "   Additionally, `listener` may have additional properties which are returned", "   to those who query using `atom.commands.findCommands`, as well as several", "   meaningful metadata properties:", "     * `displayName`: Overrides any generated `displayName` that would", "       otherwise be generated from the event name.", "     * `description`: Used by consumers to display detailed information about", "       the command.", "     * `hiddenInCommandPalette`: If `true`, this command will not appear in", "       the bundled command palette by default, but can still be shown with.", "       the `Command Palette: Show Hidden Commands` command. This is a good", "       option when you need to register large numbers of commands that don't", "       make sense to be executed from the command palette. Please use this", "       option conservatively, as it could reduce the discoverability of your", "       package's commands.", "", " ## Arguments: Registering Multiple Commands", "", " * `target` A {String} containing a CSS selector or a DOM element. If you", "   pass a selector, the commands will be globally associated with all", "   matching elements. The `,` combinator is not currently supported.", "   If you pass a DOM element, the command will be associated with just that", "   element.", " * `commands` An {Object} mapping command names like `user:insert-date` to", "   listener {Function}s.", "", " Returns a {Disposable} on which `.dispose()` can be called to remove the", " added command handler(s)."], "code": "  add (target, commandName, listener, throwOnInvalidSelector = true) {\r\n    if (typeof commandName === 'object') {\r\n      const commands = commandName\r\n      throwOnInvalidSelector = listener\r\n      const disposable = new CompositeDisposable()\r\n      for (commandName in commands) {\r\n        listener = commands[commandName]\r\n        disposable.add(this.add(target, commandName, listener, throwOnInvalidSelector))\r\n      }\r\n      return disposable\r\n    }\r\n\r\n    if (listener == null) {\r\n      throw new Error('Cannot register a command with a null listener.')\r\n    }\r\n\r\n    // type Listener = ((e: CustomEvent) => void) | {\r\n    //   displayName?: string,\r\n    //   description?: string,\r\n    //   didDispatch(e: CustomEvent): void,\r\n    // }\r\n    if ((typeof listener !== 'function') && (typeof listener.didDispatch !== 'function')) {\r\n      throw new Error('Listener must be a callback function or an object with a didDispatch method.')\r\n    }\r\n\r\n    if (typeof target === 'string') {\r\n      if (throwOnInvalidSelector) {\r\n        validateSelector(target)\r\n      }\r\n      return this.addSelectorBasedListener(target, commandName, listener)\r\n    } else {\r\n      return this.addInlineListener(target, commandName, listener)\r\n    }\r\n  }\r", "name": "add", "func_location": "CommandRegistry.add", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js", "line": 137, "func_start_line": 130}}, {"func_info": {"comment": [], "name": "CommandRegistry.addSelectorBasedListener", "params": ["selector", "commandName", "listener"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js", "end_line": 181, "start_line": 165}, "call_info": {"func_end_line": 163, "comment": [" Public: Add one or more command listeners associated with a selector.", "", " ## Arguments: Registering One Command", "", " * `target` A {String} containing a CSS selector or a DOM element. If you", "   pass a selector, the command will be globally associated with all matching", "   elements. The `,` combinator is not currently supported. If you pass a", "   DOM element, the command will be associated with just that element.", " * `commandName` A {String} containing the name of a command you want to", "   handle such as `user:insert-date`.", " * `listener` A listener which handles the event.  Either a {Function} to", "   call when the given command is invoked on an element matching the", "   selector, or an {Object} with a `didDispatch` property which is such a", "   function.", "", "   The function (`listener` itself if it is a function, or the `didDispatch`", "   method if `listener` is an object) will be called with `this` referencing", "   the matching DOM node and the following argument:", "     * `event`: A standard DOM event instance. Call `stopPropagation` or", "       `stopImmediatePropagation` to terminate bubbling early.", "", "   Additionally, `listener` may have additional properties which are returned", "   to those who query using `atom.commands.findCommands`, as well as several", "   meaningful metadata properties:", "     * `displayName`: Overrides any generated `displayName` that would", "       otherwise be generated from the event name.", "     * `description`: Used by consumers to display detailed information about", "       the command.", "     * `hiddenInCommandPalette`: If `true`, this command will not appear in", "       the bundled command palette by default, but can still be shown with.", "       the `Command Palette: Show Hidden Commands` command. This is a good", "       option when you need to register large numbers of commands that don't", "       make sense to be executed from the command palette. Please use this", "       option conservatively, as it could reduce the discoverability of your", "       package's commands.", "", " ## Arguments: Registering Multiple Commands", "", " * `target` A {String} containing a CSS selector or a DOM element. If you", "   pass a selector, the commands will be globally associated with all", "   matching elements. The `,` combinator is not currently supported.", "   If you pass a DOM element, the command will be associated with just that", "   element.", " * `commands` An {Object} mapping command names like `user:insert-date` to", "   listener {Function}s.", "", " Returns a {Disposable} on which `.dispose()` can be called to remove the", " added command handler(s)."], "code": "  add (target, commandName, listener, throwOnInvalidSelector = true) {\r\n    if (typeof commandName === 'object') {\r\n      const commands = commandName\r\n      throwOnInvalidSelector = listener\r\n      const disposable = new CompositeDisposable()\r\n      for (commandName in commands) {\r\n        listener = commands[commandName]\r\n        disposable.add(this.add(target, commandName, listener, throwOnInvalidSelector))\r\n      }\r\n      return disposable\r\n    }\r\n\r\n    if (listener == null) {\r\n      throw new Error('Cannot register a command with a null listener.')\r\n    }\r\n\r\n    // type Listener = ((e: CustomEvent) => void) | {\r\n    //   displayName?: string,\r\n    //   description?: string,\r\n    //   didDispatch(e: CustomEvent): void,\r\n    // }\r\n    if ((typeof listener !== 'function') && (typeof listener.didDispatch !== 'function')) {\r\n      throw new Error('Listener must be a callback function or an object with a didDispatch method.')\r\n    }\r\n\r\n    if (typeof target === 'string') {\r\n      if (throwOnInvalidSelector) {\r\n        validateSelector(target)\r\n      }\r\n      return this.addSelectorBasedListener(target, commandName, listener)\r\n    } else {\r\n      return this.addInlineListener(target, commandName, listener)\r\n    }\r\n  }\r", "name": "addSelectorBasedListener", "func_location": "CommandRegistry.add", "args": ["target", "commandName", "listener"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js", "line": 159, "func_start_line": 130}}, {"func_info": {"comment": [], "name": "CommandRegistry.addInlineListener", "params": ["element", "commandName", "listener"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js", "end_line": 205, "start_line": 183}, "call_info": {"func_end_line": 163, "comment": [" Public: Add one or more command listeners associated with a selector.", "", " ## Arguments: Registering One Command", "", " * `target` A {String} containing a CSS selector or a DOM element. If you", "   pass a selector, the command will be globally associated with all matching", "   elements. The `,` combinator is not currently supported. If you pass a", "   DOM element, the command will be associated with just that element.", " * `commandName` A {String} containing the name of a command you want to", "   handle such as `user:insert-date`.", " * `listener` A listener which handles the event.  Either a {Function} to", "   call when the given command is invoked on an element matching the", "   selector, or an {Object} with a `didDispatch` property which is such a", "   function.", "", "   The function (`listener` itself if it is a function, or the `didDispatch`", "   method if `listener` is an object) will be called with `this` referencing", "   the matching DOM node and the following argument:", "     * `event`: A standard DOM event instance. Call `stopPropagation` or", "       `stopImmediatePropagation` to terminate bubbling early.", "", "   Additionally, `listener` may have additional properties which are returned", "   to those who query using `atom.commands.findCommands`, as well as several", "   meaningful metadata properties:", "     * `displayName`: Overrides any generated `displayName` that would", "       otherwise be generated from the event name.", "     * `description`: Used by consumers to display detailed information about", "       the command.", "     * `hiddenInCommandPalette`: If `true`, this command will not appear in", "       the bundled command palette by default, but can still be shown with.", "       the `Command Palette: Show Hidden Commands` command. This is a good", "       option when you need to register large numbers of commands that don't", "       make sense to be executed from the command palette. Please use this", "       option conservatively, as it could reduce the discoverability of your", "       package's commands.", "", " ## Arguments: Registering Multiple Commands", "", " * `target` A {String} containing a CSS selector or a DOM element. If you", "   pass a selector, the commands will be globally associated with all", "   matching elements. The `,` combinator is not currently supported.", "   If you pass a DOM element, the command will be associated with just that", "   element.", " * `commands` An {Object} mapping command names like `user:insert-date` to", "   listener {Function}s.", "", " Returns a {Disposable} on which `.dispose()` can be called to remove the", " added command handler(s)."], "code": "  add (target, commandName, listener, throwOnInvalidSelector = true) {\r\n    if (typeof commandName === 'object') {\r\n      const commands = commandName\r\n      throwOnInvalidSelector = listener\r\n      const disposable = new CompositeDisposable()\r\n      for (commandName in commands) {\r\n        listener = commands[commandName]\r\n        disposable.add(this.add(target, commandName, listener, throwOnInvalidSelector))\r\n      }\r\n      return disposable\r\n    }\r\n\r\n    if (listener == null) {\r\n      throw new Error('Cannot register a command with a null listener.')\r\n    }\r\n\r\n    // type Listener = ((e: CustomEvent) => void) | {\r\n    //   displayName?: string,\r\n    //   description?: string,\r\n    //   didDispatch(e: CustomEvent): void,\r\n    // }\r\n    if ((typeof listener !== 'function') && (typeof listener.didDispatch !== 'function')) {\r\n      throw new Error('Listener must be a callback function or an object with a didDispatch method.')\r\n    }\r\n\r\n    if (typeof target === 'string') {\r\n      if (throwOnInvalidSelector) {\r\n        validateSelector(target)\r\n      }\r\n      return this.addSelectorBasedListener(target, commandName, listener)\r\n    } else {\r\n      return this.addInlineListener(target, commandName, listener)\r\n    }\r\n  }\r", "name": "addInlineListener", "func_location": "CommandRegistry.add", "args": ["target", "commandName", "listener"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js", "line": 161, "func_start_line": 130}}, {"func_info": {"comment": [], "name": "NotificationManager.addNotification", "params": ["notification"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification-manager.js", "end_line": 195, "start_line": 191}, "call_info": {"func_end_line": 189, "code": "  add (type, message, options) {\r\n    return this.addNotification(new Notification(type, message, options))\r\n  }\r", "name": "addNotification", "func_location": "NotificationManager.add", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification-manager.js", "line": 188, "func_start_line": 187}}, {"func_info": {"comment": [" Essential: Add a tooltip to the given element.", "", " * `target` An `HTMLElement`", " * `options` An object with one or more of the following options:", "   * `title` A {String} or {Function} to use for the text in the tip. If", "     a function is passed, `this` will be set to the `target` element. This", "     option is mutually exclusive with the `item` option.", "   * `html` A {Boolean} affecting the interpretation of the `title` option.", "     If `true` (the default), the `title` string will be interpreted as HTML.", "     Otherwise it will be interpreted as plain text.", "   * `item` A view (object with an `.element` property) or a DOM element", "     containing custom content for the tooltip. This option is mutually", "     exclusive with the `title` option.", "   * `class` A {String} with a class to apply to the tooltip element to", "     enable custom styling.", "   * `placement` A {String} or {Function} returning a string to indicate", "     the position of the tooltip relative to `element`. Can be `'top'`,", "     `'bottom'`, `'left'`, `'right'`, or `'auto'`. When `'auto'` is", "     specified, it will dynamically reorient the tooltip. For example, if", "     placement is `'auto left'`, the tooltip will display to the left when", "     possible, otherwise it will display right.", "     When a function is used to determine the placement, it is called with", "     the tooltip DOM node as its first argument and the triggering element", "     DOM node as its second. The `this` context is set to the tooltip", "     instance.", "   * `trigger` A {String} indicating how the tooltip should be displayed.", "     Choose from one of the following options:", "       * `'hover'` Show the tooltip when the mouse hovers over the element.", "         This is the default.", "       * `'click'` Show the tooltip when the element is clicked. The tooltip", "         will be hidden after clicking the element again or anywhere else", "         outside of the tooltip itself.", "       * `'focus'` Show the tooltip when the element is focused.", "       * `'manual'` Show the tooltip immediately and only hide it when the", "         returned disposable is disposed.", "   * `delay` An object specifying the show and hide delay in milliseconds.", "     Defaults to `{show: 1000, hide: 100}` if the `trigger` is `hover` and", "     otherwise defaults to `0` for both values.", "   * `keyBindingCommand` A {String} containing a command name. If you specify", "     this option and a key binding exists that matches the command, it will", "     be appended to the title or rendered alone if no title is specified.", "   * `keyBindingTarget` An `HTMLElement` on which to look up the key binding.", "     If this option is not supplied, the first of all matching key bindings", "     for the given command will be rendered.", "", " Returns a {Disposable} on which `.dispose()` can be called to remove the", " tooltip."], "name": "TooltipManager.add", "params": ["target", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip-manager.js", "end_line": 177, "start_line": 114}, "call_info": {"func_end_line": 177, "comment": [" Essential: Add a tooltip to the given element.", "", " * `target` An `HTMLElement`", " * `options` An object with one or more of the following options:", "   * `title` A {String} or {Function} to use for the text in the tip. If", "     a function is passed, `this` will be set to the `target` element. This", "     option is mutually exclusive with the `item` option.", "   * `html` A {Boolean} affecting the interpretation of the `title` option.", "     If `true` (the default), the `title` string will be interpreted as HTML.", "     Otherwise it will be interpreted as plain text.", "   * `item` A view (object with an `.element` property) or a DOM element", "     containing custom content for the tooltip. This option is mutually", "     exclusive with the `title` option.", "   * `class` A {String} with a class to apply to the tooltip element to", "     enable custom styling.", "   * `placement` A {String} or {Function} returning a string to indicate", "     the position of the tooltip relative to `element`. Can be `'top'`,", "     `'bottom'`, `'left'`, `'right'`, or `'auto'`. When `'auto'` is", "     specified, it will dynamically reorient the tooltip. For example, if", "     placement is `'auto left'`, the tooltip will display to the left when", "     possible, otherwise it will display right.", "     When a function is used to determine the placement, it is called with", "     the tooltip DOM node as its first argument and the triggering element", "     DOM node as its second. The `this` context is set to the tooltip", "     instance.", "   * `trigger` A {String} indicating how the tooltip should be displayed.", "     Choose from one of the following options:", "       * `'hover'` Show the tooltip when the mouse hovers over the element.", "         This is the default.", "       * `'click'` Show the tooltip when the element is clicked. The tooltip", "         will be hidden after clicking the element again or anywhere else", "         outside of the tooltip itself.", "       * `'focus'` Show the tooltip when the element is focused.", "       * `'manual'` Show the tooltip immediately and only hide it when the", "         returned disposable is disposed.", "   * `delay` An object specifying the show and hide delay in milliseconds.", "     Defaults to `{show: 1000, hide: 100}` if the `trigger` is `hover` and", "     otherwise defaults to `0` for both values.", "   * `keyBindingCommand` A {String} containing a command name. If you specify", "     this option and a key binding exists that matches the command, it will", "     be appended to the title or rendered alone if no title is specified.", "   * `keyBindingTarget` An `HTMLElement` on which to look up the key binding.", "     If this option is not supplied, the first of all matching key bindings", "     for the given command will be rendered.", "", " Returns a {Disposable} on which `.dispose()` can be called to remove the", " tooltip."], "code": "  add (target, options) {\r\n    if (target.jquery) {\r\n      const disposable = new CompositeDisposable()\r\n      for (let i = 0; i < target.length; i++) {\r\n        disposable.add(this.add(target[i], options))\r\n      }\r\n      return disposable\r\n    }\r\n\r\n    if (Tooltip == null) { Tooltip = require('./tooltip') }\r\n\r\n    const {keyBindingCommand, keyBindingTarget} = options\r\n\r\n    if (keyBindingCommand != null) {\r\n      const bindings = this.keymapManager.findKeyBindings({command: keyBindingCommand, target: keyBindingTarget})\r\n      const keystroke = getKeystroke(bindings)\r\n      if ((options.title != null) && (keystroke != null)) {\r\n        options.title += ` ${getKeystroke(bindings)}`\r\n      } else if (keystroke != null) {\r\n        options.title = getKeystroke(bindings)\r\n      }\r\n    }\r\n\r\n    delete options.selector\r\n    options = _.defaults(options, this.defaults)\r\n    if (options.trigger === 'hover') {\r\n      options = _.defaults(options, this.hoverDefaults)\r\n    }\r\n\r\n    const tooltip = new Tooltip(target, options, this.viewRegistry)\r\n\r\n    if (!this.tooltips.has(target)) {\r\n      this.tooltips.set(target, [])\r\n    }\r\n    this.tooltips.get(target).push(tooltip)\r\n\r\n    const hideTooltip = function () {\r\n      tooltip.leave({currentTarget: target})\r\n      tooltip.hide()\r\n    }\r\n\r\n    // note: adding a listener here adds a new listener for every tooltip element that's registered.  Adding unnecessary listeners is bad for performance.  It would be better to add/remove listeners when tooltips are actually created in the dom.\r\n    window.addEventListener('resize', hideTooltip)\r\n\r\n    const disposable = new Disposable(() => {\r\n      window.removeEventListener('resize', hideTooltip)\r\n\r\n      hideTooltip()\r\n      tooltip.destroy()\r\n\r\n      if (this.tooltips.has(target)) {\r\n        const tooltipsForTarget = this.tooltips.get(target)\r\n        const index = tooltipsForTarget.indexOf(tooltip)\r\n        if (index !== -1) {\r\n          tooltipsForTarget.splice(index, 1)\r\n        }\r\n        if (tooltipsForTarget.length === 0) {\r\n          this.tooltips.delete(target)\r\n        }\r\n      }\r\n    })\r\n\r\n    return disposable\r\n  }\r", "name": "add", "func_location": "TooltipManager.add", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip-manager.js", "line": 118, "func_start_line": 114}}, {"func_info": {"comment": [], "name": "getKeystroke", "params": ["bindings"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip-manager.js", "end_line": 203, "start_line": 199}, "call_info": {"func_end_line": 177, "comment": [" Essential: Add a tooltip to the given element.", "", " * `target` An `HTMLElement`", " * `options` An object with one or more of the following options:", "   * `title` A {String} or {Function} to use for the text in the tip. If", "     a function is passed, `this` will be set to the `target` element. This", "     option is mutually exclusive with the `item` option.", "   * `html` A {Boolean} affecting the interpretation of the `title` option.", "     If `true` (the default), the `title` string will be interpreted as HTML.", "     Otherwise it will be interpreted as plain text.", "   * `item` A view (object with an `.element` property) or a DOM element", "     containing custom content for the tooltip. This option is mutually", "     exclusive with the `title` option.", "   * `class` A {String} with a class to apply to the tooltip element to", "     enable custom styling.", "   * `placement` A {String} or {Function} returning a string to indicate", "     the position of the tooltip relative to `element`. Can be `'top'`,", "     `'bottom'`, `'left'`, `'right'`, or `'auto'`. When `'auto'` is", "     specified, it will dynamically reorient the tooltip. For example, if", "     placement is `'auto left'`, the tooltip will display to the left when", "     possible, otherwise it will display right.", "     When a function is used to determine the placement, it is called with", "     the tooltip DOM node as its first argument and the triggering element", "     DOM node as its second. The `this` context is set to the tooltip", "     instance.", "   * `trigger` A {String} indicating how the tooltip should be displayed.", "     Choose from one of the following options:", "       * `'hover'` Show the tooltip when the mouse hovers over the element.", "         This is the default.", "       * `'click'` Show the tooltip when the element is clicked. The tooltip", "         will be hidden after clicking the element again or anywhere else", "         outside of the tooltip itself.", "       * `'focus'` Show the tooltip when the element is focused.", "       * `'manual'` Show the tooltip immediately and only hide it when the", "         returned disposable is disposed.", "   * `delay` An object specifying the show and hide delay in milliseconds.", "     Defaults to `{show: 1000, hide: 100}` if the `trigger` is `hover` and", "     otherwise defaults to `0` for both values.", "   * `keyBindingCommand` A {String} containing a command name. If you specify", "     this option and a key binding exists that matches the command, it will", "     be appended to the title or rendered alone if no title is specified.", "   * `keyBindingTarget` An `HTMLElement` on which to look up the key binding.", "     If this option is not supplied, the first of all matching key bindings", "     for the given command will be rendered.", "", " Returns a {Disposable} on which `.dispose()` can be called to remove the", " tooltip."], "code": "  add (target, options) {\r\n    if (target.jquery) {\r\n      const disposable = new CompositeDisposable()\r\n      for (let i = 0; i < target.length; i++) {\r\n        disposable.add(this.add(target[i], options))\r\n      }\r\n      return disposable\r\n    }\r\n\r\n    if (Tooltip == null) { Tooltip = require('./tooltip') }\r\n\r\n    const {keyBindingCommand, keyBindingTarget} = options\r\n\r\n    if (keyBindingCommand != null) {\r\n      const bindings = this.keymapManager.findKeyBindings({command: keyBindingCommand, target: keyBindingTarget})\r\n      const keystroke = getKeystroke(bindings)\r\n      if ((options.title != null) && (keystroke != null)) {\r\n        options.title += ` ${getKeystroke(bindings)}`\r\n      } else if (keystroke != null) {\r\n        options.title = getKeystroke(bindings)\r\n      }\r\n    }\r\n\r\n    delete options.selector\r\n    options = _.defaults(options, this.defaults)\r\n    if (options.trigger === 'hover') {\r\n      options = _.defaults(options, this.hoverDefaults)\r\n    }\r\n\r\n    const tooltip = new Tooltip(target, options, this.viewRegistry)\r\n\r\n    if (!this.tooltips.has(target)) {\r\n      this.tooltips.set(target, [])\r\n    }\r\n    this.tooltips.get(target).push(tooltip)\r\n\r\n    const hideTooltip = function () {\r\n      tooltip.leave({currentTarget: target})\r\n      tooltip.hide()\r\n    }\r\n\r\n    // note: adding a listener here adds a new listener for every tooltip element that's registered.  Adding unnecessary listeners is bad for performance.  It would be better to add/remove listeners when tooltips are actually created in the dom.\r\n    window.addEventListener('resize', hideTooltip)\r\n\r\n    const disposable = new Disposable(() => {\r\n      window.removeEventListener('resize', hideTooltip)\r\n\r\n      hideTooltip()\r\n      tooltip.destroy()\r\n\r\n      if (this.tooltips.has(target)) {\r\n        const tooltipsForTarget = this.tooltips.get(target)\r\n        const index = tooltipsForTarget.indexOf(tooltip)\r\n        if (index !== -1) {\r\n          tooltipsForTarget.splice(index, 1)\r\n        }\r\n        if (tooltipsForTarget.length === 0) {\r\n          this.tooltips.delete(target)\r\n        }\r\n      }\r\n    })\r\n\r\n    return disposable\r\n  }\r", "name": "getKeystroke", "func_location": "TooltipManager.add", "args": ["bindings"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip-manager.js", "line": 129, "func_start_line": 114}}, {"func_info": {"comment": [], "name": "getKeystroke", "params": ["bindings"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip-manager.js", "end_line": 203, "start_line": 199}, "call_info": {"func_end_line": 177, "comment": [" Essential: Add a tooltip to the given element.", "", " * `target` An `HTMLElement`", " * `options` An object with one or more of the following options:", "   * `title` A {String} or {Function} to use for the text in the tip. If", "     a function is passed, `this` will be set to the `target` element. This", "     option is mutually exclusive with the `item` option.", "   * `html` A {Boolean} affecting the interpretation of the `title` option.", "     If `true` (the default), the `title` string will be interpreted as HTML.", "     Otherwise it will be interpreted as plain text.", "   * `item` A view (object with an `.element` property) or a DOM element", "     containing custom content for the tooltip. This option is mutually", "     exclusive with the `title` option.", "   * `class` A {String} with a class to apply to the tooltip element to", "     enable custom styling.", "   * `placement` A {String} or {Function} returning a string to indicate", "     the position of the tooltip relative to `element`. Can be `'top'`,", "     `'bottom'`, `'left'`, `'right'`, or `'auto'`. When `'auto'` is", "     specified, it will dynamically reorient the tooltip. For example, if", "     placement is `'auto left'`, the tooltip will display to the left when", "     possible, otherwise it will display right.", "     When a function is used to determine the placement, it is called with", "     the tooltip DOM node as its first argument and the triggering element", "     DOM node as its second. The `this` context is set to the tooltip", "     instance.", "   * `trigger` A {String} indicating how the tooltip should be displayed.", "     Choose from one of the following options:", "       * `'hover'` Show the tooltip when the mouse hovers over the element.", "         This is the default.", "       * `'click'` Show the tooltip when the element is clicked. The tooltip", "         will be hidden after clicking the element again or anywhere else", "         outside of the tooltip itself.", "       * `'focus'` Show the tooltip when the element is focused.", "       * `'manual'` Show the tooltip immediately and only hide it when the", "         returned disposable is disposed.", "   * `delay` An object specifying the show and hide delay in milliseconds.", "     Defaults to `{show: 1000, hide: 100}` if the `trigger` is `hover` and", "     otherwise defaults to `0` for both values.", "   * `keyBindingCommand` A {String} containing a command name. If you specify", "     this option and a key binding exists that matches the command, it will", "     be appended to the title or rendered alone if no title is specified.", "   * `keyBindingTarget` An `HTMLElement` on which to look up the key binding.", "     If this option is not supplied, the first of all matching key bindings", "     for the given command will be rendered.", "", " Returns a {Disposable} on which `.dispose()` can be called to remove the", " tooltip."], "code": "  add (target, options) {\r\n    if (target.jquery) {\r\n      const disposable = new CompositeDisposable()\r\n      for (let i = 0; i < target.length; i++) {\r\n        disposable.add(this.add(target[i], options))\r\n      }\r\n      return disposable\r\n    }\r\n\r\n    if (Tooltip == null) { Tooltip = require('./tooltip') }\r\n\r\n    const {keyBindingCommand, keyBindingTarget} = options\r\n\r\n    if (keyBindingCommand != null) {\r\n      const bindings = this.keymapManager.findKeyBindings({command: keyBindingCommand, target: keyBindingTarget})\r\n      const keystroke = getKeystroke(bindings)\r\n      if ((options.title != null) && (keystroke != null)) {\r\n        options.title += ` ${getKeystroke(bindings)}`\r\n      } else if (keystroke != null) {\r\n        options.title = getKeystroke(bindings)\r\n      }\r\n    }\r\n\r\n    delete options.selector\r\n    options = _.defaults(options, this.defaults)\r\n    if (options.trigger === 'hover') {\r\n      options = _.defaults(options, this.hoverDefaults)\r\n    }\r\n\r\n    const tooltip = new Tooltip(target, options, this.viewRegistry)\r\n\r\n    if (!this.tooltips.has(target)) {\r\n      this.tooltips.set(target, [])\r\n    }\r\n    this.tooltips.get(target).push(tooltip)\r\n\r\n    const hideTooltip = function () {\r\n      tooltip.leave({currentTarget: target})\r\n      tooltip.hide()\r\n    }\r\n\r\n    // note: adding a listener here adds a new listener for every tooltip element that's registered.  Adding unnecessary listeners is bad for performance.  It would be better to add/remove listeners when tooltips are actually created in the dom.\r\n    window.addEventListener('resize', hideTooltip)\r\n\r\n    const disposable = new Disposable(() => {\r\n      window.removeEventListener('resize', hideTooltip)\r\n\r\n      hideTooltip()\r\n      tooltip.destroy()\r\n\r\n      if (this.tooltips.has(target)) {\r\n        const tooltipsForTarget = this.tooltips.get(target)\r\n        const index = tooltipsForTarget.indexOf(tooltip)\r\n        if (index !== -1) {\r\n          tooltipsForTarget.splice(index, 1)\r\n        }\r\n        if (tooltipsForTarget.length === 0) {\r\n          this.tooltips.delete(target)\r\n        }\r\n      }\r\n    })\r\n\r\n    return disposable\r\n  }\r", "name": "getKeystroke", "func_location": "TooltipManager.add", "args": ["bindings"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip-manager.js", "line": 131, "func_start_line": 114}}, {"func_info": {"comment": [], "name": "getKeystroke", "params": ["bindings"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip-manager.js", "end_line": 203, "start_line": 199}, "call_info": {"func_end_line": 177, "comment": [" Essential: Add a tooltip to the given element.", "", " * `target` An `HTMLElement`", " * `options` An object with one or more of the following options:", "   * `title` A {String} or {Function} to use for the text in the tip. If", "     a function is passed, `this` will be set to the `target` element. This", "     option is mutually exclusive with the `item` option.", "   * `html` A {Boolean} affecting the interpretation of the `title` option.", "     If `true` (the default), the `title` string will be interpreted as HTML.", "     Otherwise it will be interpreted as plain text.", "   * `item` A view (object with an `.element` property) or a DOM element", "     containing custom content for the tooltip. This option is mutually", "     exclusive with the `title` option.", "   * `class` A {String} with a class to apply to the tooltip element to", "     enable custom styling.", "   * `placement` A {String} or {Function} returning a string to indicate", "     the position of the tooltip relative to `element`. Can be `'top'`,", "     `'bottom'`, `'left'`, `'right'`, or `'auto'`. When `'auto'` is", "     specified, it will dynamically reorient the tooltip. For example, if", "     placement is `'auto left'`, the tooltip will display to the left when", "     possible, otherwise it will display right.", "     When a function is used to determine the placement, it is called with", "     the tooltip DOM node as its first argument and the triggering element", "     DOM node as its second. The `this` context is set to the tooltip", "     instance.", "   * `trigger` A {String} indicating how the tooltip should be displayed.", "     Choose from one of the following options:", "       * `'hover'` Show the tooltip when the mouse hovers over the element.", "         This is the default.", "       * `'click'` Show the tooltip when the element is clicked. The tooltip", "         will be hidden after clicking the element again or anywhere else", "         outside of the tooltip itself.", "       * `'focus'` Show the tooltip when the element is focused.", "       * `'manual'` Show the tooltip immediately and only hide it when the", "         returned disposable is disposed.", "   * `delay` An object specifying the show and hide delay in milliseconds.", "     Defaults to `{show: 1000, hide: 100}` if the `trigger` is `hover` and", "     otherwise defaults to `0` for both values.", "   * `keyBindingCommand` A {String} containing a command name. If you specify", "     this option and a key binding exists that matches the command, it will", "     be appended to the title or rendered alone if no title is specified.", "   * `keyBindingTarget` An `HTMLElement` on which to look up the key binding.", "     If this option is not supplied, the first of all matching key bindings", "     for the given command will be rendered.", "", " Returns a {Disposable} on which `.dispose()` can be called to remove the", " tooltip."], "code": "  add (target, options) {\r\n    if (target.jquery) {\r\n      const disposable = new CompositeDisposable()\r\n      for (let i = 0; i < target.length; i++) {\r\n        disposable.add(this.add(target[i], options))\r\n      }\r\n      return disposable\r\n    }\r\n\r\n    if (Tooltip == null) { Tooltip = require('./tooltip') }\r\n\r\n    const {keyBindingCommand, keyBindingTarget} = options\r\n\r\n    if (keyBindingCommand != null) {\r\n      const bindings = this.keymapManager.findKeyBindings({command: keyBindingCommand, target: keyBindingTarget})\r\n      const keystroke = getKeystroke(bindings)\r\n      if ((options.title != null) && (keystroke != null)) {\r\n        options.title += ` ${getKeystroke(bindings)}`\r\n      } else if (keystroke != null) {\r\n        options.title = getKeystroke(bindings)\r\n      }\r\n    }\r\n\r\n    delete options.selector\r\n    options = _.defaults(options, this.defaults)\r\n    if (options.trigger === 'hover') {\r\n      options = _.defaults(options, this.hoverDefaults)\r\n    }\r\n\r\n    const tooltip = new Tooltip(target, options, this.viewRegistry)\r\n\r\n    if (!this.tooltips.has(target)) {\r\n      this.tooltips.set(target, [])\r\n    }\r\n    this.tooltips.get(target).push(tooltip)\r\n\r\n    const hideTooltip = function () {\r\n      tooltip.leave({currentTarget: target})\r\n      tooltip.hide()\r\n    }\r\n\r\n    // note: adding a listener here adds a new listener for every tooltip element that's registered.  Adding unnecessary listeners is bad for performance.  It would be better to add/remove listeners when tooltips are actually created in the dom.\r\n    window.addEventListener('resize', hideTooltip)\r\n\r\n    const disposable = new Disposable(() => {\r\n      window.removeEventListener('resize', hideTooltip)\r\n\r\n      hideTooltip()\r\n      tooltip.destroy()\r\n\r\n      if (this.tooltips.has(target)) {\r\n        const tooltipsForTarget = this.tooltips.get(target)\r\n        const index = tooltipsForTarget.indexOf(tooltip)\r\n        if (index !== -1) {\r\n          tooltipsForTarget.splice(index, 1)\r\n        }\r\n        if (tooltipsForTarget.length === 0) {\r\n          this.tooltips.delete(target)\r\n        }\r\n      }\r\n    })\r\n\r\n    return disposable\r\n  }\r", "name": "getKeystroke", "func_location": "TooltipManager.add", "args": ["bindings"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip-manager.js", "line": 133, "func_start_line": 114}}, {"func_info": {"comment": [" Private: re-join the segments split from an absolute path to form another absolute path."], "name": "absolute", "params": ["parts"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/native-watcher-registry.js", "end_line": 7, "start_line": 4}, "call_info": {"func_end_line": 54, "name": "absolute", "func_location": "RegistryTree.add", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/native-watcher-registry.js", "line": 40, "func_start_line": 38}}, {"func_info": {"comment": [" Public: Returns an {Array} of all the active themes."], "name": "ThemeManager.getActiveThemes", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 94, "start_line": 92}, "call_info": {"func_end_line": 368, "code": "  addActiveThemeClasses () {\r\n    const workspaceElement = this.viewRegistry.getView(this.workspace)\r\n    if (workspaceElement) {\r\n      for (const pack of this.getActiveThemes()) {\r\n        workspaceElement.classList.add(`theme-${pack.name}`)\r\n      }\r\n    }\r\n  }\r", "name": "getActiveThemes", "func_location": "ThemeManager.addActiveThemeClasses", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 364, "func_start_line": 361}}, {"func_info": {"comment": [], "name": "TextEditorComponent.scheduleUpdate", "params": ["nextUpdateOnlyBlinksCursors"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 219, "start_line": 204}, "call_info": {"func_end_line": 2560, "code": "  addBlockDecoration (decoration, subscribeToChanges = true) {\r\n    const marker = decoration.getMarker()\r\n    const {item, position} = decoration.getProperties()\r\n    const element = TextEditor.viewForItem(item)\r\n\r\n    if (marker.isValid()) {\r\n      const row = marker.getHeadScreenPosition().row\r\n      this.lineTopIndex.insertBlock(decoration, row, 0, position === 'after')\r\n      this.blockDecorationsToMeasure.add(decoration)\r\n      this.blockDecorationsByElement.set(element, decoration)\r\n      this.blockDecorationResizeObserver.observe(element)\r\n\r\n      this.scheduleUpdate()\r\n    }\r\n\r\n    if (subscribeToChanges) {\r\n      let wasValid = marker.isValid()\r\n\r\n      const didUpdateDisposable = marker.bufferMarker.onDidChange(({textChanged}) => {\r\n        const isValid = marker.isValid()\r\n        if (wasValid && !isValid) {\r\n          wasValid = false\r\n          this.blockDecorationsToMeasure.delete(decoration)\r\n          this.heightsByBlockDecoration.delete(decoration)\r\n          this.blockDecorationsByElement.delete(element)\r\n          this.blockDecorationResizeObserver.unobserve(element)\r\n          this.lineTopIndex.removeBlock(decoration)\r\n          this.scheduleUpdate()\r\n        } else if (!wasValid && isValid) {\r\n          wasValid = true\r\n          this.addBlockDecoration(decoration, false)\r\n        } else if (isValid && !textChanged) {\r\n          this.lineTopIndex.moveBlock(decoration, marker.getHeadScreenPosition().row)\r\n          this.scheduleUpdate()\r\n        }\r\n      })\r\n\r\n      const didDestroyDisposable = decoration.onDidDestroy(() => {\r\n        didUpdateDisposable.dispose()\r\n        didDestroyDisposable.dispose()\r\n\r\n        if (wasValid) {\r\n          wasValid = false\r\n          this.blockDecorationsToMeasure.delete(decoration)\r\n          this.heightsByBlockDecoration.delete(decoration)\r\n          this.blockDecorationsByElement.delete(element)\r\n          this.blockDecorationResizeObserver.unobserve(element)\r\n          this.lineTopIndex.removeBlock(decoration)\r\n          this.scheduleUpdate()\r\n        }\r\n      })\r\n    }\r\n  }\r", "name": "scheduleUpdate", "func_location": "TextEditorComponent.addBlockDecoration", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2520, "func_start_line": 2508}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedStartRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2726, "start_line": 2720}, "call_info": {"func_end_line": 1194, "code": "  addBlockDecorationToRender (decoration, screenRange, reversed) {\r\n    const {row} = reversed ? screenRange.start : screenRange.end\r\n    if (row < this.getRenderedStartRow() || row >= this.getRenderedEndRow()) return\r\n\r\n    const tileStartRow = this.tileStartRowForRow(row)\r\n    const screenLine = this.renderedScreenLines[row - this.getRenderedStartRow()]\r\n\r\n    let decorationsByScreenLine = this.decorationsToRender.blocks.get(tileStartRow)\r\n    if (!decorationsByScreenLine) {\r\n      decorationsByScreenLine = new Map()\r\n      this.decorationsToRender.blocks.set(tileStartRow, decorationsByScreenLine)\r\n    }\r\n\r\n    let decorations = decorationsByScreenLine.get(screenLine.id)\r\n    if (!decorations) {\r\n      decorations = []\r\n      decorationsByScreenLine.set(screenLine.id, decorations)\r\n    }\r\n    decorations.push(decoration)\r\n  }\r", "name": "getRenderedStartRow", "func_location": "TextEditorComponent.addBlockDecorationToRender", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1177, "func_start_line": 1175}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedEndRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2737, "start_line": 2728}, "call_info": {"func_end_line": 1194, "code": "  addBlockDecorationToRender (decoration, screenRange, reversed) {\r\n    const {row} = reversed ? screenRange.start : screenRange.end\r\n    if (row < this.getRenderedStartRow() || row >= this.getRenderedEndRow()) return\r\n\r\n    const tileStartRow = this.tileStartRowForRow(row)\r\n    const screenLine = this.renderedScreenLines[row - this.getRenderedStartRow()]\r\n\r\n    let decorationsByScreenLine = this.decorationsToRender.blocks.get(tileStartRow)\r\n    if (!decorationsByScreenLine) {\r\n      decorationsByScreenLine = new Map()\r\n      this.decorationsToRender.blocks.set(tileStartRow, decorationsByScreenLine)\r\n    }\r\n\r\n    let decorations = decorationsByScreenLine.get(screenLine.id)\r\n    if (!decorations) {\r\n      decorations = []\r\n      decorationsByScreenLine.set(screenLine.id, decorations)\r\n    }\r\n    decorations.push(decoration)\r\n  }\r", "name": "getRenderedEndRow", "func_location": "TextEditorComponent.addBlockDecorationToRender", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1177, "func_start_line": 1175}}, {"func_info": {"comment": [], "name": "TextEditorComponent.tileStartRowForRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2718, "start_line": 2716}, "call_info": {"func_end_line": 1194, "code": "  addBlockDecorationToRender (decoration, screenRange, reversed) {\r\n    const {row} = reversed ? screenRange.start : screenRange.end\r\n    if (row < this.getRenderedStartRow() || row >= this.getRenderedEndRow()) return\r\n\r\n    const tileStartRow = this.tileStartRowForRow(row)\r\n    const screenLine = this.renderedScreenLines[row - this.getRenderedStartRow()]\r\n\r\n    let decorationsByScreenLine = this.decorationsToRender.blocks.get(tileStartRow)\r\n    if (!decorationsByScreenLine) {\r\n      decorationsByScreenLine = new Map()\r\n      this.decorationsToRender.blocks.set(tileStartRow, decorationsByScreenLine)\r\n    }\r\n\r\n    let decorations = decorationsByScreenLine.get(screenLine.id)\r\n    if (!decorations) {\r\n      decorations = []\r\n      decorationsByScreenLine.set(screenLine.id, decorations)\r\n    }\r\n    decorations.push(decoration)\r\n  }\r", "name": "tileStartRowForRow", "func_location": "TextEditorComponent.addBlockDecorationToRender", "args": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1179, "func_start_line": 1175}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedStartRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2726, "start_line": 2720}, "call_info": {"func_end_line": 1194, "code": "  addBlockDecorationToRender (decoration, screenRange, reversed) {\r\n    const {row} = reversed ? screenRange.start : screenRange.end\r\n    if (row < this.getRenderedStartRow() || row >= this.getRenderedEndRow()) return\r\n\r\n    const tileStartRow = this.tileStartRowForRow(row)\r\n    const screenLine = this.renderedScreenLines[row - this.getRenderedStartRow()]\r\n\r\n    let decorationsByScreenLine = this.decorationsToRender.blocks.get(tileStartRow)\r\n    if (!decorationsByScreenLine) {\r\n      decorationsByScreenLine = new Map()\r\n      this.decorationsToRender.blocks.set(tileStartRow, decorationsByScreenLine)\r\n    }\r\n\r\n    let decorations = decorationsByScreenLine.get(screenLine.id)\r\n    if (!decorations) {\r\n      decorations = []\r\n      decorationsByScreenLine.set(screenLine.id, decorations)\r\n    }\r\n    decorations.push(decoration)\r\n  }\r", "name": "getRenderedStartRow", "func_location": "TextEditorComponent.addBlockDecorationToRender", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1180, "func_start_line": 1175}}, {"func_info": {"comment": [], "name": "Workspace.addPanel", "params": ["location", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1819, "start_line": 1816}, "call_info": {"func_end_line": 1666, "comment": [" Essential: Adds a panel item to the bottom of the editor window.", "", " * `options` {Object}", "   * `item` Your panel content. It can be DOM element, a jQuery element, or", "     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the", "     latter. See {ViewRegistry::addViewProvider} for more information.", "   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden", "     (default: true)", "   * `priority` (optional) {Number} Determines stacking order. Lower priority items are", "     forced closer to the edges of the window. (default: 100)", "", " Returns a {Panel}"], "code": "  addBottomPanel (options) {\r\n    return this.addPanel('bottom', options)\r\n  }\r", "name": "addPanel", "func_location": "Workspace.addBottomPanel", "args": [{"type": "string"}, "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1665, "func_start_line": 1664}}, {"func_info": {"comment": [], "name": "Project.subscribeToBuffer", "params": ["buffer"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 781, "start_line": 762}, "call_info": {"func_end_line": 734, "code": "  addBuffer (buffer, options = {}) {\r\n    this.buffers.push(buffer)\r\n    this.subscriptions.add(this.grammarRegistry.maintainLanguageMode(buffer))\r\n    this.subscribeToBuffer(buffer)\r\n    this.emitter.emit('did-add-buffer', buffer)\r\n    return buffer\r\n  }\r", "name": "subscribeToBuffer", "func_location": "Project.addBuffer", "args": ["buffer"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 731, "func_start_line": 728}}, {"func_info": {"comment": [], "name": "PaneAxis.subscribeToChild", "params": ["child"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js", "end_line": 184, "start_line": 180}, "call_info": {"func_end_line": 123, "code": "  addChild (child, index = this.children.length) {\r\n    this.children.splice(index, 0, child)\r\n    child.setParent(this)\r\n    child.setContainer(this.container)\r\n    this.subscribeToChild(child)\r\n    return this.emitter.emit('did-add-child', {child, index})\r\n  }\r", "name": "subscribeToChild", "func_location": "PaneAxis.addChild", "args": ["child"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js", "line": 121, "func_start_line": 117}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedStartRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2726, "start_line": 2720}, "call_info": {"func_end_line": 1145, "code": "  addCursorDecorationToMeasure (decoration, marker, screenRange, reversed) {\r\n    const {model} = this.props\r\n    if (!model.getShowCursorOnSelection() && !screenRange.isEmpty()) return\r\n\r\n    let decorationToMeasure = this.decorationsToMeasure.cursors.get(marker)\r\n    if (!decorationToMeasure) {\r\n      const isLastCursor = model.getLastCursor().getMarker() === marker\r\n      const screenPosition = reversed ? screenRange.start : screenRange.end\r\n      const {row, column} = screenPosition\r\n\r\n      if (row < this.getRenderedStartRow() || row >= this.getRenderedEndRow()) return\r\n\r\n      this.requestHorizontalMeasurement(row, column)\r\n      let columnWidth = 0\r\n      if (model.lineLengthForScreenRow(row) > column) {\r\n        columnWidth = 1\r\n        this.requestHorizontalMeasurement(row, column + 1)\r\n      }\r\n      decorationToMeasure = {screenPosition, columnWidth, isLastCursor}\r\n      this.decorationsToMeasure.cursors.set(marker, decorationToMeasure)\r\n    }\r\n\r\n    if (decoration.class) {\r\n      if (decorationToMeasure.className) {\r\n        decorationToMeasure.className += ' ' + decoration.class\r\n      } else {\r\n        decorationToMeasure.className = decoration.class\r\n      }\r\n    }\r\n\r\n    if (decoration.style) {\r\n      if (decorationToMeasure.style) {\r\n        Object.assign(decorationToMeasure.style, decoration.style)\r\n      } else {\r\n        decorationToMeasure.style = Object.assign({}, decoration.style)\r\n      }\r\n    }\r\n  }\r", "name": "getRenderedStartRow", "func_location": "TextEditorComponent.addCursorDecorationToMeasure", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1118, "func_start_line": 1108}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedEndRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2737, "start_line": 2728}, "call_info": {"func_end_line": 1145, "code": "  addCursorDecorationToMeasure (decoration, marker, screenRange, reversed) {\r\n    const {model} = this.props\r\n    if (!model.getShowCursorOnSelection() && !screenRange.isEmpty()) return\r\n\r\n    let decorationToMeasure = this.decorationsToMeasure.cursors.get(marker)\r\n    if (!decorationToMeasure) {\r\n      const isLastCursor = model.getLastCursor().getMarker() === marker\r\n      const screenPosition = reversed ? screenRange.start : screenRange.end\r\n      const {row, column} = screenPosition\r\n\r\n      if (row < this.getRenderedStartRow() || row >= this.getRenderedEndRow()) return\r\n\r\n      this.requestHorizontalMeasurement(row, column)\r\n      let columnWidth = 0\r\n      if (model.lineLengthForScreenRow(row) > column) {\r\n        columnWidth = 1\r\n        this.requestHorizontalMeasurement(row, column + 1)\r\n      }\r\n      decorationToMeasure = {screenPosition, columnWidth, isLastCursor}\r\n      this.decorationsToMeasure.cursors.set(marker, decorationToMeasure)\r\n    }\r\n\r\n    if (decoration.class) {\r\n      if (decorationToMeasure.className) {\r\n        decorationToMeasure.className += ' ' + decoration.class\r\n      } else {\r\n        decorationToMeasure.className = decoration.class\r\n      }\r\n    }\r\n\r\n    if (decoration.style) {\r\n      if (decorationToMeasure.style) {\r\n        Object.assign(decorationToMeasure.style, decoration.style)\r\n      } else {\r\n        decorationToMeasure.style = Object.assign({}, decoration.style)\r\n      }\r\n    }\r\n  }\r", "name": "getRenderedEndRow", "func_location": "TextEditorComponent.addCursorDecorationToMeasure", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1118, "func_start_line": 1108}}, {"func_info": {"comment": [], "name": "TextEditorComponent.requestHorizontalMeasurement", "params": ["row", "column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2257, "start_line": 2243}, "call_info": {"func_end_line": 1145, "code": "  addCursorDecorationToMeasure (decoration, marker, screenRange, reversed) {\r\n    const {model} = this.props\r\n    if (!model.getShowCursorOnSelection() && !screenRange.isEmpty()) return\r\n\r\n    let decorationToMeasure = this.decorationsToMeasure.cursors.get(marker)\r\n    if (!decorationToMeasure) {\r\n      const isLastCursor = model.getLastCursor().getMarker() === marker\r\n      const screenPosition = reversed ? screenRange.start : screenRange.end\r\n      const {row, column} = screenPosition\r\n\r\n      if (row < this.getRenderedStartRow() || row >= this.getRenderedEndRow()) return\r\n\r\n      this.requestHorizontalMeasurement(row, column)\r\n      let columnWidth = 0\r\n      if (model.lineLengthForScreenRow(row) > column) {\r\n        columnWidth = 1\r\n        this.requestHorizontalMeasurement(row, column + 1)\r\n      }\r\n      decorationToMeasure = {screenPosition, columnWidth, isLastCursor}\r\n      this.decorationsToMeasure.cursors.set(marker, decorationToMeasure)\r\n    }\r\n\r\n    if (decoration.class) {\r\n      if (decorationToMeasure.className) {\r\n        decorationToMeasure.className += ' ' + decoration.class\r\n      } else {\r\n        decorationToMeasure.className = decoration.class\r\n      }\r\n    }\r\n\r\n    if (decoration.style) {\r\n      if (decorationToMeasure.style) {\r\n        Object.assign(decorationToMeasure.style, decoration.style)\r\n      } else {\r\n        decorationToMeasure.style = Object.assign({}, decoration.style)\r\n      }\r\n    }\r\n  }\r", "name": "requestHorizontalMeasurement", "func_location": "TextEditorComponent.addCursorDecorationToMeasure", "args": ["row", "column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1120, "func_start_line": 1108}}, {"func_info": {"comment": [], "name": "TextEditorComponent.requestHorizontalMeasurement", "params": ["row", "column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2257, "start_line": 2243}, "call_info": {"func_end_line": 1145, "code": "  addCursorDecorationToMeasure (decoration, marker, screenRange, reversed) {\r\n    const {model} = this.props\r\n    if (!model.getShowCursorOnSelection() && !screenRange.isEmpty()) return\r\n\r\n    let decorationToMeasure = this.decorationsToMeasure.cursors.get(marker)\r\n    if (!decorationToMeasure) {\r\n      const isLastCursor = model.getLastCursor().getMarker() === marker\r\n      const screenPosition = reversed ? screenRange.start : screenRange.end\r\n      const {row, column} = screenPosition\r\n\r\n      if (row < this.getRenderedStartRow() || row >= this.getRenderedEndRow()) return\r\n\r\n      this.requestHorizontalMeasurement(row, column)\r\n      let columnWidth = 0\r\n      if (model.lineLengthForScreenRow(row) > column) {\r\n        columnWidth = 1\r\n        this.requestHorizontalMeasurement(row, column + 1)\r\n      }\r\n      decorationToMeasure = {screenPosition, columnWidth, isLastCursor}\r\n      this.decorationsToMeasure.cursors.set(marker, decorationToMeasure)\r\n    }\r\n\r\n    if (decoration.class) {\r\n      if (decorationToMeasure.className) {\r\n        decorationToMeasure.className += ' ' + decoration.class\r\n      } else {\r\n        decorationToMeasure.className = decoration.class\r\n      }\r\n    }\r\n\r\n    if (decoration.style) {\r\n      if (decorationToMeasure.style) {\r\n        Object.assign(decorationToMeasure.style, decoration.style)\r\n      } else {\r\n        decorationToMeasure.style = Object.assign({}, decoration.style)\r\n      }\r\n    }\r\n  }\r", "name": "requestHorizontalMeasurement", "func_location": "TextEditorComponent.addCursorDecorationToMeasure", "args": ["row", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1124, "func_start_line": 1108}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelPositionAfterBlocksForRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2366, "start_line": 2364}, "call_info": {"func_end_line": 1173, "code": "  addCustomGutterDecorationToRender (decoration, screenRange) {\r\n    let decorations = this.decorationsToRender.customGutter.get(decoration.gutterName)\r\n    if (!decorations) {\r\n      decorations = []\r\n      this.decorationsToRender.customGutter.set(decoration.gutterName, decorations)\r\n    }\r\n    const top = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const height = this.pixelPositionBeforeBlocksForRow(screenRange.end.row + 1) - top\r\n\r\n    decorations.push({\r\n      className: 'decoration' + (decoration.class ? ' ' + decoration.class : ''),\r\n      element: TextEditor.viewForItem(decoration.item),\r\n      top,\r\n      height\r\n    })\r\n  }\r", "name": "pixelPositionAfterBlocksForRow", "func_location": "TextEditorComponent.addCustomGutterDecorationToRender", "args": ["screenRange.start.row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1164, "func_start_line": 1158}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelPositionBeforeBlocksForRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2362, "start_line": 2360}, "call_info": {"func_end_line": 1173, "code": "  addCustomGutterDecorationToRender (decoration, screenRange) {\r\n    let decorations = this.decorationsToRender.customGutter.get(decoration.gutterName)\r\n    if (!decorations) {\r\n      decorations = []\r\n      this.decorationsToRender.customGutter.set(decoration.gutterName, decorations)\r\n    }\r\n    const top = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const height = this.pixelPositionBeforeBlocksForRow(screenRange.end.row + 1) - top\r\n\r\n    decorations.push({\r\n      className: 'decoration' + (decoration.class ? ' ' + decoration.class : ''),\r\n      element: TextEditor.viewForItem(decoration.item),\r\n      top,\r\n      height\r\n    })\r\n  }\r", "name": "pixelPositionBeforeBlocksForRow", "func_location": "TextEditorComponent.addCustomGutterDecorationToRender", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1165, "func_start_line": 1158}}, {"func_info": {"comment": [], "name": "TextEditorComponent.addDecorationToRender", "params": ["type", "decoration", "marker", "screenRange", "reversed"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1042, "start_line": 1011}, "call_info": {"func_end_line": 1042, "code": "  addDecorationToRender (type, decoration, marker, screenRange, reversed) {\r\n    if (Array.isArray(type)) {\r\n      for (let i = 0, length = type.length; i < length; i++) {\r\n        this.addDecorationToRender(type[i], decoration, marker, screenRange, reversed)\r\n      }\r\n    } else {\r\n      switch (type) {\r\n        case 'line':\r\n        case 'line-number':\r\n          this.addLineDecorationToRender(type, decoration, screenRange, reversed)\r\n          break\r\n        case 'highlight':\r\n          this.addHighlightDecorationToMeasure(decoration, screenRange, marker.id)\r\n          break\r\n        case 'cursor':\r\n          this.addCursorDecorationToMeasure(decoration, marker, screenRange, reversed)\r\n          break\r\n        case 'overlay':\r\n          this.addOverlayDecorationToRender(decoration, marker)\r\n          break\r\n        case 'gutter':\r\n          this.addCustomGutterDecorationToRender(decoration, screenRange)\r\n          break\r\n        case 'block':\r\n          this.addBlockDecorationToRender(decoration, screenRange, reversed)\r\n          break\r\n        case 'text':\r\n          this.addTextDecorationToRender(decoration, screenRange, marker)\r\n          break\r\n      }\r\n    }\r\n  }\r", "name": "addDecorationToRender", "func_location": "TextEditorComponent.addDecorationToRender", "args": ["type.i", "decoration", "marker", "screenRange", "reversed"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1014, "func_start_line": 1011}}, {"func_info": {"comment": [], "name": "TextEditorComponent.addLineDecorationToRender", "params": ["type", "decoration", "screenRange", "reversed"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1088, "start_line": 1044}, "call_info": {"func_end_line": 1042, "code": "  addDecorationToRender (type, decoration, marker, screenRange, reversed) {\r\n    if (Array.isArray(type)) {\r\n      for (let i = 0, length = type.length; i < length; i++) {\r\n        this.addDecorationToRender(type[i], decoration, marker, screenRange, reversed)\r\n      }\r\n    } else {\r\n      switch (type) {\r\n        case 'line':\r\n        case 'line-number':\r\n          this.addLineDecorationToRender(type, decoration, screenRange, reversed)\r\n          break\r\n        case 'highlight':\r\n          this.addHighlightDecorationToMeasure(decoration, screenRange, marker.id)\r\n          break\r\n        case 'cursor':\r\n          this.addCursorDecorationToMeasure(decoration, marker, screenRange, reversed)\r\n          break\r\n        case 'overlay':\r\n          this.addOverlayDecorationToRender(decoration, marker)\r\n          break\r\n        case 'gutter':\r\n          this.addCustomGutterDecorationToRender(decoration, screenRange)\r\n          break\r\n        case 'block':\r\n          this.addBlockDecorationToRender(decoration, screenRange, reversed)\r\n          break\r\n        case 'text':\r\n          this.addTextDecorationToRender(decoration, screenRange, marker)\r\n          break\r\n      }\r\n    }\r\n  }\r", "name": "addLineDecorationToRender", "func_location": "TextEditorComponent.addDecorationToRender", "args": ["type", "decoration", "screenRange", "reversed"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1020, "func_start_line": 1011}}, {"func_info": {"comment": [], "name": "TextEditorComponent.addHighlightDecorationToMeasure", "params": ["decoration", "screenRange", "key"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1106, "start_line": 1090}, "call_info": {"func_end_line": 1042, "code": "  addDecorationToRender (type, decoration, marker, screenRange, reversed) {\r\n    if (Array.isArray(type)) {\r\n      for (let i = 0, length = type.length; i < length; i++) {\r\n        this.addDecorationToRender(type[i], decoration, marker, screenRange, reversed)\r\n      }\r\n    } else {\r\n      switch (type) {\r\n        case 'line':\r\n        case 'line-number':\r\n          this.addLineDecorationToRender(type, decoration, screenRange, reversed)\r\n          break\r\n        case 'highlight':\r\n          this.addHighlightDecorationToMeasure(decoration, screenRange, marker.id)\r\n          break\r\n        case 'cursor':\r\n          this.addCursorDecorationToMeasure(decoration, marker, screenRange, reversed)\r\n          break\r\n        case 'overlay':\r\n          this.addOverlayDecorationToRender(decoration, marker)\r\n          break\r\n        case 'gutter':\r\n          this.addCustomGutterDecorationToRender(decoration, screenRange)\r\n          break\r\n        case 'block':\r\n          this.addBlockDecorationToRender(decoration, screenRange, reversed)\r\n          break\r\n        case 'text':\r\n          this.addTextDecorationToRender(decoration, screenRange, marker)\r\n          break\r\n      }\r\n    }\r\n  }\r", "name": "addHighlightDecorationToMeasure", "func_location": "TextEditorComponent.addDecorationToRender", "args": ["decoration", "screenRange", "marker.id"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1023, "func_start_line": 1011}}, {"func_info": {"comment": [], "name": "TextEditorComponent.addCursorDecorationToMeasure", "params": ["decoration", "marker", "screenRange", "reversed"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1145, "start_line": 1108}, "call_info": {"func_end_line": 1042, "code": "  addDecorationToRender (type, decoration, marker, screenRange, reversed) {\r\n    if (Array.isArray(type)) {\r\n      for (let i = 0, length = type.length; i < length; i++) {\r\n        this.addDecorationToRender(type[i], decoration, marker, screenRange, reversed)\r\n      }\r\n    } else {\r\n      switch (type) {\r\n        case 'line':\r\n        case 'line-number':\r\n          this.addLineDecorationToRender(type, decoration, screenRange, reversed)\r\n          break\r\n        case 'highlight':\r\n          this.addHighlightDecorationToMeasure(decoration, screenRange, marker.id)\r\n          break\r\n        case 'cursor':\r\n          this.addCursorDecorationToMeasure(decoration, marker, screenRange, reversed)\r\n          break\r\n        case 'overlay':\r\n          this.addOverlayDecorationToRender(decoration, marker)\r\n          break\r\n        case 'gutter':\r\n          this.addCustomGutterDecorationToRender(decoration, screenRange)\r\n          break\r\n        case 'block':\r\n          this.addBlockDecorationToRender(decoration, screenRange, reversed)\r\n          break\r\n        case 'text':\r\n          this.addTextDecorationToRender(decoration, screenRange, marker)\r\n          break\r\n      }\r\n    }\r\n  }\r", "name": "addCursorDecorationToMeasure", "func_location": "TextEditorComponent.addDecorationToRender", "args": ["decoration", "marker", "screenRange", "reversed"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1026, "func_start_line": 1011}}, {"func_info": {"comment": [], "name": "TextEditorComponent.addOverlayDecorationToRender", "params": ["decoration", "marker"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1156, "start_line": 1147}, "call_info": {"func_end_line": 1042, "code": "  addDecorationToRender (type, decoration, marker, screenRange, reversed) {\r\n    if (Array.isArray(type)) {\r\n      for (let i = 0, length = type.length; i < length; i++) {\r\n        this.addDecorationToRender(type[i], decoration, marker, screenRange, reversed)\r\n      }\r\n    } else {\r\n      switch (type) {\r\n        case 'line':\r\n        case 'line-number':\r\n          this.addLineDecorationToRender(type, decoration, screenRange, reversed)\r\n          break\r\n        case 'highlight':\r\n          this.addHighlightDecorationToMeasure(decoration, screenRange, marker.id)\r\n          break\r\n        case 'cursor':\r\n          this.addCursorDecorationToMeasure(decoration, marker, screenRange, reversed)\r\n          break\r\n        case 'overlay':\r\n          this.addOverlayDecorationToRender(decoration, marker)\r\n          break\r\n        case 'gutter':\r\n          this.addCustomGutterDecorationToRender(decoration, screenRange)\r\n          break\r\n        case 'block':\r\n          this.addBlockDecorationToRender(decoration, screenRange, reversed)\r\n          break\r\n        case 'text':\r\n          this.addTextDecorationToRender(decoration, screenRange, marker)\r\n          break\r\n      }\r\n    }\r\n  }\r", "name": "addOverlayDecorationToRender", "func_location": "TextEditorComponent.addDecorationToRender", "args": ["decoration", "marker"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1029, "func_start_line": 1011}}, {"func_info": {"comment": [], "name": "TextEditorComponent.addCustomGutterDecorationToRender", "params": ["decoration", "screenRange"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1173, "start_line": 1158}, "call_info": {"func_end_line": 1042, "code": "  addDecorationToRender (type, decoration, marker, screenRange, reversed) {\r\n    if (Array.isArray(type)) {\r\n      for (let i = 0, length = type.length; i < length; i++) {\r\n        this.addDecorationToRender(type[i], decoration, marker, screenRange, reversed)\r\n      }\r\n    } else {\r\n      switch (type) {\r\n        case 'line':\r\n        case 'line-number':\r\n          this.addLineDecorationToRender(type, decoration, screenRange, reversed)\r\n          break\r\n        case 'highlight':\r\n          this.addHighlightDecorationToMeasure(decoration, screenRange, marker.id)\r\n          break\r\n        case 'cursor':\r\n          this.addCursorDecorationToMeasure(decoration, marker, screenRange, reversed)\r\n          break\r\n        case 'overlay':\r\n          this.addOverlayDecorationToRender(decoration, marker)\r\n          break\r\n        case 'gutter':\r\n          this.addCustomGutterDecorationToRender(decoration, screenRange)\r\n          break\r\n        case 'block':\r\n          this.addBlockDecorationToRender(decoration, screenRange, reversed)\r\n          break\r\n        case 'text':\r\n          this.addTextDecorationToRender(decoration, screenRange, marker)\r\n          break\r\n      }\r\n    }\r\n  }\r", "name": "addCustomGutterDecorationToRender", "func_location": "TextEditorComponent.addDecorationToRender", "args": ["decoration", "screenRange"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1032, "func_start_line": 1011}}, {"func_info": {"comment": [], "name": "TextEditorComponent.addBlockDecorationToRender", "params": ["decoration", "screenRange", "reversed"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1194, "start_line": 1175}, "call_info": {"func_end_line": 1042, "code": "  addDecorationToRender (type, decoration, marker, screenRange, reversed) {\r\n    if (Array.isArray(type)) {\r\n      for (let i = 0, length = type.length; i < length; i++) {\r\n        this.addDecorationToRender(type[i], decoration, marker, screenRange, reversed)\r\n      }\r\n    } else {\r\n      switch (type) {\r\n        case 'line':\r\n        case 'line-number':\r\n          this.addLineDecorationToRender(type, decoration, screenRange, reversed)\r\n          break\r\n        case 'highlight':\r\n          this.addHighlightDecorationToMeasure(decoration, screenRange, marker.id)\r\n          break\r\n        case 'cursor':\r\n          this.addCursorDecorationToMeasure(decoration, marker, screenRange, reversed)\r\n          break\r\n        case 'overlay':\r\n          this.addOverlayDecorationToRender(decoration, marker)\r\n          break\r\n        case 'gutter':\r\n          this.addCustomGutterDecorationToRender(decoration, screenRange)\r\n          break\r\n        case 'block':\r\n          this.addBlockDecorationToRender(decoration, screenRange, reversed)\r\n          break\r\n        case 'text':\r\n          this.addTextDecorationToRender(decoration, screenRange, marker)\r\n          break\r\n      }\r\n    }\r\n  }\r", "name": "addBlockDecorationToRender", "func_location": "TextEditorComponent.addDecorationToRender", "args": ["decoration", "screenRange", "reversed"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1035, "func_start_line": 1011}}, {"func_info": {"comment": [], "name": "TextEditorComponent.addTextDecorationToRender", "params": ["decoration", "screenRange", "marker"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1207, "start_line": 1196}, "call_info": {"func_end_line": 1042, "code": "  addDecorationToRender (type, decoration, marker, screenRange, reversed) {\r\n    if (Array.isArray(type)) {\r\n      for (let i = 0, length = type.length; i < length; i++) {\r\n        this.addDecorationToRender(type[i], decoration, marker, screenRange, reversed)\r\n      }\r\n    } else {\r\n      switch (type) {\r\n        case 'line':\r\n        case 'line-number':\r\n          this.addLineDecorationToRender(type, decoration, screenRange, reversed)\r\n          break\r\n        case 'highlight':\r\n          this.addHighlightDecorationToMeasure(decoration, screenRange, marker.id)\r\n          break\r\n        case 'cursor':\r\n          this.addCursorDecorationToMeasure(decoration, marker, screenRange, reversed)\r\n          break\r\n        case 'overlay':\r\n          this.addOverlayDecorationToRender(decoration, marker)\r\n          break\r\n        case 'gutter':\r\n          this.addCustomGutterDecorationToRender(decoration, screenRange)\r\n          break\r\n        case 'block':\r\n          this.addBlockDecorationToRender(decoration, screenRange, reversed)\r\n          break\r\n        case 'text':\r\n          this.addTextDecorationToRender(decoration, screenRange, marker)\r\n          break\r\n      }\r\n    }\r\n  }\r", "name": "addTextDecorationToRender", "func_location": "TextEditorComponent.addDecorationToRender", "args": ["decoration", "screenRange", "marker"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1038, "func_start_line": 1011}}, {"func_info": {"comment": [], "name": "NotificationManager.addNotification", "params": ["notification"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification-manager.js", "end_line": 195, "start_line": 191}, "call_info": {"func_end_line": 155, "comment": [" Public: Add an error notification.", "", " * `message` A {String} message", " * `options` (optional) An options {Object} with the following keys:", "    * `buttons` (optional) An {Array} of {Object} where each {Object} has", "      the following options:", "      * `className` (optional) {String} a class name to add to the button's", "        default class name (`btn btn-error`).", "      * `onDidClick` (optional) {Function} callback to call when the button", "        has been clicked. The context will be set to the", "        {NotificationElement} instance.", "      * `text` {String} inner text for the button", "    * `description` (optional) A Markdown {String} containing a longer", "      description about the notification. By default, this **will not**", "      preserve newlines and whitespace when it is rendered.", "    * `detail` (optional) A plain-text {String} containing additional", "      details about the notification. By default, this **will** preserve", "      newlines and whitespace when it is rendered.", "    * `dismissable` (optional) A {Boolean} indicating whether this", "      notification can be dismissed by the user. Defaults to `false`.", "    * `icon` (optional) A {String} name of an icon from Octicons to display", "      in the notification header. Defaults to `'flame'`.", "    * `stack` (optional) A preformatted {String} with stack trace", "      information describing the location of the error.", "", " Returns the {Notification} that was added."], "code": "  addError (message, options) {\r\n    return this.addNotification(new Notification('error', message, options))\r\n  }\r", "name": "addNotification", "func_location": "NotificationManager.addError", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification-manager.js", "line": 154, "func_start_line": 153}}, {"func_info": {"comment": [], "name": "NotificationManager.addNotification", "params": ["notification"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification-manager.js", "end_line": 195, "start_line": 191}, "call_info": {"func_end_line": 185, "comment": [" Public: Add a fatal error notification.", "", " * `message` A {String} message", " * `options` (optional) An options {Object} with the following keys:", "    * `buttons` (optional) An {Array} of {Object} where each {Object} has", "      the following options:", "      * `className` (optional) {String} a class name to add to the button's", "        default class name (`btn btn-error`).", "      * `onDidClick` (optional) {Function} callback to call when the button", "        has been clicked. The context will be set to the", "        {NotificationElement} instance.", "      * `text` {String} inner text for the button", "    * `description` (optional) A Markdown {String} containing a longer", "      description about the notification. By default, this **will not**", "      preserve newlines and whitespace when it is rendered.", "    * `detail` (optional) A plain-text {String} containing additional", "      details about the notification. By default, this **will** preserve", "      newlines and whitespace when it is rendered.", "    * `dismissable` (optional) A {Boolean} indicating whether this", "      notification can be dismissed by the user. Defaults to `false`.", "    * `icon` (optional) A {String} name of an icon from Octicons to display", "      in the notification header. Defaults to `'bug'`.", "    * `stack` (optional) A preformatted {String} with stack trace", "      information describing the location of the error.", "", " Returns the {Notification} that was added."], "code": "  addFatalError (message, options) {\r\n    return this.addNotification(new Notification('fatal', message, options))\r\n  }\r", "name": "addNotification", "func_location": "NotificationManager.addFatalError", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification-manager.js", "line": 184, "func_start_line": 183}}, {"func_info": {"comment": [], "name": "Workspace.addPanel", "params": ["location", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1819, "start_line": 1816}, "call_info": {"func_end_line": 1771, "comment": [" Essential: Adds a panel item to the footer.", "", " * `options` {Object}", "   * `item` Your panel content. It can be DOM element, a jQuery element, or", "     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the", "     latter. See {ViewRegistry::addViewProvider} for more information.", "   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden", "     (default: true)", "   * `priority` (optional) {Number} Determines stacking order. Lower priority items are", "     forced closer to the edges of the window. (default: 100)", "", " Returns a {Panel}"], "code": "  addFooterPanel (options) {\r\n    return this.addPanel('footer', options)\r\n  }\r", "name": "addPanel", "func_location": "Workspace.addFooterPanel", "args": [{"type": "string"}, "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1770, "func_start_line": 1769}}, {"func_info": {"comment": [], "name": "GrammarRegistry.grammarAddedOrUpdated", "params": ["grammar"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 388, "start_line": 365}, "call_info": {"func_end_line": 470, "code": "  addGrammar (grammar) {\r\n    if (grammar instanceof TreeSitterGrammar) {\r\n      const existingParams = this.treeSitterGrammarsById[grammar.scopeName] || {}\r\n      if (grammar.scopeName) this.treeSitterGrammarsById[grammar.scopeName] = grammar\r\n      if (existingParams.injectionPoints) {\r\n        for (const injectionPoint of existingParams.injectionPoints) {\r\n          grammar.addInjectionPoint(injectionPoint)\r\n        }\r\n      }\r\n      this.grammarAddedOrUpdated(grammar)\r\n      return new Disposable(() => this.removeGrammar(grammar))\r\n    } else {\r\n      return this.textmateRegistry.addGrammar(grammar)\r\n    }\r\n  }\r", "name": "grammarAddedOrUpdated", "func_location": "GrammarRegistry.addGrammar", "args": ["grammar"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 465, "func_start_line": 456}}, {"func_info": {"comment": [], "name": "GutterContainer.gutterWithName", "params": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/gutter-container.js", "end_line": 64, "start_line": 59}, "call_info": {"func_end_line": 53, "code": "  addGutter (options) {\r\n    options = options || {}\r\n    const gutterName = options.name\r\n    if (gutterName === null) {\r\n      throw new Error('A name is required to create a gutter.')\r\n    }\r\n    if (this.gutterWithName(gutterName)) {\r\n      throw new Error('Tried to create a gutter with a name that is already in use.')\r\n    }\r\n    const newGutter = new Gutter(this, options)\r\n\r\n    let inserted = false\r\n    // Insert the gutter into the gutters array, sorted in ascending order by 'priority'.\r\n    // This could be optimized, but there are unlikely to be many gutters.\r\n    for (let i = 0; i < this.gutters.length; i++) {\r\n      if (this.gutters[i].priority >= newGutter.priority) {\r\n        this.gutters.splice(i, 0, newGutter)\r\n        inserted = true\r\n        break\r\n      }\r\n    }\r\n    if (!inserted) {\r\n      this.gutters.push(newGutter)\r\n    }\r\n    this.scheduleComponentUpdate()\r\n    this.emitter.emit('did-add-gutter', newGutter)\r\n    return newGutter\r\n  }\r", "name": "gutterWithName", "func_location": "GutterContainer.addGutter", "args": ["gutterName"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/gutter-container.js", "line": 32, "func_start_line": 26}}, {"func_info": {"comment": [], "name": "GutterContainer.scheduleComponentUpdate", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/gutter-container.js", "end_line": 13, "start_line": 11}, "call_info": {"func_end_line": 53, "code": "  addGutter (options) {\r\n    options = options || {}\r\n    const gutterName = options.name\r\n    if (gutterName === null) {\r\n      throw new Error('A name is required to create a gutter.')\r\n    }\r\n    if (this.gutterWithName(gutterName)) {\r\n      throw new Error('Tried to create a gutter with a name that is already in use.')\r\n    }\r\n    const newGutter = new Gutter(this, options)\r\n\r\n    let inserted = false\r\n    // Insert the gutter into the gutters array, sorted in ascending order by 'priority'.\r\n    // This could be optimized, but there are unlikely to be many gutters.\r\n    for (let i = 0; i < this.gutters.length; i++) {\r\n      if (this.gutters[i].priority >= newGutter.priority) {\r\n        this.gutters.splice(i, 0, newGutter)\r\n        inserted = true\r\n        break\r\n      }\r\n    }\r\n    if (!inserted) {\r\n      this.gutters.push(newGutter)\r\n    }\r\n    this.scheduleComponentUpdate()\r\n    this.emitter.emit('did-add-gutter', newGutter)\r\n    return newGutter\r\n  }\r", "name": "scheduleComponentUpdate", "func_location": "GutterContainer.addGutter", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/gutter-container.js", "line": 50, "func_start_line": 26}}, {"func_info": {"comment": [], "name": "Workspace.addPanel", "params": ["location", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1819, "start_line": 1816}, "call_info": {"func_end_line": 1750, "comment": [" Essential: Adds a panel item to the header.", "", " * `options` {Object}", "   * `item` Your panel content. It can be DOM element, a jQuery element, or", "     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the", "     latter. See {ViewRegistry::addViewProvider} for more information.", "   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden", "     (default: true)", "   * `priority` (optional) {Number} Determines stacking order. Lower priority items are", "     forced closer to the edges of the window. (default: 100)", "", " Returns a {Panel}"], "code": "  addHeaderPanel (options) {\r\n    return this.addPanel('header', options)\r\n  }\r", "name": "addPanel", "func_location": "Workspace.addHeaderPanel", "args": [{"type": "string"}, "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1749, "func_start_line": 1748}}, {"func_info": {"comment": [], "name": "constrainRangeToRows", "params": ["range", "startRow", "endRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4391, "start_line": 4378}, "call_info": {"func_end_line": 1106, "code": "  addHighlightDecorationToMeasure (decoration, screenRange, key) {\r\n    screenRange = constrainRangeToRows(screenRange, this.getRenderedStartRow(), this.getRenderedEndRow())\r\n    if (screenRange.isEmpty()) return\r\n\r\n    const {class: className, flashRequested, flashClass, flashDuration} = decoration\r\n    decoration.flashRequested = false\r\n    this.decorationsToMeasure.highlights.push({\r\n      screenRange,\r\n      key,\r\n      className,\r\n      flashRequested,\r\n      flashClass,\r\n      flashDuration\r\n    })\r\n    this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n    this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n  }\r", "name": "constrainRangeToRows", "func_location": "TextEditorComponent.addHighlightDecorationToMeasure", "args": ["screenRange", null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1091, "func_start_line": 1090}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedStartRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2726, "start_line": 2720}, "call_info": {"func_end_line": 1106, "code": "  addHighlightDecorationToMeasure (decoration, screenRange, key) {\r\n    screenRange = constrainRangeToRows(screenRange, this.getRenderedStartRow(), this.getRenderedEndRow())\r\n    if (screenRange.isEmpty()) return\r\n\r\n    const {class: className, flashRequested, flashClass, flashDuration} = decoration\r\n    decoration.flashRequested = false\r\n    this.decorationsToMeasure.highlights.push({\r\n      screenRange,\r\n      key,\r\n      className,\r\n      flashRequested,\r\n      flashClass,\r\n      flashDuration\r\n    })\r\n    this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n    this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n  }\r", "name": "getRenderedStartRow", "func_location": "TextEditorComponent.addHighlightDecorationToMeasure", "args": ["screenRange", null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1091, "func_start_line": 1090}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedEndRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2737, "start_line": 2728}, "call_info": {"func_end_line": 1106, "code": "  addHighlightDecorationToMeasure (decoration, screenRange, key) {\r\n    screenRange = constrainRangeToRows(screenRange, this.getRenderedStartRow(), this.getRenderedEndRow())\r\n    if (screenRange.isEmpty()) return\r\n\r\n    const {class: className, flashRequested, flashClass, flashDuration} = decoration\r\n    decoration.flashRequested = false\r\n    this.decorationsToMeasure.highlights.push({\r\n      screenRange,\r\n      key,\r\n      className,\r\n      flashRequested,\r\n      flashClass,\r\n      flashDuration\r\n    })\r\n    this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n    this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n  }\r", "name": "getRenderedEndRow", "func_location": "TextEditorComponent.addHighlightDecorationToMeasure", "args": ["screenRange", null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1091, "func_start_line": 1090}}, {"func_info": {"comment": [], "name": "TextEditorComponent.requestHorizontalMeasurement", "params": ["row", "column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2257, "start_line": 2243}, "call_info": {"func_end_line": 1106, "code": "  addHighlightDecorationToMeasure (decoration, screenRange, key) {\r\n    screenRange = constrainRangeToRows(screenRange, this.getRenderedStartRow(), this.getRenderedEndRow())\r\n    if (screenRange.isEmpty()) return\r\n\r\n    const {class: className, flashRequested, flashClass, flashDuration} = decoration\r\n    decoration.flashRequested = false\r\n    this.decorationsToMeasure.highlights.push({\r\n      screenRange,\r\n      key,\r\n      className,\r\n      flashRequested,\r\n      flashClass,\r\n      flashDuration\r\n    })\r\n    this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n    this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n  }\r", "name": "requestHorizontalMeasurement", "func_location": "TextEditorComponent.addHighlightDecorationToMeasure", "args": ["screenRange.start.row", "screenRange.start.column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1104, "func_start_line": 1090}}, {"func_info": {"comment": [], "name": "TextEditorComponent.requestHorizontalMeasurement", "params": ["row", "column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2257, "start_line": 2243}, "call_info": {"func_end_line": 1106, "code": "  addHighlightDecorationToMeasure (decoration, screenRange, key) {\r\n    screenRange = constrainRangeToRows(screenRange, this.getRenderedStartRow(), this.getRenderedEndRow())\r\n    if (screenRange.isEmpty()) return\r\n\r\n    const {class: className, flashRequested, flashClass, flashDuration} = decoration\r\n    decoration.flashRequested = false\r\n    this.decorationsToMeasure.highlights.push({\r\n      screenRange,\r\n      key,\r\n      className,\r\n      flashRequested,\r\n      flashClass,\r\n      flashDuration\r\n    })\r\n    this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n    this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n  }\r", "name": "requestHorizontalMeasurement", "func_location": "TextEditorComponent.addHighlightDecorationToMeasure", "args": ["screenRange.end.row", "screenRange.end.column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1105, "func_start_line": 1090}}, {"func_info": {"comment": [], "name": "NotificationManager.addNotification", "params": ["notification"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification-manager.js", "end_line": 195, "start_line": 191}, "call_info": {"func_end_line": 97, "comment": [" Public: Add an informational notification.", "", " * `message` A {String} message", " * `options` (optional) An options {Object} with the following keys:", "    * `buttons` (optional) An {Array} of {Object} where each {Object} has", "      the following options:", "      * `className` (optional) {String} a class name to add to the button's", "        default class name (`btn btn-info`).", "      * `onDidClick` (optional) {Function} callback to call when the button", "        has been clicked. The context will be set to the", "        {NotificationElement} instance.", "      * `text` {String} inner text for the button", "    * `description` (optional) A Markdown {String} containing a longer", "      description about the notification. By default, this **will not**", "      preserve newlines and whitespace when it is rendered.", "    * `detail` (optional) A plain-text {String} containing additional", "      details about the notification. By default, this **will** preserve", "      newlines and whitespace when it is rendered.", "    * `dismissable` (optional) A {Boolean} indicating whether this", "      notification can be dismissed by the user. Defaults to `false`.", "    * `icon` (optional) A {String} name of an icon from Octicons to display", "      in the notification header. Defaults to `'info'`.", "", " Returns the {Notification} that was added."], "code": "  addInfo (message, options) {\r\n    return this.addNotification(new Notification('info', message, options))\r\n  }\r", "name": "addNotification", "func_location": "NotificationManager.addInfo", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification-manager.js", "line": 96, "func_start_line": 95}}, {"func_info": {"comment": [], "name": "CommandRegistry.commandRegistered", "params": ["commandName"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js", "end_line": 406, "start_line": 401}, "call_info": {"func_end_line": 205, "code": "  addInlineListener (element, commandName, listener) {\r\n    if (this.inlineListenersByCommandName[commandName] == null) {\r\n      this.inlineListenersByCommandName[commandName] = new WeakMap()\r\n    }\r\n\r\n    const listenersForCommand = this.inlineListenersByCommandName[commandName]\r\n    let listenersForElement = listenersForCommand.get(element)\r\n    if (!listenersForElement) {\r\n      listenersForElement = []\r\n      listenersForCommand.set(element, listenersForElement)\r\n    }\r\n    const inlineListener = new InlineListener(commandName, listener)\r\n    listenersForElement.push(inlineListener)\r\n\r\n    this.commandRegistered(commandName)\r\n\r\n    return new Disposable(() => {\r\n      listenersForElement.splice(listenersForElement.indexOf(inlineListener), 1)\r\n      if (listenersForElement.length === 0) {\r\n        listenersForCommand.delete(element)\r\n      }\r\n    })\r\n  }\r", "name": "commandRegistered", "func_location": "CommandRegistry.addInlineListener", "args": ["commandName"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js", "line": 197, "func_start_line": 183}}, {"func_info": {"comment": [], "name": "ItemRegistry.hasItem", "params": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/item-registry.js", "end_line": 20, "start_line": 18}, "call_info": {"func_end_line": 12, "code": "  addItem (item) {\r\n    if (this.hasItem(item)) {\r\n      throw new Error(`The workspace can only contain one instance of item ${item}`)\r\n    }\r\n    return this.items.add(item)\r\n  }\r", "name": "hasItem", "func_location": "ItemRegistry.addItem", "args": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/item-registry.js", "line": 8, "func_start_line": 7}}, {"func_info": {"comment": [" Public: Get the index of the active item.", "", " Returns a {Number}."], "name": "Pane.getActiveItemIndex", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 555, "start_line": 553}, "call_info": {"func_end_line": 642, "comment": [" Public: Add the given item to the pane.", "", " * `item` The item to add. It can be a model with an associated view or a", "   view.", " * `options` (optional) {Object}", "   * `index` (optional) {Number} indicating the index at which to add the item.", "     If omitted, the item is added after the current active item.", "   * `pending` (optional) {Boolean} indicating that the item should be", "     added in a pending state. Existing pending items in a pane are replaced with", "     new pending items when they are opened.", "", " Returns the added item."], "code": "  addItem (item, options = {}) {\r\n    // Backward compat with old API:\r\n    //   addItem(item, index=@getActiveItemIndex() + 1)\r\n    if (typeof options === 'number') {\r\n      Grim.deprecate(`Pane::addItem(item, ${options}) is deprecated in favor of Pane::addItem(item, {index: ${options}})`)\r\n      options = {index: options}\r\n    }\r\n\r\n    const index = options.index != null ? options.index : this.getActiveItemIndex() + 1\r\n    const moved = options.moved != null ? options.moved : false\r\n    const pending = options.pending != null ? options.pending : false\r\n\r\n    if (!item || typeof item !== 'object') {\r\n      throw new Error(`Pane items must be objects. Attempted to add item ${item}.`)\r\n    }\r\n\r\n    if (typeof item.isDestroyed === 'function' && item.isDestroyed()) {\r\n      throw new Error(`Adding a pane item with URI '${typeof item.getURI === 'function' && item.getURI()}' that has already been destroyed`)\r\n    }\r\n\r\n    if (this.items.includes(item)) return\r\n\r\n    const itemSubscriptions = new CompositeDisposable()\r\n    this.subscriptionsPerItem.set(item, itemSubscriptions)\r\n    if (typeof item.onDidDestroy === 'function') {\r\n      itemSubscriptions.add(item.onDidDestroy(() => this.removeItem(item, false)))\r\n    }\r\n    if (typeof item.onDidTerminatePendingState === 'function') {\r\n      itemSubscriptions.add(item.onDidTerminatePendingState(() => {\r\n        if (this.getPendingItem() === item) this.clearPendingItem()\r\n      }))\r\n    }\r\n\r\n    this.items.splice(index, 0, item)\r\n    const lastPendingItem = this.getPendingItem()\r\n    const replacingPendingItem = lastPendingItem != null && !moved\r\n    if (replacingPendingItem) this.pendingItem = null\r\n    if (pending) this.setPendingItem(item)\r\n\r\n    this.emitter.emit('did-add-item', {item, index, moved})\r\n    if (!moved) {\r\n      if (this.container) this.container.didAddPaneItem(item, this, index)\r\n    }\r\n\r\n    if (replacingPendingItem) this.destroyItem(lastPendingItem)\r\n    if (!this.getActiveItem()) this.setActiveItem(item)\r\n    return item\r\n  }\r", "name": "getActiveItemIndex", "func_location": "Pane.addItem", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 603, "func_start_line": 595}}, {"func_info": {"comment": [], "name": "Pane.getPendingItem", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 656, "start_line": 654}, "call_info": {"func_end_line": 642, "comment": [" Public: Add the given item to the pane.", "", " * `item` The item to add. It can be a model with an associated view or a", "   view.", " * `options` (optional) {Object}", "   * `index` (optional) {Number} indicating the index at which to add the item.", "     If omitted, the item is added after the current active item.", "   * `pending` (optional) {Boolean} indicating that the item should be", "     added in a pending state. Existing pending items in a pane are replaced with", "     new pending items when they are opened.", "", " Returns the added item."], "code": "  addItem (item, options = {}) {\r\n    // Backward compat with old API:\r\n    //   addItem(item, index=@getActiveItemIndex() + 1)\r\n    if (typeof options === 'number') {\r\n      Grim.deprecate(`Pane::addItem(item, ${options}) is deprecated in favor of Pane::addItem(item, {index: ${options}})`)\r\n      options = {index: options}\r\n    }\r\n\r\n    const index = options.index != null ? options.index : this.getActiveItemIndex() + 1\r\n    const moved = options.moved != null ? options.moved : false\r\n    const pending = options.pending != null ? options.pending : false\r\n\r\n    if (!item || typeof item !== 'object') {\r\n      throw new Error(`Pane items must be objects. Attempted to add item ${item}.`)\r\n    }\r\n\r\n    if (typeof item.isDestroyed === 'function' && item.isDestroyed()) {\r\n      throw new Error(`Adding a pane item with URI '${typeof item.getURI === 'function' && item.getURI()}' that has already been destroyed`)\r\n    }\r\n\r\n    if (this.items.includes(item)) return\r\n\r\n    const itemSubscriptions = new CompositeDisposable()\r\n    this.subscriptionsPerItem.set(item, itemSubscriptions)\r\n    if (typeof item.onDidDestroy === 'function') {\r\n      itemSubscriptions.add(item.onDidDestroy(() => this.removeItem(item, false)))\r\n    }\r\n    if (typeof item.onDidTerminatePendingState === 'function') {\r\n      itemSubscriptions.add(item.onDidTerminatePendingState(() => {\r\n        if (this.getPendingItem() === item) this.clearPendingItem()\r\n      }))\r\n    }\r\n\r\n    this.items.splice(index, 0, item)\r\n    const lastPendingItem = this.getPendingItem()\r\n    const replacingPendingItem = lastPendingItem != null && !moved\r\n    if (replacingPendingItem) this.pendingItem = null\r\n    if (pending) this.setPendingItem(item)\r\n\r\n    this.emitter.emit('did-add-item', {item, index, moved})\r\n    if (!moved) {\r\n      if (this.container) this.container.didAddPaneItem(item, this, index)\r\n    }\r\n\r\n    if (replacingPendingItem) this.destroyItem(lastPendingItem)\r\n    if (!this.getActiveItem()) this.setActiveItem(item)\r\n    return item\r\n  }\r", "name": "getPendingItem", "func_location": "Pane.addItem", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 629, "func_start_line": 595}}, {"func_info": {"comment": [], "name": "Pane.setPendingItem", "params": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 652, "start_line": 644}, "call_info": {"func_end_line": 642, "comment": [" Public: Add the given item to the pane.", "", " * `item` The item to add. It can be a model with an associated view or a", "   view.", " * `options` (optional) {Object}", "   * `index` (optional) {Number} indicating the index at which to add the item.", "     If omitted, the item is added after the current active item.", "   * `pending` (optional) {Boolean} indicating that the item should be", "     added in a pending state. Existing pending items in a pane are replaced with", "     new pending items when they are opened.", "", " Returns the added item."], "code": "  addItem (item, options = {}) {\r\n    // Backward compat with old API:\r\n    //   addItem(item, index=@getActiveItemIndex() + 1)\r\n    if (typeof options === 'number') {\r\n      Grim.deprecate(`Pane::addItem(item, ${options}) is deprecated in favor of Pane::addItem(item, {index: ${options}})`)\r\n      options = {index: options}\r\n    }\r\n\r\n    const index = options.index != null ? options.index : this.getActiveItemIndex() + 1\r\n    const moved = options.moved != null ? options.moved : false\r\n    const pending = options.pending != null ? options.pending : false\r\n\r\n    if (!item || typeof item !== 'object') {\r\n      throw new Error(`Pane items must be objects. Attempted to add item ${item}.`)\r\n    }\r\n\r\n    if (typeof item.isDestroyed === 'function' && item.isDestroyed()) {\r\n      throw new Error(`Adding a pane item with URI '${typeof item.getURI === 'function' && item.getURI()}' that has already been destroyed`)\r\n    }\r\n\r\n    if (this.items.includes(item)) return\r\n\r\n    const itemSubscriptions = new CompositeDisposable()\r\n    this.subscriptionsPerItem.set(item, itemSubscriptions)\r\n    if (typeof item.onDidDestroy === 'function') {\r\n      itemSubscriptions.add(item.onDidDestroy(() => this.removeItem(item, false)))\r\n    }\r\n    if (typeof item.onDidTerminatePendingState === 'function') {\r\n      itemSubscriptions.add(item.onDidTerminatePendingState(() => {\r\n        if (this.getPendingItem() === item) this.clearPendingItem()\r\n      }))\r\n    }\r\n\r\n    this.items.splice(index, 0, item)\r\n    const lastPendingItem = this.getPendingItem()\r\n    const replacingPendingItem = lastPendingItem != null && !moved\r\n    if (replacingPendingItem) this.pendingItem = null\r\n    if (pending) this.setPendingItem(item)\r\n\r\n    this.emitter.emit('did-add-item', {item, index, moved})\r\n    if (!moved) {\r\n      if (this.container) this.container.didAddPaneItem(item, this, index)\r\n    }\r\n\r\n    if (replacingPendingItem) this.destroyItem(lastPendingItem)\r\n    if (!this.getActiveItem()) this.setActiveItem(item)\r\n    return item\r\n  }\r", "name": "setPendingItem", "func_location": "Pane.addItem", "args": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 632, "func_start_line": 595}}, {"func_info": {"comment": [" Public: Destroy the given item.", "", " If the item is active, the next item will be activated. If the item is the", " last item, the pane will be destroyed if the `core.destroyEmptyPanes` config", " setting is `true`.", "", " * `item` Item to destroy", " * `force` (optional) {Boolean} Destroy the item without prompting to save", "    it, even if the item's `isPermanentDockItem` method returns true.", "", " Returns a {Promise} that resolves with a {Boolean} indicating whether or not", " the item was destroyed."], "name": "Pane.destroyItem", "params": ["item", "force"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 782, "start_line": 757}, "call_info": {"func_end_line": 642, "comment": [" Public: Add the given item to the pane.", "", " * `item` The item to add. It can be a model with an associated view or a", "   view.", " * `options` (optional) {Object}", "   * `index` (optional) {Number} indicating the index at which to add the item.", "     If omitted, the item is added after the current active item.", "   * `pending` (optional) {Boolean} indicating that the item should be", "     added in a pending state. Existing pending items in a pane are replaced with", "     new pending items when they are opened.", "", " Returns the added item."], "code": "  addItem (item, options = {}) {\r\n    // Backward compat with old API:\r\n    //   addItem(item, index=@getActiveItemIndex() + 1)\r\n    if (typeof options === 'number') {\r\n      Grim.deprecate(`Pane::addItem(item, ${options}) is deprecated in favor of Pane::addItem(item, {index: ${options}})`)\r\n      options = {index: options}\r\n    }\r\n\r\n    const index = options.index != null ? options.index : this.getActiveItemIndex() + 1\r\n    const moved = options.moved != null ? options.moved : false\r\n    const pending = options.pending != null ? options.pending : false\r\n\r\n    if (!item || typeof item !== 'object') {\r\n      throw new Error(`Pane items must be objects. Attempted to add item ${item}.`)\r\n    }\r\n\r\n    if (typeof item.isDestroyed === 'function' && item.isDestroyed()) {\r\n      throw new Error(`Adding a pane item with URI '${typeof item.getURI === 'function' && item.getURI()}' that has already been destroyed`)\r\n    }\r\n\r\n    if (this.items.includes(item)) return\r\n\r\n    const itemSubscriptions = new CompositeDisposable()\r\n    this.subscriptionsPerItem.set(item, itemSubscriptions)\r\n    if (typeof item.onDidDestroy === 'function') {\r\n      itemSubscriptions.add(item.onDidDestroy(() => this.removeItem(item, false)))\r\n    }\r\n    if (typeof item.onDidTerminatePendingState === 'function') {\r\n      itemSubscriptions.add(item.onDidTerminatePendingState(() => {\r\n        if (this.getPendingItem() === item) this.clearPendingItem()\r\n      }))\r\n    }\r\n\r\n    this.items.splice(index, 0, item)\r\n    const lastPendingItem = this.getPendingItem()\r\n    const replacingPendingItem = lastPendingItem != null && !moved\r\n    if (replacingPendingItem) this.pendingItem = null\r\n    if (pending) this.setPendingItem(item)\r\n\r\n    this.emitter.emit('did-add-item', {item, index, moved})\r\n    if (!moved) {\r\n      if (this.container) this.container.didAddPaneItem(item, this, index)\r\n    }\r\n\r\n    if (replacingPendingItem) this.destroyItem(lastPendingItem)\r\n    if (!this.getActiveItem()) this.setActiveItem(item)\r\n    return item\r\n  }\r", "name": "destroyItem", "func_location": "Pane.addItem", "args": ["lastPendingItem"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 639, "func_start_line": 595}}, {"func_info": {"comment": [" Public: Get the active pane item in this pane.", "", " Returns a pane item."], "name": "Pane.getActiveItem", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 432, "start_line": 432}, "call_info": {"func_end_line": 642, "comment": [" Public: Add the given item to the pane.", "", " * `item` The item to add. It can be a model with an associated view or a", "   view.", " * `options` (optional) {Object}", "   * `index` (optional) {Number} indicating the index at which to add the item.", "     If omitted, the item is added after the current active item.", "   * `pending` (optional) {Boolean} indicating that the item should be", "     added in a pending state. Existing pending items in a pane are replaced with", "     new pending items when they are opened.", "", " Returns the added item."], "code": "  addItem (item, options = {}) {\r\n    // Backward compat with old API:\r\n    //   addItem(item, index=@getActiveItemIndex() + 1)\r\n    if (typeof options === 'number') {\r\n      Grim.deprecate(`Pane::addItem(item, ${options}) is deprecated in favor of Pane::addItem(item, {index: ${options}})`)\r\n      options = {index: options}\r\n    }\r\n\r\n    const index = options.index != null ? options.index : this.getActiveItemIndex() + 1\r\n    const moved = options.moved != null ? options.moved : false\r\n    const pending = options.pending != null ? options.pending : false\r\n\r\n    if (!item || typeof item !== 'object') {\r\n      throw new Error(`Pane items must be objects. Attempted to add item ${item}.`)\r\n    }\r\n\r\n    if (typeof item.isDestroyed === 'function' && item.isDestroyed()) {\r\n      throw new Error(`Adding a pane item with URI '${typeof item.getURI === 'function' && item.getURI()}' that has already been destroyed`)\r\n    }\r\n\r\n    if (this.items.includes(item)) return\r\n\r\n    const itemSubscriptions = new CompositeDisposable()\r\n    this.subscriptionsPerItem.set(item, itemSubscriptions)\r\n    if (typeof item.onDidDestroy === 'function') {\r\n      itemSubscriptions.add(item.onDidDestroy(() => this.removeItem(item, false)))\r\n    }\r\n    if (typeof item.onDidTerminatePendingState === 'function') {\r\n      itemSubscriptions.add(item.onDidTerminatePendingState(() => {\r\n        if (this.getPendingItem() === item) this.clearPendingItem()\r\n      }))\r\n    }\r\n\r\n    this.items.splice(index, 0, item)\r\n    const lastPendingItem = this.getPendingItem()\r\n    const replacingPendingItem = lastPendingItem != null && !moved\r\n    if (replacingPendingItem) this.pendingItem = null\r\n    if (pending) this.setPendingItem(item)\r\n\r\n    this.emitter.emit('did-add-item', {item, index, moved})\r\n    if (!moved) {\r\n      if (this.container) this.container.didAddPaneItem(item, this, index)\r\n    }\r\n\r\n    if (replacingPendingItem) this.destroyItem(lastPendingItem)\r\n    if (!this.getActiveItem()) this.setActiveItem(item)\r\n    return item\r\n  }\r", "name": "getActiveItem", "func_location": "Pane.addItem", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 640, "func_start_line": 595}}, {"func_info": {"comment": [], "name": "Pane.setActiveItem", "params": ["activeItem", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 443, "start_line": 434}, "call_info": {"func_end_line": 642, "comment": [" Public: Add the given item to the pane.", "", " * `item` The item to add. It can be a model with an associated view or a", "   view.", " * `options` (optional) {Object}", "   * `index` (optional) {Number} indicating the index at which to add the item.", "     If omitted, the item is added after the current active item.", "   * `pending` (optional) {Boolean} indicating that the item should be", "     added in a pending state. Existing pending items in a pane are replaced with", "     new pending items when they are opened.", "", " Returns the added item."], "code": "  addItem (item, options = {}) {\r\n    // Backward compat with old API:\r\n    //   addItem(item, index=@getActiveItemIndex() + 1)\r\n    if (typeof options === 'number') {\r\n      Grim.deprecate(`Pane::addItem(item, ${options}) is deprecated in favor of Pane::addItem(item, {index: ${options}})`)\r\n      options = {index: options}\r\n    }\r\n\r\n    const index = options.index != null ? options.index : this.getActiveItemIndex() + 1\r\n    const moved = options.moved != null ? options.moved : false\r\n    const pending = options.pending != null ? options.pending : false\r\n\r\n    if (!item || typeof item !== 'object') {\r\n      throw new Error(`Pane items must be objects. Attempted to add item ${item}.`)\r\n    }\r\n\r\n    if (typeof item.isDestroyed === 'function' && item.isDestroyed()) {\r\n      throw new Error(`Adding a pane item with URI '${typeof item.getURI === 'function' && item.getURI()}' that has already been destroyed`)\r\n    }\r\n\r\n    if (this.items.includes(item)) return\r\n\r\n    const itemSubscriptions = new CompositeDisposable()\r\n    this.subscriptionsPerItem.set(item, itemSubscriptions)\r\n    if (typeof item.onDidDestroy === 'function') {\r\n      itemSubscriptions.add(item.onDidDestroy(() => this.removeItem(item, false)))\r\n    }\r\n    if (typeof item.onDidTerminatePendingState === 'function') {\r\n      itemSubscriptions.add(item.onDidTerminatePendingState(() => {\r\n        if (this.getPendingItem() === item) this.clearPendingItem()\r\n      }))\r\n    }\r\n\r\n    this.items.splice(index, 0, item)\r\n    const lastPendingItem = this.getPendingItem()\r\n    const replacingPendingItem = lastPendingItem != null && !moved\r\n    if (replacingPendingItem) this.pendingItem = null\r\n    if (pending) this.setPendingItem(item)\r\n\r\n    this.emitter.emit('did-add-item', {item, index, moved})\r\n    if (!moved) {\r\n      if (this.container) this.container.didAddPaneItem(item, this, index)\r\n    }\r\n\r\n    if (replacingPendingItem) this.destroyItem(lastPendingItem)\r\n    if (!this.getActiveItem()) this.setActiveItem(item)\r\n    return item\r\n  }\r", "name": "setActiveItem", "func_location": "Pane.addItem", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 640, "func_start_line": 595}}, {"func_info": {"comment": [" Public: Add the given item to the pane.", "", " * `item` The item to add. It can be a model with an associated view or a", "   view.", " * `options` (optional) {Object}", "   * `index` (optional) {Number} indicating the index at which to add the item.", "     If omitted, the item is added after the current active item.", "   * `pending` (optional) {Boolean} indicating that the item should be", "     added in a pending state. Existing pending items in a pane are replaced with", "     new pending items when they are opened.", "", " Returns the added item."], "name": "Pane.addItem", "params": ["item", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 642, "start_line": 595}, "call_info": {"func_end_line": 682, "comment": [" Public: Add the given items to the pane.", "", " * `items` An {Array} of items to add. Items can be views or models with", "   associated views. Any objects that are already present in the pane's", "   current items will not be added again.", " * `index` (optional) {Number} index at which to add the items. If omitted,", "   the item is #   added after the current active item.", "", " Returns an {Array} of added items."], "code": "  addItems (items, index = this.getActiveItemIndex() + 1) {\r\n    items = items.filter(item => !this.items.includes(item))\r\n    for (let i = 0; i < items.length; i++) {\r\n      const item = items[i]\r\n      this.addItem(item, {index: index + i})\r\n    }\r\n    return items\r\n  }\r", "name": "addItem", "func_location": "Pane.addItems", "args": ["item", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 679, "func_start_line": 675}}, {"func_info": {"comment": [" Add item (or move item) to the end of the itemStack"], "name": "Pane.addItemToStack", "params": ["newItem"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 464, "start_line": 459}, "call_info": {"func_end_line": 456, "comment": [" Build the itemStack after deserializing"], "code": "  addItemsToStack (itemStackIndices) {\r\n    if (this.items.length > 0) {\r\n      if (itemStackIndices.length !== this.items.length || itemStackIndices.includes(-1)) {\r\n        itemStackIndices = this.items.map((item, i) => i)\r\n      }\r\n\r\n      for (let itemIndex of itemStackIndices) {\r\n        this.addItemToStack(this.items[itemIndex])\r\n      }\r\n    }\r\n  }\r", "name": "addItemToStack", "func_location": "Pane.addItemsToStack", "args": [".items.itemIndex"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 453, "func_start_line": 446}}, {"func_info": {"comment": [], "name": "Workspace.addPanel", "params": ["location", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1819, "start_line": 1816}, "call_info": {"func_end_line": 1687, "comment": [" Essential: Adds a panel item to the left of the editor window.", "", " * `options` {Object}", "   * `item` Your panel content. It can be DOM element, a jQuery element, or", "     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the", "     latter. See {ViewRegistry::addViewProvider} for more information.", "   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden", "     (default: true)", "   * `priority` (optional) {Number} Determines stacking order. Lower priority items are", "     forced closer to the edges of the window. (default: 100)", "", " Returns a {Panel}"], "code": "  addLeftPanel (options) {\r\n    return this.addPanel('left', options)\r\n  }\r", "name": "addPanel", "func_location": "Workspace.addLeftPanel", "args": [{"type": "string"}, "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1686, "func_start_line": 1685}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedStartRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2726, "start_line": 2720}, "call_info": {"func_end_line": 1088, "code": "  addLineDecorationToRender (type, decoration, screenRange, reversed) {\r\n    let decorationsToRender\r\n    if (type === 'line') {\r\n      decorationsToRender = this.decorationsToRender.lines\r\n    } else {\r\n      const gutterName = decoration.gutterName || 'line-number'\r\n      decorationsToRender = this.decorationsToRender.lineNumbers.get(gutterName)\r\n      if (!decorationsToRender) {\r\n        decorationsToRender = []\r\n        this.decorationsToRender.lineNumbers.set(gutterName, decorationsToRender)\r\n      }\r\n    }\r\n\r\n    let omitLastRow = false\r\n    if (screenRange.isEmpty()) {\r\n      if (decoration.onlyNonEmpty) return\r\n    } else {\r\n      if (decoration.onlyEmpty) return\r\n      if (decoration.omitEmptyLastRow !== false) {\r\n        omitLastRow = screenRange.end.column === 0\r\n      }\r\n    }\r\n\r\n    const renderedStartRow = this.getRenderedStartRow()\r\n    let rangeStartRow = screenRange.start.row\r\n    let rangeEndRow = screenRange.end.row\r\n\r\n    if (decoration.onlyHead) {\r\n      if (reversed) {\r\n        rangeEndRow = rangeStartRow\r\n      } else {\r\n        rangeStartRow = rangeEndRow\r\n      }\r\n    }\r\n\r\n    rangeStartRow = Math.max(rangeStartRow, this.getRenderedStartRow())\r\n    rangeEndRow = Math.min(rangeEndRow, this.getRenderedEndRow() - 1)\r\n\r\n    for (let row = rangeStartRow; row <= rangeEndRow; row++) {\r\n      if (omitLastRow && row === screenRange.end.row) break\r\n      const currentClassName = decorationsToRender[row - renderedStartRow]\r\n      const newClassName = currentClassName ? currentClassName + ' ' + decoration.class : decoration.class\r\n      decorationsToRender[row - renderedStartRow] = newClassName\r\n    }\r\n  }\r", "name": "getRenderedStartRow", "func_location": "TextEditorComponent.addLineDecorationToRender", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1067, "func_start_line": 1044}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedStartRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2726, "start_line": 2720}, "call_info": {"func_end_line": 1088, "code": "  addLineDecorationToRender (type, decoration, screenRange, reversed) {\r\n    let decorationsToRender\r\n    if (type === 'line') {\r\n      decorationsToRender = this.decorationsToRender.lines\r\n    } else {\r\n      const gutterName = decoration.gutterName || 'line-number'\r\n      decorationsToRender = this.decorationsToRender.lineNumbers.get(gutterName)\r\n      if (!decorationsToRender) {\r\n        decorationsToRender = []\r\n        this.decorationsToRender.lineNumbers.set(gutterName, decorationsToRender)\r\n      }\r\n    }\r\n\r\n    let omitLastRow = false\r\n    if (screenRange.isEmpty()) {\r\n      if (decoration.onlyNonEmpty) return\r\n    } else {\r\n      if (decoration.onlyEmpty) return\r\n      if (decoration.omitEmptyLastRow !== false) {\r\n        omitLastRow = screenRange.end.column === 0\r\n      }\r\n    }\r\n\r\n    const renderedStartRow = this.getRenderedStartRow()\r\n    let rangeStartRow = screenRange.start.row\r\n    let rangeEndRow = screenRange.end.row\r\n\r\n    if (decoration.onlyHead) {\r\n      if (reversed) {\r\n        rangeEndRow = rangeStartRow\r\n      } else {\r\n        rangeStartRow = rangeEndRow\r\n      }\r\n    }\r\n\r\n    rangeStartRow = Math.max(rangeStartRow, this.getRenderedStartRow())\r\n    rangeEndRow = Math.min(rangeEndRow, this.getRenderedEndRow() - 1)\r\n\r\n    for (let row = rangeStartRow; row <= rangeEndRow; row++) {\r\n      if (omitLastRow && row === screenRange.end.row) break\r\n      const currentClassName = decorationsToRender[row - renderedStartRow]\r\n      const newClassName = currentClassName ? currentClassName + ' ' + decoration.class : decoration.class\r\n      decorationsToRender[row - renderedStartRow] = newClassName\r\n    }\r\n  }\r", "name": "getRenderedStartRow", "func_location": "TextEditorComponent.addLineDecorationToRender", "args": ["rangeStartRow", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1079, "func_start_line": 1044}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedEndRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2737, "start_line": 2728}, "call_info": {"func_end_line": 1088, "code": "  addLineDecorationToRender (type, decoration, screenRange, reversed) {\r\n    let decorationsToRender\r\n    if (type === 'line') {\r\n      decorationsToRender = this.decorationsToRender.lines\r\n    } else {\r\n      const gutterName = decoration.gutterName || 'line-number'\r\n      decorationsToRender = this.decorationsToRender.lineNumbers.get(gutterName)\r\n      if (!decorationsToRender) {\r\n        decorationsToRender = []\r\n        this.decorationsToRender.lineNumbers.set(gutterName, decorationsToRender)\r\n      }\r\n    }\r\n\r\n    let omitLastRow = false\r\n    if (screenRange.isEmpty()) {\r\n      if (decoration.onlyNonEmpty) return\r\n    } else {\r\n      if (decoration.onlyEmpty) return\r\n      if (decoration.omitEmptyLastRow !== false) {\r\n        omitLastRow = screenRange.end.column === 0\r\n      }\r\n    }\r\n\r\n    const renderedStartRow = this.getRenderedStartRow()\r\n    let rangeStartRow = screenRange.start.row\r\n    let rangeEndRow = screenRange.end.row\r\n\r\n    if (decoration.onlyHead) {\r\n      if (reversed) {\r\n        rangeEndRow = rangeStartRow\r\n      } else {\r\n        rangeStartRow = rangeEndRow\r\n      }\r\n    }\r\n\r\n    rangeStartRow = Math.max(rangeStartRow, this.getRenderedStartRow())\r\n    rangeEndRow = Math.min(rangeEndRow, this.getRenderedEndRow() - 1)\r\n\r\n    for (let row = rangeStartRow; row <= rangeEndRow; row++) {\r\n      if (omitLastRow && row === screenRange.end.row) break\r\n      const currentClassName = decorationsToRender[row - renderedStartRow]\r\n      const newClassName = currentClassName ? currentClassName + ' ' + decoration.class : decoration.class\r\n      decorationsToRender[row - renderedStartRow] = newClassName\r\n    }\r\n  }\r", "name": "getRenderedEndRow", "func_location": "TextEditorComponent.addLineDecorationToRender", "args": ["rangeEndRow", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1080, "func_start_line": 1044}}, {"func_info": {"comment": [], "name": "Workspace.addPanel", "params": ["location", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1819, "start_line": 1816}, "call_info": {"func_end_line": 1797, "comment": [" Essential: Adds a panel item as a modal dialog.", "", " * `options` {Object}", "   * `item` Your panel content. It can be a DOM element, a jQuery element, or", "     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the", "     model option. See {ViewRegistry::addViewProvider} for more information.", "   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden", "     (default: true)", "   * `priority` (optional) {Number} Determines stacking order. Lower priority items are", "     forced closer to the edges of the window. (default: 100)", "   * `autoFocus` (optional) {Boolean} true if you want modal focus managed for you by Atom.", "     Atom will automatically focus your modal panel's first tabbable element when the modal", "     opens and will restore the previously selected element when the modal closes. Atom will", "     also automatically restrict user tab focus within your modal while it is open.", "     (default: false)", "", " Returns a {Panel}"], "code": "  addModalPanel (options = {}) {\r\n    return this.addPanel('modal', options)\r\n  }\r", "name": "addPanel", "func_location": "Workspace.addModalPanel", "args": [{"type": "string"}, "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1796, "func_start_line": 1795}}, {"func_info": {"comment": [], "name": "TextEditorComponent.requestHorizontalMeasurement", "params": ["row", "column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2257, "start_line": 2243}, "call_info": {"func_end_line": 1156, "code": "  addOverlayDecorationToRender (decoration, marker) {\r\n    const {class: className, item, position, avoidOverflow} = decoration\r\n    const element = TextEditor.viewForItem(item)\r\n    const screenPosition = (position === 'tail')\r\n      ? marker.getTailScreenPosition()\r\n      : marker.getHeadScreenPosition()\r\n\r\n    this.requestHorizontalMeasurement(screenPosition.row, screenPosition.column)\r\n    this.decorationsToRender.overlays.push({className, element, avoidOverflow, screenPosition})\r\n  }\r", "name": "requestHorizontalMeasurement", "func_location": "TextEditorComponent.addOverlayDecorationToRender", "args": ["screenPosition.row", "screenPosition.column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1154, "func_start_line": 1147}}, {"func_info": {"comment": [], "name": "PanelContainer.getPanelIndex", "params": ["panel"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/panel-container.js", "end_line": 100, "start_line": 85}, "call_info": {"func_end_line": 68, "code": "  addPanel (panel) {\r\n    this.subscriptions.add(panel.onDidDestroy(this.panelDestroyed.bind(this)))\r\n\r\n    const index = this.getPanelIndex(panel)\r\n    if (index === this.panels.length) {\r\n      this.panels.push(panel)\r\n    } else {\r\n      this.panels.splice(index, 0, panel)\r\n    }\r\n\r\n    this.emitter.emit('did-add-panel', {panel, index})\r\n    return panel\r\n  }\r", "name": "getPanelIndex", "func_location": "PanelContainer.addPanel", "args": ["panel"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/panel-container.js", "line": 59, "func_start_line": 56}}, {"func_info": {"comment": [], "name": "Project.getDirectoryForProjectPath", "params": ["projectPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 456, "start_line": 444}, "call_info": {"func_end_line": 442, "comment": [" Public: Add a path to the project's list of root paths", "", " * `projectPath` {String} The path to the directory to add.", " * `options` An optional {Object} that may contain the following keys:", "   * `mustExist` If `true`, throw an Error if the `projectPath` does not exist. If `false`, a `projectPath` that does", "     not exist is ignored. Default: `false`.", "   * `exact` If `true`, only add `projectPath` if it names an existing directory. If `false`, if `projectPath` is a", "     a file or does not exist, its parent directory will be added instead."], "code": "  addPath (projectPath, options = {}) {\r\n    const directory = this.getDirectoryForProjectPath(projectPath)\r\n    let ok = true\r\n    if (options.exact === true) {\r\n      ok = (directory.getPath() === projectPath)\r\n    }\r\n    ok = ok && directory.existsSync()\r\n\r\n    if (!ok) {\r\n      if (options.mustExist === true) {\r\n        const err = new Error(`Project directory ${directory} does not exist`)\r\n        err.missingProjectPaths = [projectPath]\r\n        throw err\r\n      } else {\r\n        return\r\n      }\r\n    }\r\n\r\n    for (let existingDirectory of this.getDirectories()) {\r\n      if (existingDirectory.getPath() === directory.getPath()) { return }\r\n    }\r\n\r\n    this.rootDirectories.push(directory)\r\n\r\n    const didChangeCallback = events => {\r\n      // Stop event delivery immediately on removal of a rootDirectory, even if its watcher\r\n      // promise has yet to resolve at the time of removal\r\n      if (this.rootDirectories.includes(directory)) {\r\n        this.emitter.emit('did-change-files', events)\r\n      }\r\n    }\r\n\r\n    // We'll use the directory's custom onDidChangeFiles callback, if available.\r\n    // CustomDirectory::onDidChangeFiles should match the signature of\r\n    // Project::onDidChangeFiles below (although it may resolve asynchronously)\r\n    this.watcherPromisesByPath[directory.getPath()] =\r\n      directory.onDidChangeFiles != null\r\n        ? Promise.resolve(directory.onDidChangeFiles(didChangeCallback))\r\n        : watchPath(directory.getPath(), {}, didChangeCallback)\r\n\r\n    for (let watchedPath in this.watcherPromisesByPath) {\r\n      if (!this.rootDirectories.find(dir => dir.getPath() === watchedPath)) {\r\n        this.watcherPromisesByPath[watchedPath].then(watcher => { watcher.dispose() })\r\n      }\r\n    }\r\n\r\n    let repo = null\r\n    for (let provider of this.repositoryProviders) {\r\n      if (provider.repositoryForDirectorySync) {\r\n        repo = provider.repositoryForDirectorySync(directory)\r\n      }\r\n      if (repo) { break }\r\n    }\r\n    this.repositories.push(repo != null ? repo : null)\r\n    if (repo != null) {\r\n      this.emitter.emit('did-add-repository', repo)\r\n    }\r\n\r\n    if (options.emitEvent !== false) {\r\n      this.emitter.emit('did-change-paths', this.getPaths())\r\n    }\r\n  }\r", "name": "getDirectoryForProjectPath", "func_location": "Project.addPath", "args": ["projectPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 382, "func_start_line": 381}}, {"func_info": {"comment": [" Public: Get an {Array} of {Directory}s associated with this project."], "name": "Project.getDirectories", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 512, "start_line": 510}, "call_info": {"func_end_line": 442, "comment": [" Public: Add a path to the project's list of root paths", "", " * `projectPath` {String} The path to the directory to add.", " * `options` An optional {Object} that may contain the following keys:", "   * `mustExist` If `true`, throw an Error if the `projectPath` does not exist. If `false`, a `projectPath` that does", "     not exist is ignored. Default: `false`.", "   * `exact` If `true`, only add `projectPath` if it names an existing directory. If `false`, if `projectPath` is a", "     a file or does not exist, its parent directory will be added instead."], "code": "  addPath (projectPath, options = {}) {\r\n    const directory = this.getDirectoryForProjectPath(projectPath)\r\n    let ok = true\r\n    if (options.exact === true) {\r\n      ok = (directory.getPath() === projectPath)\r\n    }\r\n    ok = ok && directory.existsSync()\r\n\r\n    if (!ok) {\r\n      if (options.mustExist === true) {\r\n        const err = new Error(`Project directory ${directory} does not exist`)\r\n        err.missingProjectPaths = [projectPath]\r\n        throw err\r\n      } else {\r\n        return\r\n      }\r\n    }\r\n\r\n    for (let existingDirectory of this.getDirectories()) {\r\n      if (existingDirectory.getPath() === directory.getPath()) { return }\r\n    }\r\n\r\n    this.rootDirectories.push(directory)\r\n\r\n    const didChangeCallback = events => {\r\n      // Stop event delivery immediately on removal of a rootDirectory, even if its watcher\r\n      // promise has yet to resolve at the time of removal\r\n      if (this.rootDirectories.includes(directory)) {\r\n        this.emitter.emit('did-change-files', events)\r\n      }\r\n    }\r\n\r\n    // We'll use the directory's custom onDidChangeFiles callback, if available.\r\n    // CustomDirectory::onDidChangeFiles should match the signature of\r\n    // Project::onDidChangeFiles below (although it may resolve asynchronously)\r\n    this.watcherPromisesByPath[directory.getPath()] =\r\n      directory.onDidChangeFiles != null\r\n        ? Promise.resolve(directory.onDidChangeFiles(didChangeCallback))\r\n        : watchPath(directory.getPath(), {}, didChangeCallback)\r\n\r\n    for (let watchedPath in this.watcherPromisesByPath) {\r\n      if (!this.rootDirectories.find(dir => dir.getPath() === watchedPath)) {\r\n        this.watcherPromisesByPath[watchedPath].then(watcher => { watcher.dispose() })\r\n      }\r\n    }\r\n\r\n    let repo = null\r\n    for (let provider of this.repositoryProviders) {\r\n      if (provider.repositoryForDirectorySync) {\r\n        repo = provider.repositoryForDirectorySync(directory)\r\n      }\r\n      if (repo) { break }\r\n    }\r\n    this.repositories.push(repo != null ? repo : null)\r\n    if (repo != null) {\r\n      this.emitter.emit('did-add-repository', repo)\r\n    }\r\n\r\n    if (options.emitEvent !== false) {\r\n      this.emitter.emit('did-change-paths', this.getPaths())\r\n    }\r\n  }\r", "name": "getDirectories", "func_location": "Project.addPath", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 399, "func_start_line": 381}}, {"func_info": {"comment": ["\r\n  Section: Managing Paths\r\n  ", " Public: Get an {Array} of {String}s containing the paths of the project's", " directories."], "name": "Project.getPaths", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 329, "start_line": 327}, "call_info": {"func_end_line": 442, "comment": [" Public: Add a path to the project's list of root paths", "", " * `projectPath` {String} The path to the directory to add.", " * `options` An optional {Object} that may contain the following keys:", "   * `mustExist` If `true`, throw an Error if the `projectPath` does not exist. If `false`, a `projectPath` that does", "     not exist is ignored. Default: `false`.", "   * `exact` If `true`, only add `projectPath` if it names an existing directory. If `false`, if `projectPath` is a", "     a file or does not exist, its parent directory will be added instead."], "code": "  addPath (projectPath, options = {}) {\r\n    const directory = this.getDirectoryForProjectPath(projectPath)\r\n    let ok = true\r\n    if (options.exact === true) {\r\n      ok = (directory.getPath() === projectPath)\r\n    }\r\n    ok = ok && directory.existsSync()\r\n\r\n    if (!ok) {\r\n      if (options.mustExist === true) {\r\n        const err = new Error(`Project directory ${directory} does not exist`)\r\n        err.missingProjectPaths = [projectPath]\r\n        throw err\r\n      } else {\r\n        return\r\n      }\r\n    }\r\n\r\n    for (let existingDirectory of this.getDirectories()) {\r\n      if (existingDirectory.getPath() === directory.getPath()) { return }\r\n    }\r\n\r\n    this.rootDirectories.push(directory)\r\n\r\n    const didChangeCallback = events => {\r\n      // Stop event delivery immediately on removal of a rootDirectory, even if its watcher\r\n      // promise has yet to resolve at the time of removal\r\n      if (this.rootDirectories.includes(directory)) {\r\n        this.emitter.emit('did-change-files', events)\r\n      }\r\n    }\r\n\r\n    // We'll use the directory's custom onDidChangeFiles callback, if available.\r\n    // CustomDirectory::onDidChangeFiles should match the signature of\r\n    // Project::onDidChangeFiles below (although it may resolve asynchronously)\r\n    this.watcherPromisesByPath[directory.getPath()] =\r\n      directory.onDidChangeFiles != null\r\n        ? Promise.resolve(directory.onDidChangeFiles(didChangeCallback))\r\n        : watchPath(directory.getPath(), {}, didChangeCallback)\r\n\r\n    for (let watchedPath in this.watcherPromisesByPath) {\r\n      if (!this.rootDirectories.find(dir => dir.getPath() === watchedPath)) {\r\n        this.watcherPromisesByPath[watchedPath].then(watcher => { watcher.dispose() })\r\n      }\r\n    }\r\n\r\n    let repo = null\r\n    for (let provider of this.repositoryProviders) {\r\n      if (provider.repositoryForDirectorySync) {\r\n        repo = provider.repositoryForDirectorySync(directory)\r\n      }\r\n      if (repo) { break }\r\n    }\r\n    this.repositories.push(repo != null ? repo : null)\r\n    if (repo != null) {\r\n      this.emitter.emit('did-add-repository', repo)\r\n    }\r\n\r\n    if (options.emitEvent !== false) {\r\n      this.emitter.emit('did-change-paths', this.getPaths())\r\n    }\r\n  }\r", "name": "getPaths", "func_location": "Project.addPath", "args": [{"type": "string"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 440, "func_start_line": 381}}, {"func_info": {"comment": [], "name": "compileFileAtPath", "params": ["compiler", "filePath", "extension"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/compile-cache.js", "end_line": 99, "start_line": 84}, "call_info": {"func_end_line": 69, "code": "exports.addPathToCache = function (filePath, atomHome) {\r\n  this.setAtomHomeDirectory(atomHome)\r\n  var extension = path.extname(filePath)\r\n\r\n  if (extension === '.cson') {\r\n    if (!CSON) {\r\n      CSON = require('season')\r\n      CSON.setCacheDir(this.getCacheDirectory())\r\n    }\r\n    return CSON.readFileSync(filePath)\r\n  } else {\r\n    var compiler = COMPILERS[extension]\r\n    if (compiler) {\r\n      return compileFileAtPath(compiler, filePath, extension)\r\n    }\r\n  }\r\n}\r", "name": "compileFileAtPath", "func_location": "exports.addPathToCache", "args": ["compiler", "filePath", "extension"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/compile-cache.js", "line": 66, "func_start_line": 53}}, {"func_info": {"comment": [], "name": "HistoryManager.getProject", "params": ["paths"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "end_line": 91, "start_line": 83}, "call_info": {"func_end_line": 68, "code": "  async addProject (paths, lastOpened) {\r\n    if (paths.length === 0) return\r\n\r\n    let project = this.getProject(paths)\r\n    if (!project) {\r\n      project = new HistoryProject(paths)\r\n      this.projects.push(project)\r\n    }\r\n    project.lastOpened = lastOpened || new Date()\r\n    this.projects.sort((a, b) => b.lastOpened - a.lastOpened)\r\n\r\n    await this.saveState()\r\n    this.didChangeProjects()\r\n  }\r", "name": "getProject", "func_location": "HistoryManager.addProject", "args": ["paths"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "line": 58, "func_start_line": 55}}, {"func_info": {"comment": [], "name": "HistoryProject.constructor", "params": ["paths", "lastOpened"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "end_line": 121, "start_line": 118}, "call_info": {"func_end_line": 68, "name": "constructor", "func_location": "HistoryManager.addProject", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "line": 60, "func_start_line": 55}}, {"func_info": {"comment": [], "name": "HistoryManager.saveState", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "end_line": 106, "start_line": 103}, "call_info": {"func_end_line": 68, "code": "  async addProject (paths, lastOpened) {\r\n    if (paths.length === 0) return\r\n\r\n    let project = this.getProject(paths)\r\n    if (!project) {\r\n      project = new HistoryProject(paths)\r\n      this.projects.push(project)\r\n    }\r\n    project.lastOpened = lastOpened || new Date()\r\n    this.projects.sort((a, b) => b.lastOpened - a.lastOpened)\r\n\r\n    await this.saveState()\r\n    this.didChangeProjects()\r\n  }\r", "name": "saveState", "func_location": "HistoryManager.addProject", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "line": 66, "func_start_line": 55}}, {"func_info": {"comment": [], "name": "HistoryManager.didChangeProjects", "params": ["args"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "end_line": 53, "start_line": 51}, "call_info": {"func_end_line": 68, "code": "  async addProject (paths, lastOpened) {\r\n    if (paths.length === 0) return\r\n\r\n    let project = this.getProject(paths)\r\n    if (!project) {\r\n      project = new HistoryProject(paths)\r\n      this.projects.push(project)\r\n    }\r\n    project.lastOpened = lastOpened || new Date()\r\n    this.projects.sort((a, b) => b.lastOpened - a.lastOpened)\r\n\r\n    await this.saveState()\r\n    this.didChangeProjects()\r\n  }\r", "name": "didChangeProjects", "func_location": "HistoryManager.addProject", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "line": 67, "func_start_line": 55}}, {"func_info": {"comment": [], "name": "Workspace.addPanel", "params": ["location", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1819, "start_line": 1816}, "call_info": {"func_end_line": 1708, "comment": [" Essential: Adds a panel item to the right of the editor window.", "", " * `options` {Object}", "   * `item` Your panel content. It can be DOM element, a jQuery element, or", "     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the", "     latter. See {ViewRegistry::addViewProvider} for more information.", "   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden", "     (default: true)", "   * `priority` (optional) {Number} Determines stacking order. Lower priority items are", "     forced closer to the edges of the window. (default: 100)", "", " Returns a {Panel}"], "code": "  addRightPanel (options) {\r\n    return this.addPanel('right', options)\r\n  }\r", "name": "addPanel", "func_location": "Workspace.addRightPanel", "args": [{"type": "string"}, "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1707, "func_start_line": 1706}}, {"func_info": {"comment": [], "name": "Config.addSchemaEnforcer", "params": ["typeName", "enforcerFunction"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 368, "start_line": 365}, "call_info": {"func_end_line": 378, "code": "  static addSchemaEnforcers (filters) {\r\n    for (let typeName in filters) {\r\n      const functions = filters[typeName]\r\n      for (let name in functions) {\r\n        const enforcerFunction = functions[name]\r\n        this.addSchemaEnforcer(typeName, enforcerFunction)\r\n      }\r\n    }\r\n  }\r", "name": "addSchemaEnforcer", "func_location": "Config.addSchemaEnforcers", "args": ["typeName", "enforcerFunction"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 375, "func_start_line": 370}}, {"func_info": {"comment": [], "name": "CommandRegistry.commandRegistered", "params": ["commandName"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js", "end_line": 406, "start_line": 401}, "call_info": {"func_end_line": 181, "code": "  addSelectorBasedListener (selector, commandName, listener) {\r\n    if (this.selectorBasedListenersByCommandName[commandName] == null) {\r\n      this.selectorBasedListenersByCommandName[commandName] = []\r\n    }\r\n    const listenersForCommand = this.selectorBasedListenersByCommandName[commandName]\r\n    const selectorListener = new SelectorBasedListener(selector, commandName, listener)\r\n    listenersForCommand.push(selectorListener)\r\n\r\n    this.commandRegistered(commandName)\r\n\r\n    return new Disposable(() => {\r\n      listenersForCommand.splice(listenersForCommand.indexOf(selectorListener), 1)\r\n      if (listenersForCommand.length === 0) {\r\n        delete this.selectorBasedListenersByCommandName[commandName]\r\n      }\r\n    })\r\n  }\r", "name": "commandRegistered", "func_location": "CommandRegistry.addSelectorBasedListener", "args": ["commandName"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js", "line": 173, "func_start_line": 165}}, {"func_info": {"comment": [], "name": "StyleManager.upgradeDeprecatedSelectorsForStyleSheet", "params": ["styleSheet", "context"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js", "end_line": 207, "start_line": 189}, "call_info": {"func_end_line": 157, "code": "  addStyleSheet (source, params = {}) {\r\n    let styleElement\r\n    let updated\r\n    if (params.sourcePath != null && this.styleElementsBySourcePath[params.sourcePath] != null) {\r\n      updated = true\r\n      styleElement = this.styleElementsBySourcePath[params.sourcePath]\r\n    } else {\r\n      updated = false\r\n      styleElement = document.createElement('style')\r\n      if (params.sourcePath != null) {\r\n        styleElement.sourcePath = params.sourcePath\r\n        styleElement.setAttribute('source-path', params.sourcePath)\r\n      }\r\n      if (params.context != null) {\r\n        styleElement.context = params.context\r\n        styleElement.setAttribute('context', params.context)\r\n      }\r\n      if (params.priority != null) {\r\n        styleElement.priority = params.priority\r\n        styleElement.setAttribute('priority', params.priority)\r\n      }\r\n    }\r\n\r\n    if (params.skipDeprecatedSelectorsTransformation) {\r\n      styleElement.textContent = source\r\n    } else {\r\n      const transformed = this.upgradeDeprecatedSelectorsForStyleSheet(source, params.context)\r\n      styleElement.textContent = transformed.source\r\n      if (transformed.deprecationMessage) {\r\n        this.deprecationsBySourcePath[params.sourcePath] = {message: transformed.deprecationMessage}\r\n        this.emitter.emit('did-update-deprecations')\r\n      }\r\n    }\r\n\r\n    if (updated) {\r\n      this.emitter.emit('did-update-style-element', styleElement)\r\n    } else {\r\n      this.addStyleElement(styleElement)\r\n    }\r\n    return new Disposable(() => { this.removeStyleElement(styleElement) })\r\n  }\r", "name": "upgradeDeprecatedSelectorsForStyleSheet", "func_location": "StyleManager.addStyleSheet", "args": ["source", "params.context"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js", "line": 143, "func_start_line": 117}}, {"func_info": {"comment": [], "name": "StyleManager.addStyleElement", "params": ["styleElement"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js", "end_line": 176, "start_line": 159}, "call_info": {"func_end_line": 157, "code": "  addStyleSheet (source, params = {}) {\r\n    let styleElement\r\n    let updated\r\n    if (params.sourcePath != null && this.styleElementsBySourcePath[params.sourcePath] != null) {\r\n      updated = true\r\n      styleElement = this.styleElementsBySourcePath[params.sourcePath]\r\n    } else {\r\n      updated = false\r\n      styleElement = document.createElement('style')\r\n      if (params.sourcePath != null) {\r\n        styleElement.sourcePath = params.sourcePath\r\n        styleElement.setAttribute('source-path', params.sourcePath)\r\n      }\r\n      if (params.context != null) {\r\n        styleElement.context = params.context\r\n        styleElement.setAttribute('context', params.context)\r\n      }\r\n      if (params.priority != null) {\r\n        styleElement.priority = params.priority\r\n        styleElement.setAttribute('priority', params.priority)\r\n      }\r\n    }\r\n\r\n    if (params.skipDeprecatedSelectorsTransformation) {\r\n      styleElement.textContent = source\r\n    } else {\r\n      const transformed = this.upgradeDeprecatedSelectorsForStyleSheet(source, params.context)\r\n      styleElement.textContent = transformed.source\r\n      if (transformed.deprecationMessage) {\r\n        this.deprecationsBySourcePath[params.sourcePath] = {message: transformed.deprecationMessage}\r\n        this.emitter.emit('did-update-deprecations')\r\n      }\r\n    }\r\n\r\n    if (updated) {\r\n      this.emitter.emit('did-update-style-element', styleElement)\r\n    } else {\r\n      this.addStyleElement(styleElement)\r\n    }\r\n    return new Disposable(() => { this.removeStyleElement(styleElement) })\r\n  }\r", "name": "addStyleElement", "func_location": "StyleManager.addStyleSheet", "args": ["styleElement"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js", "line": 154, "func_start_line": 117}}, {"func_info": {"comment": [], "name": "NotificationManager.addNotification", "params": ["notification"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification-manager.js", "end_line": 195, "start_line": 191}, "call_info": {"func_end_line": 69, "comment": ["\r\n  Section: Adding Notifications\r\n  ", " Public: Add a success notification.", "", " * `message` A {String} message", " * `options` (optional) An options {Object} with the following keys:", "    * `buttons` (optional) An {Array} of {Object} where each {Object} has", "      the following options:", "      * `className` (optional) {String} a class name to add to the button's", "        default class name (`btn btn-success`).", "      * `onDidClick` (optional) {Function} callback to call when the button", "        has been clicked. The context will be set to the", "        {NotificationElement} instance.", "      * `text` {String} inner text for the button", "    * `description` (optional) A Markdown {String} containing a longer", "      description about the notification. By default, this **will not**", "      preserve newlines and whitespace when it is rendered.", "    * `detail` (optional) A plain-text {String} containing additional", "      details about the notification. By default, this **will** preserve", "      newlines and whitespace when it is rendered.", "    * `dismissable` (optional) A {Boolean} indicating whether this", "      notification can be dismissed by the user. Defaults to `false`.", "    * `icon` (optional) A {String} name of an icon from Octicons to display", "      in the notification header. Defaults to `'check'`.", "", " Returns the {Notification} that was added."], "code": "  addSuccess (message, options) {\r\n    return this.addNotification(new Notification('success', message, options))\r\n  }\r", "name": "addNotification", "func_location": "NotificationManager.addSuccess", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification-manager.js", "line": 68, "func_start_line": 67}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedStartRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2726, "start_line": 2720}, "call_info": {"func_end_line": 1319, "code": "  addTextDecorationStart (row, column, className, style) {\r\n    const renderedStartRow = this.getRenderedStartRow()\r\n    let decorationStarts = this.decorationsToRender.text[row - renderedStartRow]\r\n    if (!decorationStarts) {\r\n      decorationStarts = []\r\n      this.decorationsToRender.text[row - renderedStartRow] = decorationStarts\r\n    }\r\n    decorationStarts.push({column, className, style})\r\n  }\r", "name": "getRenderedStartRow", "func_location": "TextEditorComponent.addTextDecorationStart", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1312, "func_start_line": 1311}}, {"func_info": {"comment": [], "name": "Workspace.addPanel", "params": ["location", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1819, "start_line": 1816}, "call_info": {"func_end_line": 1729, "comment": [" Essential: Adds a panel item to the top of the editor window above the tabs.", "", " * `options` {Object}", "   * `item` Your panel content. It can be DOM element, a jQuery element, or", "     a model with a view registered via {ViewRegistry::addViewProvider}. We recommend the", "     latter. See {ViewRegistry::addViewProvider} for more information.", "   * `visible` (optional) {Boolean} false if you want the panel to initially be hidden", "     (default: true)", "   * `priority` (optional) {Number} Determines stacking order. Lower priority items are", "     forced closer to the edges of the window. (default: 100)", "", " Returns a {Panel}"], "code": "  addTopPanel (options) {\r\n    return this.addPanel('top', options)\r\n  }\r", "name": "addPanel", "func_location": "Workspace.addTopPanel", "args": [{"type": "string"}, "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1728, "func_start_line": 1727}}, {"func_info": {"comment": [], "name": "AtomEnvironment.loadState", "params": ["stateKey"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1221, "start_line": 1210}, "call_info": {"func_end_line": 1127, "code": "  async addToProject (projectPaths) {\r\n    const state = await this.loadState(this.getStateKey(projectPaths))\r\n    if (state && (this.project.getPaths().length === 0)) {\r\n      this.attemptRestoreProjectStateForPaths(state, projectPaths)\r\n    } else {\r\n      projectPaths.map((folder) => this.project.addPath(folder))\r\n    }\r\n  }\r", "name": "loadState", "func_location": "AtomEnvironment.addToProject", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 1121, "func_start_line": 1120}}, {"func_info": {"comment": [], "name": "AtomEnvironment.getStateKey", "params": ["paths"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1286, "start_line": 1279}, "call_info": {"func_end_line": 1127, "code": "  async addToProject (projectPaths) {\r\n    const state = await this.loadState(this.getStateKey(projectPaths))\r\n    if (state && (this.project.getPaths().length === 0)) {\r\n      this.attemptRestoreProjectStateForPaths(state, projectPaths)\r\n    } else {\r\n      projectPaths.map((folder) => this.project.addPath(folder))\r\n    }\r\n  }\r", "name": "getStateKey", "func_location": "AtomEnvironment.addToProject", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 1121, "func_start_line": 1120}}, {"func_info": {"comment": [], "name": "AtomEnvironment.attemptRestoreProjectStateForPaths", "params": ["state", "projectPaths", "filesToOpen"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1181, "start_line": 1129}, "call_info": {"func_end_line": 1127, "code": "  async addToProject (projectPaths) {\r\n    const state = await this.loadState(this.getStateKey(projectPaths))\r\n    if (state && (this.project.getPaths().length === 0)) {\r\n      this.attemptRestoreProjectStateForPaths(state, projectPaths)\r\n    } else {\r\n      projectPaths.map((folder) => this.project.addPath(folder))\r\n    }\r\n  }\r", "name": "attemptRestoreProjectStateForPaths", "func_location": "AtomEnvironment.addToProject", "args": ["state", "projectPaths"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 1123, "func_start_line": 1120}}, {"func_info": {"comment": [], "name": "NotificationManager.addNotification", "params": ["notification"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification-manager.js", "end_line": 195, "start_line": 191}, "call_info": {"func_end_line": 125, "comment": [" Public: Add a warning notification.", "", " * `message` A {String} message", " * `options` (optional) An options {Object} with the following keys:", "    * `buttons` (optional) An {Array} of {Object} where each {Object} has", "      the following options:", "      * `className` (optional) {String} a class name to add to the button's", "        default class name (`btn btn-warning`).", "      * `onDidClick` (optional) {Function} callback to call when the button", "        has been clicked. The context will be set to the", "        {NotificationElement} instance.", "      * `text` {String} inner text for the button", "    * `description` (optional) A Markdown {String} containing a longer", "      description about the notification. By default, this **will not**", "      preserve newlines and whitespace when it is rendered.", "    * `detail` (optional) A plain-text {String} containing additional", "      details about the notification. By default, this **will** preserve", "      newlines and whitespace when it is rendered.", "    * `dismissable` (optional) A {Boolean} indicating whether this", "      notification can be dismissed by the user. Defaults to `false`.", "    * `icon` (optional) A {String} name of an icon from Octicons to display", "      in the notification header. Defaults to `'alert'`.", "", " Returns the {Notification} that was added."], "code": "  addWarning (message, options) {\r\n    return this.addNotification(new Notification('warning', message, options))\r\n  }\r", "name": "addNotification", "func_location": "NotificationManager.addWarning", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification-manager.js", "line": 124, "func_start_line": 123}}, {"func_info": {"comment": [], "name": "WindowStack.removeWindow", "params": ["window"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1413, "start_line": 1408}, "call_info": {"func_end_line": 1402, "code": "  addWindow (window) {\r\n    this.removeWindow(window)\r\n    return this.windows.unshift(window)\r\n  }\r", "name": "removeWindow", "func_location": "WindowStack.addWindow", "args": ["window"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 1400, "func_start_line": 1399}}, {"func_info": {"comment": [" Public: Used to make all window related menu items are active.", "", " enable - If true enables all window specific items, if false disables all", "          window specific items."], "name": "ApplicationMenu.enableWindowSpecificItems", "params": ["enable"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "end_line": 100, "start_line": 96}, "call_info": {"func_end_line": 60, "comment": [" Register a BrowserWindow with this application menu."], "code": "  addWindow (window) {\r\n    if (this.lastFocusedWindow == null) this.lastFocusedWindow = window\r\n\r\n    const focusHandler = () => {\r\n      this.lastFocusedWindow = window\r\n      const template = this.windowTemplates.get(window)\r\n      if (template) this.setActiveTemplate(template)\r\n    }\r\n\r\n    window.on('focus', focusHandler)\r\n    window.once('closed', () => {\r\n      if (window === this.lastFocusedWindow) this.lastFocusedWindow = null\r\n      this.windowTemplates.delete(window)\r\n      window.removeListener('focus', focusHandler)\r\n    })\r\n\r\n    this.enableWindowSpecificItems(true)\r\n  }\r", "name": "enableWindowSpecificItems", "func_location": "ApplicationMenu.addWindow", "args": [{"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "line": 59, "func_start_line": 43}}, {"func_info": {"comment": [], "name": "LineComponent.appendTextNode", "params": ["openScopeNode", "text", "activeClassName", "activeStyle"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4053, "start_line": 4041}, "call_info": {"func_end_line": 4039, "code": "  appendContents () {\r\n    const {displayLayer, nodePool, screenLine, textDecorations} = this.props\r\n\r\n    this.textNodes.length = 0\r\n\r\n    const {lineText, tags} = screenLine\r\n    let openScopeNode = nodePool.getElement('SPAN', null, null)\r\n    this.element.appendChild(openScopeNode)\r\n\r\n    let decorationIndex = 0\r\n    let column = 0\r\n    let activeClassName = null\r\n    let activeStyle = null\r\n    let nextDecoration = textDecorations ? textDecorations[decorationIndex] : null\r\n    if (nextDecoration && nextDecoration.column === 0) {\r\n      column = nextDecoration.column\r\n      activeClassName = nextDecoration.className\r\n      activeStyle = nextDecoration.style\r\n      nextDecoration = textDecorations[++decorationIndex]\r\n    }\r\n\r\n    for (let i = 0; i < tags.length; i++) {\r\n      const tag = tags[i]\r\n      if (tag !== 0) {\r\n        if (displayLayer.isCloseTag(tag)) {\r\n          openScopeNode = openScopeNode.parentElement\r\n        } else if (displayLayer.isOpenTag(tag)) {\r\n          const newScopeNode = nodePool.getElement('SPAN', displayLayer.classNameForTag(tag), null)\r\n          openScopeNode.appendChild(newScopeNode)\r\n          openScopeNode = newScopeNode\r\n        } else {\r\n          const nextTokenColumn = column + tag\r\n          while (nextDecoration && nextDecoration.column <= nextTokenColumn) {\r\n            const text = lineText.substring(column, nextDecoration.column)\r\n            this.appendTextNode(openScopeNode, text, activeClassName, activeStyle)\r\n            column = nextDecoration.column\r\n            activeClassName = nextDecoration.className\r\n            activeStyle = nextDecoration.style\r\n            nextDecoration = textDecorations[++decorationIndex]\r\n          }\r\n\r\n          if (column < nextTokenColumn) {\r\n            const text = lineText.substring(column, nextTokenColumn)\r\n            this.appendTextNode(openScopeNode, text, activeClassName, activeStyle)\r\n            column = nextTokenColumn\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (column === 0) {\r\n      const textNode = nodePool.getTextNode(' ')\r\n      this.element.appendChild(textNode)\r\n      this.textNodes.push(textNode)\r\n    }\r\n\r\n    if (lineText.endsWith(displayLayer.foldCharacter)) {\r\n      // Insert a zero-width non-breaking whitespace, so that LinesYardstick can\r\n      // take the fold-marker::after pseudo-element into account during\r\n      // measurements when such marker is the last character on the line.\r\n      const textNode = nodePool.getTextNode(ZERO_WIDTH_NBSP_CHARACTER)\r\n      this.element.appendChild(textNode)\r\n      this.textNodes.push(textNode)\r\n    }\r\n  }\r", "name": "appendTextNode", "func_location": "LineComponent.appendContents", "args": ["openScopeNode", "text", "activeClassName", "activeStyle"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 4009, "func_start_line": 3975}}, {"func_info": {"comment": [], "name": "LineComponent.appendTextNode", "params": ["openScopeNode", "text", "activeClassName", "activeStyle"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4053, "start_line": 4041}, "call_info": {"func_end_line": 4039, "code": "  appendContents () {\r\n    const {displayLayer, nodePool, screenLine, textDecorations} = this.props\r\n\r\n    this.textNodes.length = 0\r\n\r\n    const {lineText, tags} = screenLine\r\n    let openScopeNode = nodePool.getElement('SPAN', null, null)\r\n    this.element.appendChild(openScopeNode)\r\n\r\n    let decorationIndex = 0\r\n    let column = 0\r\n    let activeClassName = null\r\n    let activeStyle = null\r\n    let nextDecoration = textDecorations ? textDecorations[decorationIndex] : null\r\n    if (nextDecoration && nextDecoration.column === 0) {\r\n      column = nextDecoration.column\r\n      activeClassName = nextDecoration.className\r\n      activeStyle = nextDecoration.style\r\n      nextDecoration = textDecorations[++decorationIndex]\r\n    }\r\n\r\n    for (let i = 0; i < tags.length; i++) {\r\n      const tag = tags[i]\r\n      if (tag !== 0) {\r\n        if (displayLayer.isCloseTag(tag)) {\r\n          openScopeNode = openScopeNode.parentElement\r\n        } else if (displayLayer.isOpenTag(tag)) {\r\n          const newScopeNode = nodePool.getElement('SPAN', displayLayer.classNameForTag(tag), null)\r\n          openScopeNode.appendChild(newScopeNode)\r\n          openScopeNode = newScopeNode\r\n        } else {\r\n          const nextTokenColumn = column + tag\r\n          while (nextDecoration && nextDecoration.column <= nextTokenColumn) {\r\n            const text = lineText.substring(column, nextDecoration.column)\r\n            this.appendTextNode(openScopeNode, text, activeClassName, activeStyle)\r\n            column = nextDecoration.column\r\n            activeClassName = nextDecoration.className\r\n            activeStyle = nextDecoration.style\r\n            nextDecoration = textDecorations[++decorationIndex]\r\n          }\r\n\r\n          if (column < nextTokenColumn) {\r\n            const text = lineText.substring(column, nextTokenColumn)\r\n            this.appendTextNode(openScopeNode, text, activeClassName, activeStyle)\r\n            column = nextTokenColumn\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (column === 0) {\r\n      const textNode = nodePool.getTextNode(' ')\r\n      this.element.appendChild(textNode)\r\n      this.textNodes.push(textNode)\r\n    }\r\n\r\n    if (lineText.endsWith(displayLayer.foldCharacter)) {\r\n      // Insert a zero-width non-breaking whitespace, so that LinesYardstick can\r\n      // take the fold-marker::after pseudo-element into account during\r\n      // measurements when such marker is the last character on the line.\r\n      const textNode = nodePool.getTextNode(ZERO_WIDTH_NBSP_CHARACTER)\r\n      this.element.appendChild(textNode)\r\n      this.textNodes.push(textNode)\r\n    }\r\n  }\r", "name": "appendTextNode", "func_location": "LineComponent.appendContents", "args": ["openScopeNode", "text", "activeClassName", "activeStyle"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 4018, "func_start_line": 3975}}, {"func_info": {"comment": [], "name": "ReopenProjectMenuManager.taskDescription", "params": ["paths"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js", "end_line": 55, "start_line": 53}, "call_info": {"func_end_line": 73, "comment": [" Windows users can right-click Atom taskbar and remove project from the jump list.", " We have to honor that or the group stops working. As we only get a partial list", " each time we remove them from history entirely."], "code": "  async applyWindowsJumpListRemovals () {\r\n    if (process.platform !== 'win32') return\r\n    if (this.app === undefined) {\r\n      this.app = require('remote').app\r\n    }\r\n\r\n    const removed = this.app.getJumpListSettings().removedItems.map(i => i.description)\r\n    if (removed.length === 0) return\r\n    for (let project of this.historyManager.getProjects()) {\r\n      if (removed.includes(ReopenProjectMenuManager.taskDescription(project.paths))) {\r\n        await this.historyManager.removeProject(project.paths)\r\n      }\r\n    }\r\n  }\r", "name": "taskDescription", "func_location": "ReopenProjectMenuManager.applyWindowsJumpListRemovals", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js", "line": 69, "func_start_line": 60}}, {"func_info": {"comment": [" Public: Returns a {Boolean} that is `true` if the current version is an official release."], "name": "AtomEnvironment.isReleasedVersion", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 509, "start_line": 507}, "call_info": {"func_end_line": 1094, "comment": ["\r\n  Section: Private\r\n  "], "code": "  assert (condition, message, callbackOrMetadata) {\r\n    if (condition) return true\r\n\r\n    const error = new Error(`Assertion failed: ${message}`)\r\n    Error.captureStackTrace(error, this.assert)\r\n\r\n    if (callbackOrMetadata) {\r\n      if (typeof callbackOrMetadata === 'function') {\r\n        callbackOrMetadata(error)\r\n      } else {\r\n        error.metadata = callbackOrMetadata\r\n      }\r\n    }\r\n\r\n    this.emitter.emit('did-fail-assertion', error)\r\n    if (!this.isReleasedVersion()) throw error\r\n\r\n    return false\r\n  }\r", "name": "isReleasedVersion", "func_location": "AtomEnvironment.assert", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 1091, "func_start_line": 1076}}, {"func_info": {"comment": [], "name": "GrammarRegistry.grammarForId", "params": ["languageId"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 326, "start_line": 313}, "call_info": {"func_end_line": 143, "comment": [" Extended: Force a {TextBuffer} to use a different grammar than the", " one that would otherwise be selected for it.", "", " * `buffer` The {TextBuffer} whose grammar will be set.", " * `languageId` The {String} id of the desired language.", "", " Returns a {Boolean} that indicates whether the language was successfully", " found."], "code": "  assignLanguageMode (buffer, languageId) {\r\n    if (buffer.getBuffer) buffer = buffer.getBuffer()\r\n\r\n    let grammar = null\r\n    if (languageId != null) {\r\n      grammar = this.grammarForId(languageId)\r\n      if (!grammar) return false\r\n      this.languageOverridesByBufferId.set(buffer.id, languageId)\r\n    } else {\r\n      this.languageOverridesByBufferId.set(buffer.id, null)\r\n      grammar = this.textmateRegistry.nullGrammar\r\n    }\r\n\r\n    this.grammarScoresByBuffer.set(buffer, null)\r\n    if (grammar !== buffer.getLanguageMode().grammar) {\r\n      buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(grammar, buffer))\r\n    }\r\n\r\n    return true\r\n  }\r", "name": "grammarForId", "func_location": "GrammarRegistry.assignLanguageMode", "args": ["languageId"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 129, "func_start_line": 124}}, {"func_info": {"comment": [], "name": "GrammarRegistry.languageModeForGrammarAndBuffer", "params": ["grammar", "buffer"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 176, "start_line": 170}, "call_info": {"func_end_line": 143, "comment": [" Extended: Force a {TextBuffer} to use a different grammar than the", " one that would otherwise be selected for it.", "", " * `buffer` The {TextBuffer} whose grammar will be set.", " * `languageId` The {String} id of the desired language.", "", " Returns a {Boolean} that indicates whether the language was successfully", " found."], "code": "  assignLanguageMode (buffer, languageId) {\r\n    if (buffer.getBuffer) buffer = buffer.getBuffer()\r\n\r\n    let grammar = null\r\n    if (languageId != null) {\r\n      grammar = this.grammarForId(languageId)\r\n      if (!grammar) return false\r\n      this.languageOverridesByBufferId.set(buffer.id, languageId)\r\n    } else {\r\n      this.languageOverridesByBufferId.set(buffer.id, null)\r\n      grammar = this.textmateRegistry.nullGrammar\r\n    }\r\n\r\n    this.grammarScoresByBuffer.set(buffer, null)\r\n    if (grammar !== buffer.getLanguageMode().grammar) {\r\n      buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(grammar, buffer))\r\n    }\r\n\r\n    return true\r\n  }\r", "name": "languageModeForGrammarAndBuffer", "func_location": "GrammarRegistry.assignLanguageMode", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 139, "func_start_line": 124}}, {"func_info": {"comment": [], "name": "AtomApplication.getAllWindows", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 323, "start_line": 321}, "call_info": {"func_end_line": 745, "code": "  atomWindowForBrowserWindow (browserWindow) {\r\n    return this.getAllWindows().find(atomWindow => atomWindow.browserWindow === browserWindow)\r\n  }\r", "name": "getAllWindows", "func_location": "AtomApplication.atomWindowForBrowserWindow", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 744, "func_start_line": 743}}, {"func_info": {"comment": [], "name": "AtomApplication.atomWindowForBrowserWindow", "params": ["browserWindow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 745, "start_line": 743}, "call_info": {"func_end_line": 741, "comment": [" Returns the {AtomWindow} for the given ipcMain event."], "code": "  atomWindowForEvent ({sender}) {\r\n    return this.atomWindowForBrowserWindow(BrowserWindow.fromWebContents(sender))\r\n  }\r", "name": "atomWindowForBrowserWindow", "func_location": "AtomApplication.atomWindowForEvent", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 740, "func_start_line": 739}}, {"func_info": {"comment": [], "name": "CommandRegistry.commandRegistered", "params": ["commandName"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js", "end_line": 406, "start_line": 401}, "call_info": {"func_end_line": 70, "code": "  attach (rootNode) {\r\n    this.rootNode = rootNode\r\n    for (const command in this.selectorBasedListenersByCommandName) {\r\n      this.commandRegistered(command)\r\n    }\r\n\r\n    for (const command in this.inlineListenersByCommandName) {\r\n      this.commandRegistered(command)\r\n    }\r\n  }\r", "name": "commandRegistered", "func_location": "CommandRegistry.attach", "args": ["command"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js", "line": 64, "func_start_line": 61}}, {"func_info": {"comment": [], "name": "CommandRegistry.commandRegistered", "params": ["commandName"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js", "end_line": 406, "start_line": 401}, "call_info": {"func_end_line": 70, "code": "  attach (rootNode) {\r\n    this.rootNode = rootNode\r\n    for (const command in this.selectorBasedListenersByCommandName) {\r\n      this.commandRegistered(command)\r\n    }\r\n\r\n    for (const command in this.inlineListenersByCommandName) {\r\n      this.commandRegistered(command)\r\n    }\r\n  }\r", "name": "commandRegistered", "func_location": "CommandRegistry.attach", "args": ["command"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js", "line": 68, "func_start_line": 61}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 43, "code": "  attachedCallback () {\r\n    this.getComponent().didAttach()\r\n    this.emitter.emit('did-attach')\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.attachedCallback", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 41, "func_start_line": 40}}, {"func_info": {"comment": [], "name": "AtomEnvironment.restoreStateIntoThisEnvironment", "params": ["state"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1189, "start_line": 1183}, "call_info": {"func_end_line": 1181, "code": "  async attemptRestoreProjectStateForPaths (state, projectPaths, filesToOpen = []) {\r\n    const center = this.workspace.getCenter()\r\n    const windowIsUnused = () => {\r\n      for (let container of this.workspace.getPaneContainers()) {\r\n        for (let item of container.getPaneItems()) {\r\n          if (item instanceof TextEditor) {\r\n            if (item.getPath() || item.isModified()) return false\r\n          } else {\r\n            if (container === center) return false\r\n          }\r\n        }\r\n      }\r\n      return true\r\n    }\r\n\r\n    if (windowIsUnused()) {\r\n      await this.restoreStateIntoThisEnvironment(state)\r\n      return Promise.all(filesToOpen.map(file => this.workspace.open(file)))\r\n    } else {\r\n      let resolveDiscardStatePromise = null\r\n      const discardStatePromise = new Promise((resolve) => {\r\n        resolveDiscardStatePromise = resolve\r\n      })\r\n      const nouns = projectPaths.length === 1 ? 'folder' : 'folders'\r\n      this.confirm({\r\n        message: 'Previous automatically-saved project state detected',\r\n        detail: `There is previously saved state for the selected ${nouns}. ` +\r\n          `Would you like to add the ${nouns} to this window, permanently discarding the saved state, ` +\r\n          `or open the ${nouns} in a new window, restoring the saved state?`,\r\n        buttons: [\r\n          '&Open in new window and recover state',\r\n          '&Add to this window and discard state'\r\n        ]\r\n      }, response => {\r\n        if (response === 0) {\r\n          this.open({\r\n            pathsToOpen: projectPaths.concat(filesToOpen),\r\n            newWindow: true,\r\n            devMode: this.inDevMode(),\r\n            safeMode: this.inSafeMode()\r\n          })\r\n          resolveDiscardStatePromise(Promise.resolve(null))\r\n        } else if (response === 1) {\r\n          for (let selectedPath of projectPaths) {\r\n            this.project.addPath(selectedPath)\r\n          }\r\n          resolveDiscardStatePromise(Promise.all(filesToOpen.map(file => this.workspace.open(file))))\r\n        }\r\n      })\r\n\r\n      return discardStatePromise\r\n    }\r\n  }\r", "name": "restoreStateIntoThisEnvironment", "func_location": "AtomEnvironment.attemptRestoreProjectStateForPaths", "args": ["state"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 1145, "func_start_line": 1129}}, {"func_info": {"comment": [" Essential: A flexible way to open a dialog akin to an alert dialog.", "", " While both async and sync versions are provided, it is recommended to use the async version", " such that the renderer process is not blocked while the dialog box is open.", "", " The async version accepts the same options as Electron's `dialog.showMessageBox`.", " For convenience, it sets `type` to `'info'` and `normalizeAccessKeys` to `true` by default.", "", " If the dialog is closed (via `Esc` key or `X` in the top corner) without selecting a button", " the first button will be clicked unless a \"Cancel\" or \"No\" button is provided.", "", " ## Examples", "", " ```js", " // Async version (recommended)", " atom.confirm({", "   message: 'How you feeling?',", "   detail: 'Be honest.',", "   buttons: ['Good', 'Bad']", " }, response => {", "   if (response === 0) {", "     window.alert('good to hear')", "   } else {", "     window.alert('bummer')", "   }", " })", "", " ```js", " // Legacy sync version", " const chosen = atom.confirm({", "   message: 'How you feeling?',", "   detailedMessage: 'Be honest.',", "   buttons: {", "     Good: () => window.alert('good to hear'),", "     Bad: () => window.alert('bummer')", "   }", " })", " ```", "", " * `options` An options {Object}. If the callback argument is also supplied, see the documentation at", " https://electronjs.org/docs/api/dialog#dialogshowmessageboxbrowserwindow-options-callback for the list of", " available options. Otherwise, only the following keys are accepted:", "   * `message` The {String} message to display.", "   * `detailedMessage` (optional) The {String} detailed message to display.", "   * `buttons` (optional) Either an {Array} of {String}s or an {Object} where keys are", "     button names and the values are callback {Function}s to invoke when clicked.", " * `callback` (optional) A {Function} that will be called with the index of the chosen option.", "   If a callback is supplied, the dialog will be non-blocking. This argument is recommended.", "", " Returns the chosen button index {Number} if the buttons option is an array", " or the return value of the callback if the buttons option is an object.", " If a callback function is supplied, returns `undefined`."], "name": "AtomEnvironment.confirm", "params": ["options", "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1046, "start_line": 1039}, "call_info": {"func_end_line": 1181, "name": "confirm", "func_location": "AtomEnvironment.attemptRestoreProjectStateForPaths", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 1153, "func_start_line": 1129}}, {"func_info": {"comment": [], "name": "indexOfGroupContainingCommand", "params": ["groups", "command", "ignoreGroup"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js", "end_line": 45, "start_line": 37}, "call_info": {"func_end_line": 91, "code": "function attemptToMergeAGroup (groups) {\r\n  for (let i = 0; i < groups.length; i++) {\r\n    const group = groups[i]\r\n    for (const item of group) {\r\n      const toCommands = [...(item.before || []), ...(item.after || [])]\r\n      for (const command of toCommands) {\r\n        const index = indexOfGroupContainingCommand(groups, command, group)\r\n        if (index === -1) {\r\n          // No valid edge for this command\r\n          continue\r\n        }\r\n        const mergeTarget = groups[index]\r\n        // Merge with group containing `command`\r\n        mergeTarget.push(...group)\r\n        groups.splice(i, 1)\r\n        return true\r\n      }\r\n    }\r\n  }\r\n  return false\r\n}\r", "name": "indexOfGroupContainingCommand", "func_location": "attemptToMergeAGroup", "args": ["groups", "command", "group"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js", "line": 77, "func_start_line": 71}}, {"func_info": {"comment": [], "name": "TextEditorElement.getModel", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 82, "start_line": 80}, "call_info": {"func_end_line": 67, "code": "  attributeChangedCallback (name, oldValue, newValue) {\r\n    if (this.component) {\r\n      switch (name) {\r\n        case 'mini':\r\n          this.getModel().update({mini: newValue != null})\r\n          break\r\n        case 'placeholder-text':\r\n          this.getModel().update({placeholderText: newValue})\r\n          break\r\n        case 'gutter-hidden':\r\n          this.getModel().update({lineNumberGutterVisible: newValue == null})\r\n          break\r\n        case 'readonly':\r\n          this.getModel().update({readOnly: newValue != null})\r\n          break\r\n      }\r\n    }\r\n  }\r", "name": "getModel", "func_location": "TextEditorElement.attributeChangedCallback", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 54, "func_start_line": 50}}, {"func_info": {"comment": [], "name": "TextEditorElement.getModel", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 82, "start_line": 80}, "call_info": {"func_end_line": 67, "code": "  attributeChangedCallback (name, oldValue, newValue) {\r\n    if (this.component) {\r\n      switch (name) {\r\n        case 'mini':\r\n          this.getModel().update({mini: newValue != null})\r\n          break\r\n        case 'placeholder-text':\r\n          this.getModel().update({placeholderText: newValue})\r\n          break\r\n        case 'gutter-hidden':\r\n          this.getModel().update({lineNumberGutterVisible: newValue == null})\r\n          break\r\n        case 'readonly':\r\n          this.getModel().update({readOnly: newValue != null})\r\n          break\r\n      }\r\n    }\r\n  }\r", "name": "getModel", "func_location": "TextEditorElement.attributeChangedCallback", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 57, "func_start_line": 50}}, {"func_info": {"comment": [], "name": "TextEditorElement.getModel", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 82, "start_line": 80}, "call_info": {"func_end_line": 67, "code": "  attributeChangedCallback (name, oldValue, newValue) {\r\n    if (this.component) {\r\n      switch (name) {\r\n        case 'mini':\r\n          this.getModel().update({mini: newValue != null})\r\n          break\r\n        case 'placeholder-text':\r\n          this.getModel().update({placeholderText: newValue})\r\n          break\r\n        case 'gutter-hidden':\r\n          this.getModel().update({lineNumberGutterVisible: newValue == null})\r\n          break\r\n        case 'readonly':\r\n          this.getModel().update({readOnly: newValue != null})\r\n          break\r\n      }\r\n    }\r\n  }\r", "name": "getModel", "func_location": "TextEditorElement.attributeChangedCallback", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 60, "func_start_line": 50}}, {"func_info": {"comment": [], "name": "TextEditorElement.getModel", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 82, "start_line": 80}, "call_info": {"func_end_line": 67, "code": "  attributeChangedCallback (name, oldValue, newValue) {\r\n    if (this.component) {\r\n      switch (name) {\r\n        case 'mini':\r\n          this.getModel().update({mini: newValue != null})\r\n          break\r\n        case 'placeholder-text':\r\n          this.getModel().update({placeholderText: newValue})\r\n          break\r\n        case 'gutter-hidden':\r\n          this.getModel().update({lineNumberGutterVisible: newValue == null})\r\n          break\r\n        case 'readonly':\r\n          this.getModel().update({readOnly: newValue != null})\r\n          break\r\n      }\r\n    }\r\n  }\r", "name": "getModel", "func_location": "TextEditorElement.attributeChangedCallback", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 63, "func_start_line": 50}}, {"func_info": {"comment": [], "name": "GrammarRegistry.selectGrammarWithScore", "params": ["filePath", "fileContents"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 202, "start_line": 191}, "call_info": {"func_end_line": 168, "name": "selectGrammarWithScore", "func_location": "GrammarRegistry.autoAssignLanguageMode", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 159, "func_start_line": 158}}, {"func_info": {"comment": [], "name": "getGrammarSelectionContent", "params": ["buffer"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 592, "start_line": 587}, "call_info": {"func_end_line": 168, "comment": [" Extended: Remove any language mode override that has been set for the", " given {TextBuffer}. This will assign to the buffer the best language", " mode available.", "", " * `buffer` The {TextBuffer}."], "code": "  autoAssignLanguageMode (buffer) {\r\n    const result = this.selectGrammarWithScore(\r\n      buffer.getPath(),\r\n      getGrammarSelectionContent(buffer)\r\n    )\r\n    this.languageOverridesByBufferId.delete(buffer.id)\r\n    this.grammarScoresByBuffer.set(buffer, result.score)\r\n    if (result.grammar !== buffer.getLanguageMode().grammar) {\r\n      buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(result.grammar, buffer))\r\n    }\r\n  }\r", "name": "getGrammarSelectionContent", "func_location": "GrammarRegistry.autoAssignLanguageMode", "args": ["buffer"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 161, "func_start_line": 158}}, {"func_info": {"comment": [], "name": "GrammarRegistry.languageModeForGrammarAndBuffer", "params": ["grammar", "buffer"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 176, "start_line": 170}, "call_info": {"func_end_line": 168, "comment": [" Extended: Remove any language mode override that has been set for the", " given {TextBuffer}. This will assign to the buffer the best language", " mode available.", "", " * `buffer` The {TextBuffer}."], "code": "  autoAssignLanguageMode (buffer) {\r\n    const result = this.selectGrammarWithScore(\r\n      buffer.getPath(),\r\n      getGrammarSelectionContent(buffer)\r\n    )\r\n    this.languageOverridesByBufferId.delete(buffer.id)\r\n    this.grammarScoresByBuffer.set(buffer, result.score)\r\n    if (result.grammar !== buffer.getLanguageMode().grammar) {\r\n      buffer.setLanguageMode(this.languageModeForGrammarAndBuffer(result.grammar, buffer))\r\n    }\r\n  }\r", "name": "languageModeForGrammarAndBuffer", "func_location": "GrammarRegistry.autoAssignLanguageMode", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 166, "func_start_line": 158}}, {"func_info": {"comment": [], "name": "Cursor.getScreenRange", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 733, "start_line": 730}, "call_info": {"func_end_line": 738, "code": "  autoscroll (options = {}) {\r\n    options.clip = false\r\n    this.editor.scrollToScreenRange(this.getScreenRange(), options)\r\n  }\r", "name": "getScreenRange", "func_location": "Cursor.autoscroll", "args": [null, "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 737, "func_start_line": 735}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getHorizontalAutoscrollMargin", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2117, "start_line": 2108}, "call_info": {"func_end_line": 2095, "code": "  autoscrollHorizontally (screenRange, options) {\r\n    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin()\r\n\r\n    const gutterContainerWidth = this.getGutterContainerWidth()\r\n    let left = this.pixelLeftForRowAndColumn(screenRange.start.row, screenRange.start.column) + gutterContainerWidth\r\n    let right = this.pixelLeftForRowAndColumn(screenRange.end.row, screenRange.end.column) + gutterContainerWidth\r\n    const desiredScrollLeft = Math.max(0, left - horizontalScrollMargin - gutterContainerWidth)\r\n    const desiredScrollRight = Math.min(this.getScrollWidth(), right + horizontalScrollMargin)\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n    } else {\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n    }\r\n  }\r", "name": "getHorizontalAutoscrollMargin", "func_location": "TextEditorComponent.autoscrollHorizontally", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2072, "func_start_line": 2071}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getGutterContainerWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2698, "start_line": 2696}, "call_info": {"func_end_line": 2095, "code": "  autoscrollHorizontally (screenRange, options) {\r\n    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin()\r\n\r\n    const gutterContainerWidth = this.getGutterContainerWidth()\r\n    let left = this.pixelLeftForRowAndColumn(screenRange.start.row, screenRange.start.column) + gutterContainerWidth\r\n    let right = this.pixelLeftForRowAndColumn(screenRange.end.row, screenRange.end.column) + gutterContainerWidth\r\n    const desiredScrollLeft = Math.max(0, left - horizontalScrollMargin - gutterContainerWidth)\r\n    const desiredScrollRight = Math.min(this.getScrollWidth(), right + horizontalScrollMargin)\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n    } else {\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n    }\r\n  }\r", "name": "getGutterContainerWidth", "func_location": "TextEditorComponent.autoscrollHorizontally", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2074, "func_start_line": 2071}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelLeftForRowAndColumn", "params": ["row", "column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2377, "start_line": 2368}, "call_info": {"func_end_line": 2095, "code": "  autoscrollHorizontally (screenRange, options) {\r\n    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin()\r\n\r\n    const gutterContainerWidth = this.getGutterContainerWidth()\r\n    let left = this.pixelLeftForRowAndColumn(screenRange.start.row, screenRange.start.column) + gutterContainerWidth\r\n    let right = this.pixelLeftForRowAndColumn(screenRange.end.row, screenRange.end.column) + gutterContainerWidth\r\n    const desiredScrollLeft = Math.max(0, left - horizontalScrollMargin - gutterContainerWidth)\r\n    const desiredScrollRight = Math.min(this.getScrollWidth(), right + horizontalScrollMargin)\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n    } else {\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n    }\r\n  }\r", "name": "pixelLeftForRowAndColumn", "func_location": "TextEditorComponent.autoscrollHorizontally", "args": ["screenRange.start.row", "screenRange.start.column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2075, "func_start_line": 2071}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelLeftForRowAndColumn", "params": ["row", "column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2377, "start_line": 2368}, "call_info": {"func_end_line": 2095, "code": "  autoscrollHorizontally (screenRange, options) {\r\n    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin()\r\n\r\n    const gutterContainerWidth = this.getGutterContainerWidth()\r\n    let left = this.pixelLeftForRowAndColumn(screenRange.start.row, screenRange.start.column) + gutterContainerWidth\r\n    let right = this.pixelLeftForRowAndColumn(screenRange.end.row, screenRange.end.column) + gutterContainerWidth\r\n    const desiredScrollLeft = Math.max(0, left - horizontalScrollMargin - gutterContainerWidth)\r\n    const desiredScrollRight = Math.min(this.getScrollWidth(), right + horizontalScrollMargin)\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n    } else {\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n    }\r\n  }\r", "name": "pixelLeftForRowAndColumn", "func_location": "TextEditorComponent.autoscrollHorizontally", "args": ["screenRange.end.row", "screenRange.end.column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2076, "func_start_line": 2071}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2682, "start_line": 2672}, "call_info": {"func_end_line": 2095, "code": "  autoscrollHorizontally (screenRange, options) {\r\n    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin()\r\n\r\n    const gutterContainerWidth = this.getGutterContainerWidth()\r\n    let left = this.pixelLeftForRowAndColumn(screenRange.start.row, screenRange.start.column) + gutterContainerWidth\r\n    let right = this.pixelLeftForRowAndColumn(screenRange.end.row, screenRange.end.column) + gutterContainerWidth\r\n    const desiredScrollLeft = Math.max(0, left - horizontalScrollMargin - gutterContainerWidth)\r\n    const desiredScrollRight = Math.min(this.getScrollWidth(), right + horizontalScrollMargin)\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n    } else {\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n    }\r\n  }\r", "name": "getScrollWidth", "func_location": "TextEditorComponent.autoscrollHorizontally", "args": [null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2078, "func_start_line": 2071}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollRight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2847, "start_line": 2845}, "call_info": {"func_end_line": 2095, "code": "  autoscrollHorizontally (screenRange, options) {\r\n    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin()\r\n\r\n    const gutterContainerWidth = this.getGutterContainerWidth()\r\n    let left = this.pixelLeftForRowAndColumn(screenRange.start.row, screenRange.start.column) + gutterContainerWidth\r\n    let right = this.pixelLeftForRowAndColumn(screenRange.end.row, screenRange.end.column) + gutterContainerWidth\r\n    const desiredScrollLeft = Math.max(0, left - horizontalScrollMargin - gutterContainerWidth)\r\n    const desiredScrollRight = Math.min(this.getScrollWidth(), right + horizontalScrollMargin)\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n    } else {\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n    }\r\n  }\r", "name": "getScrollRight", "func_location": "TextEditorComponent.autoscrollHorizontally", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2081, "func_start_line": 2071}}, {"func_info": {"comment": [], "name": "TextEditorComponent.setScrollRight", "params": ["scrollRight"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2851, "start_line": 2849}, "call_info": {"func_end_line": 2095, "code": "  autoscrollHorizontally (screenRange, options) {\r\n    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin()\r\n\r\n    const gutterContainerWidth = this.getGutterContainerWidth()\r\n    let left = this.pixelLeftForRowAndColumn(screenRange.start.row, screenRange.start.column) + gutterContainerWidth\r\n    let right = this.pixelLeftForRowAndColumn(screenRange.end.row, screenRange.end.column) + gutterContainerWidth\r\n    const desiredScrollLeft = Math.max(0, left - horizontalScrollMargin - gutterContainerWidth)\r\n    const desiredScrollRight = Math.min(this.getScrollWidth(), right + horizontalScrollMargin)\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n    } else {\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n    }\r\n  }\r", "name": "setScrollRight", "func_location": "TextEditorComponent.autoscrollHorizontally", "args": ["desiredScrollRight"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2082, "func_start_line": 2071}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollLeft", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2825, "start_line": 2823}, "call_info": {"func_end_line": 2095, "code": "  autoscrollHorizontally (screenRange, options) {\r\n    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin()\r\n\r\n    const gutterContainerWidth = this.getGutterContainerWidth()\r\n    let left = this.pixelLeftForRowAndColumn(screenRange.start.row, screenRange.start.column) + gutterContainerWidth\r\n    let right = this.pixelLeftForRowAndColumn(screenRange.end.row, screenRange.end.column) + gutterContainerWidth\r\n    const desiredScrollLeft = Math.max(0, left - horizontalScrollMargin - gutterContainerWidth)\r\n    const desiredScrollRight = Math.min(this.getScrollWidth(), right + horizontalScrollMargin)\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n    } else {\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n    }\r\n  }\r", "name": "getScrollLeft", "func_location": "TextEditorComponent.autoscrollHorizontally", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2084, "func_start_line": 2071}}, {"func_info": {"comment": [], "name": "TextEditorComponent.setScrollLeft", "params": ["scrollLeft"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2839, "start_line": 2827}, "call_info": {"func_end_line": 2095, "code": "  autoscrollHorizontally (screenRange, options) {\r\n    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin()\r\n\r\n    const gutterContainerWidth = this.getGutterContainerWidth()\r\n    let left = this.pixelLeftForRowAndColumn(screenRange.start.row, screenRange.start.column) + gutterContainerWidth\r\n    let right = this.pixelLeftForRowAndColumn(screenRange.end.row, screenRange.end.column) + gutterContainerWidth\r\n    const desiredScrollLeft = Math.max(0, left - horizontalScrollMargin - gutterContainerWidth)\r\n    const desiredScrollRight = Math.min(this.getScrollWidth(), right + horizontalScrollMargin)\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n    } else {\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n    }\r\n  }\r", "name": "setScrollLeft", "func_location": "TextEditorComponent.autoscrollHorizontally", "args": ["desiredScrollLeft"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2085, "func_start_line": 2071}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollLeft", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2825, "start_line": 2823}, "call_info": {"func_end_line": 2095, "code": "  autoscrollHorizontally (screenRange, options) {\r\n    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin()\r\n\r\n    const gutterContainerWidth = this.getGutterContainerWidth()\r\n    let left = this.pixelLeftForRowAndColumn(screenRange.start.row, screenRange.start.column) + gutterContainerWidth\r\n    let right = this.pixelLeftForRowAndColumn(screenRange.end.row, screenRange.end.column) + gutterContainerWidth\r\n    const desiredScrollLeft = Math.max(0, left - horizontalScrollMargin - gutterContainerWidth)\r\n    const desiredScrollRight = Math.min(this.getScrollWidth(), right + horizontalScrollMargin)\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n    } else {\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n    }\r\n  }\r", "name": "getScrollLeft", "func_location": "TextEditorComponent.autoscrollHorizontally", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2088, "func_start_line": 2071}}, {"func_info": {"comment": [], "name": "TextEditorComponent.setScrollLeft", "params": ["scrollLeft"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2839, "start_line": 2827}, "call_info": {"func_end_line": 2095, "code": "  autoscrollHorizontally (screenRange, options) {\r\n    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin()\r\n\r\n    const gutterContainerWidth = this.getGutterContainerWidth()\r\n    let left = this.pixelLeftForRowAndColumn(screenRange.start.row, screenRange.start.column) + gutterContainerWidth\r\n    let right = this.pixelLeftForRowAndColumn(screenRange.end.row, screenRange.end.column) + gutterContainerWidth\r\n    const desiredScrollLeft = Math.max(0, left - horizontalScrollMargin - gutterContainerWidth)\r\n    const desiredScrollRight = Math.min(this.getScrollWidth(), right + horizontalScrollMargin)\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n    } else {\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n    }\r\n  }\r", "name": "setScrollLeft", "func_location": "TextEditorComponent.autoscrollHorizontally", "args": ["desiredScrollLeft"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2089, "func_start_line": 2071}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollRight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2847, "start_line": 2845}, "call_info": {"func_end_line": 2095, "code": "  autoscrollHorizontally (screenRange, options) {\r\n    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin()\r\n\r\n    const gutterContainerWidth = this.getGutterContainerWidth()\r\n    let left = this.pixelLeftForRowAndColumn(screenRange.start.row, screenRange.start.column) + gutterContainerWidth\r\n    let right = this.pixelLeftForRowAndColumn(screenRange.end.row, screenRange.end.column) + gutterContainerWidth\r\n    const desiredScrollLeft = Math.max(0, left - horizontalScrollMargin - gutterContainerWidth)\r\n    const desiredScrollRight = Math.min(this.getScrollWidth(), right + horizontalScrollMargin)\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n    } else {\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n    }\r\n  }\r", "name": "getScrollRight", "func_location": "TextEditorComponent.autoscrollHorizontally", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2091, "func_start_line": 2071}}, {"func_info": {"comment": [], "name": "TextEditorComponent.setScrollRight", "params": ["scrollRight"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2851, "start_line": 2849}, "call_info": {"func_end_line": 2095, "code": "  autoscrollHorizontally (screenRange, options) {\r\n    const horizontalScrollMargin = this.getHorizontalAutoscrollMargin()\r\n\r\n    const gutterContainerWidth = this.getGutterContainerWidth()\r\n    let left = this.pixelLeftForRowAndColumn(screenRange.start.row, screenRange.start.column) + gutterContainerWidth\r\n    let right = this.pixelLeftForRowAndColumn(screenRange.end.row, screenRange.end.column) + gutterContainerWidth\r\n    const desiredScrollLeft = Math.max(0, left - horizontalScrollMargin - gutterContainerWidth)\r\n    const desiredScrollRight = Math.min(this.getScrollWidth(), right + horizontalScrollMargin)\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n    } else {\r\n      if (desiredScrollLeft < this.getScrollLeft()) {\r\n        this.setScrollLeft(desiredScrollLeft)\r\n      }\r\n      if (desiredScrollRight > this.getScrollRight()) {\r\n        this.setScrollRight(desiredScrollRight)\r\n      }\r\n    }\r\n  }\r", "name": "setScrollRight", "func_location": "TextEditorComponent.autoscrollHorizontally", "args": ["desiredScrollRight"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2092, "func_start_line": 2071}}, {"func_info": {"comment": [], "name": "scaleMouseDragAutoscrollDelta", "params": ["delta"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 27, "start_line": 25}, "call_info": {"func_end_line": 1959, "code": "  autoscrollOnMouseDrag ({clientX, clientY}, verticalOnly = false) {\r\n    var {top, bottom, left, right} = this.refs.scrollContainer.getBoundingClientRect() // Using var to avoid deopt on += assignments below\r\n    top += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    bottom -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    left += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    right -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n\r\n    let yDelta, yDirection\r\n    if (clientY < top) {\r\n      yDelta = top - clientY\r\n      yDirection = -1\r\n    } else if (clientY > bottom) {\r\n      yDelta = clientY - bottom\r\n      yDirection = 1\r\n    }\r\n\r\n    let xDelta, xDirection\r\n    if (clientX < left) {\r\n      xDelta = left - clientX\r\n      xDirection = -1\r\n    } else if (clientX > right) {\r\n      xDelta = clientX - right\r\n      xDirection = 1\r\n    }\r\n\r\n    let scrolled = false\r\n    if (yDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(yDelta) * yDirection\r\n      scrolled = this.setScrollTop(this.getScrollTop() + scaledDelta)\r\n    }\r\n\r\n    if (!verticalOnly && xDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(xDelta) * xDirection\r\n      scrolled = this.setScrollLeft(this.getScrollLeft() + scaledDelta)\r\n    }\r\n\r\n    if (scrolled) this.updateSync()\r\n  }\r", "name": "scaleMouseDragAutoscrollDelta", "func_location": "TextEditorComponent.autoscrollOnMouseDrag", "args": ["yDelta"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1949, "func_start_line": 1922}}, {"func_info": {"comment": [], "name": "TextEditorComponent.setScrollTop", "params": ["scrollTop"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2809, "start_line": 2796}, "call_info": {"func_end_line": 1959, "code": "  autoscrollOnMouseDrag ({clientX, clientY}, verticalOnly = false) {\r\n    var {top, bottom, left, right} = this.refs.scrollContainer.getBoundingClientRect() // Using var to avoid deopt on += assignments below\r\n    top += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    bottom -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    left += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    right -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n\r\n    let yDelta, yDirection\r\n    if (clientY < top) {\r\n      yDelta = top - clientY\r\n      yDirection = -1\r\n    } else if (clientY > bottom) {\r\n      yDelta = clientY - bottom\r\n      yDirection = 1\r\n    }\r\n\r\n    let xDelta, xDirection\r\n    if (clientX < left) {\r\n      xDelta = left - clientX\r\n      xDirection = -1\r\n    } else if (clientX > right) {\r\n      xDelta = clientX - right\r\n      xDirection = 1\r\n    }\r\n\r\n    let scrolled = false\r\n    if (yDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(yDelta) * yDirection\r\n      scrolled = this.setScrollTop(this.getScrollTop() + scaledDelta)\r\n    }\r\n\r\n    if (!verticalOnly && xDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(xDelta) * xDirection\r\n      scrolled = this.setScrollLeft(this.getScrollLeft() + scaledDelta)\r\n    }\r\n\r\n    if (scrolled) this.updateSync()\r\n  }\r", "name": "setScrollTop", "func_location": "TextEditorComponent.autoscrollOnMouseDrag", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1950, "func_start_line": 1922}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollTop", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2794, "start_line": 2791}, "call_info": {"func_end_line": 1959, "code": "  autoscrollOnMouseDrag ({clientX, clientY}, verticalOnly = false) {\r\n    var {top, bottom, left, right} = this.refs.scrollContainer.getBoundingClientRect() // Using var to avoid deopt on += assignments below\r\n    top += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    bottom -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    left += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    right -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n\r\n    let yDelta, yDirection\r\n    if (clientY < top) {\r\n      yDelta = top - clientY\r\n      yDirection = -1\r\n    } else if (clientY > bottom) {\r\n      yDelta = clientY - bottom\r\n      yDirection = 1\r\n    }\r\n\r\n    let xDelta, xDirection\r\n    if (clientX < left) {\r\n      xDelta = left - clientX\r\n      xDirection = -1\r\n    } else if (clientX > right) {\r\n      xDelta = clientX - right\r\n      xDirection = 1\r\n    }\r\n\r\n    let scrolled = false\r\n    if (yDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(yDelta) * yDirection\r\n      scrolled = this.setScrollTop(this.getScrollTop() + scaledDelta)\r\n    }\r\n\r\n    if (!verticalOnly && xDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(xDelta) * xDirection\r\n      scrolled = this.setScrollLeft(this.getScrollLeft() + scaledDelta)\r\n    }\r\n\r\n    if (scrolled) this.updateSync()\r\n  }\r", "name": "getScrollTop", "func_location": "TextEditorComponent.autoscrollOnMouseDrag", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1950, "func_start_line": 1922}}, {"func_info": {"comment": [], "name": "scaleMouseDragAutoscrollDelta", "params": ["delta"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 27, "start_line": 25}, "call_info": {"func_end_line": 1959, "code": "  autoscrollOnMouseDrag ({clientX, clientY}, verticalOnly = false) {\r\n    var {top, bottom, left, right} = this.refs.scrollContainer.getBoundingClientRect() // Using var to avoid deopt on += assignments below\r\n    top += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    bottom -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    left += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    right -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n\r\n    let yDelta, yDirection\r\n    if (clientY < top) {\r\n      yDelta = top - clientY\r\n      yDirection = -1\r\n    } else if (clientY > bottom) {\r\n      yDelta = clientY - bottom\r\n      yDirection = 1\r\n    }\r\n\r\n    let xDelta, xDirection\r\n    if (clientX < left) {\r\n      xDelta = left - clientX\r\n      xDirection = -1\r\n    } else if (clientX > right) {\r\n      xDelta = clientX - right\r\n      xDirection = 1\r\n    }\r\n\r\n    let scrolled = false\r\n    if (yDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(yDelta) * yDirection\r\n      scrolled = this.setScrollTop(this.getScrollTop() + scaledDelta)\r\n    }\r\n\r\n    if (!verticalOnly && xDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(xDelta) * xDirection\r\n      scrolled = this.setScrollLeft(this.getScrollLeft() + scaledDelta)\r\n    }\r\n\r\n    if (scrolled) this.updateSync()\r\n  }\r", "name": "scaleMouseDragAutoscrollDelta", "func_location": "TextEditorComponent.autoscrollOnMouseDrag", "args": ["xDelta"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1954, "func_start_line": 1922}}, {"func_info": {"comment": [], "name": "TextEditorComponent.setScrollLeft", "params": ["scrollLeft"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2839, "start_line": 2827}, "call_info": {"func_end_line": 1959, "code": "  autoscrollOnMouseDrag ({clientX, clientY}, verticalOnly = false) {\r\n    var {top, bottom, left, right} = this.refs.scrollContainer.getBoundingClientRect() // Using var to avoid deopt on += assignments below\r\n    top += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    bottom -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    left += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    right -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n\r\n    let yDelta, yDirection\r\n    if (clientY < top) {\r\n      yDelta = top - clientY\r\n      yDirection = -1\r\n    } else if (clientY > bottom) {\r\n      yDelta = clientY - bottom\r\n      yDirection = 1\r\n    }\r\n\r\n    let xDelta, xDirection\r\n    if (clientX < left) {\r\n      xDelta = left - clientX\r\n      xDirection = -1\r\n    } else if (clientX > right) {\r\n      xDelta = clientX - right\r\n      xDirection = 1\r\n    }\r\n\r\n    let scrolled = false\r\n    if (yDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(yDelta) * yDirection\r\n      scrolled = this.setScrollTop(this.getScrollTop() + scaledDelta)\r\n    }\r\n\r\n    if (!verticalOnly && xDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(xDelta) * xDirection\r\n      scrolled = this.setScrollLeft(this.getScrollLeft() + scaledDelta)\r\n    }\r\n\r\n    if (scrolled) this.updateSync()\r\n  }\r", "name": "setScrollLeft", "func_location": "TextEditorComponent.autoscrollOnMouseDrag", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1955, "func_start_line": 1922}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollLeft", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2825, "start_line": 2823}, "call_info": {"func_end_line": 1959, "code": "  autoscrollOnMouseDrag ({clientX, clientY}, verticalOnly = false) {\r\n    var {top, bottom, left, right} = this.refs.scrollContainer.getBoundingClientRect() // Using var to avoid deopt on += assignments below\r\n    top += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    bottom -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    left += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    right -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n\r\n    let yDelta, yDirection\r\n    if (clientY < top) {\r\n      yDelta = top - clientY\r\n      yDirection = -1\r\n    } else if (clientY > bottom) {\r\n      yDelta = clientY - bottom\r\n      yDirection = 1\r\n    }\r\n\r\n    let xDelta, xDirection\r\n    if (clientX < left) {\r\n      xDelta = left - clientX\r\n      xDirection = -1\r\n    } else if (clientX > right) {\r\n      xDelta = clientX - right\r\n      xDirection = 1\r\n    }\r\n\r\n    let scrolled = false\r\n    if (yDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(yDelta) * yDirection\r\n      scrolled = this.setScrollTop(this.getScrollTop() + scaledDelta)\r\n    }\r\n\r\n    if (!verticalOnly && xDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(xDelta) * xDirection\r\n      scrolled = this.setScrollLeft(this.getScrollLeft() + scaledDelta)\r\n    }\r\n\r\n    if (scrolled) this.updateSync()\r\n  }\r", "name": "getScrollLeft", "func_location": "TextEditorComponent.autoscrollOnMouseDrag", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1955, "func_start_line": 1922}}, {"func_info": {"comment": [], "name": "TextEditorComponent.updateSync", "params": ["useScheduler"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 289, "start_line": 221}, "call_info": {"func_end_line": 1959, "code": "  autoscrollOnMouseDrag ({clientX, clientY}, verticalOnly = false) {\r\n    var {top, bottom, left, right} = this.refs.scrollContainer.getBoundingClientRect() // Using var to avoid deopt on += assignments below\r\n    top += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    bottom -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    left += MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n    right -= MOUSE_DRAG_AUTOSCROLL_MARGIN\r\n\r\n    let yDelta, yDirection\r\n    if (clientY < top) {\r\n      yDelta = top - clientY\r\n      yDirection = -1\r\n    } else if (clientY > bottom) {\r\n      yDelta = clientY - bottom\r\n      yDirection = 1\r\n    }\r\n\r\n    let xDelta, xDirection\r\n    if (clientX < left) {\r\n      xDelta = left - clientX\r\n      xDirection = -1\r\n    } else if (clientX > right) {\r\n      xDelta = clientX - right\r\n      xDirection = 1\r\n    }\r\n\r\n    let scrolled = false\r\n    if (yDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(yDelta) * yDirection\r\n      scrolled = this.setScrollTop(this.getScrollTop() + scaledDelta)\r\n    }\r\n\r\n    if (!verticalOnly && xDelta != null) {\r\n      const scaledDelta = scaleMouseDragAutoscrollDelta(xDelta) * xDirection\r\n      scrolled = this.setScrollLeft(this.getScrollLeft() + scaledDelta)\r\n    }\r\n\r\n    if (scrolled) this.updateSync()\r\n  }\r", "name": "updateSync", "func_location": "TextEditorComponent.autoscrollOnMouseDrag", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1958, "func_start_line": 1922}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelPositionAfterBlocksForRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2366, "start_line": 2364}, "call_info": {"func_end_line": 2069, "code": "  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r", "name": "pixelPositionAfterBlocksForRow", "func_location": "TextEditorComponent.autoscrollVertically", "args": ["screenRange.start.row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2036, "func_start_line": 2035}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelPositionAfterBlocksForRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2366, "start_line": 2364}, "call_info": {"func_end_line": 2069, "code": "  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r", "name": "pixelPositionAfterBlocksForRow", "func_location": "TextEditorComponent.autoscrollVertically", "args": ["screenRange.end.row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2037, "func_start_line": 2035}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getLineHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2602, "start_line": 2600}, "call_info": {"func_end_line": 2069, "code": "  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r", "name": "getLineHeight", "func_location": "TextEditorComponent.autoscrollVertically", "args": ["screenRange.end.row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2037, "func_start_line": 2035}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getVerticalAutoscrollMargin", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2106, "start_line": 2097}, "call_info": {"func_end_line": 2069, "code": "  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r", "name": "getVerticalAutoscrollMargin", "func_location": "TextEditorComponent.autoscrollVertically", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2038, "func_start_line": 2035}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollTop", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2794, "start_line": 2791}, "call_info": {"func_end_line": 2069, "code": "  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r", "name": "getScrollTop", "func_location": "TextEditorComponent.autoscrollVertically", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2043, "func_start_line": 2035}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollBottom", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2817, "start_line": 2815}, "call_info": {"func_end_line": 2069, "code": "  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r", "name": "getScrollBottom", "func_location": "TextEditorComponent.autoscrollVertically", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2043, "func_start_line": 2035}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollContainerClientHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2642, "start_line": 2640}, "call_info": {"func_end_line": 2069, "code": "  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r", "name": "getScrollContainerClientHeight", "func_location": "TextEditorComponent.autoscrollVertically", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2044, "func_start_line": 2035}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollContainerClientHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2642, "start_line": 2640}, "call_info": {"func_end_line": 2069, "code": "  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r", "name": "getScrollContainerClientHeight", "func_location": "TextEditorComponent.autoscrollVertically", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2045, "func_start_line": 2035}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollBottom", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2817, "start_line": 2815}, "call_info": {"func_end_line": 2069, "code": "  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r", "name": "getScrollBottom", "func_location": "TextEditorComponent.autoscrollVertically", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2053, "func_start_line": 2035}}, {"func_info": {"comment": [], "name": "TextEditorComponent.setScrollBottom", "params": ["scrollBottom"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2821, "start_line": 2819}, "call_info": {"func_end_line": 2069, "code": "  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r", "name": "setScrollBottom", "func_location": "TextEditorComponent.autoscrollVertically", "args": ["desiredScrollBottom"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2054, "func_start_line": 2035}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollTop", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2794, "start_line": 2791}, "call_info": {"func_end_line": 2069, "code": "  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r", "name": "getScrollTop", "func_location": "TextEditorComponent.autoscrollVertically", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2056, "func_start_line": 2035}}, {"func_info": {"comment": [], "name": "TextEditorComponent.setScrollTop", "params": ["scrollTop"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2809, "start_line": 2796}, "call_info": {"func_end_line": 2069, "code": "  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r", "name": "setScrollTop", "func_location": "TextEditorComponent.autoscrollVertically", "args": ["desiredScrollTop"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2057, "func_start_line": 2035}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollTop", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2794, "start_line": 2791}, "call_info": {"func_end_line": 2069, "code": "  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r", "name": "getScrollTop", "func_location": "TextEditorComponent.autoscrollVertically", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2060, "func_start_line": 2035}}, {"func_info": {"comment": [], "name": "TextEditorComponent.setScrollTop", "params": ["scrollTop"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2809, "start_line": 2796}, "call_info": {"func_end_line": 2069, "code": "  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r", "name": "setScrollTop", "func_location": "TextEditorComponent.autoscrollVertically", "args": ["desiredScrollTop"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2061, "func_start_line": 2035}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollBottom", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2817, "start_line": 2815}, "call_info": {"func_end_line": 2069, "code": "  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r", "name": "getScrollBottom", "func_location": "TextEditorComponent.autoscrollVertically", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2063, "func_start_line": 2035}}, {"func_info": {"comment": [], "name": "TextEditorComponent.setScrollBottom", "params": ["scrollBottom"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2821, "start_line": 2819}, "call_info": {"func_end_line": 2069, "code": "  autoscrollVertically (screenRange, options) {\r\n    const screenRangeTop = this.pixelPositionAfterBlocksForRow(screenRange.start.row)\r\n    const screenRangeBottom = this.pixelPositionAfterBlocksForRow(screenRange.end.row) + this.getLineHeight()\r\n    const verticalScrollMargin = this.getVerticalAutoscrollMargin()\r\n\r\n    let desiredScrollTop, desiredScrollBottom\r\n    if (options && options.center) {\r\n      const desiredScrollCenter = (screenRangeTop + screenRangeBottom) / 2\r\n      if (desiredScrollCenter < this.getScrollTop() || desiredScrollCenter > this.getScrollBottom()) {\r\n        desiredScrollTop = desiredScrollCenter - this.getScrollContainerClientHeight() / 2\r\n        desiredScrollBottom = desiredScrollCenter + this.getScrollContainerClientHeight() / 2\r\n      }\r\n    } else {\r\n      desiredScrollTop = screenRangeTop - verticalScrollMargin\r\n      desiredScrollBottom = screenRangeBottom + verticalScrollMargin\r\n    }\r\n\r\n    if (!options || options.reversed !== false) {\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n    } else {\r\n      if (desiredScrollTop < this.getScrollTop()) {\r\n        this.setScrollTop(desiredScrollTop)\r\n      }\r\n      if (desiredScrollBottom > this.getScrollBottom()) {\r\n        this.setScrollBottom(desiredScrollBottom)\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r", "name": "setScrollBottom", "func_location": "TextEditorComponent.autoscrollVertically", "args": ["desiredScrollBottom"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2064, "func_start_line": 2035}}, {"func_info": {"comment": [" Private: Ensure that the {TextEditor} is not marked read-only before allowing a buffer modification to occur. if", " the editor is read-only, require an explicit opt-in option to proceed (`bypassReadOnly`) or throw an Error."], "name": "Selection.ensureWritable", "params": ["methodName", "opts"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 427, "start_line": 412}, "call_info": {"func_end_line": 524, "comment": [" Public: Removes the first character before the selection if the selection", " is empty otherwise it deletes the selection.", "", " * `options` (optional) {Object}", "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"], "code": "  backspace (options = {}) {\r\n    if (!this.ensureWritable('backspace', options)) return\r\n    if (this.isEmpty()) this.selectLeft()\r\n    this.deleteSelectedText(options)\r\n  }\r", "name": "ensureWritable", "func_location": "Selection.backspace", "args": [{"type": "string"}, "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 521, "func_start_line": 520}}, {"func_info": {"comment": ["\r\n  Section: Info about the selection\r\n  ", " Public: Determines if the selection contains anything."], "name": "Selection.isEmpty", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 141, "start_line": 139}, "call_info": {"func_end_line": 524, "comment": [" Public: Removes the first character before the selection if the selection", " is empty otherwise it deletes the selection.", "", " * `options` (optional) {Object}", "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"], "code": "  backspace (options = {}) {\r\n    if (!this.ensureWritable('backspace', options)) return\r\n    if (this.isEmpty()) this.selectLeft()\r\n    this.deleteSelectedText(options)\r\n  }\r", "name": "isEmpty", "func_location": "Selection.backspace", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 522, "func_start_line": 520}}, {"func_info": {"comment": [" Public: Selects the text one position left of the cursor.", "", " * `columnCount` (optional) {Number} number of columns to select (default: 1)"], "name": "Selection.selectLeft", "params": ["columnCount"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 253, "start_line": 251}, "call_info": {"func_end_line": 524, "comment": [" Public: Removes the first character before the selection if the selection", " is empty otherwise it deletes the selection.", "", " * `options` (optional) {Object}", "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"], "code": "  backspace (options = {}) {\r\n    if (!this.ensureWritable('backspace', options)) return\r\n    if (this.isEmpty()) this.selectLeft()\r\n    this.deleteSelectedText(options)\r\n  }\r", "name": "selectLeft", "func_location": "Selection.backspace", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 522, "func_start_line": 520}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.updateInvalidRows", "params": ["start", "end", "delta"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 352, "start_line": 342}, "call_info": {"func_end_line": 376, "code": "  bufferDidChange (e) {\r\n    this.changeCount = this.buffer.changeCount\r\n\r\n    const {oldRange, newRange} = e\r\n    const start = oldRange.start.row\r\n    const end = oldRange.end.row\r\n    const delta = newRange.end.row - oldRange.end.row\r\n    const oldLineCount = (oldRange.end.row - oldRange.start.row) + 1\r\n    const newLineCount = (newRange.end.row - newRange.start.row) + 1\r\n\r\n    this.updateInvalidRows(start, end, delta)\r\n    const previousEndStack = this.stackForRow(end) // used in spill detection below\r\n    if (this.largeFileMode || (this.grammar.name === 'Null Grammar')) {\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, new Array(newLineCount))\r\n    } else {\r\n      const newTokenizedLines = this.buildTokenizedLinesForRows(start, end + delta, this.stackForRow(start - 1), this.openScopesForRow(start))\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, newTokenizedLines)\r\n      const newEndStack = this.stackForRow(end + delta)\r\n      if (newEndStack && !_.isEqual(newEndStack, previousEndStack)) {\r\n        this.invalidateRow(end + delta + 1)\r\n      }\r\n    }\r\n  }\r", "name": "updateInvalidRows", "func_location": "TextMateLanguageMode.bufferDidChange", "args": ["start", "end", "delta"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 364, "func_start_line": 354}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.stackForRow", "params": ["bufferRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 461, "start_line": 459}, "call_info": {"func_end_line": 376, "code": "  bufferDidChange (e) {\r\n    this.changeCount = this.buffer.changeCount\r\n\r\n    const {oldRange, newRange} = e\r\n    const start = oldRange.start.row\r\n    const end = oldRange.end.row\r\n    const delta = newRange.end.row - oldRange.end.row\r\n    const oldLineCount = (oldRange.end.row - oldRange.start.row) + 1\r\n    const newLineCount = (newRange.end.row - newRange.start.row) + 1\r\n\r\n    this.updateInvalidRows(start, end, delta)\r\n    const previousEndStack = this.stackForRow(end) // used in spill detection below\r\n    if (this.largeFileMode || (this.grammar.name === 'Null Grammar')) {\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, new Array(newLineCount))\r\n    } else {\r\n      const newTokenizedLines = this.buildTokenizedLinesForRows(start, end + delta, this.stackForRow(start - 1), this.openScopesForRow(start))\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, newTokenizedLines)\r\n      const newEndStack = this.stackForRow(end + delta)\r\n      if (newEndStack && !_.isEqual(newEndStack, previousEndStack)) {\r\n        this.invalidateRow(end + delta + 1)\r\n      }\r\n    }\r\n  }\r", "name": "stackForRow", "func_location": "TextMateLanguageMode.bufferDidChange", "args": ["end"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 365, "func_start_line": 354}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.buildTokenizedLinesForRows", "params": ["startRow", "endRow", "startingStack", "startingopenScopes"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 405, "start_line": 384}, "call_info": {"func_end_line": 376, "code": "  bufferDidChange (e) {\r\n    this.changeCount = this.buffer.changeCount\r\n\r\n    const {oldRange, newRange} = e\r\n    const start = oldRange.start.row\r\n    const end = oldRange.end.row\r\n    const delta = newRange.end.row - oldRange.end.row\r\n    const oldLineCount = (oldRange.end.row - oldRange.start.row) + 1\r\n    const newLineCount = (newRange.end.row - newRange.start.row) + 1\r\n\r\n    this.updateInvalidRows(start, end, delta)\r\n    const previousEndStack = this.stackForRow(end) // used in spill detection below\r\n    if (this.largeFileMode || (this.grammar.name === 'Null Grammar')) {\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, new Array(newLineCount))\r\n    } else {\r\n      const newTokenizedLines = this.buildTokenizedLinesForRows(start, end + delta, this.stackForRow(start - 1), this.openScopesForRow(start))\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, newTokenizedLines)\r\n      const newEndStack = this.stackForRow(end + delta)\r\n      if (newEndStack && !_.isEqual(newEndStack, previousEndStack)) {\r\n        this.invalidateRow(end + delta + 1)\r\n      }\r\n    }\r\n  }\r", "name": "buildTokenizedLinesForRows", "func_location": "TextMateLanguageMode.bufferDidChange", "args": ["start", null, null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 369, "func_start_line": 354}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.stackForRow", "params": ["bufferRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 461, "start_line": 459}, "call_info": {"func_end_line": 376, "code": "  bufferDidChange (e) {\r\n    this.changeCount = this.buffer.changeCount\r\n\r\n    const {oldRange, newRange} = e\r\n    const start = oldRange.start.row\r\n    const end = oldRange.end.row\r\n    const delta = newRange.end.row - oldRange.end.row\r\n    const oldLineCount = (oldRange.end.row - oldRange.start.row) + 1\r\n    const newLineCount = (newRange.end.row - newRange.start.row) + 1\r\n\r\n    this.updateInvalidRows(start, end, delta)\r\n    const previousEndStack = this.stackForRow(end) // used in spill detection below\r\n    if (this.largeFileMode || (this.grammar.name === 'Null Grammar')) {\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, new Array(newLineCount))\r\n    } else {\r\n      const newTokenizedLines = this.buildTokenizedLinesForRows(start, end + delta, this.stackForRow(start - 1), this.openScopesForRow(start))\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, newTokenizedLines)\r\n      const newEndStack = this.stackForRow(end + delta)\r\n      if (newEndStack && !_.isEqual(newEndStack, previousEndStack)) {\r\n        this.invalidateRow(end + delta + 1)\r\n      }\r\n    }\r\n  }\r", "name": "stackForRow", "func_location": "TextMateLanguageMode.bufferDidChange", "args": ["start", null, null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 369, "func_start_line": 354}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.openScopesForRow", "params": ["bufferRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 470, "start_line": 463}, "call_info": {"func_end_line": 376, "code": "  bufferDidChange (e) {\r\n    this.changeCount = this.buffer.changeCount\r\n\r\n    const {oldRange, newRange} = e\r\n    const start = oldRange.start.row\r\n    const end = oldRange.end.row\r\n    const delta = newRange.end.row - oldRange.end.row\r\n    const oldLineCount = (oldRange.end.row - oldRange.start.row) + 1\r\n    const newLineCount = (newRange.end.row - newRange.start.row) + 1\r\n\r\n    this.updateInvalidRows(start, end, delta)\r\n    const previousEndStack = this.stackForRow(end) // used in spill detection below\r\n    if (this.largeFileMode || (this.grammar.name === 'Null Grammar')) {\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, new Array(newLineCount))\r\n    } else {\r\n      const newTokenizedLines = this.buildTokenizedLinesForRows(start, end + delta, this.stackForRow(start - 1), this.openScopesForRow(start))\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, newTokenizedLines)\r\n      const newEndStack = this.stackForRow(end + delta)\r\n      if (newEndStack && !_.isEqual(newEndStack, previousEndStack)) {\r\n        this.invalidateRow(end + delta + 1)\r\n      }\r\n    }\r\n  }\r", "name": "openScopesForRow", "func_location": "TextMateLanguageMode.bufferDidChange", "args": ["start", null, null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 369, "func_start_line": 354}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.stackForRow", "params": ["bufferRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 461, "start_line": 459}, "call_info": {"func_end_line": 376, "code": "  bufferDidChange (e) {\r\n    this.changeCount = this.buffer.changeCount\r\n\r\n    const {oldRange, newRange} = e\r\n    const start = oldRange.start.row\r\n    const end = oldRange.end.row\r\n    const delta = newRange.end.row - oldRange.end.row\r\n    const oldLineCount = (oldRange.end.row - oldRange.start.row) + 1\r\n    const newLineCount = (newRange.end.row - newRange.start.row) + 1\r\n\r\n    this.updateInvalidRows(start, end, delta)\r\n    const previousEndStack = this.stackForRow(end) // used in spill detection below\r\n    if (this.largeFileMode || (this.grammar.name === 'Null Grammar')) {\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, new Array(newLineCount))\r\n    } else {\r\n      const newTokenizedLines = this.buildTokenizedLinesForRows(start, end + delta, this.stackForRow(start - 1), this.openScopesForRow(start))\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, newTokenizedLines)\r\n      const newEndStack = this.stackForRow(end + delta)\r\n      if (newEndStack && !_.isEqual(newEndStack, previousEndStack)) {\r\n        this.invalidateRow(end + delta + 1)\r\n      }\r\n    }\r\n  }\r", "name": "stackForRow", "func_location": "TextMateLanguageMode.bufferDidChange", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 371, "func_start_line": 354}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.invalidateRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 340, "start_line": 336}, "call_info": {"func_end_line": 376, "code": "  bufferDidChange (e) {\r\n    this.changeCount = this.buffer.changeCount\r\n\r\n    const {oldRange, newRange} = e\r\n    const start = oldRange.start.row\r\n    const end = oldRange.end.row\r\n    const delta = newRange.end.row - oldRange.end.row\r\n    const oldLineCount = (oldRange.end.row - oldRange.start.row) + 1\r\n    const newLineCount = (newRange.end.row - newRange.start.row) + 1\r\n\r\n    this.updateInvalidRows(start, end, delta)\r\n    const previousEndStack = this.stackForRow(end) // used in spill detection below\r\n    if (this.largeFileMode || (this.grammar.name === 'Null Grammar')) {\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, new Array(newLineCount))\r\n    } else {\r\n      const newTokenizedLines = this.buildTokenizedLinesForRows(start, end + delta, this.stackForRow(start - 1), this.openScopesForRow(start))\r\n      _.spliceWithArray(this.tokenizedLines, start, oldLineCount, newTokenizedLines)\r\n      const newEndStack = this.stackForRow(end + delta)\r\n      if (newEndStack && !_.isEqual(newEndStack, previousEndStack)) {\r\n        this.invalidateRow(end + delta + 1)\r\n      }\r\n    }\r\n  }\r", "name": "invalidateRow", "func_location": "TextMateLanguageMode.bufferDidChange", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 373, "func_start_line": 354}}, {"func_info": {"comment": [], "name": "Project.findBufferForId", "params": ["id"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 637, "start_line": 635}, "call_info": {"func_end_line": 656, "comment": [" Only to be used when deserializing"], "code": "  bufferForIdSync (id) {\r\n    if (this.retiredBufferIDs.has(id)) { return null }\r\n\r\n    let existingBuffer\r\n    if (id) { existingBuffer = this.findBufferForId(id) }\r\n    return existingBuffer != null ? existingBuffer : this.buildBufferSync()\r\n  }\r", "name": "findBufferForId", "func_location": "Project.bufferForIdSync", "args": ["id"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 654, "func_start_line": 650}}, {"func_info": {"comment": [" Still needed when deserializing a tokenized buffer"], "name": "Project.buildBufferSync", "params": ["absoluteFilePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 692, "start_line": 681}, "call_info": {"func_end_line": 656, "comment": [" Only to be used when deserializing"], "code": "  bufferForIdSync (id) {\r\n    if (this.retiredBufferIDs.has(id)) { return null }\r\n\r\n    let existingBuffer\r\n    if (id) { existingBuffer = this.findBufferForId(id) }\r\n    return existingBuffer != null ? existingBuffer : this.buildBufferSync()\r\n  }\r", "name": "buildBufferSync", "func_location": "Project.bufferForIdSync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 655, "func_start_line": 650}}, {"func_info": {"comment": [], "name": "Project.findBufferForPath", "params": ["filePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 633, "start_line": 631}, "call_info": {"func_end_line": 674, "comment": [" Given a file path, this retrieves or creates a new {TextBuffer}.", "", " If the `filePath` already has a `buffer`, that value is used instead. Otherwise,", " `text` is used as the contents of the new buffer.", "", " * `filePath` A {String} representing a path. If `null`, an \"Untitled\" buffer is created.", "", " Returns a {Promise} that resolves to the {TextBuffer}."], "code": "  bufferForPath (absoluteFilePath) {\r\n    let existingBuffer\r\n    if (absoluteFilePath != null) { existingBuffer = this.findBufferForPath(absoluteFilePath) }\r\n    if (existingBuffer) {\r\n      return Promise.resolve(existingBuffer)\r\n    } else {\r\n      return this.buildBuffer(absoluteFilePath)\r\n    }\r\n  }\r", "name": "findBufferForPath", "func_location": "Project.bufferForPath", "args": ["absoluteFilePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 668, "func_start_line": 666}}, {"func_info": {"comment": [" Given a file path, this sets its {TextBuffer}.", "", " * `absoluteFilePath` A {String} representing a path.", " * `text` The {String} text to use as a buffer.", "", " Returns a {Promise} that resolves to the {TextBuffer}."], "name": "Project.buildBuffer", "params": ["absoluteFilePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 726, "start_line": 700}, "call_info": {"func_end_line": 674, "comment": [" Given a file path, this retrieves or creates a new {TextBuffer}.", "", " If the `filePath` already has a `buffer`, that value is used instead. Otherwise,", " `text` is used as the contents of the new buffer.", "", " * `filePath` A {String} representing a path. If `null`, an \"Untitled\" buffer is created.", "", " Returns a {Promise} that resolves to the {TextBuffer}."], "code": "  bufferForPath (absoluteFilePath) {\r\n    let existingBuffer\r\n    if (absoluteFilePath != null) { existingBuffer = this.findBufferForPath(absoluteFilePath) }\r\n    if (existingBuffer) {\r\n      return Promise.resolve(existingBuffer)\r\n    } else {\r\n      return this.buildBuffer(absoluteFilePath)\r\n    }\r\n  }\r", "name": "buildBuffer", "func_location": "Project.bufferForPath", "args": ["absoluteFilePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 672, "func_start_line": 666}}, {"func_info": {"comment": [], "name": "Project.resolvePath", "params": ["uri"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 530, "start_line": 514}, "call_info": {"func_end_line": 647, "comment": [" Only to be used in specs"], "code": "  bufferForPathSync (filePath) {\r\n    const absoluteFilePath = this.resolvePath(filePath)\r\n    if (this.retiredBufferPaths.has(absoluteFilePath)) { return null }\r\n\r\n    let existingBuffer\r\n    if (filePath) { existingBuffer = this.findBufferForPath(absoluteFilePath) }\r\n    return existingBuffer != null ? existingBuffer : this.buildBufferSync(absoluteFilePath)\r\n  }\r", "name": "resolvePath", "func_location": "Project.bufferForPathSync", "args": ["filePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 641, "func_start_line": 640}}, {"func_info": {"comment": [], "name": "Project.findBufferForPath", "params": ["filePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 633, "start_line": 631}, "call_info": {"func_end_line": 647, "comment": [" Only to be used in specs"], "code": "  bufferForPathSync (filePath) {\r\n    const absoluteFilePath = this.resolvePath(filePath)\r\n    if (this.retiredBufferPaths.has(absoluteFilePath)) { return null }\r\n\r\n    let existingBuffer\r\n    if (filePath) { existingBuffer = this.findBufferForPath(absoluteFilePath) }\r\n    return existingBuffer != null ? existingBuffer : this.buildBufferSync(absoluteFilePath)\r\n  }\r", "name": "findBufferForPath", "func_location": "Project.bufferForPathSync", "args": ["absoluteFilePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 645, "func_start_line": 640}}, {"func_info": {"comment": [" Still needed when deserializing a tokenized buffer"], "name": "Project.buildBufferSync", "params": ["absoluteFilePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 692, "start_line": 681}, "call_info": {"func_end_line": 647, "comment": [" Only to be used in specs"], "code": "  bufferForPathSync (filePath) {\r\n    const absoluteFilePath = this.resolvePath(filePath)\r\n    if (this.retiredBufferPaths.has(absoluteFilePath)) { return null }\r\n\r\n    let existingBuffer\r\n    if (filePath) { existingBuffer = this.findBufferForPath(absoluteFilePath) }\r\n    return existingBuffer != null ? existingBuffer : this.buildBufferSync(absoluteFilePath)\r\n  }\r", "name": "buildBufferSync", "func_location": "Project.bufferForPathSync", "args": ["absoluteFilePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 646, "func_start_line": 640}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.tokenizedLineForRow", "params": ["bufferRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 449, "start_line": 425}, "call_info": {"func_end_line": 598, "code": "  bufferRangeForScopeAtPosition (selector, position) {\r\n    let endColumn, tag, tokenIndex\r\n    position = Point.fromObject(position)\r\n\r\n    const {openScopes, tags} = this.tokenizedLineForRow(position.row)\r\n    const scopes = openScopes.map(tag => this.grammar.scopeForId(tag))\r\n\r\n    let startColumn = 0\r\n    for (tokenIndex = 0; tokenIndex < tags.length; tokenIndex++) {\r\n      tag = tags[tokenIndex]\r\n      if (tag < 0) {\r\n        if ((tag % 2) === -1) {\r\n          scopes.push(this.grammar.scopeForId(tag))\r\n        } else {\r\n          scopes.pop()\r\n        }\r\n      } else {\r\n        endColumn = startColumn + tag\r\n        if (endColumn >= position.column) {\r\n          break\r\n        } else {\r\n          startColumn = endColumn\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!selectorMatchesAnyScope(selector, scopes)) return\r\n\r\n    const startScopes = scopes.slice()\r\n    for (let startTokenIndex = tokenIndex - 1; startTokenIndex >= 0; startTokenIndex--) {\r\n      tag = tags[startTokenIndex]\r\n      if (tag < 0) {\r\n        if ((tag % 2) === -1) {\r\n          startScopes.pop()\r\n        } else {\r\n          startScopes.push(this.grammar.scopeForId(tag))\r\n        }\r\n      } else {\r\n        if (!selectorMatchesAnyScope(selector, startScopes)) { break }\r\n        startColumn -= tag\r\n      }\r\n    }\r\n\r\n    const endScopes = scopes.slice()\r\n    for (let endTokenIndex = tokenIndex + 1, end = tags.length; endTokenIndex < end; endTokenIndex++) {\r\n      tag = tags[endTokenIndex]\r\n      if (tag < 0) {\r\n        if ((tag % 2) === -1) {\r\n          endScopes.push(this.grammar.scopeForId(tag))\r\n        } else {\r\n          endScopes.pop()\r\n        }\r\n      } else {\r\n        if (!selectorMatchesAnyScope(selector, endScopes)) { break }\r\n        endColumn += tag\r\n      }\r\n    }\r\n\r\n    return new Range(new Point(position.row, startColumn), new Point(position.row, endColumn))\r\n  }\r", "name": "tokenizedLineForRow", "func_location": "TextMateLanguageMode.bufferRangeForScopeAtPosition", "args": ["position.row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 543, "func_start_line": 539}}, {"func_info": {"comment": [], "name": "TreeSitterLanguageMode.getSyntaxNodeAtPosition", "params": ["position", "where"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 418, "start_line": 416}, "call_info": {"func_end_line": 436, "code": "  bufferRangeForScopeAtPosition (selector, position) {\r\n    const nodeCursorAdapter = new NodeCursorAdaptor()\r\n    if (typeof selector === 'string') {\r\n      const match = matcherForSelector(selector)\r\n      selector = (node, grammar) => {\r\n        const rules = grammar.scopeMap.get([node.type], [0], node.named)\r\n        nodeCursorAdapter.node = node\r\n        const scopeName = applyLeafRules(rules, nodeCursorAdapter)\r\n        if (scopeName != null) {\r\n          return match(scopeName)\r\n        }\r\n      }\r\n    }\r\n    if (selector === null) selector = undefined\r\n    const node = this.getSyntaxNodeAtPosition(position, selector)\r\n    return node && node.range\r\n  }\r", "name": "getSyntaxNodeAtPosition", "func_location": "TreeSitterLanguageMode.bufferRangeForScopeAtPosition", "args": ["position", "selector"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 434, "func_start_line": 420}}, {"func_info": {"comment": [], "name": "TextEditorRegistry.textEditorParamsForScope", "params": ["scopeDescriptor"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js", "end_line": 295, "start_line": 288}, "call_info": {"func_end_line": 115, "code": "  build (params) {\r\n    params = Object.assign({assert: this.assert}, params)\r\n\r\n    let scope = null\r\n    if (params.buffer) {\r\n      const {grammar} = params.buffer.getLanguageMode()\r\n      if (grammar) {\r\n        scope = new ScopeDescriptor({scopes: [grammar.scopeName]})\r\n      }\r\n    }\r\n\r\n    Object.assign(params, this.textEditorParamsForScope(scope))\r\n\r\n    return new TextEditor(params)\r\n  }\r", "name": "textEditorParamsForScope", "func_location": "TextEditorRegistry.build", "args": ["params", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js", "line": 112, "func_start_line": 101}}, {"func_info": {"comment": [], "name": "Project.addBuffer", "params": ["buffer", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 734, "start_line": 728}, "call_info": {"func_end_line": 726, "comment": [" Given a file path, this sets its {TextBuffer}.", "", " * `absoluteFilePath` A {String} representing a path.", " * `text` The {String} text to use as a buffer.", "", " Returns a {Promise} that resolves to the {TextBuffer}."], "code": "  async buildBuffer (absoluteFilePath) {\r\n    const params = {shouldDestroyOnFileDelete: this.shouldDestroyBufferOnFileDelete}\r\n\r\n    let buffer\r\n    if (absoluteFilePath != null) {\r\n      if (this.loadPromisesByPath[absoluteFilePath] == null) {\r\n        this.loadPromisesByPath[absoluteFilePath] =\r\n          TextBuffer.load(absoluteFilePath, params)\r\n            .then(result => {\r\n              delete this.loadPromisesByPath[absoluteFilePath]\r\n              return result\r\n            })\r\n            .catch(error => {\r\n              delete this.loadPromisesByPath[absoluteFilePath]\r\n              throw error\r\n            })\r\n      }\r\n      buffer = await this.loadPromisesByPath[absoluteFilePath]\r\n    } else {\r\n      buffer = new TextBuffer(params)\r\n    }\r\n\r\n    this.grammarRegistry.autoAssignLanguageMode(buffer)\r\n\r\n    this.addBuffer(buffer)\r\n    return buffer\r\n  }\r", "name": "addBuffer", "func_location": "Project.buildBuffer", "args": ["buffer"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 724, "func_start_line": 700}}, {"func_info": {"comment": [], "name": "Project.addBuffer", "params": ["buffer", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 734, "start_line": 728}, "call_info": {"func_end_line": 692, "comment": [" Still needed when deserializing a tokenized buffer"], "code": "  buildBufferSync (absoluteFilePath) {\r\n    const params = {shouldDestroyOnFileDelete: this.shouldDestroyBufferOnFileDelete}\r\n\r\n    let buffer\r\n    if (absoluteFilePath != null) {\r\n      buffer = TextBuffer.loadSync(absoluteFilePath, params)\r\n    } else {\r\n      buffer = new TextBuffer(params)\r\n    }\r\n    this.addBuffer(buffer)\r\n    return buffer\r\n  }\r", "name": "addBuffer", "func_location": "Project.buildBufferSync", "args": ["buffer"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 690, "func_start_line": 681}}, {"func_info": {"comment": [], "name": "TextMateHighlightIterator.constructor", "params": ["languageMode"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 737, "start_line": 733}, "call_info": {"func_end_line": 205, "name": "constructor", "func_location": "TextMateLanguageMode.buildHighlightIterator", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 204, "func_start_line": 203}}, {"func_info": {"comment": [], "name": "HighlightIterator.constructor", "params": ["languageMode"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 800, "start_line": 797}, "call_info": {"func_end_line": 144, "name": "constructor", "func_location": "TreeSitterLanguageMode.buildHighlightIterator", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 143, "func_start_line": 141}}, {"func_info": {"comment": [], "name": "LayerHighlightIterator.constructor", "params": ["languageLayer", "treeCursor"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 883, "start_line": 863}, "call_info": {"func_end_line": 560, "code": "  buildHighlightIterator () {\r\n    if (this.tree) {\r\n      return new LayerHighlightIterator(this, this.tree.walk())\r\n    } else {\r\n      return new NullHighlightIterator()\r\n    }\r\n  }\r", "name": "constructor", "func_location": "LanguageLayer.buildHighlightIterator", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 556, "func_start_line": 554}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.buildTokenizedLineForRowWithText", "params": ["row", "text", "currentRuleStack", "openScopes"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 423, "start_line": 411}, "call_info": {"func_end_line": 409, "code": "  buildTokenizedLineForRow (row, ruleStack, openScopes) {\r\n    return this.buildTokenizedLineForRowWithText(row, this.buffer.lineForRow(row), ruleStack, openScopes)\r\n  }\r", "name": "buildTokenizedLineForRowWithText", "func_location": "TextMateLanguageMode.buildTokenizedLineForRow", "args": ["row", null, "ruleStack", "openScopes"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 408, "func_start_line": 407}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.buildTokenizedLineForRow", "params": ["row", "ruleStack", "openScopes"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 409, "start_line": 407}, "call_info": {"func_end_line": 405, "code": "  buildTokenizedLinesForRows (startRow, endRow, startingStack, startingopenScopes) {\r\n    let ruleStack = startingStack\r\n    let openScopes = startingopenScopes\r\n    const stopTokenizingAt = startRow + this.chunkSize\r\n    const tokenizedLines = []\r\n    for (let row = startRow, end = endRow; row <= end; row++) {\r\n      let tokenizedLine\r\n      if ((ruleStack || (row === 0)) && row < stopTokenizingAt) {\r\n        tokenizedLine = this.buildTokenizedLineForRow(row, ruleStack, openScopes)\r\n        ruleStack = tokenizedLine.ruleStack\r\n        openScopes = this.scopesFromTags(openScopes, tokenizedLine.tags)\r\n      }\r\n      tokenizedLines.push(tokenizedLine)\r\n    }\r\n\r\n    if (endRow >= stopTokenizingAt) {\r\n      this.invalidateRow(stopTokenizingAt)\r\n      this.tokenizeInBackground()\r\n    }\r\n\r\n    return tokenizedLines\r\n  }\r", "name": "buildTokenizedLineForRow", "func_location": "TextMateLanguageMode.buildTokenizedLinesForRows", "args": ["row", "ruleStack", "openScopes"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 392, "func_start_line": 384}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.scopesFromTags", "params": ["startingScopes", "tags"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 490, "start_line": 472}, "call_info": {"func_end_line": 405, "code": "  buildTokenizedLinesForRows (startRow, endRow, startingStack, startingopenScopes) {\r\n    let ruleStack = startingStack\r\n    let openScopes = startingopenScopes\r\n    const stopTokenizingAt = startRow + this.chunkSize\r\n    const tokenizedLines = []\r\n    for (let row = startRow, end = endRow; row <= end; row++) {\r\n      let tokenizedLine\r\n      if ((ruleStack || (row === 0)) && row < stopTokenizingAt) {\r\n        tokenizedLine = this.buildTokenizedLineForRow(row, ruleStack, openScopes)\r\n        ruleStack = tokenizedLine.ruleStack\r\n        openScopes = this.scopesFromTags(openScopes, tokenizedLine.tags)\r\n      }\r\n      tokenizedLines.push(tokenizedLine)\r\n    }\r\n\r\n    if (endRow >= stopTokenizingAt) {\r\n      this.invalidateRow(stopTokenizingAt)\r\n      this.tokenizeInBackground()\r\n    }\r\n\r\n    return tokenizedLines\r\n  }\r", "name": "scopesFromTags", "func_location": "TextMateLanguageMode.buildTokenizedLinesForRows", "args": ["openScopes", "tokenizedLine.tags"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 394, "func_start_line": 384}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.invalidateRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 340, "start_line": 336}, "call_info": {"func_end_line": 405, "code": "  buildTokenizedLinesForRows (startRow, endRow, startingStack, startingopenScopes) {\r\n    let ruleStack = startingStack\r\n    let openScopes = startingopenScopes\r\n    const stopTokenizingAt = startRow + this.chunkSize\r\n    const tokenizedLines = []\r\n    for (let row = startRow, end = endRow; row <= end; row++) {\r\n      let tokenizedLine\r\n      if ((ruleStack || (row === 0)) && row < stopTokenizingAt) {\r\n        tokenizedLine = this.buildTokenizedLineForRow(row, ruleStack, openScopes)\r\n        ruleStack = tokenizedLine.ruleStack\r\n        openScopes = this.scopesFromTags(openScopes, tokenizedLine.tags)\r\n      }\r\n      tokenizedLines.push(tokenizedLine)\r\n    }\r\n\r\n    if (endRow >= stopTokenizingAt) {\r\n      this.invalidateRow(stopTokenizingAt)\r\n      this.tokenizeInBackground()\r\n    }\r\n\r\n    return tokenizedLines\r\n  }\r", "name": "invalidateRow", "func_location": "TextMateLanguageMode.buildTokenizedLinesForRows", "args": ["stopTokenizingAt"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 400, "func_start_line": 384}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.tokenizeInBackground", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 280, "start_line": 272}, "call_info": {"func_end_line": 405, "code": "  buildTokenizedLinesForRows (startRow, endRow, startingStack, startingopenScopes) {\r\n    let ruleStack = startingStack\r\n    let openScopes = startingopenScopes\r\n    const stopTokenizingAt = startRow + this.chunkSize\r\n    const tokenizedLines = []\r\n    for (let row = startRow, end = endRow; row <= end; row++) {\r\n      let tokenizedLine\r\n      if ((ruleStack || (row === 0)) && row < stopTokenizingAt) {\r\n        tokenizedLine = this.buildTokenizedLineForRow(row, ruleStack, openScopes)\r\n        ruleStack = tokenizedLine.ruleStack\r\n        openScopes = this.scopesFromTags(openScopes, tokenizedLine.tags)\r\n      }\r\n      tokenizedLines.push(tokenizedLine)\r\n    }\r\n\r\n    if (endRow >= stopTokenizingAt) {\r\n      this.invalidateRow(stopTokenizingAt)\r\n      this.tokenizeInBackground()\r\n    }\r\n\r\n    return tokenizedLines\r\n  }\r", "name": "tokenizeInBackground", "func_location": "TextMateLanguageMode.buildTokenizedLinesForRows", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 401, "func_start_line": 384}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getContentWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2690, "start_line": 2688}, "call_info": {"func_end_line": 2657, "code": "  canScrollHorizontally () {\r\n    const {model} = this.props\r\n    if (model.isMini()) return false\r\n    if (model.getAutoWidth()) return false\r\n    if (model.isSoftWrapped()) return false\r\n    return this.getContentWidth() > this.getScrollContainerClientWidth()\r\n  }\r", "name": "getContentWidth", "func_location": "TextEditorComponent.canScrollHorizontally", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2656, "func_start_line": 2651}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollContainerClientWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2638, "start_line": 2636}, "call_info": {"func_end_line": 2657, "code": "  canScrollHorizontally () {\r\n    const {model} = this.props\r\n    if (model.isMini()) return false\r\n    if (model.getAutoWidth()) return false\r\n    if (model.isSoftWrapped()) return false\r\n    return this.getContentWidth() > this.getScrollContainerClientWidth()\r\n  }\r", "name": "getScrollContainerClientWidth", "func_location": "TextEditorComponent.canScrollHorizontally", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2656, "func_start_line": 2651}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getContentHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2686, "start_line": 2684}, "call_info": {"func_end_line": 2649, "code": "  canScrollVertically () {\r\n    const {model} = this.props\r\n    if (model.isMini()) return false\r\n    if (model.getAutoHeight()) return false\r\n    return this.getContentHeight() > this.getScrollContainerClientHeight()\r\n  }\r", "name": "getContentHeight", "func_location": "TextEditorComponent.canScrollVertically", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2648, "func_start_line": 2644}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollContainerClientHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2642, "start_line": 2640}, "call_info": {"func_end_line": 2649, "code": "  canScrollVertically () {\r\n    const {model} = this.props\r\n    if (model.isMini()) return false\r\n    if (model.getAutoHeight()) return false\r\n    return this.getContentHeight() > this.getScrollContainerClientHeight()\r\n  }\r", "name": "getScrollContainerClientHeight", "func_location": "TextEditorComponent.canScrollVertically", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2648, "func_start_line": 2644}}, {"func_info": {"comment": ["\r\n  Section: Utilities\r\n  ", " Public: Deselects the current selection."], "name": "Cursor.clearSelection", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 665, "start_line": 663}, "call_info": {"func_end_line": 728, "code": "  changePosition (options, fn) {\r\n    this.clearSelection({autoscroll: false})\r\n    fn()\r\n    this.goalColumn = null\r\n    const autoscroll = (options && options.autoscroll != null)\r\n      ? options.autoscroll\r\n      : this.isLastCursor()\r\n    if (autoscroll) this.autoscroll()\r\n  }\r", "name": "clearSelection", "func_location": "Cursor.changePosition", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 721, "func_start_line": 720}}, {"func_info": {"comment": [" Public: Identifies if this cursor is the last in the {TextEditor}.", "", " \"Last\" is defined as the most recently added cursor.", "", " Returns a {Boolean}."], "name": "Cursor.isLastCursor", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 229, "start_line": 227}, "call_info": {"func_end_line": 728, "code": "  changePosition (options, fn) {\r\n    this.clearSelection({autoscroll: false})\r\n    fn()\r\n    this.goalColumn = null\r\n    const autoscroll = (options && options.autoscroll != null)\r\n      ? options.autoscroll\r\n      : this.isLastCursor()\r\n    if (autoscroll) this.autoscroll()\r\n  }\r", "name": "isLastCursor", "func_location": "Cursor.changePosition", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 726, "func_start_line": 720}}, {"func_info": {"comment": [], "name": "Cursor.autoscroll", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 738, "start_line": 735}, "call_info": {"func_end_line": 728, "code": "  changePosition (options, fn) {\r\n    this.clearSelection({autoscroll: false})\r\n    fn()\r\n    this.goalColumn = null\r\n    const autoscroll = (options && options.autoscroll != null)\r\n      ? options.autoscroll\r\n      : this.isLastCursor()\r\n    if (autoscroll) this.autoscroll()\r\n  }\r", "name": "autoscroll", "func_location": "Cursor.changePosition", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 727, "func_start_line": 720}}, {"func_info": {"comment": [], "name": "AutoUpdater.downloadUpdate", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-updater-win32.js", "end_line": 35, "start_line": 17}, "call_info": {"func_end_line": 85, "name": "downloadUpdate", "func_location": "AutoUpdater.checkForUpdates", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-updater-win32.js", "line": 55, "func_start_line": 45}}, {"func_info": {"comment": [" Returns the corresponding {Repository}"], "name": "GitRepository.getRepo", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 530, "start_line": 524}, "call_info": {"func_end_line": 477, "comment": ["\r\n  Section: Checking Out\r\n  ", " Public: Restore the contents of a path in the working directory and index", " to the version at `HEAD`.", "", " This is essentially the same as running:", "", " ```sh", "   git reset HEAD -- <path>", "   git checkout HEAD -- <path>", " ```", "", " * `path` The {String} path to checkout.", "", " Returns a {Boolean} that's true if the method was successful."], "code": "  checkoutHead (path) {\r\n    const repo = this.getRepo(path)\r\n    const headCheckedOut = repo.checkoutHead(repo.relativize(path))\r\n    if (headCheckedOut) this.getPathStatus(path)\r\n    return headCheckedOut\r\n  }\r", "name": "getRepo", "func_location": "GitRepository.checkoutHead", "args": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 473, "func_start_line": 472}}, {"func_info": {"comment": [" Public: Get the status of a single path in the repository.", "", " * `path` A {String} repository-relative path.", "", " Returns a {Number} representing the status. This value can be passed to", " {::isStatusModified} or {::isStatusNew} to get more information."], "name": "GitRepository.getPathStatus", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 390, "start_line": 374}, "call_info": {"func_end_line": 477, "comment": ["\r\n  Section: Checking Out\r\n  ", " Public: Restore the contents of a path in the working directory and index", " to the version at `HEAD`.", "", " This is essentially the same as running:", "", " ```sh", "   git reset HEAD -- <path>", "   git checkout HEAD -- <path>", " ```", "", " * `path` The {String} path to checkout.", "", " Returns a {Boolean} that's true if the method was successful."], "code": "  checkoutHead (path) {\r\n    const repo = this.getRepo(path)\r\n    const headCheckedOut = repo.checkoutHead(repo.relativize(path))\r\n    if (headCheckedOut) this.getPathStatus(path)\r\n    return headCheckedOut\r\n  }\r", "name": "getPathStatus", "func_location": "GitRepository.checkoutHead", "args": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 475, "func_start_line": 472}}, {"func_info": {"comment": ["\r\n  Section: Checking Out\r\n  ", " Public: Restore the contents of a path in the working directory and index", " to the version at `HEAD`.", "", " This is essentially the same as running:", "", " ```sh", "   git reset HEAD -- <path>", "   git checkout HEAD -- <path>", " ```", "", " * `path` The {String} path to checkout.", "", " Returns a {Boolean} that's true if the method was successful."], "name": "GitRepository.checkoutHead", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 477, "start_line": 472}, "call_info": {"func_end_line": 521, "comment": [" Subscribes to editor view event."], "code": "  checkoutHeadForEditor (editor) {\r\n    const buffer = editor.getBuffer()\r\n    const bufferPath = buffer.getPath()\r\n    if (bufferPath) {\r\n      this.checkoutHead(bufferPath)\r\n      return buffer.reload()\r\n    }\r\n  }\r", "name": "checkoutHead", "func_location": "GitRepository.checkoutHeadForEditor", "args": ["bufferPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 518, "func_start_line": 514}}, {"func_info": {"comment": [" Returns the corresponding {Repository}"], "name": "GitRepository.getRepo", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 530, "start_line": 524}, "call_info": {"func_end_line": 488, "comment": [" Public: Checks out a branch in your repository.", "", " * `reference` The {String} reference to checkout.", " * `create`    A {Boolean} value which, if true creates the new reference if", "   it doesn't exist.", "", " Returns a Boolean that's true if the method was successful."], "code": "  checkoutReference (reference, create) {\r\n    return this.getRepo().checkoutReference(reference, create)\r\n  }\r", "name": "getRepo", "func_location": "GitRepository.checkoutReference", "args": ["reference", "create"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 487, "func_start_line": 486}}, {"func_info": {"comment": [], "name": "ViewRegistry.clearDocumentRequests", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/view-registry.js", "end_line": 222, "start_line": 213}, "call_info": {"func_end_line": 39, "code": "  clear () {\r\n    this.views = new WeakMap()\r\n    this.providers = []\r\n    this.clearDocumentRequests()\r\n  }\r", "name": "clearDocumentRequests", "func_location": "ViewRegistry.clear", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/view-registry.js", "line": 38, "func_start_line": 35}}, {"func_info": {"comment": [], "name": "Selection.isLastSelection", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 31, "start_line": 29}, "call_info": {"func_end_line": 205, "comment": ["\r\n  Section: Modifying the selected range\r\n  ", " Public: Clears the selection, moving the marker to the head.", "", " * `options` (optional) {Object} with the following keys:", "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new", "     range. Defaults to `true` if this is the most recently added selection,", "     `false` otherwise."], "code": "  clear (options) {\r\n    this.goalScreenRange = null\r\n    if (!this.retainSelection) this.marker.clearTail()\r\n    const autoscroll = options && options.autoscroll != null\r\n      ? options.autoscroll\r\n      : this.isLastSelection()\r\n    if (autoscroll) this.autoscroll()\r\n    this.finalize()\r\n  }\r", "name": "isLastSelection", "func_location": "Selection.clear", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 202, "func_start_line": 197}}, {"func_info": {"comment": [], "name": "Pane.setPendingItem", "params": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 652, "start_line": 644}, "call_info": {"func_end_line": 660, "code": "  clearPendingItem () {\r\n    this.setPendingItem(null)\r\n  }\r", "name": "setPendingItem", "func_location": "Pane.clearPendingItem", "args": [{"type": "object"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 659, "func_start_line": 658}}, {"func_info": {"comment": [], "name": "HistoryManager.saveState", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "end_line": 106, "start_line": 103}, "call_info": {"func_end_line": 40, "comment": [" Public: Clear all projects from the history.", "", " Note: This is not a privacy function - other traces will still exist,", " e.g. window state.", "", " Return a {Promise} that resolves when the history has been successfully", " cleared."], "code": "  async clearProjects () {\r\n    this.projects = []\r\n    await this.saveState()\r\n    this.didChangeProjects()\r\n  }\r", "name": "saveState", "func_location": "HistoryManager.clearProjects", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "line": 38, "func_start_line": 36}}, {"func_info": {"comment": [], "name": "HistoryManager.didChangeProjects", "params": ["args"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "end_line": 53, "start_line": 51}, "call_info": {"func_end_line": 40, "comment": [" Public: Clear all projects from the history.", "", " Note: This is not a privacy function - other traces will still exist,", " e.g. window state.", "", " Return a {Promise} that resolves when the history has been successfully", " cleared."], "code": "  async clearProjects () {\r\n    this.projects = []\r\n    await this.saveState()\r\n    this.didChangeProjects()\r\n  }\r", "name": "didChangeProjects", "func_location": "HistoryManager.clearProjects", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "line": 39, "func_start_line": 36}}, {"func_info": {"comment": [], "name": "Config.resetProjectSettings", "params": ["newSettings", "projectFile"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 988, "start_line": 977}, "call_info": {"func_end_line": 992, "code": "  clearProjectSettings () {\r\n    this.resetProjectSettings({}, null)\r\n  }\r", "name": "resetProjectSettings", "func_location": "Config.clearProjectSettings", "args": [null, {"type": "object"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 991, "func_start_line": 990}}, {"func_info": {"comment": [], "name": "Color.constructor", "params": ["red", "green", "blue", "alpha"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js", "end_line": 43, "start_line": 38}, "call_info": {"func_end_line": 113, "name": "constructor", "func_location": "Color.clone", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js", "line": 112, "func_start_line": 111}}, {"func_info": {"comment": ["\r\n  Section: Items\r\n  ", " Public: Get the items in this pane.", "", " Returns an {Array} of items."], "name": "Pane.getItems", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 427, "start_line": 425}, "call_info": {"func_end_line": 1219, "comment": [" Private: Close the pane unless the user cancels the action via a dialog.", "", " Returns a {Promise} that resolves once the pane is either closed, or the", " closing has been cancelled."], "code": "  close () {\r\n    return Promise.all(this.getItems().map(item => this.promptToSaveItem(item)))\r\n      .then(results => {\r\n        if (!results.includes(false)) return this.destroy()\r\n      })\r\n  }\r", "name": "getItems", "func_location": "Pane.close", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 1215, "func_start_line": 1214}}, {"func_info": {"comment": ["\r\n  Section: Pane Locations\r\n  ", " Essential: Get the {WorkspaceCenter} at the center of the editor window."], "name": "Workspace.getCenter", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1601, "start_line": 1599}, "call_info": {"func_end_line": 1523, "comment": [" Close the active center pane item, or the active center pane if it is", " empty, or the current window if there is only the empty root pane."], "code": "  closeActivePaneItemOrEmptyPaneOrWindow () {\r\n    if (this.getCenter().getActivePaneItem() != null) {\r\n      this.getCenter().getActivePane().destroyActiveItem()\r\n    } else if (this.getCenter().getPanes().length > 1) {\r\n      this.getCenter().destroyActivePane()\r\n    } else if (this.config.get('core.closeEmptyWindows')) {\r\n      atom.close()\r\n    }\r\n  }\r", "name": "getCenter", "func_location": "Workspace.closeActivePaneItemOrEmptyPaneOrWindow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1516, "func_start_line": 1515}}, {"func_info": {"comment": ["\r\n  Section: Pane Locations\r\n  ", " Essential: Get the {WorkspaceCenter} at the center of the editor window."], "name": "Workspace.getCenter", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1601, "start_line": 1599}, "call_info": {"func_end_line": 1523, "comment": [" Close the active center pane item, or the active center pane if it is", " empty, or the current window if there is only the empty root pane."], "code": "  closeActivePaneItemOrEmptyPaneOrWindow () {\r\n    if (this.getCenter().getActivePaneItem() != null) {\r\n      this.getCenter().getActivePane().destroyActiveItem()\r\n    } else if (this.getCenter().getPanes().length > 1) {\r\n      this.getCenter().destroyActivePane()\r\n    } else if (this.config.get('core.closeEmptyWindows')) {\r\n      atom.close()\r\n    }\r\n  }\r", "name": "getCenter", "func_location": "Workspace.closeActivePaneItemOrEmptyPaneOrWindow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1517, "func_start_line": 1515}}, {"func_info": {"comment": ["\r\n  Section: Pane Locations\r\n  ", " Essential: Get the {WorkspaceCenter} at the center of the editor window."], "name": "Workspace.getCenter", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1601, "start_line": 1599}, "call_info": {"func_end_line": 1523, "comment": [" Close the active center pane item, or the active center pane if it is", " empty, or the current window if there is only the empty root pane."], "code": "  closeActivePaneItemOrEmptyPaneOrWindow () {\r\n    if (this.getCenter().getActivePaneItem() != null) {\r\n      this.getCenter().getActivePane().destroyActiveItem()\r\n    } else if (this.getCenter().getPanes().length > 1) {\r\n      this.getCenter().destroyActivePane()\r\n    } else if (this.config.get('core.closeEmptyWindows')) {\r\n      atom.close()\r\n    }\r\n  }\r", "name": "getCenter", "func_location": "Workspace.closeActivePaneItemOrEmptyPaneOrWindow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1518, "func_start_line": 1515}}, {"func_info": {"comment": ["\r\n  Section: Pane Locations\r\n  ", " Essential: Get the {WorkspaceCenter} at the center of the editor window."], "name": "Workspace.getCenter", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1601, "start_line": 1599}, "call_info": {"func_end_line": 1523, "comment": [" Close the active center pane item, or the active center pane if it is", " empty, or the current window if there is only the empty root pane."], "code": "  closeActivePaneItemOrEmptyPaneOrWindow () {\r\n    if (this.getCenter().getActivePaneItem() != null) {\r\n      this.getCenter().getActivePane().destroyActiveItem()\r\n    } else if (this.getCenter().getPanes().length > 1) {\r\n      this.getCenter().destroyActivePane()\r\n    } else if (this.config.get('core.closeEmptyWindows')) {\r\n      atom.close()\r\n    }\r\n  }\r", "name": "getCenter", "func_location": "Workspace.closeActivePaneItemOrEmptyPaneOrWindow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1519, "func_start_line": 1515}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.scopeDescriptorForPosition", "params": ["position"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 526, "start_line": 507}, "call_info": {"func_end_line": 197, "comment": ["\r\n  Section - Comments\r\n  "], "code": "  commentStringsForPosition (position) {\r\n    const scope = this.scopeDescriptorForPosition(position)\r\n    const commentStartEntries = this.config.getAll('editor.commentStart', {scope})\r\n    const commentEndEntries = this.config.getAll('editor.commentEnd', {scope})\r\n    const commentStartEntry = commentStartEntries[0]\r\n    const commentEndEntry = commentEndEntries.find((entry) => {\r\n      return entry.scopeSelector === commentStartEntry.scopeSelector\r\n    })\r\n    return {\r\n      commentStartString: commentStartEntry && commentStartEntry.value,\r\n      commentEndString: commentEndEntry && commentEndEntry.value\r\n    }\r\n  }\r", "name": "scopeDescriptorForPosition", "func_location": "TextMateLanguageMode.commentStringsForPosition", "args": ["position"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 186, "func_start_line": 185}}, {"func_info": {"comment": ["\r\n  Section - Private\r\n  "], "name": "TreeSitterLanguageMode.firstNonWhitespaceRange", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 528, "start_line": 526}, "call_info": {"func_end_line": 166, "comment": ["\r\n  Section - Commenting\r\n  "], "code": "  commentStringsForPosition (position) {\r\n    const range = this.firstNonWhitespaceRange(position.row) || new Range(position, position)\r\n    const {grammar} = this.getSyntaxNodeAndGrammarContainingRange(range)\r\n    return grammar.commentStrings\r\n  }\r", "name": "firstNonWhitespaceRange", "func_location": "TreeSitterLanguageMode.commentStringsForPosition", "args": ["position.row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 163, "func_start_line": 162}}, {"func_info": {"comment": [], "name": "TreeSitterLanguageMode.getSyntaxNodeAndGrammarContainingRange", "params": ["range", "where"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 409, "start_line": 387}, "call_info": {"func_end_line": 166, "comment": ["\r\n  Section - Commenting\r\n  "], "code": "  commentStringsForPosition (position) {\r\n    const range = this.firstNonWhitespaceRange(position.row) || new Range(position, position)\r\n    const {grammar} = this.getSyntaxNodeAndGrammarContainingRange(range)\r\n    return grammar.commentStrings\r\n  }\r", "name": "getSyntaxNodeAndGrammarContainingRange", "func_location": "TreeSitterLanguageMode.commentStringsForPosition", "args": ["range"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 164, "func_start_line": 162}}, {"func_info": {"comment": [" Public: Returns the current buffer position as an Array."], "name": "Cursor.getBufferPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 93, "start_line": 91}, "call_info": {"func_end_line": 656, "comment": ["\r\n  Section: Visibility\r\n  ", "\r\n  Section: Comparing to another cursor\r\n  ", " Public: Compare this cursor's buffer position to another cursor's buffer position.", "", " See {Point::compare} for more details.", "", " * `otherCursor`{Cursor} to compare against"], "code": "  compare (otherCursor) {\r\n    return this.getBufferPosition().compare(otherCursor.getBufferPosition())\r\n  }\r", "name": "getBufferPosition", "func_location": "Cursor.compare", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 655, "func_start_line": 654}}, {"func_info": {"comment": [], "name": "readCachedJavaScript", "params": ["relativeCachePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/compile-cache.js", "end_line": 109, "start_line": 101}, "call_info": {"func_end_line": 99, "code": "function compileFileAtPath (compiler, filePath, extension) {\r\n  var sourceCode = fs.readFileSync(filePath, 'utf8')\r\n  if (compiler.shouldCompile(sourceCode, filePath)) {\r\n    var cachePath = compiler.getCachePath(sourceCode, filePath)\r\n    var compiledCode = readCachedJavaScript(cachePath)\r\n    if (compiledCode != null) {\r\n      cacheStats[extension].hits++\r\n    } else {\r\n      cacheStats[extension].misses++\r\n      compiledCode = compiler.compile(sourceCode, filePath)\r\n      writeCachedJavaScript(cachePath, compiledCode)\r\n    }\r\n    return compiledCode\r\n  }\r\n  return sourceCode\r\n}\r", "name": "readCachedJavaScript", "func_location": "compileFileAtPath", "args": ["cachePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/compile-cache.js", "line": 88, "func_start_line": 84}}, {"func_info": {"comment": [], "name": "writeCachedJavaScript", "params": ["relativeCachePath", "code"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/compile-cache.js", "end_line": 114, "start_line": 111}, "call_info": {"func_end_line": 99, "code": "function compileFileAtPath (compiler, filePath, extension) {\r\n  var sourceCode = fs.readFileSync(filePath, 'utf8')\r\n  if (compiler.shouldCompile(sourceCode, filePath)) {\r\n    var cachePath = compiler.getCachePath(sourceCode, filePath)\r\n    var compiledCode = readCachedJavaScript(cachePath)\r\n    if (compiledCode != null) {\r\n      cacheStats[extension].hits++\r\n    } else {\r\n      cacheStats[extension].misses++\r\n      compiledCode = compiler.compile(sourceCode, filePath)\r\n      writeCachedJavaScript(cachePath, compiledCode)\r\n    }\r\n    return compiledCode\r\n  }\r\n  return sourceCode\r\n}\r", "name": "writeCachedJavaScript", "func_location": "compileFileAtPath", "args": ["cachePath", "compiledCode"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/compile-cache.js", "line": 94, "func_start_line": 84}}, {"func_info": {"comment": [], "name": "PaneContainer.getPanes", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 152, "start_line": 146}, "call_info": {"func_end_line": 186, "code": "  confirmClose (options) {\r\n    const promises = []\r\n    for (const pane of this.getPanes()) {\r\n      for (const item of pane.getItems()) {\r\n        promises.push(pane.promptToSaveItem(item, options))\r\n      }\r\n    }\r\n    return Promise.all(promises).then((results) => !results.includes(false))\r\n  }\r", "name": "getPanes", "func_location": "PaneContainer.confirmClose", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 180, "func_start_line": 178}}, {"func_info": {"comment": [], "name": "Workspace.getPaneContainers", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1625, "start_line": 1618}, "call_info": {"func_end_line": 1388, "code": "  confirmClose (options) {\r\n    return Promise.all(this.getPaneContainers().map(container =>\r\n      container.confirmClose(options)\r\n    )).then((results) => !results.includes(false))\r\n  }\r", "name": "getPaneContainers", "func_location": "Workspace.confirmClose", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1385, "func_start_line": 1384}}, {"func_info": {"comment": [], "name": "GrammarRegistry.clear", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 49, "start_line": 28}, "call_info": {"func_end_line": 26, "code": "  constructor ({config} = {}) {\r\n    this.config = config\r\n    this.subscriptions = new CompositeDisposable()\r\n    this.textmateRegistry = new FirstMate.GrammarRegistry({maxTokensPerLine: 100, maxLineLength: 1000})\r\n    this.clear()\r\n  }\r", "name": "clear", "func_location": "GrammarRegistry.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 25, "func_start_line": 21}}, {"func_info": {"comment": [], "name": "ViewRegistry.clear", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/view-registry.js", "end_line": 39, "start_line": 35}, "call_info": {"func_end_line": 33, "code": "  constructor (atomEnvironment) {\r\n    this.animationFrameRequest = null\r\n    this.documentReadInProgress = false\r\n    this.performDocumentUpdate = this.performDocumentUpdate.bind(this)\r\n    this.atomEnvironment = atomEnvironment\r\n    this.clear()\r\n  }\r", "name": "clear", "func_location": "ViewRegistry.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/view-registry.js", "line": 32, "func_start_line": 27}}, {"func_info": {"comment": [], "name": "TitleBar.updateTitle", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/title-bar.js", "end_line": 42, "start_line": 40}, "call_info": {"func_end_line": 22, "code": "  constructor ({workspace, themes, applicationDelegate}) {\r\n    this.dblclickHandler = this.dblclickHandler.bind(this)\r\n    this.workspace = workspace\r\n    this.themes = themes\r\n    this.applicationDelegate = applicationDelegate\r\n    this.element = document.createElement('div')\r\n    this.element.classList.add('title-bar')\r\n\r\n    this.titleElement = document.createElement('div')\r\n    this.titleElement.classList.add('title')\r\n    this.element.appendChild(this.titleElement)\r\n\r\n    this.element.addEventListener('dblclick', this.dblclickHandler)\r\n\r\n    this.workspace.onDidChangeWindowTitle(() => this.updateTitle())\r\n    this.themes.onDidChangeActiveThemes(() => this.updateWindowSheetOffset())\r\n\r\n    this.updateTitle()\r\n    this.updateWindowSheetOffset()\r\n  }\r", "name": "updateTitle", "func_location": "TitleBar.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/title-bar.js", "line": 20, "func_start_line": 3}}, {"func_info": {"comment": [], "name": "TitleBar.updateWindowSheetOffset", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/title-bar.js", "end_line": 46, "start_line": 44}, "call_info": {"func_end_line": 22, "code": "  constructor ({workspace, themes, applicationDelegate}) {\r\n    this.dblclickHandler = this.dblclickHandler.bind(this)\r\n    this.workspace = workspace\r\n    this.themes = themes\r\n    this.applicationDelegate = applicationDelegate\r\n    this.element = document.createElement('div')\r\n    this.element.classList.add('title-bar')\r\n\r\n    this.titleElement = document.createElement('div')\r\n    this.titleElement.classList.add('title')\r\n    this.element.appendChild(this.titleElement)\r\n\r\n    this.element.addEventListener('dblclick', this.dblclickHandler)\r\n\r\n    this.workspace.onDidChangeWindowTitle(() => this.updateTitle())\r\n    this.themes.onDidChangeActiveThemes(() => this.updateWindowSheetOffset())\r\n\r\n    this.updateTitle()\r\n    this.updateWindowSheetOffset()\r\n  }\r", "name": "updateWindowSheetOffset", "func_location": "TitleBar.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/title-bar.js", "line": 21, "func_start_line": 3}}, {"func_info": {"comment": [], "name": "extractDidDispatch", "params": ["listener"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js", "end_line": 457, "start_line": 455}, "call_info": {"func_end_line": 420, "code": "  constructor (selector, commandName, listener) {\r\n    this.selector = selector\r\n    this.didDispatch = extractDidDispatch(listener)\r\n    this.descriptor = extractDescriptor(commandName, listener)\r\n    this.specificity = calculateSpecificity(this.selector)\r\n    this.sequenceNumber = SequenceCount++\r\n  }\r", "name": "extractDidDispatch", "func_location": "SelectorBasedListener.constructor", "args": ["listener"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js", "line": 416, "func_start_line": 414}}, {"func_info": {"comment": [" type CommandDescriptor = {", "   name: string,", "   displayName: string,", " };"], "name": "extractDescriptor", "params": ["name", "listener"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js", "end_line": 453, "start_line": 445}, "call_info": {"func_end_line": 420, "code": "  constructor (selector, commandName, listener) {\r\n    this.selector = selector\r\n    this.didDispatch = extractDidDispatch(listener)\r\n    this.descriptor = extractDescriptor(commandName, listener)\r\n    this.specificity = calculateSpecificity(this.selector)\r\n    this.sequenceNumber = SequenceCount++\r\n  }\r", "name": "extractDescriptor", "func_location": "SelectorBasedListener.constructor", "args": ["commandName", "listener"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js", "line": 417, "func_start_line": 414}}, {"func_info": {"comment": [], "name": "extractDidDispatch", "params": ["listener"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js", "end_line": 457, "start_line": 455}, "call_info": {"func_end_line": 438, "code": "  constructor (commandName, listener) {\r\n    this.didDispatch = extractDidDispatch(listener)\r\n    this.descriptor = extractDescriptor(commandName, listener)\r\n  }\r", "name": "extractDidDispatch", "func_location": "InlineListener.constructor", "args": ["listener"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js", "line": 436, "func_start_line": 435}}, {"func_info": {"comment": [" type CommandDescriptor = {", "   name: string,", "   displayName: string,", " };"], "name": "extractDescriptor", "params": ["name", "listener"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js", "end_line": 453, "start_line": 445}, "call_info": {"func_end_line": 438, "code": "  constructor (commandName, listener) {\r\n    this.didDispatch = extractDidDispatch(listener)\r\n    this.descriptor = extractDescriptor(commandName, listener)\r\n  }\r", "name": "extractDescriptor", "func_location": "InlineListener.constructor", "args": ["commandName", "listener"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js", "line": 437, "func_start_line": 435}}, {"func_info": {"comment": [], "name": "CommandRegistry.clear", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js", "end_line": 59, "start_line": 54}, "call_info": {"func_end_line": 52, "code": "  constructor () {\r\n    this.handleCommandEvent = this.handleCommandEvent.bind(this)\r\n    this.rootNode = null\r\n    this.clear()\r\n  }\r", "name": "clear", "func_location": "CommandRegistry.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js", "line": 51, "func_start_line": 48}}, {"func_info": {"comment": [], "name": "TextEditor.isMini", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 1002, "start_line": 1002}, "call_info": {"func_end_line": 265, "code": "  constructor (params = {}) {\r\n    if (this.constructor.clipboard == null) {\r\n      throw new Error('Must call TextEditor.setClipboard at least once before creating TextEditor instances')\r\n    }\r\n\r\n    this.id = params.id != null ? params.id : nextId++\r\n    if (this.id >= nextId) {\r\n      // Ensure that new editors get unique ids:\r\n      nextId = this.id + 1\r\n    }\r\n    this.initialScrollTopRow = params.initialScrollTopRow\r\n    this.initialScrollLeftColumn = params.initialScrollLeftColumn\r\n    this.decorationManager = params.decorationManager\r\n    this.selectionsMarkerLayer = params.selectionsMarkerLayer\r\n    this.mini = (params.mini != null) ? params.mini : false\r\n    this.keyboardInputEnabled = (params.keyboardInputEnabled != null) ? params.keyboardInputEnabled : true\r\n    this.readOnly = (params.readOnly != null) ? params.readOnly : false\r\n    this.placeholderText = params.placeholderText\r\n    this.showLineNumbers = params.showLineNumbers\r\n    this.assert = params.assert || (condition => condition)\r\n    this.showInvisibles = (params.showInvisibles != null) ? params.showInvisibles : true\r\n    this.autoHeight = params.autoHeight\r\n    this.autoWidth = params.autoWidth\r\n    this.scrollPastEnd = (params.scrollPastEnd != null) ? params.scrollPastEnd : false\r\n    this.scrollSensitivity = (params.scrollSensitivity != null) ? params.scrollSensitivity : 40\r\n    this.editorWidthInChars = params.editorWidthInChars\r\n    this.invisibles = params.invisibles\r\n    this.showIndentGuide = params.showIndentGuide\r\n    this.softWrapped = params.softWrapped\r\n    this.softWrapAtPreferredLineLength = params.softWrapAtPreferredLineLength\r\n    this.preferredLineLength = params.preferredLineLength\r\n    this.showCursorOnSelection = (params.showCursorOnSelection != null) ? params.showCursorOnSelection : true\r\n    this.maxScreenLineLength = params.maxScreenLineLength\r\n    this.softTabs = (params.softTabs != null) ? params.softTabs : true\r\n    this.autoIndent = (params.autoIndent != null) ? params.autoIndent : true\r\n    this.autoIndentOnPaste = (params.autoIndentOnPaste != null) ? params.autoIndentOnPaste : true\r\n    this.undoGroupingInterval = (params.undoGroupingInterval != null) ? params.undoGroupingInterval : 300\r\n    this.softWrapped = (params.softWrapped != null) ? params.softWrapped : false\r\n    this.softWrapAtPreferredLineLength = (params.softWrapAtPreferredLineLength != null) ? params.softWrapAtPreferredLineLength : false\r\n    this.preferredLineLength = (params.preferredLineLength != null) ? params.preferredLineLength : 80\r\n    this.maxScreenLineLength = (params.maxScreenLineLength != null) ? params.maxScreenLineLength : 500\r\n    this.showLineNumbers = (params.showLineNumbers != null) ? params.showLineNumbers : true\r\n    const {tabLength = 2} = params\r\n\r\n    this.alive = true\r\n    this.doBackgroundWork = this.doBackgroundWork.bind(this)\r\n    this.serializationVersion = 1\r\n    this.suppressSelectionMerging = false\r\n    this.selectionFlashDuration = 500\r\n    this.gutterContainer = null\r\n    this.verticalScrollMargin = 2\r\n    this.horizontalScrollMargin = 6\r\n    this.lineHeightInPixels = null\r\n    this.defaultCharWidth = null\r\n    this.height = null\r\n    this.width = null\r\n    this.registered = false\r\n    this.atomicSoftTabs = true\r\n    this.emitter = new Emitter()\r\n    this.disposables = new CompositeDisposable()\r\n    this.cursors = []\r\n    this.cursorsByMarkerId = new Map()\r\n    this.selections = []\r\n    this.hasTerminatedPendingState = false\r\n\r\n    if (params.buffer) {\r\n      this.buffer = params.buffer\r\n    } else {\r\n      this.buffer = new TextBuffer({\r\n        shouldDestroyOnFileDelete () { return atom.config.get('core.closeDeletedFileTabs') }\r\n      })\r\n      this.buffer.setLanguageMode(new TextMateLanguageMode({buffer: this.buffer, config: atom.config}))\r\n    }\r\n\r\n    const languageMode = this.buffer.getLanguageMode()\r\n    this.languageModeSubscription = languageMode.onDidTokenize && languageMode.onDidTokenize(() => {\r\n      this.emitter.emit('did-tokenize')\r\n    })\r\n    if (this.languageModeSubscription) this.disposables.add(this.languageModeSubscription)\r\n\r\n    if (params.displayLayer) {\r\n      this.displayLayer = params.displayLayer\r\n    } else {\r\n      const displayLayerParams = {\r\n        invisibles: this.getInvisibles(),\r\n        softWrapColumn: this.getSoftWrapColumn(),\r\n        showIndentGuides: this.doesShowIndentGuide(),\r\n        atomicSoftTabs: params.atomicSoftTabs != null ? params.atomicSoftTabs : true,\r\n        tabLength,\r\n        ratioForCharacter: this.ratioForCharacter.bind(this),\r\n        isWrapBoundary,\r\n        foldCharacter: ZERO_WIDTH_NBSP,\r\n        softWrapHangingIndent: params.softWrapHangingIndentLength != null ? params.softWrapHangingIndentLength : 0\r\n      }\r\n\r\n      this.displayLayer = this.buffer.getDisplayLayer(params.displayLayerId)\r\n      if (this.displayLayer) {\r\n        this.displayLayer.reset(displayLayerParams)\r\n        this.selectionsMarkerLayer = this.displayLayer.getMarkerLayer(params.selectionsMarkerLayerId)\r\n      } else {\r\n        this.displayLayer = this.buffer.addDisplayLayer(displayLayerParams)\r\n      }\r\n    }\r\n\r\n    this.backgroundWorkHandle = requestIdleCallback(this.doBackgroundWork)\r\n    this.disposables.add(new Disposable(() => {\r\n      if (this.backgroundWorkHandle != null) return cancelIdleCallback(this.backgroundWorkHandle)\r\n    }))\r\n\r\n    this.defaultMarkerLayer = this.displayLayer.addMarkerLayer()\r\n    if (!this.selectionsMarkerLayer) {\r\n      this.selectionsMarkerLayer = this.addMarkerLayer({maintainHistory: true, persistent: true, role: 'selections'})\r\n    }\r\n\r\n    this.decorationManager = new DecorationManager(this)\r\n    this.decorateMarkerLayer(this.selectionsMarkerLayer, {type: 'cursor'})\r\n    if (!this.isMini()) this.decorateCursorLine()\r\n\r\n    this.decorateMarkerLayer(this.displayLayer.foldsMarkerLayer, {type: 'line-number', class: 'folded'})\r\n\r\n    for (let marker of this.selectionsMarkerLayer.getMarkers()) {\r\n      this.addSelection(marker)\r\n    }\r\n\r\n    this.subscribeToBuffer()\r\n    this.subscribeToDisplayLayer()\r\n\r\n    if (this.cursors.length === 0 && !params.suppressCursorCreation) {\r\n      const initialLine = Math.max(parseInt(params.initialLine) || 0, 0)\r\n      const initialColumn = Math.max(parseInt(params.initialColumn) || 0, 0)\r\n      this.addCursorAtBufferPosition([initialLine, initialColumn])\r\n    }\r\n\r\n    this.gutterContainer = new GutterContainer(this)\r\n    this.lineNumberGutter = this.gutterContainer.addGutter({\r\n      name: 'line-number',\r\n      type: 'line-number',\r\n      priority: 0,\r\n      visible: params.lineNumberGutterVisible\r\n    })\r\n  }\r", "name": "isMini", "func_location": "TextEditor.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 241, "func_start_line": 125}}, {"func_info": {"comment": [], "name": "TextEditor.decorateCursorLine", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 305, "start_line": 299}, "call_info": {"func_end_line": 265, "code": "  constructor (params = {}) {\r\n    if (this.constructor.clipboard == null) {\r\n      throw new Error('Must call TextEditor.setClipboard at least once before creating TextEditor instances')\r\n    }\r\n\r\n    this.id = params.id != null ? params.id : nextId++\r\n    if (this.id >= nextId) {\r\n      // Ensure that new editors get unique ids:\r\n      nextId = this.id + 1\r\n    }\r\n    this.initialScrollTopRow = params.initialScrollTopRow\r\n    this.initialScrollLeftColumn = params.initialScrollLeftColumn\r\n    this.decorationManager = params.decorationManager\r\n    this.selectionsMarkerLayer = params.selectionsMarkerLayer\r\n    this.mini = (params.mini != null) ? params.mini : false\r\n    this.keyboardInputEnabled = (params.keyboardInputEnabled != null) ? params.keyboardInputEnabled : true\r\n    this.readOnly = (params.readOnly != null) ? params.readOnly : false\r\n    this.placeholderText = params.placeholderText\r\n    this.showLineNumbers = params.showLineNumbers\r\n    this.assert = params.assert || (condition => condition)\r\n    this.showInvisibles = (params.showInvisibles != null) ? params.showInvisibles : true\r\n    this.autoHeight = params.autoHeight\r\n    this.autoWidth = params.autoWidth\r\n    this.scrollPastEnd = (params.scrollPastEnd != null) ? params.scrollPastEnd : false\r\n    this.scrollSensitivity = (params.scrollSensitivity != null) ? params.scrollSensitivity : 40\r\n    this.editorWidthInChars = params.editorWidthInChars\r\n    this.invisibles = params.invisibles\r\n    this.showIndentGuide = params.showIndentGuide\r\n    this.softWrapped = params.softWrapped\r\n    this.softWrapAtPreferredLineLength = params.softWrapAtPreferredLineLength\r\n    this.preferredLineLength = params.preferredLineLength\r\n    this.showCursorOnSelection = (params.showCursorOnSelection != null) ? params.showCursorOnSelection : true\r\n    this.maxScreenLineLength = params.maxScreenLineLength\r\n    this.softTabs = (params.softTabs != null) ? params.softTabs : true\r\n    this.autoIndent = (params.autoIndent != null) ? params.autoIndent : true\r\n    this.autoIndentOnPaste = (params.autoIndentOnPaste != null) ? params.autoIndentOnPaste : true\r\n    this.undoGroupingInterval = (params.undoGroupingInterval != null) ? params.undoGroupingInterval : 300\r\n    this.softWrapped = (params.softWrapped != null) ? params.softWrapped : false\r\n    this.softWrapAtPreferredLineLength = (params.softWrapAtPreferredLineLength != null) ? params.softWrapAtPreferredLineLength : false\r\n    this.preferredLineLength = (params.preferredLineLength != null) ? params.preferredLineLength : 80\r\n    this.maxScreenLineLength = (params.maxScreenLineLength != null) ? params.maxScreenLineLength : 500\r\n    this.showLineNumbers = (params.showLineNumbers != null) ? params.showLineNumbers : true\r\n    const {tabLength = 2} = params\r\n\r\n    this.alive = true\r\n    this.doBackgroundWork = this.doBackgroundWork.bind(this)\r\n    this.serializationVersion = 1\r\n    this.suppressSelectionMerging = false\r\n    this.selectionFlashDuration = 500\r\n    this.gutterContainer = null\r\n    this.verticalScrollMargin = 2\r\n    this.horizontalScrollMargin = 6\r\n    this.lineHeightInPixels = null\r\n    this.defaultCharWidth = null\r\n    this.height = null\r\n    this.width = null\r\n    this.registered = false\r\n    this.atomicSoftTabs = true\r\n    this.emitter = new Emitter()\r\n    this.disposables = new CompositeDisposable()\r\n    this.cursors = []\r\n    this.cursorsByMarkerId = new Map()\r\n    this.selections = []\r\n    this.hasTerminatedPendingState = false\r\n\r\n    if (params.buffer) {\r\n      this.buffer = params.buffer\r\n    } else {\r\n      this.buffer = new TextBuffer({\r\n        shouldDestroyOnFileDelete () { return atom.config.get('core.closeDeletedFileTabs') }\r\n      })\r\n      this.buffer.setLanguageMode(new TextMateLanguageMode({buffer: this.buffer, config: atom.config}))\r\n    }\r\n\r\n    const languageMode = this.buffer.getLanguageMode()\r\n    this.languageModeSubscription = languageMode.onDidTokenize && languageMode.onDidTokenize(() => {\r\n      this.emitter.emit('did-tokenize')\r\n    })\r\n    if (this.languageModeSubscription) this.disposables.add(this.languageModeSubscription)\r\n\r\n    if (params.displayLayer) {\r\n      this.displayLayer = params.displayLayer\r\n    } else {\r\n      const displayLayerParams = {\r\n        invisibles: this.getInvisibles(),\r\n        softWrapColumn: this.getSoftWrapColumn(),\r\n        showIndentGuides: this.doesShowIndentGuide(),\r\n        atomicSoftTabs: params.atomicSoftTabs != null ? params.atomicSoftTabs : true,\r\n        tabLength,\r\n        ratioForCharacter: this.ratioForCharacter.bind(this),\r\n        isWrapBoundary,\r\n        foldCharacter: ZERO_WIDTH_NBSP,\r\n        softWrapHangingIndent: params.softWrapHangingIndentLength != null ? params.softWrapHangingIndentLength : 0\r\n      }\r\n\r\n      this.displayLayer = this.buffer.getDisplayLayer(params.displayLayerId)\r\n      if (this.displayLayer) {\r\n        this.displayLayer.reset(displayLayerParams)\r\n        this.selectionsMarkerLayer = this.displayLayer.getMarkerLayer(params.selectionsMarkerLayerId)\r\n      } else {\r\n        this.displayLayer = this.buffer.addDisplayLayer(displayLayerParams)\r\n      }\r\n    }\r\n\r\n    this.backgroundWorkHandle = requestIdleCallback(this.doBackgroundWork)\r\n    this.disposables.add(new Disposable(() => {\r\n      if (this.backgroundWorkHandle != null) return cancelIdleCallback(this.backgroundWorkHandle)\r\n    }))\r\n\r\n    this.defaultMarkerLayer = this.displayLayer.addMarkerLayer()\r\n    if (!this.selectionsMarkerLayer) {\r\n      this.selectionsMarkerLayer = this.addMarkerLayer({maintainHistory: true, persistent: true, role: 'selections'})\r\n    }\r\n\r\n    this.decorationManager = new DecorationManager(this)\r\n    this.decorateMarkerLayer(this.selectionsMarkerLayer, {type: 'cursor'})\r\n    if (!this.isMini()) this.decorateCursorLine()\r\n\r\n    this.decorateMarkerLayer(this.displayLayer.foldsMarkerLayer, {type: 'line-number', class: 'folded'})\r\n\r\n    for (let marker of this.selectionsMarkerLayer.getMarkers()) {\r\n      this.addSelection(marker)\r\n    }\r\n\r\n    this.subscribeToBuffer()\r\n    this.subscribeToDisplayLayer()\r\n\r\n    if (this.cursors.length === 0 && !params.suppressCursorCreation) {\r\n      const initialLine = Math.max(parseInt(params.initialLine) || 0, 0)\r\n      const initialColumn = Math.max(parseInt(params.initialColumn) || 0, 0)\r\n      this.addCursorAtBufferPosition([initialLine, initialColumn])\r\n    }\r\n\r\n    this.gutterContainer = new GutterContainer(this)\r\n    this.lineNumberGutter = this.gutterContainer.addGutter({\r\n      name: 'line-number',\r\n      type: 'line-number',\r\n      priority: 0,\r\n      visible: params.lineNumberGutterVisible\r\n    })\r\n  }\r", "name": "decorateCursorLine", "func_location": "TextEditor.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 241, "func_start_line": 125}}, {"func_info": {"comment": [], "name": "TextEditor.subscribeToBuffer", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 595, "start_line": 581}, "call_info": {"func_end_line": 265, "code": "  constructor (params = {}) {\r\n    if (this.constructor.clipboard == null) {\r\n      throw new Error('Must call TextEditor.setClipboard at least once before creating TextEditor instances')\r\n    }\r\n\r\n    this.id = params.id != null ? params.id : nextId++\r\n    if (this.id >= nextId) {\r\n      // Ensure that new editors get unique ids:\r\n      nextId = this.id + 1\r\n    }\r\n    this.initialScrollTopRow = params.initialScrollTopRow\r\n    this.initialScrollLeftColumn = params.initialScrollLeftColumn\r\n    this.decorationManager = params.decorationManager\r\n    this.selectionsMarkerLayer = params.selectionsMarkerLayer\r\n    this.mini = (params.mini != null) ? params.mini : false\r\n    this.keyboardInputEnabled = (params.keyboardInputEnabled != null) ? params.keyboardInputEnabled : true\r\n    this.readOnly = (params.readOnly != null) ? params.readOnly : false\r\n    this.placeholderText = params.placeholderText\r\n    this.showLineNumbers = params.showLineNumbers\r\n    this.assert = params.assert || (condition => condition)\r\n    this.showInvisibles = (params.showInvisibles != null) ? params.showInvisibles : true\r\n    this.autoHeight = params.autoHeight\r\n    this.autoWidth = params.autoWidth\r\n    this.scrollPastEnd = (params.scrollPastEnd != null) ? params.scrollPastEnd : false\r\n    this.scrollSensitivity = (params.scrollSensitivity != null) ? params.scrollSensitivity : 40\r\n    this.editorWidthInChars = params.editorWidthInChars\r\n    this.invisibles = params.invisibles\r\n    this.showIndentGuide = params.showIndentGuide\r\n    this.softWrapped = params.softWrapped\r\n    this.softWrapAtPreferredLineLength = params.softWrapAtPreferredLineLength\r\n    this.preferredLineLength = params.preferredLineLength\r\n    this.showCursorOnSelection = (params.showCursorOnSelection != null) ? params.showCursorOnSelection : true\r\n    this.maxScreenLineLength = params.maxScreenLineLength\r\n    this.softTabs = (params.softTabs != null) ? params.softTabs : true\r\n    this.autoIndent = (params.autoIndent != null) ? params.autoIndent : true\r\n    this.autoIndentOnPaste = (params.autoIndentOnPaste != null) ? params.autoIndentOnPaste : true\r\n    this.undoGroupingInterval = (params.undoGroupingInterval != null) ? params.undoGroupingInterval : 300\r\n    this.softWrapped = (params.softWrapped != null) ? params.softWrapped : false\r\n    this.softWrapAtPreferredLineLength = (params.softWrapAtPreferredLineLength != null) ? params.softWrapAtPreferredLineLength : false\r\n    this.preferredLineLength = (params.preferredLineLength != null) ? params.preferredLineLength : 80\r\n    this.maxScreenLineLength = (params.maxScreenLineLength != null) ? params.maxScreenLineLength : 500\r\n    this.showLineNumbers = (params.showLineNumbers != null) ? params.showLineNumbers : true\r\n    const {tabLength = 2} = params\r\n\r\n    this.alive = true\r\n    this.doBackgroundWork = this.doBackgroundWork.bind(this)\r\n    this.serializationVersion = 1\r\n    this.suppressSelectionMerging = false\r\n    this.selectionFlashDuration = 500\r\n    this.gutterContainer = null\r\n    this.verticalScrollMargin = 2\r\n    this.horizontalScrollMargin = 6\r\n    this.lineHeightInPixels = null\r\n    this.defaultCharWidth = null\r\n    this.height = null\r\n    this.width = null\r\n    this.registered = false\r\n    this.atomicSoftTabs = true\r\n    this.emitter = new Emitter()\r\n    this.disposables = new CompositeDisposable()\r\n    this.cursors = []\r\n    this.cursorsByMarkerId = new Map()\r\n    this.selections = []\r\n    this.hasTerminatedPendingState = false\r\n\r\n    if (params.buffer) {\r\n      this.buffer = params.buffer\r\n    } else {\r\n      this.buffer = new TextBuffer({\r\n        shouldDestroyOnFileDelete () { return atom.config.get('core.closeDeletedFileTabs') }\r\n      })\r\n      this.buffer.setLanguageMode(new TextMateLanguageMode({buffer: this.buffer, config: atom.config}))\r\n    }\r\n\r\n    const languageMode = this.buffer.getLanguageMode()\r\n    this.languageModeSubscription = languageMode.onDidTokenize && languageMode.onDidTokenize(() => {\r\n      this.emitter.emit('did-tokenize')\r\n    })\r\n    if (this.languageModeSubscription) this.disposables.add(this.languageModeSubscription)\r\n\r\n    if (params.displayLayer) {\r\n      this.displayLayer = params.displayLayer\r\n    } else {\r\n      const displayLayerParams = {\r\n        invisibles: this.getInvisibles(),\r\n        softWrapColumn: this.getSoftWrapColumn(),\r\n        showIndentGuides: this.doesShowIndentGuide(),\r\n        atomicSoftTabs: params.atomicSoftTabs != null ? params.atomicSoftTabs : true,\r\n        tabLength,\r\n        ratioForCharacter: this.ratioForCharacter.bind(this),\r\n        isWrapBoundary,\r\n        foldCharacter: ZERO_WIDTH_NBSP,\r\n        softWrapHangingIndent: params.softWrapHangingIndentLength != null ? params.softWrapHangingIndentLength : 0\r\n      }\r\n\r\n      this.displayLayer = this.buffer.getDisplayLayer(params.displayLayerId)\r\n      if (this.displayLayer) {\r\n        this.displayLayer.reset(displayLayerParams)\r\n        this.selectionsMarkerLayer = this.displayLayer.getMarkerLayer(params.selectionsMarkerLayerId)\r\n      } else {\r\n        this.displayLayer = this.buffer.addDisplayLayer(displayLayerParams)\r\n      }\r\n    }\r\n\r\n    this.backgroundWorkHandle = requestIdleCallback(this.doBackgroundWork)\r\n    this.disposables.add(new Disposable(() => {\r\n      if (this.backgroundWorkHandle != null) return cancelIdleCallback(this.backgroundWorkHandle)\r\n    }))\r\n\r\n    this.defaultMarkerLayer = this.displayLayer.addMarkerLayer()\r\n    if (!this.selectionsMarkerLayer) {\r\n      this.selectionsMarkerLayer = this.addMarkerLayer({maintainHistory: true, persistent: true, role: 'selections'})\r\n    }\r\n\r\n    this.decorationManager = new DecorationManager(this)\r\n    this.decorateMarkerLayer(this.selectionsMarkerLayer, {type: 'cursor'})\r\n    if (!this.isMini()) this.decorateCursorLine()\r\n\r\n    this.decorateMarkerLayer(this.displayLayer.foldsMarkerLayer, {type: 'line-number', class: 'folded'})\r\n\r\n    for (let marker of this.selectionsMarkerLayer.getMarkers()) {\r\n      this.addSelection(marker)\r\n    }\r\n\r\n    this.subscribeToBuffer()\r\n    this.subscribeToDisplayLayer()\r\n\r\n    if (this.cursors.length === 0 && !params.suppressCursorCreation) {\r\n      const initialLine = Math.max(parseInt(params.initialLine) || 0, 0)\r\n      const initialColumn = Math.max(parseInt(params.initialColumn) || 0, 0)\r\n      this.addCursorAtBufferPosition([initialLine, initialColumn])\r\n    }\r\n\r\n    this.gutterContainer = new GutterContainer(this)\r\n    this.lineNumberGutter = this.gutterContainer.addGutter({\r\n      name: 'line-number',\r\n      type: 'line-number',\r\n      priority: 0,\r\n      visible: params.lineNumberGutterVisible\r\n    })\r\n  }\r", "name": "subscribeToBuffer", "func_location": "TextEditor.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 249, "func_start_line": 125}}, {"func_info": {"comment": [], "name": "TextEditor.subscribeToDisplayLayer", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 619, "start_line": 606}, "call_info": {"func_end_line": 265, "code": "  constructor (params = {}) {\r\n    if (this.constructor.clipboard == null) {\r\n      throw new Error('Must call TextEditor.setClipboard at least once before creating TextEditor instances')\r\n    }\r\n\r\n    this.id = params.id != null ? params.id : nextId++\r\n    if (this.id >= nextId) {\r\n      // Ensure that new editors get unique ids:\r\n      nextId = this.id + 1\r\n    }\r\n    this.initialScrollTopRow = params.initialScrollTopRow\r\n    this.initialScrollLeftColumn = params.initialScrollLeftColumn\r\n    this.decorationManager = params.decorationManager\r\n    this.selectionsMarkerLayer = params.selectionsMarkerLayer\r\n    this.mini = (params.mini != null) ? params.mini : false\r\n    this.keyboardInputEnabled = (params.keyboardInputEnabled != null) ? params.keyboardInputEnabled : true\r\n    this.readOnly = (params.readOnly != null) ? params.readOnly : false\r\n    this.placeholderText = params.placeholderText\r\n    this.showLineNumbers = params.showLineNumbers\r\n    this.assert = params.assert || (condition => condition)\r\n    this.showInvisibles = (params.showInvisibles != null) ? params.showInvisibles : true\r\n    this.autoHeight = params.autoHeight\r\n    this.autoWidth = params.autoWidth\r\n    this.scrollPastEnd = (params.scrollPastEnd != null) ? params.scrollPastEnd : false\r\n    this.scrollSensitivity = (params.scrollSensitivity != null) ? params.scrollSensitivity : 40\r\n    this.editorWidthInChars = params.editorWidthInChars\r\n    this.invisibles = params.invisibles\r\n    this.showIndentGuide = params.showIndentGuide\r\n    this.softWrapped = params.softWrapped\r\n    this.softWrapAtPreferredLineLength = params.softWrapAtPreferredLineLength\r\n    this.preferredLineLength = params.preferredLineLength\r\n    this.showCursorOnSelection = (params.showCursorOnSelection != null) ? params.showCursorOnSelection : true\r\n    this.maxScreenLineLength = params.maxScreenLineLength\r\n    this.softTabs = (params.softTabs != null) ? params.softTabs : true\r\n    this.autoIndent = (params.autoIndent != null) ? params.autoIndent : true\r\n    this.autoIndentOnPaste = (params.autoIndentOnPaste != null) ? params.autoIndentOnPaste : true\r\n    this.undoGroupingInterval = (params.undoGroupingInterval != null) ? params.undoGroupingInterval : 300\r\n    this.softWrapped = (params.softWrapped != null) ? params.softWrapped : false\r\n    this.softWrapAtPreferredLineLength = (params.softWrapAtPreferredLineLength != null) ? params.softWrapAtPreferredLineLength : false\r\n    this.preferredLineLength = (params.preferredLineLength != null) ? params.preferredLineLength : 80\r\n    this.maxScreenLineLength = (params.maxScreenLineLength != null) ? params.maxScreenLineLength : 500\r\n    this.showLineNumbers = (params.showLineNumbers != null) ? params.showLineNumbers : true\r\n    const {tabLength = 2} = params\r\n\r\n    this.alive = true\r\n    this.doBackgroundWork = this.doBackgroundWork.bind(this)\r\n    this.serializationVersion = 1\r\n    this.suppressSelectionMerging = false\r\n    this.selectionFlashDuration = 500\r\n    this.gutterContainer = null\r\n    this.verticalScrollMargin = 2\r\n    this.horizontalScrollMargin = 6\r\n    this.lineHeightInPixels = null\r\n    this.defaultCharWidth = null\r\n    this.height = null\r\n    this.width = null\r\n    this.registered = false\r\n    this.atomicSoftTabs = true\r\n    this.emitter = new Emitter()\r\n    this.disposables = new CompositeDisposable()\r\n    this.cursors = []\r\n    this.cursorsByMarkerId = new Map()\r\n    this.selections = []\r\n    this.hasTerminatedPendingState = false\r\n\r\n    if (params.buffer) {\r\n      this.buffer = params.buffer\r\n    } else {\r\n      this.buffer = new TextBuffer({\r\n        shouldDestroyOnFileDelete () { return atom.config.get('core.closeDeletedFileTabs') }\r\n      })\r\n      this.buffer.setLanguageMode(new TextMateLanguageMode({buffer: this.buffer, config: atom.config}))\r\n    }\r\n\r\n    const languageMode = this.buffer.getLanguageMode()\r\n    this.languageModeSubscription = languageMode.onDidTokenize && languageMode.onDidTokenize(() => {\r\n      this.emitter.emit('did-tokenize')\r\n    })\r\n    if (this.languageModeSubscription) this.disposables.add(this.languageModeSubscription)\r\n\r\n    if (params.displayLayer) {\r\n      this.displayLayer = params.displayLayer\r\n    } else {\r\n      const displayLayerParams = {\r\n        invisibles: this.getInvisibles(),\r\n        softWrapColumn: this.getSoftWrapColumn(),\r\n        showIndentGuides: this.doesShowIndentGuide(),\r\n        atomicSoftTabs: params.atomicSoftTabs != null ? params.atomicSoftTabs : true,\r\n        tabLength,\r\n        ratioForCharacter: this.ratioForCharacter.bind(this),\r\n        isWrapBoundary,\r\n        foldCharacter: ZERO_WIDTH_NBSP,\r\n        softWrapHangingIndent: params.softWrapHangingIndentLength != null ? params.softWrapHangingIndentLength : 0\r\n      }\r\n\r\n      this.displayLayer = this.buffer.getDisplayLayer(params.displayLayerId)\r\n      if (this.displayLayer) {\r\n        this.displayLayer.reset(displayLayerParams)\r\n        this.selectionsMarkerLayer = this.displayLayer.getMarkerLayer(params.selectionsMarkerLayerId)\r\n      } else {\r\n        this.displayLayer = this.buffer.addDisplayLayer(displayLayerParams)\r\n      }\r\n    }\r\n\r\n    this.backgroundWorkHandle = requestIdleCallback(this.doBackgroundWork)\r\n    this.disposables.add(new Disposable(() => {\r\n      if (this.backgroundWorkHandle != null) return cancelIdleCallback(this.backgroundWorkHandle)\r\n    }))\r\n\r\n    this.defaultMarkerLayer = this.displayLayer.addMarkerLayer()\r\n    if (!this.selectionsMarkerLayer) {\r\n      this.selectionsMarkerLayer = this.addMarkerLayer({maintainHistory: true, persistent: true, role: 'selections'})\r\n    }\r\n\r\n    this.decorationManager = new DecorationManager(this)\r\n    this.decorateMarkerLayer(this.selectionsMarkerLayer, {type: 'cursor'})\r\n    if (!this.isMini()) this.decorateCursorLine()\r\n\r\n    this.decorateMarkerLayer(this.displayLayer.foldsMarkerLayer, {type: 'line-number', class: 'folded'})\r\n\r\n    for (let marker of this.selectionsMarkerLayer.getMarkers()) {\r\n      this.addSelection(marker)\r\n    }\r\n\r\n    this.subscribeToBuffer()\r\n    this.subscribeToDisplayLayer()\r\n\r\n    if (this.cursors.length === 0 && !params.suppressCursorCreation) {\r\n      const initialLine = Math.max(parseInt(params.initialLine) || 0, 0)\r\n      const initialColumn = Math.max(parseInt(params.initialColumn) || 0, 0)\r\n      this.addCursorAtBufferPosition([initialLine, initialColumn])\r\n    }\r\n\r\n    this.gutterContainer = new GutterContainer(this)\r\n    this.lineNumberGutter = this.gutterContainer.addGutter({\r\n      name: 'line-number',\r\n      type: 'line-number',\r\n      priority: 0,\r\n      visible: params.lineNumberGutterVisible\r\n    })\r\n  }\r", "name": "subscribeToDisplayLayer", "func_location": "TextEditor.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 250, "func_start_line": 125}}, {"func_info": {"comment": [], "name": "debounce", "params": ["fn", "wait"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4410, "start_line": 4393}, "call_info": {"func_end_line": 182, "name": "debounce", "func_location": "TextEditorComponent.constructor", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 89, "func_start_line": 55}}, {"func_info": {"comment": [], "name": "NodePool.constructor", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4416, "start_line": 4413}, "call_info": {"func_end_line": 182, "name": "constructor", "func_location": "TextEditorComponent.constructor", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 94, "func_start_line": 55}}, {"func_info": {"comment": [], "name": "TextEditorComponent.queryGuttersToRender", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 979, "start_line": 963}, "call_info": {"func_end_line": 182, "code": "  constructor (props) {\r\n    this.props = props\r\n\r\n    if (!props.model) {\r\n      props.model = new TextEditor({mini: props.mini, readOnly: props.readOnly})\r\n    }\r\n    this.props.model.component = this\r\n\r\n    if (props.element) {\r\n      this.element = props.element\r\n    } else {\r\n      if (!TextEditorElement) TextEditorElement = require('./text-editor-element')\r\n      this.element = new TextEditorElement()\r\n    }\r\n    this.element.initialize(this)\r\n    this.virtualNode = $('atom-text-editor')\r\n    this.virtualNode.domNode = this.element\r\n    this.refs = {}\r\n\r\n    this.updateSync = this.updateSync.bind(this)\r\n    this.didBlurHiddenInput = this.didBlurHiddenInput.bind(this)\r\n    this.didFocusHiddenInput = this.didFocusHiddenInput.bind(this)\r\n    this.didPaste = this.didPaste.bind(this)\r\n    this.didTextInput = this.didTextInput.bind(this)\r\n    this.didKeydown = this.didKeydown.bind(this)\r\n    this.didKeyup = this.didKeyup.bind(this)\r\n    this.didKeypress = this.didKeypress.bind(this)\r\n    this.didCompositionStart = this.didCompositionStart.bind(this)\r\n    this.didCompositionUpdate = this.didCompositionUpdate.bind(this)\r\n    this.didCompositionEnd = this.didCompositionEnd.bind(this)\r\n\r\n    this.updatedSynchronously = this.props.updatedSynchronously\r\n    this.didScrollDummyScrollbar = this.didScrollDummyScrollbar.bind(this)\r\n    this.didMouseDownOnContent = this.didMouseDownOnContent.bind(this)\r\n    this.debouncedResumeCursorBlinking = debounce(\r\n      this.resumeCursorBlinking.bind(this),\r\n      (this.props.cursorBlinkResumeDelay || CURSOR_BLINK_RESUME_DELAY)\r\n    )\r\n    this.lineTopIndex = new LineTopIndex()\r\n    this.lineNodesPool = new NodePool()\r\n    this.updateScheduled = false\r\n    this.suppressUpdates = false\r\n    this.hasInitialMeasurements = false\r\n    this.measurements = {\r\n      lineHeight: 0,\r\n      baseCharacterWidth: 0,\r\n      doubleWidthCharacterWidth: 0,\r\n      halfWidthCharacterWidth: 0,\r\n      koreanCharacterWidth: 0,\r\n      gutterContainerWidth: 0,\r\n      lineNumberGutterWidth: 0,\r\n      clientContainerHeight: 0,\r\n      clientContainerWidth: 0,\r\n      verticalScrollbarWidth: 0,\r\n      horizontalScrollbarHeight: 0,\r\n      longestLineWidth: 0\r\n    }\r\n    this.derivedDimensionsCache = {}\r\n    this.visible = false\r\n    this.cursorsBlinking = false\r\n    this.cursorsBlinkedOff = false\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    this.linesToMeasure = new Map()\r\n    this.extraRenderedScreenLines = new Map()\r\n    this.horizontalPositionsToMeasure = new Map() // Keys are rows with positions we want to measure, values are arrays of columns to measure\r\n    this.horizontalPixelPositionsByScreenLineId = new Map() // Values are maps from column to horizontal pixel positions\r\n    this.blockDecorationsToMeasure = new Set()\r\n    this.blockDecorationsByElement = new WeakMap()\r\n    this.blockDecorationSentinel = document.createElement('div')\r\n    this.blockDecorationSentinel.style.height = '1px'\r\n    this.heightsByBlockDecoration = new WeakMap()\r\n    this.blockDecorationResizeObserver = new ResizeObserver(this.didResizeBlockDecorations.bind(this))\r\n    this.lineComponentsByScreenLineId = new Map()\r\n    this.overlayComponents = new Set()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.remeasureScrollbars = false\r\n    this.pendingAutoscroll = null\r\n    this.scrollTopPending = false\r\n    this.scrollLeftPending = false\r\n    this.scrollTop = 0\r\n    this.scrollLeft = 0\r\n    this.previousScrollWidth = 0\r\n    this.previousScrollHeight = 0\r\n    this.lastKeydown = null\r\n    this.lastKeydownBeforeKeypress = null\r\n    this.accentedCharacterMenuIsOpen = false\r\n    this.remeasureGutterDimensions = false\r\n    this.guttersToRender = [this.props.model.getLineNumberGutter()]\r\n    this.guttersVisibility = [this.guttersToRender[0].visible]\r\n    this.idsByTileStartRow = new Map()\r\n    this.nextTileId = 0\r\n    this.renderedTileStartRows = []\r\n    this.showLineNumbers = this.props.model.doesShowLineNumbers()\r\n    this.lineNumbersToRender = {\r\n      maxDigits: 2,\r\n      bufferRows: [],\r\n      screenRows: [],\r\n      keys: [],\r\n      softWrappedFlags: [],\r\n      foldableFlags: []\r\n    }\r\n    this.decorationsToRender = {\r\n      lineNumbers: new Map(),\r\n      lines: null,\r\n      highlights: [],\r\n      cursors: [],\r\n      overlays: [],\r\n      customGutter: new Map(),\r\n      blocks: new Map(),\r\n      text: []\r\n    }\r\n    this.decorationsToMeasure = {\r\n      highlights: [],\r\n      cursors: new Map()\r\n    }\r\n    this.textDecorationsByMarker = new Map()\r\n    this.textDecorationBoundaries = []\r\n    this.pendingScrollTopRow = this.props.initialScrollTopRow\r\n    this.pendingScrollLeftColumn = this.props.initialScrollLeftColumn\r\n    this.tabIndex = this.props.element && this.props.element.tabIndex ? this.props.element.tabIndex : -1\r\n\r\n    this.measuredContent = false\r\n    this.queryGuttersToRender()\r\n    this.queryMaxLineNumberDigits()\r\n    this.observeBlockDecorations()\r\n    this.updateClassList()\r\n    etch.updateSync(this)\r\n  }\r", "name": "queryGuttersToRender", "func_location": "TextEditorComponent.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 177, "func_start_line": 55}}, {"func_info": {"comment": [], "name": "TextEditorComponent.queryMaxLineNumberDigits", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 954, "start_line": 945}, "call_info": {"func_end_line": 182, "code": "  constructor (props) {\r\n    this.props = props\r\n\r\n    if (!props.model) {\r\n      props.model = new TextEditor({mini: props.mini, readOnly: props.readOnly})\r\n    }\r\n    this.props.model.component = this\r\n\r\n    if (props.element) {\r\n      this.element = props.element\r\n    } else {\r\n      if (!TextEditorElement) TextEditorElement = require('./text-editor-element')\r\n      this.element = new TextEditorElement()\r\n    }\r\n    this.element.initialize(this)\r\n    this.virtualNode = $('atom-text-editor')\r\n    this.virtualNode.domNode = this.element\r\n    this.refs = {}\r\n\r\n    this.updateSync = this.updateSync.bind(this)\r\n    this.didBlurHiddenInput = this.didBlurHiddenInput.bind(this)\r\n    this.didFocusHiddenInput = this.didFocusHiddenInput.bind(this)\r\n    this.didPaste = this.didPaste.bind(this)\r\n    this.didTextInput = this.didTextInput.bind(this)\r\n    this.didKeydown = this.didKeydown.bind(this)\r\n    this.didKeyup = this.didKeyup.bind(this)\r\n    this.didKeypress = this.didKeypress.bind(this)\r\n    this.didCompositionStart = this.didCompositionStart.bind(this)\r\n    this.didCompositionUpdate = this.didCompositionUpdate.bind(this)\r\n    this.didCompositionEnd = this.didCompositionEnd.bind(this)\r\n\r\n    this.updatedSynchronously = this.props.updatedSynchronously\r\n    this.didScrollDummyScrollbar = this.didScrollDummyScrollbar.bind(this)\r\n    this.didMouseDownOnContent = this.didMouseDownOnContent.bind(this)\r\n    this.debouncedResumeCursorBlinking = debounce(\r\n      this.resumeCursorBlinking.bind(this),\r\n      (this.props.cursorBlinkResumeDelay || CURSOR_BLINK_RESUME_DELAY)\r\n    )\r\n    this.lineTopIndex = new LineTopIndex()\r\n    this.lineNodesPool = new NodePool()\r\n    this.updateScheduled = false\r\n    this.suppressUpdates = false\r\n    this.hasInitialMeasurements = false\r\n    this.measurements = {\r\n      lineHeight: 0,\r\n      baseCharacterWidth: 0,\r\n      doubleWidthCharacterWidth: 0,\r\n      halfWidthCharacterWidth: 0,\r\n      koreanCharacterWidth: 0,\r\n      gutterContainerWidth: 0,\r\n      lineNumberGutterWidth: 0,\r\n      clientContainerHeight: 0,\r\n      clientContainerWidth: 0,\r\n      verticalScrollbarWidth: 0,\r\n      horizontalScrollbarHeight: 0,\r\n      longestLineWidth: 0\r\n    }\r\n    this.derivedDimensionsCache = {}\r\n    this.visible = false\r\n    this.cursorsBlinking = false\r\n    this.cursorsBlinkedOff = false\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    this.linesToMeasure = new Map()\r\n    this.extraRenderedScreenLines = new Map()\r\n    this.horizontalPositionsToMeasure = new Map() // Keys are rows with positions we want to measure, values are arrays of columns to measure\r\n    this.horizontalPixelPositionsByScreenLineId = new Map() // Values are maps from column to horizontal pixel positions\r\n    this.blockDecorationsToMeasure = new Set()\r\n    this.blockDecorationsByElement = new WeakMap()\r\n    this.blockDecorationSentinel = document.createElement('div')\r\n    this.blockDecorationSentinel.style.height = '1px'\r\n    this.heightsByBlockDecoration = new WeakMap()\r\n    this.blockDecorationResizeObserver = new ResizeObserver(this.didResizeBlockDecorations.bind(this))\r\n    this.lineComponentsByScreenLineId = new Map()\r\n    this.overlayComponents = new Set()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.remeasureScrollbars = false\r\n    this.pendingAutoscroll = null\r\n    this.scrollTopPending = false\r\n    this.scrollLeftPending = false\r\n    this.scrollTop = 0\r\n    this.scrollLeft = 0\r\n    this.previousScrollWidth = 0\r\n    this.previousScrollHeight = 0\r\n    this.lastKeydown = null\r\n    this.lastKeydownBeforeKeypress = null\r\n    this.accentedCharacterMenuIsOpen = false\r\n    this.remeasureGutterDimensions = false\r\n    this.guttersToRender = [this.props.model.getLineNumberGutter()]\r\n    this.guttersVisibility = [this.guttersToRender[0].visible]\r\n    this.idsByTileStartRow = new Map()\r\n    this.nextTileId = 0\r\n    this.renderedTileStartRows = []\r\n    this.showLineNumbers = this.props.model.doesShowLineNumbers()\r\n    this.lineNumbersToRender = {\r\n      maxDigits: 2,\r\n      bufferRows: [],\r\n      screenRows: [],\r\n      keys: [],\r\n      softWrappedFlags: [],\r\n      foldableFlags: []\r\n    }\r\n    this.decorationsToRender = {\r\n      lineNumbers: new Map(),\r\n      lines: null,\r\n      highlights: [],\r\n      cursors: [],\r\n      overlays: [],\r\n      customGutter: new Map(),\r\n      blocks: new Map(),\r\n      text: []\r\n    }\r\n    this.decorationsToMeasure = {\r\n      highlights: [],\r\n      cursors: new Map()\r\n    }\r\n    this.textDecorationsByMarker = new Map()\r\n    this.textDecorationBoundaries = []\r\n    this.pendingScrollTopRow = this.props.initialScrollTopRow\r\n    this.pendingScrollLeftColumn = this.props.initialScrollLeftColumn\r\n    this.tabIndex = this.props.element && this.props.element.tabIndex ? this.props.element.tabIndex : -1\r\n\r\n    this.measuredContent = false\r\n    this.queryGuttersToRender()\r\n    this.queryMaxLineNumberDigits()\r\n    this.observeBlockDecorations()\r\n    this.updateClassList()\r\n    etch.updateSync(this)\r\n  }\r", "name": "queryMaxLineNumberDigits", "func_location": "TextEditorComponent.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 178, "func_start_line": 55}}, {"func_info": {"comment": [], "name": "TextEditorComponent.observeBlockDecorations", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2506, "start_line": 2500}, "call_info": {"func_end_line": 182, "code": "  constructor (props) {\r\n    this.props = props\r\n\r\n    if (!props.model) {\r\n      props.model = new TextEditor({mini: props.mini, readOnly: props.readOnly})\r\n    }\r\n    this.props.model.component = this\r\n\r\n    if (props.element) {\r\n      this.element = props.element\r\n    } else {\r\n      if (!TextEditorElement) TextEditorElement = require('./text-editor-element')\r\n      this.element = new TextEditorElement()\r\n    }\r\n    this.element.initialize(this)\r\n    this.virtualNode = $('atom-text-editor')\r\n    this.virtualNode.domNode = this.element\r\n    this.refs = {}\r\n\r\n    this.updateSync = this.updateSync.bind(this)\r\n    this.didBlurHiddenInput = this.didBlurHiddenInput.bind(this)\r\n    this.didFocusHiddenInput = this.didFocusHiddenInput.bind(this)\r\n    this.didPaste = this.didPaste.bind(this)\r\n    this.didTextInput = this.didTextInput.bind(this)\r\n    this.didKeydown = this.didKeydown.bind(this)\r\n    this.didKeyup = this.didKeyup.bind(this)\r\n    this.didKeypress = this.didKeypress.bind(this)\r\n    this.didCompositionStart = this.didCompositionStart.bind(this)\r\n    this.didCompositionUpdate = this.didCompositionUpdate.bind(this)\r\n    this.didCompositionEnd = this.didCompositionEnd.bind(this)\r\n\r\n    this.updatedSynchronously = this.props.updatedSynchronously\r\n    this.didScrollDummyScrollbar = this.didScrollDummyScrollbar.bind(this)\r\n    this.didMouseDownOnContent = this.didMouseDownOnContent.bind(this)\r\n    this.debouncedResumeCursorBlinking = debounce(\r\n      this.resumeCursorBlinking.bind(this),\r\n      (this.props.cursorBlinkResumeDelay || CURSOR_BLINK_RESUME_DELAY)\r\n    )\r\n    this.lineTopIndex = new LineTopIndex()\r\n    this.lineNodesPool = new NodePool()\r\n    this.updateScheduled = false\r\n    this.suppressUpdates = false\r\n    this.hasInitialMeasurements = false\r\n    this.measurements = {\r\n      lineHeight: 0,\r\n      baseCharacterWidth: 0,\r\n      doubleWidthCharacterWidth: 0,\r\n      halfWidthCharacterWidth: 0,\r\n      koreanCharacterWidth: 0,\r\n      gutterContainerWidth: 0,\r\n      lineNumberGutterWidth: 0,\r\n      clientContainerHeight: 0,\r\n      clientContainerWidth: 0,\r\n      verticalScrollbarWidth: 0,\r\n      horizontalScrollbarHeight: 0,\r\n      longestLineWidth: 0\r\n    }\r\n    this.derivedDimensionsCache = {}\r\n    this.visible = false\r\n    this.cursorsBlinking = false\r\n    this.cursorsBlinkedOff = false\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    this.linesToMeasure = new Map()\r\n    this.extraRenderedScreenLines = new Map()\r\n    this.horizontalPositionsToMeasure = new Map() // Keys are rows with positions we want to measure, values are arrays of columns to measure\r\n    this.horizontalPixelPositionsByScreenLineId = new Map() // Values are maps from column to horizontal pixel positions\r\n    this.blockDecorationsToMeasure = new Set()\r\n    this.blockDecorationsByElement = new WeakMap()\r\n    this.blockDecorationSentinel = document.createElement('div')\r\n    this.blockDecorationSentinel.style.height = '1px'\r\n    this.heightsByBlockDecoration = new WeakMap()\r\n    this.blockDecorationResizeObserver = new ResizeObserver(this.didResizeBlockDecorations.bind(this))\r\n    this.lineComponentsByScreenLineId = new Map()\r\n    this.overlayComponents = new Set()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.remeasureScrollbars = false\r\n    this.pendingAutoscroll = null\r\n    this.scrollTopPending = false\r\n    this.scrollLeftPending = false\r\n    this.scrollTop = 0\r\n    this.scrollLeft = 0\r\n    this.previousScrollWidth = 0\r\n    this.previousScrollHeight = 0\r\n    this.lastKeydown = null\r\n    this.lastKeydownBeforeKeypress = null\r\n    this.accentedCharacterMenuIsOpen = false\r\n    this.remeasureGutterDimensions = false\r\n    this.guttersToRender = [this.props.model.getLineNumberGutter()]\r\n    this.guttersVisibility = [this.guttersToRender[0].visible]\r\n    this.idsByTileStartRow = new Map()\r\n    this.nextTileId = 0\r\n    this.renderedTileStartRows = []\r\n    this.showLineNumbers = this.props.model.doesShowLineNumbers()\r\n    this.lineNumbersToRender = {\r\n      maxDigits: 2,\r\n      bufferRows: [],\r\n      screenRows: [],\r\n      keys: [],\r\n      softWrappedFlags: [],\r\n      foldableFlags: []\r\n    }\r\n    this.decorationsToRender = {\r\n      lineNumbers: new Map(),\r\n      lines: null,\r\n      highlights: [],\r\n      cursors: [],\r\n      overlays: [],\r\n      customGutter: new Map(),\r\n      blocks: new Map(),\r\n      text: []\r\n    }\r\n    this.decorationsToMeasure = {\r\n      highlights: [],\r\n      cursors: new Map()\r\n    }\r\n    this.textDecorationsByMarker = new Map()\r\n    this.textDecorationBoundaries = []\r\n    this.pendingScrollTopRow = this.props.initialScrollTopRow\r\n    this.pendingScrollLeftColumn = this.props.initialScrollLeftColumn\r\n    this.tabIndex = this.props.element && this.props.element.tabIndex ? this.props.element.tabIndex : -1\r\n\r\n    this.measuredContent = false\r\n    this.queryGuttersToRender()\r\n    this.queryMaxLineNumberDigits()\r\n    this.observeBlockDecorations()\r\n    this.updateClassList()\r\n    etch.updateSync(this)\r\n  }\r", "name": "observeBlockDecorations", "func_location": "TextEditorComponent.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 179, "func_start_line": 55}}, {"func_info": {"comment": [" Imperatively manipulate the class list of the root element to avoid", " clearing classes assigned by package authors."], "name": "TextEditorComponent.updateClassList", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 857, "start_line": 829}, "call_info": {"func_end_line": 182, "code": "  constructor (props) {\r\n    this.props = props\r\n\r\n    if (!props.model) {\r\n      props.model = new TextEditor({mini: props.mini, readOnly: props.readOnly})\r\n    }\r\n    this.props.model.component = this\r\n\r\n    if (props.element) {\r\n      this.element = props.element\r\n    } else {\r\n      if (!TextEditorElement) TextEditorElement = require('./text-editor-element')\r\n      this.element = new TextEditorElement()\r\n    }\r\n    this.element.initialize(this)\r\n    this.virtualNode = $('atom-text-editor')\r\n    this.virtualNode.domNode = this.element\r\n    this.refs = {}\r\n\r\n    this.updateSync = this.updateSync.bind(this)\r\n    this.didBlurHiddenInput = this.didBlurHiddenInput.bind(this)\r\n    this.didFocusHiddenInput = this.didFocusHiddenInput.bind(this)\r\n    this.didPaste = this.didPaste.bind(this)\r\n    this.didTextInput = this.didTextInput.bind(this)\r\n    this.didKeydown = this.didKeydown.bind(this)\r\n    this.didKeyup = this.didKeyup.bind(this)\r\n    this.didKeypress = this.didKeypress.bind(this)\r\n    this.didCompositionStart = this.didCompositionStart.bind(this)\r\n    this.didCompositionUpdate = this.didCompositionUpdate.bind(this)\r\n    this.didCompositionEnd = this.didCompositionEnd.bind(this)\r\n\r\n    this.updatedSynchronously = this.props.updatedSynchronously\r\n    this.didScrollDummyScrollbar = this.didScrollDummyScrollbar.bind(this)\r\n    this.didMouseDownOnContent = this.didMouseDownOnContent.bind(this)\r\n    this.debouncedResumeCursorBlinking = debounce(\r\n      this.resumeCursorBlinking.bind(this),\r\n      (this.props.cursorBlinkResumeDelay || CURSOR_BLINK_RESUME_DELAY)\r\n    )\r\n    this.lineTopIndex = new LineTopIndex()\r\n    this.lineNodesPool = new NodePool()\r\n    this.updateScheduled = false\r\n    this.suppressUpdates = false\r\n    this.hasInitialMeasurements = false\r\n    this.measurements = {\r\n      lineHeight: 0,\r\n      baseCharacterWidth: 0,\r\n      doubleWidthCharacterWidth: 0,\r\n      halfWidthCharacterWidth: 0,\r\n      koreanCharacterWidth: 0,\r\n      gutterContainerWidth: 0,\r\n      lineNumberGutterWidth: 0,\r\n      clientContainerHeight: 0,\r\n      clientContainerWidth: 0,\r\n      verticalScrollbarWidth: 0,\r\n      horizontalScrollbarHeight: 0,\r\n      longestLineWidth: 0\r\n    }\r\n    this.derivedDimensionsCache = {}\r\n    this.visible = false\r\n    this.cursorsBlinking = false\r\n    this.cursorsBlinkedOff = false\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    this.linesToMeasure = new Map()\r\n    this.extraRenderedScreenLines = new Map()\r\n    this.horizontalPositionsToMeasure = new Map() // Keys are rows with positions we want to measure, values are arrays of columns to measure\r\n    this.horizontalPixelPositionsByScreenLineId = new Map() // Values are maps from column to horizontal pixel positions\r\n    this.blockDecorationsToMeasure = new Set()\r\n    this.blockDecorationsByElement = new WeakMap()\r\n    this.blockDecorationSentinel = document.createElement('div')\r\n    this.blockDecorationSentinel.style.height = '1px'\r\n    this.heightsByBlockDecoration = new WeakMap()\r\n    this.blockDecorationResizeObserver = new ResizeObserver(this.didResizeBlockDecorations.bind(this))\r\n    this.lineComponentsByScreenLineId = new Map()\r\n    this.overlayComponents = new Set()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.remeasureScrollbars = false\r\n    this.pendingAutoscroll = null\r\n    this.scrollTopPending = false\r\n    this.scrollLeftPending = false\r\n    this.scrollTop = 0\r\n    this.scrollLeft = 0\r\n    this.previousScrollWidth = 0\r\n    this.previousScrollHeight = 0\r\n    this.lastKeydown = null\r\n    this.lastKeydownBeforeKeypress = null\r\n    this.accentedCharacterMenuIsOpen = false\r\n    this.remeasureGutterDimensions = false\r\n    this.guttersToRender = [this.props.model.getLineNumberGutter()]\r\n    this.guttersVisibility = [this.guttersToRender[0].visible]\r\n    this.idsByTileStartRow = new Map()\r\n    this.nextTileId = 0\r\n    this.renderedTileStartRows = []\r\n    this.showLineNumbers = this.props.model.doesShowLineNumbers()\r\n    this.lineNumbersToRender = {\r\n      maxDigits: 2,\r\n      bufferRows: [],\r\n      screenRows: [],\r\n      keys: [],\r\n      softWrappedFlags: [],\r\n      foldableFlags: []\r\n    }\r\n    this.decorationsToRender = {\r\n      lineNumbers: new Map(),\r\n      lines: null,\r\n      highlights: [],\r\n      cursors: [],\r\n      overlays: [],\r\n      customGutter: new Map(),\r\n      blocks: new Map(),\r\n      text: []\r\n    }\r\n    this.decorationsToMeasure = {\r\n      highlights: [],\r\n      cursors: new Map()\r\n    }\r\n    this.textDecorationsByMarker = new Map()\r\n    this.textDecorationBoundaries = []\r\n    this.pendingScrollTopRow = this.props.initialScrollTopRow\r\n    this.pendingScrollLeftColumn = this.props.initialScrollLeftColumn\r\n    this.tabIndex = this.props.element && this.props.element.tabIndex ? this.props.element.tabIndex : -1\r\n\r\n    this.measuredContent = false\r\n    this.queryGuttersToRender()\r\n    this.queryMaxLineNumberDigits()\r\n    this.observeBlockDecorations()\r\n    this.updateClassList()\r\n    etch.updateSync(this)\r\n  }\r", "name": "updateClassList", "func_location": "TextEditorComponent.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 180, "func_start_line": 55}}, {"func_info": {"comment": [], "name": "OverlayComponent.didAttach", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4327, "start_line": 4325}, "call_info": {"func_end_line": 4292, "code": "  constructor (props) {\r\n    this.props = props\r\n    this.element = document.createElement('atom-overlay')\r\n    if (this.props.className != null) this.element.classList.add(this.props.className)\r\n    this.element.appendChild(this.props.element)\r\n    this.element.style.position = 'fixed'\r\n    this.element.style.zIndex = 4\r\n    this.element.style.top = (this.props.pixelTop || 0) + 'px'\r\n    this.element.style.left = (this.props.pixelLeft || 0) + 'px'\r\n    this.currentContentRect = null\r\n\r\n    // Synchronous DOM updates in response to resize events might trigger a\r\n    // \"loop limit exceeded\" error. We disconnect the observer before\r\n    // potentially mutating the DOM, and then reconnect it on the next tick.\r\n    // Note: ResizeObserver calls its callback when .observe is called\r\n    this.resizeObserver = new ResizeObserver((entries) => {\r\n      const {contentRect} = entries[0]\r\n\r\n      if (\r\n        this.currentContentRect &&\r\n        (this.currentContentRect.width !== contentRect.width ||\r\n          this.currentContentRect.height !== contentRect.height)\r\n      ) {\r\n        this.resizeObserver.disconnect()\r\n        this.props.didResize(this)\r\n        process.nextTick(() => { this.resizeObserver.observe(this.props.element) })\r\n      }\r\n\r\n      this.currentContentRect = contentRect\r\n    })\r\n    this.didAttach()\r\n    this.props.overlayComponents.add(this)\r\n  }\r", "name": "didAttach", "func_location": "OverlayComponent.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 4290, "func_start_line": 4260}}, {"func_info": {"comment": [" Lines and block decorations will be manually inserted here for efficiency"], "name": "LinesTileComponent.createLines", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 3717, "start_line": 3697}, "call_info": {"func_end_line": 3657, "code": "  constructor (props) {\r\n    this.props = props\r\n    etch.initialize(this)\r\n    this.createLines()\r\n    this.updateBlockDecorations({}, props)\r\n  }\r", "name": "createLines", "func_location": "LinesTileComponent.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3655, "func_start_line": 3652}}, {"func_info": {"comment": [], "name": "LinesTileComponent.updateBlockDecorations", "params": ["oldProps", "newProps"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 3880, "start_line": 3845}, "call_info": {"func_end_line": 3657, "code": "  constructor (props) {\r\n    this.props = props\r\n    etch.initialize(this)\r\n    this.createLines()\r\n    this.updateBlockDecorations({}, props)\r\n  }\r", "name": "updateBlockDecorations", "func_location": "LinesTileComponent.constructor", "args": [null, "props"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3656, "func_start_line": 3652}}, {"func_info": {"comment": [], "name": "NodePool.constructor", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4416, "start_line": 4413}, "call_info": {"func_end_line": 3197, "name": "constructor", "func_location": "LineNumberGutterComponent.constructor", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3195, "func_start_line": 3190}}, {"func_info": {"comment": [], "name": "LineComponent.buildClassName", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4060, "start_line": 4055}, "call_info": {"func_end_line": 3944, "code": "  constructor (props) {\r\n    const {nodePool, screenRow, screenLine, lineComponentsByScreenLineId, offScreen} = props\r\n    this.props = props\r\n    this.element = nodePool.getElement('DIV', this.buildClassName(), null)\r\n    this.element.dataset.screenRow = screenRow\r\n    this.textNodes = []\r\n\r\n    if (offScreen) {\r\n      this.element.style.position = 'absolute'\r\n      this.element.style.visibility = 'hidden'\r\n      this.element.dataset.offScreen = true\r\n    }\r\n\r\n    this.appendContents()\r\n    lineComponentsByScreenLineId.set(screenLine.id, this)\r\n  }\r", "name": "buildClassName", "func_location": "LineComponent.constructor", "args": [{"type": "string"}, null, {"type": "object"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3932, "func_start_line": 3929}}, {"func_info": {"comment": [], "name": "LineComponent.appendContents", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4039, "start_line": 3975}, "call_info": {"func_end_line": 3944, "code": "  constructor (props) {\r\n    const {nodePool, screenRow, screenLine, lineComponentsByScreenLineId, offScreen} = props\r\n    this.props = props\r\n    this.element = nodePool.getElement('DIV', this.buildClassName(), null)\r\n    this.element.dataset.screenRow = screenRow\r\n    this.textNodes = []\r\n\r\n    if (offScreen) {\r\n      this.element.style.position = 'absolute'\r\n      this.element.style.visibility = 'hidden'\r\n      this.element.dataset.offScreen = true\r\n    }\r\n\r\n    this.appendContents()\r\n    lineComponentsByScreenLineId.set(screenLine.id, this)\r\n  }\r", "name": "appendContents", "func_location": "LineComponent.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3942, "func_start_line": 3929}}, {"func_info": {"comment": [], "name": "HighlightsComponent.update", "params": ["newProps"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4118, "start_line": 4083}, "call_info": {"func_end_line": 4074, "code": "  constructor (props) {\r\n    this.props = {}\r\n    this.element = document.createElement('div')\r\n    this.element.className = 'highlights'\r\n    this.element.style.contain = 'strict'\r\n    this.element.style.position = 'absolute'\r\n    this.element.style.overflow = 'hidden'\r\n    this.element.style.userSelect = 'none'\r\n    this.highlightComponentsByKey = new Map()\r\n    this.update(props)\r\n  }\r", "name": "update", "func_location": "HighlightsComponent.constructor", "args": ["props"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 4073, "func_start_line": 4064}}, {"func_info": {"comment": [], "name": "HighlightComponent.performFlash", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4190, "start_line": 4172}, "call_info": {"func_end_line": 4153, "code": "  constructor (props) {\r\n    this.props = props\r\n    etch.initialize(this)\r\n    if (this.props.flashRequested) this.performFlash()\r\n  }\r", "name": "performFlash", "func_location": "HighlightComponent.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 4152, "func_start_line": 4149}}, {"func_info": {"comment": [], "name": "Config.clear", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 438, "start_line": 419}, "call_info": {"func_end_line": 406, "comment": [" Created during initialization, available as `atom.config`"], "code": "  constructor (params = {}) {\r\n    this.clear()\r\n    this.initialize(params)\r\n  }\r", "name": "clear", "func_location": "Config.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 404, "func_start_line": 403}}, {"func_info": {"comment": [], "name": "Config.initialize", "params": [["saveCallback", "mainSource", "projectHomeSchema"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 417, "start_line": 408}, "call_info": {"func_end_line": 406, "comment": [" Created during initialization, available as `atom.config`"], "code": "  constructor (params = {}) {\r\n    this.clear()\r\n    this.initialize(params)\r\n  }\r", "name": "initialize", "func_location": "Config.constructor", "args": ["params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 405, "func_start_line": 403}}, {"func_info": {"comment": [" Windows users can right-click Atom taskbar and remove project from the jump list.", " We have to honor that or the group stops working. As we only get a partial list", " each time we remove them from history entirely."], "name": "ReopenProjectMenuManager.applyWindowsJumpListRemovals", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js", "end_line": 73, "start_line": 60}, "call_info": {"func_end_line": 23, "code": "  constructor ({menu, commands, history, config, open}) {\r\n    this.menuManager = menu\r\n    this.historyManager = history\r\n    this.config = config\r\n    this.open = open\r\n    this.projects = []\r\n\r\n    this.subscriptions = new CompositeDisposable()\r\n    this.subscriptions.add(\r\n      history.onDidChangeProjects(this.update.bind(this)),\r\n      config.onDidChange('core.reopenProjectMenuCount', ({oldValue, newValue}) => {\r\n        this.update()\r\n      }),\r\n      commands.add('atom-workspace', { 'application:reopen-project': this.reopenProjectCommand.bind(this) })\r\n    )\r\n\r\n    this.applyWindowsJumpListRemovals()\r\n  }\r", "name": "applyWindowsJumpListRemovals", "func_location": "ReopenProjectMenuManager.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js", "line": 22, "func_start_line": 6}}, {"func_info": {"comment": [], "name": "AtomWindow.shouldAddCustomTitleBar", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "end_line": 312, "start_line": 306}, "call_info": {"func_end_line": 138, "code": "  constructor (atomApplication, fileRecoveryService, settings = {}) {\r\n    super()\r\n\r\n    this.id = nextId++\r\n    this.atomApplication = atomApplication\r\n    this.fileRecoveryService = fileRecoveryService\r\n    this.isSpec = settings.isSpec\r\n    this.headless = settings.headless\r\n    this.safeMode = settings.safeMode\r\n    this.devMode = settings.devMode\r\n    this.resourcePath = settings.resourcePath\r\n\r\n    let {pathToOpen, locationsToOpen} = settings\r\n    if (!locationsToOpen && pathToOpen) locationsToOpen = [{pathToOpen}]\r\n    if (!locationsToOpen) locationsToOpen = []\r\n\r\n    this.loadedPromise = new Promise(resolve => { this.resolveLoadedPromise = resolve })\r\n    this.closedPromise = new Promise(resolve => { this.resolveClosedPromise = resolve })\r\n\r\n    const options = {\r\n      show: false,\r\n      title: 'Atom',\r\n      tabbingIdentifier: 'atom',\r\n      webPreferences: {\r\n        // Prevent specs from throttling when the window is in the background:\r\n        // this should result in faster CI builds, and an improvement in the\r\n        // local development experience when running specs through the UI (which\r\n        // now won't pause when e.g. minimizing the window).\r\n        backgroundThrottling: !this.isSpec,\r\n        // Disable the `auxclick` feature so that `click` events are triggered in\r\n        // response to a middle-click.\r\n        // (Ref: https://github.com/atom/atom/pull/12696#issuecomment-290496960)\r\n        disableBlinkFeatures: 'Auxclick'\r\n      }\r\n    }\r\n\r\n    // Don't set icon on Windows so the exe's ico will be used as window and\r\n    // taskbar's icon. See https://github.com/atom/atom/issues/4811 for more.\r\n    if (process.platform === 'linux') options.icon = ICON_PATH\r\n    if (this.shouldAddCustomTitleBar()) options.titleBarStyle = 'hidden'\r\n    if (this.shouldAddCustomInsetTitleBar()) options.titleBarStyle = 'hiddenInset'\r\n    if (this.shouldHideTitleBar()) options.frame = false\r\n    this.browserWindow = new BrowserWindow(options)\r\n\r\n    Object.defineProperty(this.browserWindow, 'loadSettingsJSON', {\r\n      get: () => JSON.stringify(Object.assign({\r\n        userSettings: !this.isSpec\r\n          ? this.atomApplication.configFile.get()\r\n          : null\r\n      }, this.loadSettings))\r\n    })\r\n\r\n    this.handleEvents()\r\n\r\n    this.loadSettings = Object.assign({}, settings)\r\n    this.loadSettings.appVersion = app.getVersion()\r\n    this.loadSettings.resourcePath = this.resourcePath\r\n    this.loadSettings.atomHome = process.env.ATOM_HOME\r\n    if (this.loadSettings.devMode == null) this.loadSettings.devMode = false\r\n    if (this.loadSettings.safeMode == null) this.loadSettings.safeMode = false\r\n    if (this.loadSettings.clearWindowState == null) this.loadSettings.clearWindowState = false\r\n\r\n    if (!this.loadSettings.initialPaths) {\r\n      this.loadSettings.initialPaths = []\r\n      for (const {pathToOpen, stat} of locationsToOpen) {\r\n        if (!pathToOpen) continue\r\n        if (stat && stat.isDirectory()) {\r\n          this.loadSettings.initialPaths.push(pathToOpen)\r\n        } else {\r\n          const parentDirectory = path.dirname(pathToOpen)\r\n          if (stat && stat.isFile() || fs.existsSync(parentDirectory)) {\r\n            this.loadSettings.initialPaths.push(parentDirectory)\r\n          } else {\r\n            this.loadSettings.initialPaths.push(pathToOpen)\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    this.loadSettings.initialPaths.sort()\r\n\r\n    // Only send to the first non-spec window created\r\n    if (includeShellLoadTime && !this.isSpec) {\r\n      includeShellLoadTime = false\r\n      if (!this.loadSettings.shellLoadTime) {\r\n        this.loadSettings.shellLoadTime = Date.now() - global.shellStartTime\r\n      }\r\n    }\r\n\r\n    this.representedDirectoryPaths = this.loadSettings.initialPaths\r\n    if (!this.loadSettings.env) this.env = this.loadSettings.env\r\n\r\n    this.browserWindow.on('window:loaded', () => {\r\n      this.disableZoom()\r\n      this.emit('window:loaded')\r\n      this.resolveLoadedPromise()\r\n    })\r\n\r\n    this.browserWindow.on('window:locations-opened', () => {\r\n      this.emit('window:locations-opened')\r\n    })\r\n\r\n    this.browserWindow.on('enter-full-screen', () => {\r\n      this.browserWindow.webContents.send('did-enter-full-screen')\r\n    })\r\n\r\n    this.browserWindow.on('leave-full-screen', () => {\r\n      this.browserWindow.webContents.send('did-leave-full-screen')\r\n    })\r\n\r\n    this.browserWindow.loadURL(\r\n      url.format({\r\n        protocol: 'file',\r\n        pathname: `${this.resourcePath}/static/index.html`,\r\n        slashes: true\r\n      })\r\n    )\r\n\r\n    this.browserWindow.showSaveDialog = this.showSaveDialog.bind(this)\r\n\r\n    if (this.isSpec) this.browserWindow.focusOnWebView()\r\n\r\n    const hasPathToOpen = !(locationsToOpen.length === 1 && locationsToOpen[0].pathToOpen == null)\r\n    if (hasPathToOpen && !this.isSpecWindow()) this.openLocations(locationsToOpen)\r\n  }\r", "name": "shouldAddCustomTitleBar", "func_location": "AtomWindow.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "line": 53, "func_start_line": 14}}, {"func_info": {"comment": [], "name": "AtomWindow.shouldAddCustomInsetTitleBar", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "end_line": 320, "start_line": 314}, "call_info": {"func_end_line": 138, "code": "  constructor (atomApplication, fileRecoveryService, settings = {}) {\r\n    super()\r\n\r\n    this.id = nextId++\r\n    this.atomApplication = atomApplication\r\n    this.fileRecoveryService = fileRecoveryService\r\n    this.isSpec = settings.isSpec\r\n    this.headless = settings.headless\r\n    this.safeMode = settings.safeMode\r\n    this.devMode = settings.devMode\r\n    this.resourcePath = settings.resourcePath\r\n\r\n    let {pathToOpen, locationsToOpen} = settings\r\n    if (!locationsToOpen && pathToOpen) locationsToOpen = [{pathToOpen}]\r\n    if (!locationsToOpen) locationsToOpen = []\r\n\r\n    this.loadedPromise = new Promise(resolve => { this.resolveLoadedPromise = resolve })\r\n    this.closedPromise = new Promise(resolve => { this.resolveClosedPromise = resolve })\r\n\r\n    const options = {\r\n      show: false,\r\n      title: 'Atom',\r\n      tabbingIdentifier: 'atom',\r\n      webPreferences: {\r\n        // Prevent specs from throttling when the window is in the background:\r\n        // this should result in faster CI builds, and an improvement in the\r\n        // local development experience when running specs through the UI (which\r\n        // now won't pause when e.g. minimizing the window).\r\n        backgroundThrottling: !this.isSpec,\r\n        // Disable the `auxclick` feature so that `click` events are triggered in\r\n        // response to a middle-click.\r\n        // (Ref: https://github.com/atom/atom/pull/12696#issuecomment-290496960)\r\n        disableBlinkFeatures: 'Auxclick'\r\n      }\r\n    }\r\n\r\n    // Don't set icon on Windows so the exe's ico will be used as window and\r\n    // taskbar's icon. See https://github.com/atom/atom/issues/4811 for more.\r\n    if (process.platform === 'linux') options.icon = ICON_PATH\r\n    if (this.shouldAddCustomTitleBar()) options.titleBarStyle = 'hidden'\r\n    if (this.shouldAddCustomInsetTitleBar()) options.titleBarStyle = 'hiddenInset'\r\n    if (this.shouldHideTitleBar()) options.frame = false\r\n    this.browserWindow = new BrowserWindow(options)\r\n\r\n    Object.defineProperty(this.browserWindow, 'loadSettingsJSON', {\r\n      get: () => JSON.stringify(Object.assign({\r\n        userSettings: !this.isSpec\r\n          ? this.atomApplication.configFile.get()\r\n          : null\r\n      }, this.loadSettings))\r\n    })\r\n\r\n    this.handleEvents()\r\n\r\n    this.loadSettings = Object.assign({}, settings)\r\n    this.loadSettings.appVersion = app.getVersion()\r\n    this.loadSettings.resourcePath = this.resourcePath\r\n    this.loadSettings.atomHome = process.env.ATOM_HOME\r\n    if (this.loadSettings.devMode == null) this.loadSettings.devMode = false\r\n    if (this.loadSettings.safeMode == null) this.loadSettings.safeMode = false\r\n    if (this.loadSettings.clearWindowState == null) this.loadSettings.clearWindowState = false\r\n\r\n    if (!this.loadSettings.initialPaths) {\r\n      this.loadSettings.initialPaths = []\r\n      for (const {pathToOpen, stat} of locationsToOpen) {\r\n        if (!pathToOpen) continue\r\n        if (stat && stat.isDirectory()) {\r\n          this.loadSettings.initialPaths.push(pathToOpen)\r\n        } else {\r\n          const parentDirectory = path.dirname(pathToOpen)\r\n          if (stat && stat.isFile() || fs.existsSync(parentDirectory)) {\r\n            this.loadSettings.initialPaths.push(parentDirectory)\r\n          } else {\r\n            this.loadSettings.initialPaths.push(pathToOpen)\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    this.loadSettings.initialPaths.sort()\r\n\r\n    // Only send to the first non-spec window created\r\n    if (includeShellLoadTime && !this.isSpec) {\r\n      includeShellLoadTime = false\r\n      if (!this.loadSettings.shellLoadTime) {\r\n        this.loadSettings.shellLoadTime = Date.now() - global.shellStartTime\r\n      }\r\n    }\r\n\r\n    this.representedDirectoryPaths = this.loadSettings.initialPaths\r\n    if (!this.loadSettings.env) this.env = this.loadSettings.env\r\n\r\n    this.browserWindow.on('window:loaded', () => {\r\n      this.disableZoom()\r\n      this.emit('window:loaded')\r\n      this.resolveLoadedPromise()\r\n    })\r\n\r\n    this.browserWindow.on('window:locations-opened', () => {\r\n      this.emit('window:locations-opened')\r\n    })\r\n\r\n    this.browserWindow.on('enter-full-screen', () => {\r\n      this.browserWindow.webContents.send('did-enter-full-screen')\r\n    })\r\n\r\n    this.browserWindow.on('leave-full-screen', () => {\r\n      this.browserWindow.webContents.send('did-leave-full-screen')\r\n    })\r\n\r\n    this.browserWindow.loadURL(\r\n      url.format({\r\n        protocol: 'file',\r\n        pathname: `${this.resourcePath}/static/index.html`,\r\n        slashes: true\r\n      })\r\n    )\r\n\r\n    this.browserWindow.showSaveDialog = this.showSaveDialog.bind(this)\r\n\r\n    if (this.isSpec) this.browserWindow.focusOnWebView()\r\n\r\n    const hasPathToOpen = !(locationsToOpen.length === 1 && locationsToOpen[0].pathToOpen == null)\r\n    if (hasPathToOpen && !this.isSpecWindow()) this.openLocations(locationsToOpen)\r\n  }\r", "name": "shouldAddCustomInsetTitleBar", "func_location": "AtomWindow.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "line": 54, "func_start_line": 14}}, {"func_info": {"comment": [], "name": "AtomWindow.shouldHideTitleBar", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "end_line": 328, "start_line": 322}, "call_info": {"func_end_line": 138, "code": "  constructor (atomApplication, fileRecoveryService, settings = {}) {\r\n    super()\r\n\r\n    this.id = nextId++\r\n    this.atomApplication = atomApplication\r\n    this.fileRecoveryService = fileRecoveryService\r\n    this.isSpec = settings.isSpec\r\n    this.headless = settings.headless\r\n    this.safeMode = settings.safeMode\r\n    this.devMode = settings.devMode\r\n    this.resourcePath = settings.resourcePath\r\n\r\n    let {pathToOpen, locationsToOpen} = settings\r\n    if (!locationsToOpen && pathToOpen) locationsToOpen = [{pathToOpen}]\r\n    if (!locationsToOpen) locationsToOpen = []\r\n\r\n    this.loadedPromise = new Promise(resolve => { this.resolveLoadedPromise = resolve })\r\n    this.closedPromise = new Promise(resolve => { this.resolveClosedPromise = resolve })\r\n\r\n    const options = {\r\n      show: false,\r\n      title: 'Atom',\r\n      tabbingIdentifier: 'atom',\r\n      webPreferences: {\r\n        // Prevent specs from throttling when the window is in the background:\r\n        // this should result in faster CI builds, and an improvement in the\r\n        // local development experience when running specs through the UI (which\r\n        // now won't pause when e.g. minimizing the window).\r\n        backgroundThrottling: !this.isSpec,\r\n        // Disable the `auxclick` feature so that `click` events are triggered in\r\n        // response to a middle-click.\r\n        // (Ref: https://github.com/atom/atom/pull/12696#issuecomment-290496960)\r\n        disableBlinkFeatures: 'Auxclick'\r\n      }\r\n    }\r\n\r\n    // Don't set icon on Windows so the exe's ico will be used as window and\r\n    // taskbar's icon. See https://github.com/atom/atom/issues/4811 for more.\r\n    if (process.platform === 'linux') options.icon = ICON_PATH\r\n    if (this.shouldAddCustomTitleBar()) options.titleBarStyle = 'hidden'\r\n    if (this.shouldAddCustomInsetTitleBar()) options.titleBarStyle = 'hiddenInset'\r\n    if (this.shouldHideTitleBar()) options.frame = false\r\n    this.browserWindow = new BrowserWindow(options)\r\n\r\n    Object.defineProperty(this.browserWindow, 'loadSettingsJSON', {\r\n      get: () => JSON.stringify(Object.assign({\r\n        userSettings: !this.isSpec\r\n          ? this.atomApplication.configFile.get()\r\n          : null\r\n      }, this.loadSettings))\r\n    })\r\n\r\n    this.handleEvents()\r\n\r\n    this.loadSettings = Object.assign({}, settings)\r\n    this.loadSettings.appVersion = app.getVersion()\r\n    this.loadSettings.resourcePath = this.resourcePath\r\n    this.loadSettings.atomHome = process.env.ATOM_HOME\r\n    if (this.loadSettings.devMode == null) this.loadSettings.devMode = false\r\n    if (this.loadSettings.safeMode == null) this.loadSettings.safeMode = false\r\n    if (this.loadSettings.clearWindowState == null) this.loadSettings.clearWindowState = false\r\n\r\n    if (!this.loadSettings.initialPaths) {\r\n      this.loadSettings.initialPaths = []\r\n      for (const {pathToOpen, stat} of locationsToOpen) {\r\n        if (!pathToOpen) continue\r\n        if (stat && stat.isDirectory()) {\r\n          this.loadSettings.initialPaths.push(pathToOpen)\r\n        } else {\r\n          const parentDirectory = path.dirname(pathToOpen)\r\n          if (stat && stat.isFile() || fs.existsSync(parentDirectory)) {\r\n            this.loadSettings.initialPaths.push(parentDirectory)\r\n          } else {\r\n            this.loadSettings.initialPaths.push(pathToOpen)\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    this.loadSettings.initialPaths.sort()\r\n\r\n    // Only send to the first non-spec window created\r\n    if (includeShellLoadTime && !this.isSpec) {\r\n      includeShellLoadTime = false\r\n      if (!this.loadSettings.shellLoadTime) {\r\n        this.loadSettings.shellLoadTime = Date.now() - global.shellStartTime\r\n      }\r\n    }\r\n\r\n    this.representedDirectoryPaths = this.loadSettings.initialPaths\r\n    if (!this.loadSettings.env) this.env = this.loadSettings.env\r\n\r\n    this.browserWindow.on('window:loaded', () => {\r\n      this.disableZoom()\r\n      this.emit('window:loaded')\r\n      this.resolveLoadedPromise()\r\n    })\r\n\r\n    this.browserWindow.on('window:locations-opened', () => {\r\n      this.emit('window:locations-opened')\r\n    })\r\n\r\n    this.browserWindow.on('enter-full-screen', () => {\r\n      this.browserWindow.webContents.send('did-enter-full-screen')\r\n    })\r\n\r\n    this.browserWindow.on('leave-full-screen', () => {\r\n      this.browserWindow.webContents.send('did-leave-full-screen')\r\n    })\r\n\r\n    this.browserWindow.loadURL(\r\n      url.format({\r\n        protocol: 'file',\r\n        pathname: `${this.resourcePath}/static/index.html`,\r\n        slashes: true\r\n      })\r\n    )\r\n\r\n    this.browserWindow.showSaveDialog = this.showSaveDialog.bind(this)\r\n\r\n    if (this.isSpec) this.browserWindow.focusOnWebView()\r\n\r\n    const hasPathToOpen = !(locationsToOpen.length === 1 && locationsToOpen[0].pathToOpen == null)\r\n    if (hasPathToOpen && !this.isSpecWindow()) this.openLocations(locationsToOpen)\r\n  }\r", "name": "shouldHideTitleBar", "func_location": "AtomWindow.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "line": 55, "func_start_line": 14}}, {"func_info": {"comment": [], "name": "AtomWindow.handleEvents", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "end_line": 225, "start_line": 167}, "call_info": {"func_end_line": 138, "code": "  constructor (atomApplication, fileRecoveryService, settings = {}) {\r\n    super()\r\n\r\n    this.id = nextId++\r\n    this.atomApplication = atomApplication\r\n    this.fileRecoveryService = fileRecoveryService\r\n    this.isSpec = settings.isSpec\r\n    this.headless = settings.headless\r\n    this.safeMode = settings.safeMode\r\n    this.devMode = settings.devMode\r\n    this.resourcePath = settings.resourcePath\r\n\r\n    let {pathToOpen, locationsToOpen} = settings\r\n    if (!locationsToOpen && pathToOpen) locationsToOpen = [{pathToOpen}]\r\n    if (!locationsToOpen) locationsToOpen = []\r\n\r\n    this.loadedPromise = new Promise(resolve => { this.resolveLoadedPromise = resolve })\r\n    this.closedPromise = new Promise(resolve => { this.resolveClosedPromise = resolve })\r\n\r\n    const options = {\r\n      show: false,\r\n      title: 'Atom',\r\n      tabbingIdentifier: 'atom',\r\n      webPreferences: {\r\n        // Prevent specs from throttling when the window is in the background:\r\n        // this should result in faster CI builds, and an improvement in the\r\n        // local development experience when running specs through the UI (which\r\n        // now won't pause when e.g. minimizing the window).\r\n        backgroundThrottling: !this.isSpec,\r\n        // Disable the `auxclick` feature so that `click` events are triggered in\r\n        // response to a middle-click.\r\n        // (Ref: https://github.com/atom/atom/pull/12696#issuecomment-290496960)\r\n        disableBlinkFeatures: 'Auxclick'\r\n      }\r\n    }\r\n\r\n    // Don't set icon on Windows so the exe's ico will be used as window and\r\n    // taskbar's icon. See https://github.com/atom/atom/issues/4811 for more.\r\n    if (process.platform === 'linux') options.icon = ICON_PATH\r\n    if (this.shouldAddCustomTitleBar()) options.titleBarStyle = 'hidden'\r\n    if (this.shouldAddCustomInsetTitleBar()) options.titleBarStyle = 'hiddenInset'\r\n    if (this.shouldHideTitleBar()) options.frame = false\r\n    this.browserWindow = new BrowserWindow(options)\r\n\r\n    Object.defineProperty(this.browserWindow, 'loadSettingsJSON', {\r\n      get: () => JSON.stringify(Object.assign({\r\n        userSettings: !this.isSpec\r\n          ? this.atomApplication.configFile.get()\r\n          : null\r\n      }, this.loadSettings))\r\n    })\r\n\r\n    this.handleEvents()\r\n\r\n    this.loadSettings = Object.assign({}, settings)\r\n    this.loadSettings.appVersion = app.getVersion()\r\n    this.loadSettings.resourcePath = this.resourcePath\r\n    this.loadSettings.atomHome = process.env.ATOM_HOME\r\n    if (this.loadSettings.devMode == null) this.loadSettings.devMode = false\r\n    if (this.loadSettings.safeMode == null) this.loadSettings.safeMode = false\r\n    if (this.loadSettings.clearWindowState == null) this.loadSettings.clearWindowState = false\r\n\r\n    if (!this.loadSettings.initialPaths) {\r\n      this.loadSettings.initialPaths = []\r\n      for (const {pathToOpen, stat} of locationsToOpen) {\r\n        if (!pathToOpen) continue\r\n        if (stat && stat.isDirectory()) {\r\n          this.loadSettings.initialPaths.push(pathToOpen)\r\n        } else {\r\n          const parentDirectory = path.dirname(pathToOpen)\r\n          if (stat && stat.isFile() || fs.existsSync(parentDirectory)) {\r\n            this.loadSettings.initialPaths.push(parentDirectory)\r\n          } else {\r\n            this.loadSettings.initialPaths.push(pathToOpen)\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    this.loadSettings.initialPaths.sort()\r\n\r\n    // Only send to the first non-spec window created\r\n    if (includeShellLoadTime && !this.isSpec) {\r\n      includeShellLoadTime = false\r\n      if (!this.loadSettings.shellLoadTime) {\r\n        this.loadSettings.shellLoadTime = Date.now() - global.shellStartTime\r\n      }\r\n    }\r\n\r\n    this.representedDirectoryPaths = this.loadSettings.initialPaths\r\n    if (!this.loadSettings.env) this.env = this.loadSettings.env\r\n\r\n    this.browserWindow.on('window:loaded', () => {\r\n      this.disableZoom()\r\n      this.emit('window:loaded')\r\n      this.resolveLoadedPromise()\r\n    })\r\n\r\n    this.browserWindow.on('window:locations-opened', () => {\r\n      this.emit('window:locations-opened')\r\n    })\r\n\r\n    this.browserWindow.on('enter-full-screen', () => {\r\n      this.browserWindow.webContents.send('did-enter-full-screen')\r\n    })\r\n\r\n    this.browserWindow.on('leave-full-screen', () => {\r\n      this.browserWindow.webContents.send('did-leave-full-screen')\r\n    })\r\n\r\n    this.browserWindow.loadURL(\r\n      url.format({\r\n        protocol: 'file',\r\n        pathname: `${this.resourcePath}/static/index.html`,\r\n        slashes: true\r\n      })\r\n    )\r\n\r\n    this.browserWindow.showSaveDialog = this.showSaveDialog.bind(this)\r\n\r\n    if (this.isSpec) this.browserWindow.focusOnWebView()\r\n\r\n    const hasPathToOpen = !(locationsToOpen.length === 1 && locationsToOpen[0].pathToOpen == null)\r\n    if (hasPathToOpen && !this.isSpecWindow()) this.openLocations(locationsToOpen)\r\n  }\r", "name": "handleEvents", "func_location": "AtomWindow.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "line": 66, "func_start_line": 14}}, {"func_info": {"comment": [], "name": "AtomWindow.isSpecWindow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "end_line": 384, "start_line": 382}, "call_info": {"func_end_line": 138, "code": "  constructor (atomApplication, fileRecoveryService, settings = {}) {\r\n    super()\r\n\r\n    this.id = nextId++\r\n    this.atomApplication = atomApplication\r\n    this.fileRecoveryService = fileRecoveryService\r\n    this.isSpec = settings.isSpec\r\n    this.headless = settings.headless\r\n    this.safeMode = settings.safeMode\r\n    this.devMode = settings.devMode\r\n    this.resourcePath = settings.resourcePath\r\n\r\n    let {pathToOpen, locationsToOpen} = settings\r\n    if (!locationsToOpen && pathToOpen) locationsToOpen = [{pathToOpen}]\r\n    if (!locationsToOpen) locationsToOpen = []\r\n\r\n    this.loadedPromise = new Promise(resolve => { this.resolveLoadedPromise = resolve })\r\n    this.closedPromise = new Promise(resolve => { this.resolveClosedPromise = resolve })\r\n\r\n    const options = {\r\n      show: false,\r\n      title: 'Atom',\r\n      tabbingIdentifier: 'atom',\r\n      webPreferences: {\r\n        // Prevent specs from throttling when the window is in the background:\r\n        // this should result in faster CI builds, and an improvement in the\r\n        // local development experience when running specs through the UI (which\r\n        // now won't pause when e.g. minimizing the window).\r\n        backgroundThrottling: !this.isSpec,\r\n        // Disable the `auxclick` feature so that `click` events are triggered in\r\n        // response to a middle-click.\r\n        // (Ref: https://github.com/atom/atom/pull/12696#issuecomment-290496960)\r\n        disableBlinkFeatures: 'Auxclick'\r\n      }\r\n    }\r\n\r\n    // Don't set icon on Windows so the exe's ico will be used as window and\r\n    // taskbar's icon. See https://github.com/atom/atom/issues/4811 for more.\r\n    if (process.platform === 'linux') options.icon = ICON_PATH\r\n    if (this.shouldAddCustomTitleBar()) options.titleBarStyle = 'hidden'\r\n    if (this.shouldAddCustomInsetTitleBar()) options.titleBarStyle = 'hiddenInset'\r\n    if (this.shouldHideTitleBar()) options.frame = false\r\n    this.browserWindow = new BrowserWindow(options)\r\n\r\n    Object.defineProperty(this.browserWindow, 'loadSettingsJSON', {\r\n      get: () => JSON.stringify(Object.assign({\r\n        userSettings: !this.isSpec\r\n          ? this.atomApplication.configFile.get()\r\n          : null\r\n      }, this.loadSettings))\r\n    })\r\n\r\n    this.handleEvents()\r\n\r\n    this.loadSettings = Object.assign({}, settings)\r\n    this.loadSettings.appVersion = app.getVersion()\r\n    this.loadSettings.resourcePath = this.resourcePath\r\n    this.loadSettings.atomHome = process.env.ATOM_HOME\r\n    if (this.loadSettings.devMode == null) this.loadSettings.devMode = false\r\n    if (this.loadSettings.safeMode == null) this.loadSettings.safeMode = false\r\n    if (this.loadSettings.clearWindowState == null) this.loadSettings.clearWindowState = false\r\n\r\n    if (!this.loadSettings.initialPaths) {\r\n      this.loadSettings.initialPaths = []\r\n      for (const {pathToOpen, stat} of locationsToOpen) {\r\n        if (!pathToOpen) continue\r\n        if (stat && stat.isDirectory()) {\r\n          this.loadSettings.initialPaths.push(pathToOpen)\r\n        } else {\r\n          const parentDirectory = path.dirname(pathToOpen)\r\n          if (stat && stat.isFile() || fs.existsSync(parentDirectory)) {\r\n            this.loadSettings.initialPaths.push(parentDirectory)\r\n          } else {\r\n            this.loadSettings.initialPaths.push(pathToOpen)\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    this.loadSettings.initialPaths.sort()\r\n\r\n    // Only send to the first non-spec window created\r\n    if (includeShellLoadTime && !this.isSpec) {\r\n      includeShellLoadTime = false\r\n      if (!this.loadSettings.shellLoadTime) {\r\n        this.loadSettings.shellLoadTime = Date.now() - global.shellStartTime\r\n      }\r\n    }\r\n\r\n    this.representedDirectoryPaths = this.loadSettings.initialPaths\r\n    if (!this.loadSettings.env) this.env = this.loadSettings.env\r\n\r\n    this.browserWindow.on('window:loaded', () => {\r\n      this.disableZoom()\r\n      this.emit('window:loaded')\r\n      this.resolveLoadedPromise()\r\n    })\r\n\r\n    this.browserWindow.on('window:locations-opened', () => {\r\n      this.emit('window:locations-opened')\r\n    })\r\n\r\n    this.browserWindow.on('enter-full-screen', () => {\r\n      this.browserWindow.webContents.send('did-enter-full-screen')\r\n    })\r\n\r\n    this.browserWindow.on('leave-full-screen', () => {\r\n      this.browserWindow.webContents.send('did-leave-full-screen')\r\n    })\r\n\r\n    this.browserWindow.loadURL(\r\n      url.format({\r\n        protocol: 'file',\r\n        pathname: `${this.resourcePath}/static/index.html`,\r\n        slashes: true\r\n      })\r\n    )\r\n\r\n    this.browserWindow.showSaveDialog = this.showSaveDialog.bind(this)\r\n\r\n    if (this.isSpec) this.browserWindow.focusOnWebView()\r\n\r\n    const hasPathToOpen = !(locationsToOpen.length === 1 && locationsToOpen[0].pathToOpen == null)\r\n    if (hasPathToOpen && !this.isSpecWindow()) this.openLocations(locationsToOpen)\r\n  }\r", "name": "isSpecWindow", "func_location": "AtomWindow.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "line": 137, "func_start_line": 14}}, {"func_info": {"comment": [], "name": "AtomWindow.openLocations", "params": ["locationsToOpen"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "end_line": 255, "start_line": 252}, "call_info": {"func_end_line": 138, "code": "  constructor (atomApplication, fileRecoveryService, settings = {}) {\r\n    super()\r\n\r\n    this.id = nextId++\r\n    this.atomApplication = atomApplication\r\n    this.fileRecoveryService = fileRecoveryService\r\n    this.isSpec = settings.isSpec\r\n    this.headless = settings.headless\r\n    this.safeMode = settings.safeMode\r\n    this.devMode = settings.devMode\r\n    this.resourcePath = settings.resourcePath\r\n\r\n    let {pathToOpen, locationsToOpen} = settings\r\n    if (!locationsToOpen && pathToOpen) locationsToOpen = [{pathToOpen}]\r\n    if (!locationsToOpen) locationsToOpen = []\r\n\r\n    this.loadedPromise = new Promise(resolve => { this.resolveLoadedPromise = resolve })\r\n    this.closedPromise = new Promise(resolve => { this.resolveClosedPromise = resolve })\r\n\r\n    const options = {\r\n      show: false,\r\n      title: 'Atom',\r\n      tabbingIdentifier: 'atom',\r\n      webPreferences: {\r\n        // Prevent specs from throttling when the window is in the background:\r\n        // this should result in faster CI builds, and an improvement in the\r\n        // local development experience when running specs through the UI (which\r\n        // now won't pause when e.g. minimizing the window).\r\n        backgroundThrottling: !this.isSpec,\r\n        // Disable the `auxclick` feature so that `click` events are triggered in\r\n        // response to a middle-click.\r\n        // (Ref: https://github.com/atom/atom/pull/12696#issuecomment-290496960)\r\n        disableBlinkFeatures: 'Auxclick'\r\n      }\r\n    }\r\n\r\n    // Don't set icon on Windows so the exe's ico will be used as window and\r\n    // taskbar's icon. See https://github.com/atom/atom/issues/4811 for more.\r\n    if (process.platform === 'linux') options.icon = ICON_PATH\r\n    if (this.shouldAddCustomTitleBar()) options.titleBarStyle = 'hidden'\r\n    if (this.shouldAddCustomInsetTitleBar()) options.titleBarStyle = 'hiddenInset'\r\n    if (this.shouldHideTitleBar()) options.frame = false\r\n    this.browserWindow = new BrowserWindow(options)\r\n\r\n    Object.defineProperty(this.browserWindow, 'loadSettingsJSON', {\r\n      get: () => JSON.stringify(Object.assign({\r\n        userSettings: !this.isSpec\r\n          ? this.atomApplication.configFile.get()\r\n          : null\r\n      }, this.loadSettings))\r\n    })\r\n\r\n    this.handleEvents()\r\n\r\n    this.loadSettings = Object.assign({}, settings)\r\n    this.loadSettings.appVersion = app.getVersion()\r\n    this.loadSettings.resourcePath = this.resourcePath\r\n    this.loadSettings.atomHome = process.env.ATOM_HOME\r\n    if (this.loadSettings.devMode == null) this.loadSettings.devMode = false\r\n    if (this.loadSettings.safeMode == null) this.loadSettings.safeMode = false\r\n    if (this.loadSettings.clearWindowState == null) this.loadSettings.clearWindowState = false\r\n\r\n    if (!this.loadSettings.initialPaths) {\r\n      this.loadSettings.initialPaths = []\r\n      for (const {pathToOpen, stat} of locationsToOpen) {\r\n        if (!pathToOpen) continue\r\n        if (stat && stat.isDirectory()) {\r\n          this.loadSettings.initialPaths.push(pathToOpen)\r\n        } else {\r\n          const parentDirectory = path.dirname(pathToOpen)\r\n          if (stat && stat.isFile() || fs.existsSync(parentDirectory)) {\r\n            this.loadSettings.initialPaths.push(parentDirectory)\r\n          } else {\r\n            this.loadSettings.initialPaths.push(pathToOpen)\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    this.loadSettings.initialPaths.sort()\r\n\r\n    // Only send to the first non-spec window created\r\n    if (includeShellLoadTime && !this.isSpec) {\r\n      includeShellLoadTime = false\r\n      if (!this.loadSettings.shellLoadTime) {\r\n        this.loadSettings.shellLoadTime = Date.now() - global.shellStartTime\r\n      }\r\n    }\r\n\r\n    this.representedDirectoryPaths = this.loadSettings.initialPaths\r\n    if (!this.loadSettings.env) this.env = this.loadSettings.env\r\n\r\n    this.browserWindow.on('window:loaded', () => {\r\n      this.disableZoom()\r\n      this.emit('window:loaded')\r\n      this.resolveLoadedPromise()\r\n    })\r\n\r\n    this.browserWindow.on('window:locations-opened', () => {\r\n      this.emit('window:locations-opened')\r\n    })\r\n\r\n    this.browserWindow.on('enter-full-screen', () => {\r\n      this.browserWindow.webContents.send('did-enter-full-screen')\r\n    })\r\n\r\n    this.browserWindow.on('leave-full-screen', () => {\r\n      this.browserWindow.webContents.send('did-leave-full-screen')\r\n    })\r\n\r\n    this.browserWindow.loadURL(\r\n      url.format({\r\n        protocol: 'file',\r\n        pathname: `${this.resourcePath}/static/index.html`,\r\n        slashes: true\r\n      })\r\n    )\r\n\r\n    this.browserWindow.showSaveDialog = this.showSaveDialog.bind(this)\r\n\r\n    if (this.isSpec) this.browserWindow.focusOnWebView()\r\n\r\n    const hasPathToOpen = !(locationsToOpen.length === 1 && locationsToOpen[0].pathToOpen == null)\r\n    if (hasPathToOpen && !this.isSpecWindow()) this.openLocations(locationsToOpen)\r\n  }\r", "name": "openLocations", "func_location": "AtomWindow.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "line": 137, "func_start_line": 14}}, {"func_info": {"comment": [], "name": "Clipboard.reset", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/clipboard.js", "end_line": 24, "start_line": 21}, "call_info": {"func_end_line": 19, "code": "  constructor () {\r\n    this.reset()\r\n  }\r", "name": "reset", "func_location": "Clipboard.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/clipboard.js", "line": 18, "func_start_line": 17}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.retokenizeLines", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 263, "start_line": 253}, "call_info": {"func_end_line": 38, "code": "  constructor (params) {\r\n    this.emitter = new Emitter()\r\n    this.disposables = new CompositeDisposable()\r\n    this.tokenIterator = new TokenIterator(this)\r\n    this.regexesByPattern = {}\r\n\r\n    this.alive = true\r\n    this.tokenizationStarted = false\r\n    this.id = params.id != null ? params.id : nextId++\r\n    this.buffer = params.buffer\r\n    this.largeFileMode = params.largeFileMode\r\n    this.config = params.config\r\n    this.largeFileMode = params.largeFileMode != null\r\n      ? params.largeFileMode\r\n      : this.buffer.buffer.getLength() >= 2 * 1024 * 1024\r\n\r\n    this.grammar = params.grammar || NullGrammar\r\n    this.rootScopeDescriptor = new ScopeDescriptor({scopes: [this.grammar.scopeName]})\r\n    this.disposables.add(this.grammar.onDidUpdate(() => this.retokenizeLines()))\r\n    this.retokenizeLines()\r\n  }\r", "name": "retokenizeLines", "func_location": "TextMateLanguageMode.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 37, "func_start_line": 18}}, {"func_info": {"comment": [], "name": "Notification.isDismissable", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js", "end_line": 97, "start_line": 95}, "call_info": {"func_end_line": 17, "code": "  constructor (type, message, options = {}) {\r\n    this.type = type\r\n    this.message = message\r\n    this.options = options\r\n    this.emitter = new Emitter()\r\n    this.timestamp = new Date()\r\n    this.dismissed = true\r\n    if (this.isDismissable()) this.dismissed = false\r\n    this.displayed = false\r\n    this.validate()\r\n  }\r", "name": "isDismissable", "func_location": "Notification.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js", "line": 14, "func_start_line": 7}}, {"func_info": {"comment": [], "name": "Notification.validate", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js", "end_line": 27, "start_line": 19}, "call_info": {"func_end_line": 17, "code": "  constructor (type, message, options = {}) {\r\n    this.type = type\r\n    this.message = message\r\n    this.options = options\r\n    this.emitter = new Emitter()\r\n    this.timestamp = new Date()\r\n    this.dismissed = true\r\n    if (this.isDismissable()) this.dismissed = false\r\n    this.displayed = false\r\n    this.validate()\r\n  }\r", "name": "validate", "func_location": "Notification.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js", "line": 16, "func_start_line": 7}}, {"func_info": {"comment": [], "name": "PaneContainer.setRoot", "params": ["root"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 139, "start_line": 131}, "call_info": {"func_end_line": 23, "code": "  constructor (params) {\r\n    let applicationDelegate, deserializerManager, notificationManager;\r\n    ({config: this.config, applicationDelegate, notificationManager, deserializerManager, viewRegistry: this.viewRegistry, location: this.location} = params)\r\n    this.emitter = new Emitter()\r\n    this.subscriptions = new CompositeDisposable()\r\n    this.itemRegistry = new ItemRegistry()\r\n    this.alive = true\r\n    this.stoppedChangingActivePaneItemTimeout = null\r\n\r\n    this.setRoot(new Pane({container: this, config: this.config, applicationDelegate, notificationManager, deserializerManager, viewRegistry: this.viewRegistry}))\r\n    this.didActivatePane(this.getRoot())\r\n  }\r", "name": "setRoot", "func_location": "PaneContainer.constructor", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 21, "func_start_line": 12}}, {"func_info": {"comment": [], "name": "PaneContainer.didActivatePane", "params": ["activePane"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 263, "start_line": 251}, "call_info": {"func_end_line": 23, "code": "  constructor (params) {\r\n    let applicationDelegate, deserializerManager, notificationManager;\r\n    ({config: this.config, applicationDelegate, notificationManager, deserializerManager, viewRegistry: this.viewRegistry, location: this.location} = params)\r\n    this.emitter = new Emitter()\r\n    this.subscriptions = new CompositeDisposable()\r\n    this.itemRegistry = new ItemRegistry()\r\n    this.alive = true\r\n    this.stoppedChangingActivePaneItemTimeout = null\r\n\r\n    this.setRoot(new Pane({container: this, config: this.config, applicationDelegate, notificationManager, deserializerManager, viewRegistry: this.viewRegistry}))\r\n    this.didActivatePane(this.getRoot())\r\n  }\r", "name": "didActivatePane", "func_location": "PaneContainer.constructor", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 22, "func_start_line": 12}}, {"func_info": {"comment": [], "name": "PaneContainer.getRoot", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 129, "start_line": 129}, "call_info": {"func_end_line": 23, "code": "  constructor (params) {\r\n    let applicationDelegate, deserializerManager, notificationManager;\r\n    ({config: this.config, applicationDelegate, notificationManager, deserializerManager, viewRegistry: this.viewRegistry, location: this.location} = params)\r\n    this.emitter = new Emitter()\r\n    this.subscriptions = new CompositeDisposable()\r\n    this.itemRegistry = new ItemRegistry()\r\n    this.alive = true\r\n    this.stoppedChangingActivePaneItemTimeout = null\r\n\r\n    this.setRoot(new Pane({container: this, config: this.config, applicationDelegate, notificationManager, deserializerManager, viewRegistry: this.viewRegistry}))\r\n    this.didActivatePane(this.getRoot())\r\n  }\r", "name": "getRoot", "func_location": "PaneContainer.constructor", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 22, "func_start_line": 12}}, {"func_info": {"comment": [" It's necessary to build the event handlers in this process, otherwise", " closures are dragged across processes and failed to be garbage collected", " appropriately."], "name": "ContextMenu.createClickHandlers", "params": ["template"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/context-menu.js", "end_line": 32, "start_line": 15}, "call_info": {"func_end_line": 10, "code": "  constructor (template, atomWindow) {\r\n    this.atomWindow = atomWindow\r\n    this.createClickHandlers(template)\r\n    const menu = Menu.buildFromTemplate(template)\r\n    menu.popup(this.atomWindow.browserWindow, {async: true})\r\n  }\r", "name": "createClickHandlers", "func_location": "ContextMenu.constructor", "args": ["template"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/context-menu.js", "line": 7, "func_start_line": 5}}, {"func_info": {"comment": [], "name": "BufferedProcess.start", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "end_line": 76, "start_line": 65}, "call_info": {"func_end_line": 63, "comment": ["\r\n  Section: Construction\r\n  ", " Public: Runs the given command by spawning a new child process.", "", " * `options` An {Object} with the following keys:", "   * `command` The {String} command to execute.", "   * `args` The {Array} of arguments to pass to the command (optional).", "   * `options` {Object} (optional) The options {Object} to pass to Node's", "     `ChildProcess.spawn` method.", "   * `stdout` {Function} (optional) The callback that receives a single", "     argument which contains the standard output from the command. The", "     callback is called as data is received but it's buffered to ensure only", "     complete lines are passed until the source stream closes. After the", "     source stream has closed all remaining data is sent in a final call.", "     * `data` {String}", "   * `stderr` {Function} (optional) The callback that receives a single", "     argument which contains the standard error output from the command. The", "     callback is called as data is received but it's buffered to ensure only", "     complete lines are passed until the source stream closes. After the", "     source stream has closed all remaining data is sent in a final call.", "     * `data` {String}", "   * `exit` {Function} (optional) The callback which receives a single", "     argument containing the exit status.", "     * `code` {Number}", "   * `autoStart` {Boolean} (optional) Whether the command will automatically start", "     when this BufferedProcess is created. Defaults to true.  When set to false you", "     must call the `start` method to start the process."], "code": "  constructor ({command, args, options = {}, stdout, stderr, exit, autoStart = true} = {}) {\r\n    this.emitter = new Emitter()\r\n    this.command = command\r\n    this.args = args\r\n    this.options = options\r\n    this.stdout = stdout\r\n    this.stderr = stderr\r\n    this.exit = exit\r\n    if (autoStart === true) {\r\n      this.start()\r\n    }\r\n    this.killed = false\r\n  }\r", "name": "start", "func_location": "BufferedProcess.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "line": 60, "func_start_line": 51}}, {"func_info": {"comment": [], "name": "Workspace.consumeServices", "params": [["serviceHub"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 335, "start_line": 328}, "call_info": {"func_end_line": 231, "code": "  constructor (params) {\r\n    super(...arguments)\r\n\r\n    this.updateWindowTitle = this.updateWindowTitle.bind(this)\r\n    this.updateDocumentEdited = this.updateDocumentEdited.bind(this)\r\n    this.didDestroyPaneItem = this.didDestroyPaneItem.bind(this)\r\n    this.didChangeActivePaneOnPaneContainer = this.didChangeActivePaneOnPaneContainer.bind(this)\r\n    this.didChangeActivePaneItemOnPaneContainer = this.didChangeActivePaneItemOnPaneContainer.bind(this)\r\n    this.didActivatePaneContainer = this.didActivatePaneContainer.bind(this)\r\n\r\n    this.enablePersistence = params.enablePersistence\r\n    this.packageManager = params.packageManager\r\n    this.config = params.config\r\n    this.project = params.project\r\n    this.notificationManager = params.notificationManager\r\n    this.viewRegistry = params.viewRegistry\r\n    this.grammarRegistry = params.grammarRegistry\r\n    this.applicationDelegate = params.applicationDelegate\r\n    this.assert = params.assert\r\n    this.deserializerManager = params.deserializerManager\r\n    this.textEditorRegistry = params.textEditorRegistry\r\n    this.styleManager = params.styleManager\r\n    this.draggingItem = false\r\n    this.itemLocationStore = new StateStore('AtomPreviousItemLocations', 1)\r\n\r\n    this.emitter = new Emitter()\r\n    this.openers = []\r\n    this.destroyedItemURIs = []\r\n    this.stoppedChangingActivePaneItemTimeout = null\r\n\r\n    this.defaultDirectorySearcher = new DefaultDirectorySearcher()\r\n    this.consumeServices(this.packageManager)\r\n\r\n    this.paneContainers = {\r\n      center: this.createCenter(),\r\n      left: this.createDock('left'),\r\n      right: this.createDock('right'),\r\n      bottom: this.createDock('bottom')\r\n    }\r\n    this.activePaneContainer = this.paneContainers.center\r\n    this.hasActiveTextEditor = false\r\n\r\n    this.panelContainers = {\r\n      top: new PanelContainer({viewRegistry: this.viewRegistry, location: 'top'}),\r\n      left: new PanelContainer({viewRegistry: this.viewRegistry, location: 'left', dock: this.paneContainers.left}),\r\n      right: new PanelContainer({viewRegistry: this.viewRegistry, location: 'right', dock: this.paneContainers.right}),\r\n      bottom: new PanelContainer({viewRegistry: this.viewRegistry, location: 'bottom', dock: this.paneContainers.bottom}),\r\n      header: new PanelContainer({viewRegistry: this.viewRegistry, location: 'header'}),\r\n      footer: new PanelContainer({viewRegistry: this.viewRegistry, location: 'footer'}),\r\n      modal: new PanelContainer({viewRegistry: this.viewRegistry, location: 'modal'})\r\n    }\r\n\r\n    this.incoming = new Map()\r\n\r\n    this.subscribeToEvents()\r\n  }\r", "name": "consumeServices", "func_location": "Workspace.constructor", "args": [".packageManager"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 207, "func_start_line": 176}}, {"func_info": {"comment": [], "name": "Workspace.createCenter", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 262, "start_line": 250}, "call_info": {"func_end_line": 231, "code": "  constructor (params) {\r\n    super(...arguments)\r\n\r\n    this.updateWindowTitle = this.updateWindowTitle.bind(this)\r\n    this.updateDocumentEdited = this.updateDocumentEdited.bind(this)\r\n    this.didDestroyPaneItem = this.didDestroyPaneItem.bind(this)\r\n    this.didChangeActivePaneOnPaneContainer = this.didChangeActivePaneOnPaneContainer.bind(this)\r\n    this.didChangeActivePaneItemOnPaneContainer = this.didChangeActivePaneItemOnPaneContainer.bind(this)\r\n    this.didActivatePaneContainer = this.didActivatePaneContainer.bind(this)\r\n\r\n    this.enablePersistence = params.enablePersistence\r\n    this.packageManager = params.packageManager\r\n    this.config = params.config\r\n    this.project = params.project\r\n    this.notificationManager = params.notificationManager\r\n    this.viewRegistry = params.viewRegistry\r\n    this.grammarRegistry = params.grammarRegistry\r\n    this.applicationDelegate = params.applicationDelegate\r\n    this.assert = params.assert\r\n    this.deserializerManager = params.deserializerManager\r\n    this.textEditorRegistry = params.textEditorRegistry\r\n    this.styleManager = params.styleManager\r\n    this.draggingItem = false\r\n    this.itemLocationStore = new StateStore('AtomPreviousItemLocations', 1)\r\n\r\n    this.emitter = new Emitter()\r\n    this.openers = []\r\n    this.destroyedItemURIs = []\r\n    this.stoppedChangingActivePaneItemTimeout = null\r\n\r\n    this.defaultDirectorySearcher = new DefaultDirectorySearcher()\r\n    this.consumeServices(this.packageManager)\r\n\r\n    this.paneContainers = {\r\n      center: this.createCenter(),\r\n      left: this.createDock('left'),\r\n      right: this.createDock('right'),\r\n      bottom: this.createDock('bottom')\r\n    }\r\n    this.activePaneContainer = this.paneContainers.center\r\n    this.hasActiveTextEditor = false\r\n\r\n    this.panelContainers = {\r\n      top: new PanelContainer({viewRegistry: this.viewRegistry, location: 'top'}),\r\n      left: new PanelContainer({viewRegistry: this.viewRegistry, location: 'left', dock: this.paneContainers.left}),\r\n      right: new PanelContainer({viewRegistry: this.viewRegistry, location: 'right', dock: this.paneContainers.right}),\r\n      bottom: new PanelContainer({viewRegistry: this.viewRegistry, location: 'bottom', dock: this.paneContainers.bottom}),\r\n      header: new PanelContainer({viewRegistry: this.viewRegistry, location: 'header'}),\r\n      footer: new PanelContainer({viewRegistry: this.viewRegistry, location: 'footer'}),\r\n      modal: new PanelContainer({viewRegistry: this.viewRegistry, location: 'modal'})\r\n    }\r\n\r\n    this.incoming = new Map()\r\n\r\n    this.subscribeToEvents()\r\n  }\r", "name": "createCenter", "func_location": "Workspace.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 210, "func_start_line": 176}}, {"func_info": {"comment": [], "name": "Workspace.createDock", "params": ["location"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 277, "start_line": 264}, "call_info": {"func_end_line": 231, "code": "  constructor (params) {\r\n    super(...arguments)\r\n\r\n    this.updateWindowTitle = this.updateWindowTitle.bind(this)\r\n    this.updateDocumentEdited = this.updateDocumentEdited.bind(this)\r\n    this.didDestroyPaneItem = this.didDestroyPaneItem.bind(this)\r\n    this.didChangeActivePaneOnPaneContainer = this.didChangeActivePaneOnPaneContainer.bind(this)\r\n    this.didChangeActivePaneItemOnPaneContainer = this.didChangeActivePaneItemOnPaneContainer.bind(this)\r\n    this.didActivatePaneContainer = this.didActivatePaneContainer.bind(this)\r\n\r\n    this.enablePersistence = params.enablePersistence\r\n    this.packageManager = params.packageManager\r\n    this.config = params.config\r\n    this.project = params.project\r\n    this.notificationManager = params.notificationManager\r\n    this.viewRegistry = params.viewRegistry\r\n    this.grammarRegistry = params.grammarRegistry\r\n    this.applicationDelegate = params.applicationDelegate\r\n    this.assert = params.assert\r\n    this.deserializerManager = params.deserializerManager\r\n    this.textEditorRegistry = params.textEditorRegistry\r\n    this.styleManager = params.styleManager\r\n    this.draggingItem = false\r\n    this.itemLocationStore = new StateStore('AtomPreviousItemLocations', 1)\r\n\r\n    this.emitter = new Emitter()\r\n    this.openers = []\r\n    this.destroyedItemURIs = []\r\n    this.stoppedChangingActivePaneItemTimeout = null\r\n\r\n    this.defaultDirectorySearcher = new DefaultDirectorySearcher()\r\n    this.consumeServices(this.packageManager)\r\n\r\n    this.paneContainers = {\r\n      center: this.createCenter(),\r\n      left: this.createDock('left'),\r\n      right: this.createDock('right'),\r\n      bottom: this.createDock('bottom')\r\n    }\r\n    this.activePaneContainer = this.paneContainers.center\r\n    this.hasActiveTextEditor = false\r\n\r\n    this.panelContainers = {\r\n      top: new PanelContainer({viewRegistry: this.viewRegistry, location: 'top'}),\r\n      left: new PanelContainer({viewRegistry: this.viewRegistry, location: 'left', dock: this.paneContainers.left}),\r\n      right: new PanelContainer({viewRegistry: this.viewRegistry, location: 'right', dock: this.paneContainers.right}),\r\n      bottom: new PanelContainer({viewRegistry: this.viewRegistry, location: 'bottom', dock: this.paneContainers.bottom}),\r\n      header: new PanelContainer({viewRegistry: this.viewRegistry, location: 'header'}),\r\n      footer: new PanelContainer({viewRegistry: this.viewRegistry, location: 'footer'}),\r\n      modal: new PanelContainer({viewRegistry: this.viewRegistry, location: 'modal'})\r\n    }\r\n\r\n    this.incoming = new Map()\r\n\r\n    this.subscribeToEvents()\r\n  }\r", "name": "createDock", "func_location": "Workspace.constructor", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 211, "func_start_line": 176}}, {"func_info": {"comment": [], "name": "Workspace.createDock", "params": ["location"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 277, "start_line": 264}, "call_info": {"func_end_line": 231, "code": "  constructor (params) {\r\n    super(...arguments)\r\n\r\n    this.updateWindowTitle = this.updateWindowTitle.bind(this)\r\n    this.updateDocumentEdited = this.updateDocumentEdited.bind(this)\r\n    this.didDestroyPaneItem = this.didDestroyPaneItem.bind(this)\r\n    this.didChangeActivePaneOnPaneContainer = this.didChangeActivePaneOnPaneContainer.bind(this)\r\n    this.didChangeActivePaneItemOnPaneContainer = this.didChangeActivePaneItemOnPaneContainer.bind(this)\r\n    this.didActivatePaneContainer = this.didActivatePaneContainer.bind(this)\r\n\r\n    this.enablePersistence = params.enablePersistence\r\n    this.packageManager = params.packageManager\r\n    this.config = params.config\r\n    this.project = params.project\r\n    this.notificationManager = params.notificationManager\r\n    this.viewRegistry = params.viewRegistry\r\n    this.grammarRegistry = params.grammarRegistry\r\n    this.applicationDelegate = params.applicationDelegate\r\n    this.assert = params.assert\r\n    this.deserializerManager = params.deserializerManager\r\n    this.textEditorRegistry = params.textEditorRegistry\r\n    this.styleManager = params.styleManager\r\n    this.draggingItem = false\r\n    this.itemLocationStore = new StateStore('AtomPreviousItemLocations', 1)\r\n\r\n    this.emitter = new Emitter()\r\n    this.openers = []\r\n    this.destroyedItemURIs = []\r\n    this.stoppedChangingActivePaneItemTimeout = null\r\n\r\n    this.defaultDirectorySearcher = new DefaultDirectorySearcher()\r\n    this.consumeServices(this.packageManager)\r\n\r\n    this.paneContainers = {\r\n      center: this.createCenter(),\r\n      left: this.createDock('left'),\r\n      right: this.createDock('right'),\r\n      bottom: this.createDock('bottom')\r\n    }\r\n    this.activePaneContainer = this.paneContainers.center\r\n    this.hasActiveTextEditor = false\r\n\r\n    this.panelContainers = {\r\n      top: new PanelContainer({viewRegistry: this.viewRegistry, location: 'top'}),\r\n      left: new PanelContainer({viewRegistry: this.viewRegistry, location: 'left', dock: this.paneContainers.left}),\r\n      right: new PanelContainer({viewRegistry: this.viewRegistry, location: 'right', dock: this.paneContainers.right}),\r\n      bottom: new PanelContainer({viewRegistry: this.viewRegistry, location: 'bottom', dock: this.paneContainers.bottom}),\r\n      header: new PanelContainer({viewRegistry: this.viewRegistry, location: 'header'}),\r\n      footer: new PanelContainer({viewRegistry: this.viewRegistry, location: 'footer'}),\r\n      modal: new PanelContainer({viewRegistry: this.viewRegistry, location: 'modal'})\r\n    }\r\n\r\n    this.incoming = new Map()\r\n\r\n    this.subscribeToEvents()\r\n  }\r", "name": "createDock", "func_location": "Workspace.constructor", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 212, "func_start_line": 176}}, {"func_info": {"comment": [], "name": "Workspace.createDock", "params": ["location"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 277, "start_line": 264}, "call_info": {"func_end_line": 231, "code": "  constructor (params) {\r\n    super(...arguments)\r\n\r\n    this.updateWindowTitle = this.updateWindowTitle.bind(this)\r\n    this.updateDocumentEdited = this.updateDocumentEdited.bind(this)\r\n    this.didDestroyPaneItem = this.didDestroyPaneItem.bind(this)\r\n    this.didChangeActivePaneOnPaneContainer = this.didChangeActivePaneOnPaneContainer.bind(this)\r\n    this.didChangeActivePaneItemOnPaneContainer = this.didChangeActivePaneItemOnPaneContainer.bind(this)\r\n    this.didActivatePaneContainer = this.didActivatePaneContainer.bind(this)\r\n\r\n    this.enablePersistence = params.enablePersistence\r\n    this.packageManager = params.packageManager\r\n    this.config = params.config\r\n    this.project = params.project\r\n    this.notificationManager = params.notificationManager\r\n    this.viewRegistry = params.viewRegistry\r\n    this.grammarRegistry = params.grammarRegistry\r\n    this.applicationDelegate = params.applicationDelegate\r\n    this.assert = params.assert\r\n    this.deserializerManager = params.deserializerManager\r\n    this.textEditorRegistry = params.textEditorRegistry\r\n    this.styleManager = params.styleManager\r\n    this.draggingItem = false\r\n    this.itemLocationStore = new StateStore('AtomPreviousItemLocations', 1)\r\n\r\n    this.emitter = new Emitter()\r\n    this.openers = []\r\n    this.destroyedItemURIs = []\r\n    this.stoppedChangingActivePaneItemTimeout = null\r\n\r\n    this.defaultDirectorySearcher = new DefaultDirectorySearcher()\r\n    this.consumeServices(this.packageManager)\r\n\r\n    this.paneContainers = {\r\n      center: this.createCenter(),\r\n      left: this.createDock('left'),\r\n      right: this.createDock('right'),\r\n      bottom: this.createDock('bottom')\r\n    }\r\n    this.activePaneContainer = this.paneContainers.center\r\n    this.hasActiveTextEditor = false\r\n\r\n    this.panelContainers = {\r\n      top: new PanelContainer({viewRegistry: this.viewRegistry, location: 'top'}),\r\n      left: new PanelContainer({viewRegistry: this.viewRegistry, location: 'left', dock: this.paneContainers.left}),\r\n      right: new PanelContainer({viewRegistry: this.viewRegistry, location: 'right', dock: this.paneContainers.right}),\r\n      bottom: new PanelContainer({viewRegistry: this.viewRegistry, location: 'bottom', dock: this.paneContainers.bottom}),\r\n      header: new PanelContainer({viewRegistry: this.viewRegistry, location: 'header'}),\r\n      footer: new PanelContainer({viewRegistry: this.viewRegistry, location: 'footer'}),\r\n      modal: new PanelContainer({viewRegistry: this.viewRegistry, location: 'modal'})\r\n    }\r\n\r\n    this.incoming = new Map()\r\n\r\n    this.subscribeToEvents()\r\n  }\r", "name": "createDock", "func_location": "Workspace.constructor", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 213, "func_start_line": 176}}, {"func_info": {"comment": [], "name": "Workspace.subscribeToEvents", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 326, "start_line": 320}, "call_info": {"func_end_line": 231, "code": "  constructor (params) {\r\n    super(...arguments)\r\n\r\n    this.updateWindowTitle = this.updateWindowTitle.bind(this)\r\n    this.updateDocumentEdited = this.updateDocumentEdited.bind(this)\r\n    this.didDestroyPaneItem = this.didDestroyPaneItem.bind(this)\r\n    this.didChangeActivePaneOnPaneContainer = this.didChangeActivePaneOnPaneContainer.bind(this)\r\n    this.didChangeActivePaneItemOnPaneContainer = this.didChangeActivePaneItemOnPaneContainer.bind(this)\r\n    this.didActivatePaneContainer = this.didActivatePaneContainer.bind(this)\r\n\r\n    this.enablePersistence = params.enablePersistence\r\n    this.packageManager = params.packageManager\r\n    this.config = params.config\r\n    this.project = params.project\r\n    this.notificationManager = params.notificationManager\r\n    this.viewRegistry = params.viewRegistry\r\n    this.grammarRegistry = params.grammarRegistry\r\n    this.applicationDelegate = params.applicationDelegate\r\n    this.assert = params.assert\r\n    this.deserializerManager = params.deserializerManager\r\n    this.textEditorRegistry = params.textEditorRegistry\r\n    this.styleManager = params.styleManager\r\n    this.draggingItem = false\r\n    this.itemLocationStore = new StateStore('AtomPreviousItemLocations', 1)\r\n\r\n    this.emitter = new Emitter()\r\n    this.openers = []\r\n    this.destroyedItemURIs = []\r\n    this.stoppedChangingActivePaneItemTimeout = null\r\n\r\n    this.defaultDirectorySearcher = new DefaultDirectorySearcher()\r\n    this.consumeServices(this.packageManager)\r\n\r\n    this.paneContainers = {\r\n      center: this.createCenter(),\r\n      left: this.createDock('left'),\r\n      right: this.createDock('right'),\r\n      bottom: this.createDock('bottom')\r\n    }\r\n    this.activePaneContainer = this.paneContainers.center\r\n    this.hasActiveTextEditor = false\r\n\r\n    this.panelContainers = {\r\n      top: new PanelContainer({viewRegistry: this.viewRegistry, location: 'top'}),\r\n      left: new PanelContainer({viewRegistry: this.viewRegistry, location: 'left', dock: this.paneContainers.left}),\r\n      right: new PanelContainer({viewRegistry: this.viewRegistry, location: 'right', dock: this.paneContainers.right}),\r\n      bottom: new PanelContainer({viewRegistry: this.viewRegistry, location: 'bottom', dock: this.paneContainers.bottom}),\r\n      header: new PanelContainer({viewRegistry: this.viewRegistry, location: 'header'}),\r\n      footer: new PanelContainer({viewRegistry: this.viewRegistry, location: 'footer'}),\r\n      modal: new PanelContainer({viewRegistry: this.viewRegistry, location: 'modal'})\r\n    }\r\n\r\n    this.incoming = new Map()\r\n\r\n    this.subscribeToEvents()\r\n  }\r", "name": "subscribeToEvents", "func_location": "Workspace.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 230, "func_start_line": 176}}, {"func_info": {"comment": ["\r\n  Section: Private\r\n  "], "name": "Project.consumeServices", "params": [["serviceHub"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 615, "start_line": 594}, "call_info": {"func_end_line": 42, "comment": ["\r\n  Section: Construction and Destruction\r\n  "], "code": "  constructor ({notificationManager, packageManager, config, applicationDelegate, grammarRegistry}) {\r\n    super()\r\n    this.notificationManager = notificationManager\r\n    this.applicationDelegate = applicationDelegate\r\n    this.grammarRegistry = grammarRegistry\r\n\r\n    this.emitter = new Emitter()\r\n    this.buffers = []\r\n    this.rootDirectories = []\r\n    this.repositories = []\r\n    this.directoryProviders = []\r\n    this.defaultDirectoryProvider = new DefaultDirectoryProvider()\r\n    this.repositoryPromisesByPath = new Map()\r\n    this.repositoryProviders = [new GitRepositoryProvider(this, config)]\r\n    this.loadPromisesByPath = {}\r\n    this.watcherPromisesByPath = {}\r\n    this.retiredBufferIDs = new Set()\r\n    this.retiredBufferPaths = new Set()\r\n    this.subscriptions = new CompositeDisposable()\r\n    this.consumeServices(packageManager)\r\n  }\r", "name": "consumeServices", "func_location": "Project.constructor", "args": ["packageManager"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 41, "func_start_line": 22}}, {"func_info": {"comment": [], "name": "TreeSitterLanguageMode._patchSyntaxNode", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 25, "start_line": 17}, "call_info": {"func_end_line": 56, "code": "  constructor ({buffer, grammar, config, grammars, syncOperationLimit}) {\r\n    TreeSitterLanguageMode._patchSyntaxNode()\r\n    this.id = nextId++\r\n    this.buffer = buffer\r\n    this.grammar = grammar\r\n    this.config = config\r\n    this.grammarRegistry = grammars\r\n    this.parser = new Parser()\r\n    this.rootLanguageLayer = new LanguageLayer(this, grammar)\r\n    this.injectionsMarkerLayer = buffer.addMarkerLayer()\r\n\r\n    if (syncOperationLimit != null) {\r\n      this.syncOperationLimit = syncOperationLimit\r\n    }\r\n\r\n    this.rootScopeDescriptor = new ScopeDescriptor({scopes: [this.grammar.scopeName]})\r\n    this.emitter = new Emitter()\r\n    this.isFoldableCache = []\r\n    this.hasQueuedParse = false\r\n\r\n    this.grammarForLanguageString = this.grammarForLanguageString.bind(this)\r\n\r\n    this.rootLanguageLayer.update(null).then(() =>\r\n      this.emitter.emit('did-tokenize')\r\n    )\r\n\r\n    // TODO: Remove this once TreeSitterLanguageMode implements its own auto-indentation system. This\r\n    // is temporarily needed in order to delegate to the TextMateLanguageMode's auto-indent system.\r\n    this.regexesByPattern = {}\r\n  }\r", "name": "_patchSyntaxNode", "func_location": "TreeSitterLanguageMode.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 28, "func_start_line": 27}}, {"func_info": {"comment": [], "name": "LanguageLayer.constructor", "params": ["languageMode", "grammar", "contentChildTypes"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 552, "start_line": 545}, "call_info": {"func_end_line": 56, "name": "constructor", "func_location": "TreeSitterLanguageMode.constructor", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 35, "func_start_line": 27}}, {"func_info": {"comment": [" Creates the 'atom' custom protocol handler."], "name": "AtomProtocolHandler.registerAtomProtocol", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-protocol-handler.js", "end_line": 54, "start_line": 33}, "call_info": {"func_end_line": 30, "code": "  constructor (resourcePath, safeMode) {\r\n    this.loadPaths = []\r\n\r\n    if (!safeMode) {\r\n      this.loadPaths.push(path.join(process.env.ATOM_HOME, 'dev', 'packages'))\r\n      this.loadPaths.push(path.join(resourcePath, 'packages'))\r\n    }\r\n\r\n    this.loadPaths.push(path.join(process.env.ATOM_HOME, 'packages'))\r\n    this.loadPaths.push(path.join(resourcePath, 'node_modules'))\r\n\r\n    this.registerAtomProtocol()\r\n  }\r", "name": "registerAtomProtocol", "func_location": "AtomProtocolHandler.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-protocol-handler.js", "line": 29, "func_start_line": 18}}, {"func_info": {"comment": [], "name": "AtomEnvironment.registerDefaultCommands", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 307, "start_line": 305}, "call_info": {"func_end_line": 199, "comment": ["\r\n  Section: Properties\r\n  "], "code": "  constructor (params = {}) {\r\n    this.id = (params.id != null) ? params.id : nextId++\r\n\r\n    // Public: A {Clipboard} instance\r\n    this.clipboard = params.clipboard\r\n    this.updateProcessEnv = params.updateProcessEnv || updateProcessEnv\r\n    this.enablePersistence = params.enablePersistence\r\n    this.applicationDelegate = params.applicationDelegate\r\n\r\n    this.nextProxyRequestId = 0\r\n    this.unloading = false\r\n    this.loadTime = null\r\n    this.emitter = new Emitter()\r\n    this.disposables = new CompositeDisposable()\r\n    this.pathsWithWaitSessions = new Set()\r\n\r\n    // Public: A {DeserializerManager} instance\r\n    this.deserializers = new DeserializerManager(this)\r\n    this.deserializeTimings = {}\r\n\r\n    // Public: A {ViewRegistry} instance\r\n    this.views = new ViewRegistry(this)\r\n\r\n    // Public: A {NotificationManager} instance\r\n    this.notifications = new NotificationManager()\r\n\r\n    this.stateStore = new StateStore('AtomEnvironments', 1)\r\n\r\n    // Public: A {Config} instance\r\n    this.config = new Config({\r\n      saveCallback: settings => {\r\n        if (this.enablePersistence) {\r\n          this.applicationDelegate.setUserSettings(settings, this.config.getUserConfigPath())\r\n        }\r\n      }\r\n    })\r\n    this.config.setSchema(null, {type: 'object', properties: _.clone(ConfigSchema)})\r\n\r\n    // Public: A {KeymapManager} instance\r\n    this.keymaps = new KeymapManager({notificationManager: this.notifications})\r\n\r\n    // Public: A {TooltipManager} instance\r\n    this.tooltips = new TooltipManager({keymapManager: this.keymaps, viewRegistry: this.views})\r\n\r\n    // Public: A {CommandRegistry} instance\r\n    this.commands = new CommandRegistry()\r\n    this.uriHandlerRegistry = new URIHandlerRegistry()\r\n\r\n    // Public: A {GrammarRegistry} instance\r\n    this.grammars = new GrammarRegistry({config: this.config})\r\n\r\n    // Public: A {StyleManager} instance\r\n    this.styles = new StyleManager()\r\n\r\n    // Public: A {PackageManager} instance\r\n    this.packages = new PackageManager({\r\n      config: this.config,\r\n      styleManager: this.styles,\r\n      commandRegistry: this.commands,\r\n      keymapManager: this.keymaps,\r\n      notificationManager: this.notifications,\r\n      grammarRegistry: this.grammars,\r\n      deserializerManager: this.deserializers,\r\n      viewRegistry: this.views,\r\n      uriHandlerRegistry: this.uriHandlerRegistry\r\n    })\r\n\r\n    // Public: A {ThemeManager} instance\r\n    this.themes = new ThemeManager({\r\n      packageManager: this.packages,\r\n      config: this.config,\r\n      styleManager: this.styles,\r\n      notificationManager: this.notifications,\r\n      viewRegistry: this.views\r\n    })\r\n\r\n    // Public: A {MenuManager} instance\r\n    this.menu = new MenuManager({keymapManager: this.keymaps, packageManager: this.packages})\r\n\r\n    // Public: A {ContextMenuManager} instance\r\n    this.contextMenu = new ContextMenuManager({keymapManager: this.keymaps})\r\n\r\n    this.packages.setMenuManager(this.menu)\r\n    this.packages.setContextMenuManager(this.contextMenu)\r\n    this.packages.setThemeManager(this.themes)\r\n\r\n    // Public: A {Project} instance\r\n    this.project = new Project({\r\n      notificationManager: this.notifications,\r\n      packageManager: this.packages,\r\n      grammarRegistry: this.grammars,\r\n      config: this.config,\r\n      applicationDelegate: this.applicationDelegate\r\n    })\r\n    this.commandInstaller = new CommandInstaller(this.applicationDelegate)\r\n    this.protocolHandlerInstaller = new ProtocolHandlerInstaller()\r\n\r\n    // Public: A {TextEditorRegistry} instance\r\n    this.textEditors = new TextEditorRegistry({\r\n      config: this.config,\r\n      grammarRegistry: this.grammars,\r\n      assert: this.assert.bind(this),\r\n      packageManager: this.packages\r\n    })\r\n\r\n    // Public: A {Workspace} instance\r\n    this.workspace = new Workspace({\r\n      config: this.config,\r\n      project: this.project,\r\n      packageManager: this.packages,\r\n      grammarRegistry: this.grammars,\r\n      deserializerManager: this.deserializers,\r\n      notificationManager: this.notifications,\r\n      applicationDelegate: this.applicationDelegate,\r\n      viewRegistry: this.views,\r\n      assert: this.assert.bind(this),\r\n      textEditorRegistry: this.textEditors,\r\n      styleManager: this.styles,\r\n      enablePersistence: this.enablePersistence\r\n    })\r\n\r\n    this.themes.workspace = this.workspace\r\n\r\n    this.autoUpdater = new AutoUpdateManager({applicationDelegate: this.applicationDelegate})\r\n\r\n    if (this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.registerDefaultCommands()\r\n    this.registerDefaultOpeners()\r\n    this.registerDefaultDeserializers()\r\n\r\n    this.windowEventHandler = new WindowEventHandler({atomEnvironment: this, applicationDelegate: this.applicationDelegate})\r\n\r\n    // Public: A {HistoryManager} instance\r\n    this.history = new HistoryManager({project: this.project, commands: this.commands, stateStore: this.stateStore})\r\n\r\n    // Keep instances of HistoryManager in sync\r\n    this.disposables.add(this.history.onDidChangeProjects(event => {\r\n      if (!event.reloaded) this.applicationDelegate.didChangeHistoryManager()\r\n    }))\r\n  }\r", "name": "registerDefaultCommands", "func_location": "AtomEnvironment.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 186, "func_start_line": 57}}, {"func_info": {"comment": [], "name": "AtomEnvironment.registerDefaultOpeners", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 322, "start_line": 309}, "call_info": {"func_end_line": 199, "comment": ["\r\n  Section: Properties\r\n  "], "code": "  constructor (params = {}) {\r\n    this.id = (params.id != null) ? params.id : nextId++\r\n\r\n    // Public: A {Clipboard} instance\r\n    this.clipboard = params.clipboard\r\n    this.updateProcessEnv = params.updateProcessEnv || updateProcessEnv\r\n    this.enablePersistence = params.enablePersistence\r\n    this.applicationDelegate = params.applicationDelegate\r\n\r\n    this.nextProxyRequestId = 0\r\n    this.unloading = false\r\n    this.loadTime = null\r\n    this.emitter = new Emitter()\r\n    this.disposables = new CompositeDisposable()\r\n    this.pathsWithWaitSessions = new Set()\r\n\r\n    // Public: A {DeserializerManager} instance\r\n    this.deserializers = new DeserializerManager(this)\r\n    this.deserializeTimings = {}\r\n\r\n    // Public: A {ViewRegistry} instance\r\n    this.views = new ViewRegistry(this)\r\n\r\n    // Public: A {NotificationManager} instance\r\n    this.notifications = new NotificationManager()\r\n\r\n    this.stateStore = new StateStore('AtomEnvironments', 1)\r\n\r\n    // Public: A {Config} instance\r\n    this.config = new Config({\r\n      saveCallback: settings => {\r\n        if (this.enablePersistence) {\r\n          this.applicationDelegate.setUserSettings(settings, this.config.getUserConfigPath())\r\n        }\r\n      }\r\n    })\r\n    this.config.setSchema(null, {type: 'object', properties: _.clone(ConfigSchema)})\r\n\r\n    // Public: A {KeymapManager} instance\r\n    this.keymaps = new KeymapManager({notificationManager: this.notifications})\r\n\r\n    // Public: A {TooltipManager} instance\r\n    this.tooltips = new TooltipManager({keymapManager: this.keymaps, viewRegistry: this.views})\r\n\r\n    // Public: A {CommandRegistry} instance\r\n    this.commands = new CommandRegistry()\r\n    this.uriHandlerRegistry = new URIHandlerRegistry()\r\n\r\n    // Public: A {GrammarRegistry} instance\r\n    this.grammars = new GrammarRegistry({config: this.config})\r\n\r\n    // Public: A {StyleManager} instance\r\n    this.styles = new StyleManager()\r\n\r\n    // Public: A {PackageManager} instance\r\n    this.packages = new PackageManager({\r\n      config: this.config,\r\n      styleManager: this.styles,\r\n      commandRegistry: this.commands,\r\n      keymapManager: this.keymaps,\r\n      notificationManager: this.notifications,\r\n      grammarRegistry: this.grammars,\r\n      deserializerManager: this.deserializers,\r\n      viewRegistry: this.views,\r\n      uriHandlerRegistry: this.uriHandlerRegistry\r\n    })\r\n\r\n    // Public: A {ThemeManager} instance\r\n    this.themes = new ThemeManager({\r\n      packageManager: this.packages,\r\n      config: this.config,\r\n      styleManager: this.styles,\r\n      notificationManager: this.notifications,\r\n      viewRegistry: this.views\r\n    })\r\n\r\n    // Public: A {MenuManager} instance\r\n    this.menu = new MenuManager({keymapManager: this.keymaps, packageManager: this.packages})\r\n\r\n    // Public: A {ContextMenuManager} instance\r\n    this.contextMenu = new ContextMenuManager({keymapManager: this.keymaps})\r\n\r\n    this.packages.setMenuManager(this.menu)\r\n    this.packages.setContextMenuManager(this.contextMenu)\r\n    this.packages.setThemeManager(this.themes)\r\n\r\n    // Public: A {Project} instance\r\n    this.project = new Project({\r\n      notificationManager: this.notifications,\r\n      packageManager: this.packages,\r\n      grammarRegistry: this.grammars,\r\n      config: this.config,\r\n      applicationDelegate: this.applicationDelegate\r\n    })\r\n    this.commandInstaller = new CommandInstaller(this.applicationDelegate)\r\n    this.protocolHandlerInstaller = new ProtocolHandlerInstaller()\r\n\r\n    // Public: A {TextEditorRegistry} instance\r\n    this.textEditors = new TextEditorRegistry({\r\n      config: this.config,\r\n      grammarRegistry: this.grammars,\r\n      assert: this.assert.bind(this),\r\n      packageManager: this.packages\r\n    })\r\n\r\n    // Public: A {Workspace} instance\r\n    this.workspace = new Workspace({\r\n      config: this.config,\r\n      project: this.project,\r\n      packageManager: this.packages,\r\n      grammarRegistry: this.grammars,\r\n      deserializerManager: this.deserializers,\r\n      notificationManager: this.notifications,\r\n      applicationDelegate: this.applicationDelegate,\r\n      viewRegistry: this.views,\r\n      assert: this.assert.bind(this),\r\n      textEditorRegistry: this.textEditors,\r\n      styleManager: this.styles,\r\n      enablePersistence: this.enablePersistence\r\n    })\r\n\r\n    this.themes.workspace = this.workspace\r\n\r\n    this.autoUpdater = new AutoUpdateManager({applicationDelegate: this.applicationDelegate})\r\n\r\n    if (this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.registerDefaultCommands()\r\n    this.registerDefaultOpeners()\r\n    this.registerDefaultDeserializers()\r\n\r\n    this.windowEventHandler = new WindowEventHandler({atomEnvironment: this, applicationDelegate: this.applicationDelegate})\r\n\r\n    // Public: A {HistoryManager} instance\r\n    this.history = new HistoryManager({project: this.project, commands: this.commands, stateStore: this.stateStore})\r\n\r\n    // Keep instances of HistoryManager in sync\r\n    this.disposables.add(this.history.onDidChangeProjects(event => {\r\n      if (!event.reloaded) this.applicationDelegate.didChangeHistoryManager()\r\n    }))\r\n  }\r", "name": "registerDefaultOpeners", "func_location": "AtomEnvironment.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 187, "func_start_line": 57}}, {"func_info": {"comment": [], "name": "AtomEnvironment.registerDefaultDeserializers", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 303, "start_line": 294}, "call_info": {"func_end_line": 199, "comment": ["\r\n  Section: Properties\r\n  "], "code": "  constructor (params = {}) {\r\n    this.id = (params.id != null) ? params.id : nextId++\r\n\r\n    // Public: A {Clipboard} instance\r\n    this.clipboard = params.clipboard\r\n    this.updateProcessEnv = params.updateProcessEnv || updateProcessEnv\r\n    this.enablePersistence = params.enablePersistence\r\n    this.applicationDelegate = params.applicationDelegate\r\n\r\n    this.nextProxyRequestId = 0\r\n    this.unloading = false\r\n    this.loadTime = null\r\n    this.emitter = new Emitter()\r\n    this.disposables = new CompositeDisposable()\r\n    this.pathsWithWaitSessions = new Set()\r\n\r\n    // Public: A {DeserializerManager} instance\r\n    this.deserializers = new DeserializerManager(this)\r\n    this.deserializeTimings = {}\r\n\r\n    // Public: A {ViewRegistry} instance\r\n    this.views = new ViewRegistry(this)\r\n\r\n    // Public: A {NotificationManager} instance\r\n    this.notifications = new NotificationManager()\r\n\r\n    this.stateStore = new StateStore('AtomEnvironments', 1)\r\n\r\n    // Public: A {Config} instance\r\n    this.config = new Config({\r\n      saveCallback: settings => {\r\n        if (this.enablePersistence) {\r\n          this.applicationDelegate.setUserSettings(settings, this.config.getUserConfigPath())\r\n        }\r\n      }\r\n    })\r\n    this.config.setSchema(null, {type: 'object', properties: _.clone(ConfigSchema)})\r\n\r\n    // Public: A {KeymapManager} instance\r\n    this.keymaps = new KeymapManager({notificationManager: this.notifications})\r\n\r\n    // Public: A {TooltipManager} instance\r\n    this.tooltips = new TooltipManager({keymapManager: this.keymaps, viewRegistry: this.views})\r\n\r\n    // Public: A {CommandRegistry} instance\r\n    this.commands = new CommandRegistry()\r\n    this.uriHandlerRegistry = new URIHandlerRegistry()\r\n\r\n    // Public: A {GrammarRegistry} instance\r\n    this.grammars = new GrammarRegistry({config: this.config})\r\n\r\n    // Public: A {StyleManager} instance\r\n    this.styles = new StyleManager()\r\n\r\n    // Public: A {PackageManager} instance\r\n    this.packages = new PackageManager({\r\n      config: this.config,\r\n      styleManager: this.styles,\r\n      commandRegistry: this.commands,\r\n      keymapManager: this.keymaps,\r\n      notificationManager: this.notifications,\r\n      grammarRegistry: this.grammars,\r\n      deserializerManager: this.deserializers,\r\n      viewRegistry: this.views,\r\n      uriHandlerRegistry: this.uriHandlerRegistry\r\n    })\r\n\r\n    // Public: A {ThemeManager} instance\r\n    this.themes = new ThemeManager({\r\n      packageManager: this.packages,\r\n      config: this.config,\r\n      styleManager: this.styles,\r\n      notificationManager: this.notifications,\r\n      viewRegistry: this.views\r\n    })\r\n\r\n    // Public: A {MenuManager} instance\r\n    this.menu = new MenuManager({keymapManager: this.keymaps, packageManager: this.packages})\r\n\r\n    // Public: A {ContextMenuManager} instance\r\n    this.contextMenu = new ContextMenuManager({keymapManager: this.keymaps})\r\n\r\n    this.packages.setMenuManager(this.menu)\r\n    this.packages.setContextMenuManager(this.contextMenu)\r\n    this.packages.setThemeManager(this.themes)\r\n\r\n    // Public: A {Project} instance\r\n    this.project = new Project({\r\n      notificationManager: this.notifications,\r\n      packageManager: this.packages,\r\n      grammarRegistry: this.grammars,\r\n      config: this.config,\r\n      applicationDelegate: this.applicationDelegate\r\n    })\r\n    this.commandInstaller = new CommandInstaller(this.applicationDelegate)\r\n    this.protocolHandlerInstaller = new ProtocolHandlerInstaller()\r\n\r\n    // Public: A {TextEditorRegistry} instance\r\n    this.textEditors = new TextEditorRegistry({\r\n      config: this.config,\r\n      grammarRegistry: this.grammars,\r\n      assert: this.assert.bind(this),\r\n      packageManager: this.packages\r\n    })\r\n\r\n    // Public: A {Workspace} instance\r\n    this.workspace = new Workspace({\r\n      config: this.config,\r\n      project: this.project,\r\n      packageManager: this.packages,\r\n      grammarRegistry: this.grammars,\r\n      deserializerManager: this.deserializers,\r\n      notificationManager: this.notifications,\r\n      applicationDelegate: this.applicationDelegate,\r\n      viewRegistry: this.views,\r\n      assert: this.assert.bind(this),\r\n      textEditorRegistry: this.textEditors,\r\n      styleManager: this.styles,\r\n      enablePersistence: this.enablePersistence\r\n    })\r\n\r\n    this.themes.workspace = this.workspace\r\n\r\n    this.autoUpdater = new AutoUpdateManager({applicationDelegate: this.applicationDelegate})\r\n\r\n    if (this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.registerDefaultCommands()\r\n    this.registerDefaultOpeners()\r\n    this.registerDefaultDeserializers()\r\n\r\n    this.windowEventHandler = new WindowEventHandler({atomEnvironment: this, applicationDelegate: this.applicationDelegate})\r\n\r\n    // Public: A {HistoryManager} instance\r\n    this.history = new HistoryManager({project: this.project, commands: this.commands, stateStore: this.stateStore})\r\n\r\n    // Keep instances of HistoryManager in sync\r\n    this.disposables.add(this.history.onDidChangeProjects(event => {\r\n      if (!event.reloaded) this.applicationDelegate.didChangeHistoryManager()\r\n    }))\r\n  }\r", "name": "registerDefaultDeserializers", "func_location": "AtomEnvironment.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 188, "func_start_line": 57}}, {"func_info": {"comment": [], "name": "Package.reset", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 168, "start_line": 160}, "call_info": {"func_end_line": 49, "comment": ["\r\n  Section: Construction\r\n  "], "code": "  constructor (params) {\r\n    this.config = params.config\r\n    this.packageManager = params.packageManager\r\n    this.styleManager = params.styleManager\r\n    this.commandRegistry = params.commandRegistry\r\n    this.keymapManager = params.keymapManager\r\n    this.notificationManager = params.notificationManager\r\n    this.grammarRegistry = params.grammarRegistry\r\n    this.themeManager = params.themeManager\r\n    this.menuManager = params.menuManager\r\n    this.contextMenuManager = params.contextMenuManager\r\n    this.deserializerManager = params.deserializerManager\r\n    this.viewRegistry = params.viewRegistry\r\n    this.emitter = new Emitter()\r\n\r\n    this.mainModule = null\r\n    this.path = params.path\r\n    this.preloadedPackage = params.preloadedPackage\r\n    this.metadata =\r\n      params.metadata ||\r\n      this.packageManager.loadPackageMetadata(this.path)\r\n    this.bundledPackage = params.bundledPackage != null\r\n      ? params.bundledPackage\r\n      : this.packageManager.isBundledPackagePath(this.path)\r\n    this.name =\r\n      (this.metadata && this.metadata.name) ||\r\n      params.name ||\r\n      path.basename(this.path)\r\n    this.reset()\r\n  }\r", "name": "reset", "func_location": "Package.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 48, "func_start_line": 20}}, {"func_info": {"comment": [" another type of package manager can handle other package types.", " See ThemeManager"], "name": "PackageManager.registerPackageActivator", "params": ["activator", "types"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 677, "start_line": 675}, "call_info": {"func_end_line": 58, "code": "  constructor (params) {\r\n    ({\r\n      config: this.config, styleManager: this.styleManager, notificationManager: this.notificationManager, keymapManager: this.keymapManager,\r\n      commandRegistry: this.commandRegistry, grammarRegistry: this.grammarRegistry, deserializerManager: this.deserializerManager, viewRegistry: this.viewRegistry,\r\n      uriHandlerRegistry: this.uriHandlerRegistry\r\n    } = params)\r\n\r\n    this.emitter = new Emitter()\r\n    this.activationHookEmitter = new Emitter()\r\n    this.packageDirPaths = []\r\n    this.deferredActivationHooks = []\r\n    this.triggeredActivationHooks = new Set()\r\n    this.packagesCache = packageJSON._atomPackages != null ? packageJSON._atomPackages : {}\r\n    this.packageDependencies = packageJSON.packageDependencies != null ? packageJSON.packageDependencies : {}\r\n    this.deprecatedPackages = packageJSON._deprecatedPackages || {}\r\n    this.deprecatedPackageRanges = {}\r\n    this.initialPackagesLoaded = false\r\n    this.initialPackagesActivated = false\r\n    this.preloadedPackages = {}\r\n    this.loadedPackages = {}\r\n    this.activePackages = {}\r\n    this.activatingPackages = {}\r\n    this.packageStates = {}\r\n    this.serviceHub = new ServiceHub()\r\n\r\n    this.packageActivators = []\r\n    this.registerPackageActivator(this, ['atom', 'textmate'])\r\n  }\r", "name": "registerPackageActivator", "func_location": "PackageManager.constructor", "args": [null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 57, "func_start_line": 31}}, {"func_info": {"comment": [], "name": "WindowStack.constructor", "params": ["windows"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1397, "start_line": 1390}, "call_info": {"func_end_line": 136, "name": "constructor", "func_location": "AtomApplication.constructor", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 108, "func_start_line": 91}}, {"func_info": {"comment": [], "name": "AtomApplication.initializeAtomHome", "params": ["configDirPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 649, "start_line": 644}, "call_info": {"func_end_line": 136, "code": "  constructor (options) {\r\n    super()\r\n    this.quitting = false\r\n    this.getAllWindows = this.getAllWindows.bind(this)\r\n    this.getLastFocusedWindow = this.getLastFocusedWindow.bind(this)\r\n    this.resourcePath = options.resourcePath\r\n    this.devResourcePath = options.devResourcePath\r\n    this.version = options.version\r\n    this.devMode = options.devMode\r\n    this.safeMode = options.safeMode\r\n    this.socketPath = options.socketPath\r\n    this.logFile = options.logFile\r\n    this.userDataDir = options.userDataDir\r\n    this._killProcess = options.killProcess || process.kill.bind(process)\r\n    if (options.test || options.benchmark || options.benchmarkTest) this.socketPath = null\r\n\r\n    this.waitSessionsByWindow = new Map()\r\n    this.windowStack = new WindowStack()\r\n\r\n    this.initializeAtomHome(process.env.ATOM_HOME)\r\n\r\n    const configFilePath = fs.existsSync(path.join(process.env.ATOM_HOME, 'config.json'))\r\n      ? path.join(process.env.ATOM_HOME, 'config.json')\r\n      : path.join(process.env.ATOM_HOME, 'config.cson')\r\n\r\n    this.configFile = ConfigFile.at(configFilePath)\r\n    this.config = new Config({\r\n      saveCallback: settings => {\r\n        if (!this.quitting) {\r\n          return this.configFile.update(settings)\r\n        }\r\n      }\r\n    })\r\n    this.config.setSchema(null, {type: 'object', properties: _.clone(ConfigSchema)})\r\n\r\n    this.fileRecoveryService = new FileRecoveryService(path.join(process.env.ATOM_HOME, 'recovery'))\r\n    this.storageFolder = new StorageFolder(process.env.ATOM_HOME)\r\n    this.autoUpdateManager = new AutoUpdateManager(\r\n      this.version,\r\n      options.test || options.benchmark || options.benchmarkTest,\r\n      this.config\r\n    )\r\n\r\n    this.disposable = new CompositeDisposable()\r\n    this.handleEvents()\r\n  }\r", "name": "initializeAtomHome", "func_location": "AtomApplication.constructor", "args": ["process.env.ATOM_HOME"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 110, "func_start_line": 91}}, {"func_info": {"comment": [" Registers basic application commands, non-idempotent."], "name": "AtomApplication.handleEvents", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 634, "start_line": 364}, "call_info": {"func_end_line": 136, "code": "  constructor (options) {\r\n    super()\r\n    this.quitting = false\r\n    this.getAllWindows = this.getAllWindows.bind(this)\r\n    this.getLastFocusedWindow = this.getLastFocusedWindow.bind(this)\r\n    this.resourcePath = options.resourcePath\r\n    this.devResourcePath = options.devResourcePath\r\n    this.version = options.version\r\n    this.devMode = options.devMode\r\n    this.safeMode = options.safeMode\r\n    this.socketPath = options.socketPath\r\n    this.logFile = options.logFile\r\n    this.userDataDir = options.userDataDir\r\n    this._killProcess = options.killProcess || process.kill.bind(process)\r\n    if (options.test || options.benchmark || options.benchmarkTest) this.socketPath = null\r\n\r\n    this.waitSessionsByWindow = new Map()\r\n    this.windowStack = new WindowStack()\r\n\r\n    this.initializeAtomHome(process.env.ATOM_HOME)\r\n\r\n    const configFilePath = fs.existsSync(path.join(process.env.ATOM_HOME, 'config.json'))\r\n      ? path.join(process.env.ATOM_HOME, 'config.json')\r\n      : path.join(process.env.ATOM_HOME, 'config.cson')\r\n\r\n    this.configFile = ConfigFile.at(configFilePath)\r\n    this.config = new Config({\r\n      saveCallback: settings => {\r\n        if (!this.quitting) {\r\n          return this.configFile.update(settings)\r\n        }\r\n      }\r\n    })\r\n    this.config.setSchema(null, {type: 'object', properties: _.clone(ConfigSchema)})\r\n\r\n    this.fileRecoveryService = new FileRecoveryService(path.join(process.env.ATOM_HOME, 'recovery'))\r\n    this.storageFolder = new StorageFolder(process.env.ATOM_HOME)\r\n    this.autoUpdateManager = new AutoUpdateManager(\r\n      this.version,\r\n      options.test || options.benchmark || options.benchmarkTest,\r\n      this.config\r\n    )\r\n\r\n    this.disposable = new CompositeDisposable()\r\n    this.handleEvents()\r\n  }\r", "name": "handleEvents", "func_location": "AtomApplication.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 135, "func_start_line": 91}}, {"func_info": {"comment": [], "name": "TextEditorRegistry.clear", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js", "end_line": 79, "start_line": 66}, "call_info": {"func_end_line": 54, "code": "  constructor ({config, assert, packageManager}) {\r\n    this.assert = assert\r\n    this.config = config\r\n    this.clear()\r\n\r\n    this.initialPackageActivationPromise = new Promise((resolve) => {\r\n      // TODO: Remove this usage of a private property of PackageManager.\r\n      // Should PackageManager just expose a promise-based API like this?\r\n      if (packageManager.deferredActivationHooks) {\r\n        packageManager.onDidActivateInitialPackages(resolve)\r\n      } else {\r\n        resolve()\r\n      }\r\n    })\r\n  }\r", "name": "clear", "func_location": "TextEditorRegistry.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js", "line": 43, "func_start_line": 40}}, {"func_info": {"comment": [], "name": "SyntaxScopeMap.addSelector", "params": ["selector", "result"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js", "end_line": 97, "start_line": 15}, "call_info": {"func_end_line": 13, "code": "  constructor (resultsBySelector) {\r\n    this.namedScopeTable = {}\r\n    this.anonymousScopeTable = {}\r\n    for (let selector in resultsBySelector) {\r\n      this.addSelector(selector, resultsBySelector[selector])\r\n    }\r\n    setTableDefaults(this.namedScopeTable, true)\r\n    setTableDefaults(this.anonymousScopeTable, false)\r\n  }\r", "name": "addSelector", "func_location": "SyntaxScopeMap.constructor", "args": ["selector", "resultsBySelector.selector"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js", "line": 9, "func_start_line": 5}}, {"func_info": {"comment": [], "name": "setTableDefaults", "params": ["table", "allowWildcardSelector"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js", "end_line": 152, "start_line": 129}, "call_info": {"func_end_line": 13, "code": "  constructor (resultsBySelector) {\r\n    this.namedScopeTable = {}\r\n    this.anonymousScopeTable = {}\r\n    for (let selector in resultsBySelector) {\r\n      this.addSelector(selector, resultsBySelector[selector])\r\n    }\r\n    setTableDefaults(this.namedScopeTable, true)\r\n    setTableDefaults(this.anonymousScopeTable, false)\r\n  }\r", "name": "setTableDefaults", "func_location": "SyntaxScopeMap.constructor", "args": [".namedScopeTable", {"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js", "line": 11, "func_start_line": 5}}, {"func_info": {"comment": [], "name": "setTableDefaults", "params": ["table", "allowWildcardSelector"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js", "end_line": 152, "start_line": 129}, "call_info": {"func_end_line": 13, "code": "  constructor (resultsBySelector) {\r\n    this.namedScopeTable = {}\r\n    this.anonymousScopeTable = {}\r\n    for (let selector in resultsBySelector) {\r\n      this.addSelector(selector, resultsBySelector[selector])\r\n    }\r\n    setTableDefaults(this.namedScopeTable, true)\r\n    setTableDefaults(this.anonymousScopeTable, false)\r\n  }\r", "name": "setTableDefaults", "func_location": "SyntaxScopeMap.constructor", "args": [".anonymousScopeTable", {"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js", "line": 12, "func_start_line": 5}}, {"func_info": {"comment": [], "name": "PaneAxis.addChild", "params": ["child", "index"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js", "end_line": 123, "start_line": 117}, "call_info": {"func_end_line": 28, "code": "  constructor ({orientation, children, flexScale}, viewRegistry) {\r\n    super()\r\n    this.parent = null\r\n    this.container = null\r\n    this.orientation = orientation\r\n    this.viewRegistry = viewRegistry\r\n    this.emitter = new Emitter()\r\n    this.subscriptionsByChild = new WeakMap()\r\n    this.subscriptions = new CompositeDisposable()\r\n    this.flexScale = flexScale != null ? flexScale : 1\r\n    this.children = []\r\n    if (children) {\r\n      for (let child of children) {\r\n        this.addChild(child)\r\n      }\r\n    }\r\n  }\r", "name": "addChild", "func_location": "PaneAxis.constructor", "args": ["child"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js", "line": 25, "func_start_line": 12}}, {"func_info": {"comment": [" Essential: Update the marker with new Properties. Allows you to change the decoration's class.", "", " ## Examples", "", " ```coffee", " decoration.setProperties({type: 'line-number', class: 'my-new-class'})", " ```", "", " * `newProperties` {Object} eg. `{type: 'line-number', class: 'my-new-class'}`"], "name": "Decoration.setProperties", "params": ["newProperties"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration.js", "end_line": 173, "start_line": 164}, "call_info": {"func_end_line": 82, "comment": ["\r\n  Section: Construction and Destruction\r\n  "], "code": "  constructor (marker, decorationManager, properties) {\r\n    this.marker = marker\r\n    this.decorationManager = decorationManager\r\n    this.emitter = new Emitter()\r\n    this.id = nextId()\r\n    this.setProperties(properties)\r\n    this.destroyed = false\r\n    this.markerDestroyDisposable = this.marker.onDidDestroy(() => this.destroy())\r\n  }\r", "name": "setProperties", "func_location": "Decoration.constructor", "args": ["properties"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration.js", "line": 79, "func_start_line": 74}}, {"func_info": {"comment": [], "name": "ApplicationMenu.setActiveTemplate", "params": ["template"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "end_line": 40, "start_line": 32}, "call_info": {"func_end_line": 17, "code": "  constructor (version, autoUpdateManager) {\r\n    this.version = version\r\n    this.autoUpdateManager = autoUpdateManager\r\n    this.windowTemplates = new WeakMap()\r\n    this.setActiveTemplate(this.getDefaultTemplate())\r\n    this.autoUpdateManager.on('state-changed', state => this.showUpdateMenuItem(state))\r\n  }\r", "name": "setActiveTemplate", "func_location": "ApplicationMenu.constructor", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "line": 15, "func_start_line": 11}}, {"func_info": {"comment": [" Default list of menu items.", "", " Returns an Array of menu item Objects."], "name": "ApplicationMenu.getDefaultTemplate", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "end_line": 184, "start_line": 145}, "call_info": {"func_end_line": 17, "code": "  constructor (version, autoUpdateManager) {\r\n    this.version = version\r\n    this.autoUpdateManager = autoUpdateManager\r\n    this.windowTemplates = new WeakMap()\r\n    this.setActiveTemplate(this.getDefaultTemplate())\r\n    this.autoUpdateManager.on('state-changed', state => this.showUpdateMenuItem(state))\r\n  }\r", "name": "getDefaultTemplate", "func_location": "ApplicationMenu.constructor", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "line": 15, "func_start_line": 11}}, {"func_info": {"comment": [" Wire commands that should be handled by Chromium for elements with the", " `.native-key-bindings` class."], "name": "WindowEventHandler.handleNativeKeybindings", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js", "end_line": 89, "start_line": 71}, "call_info": {"func_end_line": 29, "code": "  constructor ({atomEnvironment, applicationDelegate}) {\r\n    this.handleDocumentKeyEvent = this.handleDocumentKeyEvent.bind(this)\r\n    this.handleFocusNext = this.handleFocusNext.bind(this)\r\n    this.handleFocusPrevious = this.handleFocusPrevious.bind(this)\r\n    this.handleWindowBlur = this.handleWindowBlur.bind(this)\r\n    this.handleWindowResize = this.handleWindowResize.bind(this)\r\n    this.handleEnterFullScreen = this.handleEnterFullScreen.bind(this)\r\n    this.handleLeaveFullScreen = this.handleLeaveFullScreen.bind(this)\r\n    this.handleWindowBeforeunload = this.handleWindowBeforeunload.bind(this)\r\n    this.handleWindowToggleFullScreen = this.handleWindowToggleFullScreen.bind(this)\r\n    this.handleWindowClose = this.handleWindowClose.bind(this)\r\n    this.handleWindowReload = this.handleWindowReload.bind(this)\r\n    this.handleWindowToggleDevTools = this.handleWindowToggleDevTools.bind(this)\r\n    this.handleWindowToggleMenuBar = this.handleWindowToggleMenuBar.bind(this)\r\n    this.handleLinkClick = this.handleLinkClick.bind(this)\r\n    this.handleDocumentContextmenu = this.handleDocumentContextmenu.bind(this)\r\n    this.atomEnvironment = atomEnvironment\r\n    this.applicationDelegate = applicationDelegate\r\n    this.reloadRequested = false\r\n    this.subscriptions = new CompositeDisposable()\r\n\r\n    this.handleNativeKeybindings()\r\n  }\r", "name": "handleNativeKeybindings", "func_location": "WindowEventHandler.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js", "line": 28, "func_start_line": 7}}, {"func_info": {"comment": [], "name": "getWidthOrHeight", "params": ["location"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 823, "start_line": 821}, "call_info": {"func_end_line": 72, "code": "  constructor (params) {\r\n    this.handleResizeHandleDragStart = this.handleResizeHandleDragStart.bind(this)\r\n    this.handleResizeToFit = this.handleResizeToFit.bind(this)\r\n    this.handleMouseMove = this.handleMouseMove.bind(this)\r\n    this.handleMouseUp = this.handleMouseUp.bind(this)\r\n    this.handleDrag = _.throttle(this.handleDrag.bind(this), 30)\r\n    this.handleDragEnd = this.handleDragEnd.bind(this)\r\n    this.handleToggleButtonDragEnter = this.handleToggleButtonDragEnter.bind(this)\r\n    this.toggle = this.toggle.bind(this)\r\n\r\n    this.location = params.location\r\n    this.widthOrHeight = getWidthOrHeight(this.location)\r\n    this.config = params.config\r\n    this.applicationDelegate = params.applicationDelegate\r\n    this.deserializerManager = params.deserializerManager\r\n    this.notificationManager = params.notificationManager\r\n    this.viewRegistry = params.viewRegistry\r\n    this.didActivate = params.didActivate\r\n\r\n    this.emitter = new Emitter()\r\n\r\n    this.paneContainer = new PaneContainer({\r\n      location: this.location,\r\n      config: this.config,\r\n      applicationDelegate: this.applicationDelegate,\r\n      deserializerManager: this.deserializerManager,\r\n      notificationManager: this.notificationManager,\r\n      viewRegistry: this.viewRegistry\r\n    })\r\n\r\n    this.state = {\r\n      size: null,\r\n      visible: false,\r\n      shouldAnimate: false\r\n    }\r\n\r\n    this.subscriptions = new CompositeDisposable(\r\n      this.emitter,\r\n      this.paneContainer.onDidActivatePane(() => {\r\n        this.show()\r\n        this.didActivate(this)\r\n      }),\r\n      this.paneContainer.observePanes(pane => {\r\n        pane.onDidAddItem(this.handleDidAddPaneItem.bind(this))\r\n        pane.onDidRemoveItem(this.handleDidRemovePaneItem.bind(this))\r\n      }),\r\n      this.paneContainer.onDidChangeActivePane((item) => params.didChangeActivePane(this, item)),\r\n      this.paneContainer.onDidChangeActivePaneItem((item) => params.didChangeActivePaneItem(this, item)),\r\n      this.paneContainer.onDidDestroyPaneItem((item) => params.didDestroyPaneItem(item))\r\n    )\r\n  }\r", "name": "getWidthOrHeight", "func_location": "Dock.constructor", "args": [".location"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 33, "func_start_line": 22}}, {"func_info": {"comment": [], "name": "buildRegex", "params": ["value"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js", "end_line": 165, "start_line": 159}, "call_info": {"func_end_line": 63, "code": "  constructor (registry, filePath, params) {\r\n    this.registry = registry\r\n    this.name = params.name\r\n    this.scopeName = params.scopeName\r\n\r\n    // TODO - Remove the `RegExp` spelling and only support `Regex`, once all of the existing\r\n    // Tree-sitter grammars are updated to spell it `Regex`.\r\n    this.contentRegex = buildRegex(params.contentRegex || params.contentRegExp)\r\n    this.injectionRegex = buildRegex(params.injectionRegex || params.injectionRegExp)\r\n    this.firstLineRegex = buildRegex(params.firstLineRegex)\r\n\r\n    this.folds = params.folds || []\r\n    this.folds.forEach(normalizeFoldSpecification)\r\n\r\n    this.commentStrings = {\r\n      commentStartString: params.comments && params.comments.start,\r\n      commentEndString: params.comments && params.comments.end\r\n    }\r\n\r\n    const scopeSelectors = {}\r\n    for (const key in params.scopes || {}) {\r\n      const classes = preprocessScopes(params.scopes[key])\r\n      const selectors = key.split(/,\\s+/)\r\n      for (let selector of selectors) {\r\n        selector = selector.trim()\r\n        if (!selector) continue\r\n        if (scopeSelectors[selector]) {\r\n          scopeSelectors[selector] = [].concat(scopeSelectors[selector], classes)\r\n        } else {\r\n          scopeSelectors[selector] = classes\r\n        }\r\n      }\r\n    }\r\n\r\n    this.scopeMap = new SyntaxScopeMap(scopeSelectors)\r\n    this.fileTypes = params.fileTypes || []\r\n    this.injectionPointsByType = {}\r\n\r\n    for (const injectionPoint of params.injectionPoints || []) {\r\n      this.addInjectionPoint(injectionPoint)\r\n    }\r\n\r\n    // TODO - When we upgrade to a new enough version of node, use `require.resolve`\r\n    // with the new `paths` option instead of this private API.\r\n    const languageModulePath = Module._resolveFilename(params.parser, {\r\n      id: filePath,\r\n      filename: filePath,\r\n      paths: Module._nodeModulePaths(path.dirname(filePath))\r\n    })\r\n\r\n    this.languageModule = require(languageModulePath)\r\n    this.classNamesById = new Map()\r\n    this.scopeNamesById = new Map()\r\n    this.idsByScope = Object.create(null)\r\n    this.nextScopeId = 256 + 1\r\n    this.registration = null\r\n  }\r", "name": "buildRegex", "func_location": "TreeSitterGrammar.constructor", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js", "line": 14, "func_start_line": 7}}, {"func_info": {"comment": [], "name": "buildRegex", "params": ["value"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js", "end_line": 165, "start_line": 159}, "call_info": {"func_end_line": 63, "code": "  constructor (registry, filePath, params) {\r\n    this.registry = registry\r\n    this.name = params.name\r\n    this.scopeName = params.scopeName\r\n\r\n    // TODO - Remove the `RegExp` spelling and only support `Regex`, once all of the existing\r\n    // Tree-sitter grammars are updated to spell it `Regex`.\r\n    this.contentRegex = buildRegex(params.contentRegex || params.contentRegExp)\r\n    this.injectionRegex = buildRegex(params.injectionRegex || params.injectionRegExp)\r\n    this.firstLineRegex = buildRegex(params.firstLineRegex)\r\n\r\n    this.folds = params.folds || []\r\n    this.folds.forEach(normalizeFoldSpecification)\r\n\r\n    this.commentStrings = {\r\n      commentStartString: params.comments && params.comments.start,\r\n      commentEndString: params.comments && params.comments.end\r\n    }\r\n\r\n    const scopeSelectors = {}\r\n    for (const key in params.scopes || {}) {\r\n      const classes = preprocessScopes(params.scopes[key])\r\n      const selectors = key.split(/,\\s+/)\r\n      for (let selector of selectors) {\r\n        selector = selector.trim()\r\n        if (!selector) continue\r\n        if (scopeSelectors[selector]) {\r\n          scopeSelectors[selector] = [].concat(scopeSelectors[selector], classes)\r\n        } else {\r\n          scopeSelectors[selector] = classes\r\n        }\r\n      }\r\n    }\r\n\r\n    this.scopeMap = new SyntaxScopeMap(scopeSelectors)\r\n    this.fileTypes = params.fileTypes || []\r\n    this.injectionPointsByType = {}\r\n\r\n    for (const injectionPoint of params.injectionPoints || []) {\r\n      this.addInjectionPoint(injectionPoint)\r\n    }\r\n\r\n    // TODO - When we upgrade to a new enough version of node, use `require.resolve`\r\n    // with the new `paths` option instead of this private API.\r\n    const languageModulePath = Module._resolveFilename(params.parser, {\r\n      id: filePath,\r\n      filename: filePath,\r\n      paths: Module._nodeModulePaths(path.dirname(filePath))\r\n    })\r\n\r\n    this.languageModule = require(languageModulePath)\r\n    this.classNamesById = new Map()\r\n    this.scopeNamesById = new Map()\r\n    this.idsByScope = Object.create(null)\r\n    this.nextScopeId = 256 + 1\r\n    this.registration = null\r\n  }\r", "name": "buildRegex", "func_location": "TreeSitterGrammar.constructor", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js", "line": 15, "func_start_line": 7}}, {"func_info": {"comment": [], "name": "buildRegex", "params": ["value"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js", "end_line": 165, "start_line": 159}, "call_info": {"func_end_line": 63, "code": "  constructor (registry, filePath, params) {\r\n    this.registry = registry\r\n    this.name = params.name\r\n    this.scopeName = params.scopeName\r\n\r\n    // TODO - Remove the `RegExp` spelling and only support `Regex`, once all of the existing\r\n    // Tree-sitter grammars are updated to spell it `Regex`.\r\n    this.contentRegex = buildRegex(params.contentRegex || params.contentRegExp)\r\n    this.injectionRegex = buildRegex(params.injectionRegex || params.injectionRegExp)\r\n    this.firstLineRegex = buildRegex(params.firstLineRegex)\r\n\r\n    this.folds = params.folds || []\r\n    this.folds.forEach(normalizeFoldSpecification)\r\n\r\n    this.commentStrings = {\r\n      commentStartString: params.comments && params.comments.start,\r\n      commentEndString: params.comments && params.comments.end\r\n    }\r\n\r\n    const scopeSelectors = {}\r\n    for (const key in params.scopes || {}) {\r\n      const classes = preprocessScopes(params.scopes[key])\r\n      const selectors = key.split(/,\\s+/)\r\n      for (let selector of selectors) {\r\n        selector = selector.trim()\r\n        if (!selector) continue\r\n        if (scopeSelectors[selector]) {\r\n          scopeSelectors[selector] = [].concat(scopeSelectors[selector], classes)\r\n        } else {\r\n          scopeSelectors[selector] = classes\r\n        }\r\n      }\r\n    }\r\n\r\n    this.scopeMap = new SyntaxScopeMap(scopeSelectors)\r\n    this.fileTypes = params.fileTypes || []\r\n    this.injectionPointsByType = {}\r\n\r\n    for (const injectionPoint of params.injectionPoints || []) {\r\n      this.addInjectionPoint(injectionPoint)\r\n    }\r\n\r\n    // TODO - When we upgrade to a new enough version of node, use `require.resolve`\r\n    // with the new `paths` option instead of this private API.\r\n    const languageModulePath = Module._resolveFilename(params.parser, {\r\n      id: filePath,\r\n      filename: filePath,\r\n      paths: Module._nodeModulePaths(path.dirname(filePath))\r\n    })\r\n\r\n    this.languageModule = require(languageModulePath)\r\n    this.classNamesById = new Map()\r\n    this.scopeNamesById = new Map()\r\n    this.idsByScope = Object.create(null)\r\n    this.nextScopeId = 256 + 1\r\n    this.registration = null\r\n  }\r", "name": "buildRegex", "func_location": "TreeSitterGrammar.constructor", "args": ["params.firstLineRegex"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js", "line": 16, "func_start_line": 7}}, {"func_info": {"comment": [], "name": "TreeSitterGrammar.addInjectionPoint", "params": ["injectionPoint"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js", "end_line": 103, "start_line": 97}, "call_info": {"func_end_line": 63, "code": "  constructor (registry, filePath, params) {\r\n    this.registry = registry\r\n    this.name = params.name\r\n    this.scopeName = params.scopeName\r\n\r\n    // TODO - Remove the `RegExp` spelling and only support `Regex`, once all of the existing\r\n    // Tree-sitter grammars are updated to spell it `Regex`.\r\n    this.contentRegex = buildRegex(params.contentRegex || params.contentRegExp)\r\n    this.injectionRegex = buildRegex(params.injectionRegex || params.injectionRegExp)\r\n    this.firstLineRegex = buildRegex(params.firstLineRegex)\r\n\r\n    this.folds = params.folds || []\r\n    this.folds.forEach(normalizeFoldSpecification)\r\n\r\n    this.commentStrings = {\r\n      commentStartString: params.comments && params.comments.start,\r\n      commentEndString: params.comments && params.comments.end\r\n    }\r\n\r\n    const scopeSelectors = {}\r\n    for (const key in params.scopes || {}) {\r\n      const classes = preprocessScopes(params.scopes[key])\r\n      const selectors = key.split(/,\\s+/)\r\n      for (let selector of selectors) {\r\n        selector = selector.trim()\r\n        if (!selector) continue\r\n        if (scopeSelectors[selector]) {\r\n          scopeSelectors[selector] = [].concat(scopeSelectors[selector], classes)\r\n        } else {\r\n          scopeSelectors[selector] = classes\r\n        }\r\n      }\r\n    }\r\n\r\n    this.scopeMap = new SyntaxScopeMap(scopeSelectors)\r\n    this.fileTypes = params.fileTypes || []\r\n    this.injectionPointsByType = {}\r\n\r\n    for (const injectionPoint of params.injectionPoints || []) {\r\n      this.addInjectionPoint(injectionPoint)\r\n    }\r\n\r\n    // TODO - When we upgrade to a new enough version of node, use `require.resolve`\r\n    // with the new `paths` option instead of this private API.\r\n    const languageModulePath = Module._resolveFilename(params.parser, {\r\n      id: filePath,\r\n      filename: filePath,\r\n      paths: Module._nodeModulePaths(path.dirname(filePath))\r\n    })\r\n\r\n    this.languageModule = require(languageModulePath)\r\n    this.classNamesById = new Map()\r\n    this.scopeNamesById = new Map()\r\n    this.idsByScope = Object.create(null)\r\n    this.nextScopeId = 256 + 1\r\n    this.registration = null\r\n  }\r", "name": "addInjectionPoint", "func_location": "TreeSitterGrammar.constructor", "args": ["injectionPoint"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js", "line": 46, "func_start_line": 7}}, {"func_info": {"comment": [], "name": "FileSystemBlobStore.reset", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/file-system-blob-store.js", "end_line": 26, "start_line": 21}, "call_info": {"func_end_line": 19, "code": "  constructor (directory) {\r\n    this.blobFilename = path.join(directory, 'BLOB')\r\n    this.blobMapFilename = path.join(directory, 'MAP')\r\n    this.lockFilename = path.join(directory, 'LOCK')\r\n    this.reset()\r\n  }\r", "name": "reset", "func_location": "FileSystemBlobStore.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/file-system-blob-store.js", "line": 18, "func_start_line": 14}}, {"func_info": {"comment": [" Public: Add the given items to the pane.", "", " * `items` An {Array} of items to add. Items can be views or models with", "   associated views. Any objects that are already present in the pane's", "   current items will not be added again.", " * `index` (optional) {Number} index at which to add the items. If omitted,", "   the item is #   added after the current active item.", "", " Returns an {Array} of added items."], "name": "Pane.addItems", "params": ["items", "index"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 682, "start_line": 675}, "call_info": {"func_end_line": 87, "code": "  constructor (params = {}) {\r\n    this.setPendingItem = this.setPendingItem.bind(this)\r\n    this.getPendingItem = this.getPendingItem.bind(this)\r\n    this.clearPendingItem = this.clearPendingItem.bind(this)\r\n    this.onItemDidTerminatePendingState = this.onItemDidTerminatePendingState.bind(this)\r\n    this.saveItem = this.saveItem.bind(this)\r\n    this.saveItemAs = this.saveItemAs.bind(this)\r\n\r\n    this.id = params.id\r\n    if (this.id != null) {\r\n      nextInstanceId = Math.max(nextInstanceId, this.id + 1)\r\n    } else {\r\n      this.id = nextInstanceId++\r\n    }\r\n\r\n    this.activeItem = params.activeItem\r\n    this.focused = params.focused != null ? params.focused : false\r\n    this.applicationDelegate = params.applicationDelegate\r\n    this.notificationManager = params.notificationManager\r\n    this.config = params.config\r\n    this.deserializerManager = params.deserializerManager\r\n    this.viewRegistry = params.viewRegistry\r\n\r\n    this.emitter = new Emitter()\r\n    this.alive = true\r\n    this.subscriptionsPerItem = new WeakMap()\r\n    this.items = []\r\n    this.itemStack = []\r\n    this.container = null\r\n\r\n    this.addItems((params.items || []).filter(item => item))\r\n    if (!this.getActiveItem()) this.setActiveItem(this.items[0])\r\n    this.addItemsToStack(params.itemStackIndices || [])\r\n    this.setFlexScale(params.flexScale || 1)\r\n  }\r", "name": "addItems", "func_location": "Pane.constructor", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 83, "func_start_line": 53}}, {"func_info": {"comment": [" Public: Get the active pane item in this pane.", "", " Returns a pane item."], "name": "Pane.getActiveItem", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 432, "start_line": 432}, "call_info": {"func_end_line": 87, "code": "  constructor (params = {}) {\r\n    this.setPendingItem = this.setPendingItem.bind(this)\r\n    this.getPendingItem = this.getPendingItem.bind(this)\r\n    this.clearPendingItem = this.clearPendingItem.bind(this)\r\n    this.onItemDidTerminatePendingState = this.onItemDidTerminatePendingState.bind(this)\r\n    this.saveItem = this.saveItem.bind(this)\r\n    this.saveItemAs = this.saveItemAs.bind(this)\r\n\r\n    this.id = params.id\r\n    if (this.id != null) {\r\n      nextInstanceId = Math.max(nextInstanceId, this.id + 1)\r\n    } else {\r\n      this.id = nextInstanceId++\r\n    }\r\n\r\n    this.activeItem = params.activeItem\r\n    this.focused = params.focused != null ? params.focused : false\r\n    this.applicationDelegate = params.applicationDelegate\r\n    this.notificationManager = params.notificationManager\r\n    this.config = params.config\r\n    this.deserializerManager = params.deserializerManager\r\n    this.viewRegistry = params.viewRegistry\r\n\r\n    this.emitter = new Emitter()\r\n    this.alive = true\r\n    this.subscriptionsPerItem = new WeakMap()\r\n    this.items = []\r\n    this.itemStack = []\r\n    this.container = null\r\n\r\n    this.addItems((params.items || []).filter(item => item))\r\n    if (!this.getActiveItem()) this.setActiveItem(this.items[0])\r\n    this.addItemsToStack(params.itemStackIndices || [])\r\n    this.setFlexScale(params.flexScale || 1)\r\n  }\r", "name": "getActiveItem", "func_location": "Pane.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 84, "func_start_line": 53}}, {"func_info": {"comment": [], "name": "Pane.setActiveItem", "params": ["activeItem", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 443, "start_line": 434}, "call_info": {"func_end_line": 87, "code": "  constructor (params = {}) {\r\n    this.setPendingItem = this.setPendingItem.bind(this)\r\n    this.getPendingItem = this.getPendingItem.bind(this)\r\n    this.clearPendingItem = this.clearPendingItem.bind(this)\r\n    this.onItemDidTerminatePendingState = this.onItemDidTerminatePendingState.bind(this)\r\n    this.saveItem = this.saveItem.bind(this)\r\n    this.saveItemAs = this.saveItemAs.bind(this)\r\n\r\n    this.id = params.id\r\n    if (this.id != null) {\r\n      nextInstanceId = Math.max(nextInstanceId, this.id + 1)\r\n    } else {\r\n      this.id = nextInstanceId++\r\n    }\r\n\r\n    this.activeItem = params.activeItem\r\n    this.focused = params.focused != null ? params.focused : false\r\n    this.applicationDelegate = params.applicationDelegate\r\n    this.notificationManager = params.notificationManager\r\n    this.config = params.config\r\n    this.deserializerManager = params.deserializerManager\r\n    this.viewRegistry = params.viewRegistry\r\n\r\n    this.emitter = new Emitter()\r\n    this.alive = true\r\n    this.subscriptionsPerItem = new WeakMap()\r\n    this.items = []\r\n    this.itemStack = []\r\n    this.container = null\r\n\r\n    this.addItems((params.items || []).filter(item => item))\r\n    if (!this.getActiveItem()) this.setActiveItem(this.items[0])\r\n    this.addItemsToStack(params.itemStackIndices || [])\r\n    this.setFlexScale(params.flexScale || 1)\r\n  }\r", "name": "setActiveItem", "func_location": "Pane.constructor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 84, "func_start_line": 53}}, {"func_info": {"comment": [" Build the itemStack after deserializing"], "name": "Pane.addItemsToStack", "params": ["itemStackIndices"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 456, "start_line": 446}, "call_info": {"func_end_line": 87, "code": "  constructor (params = {}) {\r\n    this.setPendingItem = this.setPendingItem.bind(this)\r\n    this.getPendingItem = this.getPendingItem.bind(this)\r\n    this.clearPendingItem = this.clearPendingItem.bind(this)\r\n    this.onItemDidTerminatePendingState = this.onItemDidTerminatePendingState.bind(this)\r\n    this.saveItem = this.saveItem.bind(this)\r\n    this.saveItemAs = this.saveItemAs.bind(this)\r\n\r\n    this.id = params.id\r\n    if (this.id != null) {\r\n      nextInstanceId = Math.max(nextInstanceId, this.id + 1)\r\n    } else {\r\n      this.id = nextInstanceId++\r\n    }\r\n\r\n    this.activeItem = params.activeItem\r\n    this.focused = params.focused != null ? params.focused : false\r\n    this.applicationDelegate = params.applicationDelegate\r\n    this.notificationManager = params.notificationManager\r\n    this.config = params.config\r\n    this.deserializerManager = params.deserializerManager\r\n    this.viewRegistry = params.viewRegistry\r\n\r\n    this.emitter = new Emitter()\r\n    this.alive = true\r\n    this.subscriptionsPerItem = new WeakMap()\r\n    this.items = []\r\n    this.itemStack = []\r\n    this.container = null\r\n\r\n    this.addItems((params.items || []).filter(item => item))\r\n    if (!this.getActiveItem()) this.setActiveItem(this.items[0])\r\n    this.addItemsToStack(params.itemStackIndices || [])\r\n    this.setFlexScale(params.flexScale || 1)\r\n  }\r", "name": "addItemsToStack", "func_location": "Pane.constructor", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 85, "func_start_line": 53}}, {"func_info": {"comment": [], "name": "Pane.setFlexScale", "params": ["flexScale"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 154, "start_line": 150}, "call_info": {"func_end_line": 87, "code": "  constructor (params = {}) {\r\n    this.setPendingItem = this.setPendingItem.bind(this)\r\n    this.getPendingItem = this.getPendingItem.bind(this)\r\n    this.clearPendingItem = this.clearPendingItem.bind(this)\r\n    this.onItemDidTerminatePendingState = this.onItemDidTerminatePendingState.bind(this)\r\n    this.saveItem = this.saveItem.bind(this)\r\n    this.saveItemAs = this.saveItemAs.bind(this)\r\n\r\n    this.id = params.id\r\n    if (this.id != null) {\r\n      nextInstanceId = Math.max(nextInstanceId, this.id + 1)\r\n    } else {\r\n      this.id = nextInstanceId++\r\n    }\r\n\r\n    this.activeItem = params.activeItem\r\n    this.focused = params.focused != null ? params.focused : false\r\n    this.applicationDelegate = params.applicationDelegate\r\n    this.notificationManager = params.notificationManager\r\n    this.config = params.config\r\n    this.deserializerManager = params.deserializerManager\r\n    this.viewRegistry = params.viewRegistry\r\n\r\n    this.emitter = new Emitter()\r\n    this.alive = true\r\n    this.subscriptionsPerItem = new WeakMap()\r\n    this.items = []\r\n    this.itemStack = []\r\n    this.container = null\r\n\r\n    this.addItems((params.items || []).filter(item => item))\r\n    if (!this.getActiveItem()) this.setActiveItem(this.items[0])\r\n    this.addItemsToStack(params.itemStackIndices || [])\r\n    this.setFlexScale(params.flexScale || 1)\r\n  }\r", "name": "setFlexScale", "func_location": "Pane.constructor", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 86, "func_start_line": 53}}, {"func_info": {"comment": [], "name": "TextEditor.constructor", "params": ["params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 265, "start_line": 125}, "call_info": {"func_end_line": 988, "name": "constructor", "func_location": "TextEditor.copy", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 973, "func_start_line": 969}}, {"func_info": {"comment": [], "name": "loadDependencies", "params": ["modulePath", "rootPath", "rootMetadata", "moduleCache"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js", "end_line": 84, "start_line": 52}, "call_info": {"func_end_line": 272, "code": "exports.create = function (modulePath) {\r\n  const fs = require('fs-plus')\r\n\r\n  modulePath = fs.realpathSync(modulePath)\r\n  const metadataPath = path.join(modulePath, 'package.json')\r\n  const metadata = JSON.parse(fs.readFileSync(metadataPath))\r\n\r\n  const moduleCache = {\r\n    version: 1,\r\n    dependencies: [],\r\n    extensions: {},\r\n    folders: []\r\n  }\r\n\r\n  loadDependencies(modulePath, modulePath, metadata, moduleCache)\r\n  loadFolderCompatibility(modulePath, modulePath, metadata, moduleCache)\r\n  loadExtensions(modulePath, modulePath, metadata, moduleCache)\r\n\r\n  metadata._atomModuleCache = moduleCache\r\n  fs.writeFileSync(metadataPath, JSON.stringify(metadata, null, 2))\r\n}\r", "name": "loadDependencies", "func_location": "exports.create", "args": ["modulePath", "modulePath", "metadata", "moduleCache"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js", "line": 266, "func_start_line": 252}}, {"func_info": {"comment": [], "name": "loadFolderCompatibility", "params": ["modulePath", "rootPath", "rootMetadata", "moduleCache"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js", "end_line": 126, "start_line": 86}, "call_info": {"func_end_line": 272, "code": "exports.create = function (modulePath) {\r\n  const fs = require('fs-plus')\r\n\r\n  modulePath = fs.realpathSync(modulePath)\r\n  const metadataPath = path.join(modulePath, 'package.json')\r\n  const metadata = JSON.parse(fs.readFileSync(metadataPath))\r\n\r\n  const moduleCache = {\r\n    version: 1,\r\n    dependencies: [],\r\n    extensions: {},\r\n    folders: []\r\n  }\r\n\r\n  loadDependencies(modulePath, modulePath, metadata, moduleCache)\r\n  loadFolderCompatibility(modulePath, modulePath, metadata, moduleCache)\r\n  loadExtensions(modulePath, modulePath, metadata, moduleCache)\r\n\r\n  metadata._atomModuleCache = moduleCache\r\n  fs.writeFileSync(metadataPath, JSON.stringify(metadata, null, 2))\r\n}\r", "name": "loadFolderCompatibility", "func_location": "exports.create", "args": ["modulePath", "modulePath", "metadata", "moduleCache"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js", "line": 267, "func_start_line": 252}}, {"func_info": {"comment": [], "name": "loadExtensions", "params": ["modulePath", "rootPath", "rootMetadata", "moduleCache"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js", "end_line": 164, "start_line": 128}, "call_info": {"func_end_line": 272, "code": "exports.create = function (modulePath) {\r\n  const fs = require('fs-plus')\r\n\r\n  modulePath = fs.realpathSync(modulePath)\r\n  const metadataPath = path.join(modulePath, 'package.json')\r\n  const metadata = JSON.parse(fs.readFileSync(metadataPath))\r\n\r\n  const moduleCache = {\r\n    version: 1,\r\n    dependencies: [],\r\n    extensions: {},\r\n    folders: []\r\n  }\r\n\r\n  loadDependencies(modulePath, modulePath, metadata, moduleCache)\r\n  loadFolderCompatibility(modulePath, modulePath, metadata, moduleCache)\r\n  loadExtensions(modulePath, modulePath, metadata, moduleCache)\r\n\r\n  metadata._atomModuleCache = moduleCache\r\n  fs.writeFileSync(metadataPath, JSON.stringify(metadata, null, 2))\r\n}\r", "name": "loadExtensions", "func_location": "exports.create", "args": ["modulePath", "modulePath", "metadata", "moduleCache"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js", "line": 268, "func_start_line": 252}}, {"func_info": {"comment": [], "name": "PaneElement.initializeContent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js", "end_line": 30, "start_line": 24}, "call_info": {"func_end_line": 11, "code": "  createdCallback () {\r\n    this.attached = false\r\n    this.subscriptions = new CompositeDisposable()\r\n    this.inlineDisplayStyles = new WeakMap()\r\n    this.initializeContent()\r\n    this.subscribeToDOMEvents()\r\n  }\r", "name": "initializeContent", "func_location": "PaneElement.createdCallback", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js", "line": 9, "func_start_line": 5}}, {"func_info": {"comment": [], "name": "PaneElement.subscribeToDOMEvents", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js", "end_line": 72, "start_line": 32}, "call_info": {"func_end_line": 11, "code": "  createdCallback () {\r\n    this.attached = false\r\n    this.subscriptions = new CompositeDisposable()\r\n    this.inlineDisplayStyles = new WeakMap()\r\n    this.initializeContent()\r\n    this.subscribeToDOMEvents()\r\n  }\r", "name": "subscribeToDOMEvents", "func_location": "PaneElement.createdCallback", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-element.js", "line": 10, "func_start_line": 5}}, {"func_info": {"comment": [], "name": "Workspace.getOpeners", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1341, "start_line": 1339}, "call_info": {"func_end_line": 1229, "comment": [" Public: Creates a new item that corresponds to the provided URI.", "", " If no URI is given, or no registered opener can open the URI, a new empty", " {TextEditor} will be created.", "", " * `uri` A {String} containing a URI.", "", " Returns a {Promise} that resolves to the {TextEditor} (or other item) for the given URI."], "code": "  async createItemForURI (uri, options) {\r\n    if (uri != null) {\r\n      for (const opener of this.getOpeners()) {\r\n        const item = opener(uri, options)\r\n        if (item != null) return item\r\n      }\r\n    }\r\n\r\n    try {\r\n      const item = await this.openTextFile(uri, options)\r\n      return item\r\n    } catch (error) {\r\n      switch (error.code) {\r\n        case 'CANCELLED':\r\n          return Promise.resolve()\r\n        case 'EACCES':\r\n          this.notificationManager.addWarning(`Permission denied '${error.path}'`)\r\n          return Promise.resolve()\r\n        case 'EPERM':\r\n        case 'EBUSY':\r\n        case 'ENXIO':\r\n        case 'EIO':\r\n        case 'ENOTCONN':\r\n        case 'UNKNOWN':\r\n        case 'ECONNRESET':\r\n        case 'EINVAL':\r\n        case 'EMFILE':\r\n        case 'ENOTDIR':\r\n        case 'EAGAIN':\r\n          this.notificationManager.addWarning(\r\n            `Unable to open '${error.path != null ? error.path : uri}'`,\r\n            {detail: error.message}\r\n          )\r\n          return Promise.resolve()\r\n        default:\r\n          throw error\r\n      }\r\n    }\r\n  }\r", "name": "getOpeners", "func_location": "Workspace.createItemForURI", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1193, "func_start_line": 1191}}, {"func_info": {"comment": [], "name": "Workspace.openTextFile", "params": ["uri", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1267, "start_line": 1231}, "call_info": {"func_end_line": 1229, "comment": [" Public: Creates a new item that corresponds to the provided URI.", "", " If no URI is given, or no registered opener can open the URI, a new empty", " {TextEditor} will be created.", "", " * `uri` A {String} containing a URI.", "", " Returns a {Promise} that resolves to the {TextEditor} (or other item) for the given URI."], "code": "  async createItemForURI (uri, options) {\r\n    if (uri != null) {\r\n      for (const opener of this.getOpeners()) {\r\n        const item = opener(uri, options)\r\n        if (item != null) return item\r\n      }\r\n    }\r\n\r\n    try {\r\n      const item = await this.openTextFile(uri, options)\r\n      return item\r\n    } catch (error) {\r\n      switch (error.code) {\r\n        case 'CANCELLED':\r\n          return Promise.resolve()\r\n        case 'EACCES':\r\n          this.notificationManager.addWarning(`Permission denied '${error.path}'`)\r\n          return Promise.resolve()\r\n        case 'EPERM':\r\n        case 'EBUSY':\r\n        case 'ENXIO':\r\n        case 'EIO':\r\n        case 'ENOTCONN':\r\n        case 'UNKNOWN':\r\n        case 'ECONNRESET':\r\n        case 'EINVAL':\r\n        case 'EMFILE':\r\n        case 'ENOTDIR':\r\n        case 'EAGAIN':\r\n          this.notificationManager.addWarning(\r\n            `Unable to open '${error.path != null ? error.path : uri}'`,\r\n            {detail: error.message}\r\n          )\r\n          return Promise.resolve()\r\n        default:\r\n          throw error\r\n      }\r\n    }\r\n  }\r", "name": "openTextFile", "func_location": "Workspace.createItemForURI", "args": ["uri", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1200, "func_start_line": 1191}}, {"func_info": {"comment": [], "name": "Package.unregisterURIHandler", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 417, "start_line": 415}, "call_info": {"func_end_line": 722, "code": "  async deactivate () {\r\n    this.activationPromise = null\r\n    this.resolveActivationPromise = null\r\n    if (this.activationCommandSubscriptions) this.activationCommandSubscriptions.dispose()\r\n    if (this.activationHookSubscriptions) this.activationHookSubscriptions.dispose()\r\n    this.configSchemaRegisteredOnActivate = false\r\n    this.unregisterURIHandler()\r\n    this.deactivateResources()\r\n    this.deactivateKeymaps()\r\n\r\n    if (!this.mainActivated) {\r\n      this.emitter.emit('did-deactivate')\r\n      return\r\n    }\r\n\r\n    if (typeof this.mainModule.deactivate === 'function') {\r\n      try {\r\n        const deactivationResult = this.mainModule.deactivate()\r\n        if (deactivationResult && typeof deactivationResult.then === 'function') {\r\n          await deactivationResult\r\n        }\r\n      } catch (error) {\r\n        console.error(`Error deactivating package '${this.name}'`, error.stack)\r\n      }\r\n    }\r\n\r\n    if (typeof this.mainModule.deactivateConfig === 'function') {\r\n      try {\r\n        await this.mainModule.deactivateConfig()\r\n      } catch (error) {\r\n        console.error(`Error deactivating package '${this.name}'`, error.stack)\r\n      }\r\n    }\r\n\r\n    this.mainActivated = false\r\n    this.mainInitialized = false\r\n    this.emitter.emit('did-deactivate')\r\n  }\r", "name": "unregisterURIHandler", "func_location": "Package.deactivate", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 691, "func_start_line": 685}}, {"func_info": {"comment": [], "name": "Package.deactivateResources", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 740, "start_line": 724}, "call_info": {"func_end_line": 722, "code": "  async deactivate () {\r\n    this.activationPromise = null\r\n    this.resolveActivationPromise = null\r\n    if (this.activationCommandSubscriptions) this.activationCommandSubscriptions.dispose()\r\n    if (this.activationHookSubscriptions) this.activationHookSubscriptions.dispose()\r\n    this.configSchemaRegisteredOnActivate = false\r\n    this.unregisterURIHandler()\r\n    this.deactivateResources()\r\n    this.deactivateKeymaps()\r\n\r\n    if (!this.mainActivated) {\r\n      this.emitter.emit('did-deactivate')\r\n      return\r\n    }\r\n\r\n    if (typeof this.mainModule.deactivate === 'function') {\r\n      try {\r\n        const deactivationResult = this.mainModule.deactivate()\r\n        if (deactivationResult && typeof deactivationResult.then === 'function') {\r\n          await deactivationResult\r\n        }\r\n      } catch (error) {\r\n        console.error(`Error deactivating package '${this.name}'`, error.stack)\r\n      }\r\n    }\r\n\r\n    if (typeof this.mainModule.deactivateConfig === 'function') {\r\n      try {\r\n        await this.mainModule.deactivateConfig()\r\n      } catch (error) {\r\n        console.error(`Error deactivating package '${this.name}'`, error.stack)\r\n      }\r\n    }\r\n\r\n    this.mainActivated = false\r\n    this.mainInitialized = false\r\n    this.emitter.emit('did-deactivate')\r\n  }\r", "name": "deactivateResources", "func_location": "Package.deactivate", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 692, "func_start_line": 685}}, {"func_info": {"comment": [], "name": "Package.deactivateKeymaps", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 347, "start_line": 340}, "call_info": {"func_end_line": 722, "code": "  async deactivate () {\r\n    this.activationPromise = null\r\n    this.resolveActivationPromise = null\r\n    if (this.activationCommandSubscriptions) this.activationCommandSubscriptions.dispose()\r\n    if (this.activationHookSubscriptions) this.activationHookSubscriptions.dispose()\r\n    this.configSchemaRegisteredOnActivate = false\r\n    this.unregisterURIHandler()\r\n    this.deactivateResources()\r\n    this.deactivateKeymaps()\r\n\r\n    if (!this.mainActivated) {\r\n      this.emitter.emit('did-deactivate')\r\n      return\r\n    }\r\n\r\n    if (typeof this.mainModule.deactivate === 'function') {\r\n      try {\r\n        const deactivationResult = this.mainModule.deactivate()\r\n        if (deactivationResult && typeof deactivationResult.then === 'function') {\r\n          await deactivationResult\r\n        }\r\n      } catch (error) {\r\n        console.error(`Error deactivating package '${this.name}'`, error.stack)\r\n      }\r\n    }\r\n\r\n    if (typeof this.mainModule.deactivateConfig === 'function') {\r\n      try {\r\n        await this.mainModule.deactivateConfig()\r\n      } catch (error) {\r\n        console.error(`Error deactivating package '${this.name}'`, error.stack)\r\n      }\r\n    }\r\n\r\n    this.mainActivated = false\r\n    this.mainInitialized = false\r\n    this.emitter.emit('did-deactivate')\r\n  }\r", "name": "deactivateKeymaps", "func_location": "Package.deactivate", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 693, "func_start_line": 685}}, {"func_info": {"comment": [" Public: Get the loaded {Package} with the given name.", "", " * `name` - The {String} package name.", "", " Returns a {Package} or undefined."], "name": "PackageManager.getLoadedPackage", "params": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 341, "start_line": 339}, "call_info": {"func_end_line": 797, "comment": [" Deactivate the package with the given name"], "code": "  async deactivatePackage (name, suppressSerialization) {\r\n    const pack = this.getLoadedPackage(name)\r\n    if (pack == null) {\r\n      return\r\n    }\r\n\r\n    if (!suppressSerialization && this.isPackageActive(pack.name)) {\r\n      this.serializePackage(pack)\r\n    }\r\n\r\n    const deactivationResult = pack.deactivate()\r\n    if (deactivationResult && typeof deactivationResult.then === 'function') {\r\n      await deactivationResult\r\n    }\r\n\r\n    delete this.activePackages[pack.name]\r\n    delete this.activatingPackages[pack.name]\r\n    this.emitter.emit('did-deactivate-package', pack)\r\n  }\r", "name": "getLoadedPackage", "func_location": "PackageManager.deactivatePackage", "args": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 780, "func_start_line": 779}}, {"func_info": {"comment": [" Public: Is the {Package} with the given name active?", "", " * `name` - The {String} package name.", "", " Returns a {Boolean}."], "name": "PackageManager.isPackageActive", "params": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 311, "start_line": 309}, "call_info": {"func_end_line": 797, "comment": [" Deactivate the package with the given name"], "code": "  async deactivatePackage (name, suppressSerialization) {\r\n    const pack = this.getLoadedPackage(name)\r\n    if (pack == null) {\r\n      return\r\n    }\r\n\r\n    if (!suppressSerialization && this.isPackageActive(pack.name)) {\r\n      this.serializePackage(pack)\r\n    }\r\n\r\n    const deactivationResult = pack.deactivate()\r\n    if (deactivationResult && typeof deactivationResult.then === 'function') {\r\n      await deactivationResult\r\n    }\r\n\r\n    delete this.activePackages[pack.name]\r\n    delete this.activatingPackages[pack.name]\r\n    this.emitter.emit('did-deactivate-package', pack)\r\n  }\r", "name": "isPackageActive", "func_location": "PackageManager.deactivatePackage", "args": ["pack.name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 785, "func_start_line": 779}}, {"func_info": {"comment": [], "name": "PackageManager.serializePackage", "params": ["pack"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 767, "start_line": 763}, "call_info": {"func_end_line": 797, "comment": [" Deactivate the package with the given name"], "code": "  async deactivatePackage (name, suppressSerialization) {\r\n    const pack = this.getLoadedPackage(name)\r\n    if (pack == null) {\r\n      return\r\n    }\r\n\r\n    if (!suppressSerialization && this.isPackageActive(pack.name)) {\r\n      this.serializePackage(pack)\r\n    }\r\n\r\n    const deactivationResult = pack.deactivate()\r\n    if (deactivationResult && typeof deactivationResult.then === 'function') {\r\n      await deactivationResult\r\n    }\r\n\r\n    delete this.activePackages[pack.name]\r\n    delete this.activatingPackages[pack.name]\r\n    this.emitter.emit('did-deactivate-package', pack)\r\n  }\r", "name": "serializePackage", "func_location": "PackageManager.deactivatePackage", "args": ["pack"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 786, "func_start_line": 779}}, {"func_info": {"comment": [], "name": "PackageManager.unobserveDisabledPackages", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 442, "start_line": 437}, "call_info": {"func_end_line": 776, "comment": [" Deactivate all packages"], "code": "  async deactivatePackages () {\r\n    await this.config.transactAsync(() =>\r\n      Promise.all(this.getLoadedPackages().map(pack => this.deactivatePackage(pack.name, true)))\r\n    )\r\n    this.unobserveDisabledPackages()\r\n    this.unobservePackagesWithKeymapsDisabled()\r\n  }\r", "name": "unobserveDisabledPackages", "func_location": "PackageManager.deactivatePackages", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 774, "func_start_line": 770}}, {"func_info": {"comment": [], "name": "PackageManager.unobservePackagesWithKeymapsDisabled", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 463, "start_line": 458}, "call_info": {"func_end_line": 776, "comment": [" Deactivate all packages"], "code": "  async deactivatePackages () {\r\n    await this.config.transactAsync(() =>\r\n      Promise.all(this.getLoadedPackages().map(pack => this.deactivatePackage(pack.name, true)))\r\n    )\r\n    this.unobserveDisabledPackages()\r\n    this.unobservePackagesWithKeymapsDisabled()\r\n  }\r", "name": "unobservePackagesWithKeymapsDisabled", "func_location": "PackageManager.deactivatePackages", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 775, "func_start_line": 770}}, {"func_info": {"comment": [], "name": "ThemeManager.removeActiveThemeClasses", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 375, "start_line": 370}, "call_info": {"func_end_line": 355, "code": "  deactivateThemes () {\r\n    this.removeActiveThemeClasses()\r\n    this.unwatchUserStylesheet()\r\n    const results = this.getActiveThemes().map(pack => this.packageManager.deactivatePackage(pack.name))\r\n    return Promise.all(results.filter((r) => (r != null) && (typeof r.then === 'function')))\r\n  }\r", "name": "removeActiveThemeClasses", "func_location": "ThemeManager.deactivateThemes", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 351, "func_start_line": 350}}, {"func_info": {"comment": [], "name": "ThemeManager.unwatchUserStylesheet", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 183, "start_line": 177}, "call_info": {"func_end_line": 355, "code": "  deactivateThemes () {\r\n    this.removeActiveThemeClasses()\r\n    this.unwatchUserStylesheet()\r\n    const results = this.getActiveThemes().map(pack => this.packageManager.deactivatePackage(pack.name))\r\n    return Promise.all(results.filter((r) => (r != null) && (typeof r.then === 'function')))\r\n  }\r", "name": "unwatchUserStylesheet", "func_location": "ThemeManager.deactivateThemes", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 352, "func_start_line": 350}}, {"func_info": {"comment": [" Public: Returns an {Array} of all the active themes."], "name": "ThemeManager.getActiveThemes", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 94, "start_line": 92}, "call_info": {"func_end_line": 355, "code": "  deactivateThemes () {\r\n    this.removeActiveThemeClasses()\r\n    this.unwatchUserStylesheet()\r\n    const results = this.getActiveThemes().map(pack => this.packageManager.deactivatePackage(pack.name))\r\n    return Promise.all(results.filter((r) => (r != null) && (typeof r.then === 'function')))\r\n  }\r", "name": "getActiveThemes", "func_location": "ThemeManager.deactivateThemes", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 353, "func_start_line": 350}}, {"func_info": {"comment": [], "name": "DecorationManager.observeDecoratedLayer", "params": ["layer", "isMarkerDecoration"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js", "end_line": 275, "start_line": 266}, "call_info": {"func_end_line": 207, "code": "  decorateMarker (marker, decorationParams) {\r\n    if (marker.isDestroyed()) {\r\n      const error = new Error('Cannot decorate a destroyed marker')\r\n      error.metadata = {markerLayerIsDestroyed: marker.layer.isDestroyed()}\r\n      if (marker.destroyStackTrace != null) {\r\n        error.metadata.destroyStackTrace = marker.destroyStackTrace\r\n      }\r\n      if (marker.bufferMarker != null && marker.bufferMarker.destroyStackTrace != null) {\r\n        error.metadata.destroyStackTrace = marker.bufferMarker.destroyStackTrace\r\n      }\r\n      throw error\r\n    }\r\n    marker = this.displayLayer.getMarkerLayer(marker.layer.id).getMarker(marker.id)\r\n    const decoration = new Decoration(marker, this, decorationParams)\r\n    let decorationsForMarker = this.decorationsByMarker.get(marker)\r\n    if (!decorationsForMarker) {\r\n      decorationsForMarker = new Set()\r\n      this.decorationsByMarker.set(marker, decorationsForMarker)\r\n    }\r\n    decorationsForMarker.add(decoration)\r\n    if (decoration.isType('overlay')) this.overlayDecorations.add(decoration)\r\n    this.observeDecoratedLayer(marker.layer, true)\r\n    this.editor.didAddDecoration(decoration)\r\n    this.emitDidUpdateDecorations()\r\n    this.emitter.emit('did-add-decoration', decoration)\r\n    return decoration\r\n  }\r", "name": "observeDecoratedLayer", "func_location": "DecorationManager.decorateMarker", "args": ["marker.layer", {"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js", "line": 202, "func_start_line": 181}}, {"func_info": {"comment": [], "name": "DecorationManager.emitDidUpdateDecorations", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js", "end_line": 229, "start_line": 226}, "call_info": {"func_end_line": 207, "code": "  decorateMarker (marker, decorationParams) {\r\n    if (marker.isDestroyed()) {\r\n      const error = new Error('Cannot decorate a destroyed marker')\r\n      error.metadata = {markerLayerIsDestroyed: marker.layer.isDestroyed()}\r\n      if (marker.destroyStackTrace != null) {\r\n        error.metadata.destroyStackTrace = marker.destroyStackTrace\r\n      }\r\n      if (marker.bufferMarker != null && marker.bufferMarker.destroyStackTrace != null) {\r\n        error.metadata.destroyStackTrace = marker.bufferMarker.destroyStackTrace\r\n      }\r\n      throw error\r\n    }\r\n    marker = this.displayLayer.getMarkerLayer(marker.layer.id).getMarker(marker.id)\r\n    const decoration = new Decoration(marker, this, decorationParams)\r\n    let decorationsForMarker = this.decorationsByMarker.get(marker)\r\n    if (!decorationsForMarker) {\r\n      decorationsForMarker = new Set()\r\n      this.decorationsByMarker.set(marker, decorationsForMarker)\r\n    }\r\n    decorationsForMarker.add(decoration)\r\n    if (decoration.isType('overlay')) this.overlayDecorations.add(decoration)\r\n    this.observeDecoratedLayer(marker.layer, true)\r\n    this.editor.didAddDecoration(decoration)\r\n    this.emitDidUpdateDecorations()\r\n    this.emitter.emit('did-add-decoration', decoration)\r\n    return decoration\r\n  }\r", "name": "emitDidUpdateDecorations", "func_location": "DecorationManager.decorateMarker", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js", "line": 204, "func_start_line": 181}}, {"func_info": {"comment": [], "name": "DecorationManager.observeDecoratedLayer", "params": ["layer", "isMarkerDecoration"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js", "end_line": 275, "start_line": 266}, "call_info": {"func_end_line": 224, "code": "  decorateMarkerLayer (markerLayer, decorationParams) {\r\n    if (markerLayer.isDestroyed()) {\r\n      throw new Error('Cannot decorate a destroyed marker layer')\r\n    }\r\n    markerLayer = this.displayLayer.getMarkerLayer(markerLayer.id)\r\n    const decoration = new LayerDecoration(markerLayer, this, decorationParams)\r\n    let layerDecorations = this.layerDecorationsByMarkerLayer.get(markerLayer)\r\n    if (layerDecorations == null) {\r\n      layerDecorations = new Set()\r\n      this.layerDecorationsByMarkerLayer.set(markerLayer, layerDecorations)\r\n    }\r\n    layerDecorations.add(decoration)\r\n    this.observeDecoratedLayer(markerLayer, false)\r\n    this.emitDidUpdateDecorations()\r\n    return decoration\r\n  }\r", "name": "observeDecoratedLayer", "func_location": "DecorationManager.decorateMarkerLayer", "args": ["markerLayer", {"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js", "line": 221, "func_start_line": 209}}, {"func_info": {"comment": [], "name": "DecorationManager.emitDidUpdateDecorations", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js", "end_line": 229, "start_line": 226}, "call_info": {"func_end_line": 224, "code": "  decorateMarkerLayer (markerLayer, decorationParams) {\r\n    if (markerLayer.isDestroyed()) {\r\n      throw new Error('Cannot decorate a destroyed marker layer')\r\n    }\r\n    markerLayer = this.displayLayer.getMarkerLayer(markerLayer.id)\r\n    const decoration = new LayerDecoration(markerLayer, this, decorationParams)\r\n    let layerDecorations = this.layerDecorationsByMarkerLayer.get(markerLayer)\r\n    if (layerDecorations == null) {\r\n      layerDecorations = new Set()\r\n      this.layerDecorationsByMarkerLayer.set(markerLayer, layerDecorations)\r\n    }\r\n    layerDecorations.add(decoration)\r\n    this.observeDecoratedLayer(markerLayer, false)\r\n    this.emitDidUpdateDecorations()\r\n    return decoration\r\n  }\r", "name": "emitDidUpdateDecorations", "func_location": "DecorationManager.decorateMarkerLayer", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js", "line": 222, "func_start_line": 209}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.regexForPattern", "params": ["pattern"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 720, "start_line": 713}, "call_info": {"func_end_line": 703, "code": "  decreaseIndentRegexForScopeDescriptor (scope) {\r\n    return this.regexForPattern(this.config.get('editor.decreaseIndentPattern', {scope}))\r\n  }\r", "name": "regexForPattern", "func_location": "TextMateLanguageMode.decreaseIndentRegexForScopeDescriptor", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 702, "func_start_line": 701}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.regexForPattern", "params": ["pattern"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 720, "start_line": 713}, "call_info": {"func_end_line": 707, "code": "  decreaseNextIndentRegexForScopeDescriptor (scope) {\r\n    return this.regexForPattern(this.config.get('editor.decreaseNextIndentPattern', {scope}))\r\n  }\r", "name": "regexForPattern", "func_location": "TextMateLanguageMode.decreaseNextIndentRegexForScopeDescriptor", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 706, "func_start_line": 705}}, {"func_info": {"comment": [], "name": "Pane.getContainer", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 128, "start_line": 128}, "call_info": {"func_end_line": 168, "code": "  decreaseSize () {\r\n    if (this.getContainer().getPanes().length > 1) {\r\n      this.setFlexScale(this.getFlexScale() / 1.1)\r\n    }\r\n  }\r", "name": "getContainer", "func_location": "Pane.decreaseSize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 165, "func_start_line": 164}}, {"func_info": {"comment": [], "name": "Pane.setFlexScale", "params": ["flexScale"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 154, "start_line": 150}, "call_info": {"func_end_line": 168, "code": "  decreaseSize () {\r\n    if (this.getContainer().getPanes().length > 1) {\r\n      this.setFlexScale(this.getFlexScale() / 1.1)\r\n    }\r\n  }\r", "name": "setFlexScale", "func_location": "Pane.decreaseSize", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 166, "func_start_line": 164}}, {"func_info": {"comment": [], "name": "Pane.getFlexScale", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 156, "start_line": 156}, "call_info": {"func_end_line": 168, "code": "  decreaseSize () {\r\n    if (this.getContainer().getPanes().length > 1) {\r\n      this.setFlexScale(this.getFlexScale() / 1.1)\r\n    }\r\n  }\r", "name": "getFlexScale", "func_location": "Pane.decreaseSize", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 166, "func_start_line": 164}}, {"func_info": {"comment": [], "name": "Config.deepDefaults", "params": ["target"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1120, "start_line": 1104}, "call_info": {"func_end_line": 1120, "code": "  deepDefaults (target) {\r\n    let result = target\r\n    let i = 0\r\n    while (++i < arguments.length) {\r\n      const object = arguments[i]\r\n      if (isPlainObject(result) && isPlainObject(object)) {\r\n        for (let key of Object.keys(object)) {\r\n          result[key] = this.deepDefaults(result[key], object[key])\r\n        }\r\n      } else {\r\n        if ((result == null)) {\r\n          result = this.deepClone(object)\r\n        }\r\n      }\r\n    }\r\n    return result\r\n  }\r", "name": "deepDefaults", "func_location": "Config.deepDefaults", "args": ["result.key", "object.key"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1111, "func_start_line": 1104}}, {"func_info": {"comment": [], "name": "Config.deepClone", "params": ["object"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1102, "start_line": 1092}, "call_info": {"func_end_line": 1120, "code": "  deepDefaults (target) {\r\n    let result = target\r\n    let i = 0\r\n    while (++i < arguments.length) {\r\n      const object = arguments[i]\r\n      if (isPlainObject(result) && isPlainObject(object)) {\r\n        for (let key of Object.keys(object)) {\r\n          result[key] = this.deepDefaults(result[key], object[key])\r\n        }\r\n      } else {\r\n        if ((result == null)) {\r\n          result = this.deepClone(object)\r\n        }\r\n      }\r\n    }\r\n    return result\r\n  }\r", "name": "deepClone", "func_location": "Config.deepDefaults", "args": ["object"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1115, "func_start_line": 1104}}, {"func_info": {"comment": [" Private: Ensure that the {TextEditor} is not marked read-only before allowing a buffer modification to occur. if", " the editor is read-only, require an explicit opt-in option to proceed (`bypassReadOnly`) or throw an Error."], "name": "Selection.ensureWritable", "params": ["methodName", "opts"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 427, "start_line": 412}, "call_info": {"func_end_line": 574, "comment": [" Public: Removes from the beginning of the line which the selection begins on", " all the way through to the end of the selection.", "", " * `options` (optional) {Object}", "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"], "code": "  deleteToBeginningOfLine (options = {}) {\r\n    if (!this.ensureWritable('deleteToBeginningOfLine', options)) return\r\n    if (this.isEmpty() && this.cursor.isAtBeginningOfLine()) {\r\n      this.selectLeft()\r\n    } else {\r\n      this.selectToBeginningOfLine()\r\n    }\r\n    this.deleteSelectedText(options)\r\n  }\r", "name": "ensureWritable", "func_location": "Selection.deleteToBeginningOfLine", "args": [{"type": "string"}, "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 567, "func_start_line": 566}}, {"func_info": {"comment": ["\r\n  Section: Info about the selection\r\n  ", " Public: Determines if the selection contains anything."], "name": "Selection.isEmpty", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 141, "start_line": 139}, "call_info": {"func_end_line": 574, "comment": [" Public: Removes from the beginning of the line which the selection begins on", " all the way through to the end of the selection.", "", " * `options` (optional) {Object}", "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"], "code": "  deleteToBeginningOfLine (options = {}) {\r\n    if (!this.ensureWritable('deleteToBeginningOfLine', options)) return\r\n    if (this.isEmpty() && this.cursor.isAtBeginningOfLine()) {\r\n      this.selectLeft()\r\n    } else {\r\n      this.selectToBeginningOfLine()\r\n    }\r\n    this.deleteSelectedText(options)\r\n  }\r", "name": "isEmpty", "func_location": "Selection.deleteToBeginningOfLine", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 568, "func_start_line": 566}}, {"func_info": {"comment": [" Public: Selects the text one position left of the cursor.", "", " * `columnCount` (optional) {Number} number of columns to select (default: 1)"], "name": "Selection.selectLeft", "params": ["columnCount"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 253, "start_line": 251}, "call_info": {"func_end_line": 574, "comment": [" Public: Removes from the beginning of the line which the selection begins on", " all the way through to the end of the selection.", "", " * `options` (optional) {Object}", "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"], "code": "  deleteToBeginningOfLine (options = {}) {\r\n    if (!this.ensureWritable('deleteToBeginningOfLine', options)) return\r\n    if (this.isEmpty() && this.cursor.isAtBeginningOfLine()) {\r\n      this.selectLeft()\r\n    } else {\r\n      this.selectToBeginningOfLine()\r\n    }\r\n    this.deleteSelectedText(options)\r\n  }\r", "name": "selectLeft", "func_location": "Selection.deleteToBeginningOfLine", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 569, "func_start_line": 566}}, {"func_info": {"comment": [" Public: Selects all the text from the current cursor position to the", " beginning of the line."], "name": "Selection.selectToBeginningOfLine", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 290, "start_line": 288}, "call_info": {"func_end_line": 574, "comment": [" Public: Removes from the beginning of the line which the selection begins on", " all the way through to the end of the selection.", "", " * `options` (optional) {Object}", "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"], "code": "  deleteToBeginningOfLine (options = {}) {\r\n    if (!this.ensureWritable('deleteToBeginningOfLine', options)) return\r\n    if (this.isEmpty() && this.cursor.isAtBeginningOfLine()) {\r\n      this.selectLeft()\r\n    } else {\r\n      this.selectToBeginningOfLine()\r\n    }\r\n    this.deleteSelectedText(options)\r\n  }\r", "name": "selectToBeginningOfLine", "func_location": "Selection.deleteToBeginningOfLine", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 571, "func_start_line": 566}}, {"func_info": {"comment": [" Private: Ensure that the {TextEditor} is not marked read-only before allowing a buffer modification to occur. if", " the editor is read-only, require an explicit opt-in option to proceed (`bypassReadOnly`) or throw an Error."], "name": "Selection.ensureWritable", "params": ["methodName", "opts"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 427, "start_line": 412}, "call_info": {"func_end_line": 559, "comment": [" Public: Removes from the start of the selection to the beginning of the", " current word if the selection is empty otherwise it deletes the selection.", "", " * `options` (optional) {Object}", "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"], "code": "  deleteToBeginningOfWord (options = {}) {\r\n    if (!this.ensureWritable('deleteToBeginningOfWord', options)) return\r\n    if (this.isEmpty()) this.selectToBeginningOfWord()\r\n    this.deleteSelectedText(options)\r\n  }\r", "name": "ensureWritable", "func_location": "Selection.deleteToBeginningOfWord", "args": [{"type": "string"}, "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 556, "func_start_line": 555}}, {"func_info": {"comment": ["\r\n  Section: Info about the selection\r\n  ", " Public: Determines if the selection contains anything."], "name": "Selection.isEmpty", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 141, "start_line": 139}, "call_info": {"func_end_line": 559, "comment": [" Public: Removes from the start of the selection to the beginning of the", " current word if the selection is empty otherwise it deletes the selection.", "", " * `options` (optional) {Object}", "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"], "code": "  deleteToBeginningOfWord (options = {}) {\r\n    if (!this.ensureWritable('deleteToBeginningOfWord', options)) return\r\n    if (this.isEmpty()) this.selectToBeginningOfWord()\r\n    this.deleteSelectedText(options)\r\n  }\r", "name": "isEmpty", "func_location": "Selection.deleteToBeginningOfWord", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 557, "func_start_line": 555}}, {"func_info": {"comment": [" Public: Selects all the text from the current cursor position to the", " beginning of the word."], "name": "Selection.selectToBeginningOfWord", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 314, "start_line": 312}, "call_info": {"func_end_line": 559, "comment": [" Public: Removes from the start of the selection to the beginning of the", " current word if the selection is empty otherwise it deletes the selection.", "", " * `options` (optional) {Object}", "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"], "code": "  deleteToBeginningOfWord (options = {}) {\r\n    if (!this.ensureWritable('deleteToBeginningOfWord', options)) return\r\n    if (this.isEmpty()) this.selectToBeginningOfWord()\r\n    this.deleteSelectedText(options)\r\n  }\r", "name": "selectToBeginningOfWord", "func_location": "Selection.deleteToBeginningOfWord", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 557, "func_start_line": 555}}, {"func_info": {"comment": [" Private: Ensure that the {TextEditor} is not marked read-only before allowing a buffer modification to occur. if", " the editor is read-only, require an explicit opt-in option to proceed (`bypassReadOnly`) or throw an Error."], "name": "Selection.ensureWritable", "params": ["methodName", "opts"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 427, "start_line": 412}, "call_info": {"func_end_line": 548, "comment": [" Public: Removes the selection or, if nothing is selected, then all", " characters from the start of the selection up to the next word", " boundary.", "", " * `options` (optional) {Object}", "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"], "code": "  deleteToNextWordBoundary (options = {}) {\r\n    if (!this.ensureWritable('deleteToNextWordBoundary', options)) return\r\n    if (this.isEmpty()) this.selectToNextWordBoundary()\r\n    this.deleteSelectedText(options)\r\n  }\r", "name": "ensureWritable", "func_location": "Selection.deleteToNextWordBoundary", "args": [{"type": "string"}, "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 545, "func_start_line": 544}}, {"func_info": {"comment": ["\r\n  Section: Info about the selection\r\n  ", " Public: Determines if the selection contains anything."], "name": "Selection.isEmpty", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 141, "start_line": 139}, "call_info": {"func_end_line": 548, "comment": [" Public: Removes the selection or, if nothing is selected, then all", " characters from the start of the selection up to the next word", " boundary.", "", " * `options` (optional) {Object}", "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"], "code": "  deleteToNextWordBoundary (options = {}) {\r\n    if (!this.ensureWritable('deleteToNextWordBoundary', options)) return\r\n    if (this.isEmpty()) this.selectToNextWordBoundary()\r\n    this.deleteSelectedText(options)\r\n  }\r", "name": "isEmpty", "func_location": "Selection.deleteToNextWordBoundary", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 546, "func_start_line": 544}}, {"func_info": {"comment": [" Public: Selects text to the next word boundary."], "name": "Selection.selectToNextWordBoundary", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 336, "start_line": 334}, "call_info": {"func_end_line": 548, "comment": [" Public: Removes the selection or, if nothing is selected, then all", " characters from the start of the selection up to the next word", " boundary.", "", " * `options` (optional) {Object}", "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"], "code": "  deleteToNextWordBoundary (options = {}) {\r\n    if (!this.ensureWritable('deleteToNextWordBoundary', options)) return\r\n    if (this.isEmpty()) this.selectToNextWordBoundary()\r\n    this.deleteSelectedText(options)\r\n  }\r", "name": "selectToNextWordBoundary", "func_location": "Selection.deleteToNextWordBoundary", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 546, "func_start_line": 544}}, {"func_info": {"comment": [" Private: Ensure that the {TextEditor} is not marked read-only before allowing a buffer modification to occur. if", " the editor is read-only, require an explicit opt-in option to proceed (`bypassReadOnly`) or throw an Error."], "name": "Selection.ensureWritable", "params": ["methodName", "opts"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 427, "start_line": 412}, "call_info": {"func_end_line": 536, "comment": [" Public: Removes the selection or, if nothing is selected, then all", " characters from the start of the selection back to the previous word", " boundary.", "", " * `options` (optional) {Object}", "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"], "code": "  deleteToPreviousWordBoundary (options = {}) {\r\n    if (!this.ensureWritable('deleteToPreviousWordBoundary', options)) return\r\n    if (this.isEmpty()) this.selectToPreviousWordBoundary()\r\n    this.deleteSelectedText(options)\r\n  }\r", "name": "ensureWritable", "func_location": "Selection.deleteToPreviousWordBoundary", "args": [{"type": "string"}, "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 533, "func_start_line": 532}}, {"func_info": {"comment": ["\r\n  Section: Info about the selection\r\n  ", " Public: Determines if the selection contains anything."], "name": "Selection.isEmpty", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 141, "start_line": 139}, "call_info": {"func_end_line": 536, "comment": [" Public: Removes the selection or, if nothing is selected, then all", " characters from the start of the selection back to the previous word", " boundary.", "", " * `options` (optional) {Object}", "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"], "code": "  deleteToPreviousWordBoundary (options = {}) {\r\n    if (!this.ensureWritable('deleteToPreviousWordBoundary', options)) return\r\n    if (this.isEmpty()) this.selectToPreviousWordBoundary()\r\n    this.deleteSelectedText(options)\r\n  }\r", "name": "isEmpty", "func_location": "Selection.deleteToPreviousWordBoundary", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 534, "func_start_line": 532}}, {"func_info": {"comment": [" Public: Selects text to the previous word boundary."], "name": "Selection.selectToPreviousWordBoundary", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 331, "start_line": 329}, "call_info": {"func_end_line": 536, "comment": [" Public: Removes the selection or, if nothing is selected, then all", " characters from the start of the selection back to the previous word", " boundary.", "", " * `options` (optional) {Object}", "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"], "code": "  deleteToPreviousWordBoundary (options = {}) {\r\n    if (!this.ensureWritable('deleteToPreviousWordBoundary', options)) return\r\n    if (this.isEmpty()) this.selectToPreviousWordBoundary()\r\n    this.deleteSelectedText(options)\r\n  }\r", "name": "selectToPreviousWordBoundary", "func_location": "Selection.deleteToPreviousWordBoundary", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 534, "func_start_line": 532}}, {"func_info": {"comment": [], "name": "ShellOption.isRegistered", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/win-shell.js", "end_line": 23, "start_line": 20}, "call_info": {"func_end_line": 41, "name": "isRegistered", "func_location": "ShellOption.deregister", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/win-shell.js", "line": 34, "func_start_line": 33}}, {"func_info": {"comment": [], "name": "PaneContainer.setRoot", "params": ["root"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 139, "start_line": 131}, "call_info": {"func_end_line": 58, "code": "  deserialize (state, deserializerManager) {\r\n    if (state.version !== SERIALIZATION_VERSION) return\r\n    this.itemRegistry = new ItemRegistry()\r\n    this.setRoot(deserializerManager.deserialize(state.root))\r\n    this.activePane = find(this.getRoot().getPanes(), pane => pane.id === state.activePaneId) || this.getPanes()[0]\r\n    if (this.config.get('core.destroyEmptyPanes')) this.destroyEmptyPanes()\r\n  }\r", "name": "setRoot", "func_location": "PaneContainer.deserialize", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 55, "func_start_line": 52}}, {"func_info": {"comment": [], "name": "PaneContainer.getRoot", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 129, "start_line": 129}, "call_info": {"func_end_line": 58, "code": "  deserialize (state, deserializerManager) {\r\n    if (state.version !== SERIALIZATION_VERSION) return\r\n    this.itemRegistry = new ItemRegistry()\r\n    this.setRoot(deserializerManager.deserialize(state.root))\r\n    this.activePane = find(this.getRoot().getPanes(), pane => pane.id === state.activePaneId) || this.getPanes()[0]\r\n    if (this.config.get('core.destroyEmptyPanes')) this.destroyEmptyPanes()\r\n  }\r", "name": "getRoot", "func_location": "PaneContainer.deserialize", "args": [null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 56, "func_start_line": 52}}, {"func_info": {"comment": [], "name": "PaneContainer.getPanes", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 152, "start_line": 146}, "call_info": {"func_end_line": 58, "code": "  deserialize (state, deserializerManager) {\r\n    if (state.version !== SERIALIZATION_VERSION) return\r\n    this.itemRegistry = new ItemRegistry()\r\n    this.setRoot(deserializerManager.deserialize(state.root))\r\n    this.activePane = find(this.getRoot().getPanes(), pane => pane.id === state.activePaneId) || this.getPanes()[0]\r\n    if (this.config.get('core.destroyEmptyPanes')) this.destroyEmptyPanes()\r\n  }\r", "name": "getPanes", "func_location": "PaneContainer.deserialize", "args": [null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 56, "func_start_line": 52}}, {"func_info": {"comment": [], "name": "PaneContainer.destroyEmptyPanes", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 232, "start_line": 230}, "call_info": {"func_end_line": 58, "code": "  deserialize (state, deserializerManager) {\r\n    if (state.version !== SERIALIZATION_VERSION) return\r\n    this.itemRegistry = new ItemRegistry()\r\n    this.setRoot(deserializerManager.deserialize(state.root))\r\n    this.activePane = find(this.getRoot().getPanes(), pane => pane.id === state.activePaneId) || this.getPanes()[0]\r\n    if (this.config.get('core.destroyEmptyPanes')) this.destroyEmptyPanes()\r\n  }\r", "name": "destroyEmptyPanes", "func_location": "PaneContainer.deserialize", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 57, "func_start_line": 52}}, {"func_info": {"comment": [" Essential: Get the workspace center's active item if it is a {TextEditor}.", "", " Returns a {TextEditor} or `undefined` if the workspace center's current", " active item is not a {TextEditor}."], "name": "Workspace.getActiveTextEditor", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1375, "start_line": 1372}, "call_info": {"func_end_line": 381, "code": "  deserialize (state, deserializerManager) {\r\n    const packagesWithActiveGrammars =\r\n      state.packagesWithActiveGrammars != null ? state.packagesWithActiveGrammars : []\r\n    for (let packageName of packagesWithActiveGrammars) {\r\n      const pkg = this.packageManager.getLoadedPackage(packageName)\r\n      if (pkg != null) {\r\n        pkg.loadGrammarsSync()\r\n      }\r\n    }\r\n    if (state.destroyedItemURIs != null) {\r\n      this.destroyedItemURIs = state.destroyedItemURIs\r\n    }\r\n\r\n    if (state.paneContainers) {\r\n      this.paneContainers.center.deserialize(state.paneContainers.center, deserializerManager)\r\n      this.paneContainers.left.deserialize(state.paneContainers.left, deserializerManager)\r\n      this.paneContainers.right.deserialize(state.paneContainers.right, deserializerManager)\r\n      this.paneContainers.bottom.deserialize(state.paneContainers.bottom, deserializerManager)\r\n    } else if (state.paneContainer) {\r\n      // TODO: Remove this fallback once a lot of time has passed since 1.17 was released\r\n      this.paneContainers.center.deserialize(state.paneContainer, deserializerManager)\r\n    }\r\n\r\n    this.hasActiveTextEditor = this.getActiveTextEditor() != null\r\n\r\n    this.updateWindowTitle()\r\n  }\r", "name": "getActiveTextEditor", "func_location": "Workspace.deserialize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 378, "func_start_line": 355}}, {"func_info": {"comment": [" Updates the application's title and proxy icon based on whichever file is", " open."], "name": "Workspace.updateWindowTitle", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 604, "start_line": 561}, "call_info": {"func_end_line": 381, "code": "  deserialize (state, deserializerManager) {\r\n    const packagesWithActiveGrammars =\r\n      state.packagesWithActiveGrammars != null ? state.packagesWithActiveGrammars : []\r\n    for (let packageName of packagesWithActiveGrammars) {\r\n      const pkg = this.packageManager.getLoadedPackage(packageName)\r\n      if (pkg != null) {\r\n        pkg.loadGrammarsSync()\r\n      }\r\n    }\r\n    if (state.destroyedItemURIs != null) {\r\n      this.destroyedItemURIs = state.destroyedItemURIs\r\n    }\r\n\r\n    if (state.paneContainers) {\r\n      this.paneContainers.center.deserialize(state.paneContainers.center, deserializerManager)\r\n      this.paneContainers.left.deserialize(state.paneContainers.left, deserializerManager)\r\n      this.paneContainers.right.deserialize(state.paneContainers.right, deserializerManager)\r\n      this.paneContainers.bottom.deserialize(state.paneContainers.bottom, deserializerManager)\r\n    } else if (state.paneContainer) {\r\n      // TODO: Remove this fallback once a lot of time has passed since 1.17 was released\r\n      this.paneContainers.center.deserialize(state.paneContainer, deserializerManager)\r\n    }\r\n\r\n    this.hasActiveTextEditor = this.getActiveTextEditor() != null\r\n\r\n    this.updateWindowTitle()\r\n  }\r", "name": "updateWindowTitle", "func_location": "Workspace.deserialize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 380, "func_start_line": 355}}, {"func_info": {"comment": [" Get the deserializer for the state.", "", " * `state` The state {Object} being deserialized."], "name": "DeserializerManager.get", "params": ["state"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/deserializer-manager.js", "end_line": 94, "start_line": 83}, "call_info": {"func_end_line": 78, "comment": [" Public: Deserialize the state and params.", "", " * `state` The state {Object} to deserialize."], "code": "  deserialize (state) {\r\n    if (state == null) {\r\n      return\r\n    }\r\n\r\n    const deserializer = this.get(state)\r\n    if (deserializer) {\r\n      let stateVersion = (\r\n        (typeof state.get === 'function') && state.get('version') ||\r\n        state.version\r\n      )\r\n\r\n      if ((deserializer.version != null) && deserializer.version !== stateVersion) {\r\n        return\r\n      }\r\n      return deserializer.deserialize(state, this.atomEnvironment)\r\n    } else {\r\n      return console.warn('No deserializer found for', state)\r\n    }\r\n  }\r", "name": "get", "func_location": "DeserializerManager.deserialize", "args": ["state"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/deserializer-manager.js", "line": 64, "func_start_line": 59}}, {"func_info": {"comment": [" Extended: Set the full screen state of the current window."], "name": "AtomEnvironment.setFullScreen", "params": ["fullScreen"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 648, "start_line": 646}, "call_info": {"func_end_line": 1277, "code": "  async deserialize (state) {\r\n    if (!state) return Promise.resolve()\r\n\r\n    this.setFullScreen(state.fullScreen)\r\n\r\n    const missingProjectPaths = []\r\n\r\n    this.packages.packageStates = state.packageStates || {}\r\n\r\n    let startTime = Date.now()\r\n    if (state.project) {\r\n      try {\r\n        await this.project.deserialize(state.project, this.deserializers)\r\n      } catch (error) {\r\n        if (error.missingProjectPaths) {\r\n          missingProjectPaths.push(...error.missingProjectPaths)\r\n        } else {\r\n          this.notifications.addError('Unable to deserialize project', {\r\n            description: error.message,\r\n            stack: error.stack\r\n          })\r\n        }\r\n      }\r\n    }\r\n\r\n    this.deserializeTimings.project = Date.now() - startTime\r\n\r\n    if (state.grammars) this.grammars.deserialize(state.grammars)\r\n\r\n    startTime = Date.now()\r\n    if (state.workspace) this.workspace.deserialize(state.workspace, this.deserializers)\r\n    this.deserializeTimings.workspace = Date.now() - startTime\r\n\r\n    if (missingProjectPaths.length > 0) {\r\n      const count = missingProjectPaths.length === 1 ? '' : missingProjectPaths.length + ' '\r\n      const noun = missingProjectPaths.length === 1 ? 'directory' : 'directories'\r\n      const toBe = missingProjectPaths.length === 1 ? 'is' : 'are'\r\n      const escaped = missingProjectPaths.map(projectPath => `\\`${projectPath}\\``)\r\n      let group\r\n      switch (escaped.length) {\r\n        case 1:\r\n          group = escaped[0]\r\n          break\r\n        case 2:\r\n          group = `${escaped[0]} and ${escaped[1]}`\r\n          break\r\n        default:\r\n          group = escaped.slice(0, -1).join(', ') + `, and ${escaped[escaped.length - 1]}`\r\n      }\r\n\r\n      this.notifications.addError(`Unable to open ${count}project ${noun}`, {\r\n        description: `Project ${noun} ${group} ${toBe} no longer on disk.`\r\n      })\r\n    }\r\n  }\r", "name": "setFullScreen", "func_location": "AtomEnvironment.deserialize", "args": ["state.fullScreen"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 1226, "func_start_line": 1223}}, {"func_info": {"comment": [], "name": "PaneAxis.constructor", "params": [["orientation", "children", "flexScale"], "viewRegistry"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js", "end_line": 28, "start_line": 12}, "call_info": {"func_end_line": 10, "name": "constructor", "func_location": "PaneAxis.deserialize", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js", "line": 9, "func_start_line": 7}}, {"func_info": {"comment": [], "name": "Dock.setState", "params": ["newState"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 177, "start_line": 144}, "call_info": {"func_end_line": 432, "name": "setState", "func_location": "Dock.deserialize", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 427, "func_start_line": 425}}, {"func_info": {"comment": [], "name": "Dock.getInitialSize", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 414, "start_line": 407}, "call_info": {"func_end_line": 432, "code": "  deserialize (serialized, deserializerManager) {\r\n    this.paneContainer.deserialize(serialized.paneContainer, deserializerManager)\r\n    this.setState({\r\n      size: serialized.size || this.getInitialSize(),\r\n      // If no items could be deserialized, we don't want to show the dock (even if it was visible last time)\r\n      visible: serialized.visible && (this.paneContainer.getPaneItems().length > 0)\r\n    })\r\n  }\r", "name": "getInitialSize", "func_location": "Dock.deserialize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 428, "func_start_line": 425}}, {"func_info": {"comment": [], "name": "Pane.constructor", "params": ["params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 87, "start_line": 53}, "call_info": {"func_end_line": 51, "name": "constructor", "func_location": "Pane.deserialize", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 44, "func_start_line": 26}}, {"func_info": {"comment": [], "name": "OverlayComponent.didDetach", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4331, "start_line": 4329}, "call_info": {"func_end_line": 4297, "code": "  destroy () {\r\n    this.props.overlayComponents.delete(this)\r\n    this.didDetach()\r\n  }\r", "name": "didDetach", "func_location": "OverlayComponent.destroy", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 4296, "func_start_line": 4294}}, {"func_info": {"comment": [], "name": "PaneContainer.getRoot", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 129, "start_line": 129}, "call_info": {"func_end_line": 37, "code": "  destroy () {\r\n    this.alive = false\r\n    for (let pane of this.getRoot().getPanes()) { pane.destroy() }\r\n    this.cancelStoppedChangingActivePaneItemTimeout()\r\n    this.subscriptions.dispose()\r\n    this.emitter.dispose()\r\n  }\r", "name": "getRoot", "func_location": "PaneContainer.destroy", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 33, "func_start_line": 31}}, {"func_info": {"comment": [], "name": "PaneContainer.cancelStoppedChangingActivePaneItemTimeout", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 298, "start_line": 294}, "call_info": {"func_end_line": 37, "code": "  destroy () {\r\n    this.alive = false\r\n    for (let pane of this.getRoot().getPanes()) { pane.destroy() }\r\n    this.cancelStoppedChangingActivePaneItemTimeout()\r\n    this.subscriptions.dispose()\r\n    this.emitter.dispose()\r\n  }\r", "name": "cancelStoppedChangingActivePaneItemTimeout", "func_location": "PaneContainer.destroy", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 34, "func_start_line": 31}}, {"func_info": {"comment": [], "name": "PanelContainer.getPanels", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/panel-container.js", "end_line": 54, "start_line": 54}, "call_info": {"func_end_line": 21, "code": "  destroy () {\r\n    for (let panel of this.getPanels()) { panel.destroy() }\r\n    this.subscriptions.dispose()\r\n    this.emitter.emit('did-destroy', this)\r\n    this.emitter.dispose()\r\n  }\r", "name": "getPanels", "func_location": "PanelContainer.destroy", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/panel-container.js", "line": 17, "func_start_line": 16}}, {"func_info": {"comment": [" Public: Hide this panel"], "name": "Panel.hide", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/panel.js", "end_line": 100, "start_line": 95}, "call_info": {"func_end_line": 35, "comment": [" Public: Destroy and remove this panel from the UI."], "code": "  destroy () {\r\n    if (this.destroyed) return\r\n    this.destroyed = true\r\n    this.hide()\r\n    if (this.element) this.element.remove()\r\n    this.emitter.emit('did-destroy', this)\r\n    return this.emitter.dispose()\r\n  }\r", "name": "hide", "func_location": "Panel.destroy", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/panel.js", "line": 31, "func_start_line": 28}}, {"func_info": {"comment": [], "name": "AtomEnvironment.uninstallWindowEventHandler", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 961, "start_line": 956}, "call_info": {"func_end_line": 384, "code": "  destroy () {\r\n    if (!this.project) return\r\n\r\n    this.disposables.dispose()\r\n    if (this.workspace) this.workspace.destroy()\r\n    this.workspace = null\r\n    this.themes.workspace = null\r\n    if (this.project) this.project.destroy()\r\n    this.project = null\r\n    this.commands.clear()\r\n    if (this.stylesElement) this.stylesElement.remove()\r\n    this.autoUpdater.destroy()\r\n    this.uriHandlerRegistry.destroy()\r\n\r\n    this.uninstallWindowEventHandler()\r\n  }\r", "name": "uninstallWindowEventHandler", "func_location": "AtomEnvironment.destroy", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 383, "func_start_line": 369}}, {"func_info": {"comment": [], "name": "AtomApplication.getAllWindows", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 323, "start_line": 321}, "call_info": {"func_end_line": 170, "code": "  async destroy () {\r\n    const windowsClosePromises = this.getAllWindows().map(window => {\r\n      window.close()\r\n      return window.closedPromise\r\n    })\r\n    await Promise.all(windowsClosePromises)\r\n    this.disposable.dispose()\r\n  }\r", "name": "getAllWindows", "func_location": "AtomApplication.destroy", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 164, "func_start_line": 163}}, {"func_info": {"comment": [" Public: Destroy all items."], "name": "Pane.destroyItems", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 789, "start_line": 785}, "call_info": {"func_end_line": 1039, "comment": [" Public: Close the pane and destroy all its items.", "", " If this is the last pane, all the items will be destroyed but the pane", " itself will not be destroyed."], "code": "  destroy () {\r\n    if (this.container && this.container.isAlive() && this.container.getPanes().length === 1) {\r\n      return this.destroyItems()\r\n    }\r\n\r\n    this.emitter.emit('will-destroy')\r\n    this.alive = false\r\n    if (this.container) {\r\n      this.container.willDestroyPane({pane: this})\r\n      if (this.isActive()) this.container.activateNextPane()\r\n    }\r\n    this.emitter.emit('did-destroy')\r\n    this.emitter.dispose()\r\n    for (let item of this.items.slice()) {\r\n      if (typeof item.destroy === 'function') item.destroy()\r\n    }\r\n    if (this.container) this.container.didDestroyPane({pane: this})\r\n  }\r", "name": "destroyItems", "func_location": "Pane.destroy", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 1024, "func_start_line": 1022}}, {"func_info": {"comment": ["\r\n  Section: Lifecycle\r\n  ", " Public: Determine whether the pane is active.", "", " Returns a {Boolean}."], "name": "Pane.isActive", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 1009, "start_line": 1007}, "call_info": {"func_end_line": 1039, "comment": [" Public: Close the pane and destroy all its items.", "", " If this is the last pane, all the items will be destroyed but the pane", " itself will not be destroyed."], "code": "  destroy () {\r\n    if (this.container && this.container.isAlive() && this.container.getPanes().length === 1) {\r\n      return this.destroyItems()\r\n    }\r\n\r\n    this.emitter.emit('will-destroy')\r\n    this.alive = false\r\n    if (this.container) {\r\n      this.container.willDestroyPane({pane: this})\r\n      if (this.isActive()) this.container.activateNextPane()\r\n    }\r\n    this.emitter.emit('did-destroy')\r\n    this.emitter.dispose()\r\n    for (let item of this.items.slice()) {\r\n      if (typeof item.destroy === 'function') item.destroy()\r\n    }\r\n    if (this.container) this.container.didDestroyPane({pane: this})\r\n  }\r", "name": "isActive", "func_location": "Pane.destroy", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 1031, "func_start_line": 1022}}, {"func_info": {"comment": [" Public: Destroy the given item.", "", " If the item is active, the next item will be activated. If the item is the", " last item, the pane will be destroyed if the `core.destroyEmptyPanes` config", " setting is `true`.", "", " * `item` Item to destroy", " * `force` (optional) {Boolean} Destroy the item without prompting to save", "    it, even if the item's `isPermanentDockItem` method returns true.", "", " Returns a {Promise} that resolves with a {Boolean} indicating whether or not", " the item was destroyed."], "name": "Pane.destroyItem", "params": ["item", "force"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 782, "start_line": 757}, "call_info": {"func_end_line": 743, "comment": [" Public: Destroy the active item and activate the next item.", "", " Returns a {Promise} that resolves when the item is destroyed."], "code": "  destroyActiveItem () {\r\n    return this.destroyItem(this.activeItem)\r\n  }\r", "name": "destroyItem", "func_location": "Pane.destroyActiveItem", "args": [".activeItem"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 742, "func_start_line": 741}}, {"func_info": {"comment": [" Extended: Get the active {Pane}.", "", " Returns a {Pane}."], "name": "WorkspaceCenter.getActivePane", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js", "end_line": 308, "start_line": 306}, "call_info": {"func_end_line": 334, "comment": [" Destroy (close) the active pane."], "code": "  destroyActivePane () {\r\n    const activePane = this.getActivePane()\r\n    if (activePane != null) {\r\n      activePane.destroy()\r\n    }\r\n  }\r", "name": "getActivePane", "func_location": "WorkspaceCenter.destroyActivePane", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js", "line": 330, "func_start_line": 329}}, {"func_info": {"comment": [" Extended: Get the active {Pane}.", "", " Returns a {Pane}."], "name": "Workspace.getActivePane", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1444, "start_line": 1442}, "call_info": {"func_end_line": 1511, "comment": [" Destroy (close) the active pane."], "code": "  destroyActivePane () {\r\n    const activePane = this.getActivePane()\r\n    if (activePane != null) {\r\n      activePane.destroy()\r\n    }\r\n  }\r", "name": "getActivePane", "func_location": "Workspace.destroyActivePane", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1507, "func_start_line": 1506}}, {"func_info": {"comment": [" Extended: Get the active {Pane}.", "", " Returns a {Pane}."], "name": "Dock.getActivePane", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 689, "start_line": 687}, "call_info": {"func_end_line": 715, "comment": [" Destroy (close) the active pane."], "code": "  destroyActivePane () {\r\n    const activePane = this.getActivePane()\r\n    if (activePane != null) {\r\n      activePane.destroy()\r\n    }\r\n  }\r", "name": "getActivePane", "func_location": "Dock.destroyActivePane", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 711, "func_start_line": 710}}, {"func_info": {"comment": [" Extended: Get the active {Pane}.", "", " Returns a {Pane}."], "name": "Workspace.getActivePane", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1444, "start_line": 1442}, "call_info": {"func_end_line": 1415, "comment": [" Destroy (close) the active pane item.", "", " Removes the active pane item and calls the `.destroy` method on it if one is", " defined."], "code": "  destroyActivePaneItem () {\r\n    return this.getActivePane().destroyActiveItem()\r\n  }\r", "name": "getActivePane", "func_location": "Workspace.destroyActivePaneItem", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1414, "func_start_line": 1413}}, {"func_info": {"comment": [], "name": "Workspace.cancelStoppedChangingActivePaneItemTimeout", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 487, "start_line": 483}, "call_info": {"func_end_line": 1592, "comment": [" Called by Model superclass when destroyed"], "code": "  destroyed () {\r\n    this.paneContainers.center.destroy()\r\n    this.paneContainers.left.destroy()\r\n    this.paneContainers.right.destroy()\r\n    this.paneContainers.bottom.destroy()\r\n    this.cancelStoppedChangingActivePaneItemTimeout()\r\n    if (this.activeItemSubscriptions != null) {\r\n      this.activeItemSubscriptions.dispose()\r\n    }\r\n    if (this.element) this.element.destroy()\r\n  }\r", "name": "cancelStoppedChangingActivePaneItemTimeout", "func_location": "Workspace.destroyed", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1587, "func_start_line": 1582}}, {"func_info": {"comment": [], "name": "PaneContainer.getPanes", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 152, "start_line": 146}, "call_info": {"func_end_line": 232, "code": "  destroyEmptyPanes () {\r\n    for (let pane of this.getPanes()) { if (pane.items.length === 0) { pane.destroy() } }\r\n  }\r", "name": "getPanes", "func_location": "PaneContainer.destroyEmptyPanes", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 231, "func_start_line": 230}}, {"func_info": {"comment": ["\r\n  Section: Items\r\n  ", " Public: Get the items in this pane.", "", " Returns an {Array} of items."], "name": "Pane.getItems", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 427, "start_line": 425}, "call_info": {"func_end_line": 798, "comment": [" Public: Destroy all items except for the active item."], "code": "  destroyInactiveItems () {\r\n    return Promise.all(\r\n      this.getItems()\r\n        .filter(item => item !== this.activeItem)\r\n        .map(item => this.destroyItem(item))\r\n    )\r\n  }\r", "name": "getItems", "func_location": "Pane.destroyInactiveItems", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 794, "func_start_line": 792}}, {"func_info": {"comment": [], "name": "Pane.promptToSaveItem", "params": ["item", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 848, "start_line": 800}, "call_info": {"func_end_line": 782, "comment": [" Public: Destroy the given item.", "", " If the item is active, the next item will be activated. If the item is the", " last item, the pane will be destroyed if the `core.destroyEmptyPanes` config", " setting is `true`.", "", " * `item` Item to destroy", " * `force` (optional) {Boolean} Destroy the item without prompting to save", "    it, even if the item's `isPermanentDockItem` method returns true.", "", " Returns a {Promise} that resolves with a {Boolean} indicating whether or not", " the item was destroyed."], "code": "  async destroyItem (item, force) {\r\n    const index = this.items.indexOf(item)\r\n    if (index === -1) return false\r\n\r\n    if (!force &&\r\n        typeof item.isPermanentDockItem === 'function' && item.isPermanentDockItem() &&\r\n        (!this.container || this.container.getLocation() !== 'center')) {\r\n      return false\r\n    }\r\n\r\n    // In the case where there are no `onWillDestroyPaneItem` listeners, preserve the old behavior\r\n    // where `Pane.destroyItem` and callers such as `Pane.close` take effect synchronously.\r\n    if (this.emitter.listenerCountForEventName('will-destroy-item') > 0) {\r\n      await this.emitter.emitAsync('will-destroy-item', {item, index})\r\n    }\r\n    if (this.container && this.container.emitter.listenerCountForEventName('will-destroy-pane-item') > 0) {\r\n      await this.container.willDestroyPaneItem({item, index, pane: this})\r\n    }\r\n\r\n    if (!force && typeof item.shouldPromptToSave === 'function' && item.shouldPromptToSave()) {\r\n      if (!await this.promptToSaveItem(item)) return false\r\n    }\r\n    this.removeItem(item, false)\r\n    if (typeof item.destroy === 'function') item.destroy()\r\n    return true\r\n  }\r", "name": "promptToSaveItem", "func_location": "Pane.destroyItem", "args": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 777, "func_start_line": 757}}, {"func_info": {"comment": [], "name": "Pane.removeItem", "params": ["item", "moved"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 705, "start_line": 684}, "call_info": {"func_end_line": 782, "comment": [" Public: Destroy the given item.", "", " If the item is active, the next item will be activated. If the item is the", " last item, the pane will be destroyed if the `core.destroyEmptyPanes` config", " setting is `true`.", "", " * `item` Item to destroy", " * `force` (optional) {Boolean} Destroy the item without prompting to save", "    it, even if the item's `isPermanentDockItem` method returns true.", "", " Returns a {Promise} that resolves with a {Boolean} indicating whether or not", " the item was destroyed."], "code": "  async destroyItem (item, force) {\r\n    const index = this.items.indexOf(item)\r\n    if (index === -1) return false\r\n\r\n    if (!force &&\r\n        typeof item.isPermanentDockItem === 'function' && item.isPermanentDockItem() &&\r\n        (!this.container || this.container.getLocation() !== 'center')) {\r\n      return false\r\n    }\r\n\r\n    // In the case where there are no `onWillDestroyPaneItem` listeners, preserve the old behavior\r\n    // where `Pane.destroyItem` and callers such as `Pane.close` take effect synchronously.\r\n    if (this.emitter.listenerCountForEventName('will-destroy-item') > 0) {\r\n      await this.emitter.emitAsync('will-destroy-item', {item, index})\r\n    }\r\n    if (this.container && this.container.emitter.listenerCountForEventName('will-destroy-pane-item') > 0) {\r\n      await this.container.willDestroyPaneItem({item, index, pane: this})\r\n    }\r\n\r\n    if (!force && typeof item.shouldPromptToSave === 'function' && item.shouldPromptToSave()) {\r\n      if (!await this.promptToSaveItem(item)) return false\r\n    }\r\n    this.removeItem(item, false)\r\n    if (typeof item.destroy === 'function') item.destroy()\r\n    return true\r\n  }\r", "name": "removeItem", "func_location": "Pane.destroyItem", "args": ["item", {"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 779, "func_start_line": 757}}, {"func_info": {"comment": ["\r\n  Section: Items\r\n  ", " Public: Get the items in this pane.", "", " Returns an {Array} of items."], "name": "Pane.getItems", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 427, "start_line": 425}, "call_info": {"func_end_line": 789, "comment": [" Public: Destroy all items."], "code": "  destroyItems () {\r\n    return Promise.all(\r\n      this.getItems().map(item => this.destroyItem(item))\r\n    )\r\n  }\r", "name": "getItems", "func_location": "Pane.destroyItems", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 787, "func_start_line": 785}}, {"func_info": {"comment": [" Retrieves all the {TextBuffer}s in the project; that is, the", " buffers for all open files.", "", " Returns an {Array} of {TextBuffer}s."], "name": "Project.getBuffers", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 623, "start_line": 621}, "call_info": {"func_end_line": 78, "code": "  destroyUnretainedBuffers () {\r\n    for (let buffer of this.getBuffers()) {\r\n      if (!buffer.isRetained()) buffer.destroy()\r\n    }\r\n  }\r", "name": "getBuffers", "func_location": "Project.destroyUnretainedBuffers", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 75, "func_start_line": 74}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 48, "code": "  detachedCallback () {\r\n    this.emitter.emit('did-detach')\r\n    this.getComponent().didDetach()\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.detachedCallback", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 47, "func_start_line": 45}}, {"func_info": {"comment": [], "name": "PaneContainer.getPanes", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 152, "start_line": 146}, "call_info": {"func_end_line": 263, "code": "  didActivatePane (activePane) {\r\n    if (activePane !== this.activePane) {\r\n      if (!this.getPanes().includes(activePane)) {\r\n        throw new Error('Setting active pane that is not present in pane container')\r\n      }\r\n\r\n      this.activePane = activePane\r\n      this.emitter.emit('did-change-active-pane', this.activePane)\r\n      this.didChangeActiveItemOnPane(this.activePane, this.activePane.getActiveItem())\r\n    }\r\n    this.emitter.emit('did-activate-pane', this.activePane)\r\n    return this.activePane\r\n  }\r", "name": "getPanes", "func_location": "PaneContainer.didActivatePane", "args": ["activePane"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 253, "func_start_line": 251}}, {"func_info": {"comment": [], "name": "PaneContainer.didChangeActiveItemOnPane", "params": ["pane", "activeItem"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 292, "start_line": 279}, "call_info": {"func_end_line": 263, "code": "  didActivatePane (activePane) {\r\n    if (activePane !== this.activePane) {\r\n      if (!this.getPanes().includes(activePane)) {\r\n        throw new Error('Setting active pane that is not present in pane container')\r\n      }\r\n\r\n      this.activePane = activePane\r\n      this.emitter.emit('did-change-active-pane', this.activePane)\r\n      this.didChangeActiveItemOnPane(this.activePane, this.activePane.getActiveItem())\r\n    }\r\n    this.emitter.emit('did-activate-pane', this.activePane)\r\n    return this.activePane\r\n  }\r", "name": "didChangeActiveItemOnPane", "func_location": "PaneContainer.didActivatePane", "args": [".activePane", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 259, "func_start_line": 251}}, {"func_info": {"comment": ["\r\n  Section: Panes\r\n  ", " Extended: Get the most recently focused pane container.", "", " Returns a {Dock} or the {WorkspaceCenter}."], "name": "Workspace.getActivePaneContainer", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1426, "start_line": 1424}, "call_info": {"func_end_line": 418, "code": "  didActivatePaneContainer (paneContainer) {\r\n    if (paneContainer !== this.getActivePaneContainer()) {\r\n      this.activePaneContainer = paneContainer\r\n      this.didChangeActivePaneItem(this.activePaneContainer.getActivePaneItem())\r\n      this.emitter.emit('did-change-active-pane-container', this.activePaneContainer)\r\n      this.emitter.emit('did-change-active-pane', this.activePaneContainer.getActivePane())\r\n      this.emitter.emit('did-change-active-pane-item', this.activePaneContainer.getActivePaneItem())\r\n    }\r\n  }\r", "name": "getActivePaneContainer", "func_location": "Workspace.didActivatePaneContainer", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 411, "func_start_line": 410}}, {"func_info": {"comment": [], "name": "Workspace.didChangeActivePaneItem", "params": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 481, "start_line": 443}, "call_info": {"func_end_line": 418, "code": "  didActivatePaneContainer (paneContainer) {\r\n    if (paneContainer !== this.getActivePaneContainer()) {\r\n      this.activePaneContainer = paneContainer\r\n      this.didChangeActivePaneItem(this.activePaneContainer.getActivePaneItem())\r\n      this.emitter.emit('did-change-active-pane-container', this.activePaneContainer)\r\n      this.emitter.emit('did-change-active-pane', this.activePaneContainer.getActivePane())\r\n      this.emitter.emit('did-change-active-pane-item', this.activePaneContainer.getActivePaneItem())\r\n    }\r\n  }\r", "name": "didChangeActivePaneItem", "func_location": "Workspace.didActivatePaneContainer", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 413, "func_start_line": 410}}, {"func_info": {"comment": [], "name": "PaneContainer.didAddPaneItem", "params": ["item", "pane", "index"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 268, "start_line": 265}, "call_info": {"func_end_line": 241, "code": "  didAddPane (event) {\r\n    this.emitter.emit('did-add-pane', event)\r\n    const items = event.pane.getItems()\r\n    for (let i = 0, length = items.length; i < length; i++) {\r\n      const item = items[i]\r\n      this.didAddPaneItem(item, event.pane, i)\r\n    }\r\n  }\r", "name": "didAddPaneItem", "func_location": "PaneContainer.didAddPane", "args": ["item", "event.pane", "i"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 239, "func_start_line": 234}}, {"func_info": {"comment": [], "name": "TextEditorComponent.isVisible", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2590, "start_line": 2588}, "call_info": {"func_end_line": 1441, "code": "  didAttach () {\r\n    if (!this.attached) {\r\n      this.attached = true\r\n      this.intersectionObserver = new IntersectionObserver((entries) => {\r\n        const {intersectionRect} = entries[entries.length - 1]\r\n        if (intersectionRect.width > 0 || intersectionRect.height > 0) {\r\n          this.didShow()\r\n        } else {\r\n          this.didHide()\r\n        }\r\n      })\r\n      this.intersectionObserver.observe(this.element)\r\n\r\n      this.resizeObserver = new ResizeObserver(this.didResize.bind(this))\r\n      this.resizeObserver.observe(this.element)\r\n\r\n      if (this.refs.gutterContainer) {\r\n        this.gutterContainerResizeObserver = new ResizeObserver(this.didResizeGutterContainer.bind(this))\r\n        this.gutterContainerResizeObserver.observe(this.refs.gutterContainer.element)\r\n      }\r\n\r\n      this.overlayComponents.forEach((component) => component.didAttach())\r\n\r\n      if (this.isVisible()) {\r\n        this.didShow()\r\n\r\n        if (this.refs.verticalScrollbar) this.refs.verticalScrollbar.flushScrollPosition()\r\n        if (this.refs.horizontalScrollbar) this.refs.horizontalScrollbar.flushScrollPosition()\r\n      } else {\r\n        this.didHide()\r\n      }\r\n      if (!this.constructor.attachedComponents) {\r\n        this.constructor.attachedComponents = new Set()\r\n      }\r\n      this.constructor.attachedComponents.add(this)\r\n    }\r\n  }\r", "name": "isVisible", "func_location": "TextEditorComponent.didAttach", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1428, "func_start_line": 1405}}, {"func_info": {"comment": [], "name": "TextEditorComponent.didShow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1465, "start_line": 1456}, "call_info": {"func_end_line": 1441, "code": "  didAttach () {\r\n    if (!this.attached) {\r\n      this.attached = true\r\n      this.intersectionObserver = new IntersectionObserver((entries) => {\r\n        const {intersectionRect} = entries[entries.length - 1]\r\n        if (intersectionRect.width > 0 || intersectionRect.height > 0) {\r\n          this.didShow()\r\n        } else {\r\n          this.didHide()\r\n        }\r\n      })\r\n      this.intersectionObserver.observe(this.element)\r\n\r\n      this.resizeObserver = new ResizeObserver(this.didResize.bind(this))\r\n      this.resizeObserver.observe(this.element)\r\n\r\n      if (this.refs.gutterContainer) {\r\n        this.gutterContainerResizeObserver = new ResizeObserver(this.didResizeGutterContainer.bind(this))\r\n        this.gutterContainerResizeObserver.observe(this.refs.gutterContainer.element)\r\n      }\r\n\r\n      this.overlayComponents.forEach((component) => component.didAttach())\r\n\r\n      if (this.isVisible()) {\r\n        this.didShow()\r\n\r\n        if (this.refs.verticalScrollbar) this.refs.verticalScrollbar.flushScrollPosition()\r\n        if (this.refs.horizontalScrollbar) this.refs.horizontalScrollbar.flushScrollPosition()\r\n      } else {\r\n        this.didHide()\r\n      }\r\n      if (!this.constructor.attachedComponents) {\r\n        this.constructor.attachedComponents = new Set()\r\n      }\r\n      this.constructor.attachedComponents.add(this)\r\n    }\r\n  }\r", "name": "didShow", "func_location": "TextEditorComponent.didAttach", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1429, "func_start_line": 1405}}, {"func_info": {"comment": [], "name": "TextEditorComponent.didHide", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1472, "start_line": 1467}, "call_info": {"func_end_line": 1441, "code": "  didAttach () {\r\n    if (!this.attached) {\r\n      this.attached = true\r\n      this.intersectionObserver = new IntersectionObserver((entries) => {\r\n        const {intersectionRect} = entries[entries.length - 1]\r\n        if (intersectionRect.width > 0 || intersectionRect.height > 0) {\r\n          this.didShow()\r\n        } else {\r\n          this.didHide()\r\n        }\r\n      })\r\n      this.intersectionObserver.observe(this.element)\r\n\r\n      this.resizeObserver = new ResizeObserver(this.didResize.bind(this))\r\n      this.resizeObserver.observe(this.element)\r\n\r\n      if (this.refs.gutterContainer) {\r\n        this.gutterContainerResizeObserver = new ResizeObserver(this.didResizeGutterContainer.bind(this))\r\n        this.gutterContainerResizeObserver.observe(this.refs.gutterContainer.element)\r\n      }\r\n\r\n      this.overlayComponents.forEach((component) => component.didAttach())\r\n\r\n      if (this.isVisible()) {\r\n        this.didShow()\r\n\r\n        if (this.refs.verticalScrollbar) this.refs.verticalScrollbar.flushScrollPosition()\r\n        if (this.refs.horizontalScrollbar) this.refs.horizontalScrollbar.flushScrollPosition()\r\n      } else {\r\n        this.didHide()\r\n      }\r\n      if (!this.constructor.attachedComponents) {\r\n        this.constructor.attachedComponents = new Set()\r\n      }\r\n      this.constructor.attachedComponents.add(this)\r\n    }\r\n  }\r", "name": "didHide", "func_location": "TextEditorComponent.didAttach", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1434, "func_start_line": 1405}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getHiddenInput", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2962, "start_line": 2960}, "call_info": {"func_end_line": 1504, "comment": [" Called by TextEditorElement so that this function is always the first", " listener to be fired, even if other listeners are bound before creating", " the component."], "code": "  didBlur (event) {\r\n    if (event.relatedTarget === this.getHiddenInput()) {\r\n      event.stopImmediatePropagation()\r\n    }\r\n  }\r", "name": "getHiddenInput", "func_location": "TextEditorComponent.didBlur", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1501, "func_start_line": 1500}}, {"func_info": {"comment": [], "name": "TextEditorComponent.stopCursorBlinking", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1999, "start_line": 1991}, "call_info": {"func_end_line": 1513, "code": "  didBlurHiddenInput (event) {\r\n    if (this.element !== event.relatedTarget && !this.element.contains(event.relatedTarget)) {\r\n      this.focused = false\r\n      this.stopCursorBlinking()\r\n      this.scheduleUpdate()\r\n      this.element.dispatchEvent(new FocusEvent(event.type, event))\r\n    }\r\n  }\r", "name": "stopCursorBlinking", "func_location": "TextEditorComponent.didBlurHiddenInput", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1509, "func_start_line": 1506}}, {"func_info": {"comment": [], "name": "TextEditorComponent.scheduleUpdate", "params": ["nextUpdateOnlyBlinksCursors"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 219, "start_line": 204}, "call_info": {"func_end_line": 1513, "code": "  didBlurHiddenInput (event) {\r\n    if (this.element !== event.relatedTarget && !this.element.contains(event.relatedTarget)) {\r\n      this.focused = false\r\n      this.stopCursorBlinking()\r\n      this.scheduleUpdate()\r\n      this.element.dispatchEvent(new FocusEvent(event.type, event))\r\n    }\r\n  }\r", "name": "scheduleUpdate", "func_location": "TextEditorComponent.didBlurHiddenInput", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1510, "func_start_line": 1506}}, {"func_info": {"comment": [], "name": "PaneContainer.getActivePane", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 160, "start_line": 158}, "call_info": {"func_end_line": 292, "code": "  didChangeActiveItemOnPane (pane, activeItem) {\r\n    if (pane === this.getActivePane()) {\r\n      this.emitter.emit('did-change-active-pane-item', activeItem)\r\n\r\n      this.cancelStoppedChangingActivePaneItemTimeout()\r\n      // `setTimeout()` isn't available during the snapshotting phase, but that's okay.\r\n      if (typeof setTimeout === 'function') {\r\n        this.stoppedChangingActivePaneItemTimeout = setTimeout(() => {\r\n          this.stoppedChangingActivePaneItemTimeout = null\r\n          this.emitter.emit('did-stop-changing-active-pane-item', activeItem)\r\n        }, STOPPED_CHANGING_ACTIVE_PANE_ITEM_DELAY)\r\n      }\r\n    }\r\n  }\r", "name": "getActivePane", "func_location": "PaneContainer.didChangeActiveItemOnPane", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 280, "func_start_line": 279}}, {"func_info": {"comment": [], "name": "PaneContainer.cancelStoppedChangingActivePaneItemTimeout", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 298, "start_line": 294}, "call_info": {"func_end_line": 292, "code": "  didChangeActiveItemOnPane (pane, activeItem) {\r\n    if (pane === this.getActivePane()) {\r\n      this.emitter.emit('did-change-active-pane-item', activeItem)\r\n\r\n      this.cancelStoppedChangingActivePaneItemTimeout()\r\n      // `setTimeout()` isn't available during the snapshotting phase, but that's okay.\r\n      if (typeof setTimeout === 'function') {\r\n        this.stoppedChangingActivePaneItemTimeout = setTimeout(() => {\r\n          this.stoppedChangingActivePaneItemTimeout = null\r\n          this.emitter.emit('did-stop-changing-active-pane-item', activeItem)\r\n        }, STOPPED_CHANGING_ACTIVE_PANE_ITEM_DELAY)\r\n      }\r\n    }\r\n  }\r", "name": "cancelStoppedChangingActivePaneItemTimeout", "func_location": "PaneContainer.didChangeActiveItemOnPane", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 283, "func_start_line": 279}}, {"func_info": {"comment": [" Updates the application's title and proxy icon based on whichever file is", " open."], "name": "Workspace.updateWindowTitle", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 604, "start_line": 561}, "call_info": {"func_end_line": 481, "code": "  didChangeActivePaneItem (item) {\r\n    this.updateWindowTitle()\r\n    this.updateDocumentEdited()\r\n    if (this.activeItemSubscriptions) this.activeItemSubscriptions.dispose()\r\n    this.activeItemSubscriptions = new CompositeDisposable()\r\n\r\n    let modifiedSubscription, titleSubscription\r\n\r\n    if (item != null && typeof item.onDidChangeTitle === 'function') {\r\n      titleSubscription = item.onDidChangeTitle(this.updateWindowTitle)\r\n    } else if (item != null && typeof item.on === 'function') {\r\n      titleSubscription = item.on('title-changed', this.updateWindowTitle)\r\n      if (titleSubscription == null || typeof titleSubscription.dispose !== 'function') {\r\n        titleSubscription = new Disposable(() => {\r\n          item.off('title-changed', this.updateWindowTitle)\r\n        })\r\n      }\r\n    }\r\n\r\n    if (item != null && typeof item.onDidChangeModified === 'function') {\r\n      modifiedSubscription = item.onDidChangeModified(this.updateDocumentEdited)\r\n    } else if (item != null && typeof item.on === 'function') {\r\n      modifiedSubscription = item.on('modified-status-changed', this.updateDocumentEdited)\r\n      if (modifiedSubscription == null || typeof modifiedSubscription.dispose !== 'function') {\r\n        modifiedSubscription = new Disposable(() => {\r\n          item.off('modified-status-changed', this.updateDocumentEdited)\r\n        })\r\n      }\r\n    }\r\n\r\n    if (titleSubscription != null) { this.activeItemSubscriptions.add(titleSubscription) }\r\n    if (modifiedSubscription != null) { this.activeItemSubscriptions.add(modifiedSubscription) }\r\n\r\n    this.cancelStoppedChangingActivePaneItemTimeout()\r\n    this.stoppedChangingActivePaneItemTimeout = setTimeout(() => {\r\n      this.stoppedChangingActivePaneItemTimeout = null\r\n      this.emitter.emit('did-stop-changing-active-pane-item', item)\r\n    }, STOPPED_CHANGING_ACTIVE_PANE_ITEM_DELAY)\r\n  }\r", "name": "updateWindowTitle", "func_location": "Workspace.didChangeActivePaneItem", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 444, "func_start_line": 443}}, {"func_info": {"comment": [" On macOS, fades the application window's proxy icon when the current file", " has been modified."], "name": "Workspace.updateDocumentEdited", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 614, "start_line": 608}, "call_info": {"func_end_line": 481, "code": "  didChangeActivePaneItem (item) {\r\n    this.updateWindowTitle()\r\n    this.updateDocumentEdited()\r\n    if (this.activeItemSubscriptions) this.activeItemSubscriptions.dispose()\r\n    this.activeItemSubscriptions = new CompositeDisposable()\r\n\r\n    let modifiedSubscription, titleSubscription\r\n\r\n    if (item != null && typeof item.onDidChangeTitle === 'function') {\r\n      titleSubscription = item.onDidChangeTitle(this.updateWindowTitle)\r\n    } else if (item != null && typeof item.on === 'function') {\r\n      titleSubscription = item.on('title-changed', this.updateWindowTitle)\r\n      if (titleSubscription == null || typeof titleSubscription.dispose !== 'function') {\r\n        titleSubscription = new Disposable(() => {\r\n          item.off('title-changed', this.updateWindowTitle)\r\n        })\r\n      }\r\n    }\r\n\r\n    if (item != null && typeof item.onDidChangeModified === 'function') {\r\n      modifiedSubscription = item.onDidChangeModified(this.updateDocumentEdited)\r\n    } else if (item != null && typeof item.on === 'function') {\r\n      modifiedSubscription = item.on('modified-status-changed', this.updateDocumentEdited)\r\n      if (modifiedSubscription == null || typeof modifiedSubscription.dispose !== 'function') {\r\n        modifiedSubscription = new Disposable(() => {\r\n          item.off('modified-status-changed', this.updateDocumentEdited)\r\n        })\r\n      }\r\n    }\r\n\r\n    if (titleSubscription != null) { this.activeItemSubscriptions.add(titleSubscription) }\r\n    if (modifiedSubscription != null) { this.activeItemSubscriptions.add(modifiedSubscription) }\r\n\r\n    this.cancelStoppedChangingActivePaneItemTimeout()\r\n    this.stoppedChangingActivePaneItemTimeout = setTimeout(() => {\r\n      this.stoppedChangingActivePaneItemTimeout = null\r\n      this.emitter.emit('did-stop-changing-active-pane-item', item)\r\n    }, STOPPED_CHANGING_ACTIVE_PANE_ITEM_DELAY)\r\n  }\r", "name": "updateDocumentEdited", "func_location": "Workspace.didChangeActivePaneItem", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 445, "func_start_line": 443}}, {"func_info": {"comment": [], "name": "Workspace.cancelStoppedChangingActivePaneItemTimeout", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 487, "start_line": 483}, "call_info": {"func_end_line": 481, "code": "  didChangeActivePaneItem (item) {\r\n    this.updateWindowTitle()\r\n    this.updateDocumentEdited()\r\n    if (this.activeItemSubscriptions) this.activeItemSubscriptions.dispose()\r\n    this.activeItemSubscriptions = new CompositeDisposable()\r\n\r\n    let modifiedSubscription, titleSubscription\r\n\r\n    if (item != null && typeof item.onDidChangeTitle === 'function') {\r\n      titleSubscription = item.onDidChangeTitle(this.updateWindowTitle)\r\n    } else if (item != null && typeof item.on === 'function') {\r\n      titleSubscription = item.on('title-changed', this.updateWindowTitle)\r\n      if (titleSubscription == null || typeof titleSubscription.dispose !== 'function') {\r\n        titleSubscription = new Disposable(() => {\r\n          item.off('title-changed', this.updateWindowTitle)\r\n        })\r\n      }\r\n    }\r\n\r\n    if (item != null && typeof item.onDidChangeModified === 'function') {\r\n      modifiedSubscription = item.onDidChangeModified(this.updateDocumentEdited)\r\n    } else if (item != null && typeof item.on === 'function') {\r\n      modifiedSubscription = item.on('modified-status-changed', this.updateDocumentEdited)\r\n      if (modifiedSubscription == null || typeof modifiedSubscription.dispose !== 'function') {\r\n        modifiedSubscription = new Disposable(() => {\r\n          item.off('modified-status-changed', this.updateDocumentEdited)\r\n        })\r\n      }\r\n    }\r\n\r\n    if (titleSubscription != null) { this.activeItemSubscriptions.add(titleSubscription) }\r\n    if (modifiedSubscription != null) { this.activeItemSubscriptions.add(modifiedSubscription) }\r\n\r\n    this.cancelStoppedChangingActivePaneItemTimeout()\r\n    this.stoppedChangingActivePaneItemTimeout = setTimeout(() => {\r\n      this.stoppedChangingActivePaneItemTimeout = null\r\n      this.emitter.emit('did-stop-changing-active-pane-item', item)\r\n    }, STOPPED_CHANGING_ACTIVE_PANE_ITEM_DELAY)\r\n  }\r", "name": "cancelStoppedChangingActivePaneItemTimeout", "func_location": "Workspace.didChangeActivePaneItem", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 476, "func_start_line": 443}}, {"func_info": {"comment": ["\r\n  Section: Panes\r\n  ", " Extended: Get the most recently focused pane container.", "", " Returns a {Dock} or the {WorkspaceCenter}."], "name": "Workspace.getActivePaneContainer", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1426, "start_line": 1424}, "call_info": {"func_end_line": 441, "code": "  didChangeActivePaneItemOnPaneContainer (paneContainer, item) {\r\n    if (paneContainer === this.getActivePaneContainer()) {\r\n      this.didChangeActivePaneItem(item)\r\n      this.emitter.emit('did-change-active-pane-item', item)\r\n    }\r\n\r\n    if (paneContainer === this.getCenter()) {\r\n      const hadActiveTextEditor = this.hasActiveTextEditor\r\n      this.hasActiveTextEditor = item instanceof TextEditor\r\n\r\n      if (this.hasActiveTextEditor || hadActiveTextEditor) {\r\n        const itemValue = this.hasActiveTextEditor ? item : undefined\r\n        this.emitter.emit('did-change-active-text-editor', itemValue)\r\n      }\r\n    }\r\n  }\r", "name": "getActivePaneContainer", "func_location": "Workspace.didChangeActivePaneItemOnPaneContainer", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 427, "func_start_line": 426}}, {"func_info": {"comment": [], "name": "Workspace.didChangeActivePaneItem", "params": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 481, "start_line": 443}, "call_info": {"func_end_line": 441, "code": "  didChangeActivePaneItemOnPaneContainer (paneContainer, item) {\r\n    if (paneContainer === this.getActivePaneContainer()) {\r\n      this.didChangeActivePaneItem(item)\r\n      this.emitter.emit('did-change-active-pane-item', item)\r\n    }\r\n\r\n    if (paneContainer === this.getCenter()) {\r\n      const hadActiveTextEditor = this.hasActiveTextEditor\r\n      this.hasActiveTextEditor = item instanceof TextEditor\r\n\r\n      if (this.hasActiveTextEditor || hadActiveTextEditor) {\r\n        const itemValue = this.hasActiveTextEditor ? item : undefined\r\n        this.emitter.emit('did-change-active-text-editor', itemValue)\r\n      }\r\n    }\r\n  }\r", "name": "didChangeActivePaneItem", "func_location": "Workspace.didChangeActivePaneItemOnPaneContainer", "args": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 428, "func_start_line": 426}}, {"func_info": {"comment": ["\r\n  Section: Pane Locations\r\n  ", " Essential: Get the {WorkspaceCenter} at the center of the editor window."], "name": "Workspace.getCenter", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1601, "start_line": 1599}, "call_info": {"func_end_line": 441, "code": "  didChangeActivePaneItemOnPaneContainer (paneContainer, item) {\r\n    if (paneContainer === this.getActivePaneContainer()) {\r\n      this.didChangeActivePaneItem(item)\r\n      this.emitter.emit('did-change-active-pane-item', item)\r\n    }\r\n\r\n    if (paneContainer === this.getCenter()) {\r\n      const hadActiveTextEditor = this.hasActiveTextEditor\r\n      this.hasActiveTextEditor = item instanceof TextEditor\r\n\r\n      if (this.hasActiveTextEditor || hadActiveTextEditor) {\r\n        const itemValue = this.hasActiveTextEditor ? item : undefined\r\n        this.emitter.emit('did-change-active-text-editor', itemValue)\r\n      }\r\n    }\r\n  }\r", "name": "getCenter", "func_location": "Workspace.didChangeActivePaneItemOnPaneContainer", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 432, "func_start_line": 426}}, {"func_info": {"comment": ["\r\n  Section: Panes\r\n  ", " Extended: Get the most recently focused pane container.", "", " Returns a {Dock} or the {WorkspaceCenter}."], "name": "Workspace.getActivePaneContainer", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1426, "start_line": 1424}, "call_info": {"func_end_line": 424, "code": "  didChangeActivePaneOnPaneContainer (paneContainer, pane) {\r\n    if (paneContainer === this.getActivePaneContainer()) {\r\n      this.emitter.emit('did-change-active-pane', pane)\r\n    }\r\n  }\r", "name": "getActivePaneContainer", "func_location": "Workspace.didChangeActivePaneOnPaneContainer", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 421, "func_start_line": 420}}, {"func_info": {"comment": [], "name": "TextEditorComponent.spliceLineTopIndex", "params": ["startRow", "oldExtent", "newExtent"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2586, "start_line": 2580}, "call_info": {"func_end_line": 2474, "name": "spliceLineTopIndex", "func_location": "TextEditorComponent.didChangeDisplayLayer", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2466, "func_start_line": 2463}}, {"func_info": {"comment": [], "name": "TextEditorComponent.scheduleUpdate", "params": ["nextUpdateOnlyBlinksCursors"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 219, "start_line": 204}, "call_info": {"func_end_line": 2474, "code": "  didChangeDisplayLayer (changes) {\r\n    for (let i = 0; i < changes.length; i++) {\r\n      const {oldRange, newRange} = changes[i]\r\n      this.spliceLineTopIndex(\r\n        newRange.start.row,\r\n        oldRange.end.row - oldRange.start.row,\r\n        newRange.end.row - newRange.start.row\r\n      )\r\n    }\r\n\r\n    this.scheduleUpdate()\r\n  }\r", "name": "scheduleUpdate", "func_location": "TextEditorComponent.didChangeDisplayLayer", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2473, "func_start_line": 2463}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getPlatform", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2966, "start_line": 2964}, "call_info": {"func_end_line": 2498, "code": "  didChangeSelectionRange () {\r\n    const {model} = this.props\r\n\r\n    if (this.getPlatform() === 'linux') {\r\n      if (this.selectionClipboardImmediateId) {\r\n        clearImmediate(this.selectionClipboardImmediateId)\r\n      }\r\n\r\n      this.selectionClipboardImmediateId = setImmediate(() => {\r\n        this.selectionClipboardImmediateId = null\r\n\r\n        if (model.isDestroyed()) return\r\n\r\n        const selectedText = model.getSelectedText()\r\n        if (selectedText) {\r\n          // This uses ipcRenderer.send instead of clipboard.writeText because\r\n          // clipboard.writeText is a sync ipcRenderer call on Linux and that\r\n          // will slow down selections.\r\n          electron.ipcRenderer.send('write-text-to-selection-clipboard', selectedText)\r\n        }\r\n      })\r\n    }\r\n  }\r", "name": "getPlatform", "func_location": "TextEditorComponent.didChangeSelectionRange", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2479, "func_start_line": 2476}}, {"func_info": {"comment": [], "name": "AtomWindow.sendMessage", "params": ["message", "detail"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "end_line": 271, "start_line": 269}, "call_info": {"func_end_line": 259, "code": "  didChangeUserSettings (settings) {\r\n    this.sendMessage('did-change-user-settings', settings)\r\n  }\r", "name": "sendMessage", "func_location": "AtomWindow.didChangeUserSettings", "args": [{"type": "string"}, "settings"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "line": 258, "func_start_line": 257}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getHiddenInput", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2962, "start_line": 2960}, "call_info": {"func_end_line": 1734, "comment": [" The IME composition events work like this:", "", " User types 's', chromium pops up the completion helper", "   1. compositionstart fired", "   2. compositionupdate fired; event.data == 's'", " User hits arrow keys to move around in completion helper", "   3. compositionupdate fired; event.data == 's' for each arry key press", " User escape to cancel OR User chooses a completion", "   4. compositionend fired", "   5. textInput fired; event.data == the completion string"], "code": "  didCompositionStart () {\r\n    // Workaround for Chromium not preventing composition events when\r\n    // preventDefault is called on the keydown event that precipitated them.\r\n    if (this.lastKeydown && this.lastKeydown.defaultPrevented) {\r\n      this.getHiddenInput().disabled = true\r\n      process.nextTick(() => {\r\n        // Disabling the hidden input makes it lose focus as well, so we have to\r\n        // re-enable and re-focus it.\r\n        this.getHiddenInput().disabled = false\r\n        this.getHiddenInput().focus()\r\n      })\r\n      return\r\n    }\r\n\r\n    this.compositionCheckpoint = this.props.model.createCheckpoint()\r\n    if (this.accentedCharacterMenuIsOpen) {\r\n      this.props.model.selectLeft()\r\n    }\r\n  }\r", "name": "getHiddenInput", "func_location": "TextEditorComponent.didCompositionStart", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1720, "func_start_line": 1716}}, {"func_info": {"comment": [], "name": "DecorationManager.unobserveDecoratedLayer", "params": ["layer", "isMarkerDecoration"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js", "end_line": 288, "start_line": 277}, "call_info": {"func_end_line": 264, "code": "  didDestroyLayerDecoration (decoration) {\r\n    const {markerLayer} = decoration\r\n    const decorations = this.layerDecorationsByMarkerLayer.get(markerLayer)\r\n\r\n    if (decorations && decorations.has(decoration)) {\r\n      decorations.delete(decoration)\r\n      if (decorations.size === 0) {\r\n        this.layerDecorationsByMarkerLayer.delete(markerLayer)\r\n      }\r\n      this.unobserveDecoratedLayer(markerLayer, true)\r\n      this.emitDidUpdateDecorations()\r\n    }\r\n  }\r", "name": "unobserveDecoratedLayer", "func_location": "DecorationManager.didDestroyLayerDecoration", "args": ["markerLayer", {"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js", "line": 261, "func_start_line": 252}}, {"func_info": {"comment": [], "name": "DecorationManager.emitDidUpdateDecorations", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js", "end_line": 229, "start_line": 226}, "call_info": {"func_end_line": 264, "code": "  didDestroyLayerDecoration (decoration) {\r\n    const {markerLayer} = decoration\r\n    const decorations = this.layerDecorationsByMarkerLayer.get(markerLayer)\r\n\r\n    if (decorations && decorations.has(decoration)) {\r\n      decorations.delete(decoration)\r\n      if (decorations.size === 0) {\r\n        this.layerDecorationsByMarkerLayer.delete(markerLayer)\r\n      }\r\n      this.unobserveDecoratedLayer(markerLayer, true)\r\n      this.emitDidUpdateDecorations()\r\n    }\r\n  }\r", "name": "emitDidUpdateDecorations", "func_location": "DecorationManager.didDestroyLayerDecoration", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js", "line": 262, "func_start_line": 252}}, {"func_info": {"comment": [], "name": "DecorationManager.unobserveDecoratedLayer", "params": ["layer", "isMarkerDecoration"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js", "end_line": 288, "start_line": 277}, "call_info": {"func_end_line": 250, "code": "  didDestroyMarkerDecoration (decoration) {\r\n    const {marker} = decoration\r\n    const decorations = this.decorationsByMarker.get(marker)\r\n    if (decorations && decorations.has(decoration)) {\r\n      decorations.delete(decoration)\r\n      if (decorations.size === 0) this.decorationsByMarker.delete(marker)\r\n      this.overlayDecorations.delete(decoration)\r\n      this.unobserveDecoratedLayer(marker.layer, true)\r\n      this.emitter.emit('did-remove-decoration', decoration)\r\n      this.emitDidUpdateDecorations()\r\n    }\r\n  }\r", "name": "unobserveDecoratedLayer", "func_location": "DecorationManager.didDestroyMarkerDecoration", "args": ["marker.layer", {"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js", "line": 246, "func_start_line": 239}}, {"func_info": {"comment": [], "name": "DecorationManager.emitDidUpdateDecorations", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js", "end_line": 229, "start_line": 226}, "call_info": {"func_end_line": 250, "code": "  didDestroyMarkerDecoration (decoration) {\r\n    const {marker} = decoration\r\n    const decorations = this.decorationsByMarker.get(marker)\r\n    if (decorations && decorations.has(decoration)) {\r\n      decorations.delete(decoration)\r\n      if (decorations.size === 0) this.decorationsByMarker.delete(marker)\r\n      this.overlayDecorations.delete(decoration)\r\n      this.unobserveDecoratedLayer(marker.layer, true)\r\n      this.emitter.emit('did-remove-decoration', decoration)\r\n      this.emitDidUpdateDecorations()\r\n    }\r\n  }\r", "name": "emitDidUpdateDecorations", "func_location": "DecorationManager.didDestroyMarkerDecoration", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js", "line": 248, "func_start_line": 239}}, {"func_info": {"comment": [], "name": "TextEditorComponent.didHide", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1472, "start_line": 1467}, "call_info": {"func_end_line": 1454, "code": "  didDetach () {\r\n    if (this.attached) {\r\n      this.intersectionObserver.disconnect()\r\n      this.resizeObserver.disconnect()\r\n      if (this.gutterContainerResizeObserver) this.gutterContainerResizeObserver.disconnect()\r\n      this.overlayComponents.forEach((component) => component.didDetach())\r\n\r\n      this.didHide()\r\n      this.attached = false\r\n      this.constructor.attachedComponents.delete(this)\r\n    }\r\n  }\r", "name": "didHide", "func_location": "TextEditorComponent.didDetach", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1450, "func_start_line": 1443}}, {"func_info": {"comment": [], "name": "AtomWindow.sendMessage", "params": ["message", "detail"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "end_line": 271, "start_line": 269}, "call_info": {"func_end_line": 263, "code": "  didFailToReadUserSettings (message) {\r\n    this.sendMessage('did-fail-to-read-user-settings', message)\r\n  }\r", "name": "sendMessage", "func_location": "AtomWindow.didFailToReadUserSettings", "args": [{"type": "string"}, "message"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "line": 262, "func_start_line": 261}}, {"func_info": {"comment": [], "name": "TextEditorComponent.didAttach", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1441, "start_line": 1405}, "call_info": {"func_end_line": 1495, "comment": [" Called by TextEditorElement so that focus events can be handled before", " the element is attached to the DOM."], "code": "  didFocus () {\r\n    // This element can be focused from a parent custom element's\r\n    // attachedCallback before *its* attachedCallback is fired. This protects\r\n    // against that case.\r\n    if (!this.attached) this.didAttach()\r\n\r\n    // The element can be focused before the intersection observer detects that\r\n    // it has been shown for the first time. If this element is being focused,\r\n    // it is necessarily visible, so we call `didShow` to ensure the hidden\r\n    // input is rendered before we try to shift focus to it.\r\n    if (!this.visible) this.didShow()\r\n\r\n    if (!this.focused) {\r\n      this.focused = true\r\n      this.startCursorBlinking()\r\n      this.scheduleUpdate()\r\n    }\r\n\r\n    this.getHiddenInput().focus()\r\n  }\r", "name": "didAttach", "func_location": "TextEditorComponent.didFocus", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1480, "func_start_line": 1476}}, {"func_info": {"comment": [], "name": "TextEditorComponent.didShow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1465, "start_line": 1456}, "call_info": {"func_end_line": 1495, "comment": [" Called by TextEditorElement so that focus events can be handled before", " the element is attached to the DOM."], "code": "  didFocus () {\r\n    // This element can be focused from a parent custom element's\r\n    // attachedCallback before *its* attachedCallback is fired. This protects\r\n    // against that case.\r\n    if (!this.attached) this.didAttach()\r\n\r\n    // The element can be focused before the intersection observer detects that\r\n    // it has been shown for the first time. If this element is being focused,\r\n    // it is necessarily visible, so we call `didShow` to ensure the hidden\r\n    // input is rendered before we try to shift focus to it.\r\n    if (!this.visible) this.didShow()\r\n\r\n    if (!this.focused) {\r\n      this.focused = true\r\n      this.startCursorBlinking()\r\n      this.scheduleUpdate()\r\n    }\r\n\r\n    this.getHiddenInput().focus()\r\n  }\r", "name": "didShow", "func_location": "TextEditorComponent.didFocus", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1486, "func_start_line": 1476}}, {"func_info": {"comment": [], "name": "TextEditorComponent.startCursorBlinking", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2010, "start_line": 2001}, "call_info": {"func_end_line": 1495, "comment": [" Called by TextEditorElement so that focus events can be handled before", " the element is attached to the DOM."], "code": "  didFocus () {\r\n    // This element can be focused from a parent custom element's\r\n    // attachedCallback before *its* attachedCallback is fired. This protects\r\n    // against that case.\r\n    if (!this.attached) this.didAttach()\r\n\r\n    // The element can be focused before the intersection observer detects that\r\n    // it has been shown for the first time. If this element is being focused,\r\n    // it is necessarily visible, so we call `didShow` to ensure the hidden\r\n    // input is rendered before we try to shift focus to it.\r\n    if (!this.visible) this.didShow()\r\n\r\n    if (!this.focused) {\r\n      this.focused = true\r\n      this.startCursorBlinking()\r\n      this.scheduleUpdate()\r\n    }\r\n\r\n    this.getHiddenInput().focus()\r\n  }\r", "name": "startCursorBlinking", "func_location": "TextEditorComponent.didFocus", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1490, "func_start_line": 1476}}, {"func_info": {"comment": [], "name": "TextEditorComponent.scheduleUpdate", "params": ["nextUpdateOnlyBlinksCursors"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 219, "start_line": 204}, "call_info": {"func_end_line": 1495, "comment": [" Called by TextEditorElement so that focus events can be handled before", " the element is attached to the DOM."], "code": "  didFocus () {\r\n    // This element can be focused from a parent custom element's\r\n    // attachedCallback before *its* attachedCallback is fired. This protects\r\n    // against that case.\r\n    if (!this.attached) this.didAttach()\r\n\r\n    // The element can be focused before the intersection observer detects that\r\n    // it has been shown for the first time. If this element is being focused,\r\n    // it is necessarily visible, so we call `didShow` to ensure the hidden\r\n    // input is rendered before we try to shift focus to it.\r\n    if (!this.visible) this.didShow()\r\n\r\n    if (!this.focused) {\r\n      this.focused = true\r\n      this.startCursorBlinking()\r\n      this.scheduleUpdate()\r\n    }\r\n\r\n    this.getHiddenInput().focus()\r\n  }\r", "name": "scheduleUpdate", "func_location": "TextEditorComponent.didFocus", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1491, "func_start_line": 1476}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getHiddenInput", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2962, "start_line": 2960}, "call_info": {"func_end_line": 1495, "comment": [" Called by TextEditorElement so that focus events can be handled before", " the element is attached to the DOM."], "code": "  didFocus () {\r\n    // This element can be focused from a parent custom element's\r\n    // attachedCallback before *its* attachedCallback is fired. This protects\r\n    // against that case.\r\n    if (!this.attached) this.didAttach()\r\n\r\n    // The element can be focused before the intersection observer detects that\r\n    // it has been shown for the first time. If this element is being focused,\r\n    // it is necessarily visible, so we call `didShow` to ensure the hidden\r\n    // input is rendered before we try to shift focus to it.\r\n    if (!this.visible) this.didShow()\r\n\r\n    if (!this.focused) {\r\n      this.focused = true\r\n      this.startCursorBlinking()\r\n      this.scheduleUpdate()\r\n    }\r\n\r\n    this.getHiddenInput().focus()\r\n  }\r", "name": "getHiddenInput", "func_location": "TextEditorComponent.didFocus", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1494, "func_start_line": 1476}}, {"func_info": {"comment": [], "name": "TextEditorComponent.startCursorBlinking", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2010, "start_line": 2001}, "call_info": {"func_end_line": 1527, "code": "  didFocusHiddenInput () {\r\n    // Focusing the hidden input when it is off-screen causes the browser to\r\n    // scroll it into view. Since we use synthetic scrolling this behavior\r\n    // causes all the lines to disappear so we counteract it by always setting\r\n    // the scroll position to 0.\r\n    this.refs.scrollContainer.scrollTop = 0\r\n    this.refs.scrollContainer.scrollLeft = 0\r\n    if (!this.focused) {\r\n      this.focused = true\r\n      this.startCursorBlinking()\r\n      this.scheduleUpdate()\r\n    }\r\n  }\r", "name": "startCursorBlinking", "func_location": "TextEditorComponent.didFocusHiddenInput", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1524, "func_start_line": 1515}}, {"func_info": {"comment": [], "name": "TextEditorComponent.scheduleUpdate", "params": ["nextUpdateOnlyBlinksCursors"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 219, "start_line": 204}, "call_info": {"func_end_line": 1527, "code": "  didFocusHiddenInput () {\r\n    // Focusing the hidden input when it is off-screen causes the browser to\r\n    // scroll it into view. Since we use synthetic scrolling this behavior\r\n    // causes all the lines to disappear so we counteract it by always setting\r\n    // the scroll position to 0.\r\n    this.refs.scrollContainer.scrollTop = 0\r\n    this.refs.scrollContainer.scrollLeft = 0\r\n    if (!this.focused) {\r\n      this.focused = true\r\n      this.startCursorBlinking()\r\n      this.scheduleUpdate()\r\n    }\r\n  }\r", "name": "scheduleUpdate", "func_location": "TextEditorComponent.didFocusHiddenInput", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1525, "func_start_line": 1515}}, {"func_info": {"comment": [], "name": "DummyScrollbarComponent.getRealScrollbarHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 3066, "start_line": 3064}, "call_info": {"func_end_line": 3058, "code": "  didMouseDown (event) {\r\n    let {bottom, right} = this.element.getBoundingClientRect()\r\n    const clickedOnScrollbar = (this.props.orientation === 'horizontal')\r\n      ? event.clientY >= (bottom - this.getRealScrollbarHeight())\r\n      : event.clientX >= (right - this.getRealScrollbarWidth())\r\n    if (!clickedOnScrollbar) this.props.didMouseDown(event)\r\n  }\r", "name": "getRealScrollbarHeight", "func_location": "DummyScrollbarComponent.didMouseDown", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3055, "func_start_line": 3052}}, {"func_info": {"comment": [], "name": "DummyScrollbarComponent.getRealScrollbarWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 3062, "start_line": 3060}, "call_info": {"func_end_line": 3058, "code": "  didMouseDown (event) {\r\n    let {bottom, right} = this.element.getBoundingClientRect()\r\n    const clickedOnScrollbar = (this.props.orientation === 'horizontal')\r\n      ? event.clientY >= (bottom - this.getRealScrollbarHeight())\r\n      : event.clientX >= (right - this.getRealScrollbarWidth())\r\n    if (!clickedOnScrollbar) this.props.didMouseDown(event)\r\n  }\r", "name": "getRealScrollbarWidth", "func_location": "DummyScrollbarComponent.didMouseDown", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3056, "func_start_line": 3052}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getPlatform", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2966, "start_line": 2964}, "call_info": {"func_end_line": 1826, "code": "  didMouseDownOnContent (event) {\r\n    const {model} = this.props\r\n    const {target, button, detail, ctrlKey, shiftKey, metaKey} = event\r\n    const platform = this.getPlatform()\r\n\r\n    // Ignore clicks on block decorations.\r\n    if (target) {\r\n      let element = target\r\n      while (element && element !== this.element) {\r\n        if (this.blockDecorationsByElement.has(element)) {\r\n          return\r\n        }\r\n\r\n        element = element.parentElement\r\n      }\r\n    }\r\n\r\n    const screenPosition = this.screenPositionForMouseEvent(event)\r\n\r\n    if (button === 1) {\r\n      model.setCursorScreenPosition(screenPosition, {autoscroll: false})\r\n\r\n      // On Linux, pasting happens on middle click. A textInput event with the\r\n      // contents of the selection clipboard will be dispatched by the browser\r\n      // automatically on mouseup.\r\n      if (platform === 'linux' && this.isInputEnabled()) model.insertText(clipboard.readText('selection'))\r\n      return\r\n    }\r\n\r\n    if (button !== 0) return\r\n\r\n    // Ctrl-click brings up the context menu on macOS\r\n    if (platform === 'darwin' && ctrlKey) return\r\n\r\n    if (target && target.matches('.fold-marker')) {\r\n      const bufferPosition = model.bufferPositionForScreenPosition(screenPosition)\r\n      model.destroyFoldsContainingBufferPositions([bufferPosition], false)\r\n      return\r\n    }\r\n\r\n    const addOrRemoveSelection = metaKey || (ctrlKey && platform !== 'darwin')\r\n\r\n    switch (detail) {\r\n      case 1:\r\n        if (addOrRemoveSelection) {\r\n          const existingSelection = model.getSelectionAtScreenPosition(screenPosition)\r\n          if (existingSelection) {\r\n            if (model.hasMultipleCursors()) existingSelection.destroy()\r\n          } else {\r\n            model.addCursorAtScreenPosition(screenPosition, {autoscroll: false})\r\n          }\r\n        } else {\r\n          if (shiftKey) {\r\n            model.selectToScreenPosition(screenPosition, {autoscroll: false})\r\n          } else {\r\n            model.setCursorScreenPosition(screenPosition, {autoscroll: false})\r\n          }\r\n        }\r\n        break\r\n      case 2:\r\n        if (addOrRemoveSelection) model.addCursorAtScreenPosition(screenPosition, {autoscroll: false})\r\n        model.getLastSelection().selectWord({autoscroll: false})\r\n        break\r\n      case 3:\r\n        if (addOrRemoveSelection) model.addCursorAtScreenPosition(screenPosition, {autoscroll: false})\r\n        model.getLastSelection().selectLine(null, {autoscroll: false})\r\n        break\r\n    }\r\n\r\n    this.handleMouseDragUntilMouseUp({\r\n      didDrag: (event) => {\r\n        this.autoscrollOnMouseDrag(event)\r\n        const screenPosition = this.screenPositionForMouseEvent(event)\r\n        model.selectToScreenPosition(screenPosition, {suppressSelectionMerge: true, autoscroll: false})\r\n        this.updateSync()\r\n      },\r\n      didStopDragging: () => {\r\n        model.finalizeSelections()\r\n        model.mergeIntersectingSelections()\r\n        this.updateSync()\r\n      }\r\n    })\r\n  }\r", "name": "getPlatform", "func_location": "TextEditorComponent.didMouseDownOnContent", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1747, "func_start_line": 1744}}, {"func_info": {"comment": [], "name": "TextEditorComponent.screenPositionForMouseEvent", "params": ["event"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1963, "start_line": 1961}, "call_info": {"func_end_line": 1826, "code": "  didMouseDownOnContent (event) {\r\n    const {model} = this.props\r\n    const {target, button, detail, ctrlKey, shiftKey, metaKey} = event\r\n    const platform = this.getPlatform()\r\n\r\n    // Ignore clicks on block decorations.\r\n    if (target) {\r\n      let element = target\r\n      while (element && element !== this.element) {\r\n        if (this.blockDecorationsByElement.has(element)) {\r\n          return\r\n        }\r\n\r\n        element = element.parentElement\r\n      }\r\n    }\r\n\r\n    const screenPosition = this.screenPositionForMouseEvent(event)\r\n\r\n    if (button === 1) {\r\n      model.setCursorScreenPosition(screenPosition, {autoscroll: false})\r\n\r\n      // On Linux, pasting happens on middle click. A textInput event with the\r\n      // contents of the selection clipboard will be dispatched by the browser\r\n      // automatically on mouseup.\r\n      if (platform === 'linux' && this.isInputEnabled()) model.insertText(clipboard.readText('selection'))\r\n      return\r\n    }\r\n\r\n    if (button !== 0) return\r\n\r\n    // Ctrl-click brings up the context menu on macOS\r\n    if (platform === 'darwin' && ctrlKey) return\r\n\r\n    if (target && target.matches('.fold-marker')) {\r\n      const bufferPosition = model.bufferPositionForScreenPosition(screenPosition)\r\n      model.destroyFoldsContainingBufferPositions([bufferPosition], false)\r\n      return\r\n    }\r\n\r\n    const addOrRemoveSelection = metaKey || (ctrlKey && platform !== 'darwin')\r\n\r\n    switch (detail) {\r\n      case 1:\r\n        if (addOrRemoveSelection) {\r\n          const existingSelection = model.getSelectionAtScreenPosition(screenPosition)\r\n          if (existingSelection) {\r\n            if (model.hasMultipleCursors()) existingSelection.destroy()\r\n          } else {\r\n            model.addCursorAtScreenPosition(screenPosition, {autoscroll: false})\r\n          }\r\n        } else {\r\n          if (shiftKey) {\r\n            model.selectToScreenPosition(screenPosition, {autoscroll: false})\r\n          } else {\r\n            model.setCursorScreenPosition(screenPosition, {autoscroll: false})\r\n          }\r\n        }\r\n        break\r\n      case 2:\r\n        if (addOrRemoveSelection) model.addCursorAtScreenPosition(screenPosition, {autoscroll: false})\r\n        model.getLastSelection().selectWord({autoscroll: false})\r\n        break\r\n      case 3:\r\n        if (addOrRemoveSelection) model.addCursorAtScreenPosition(screenPosition, {autoscroll: false})\r\n        model.getLastSelection().selectLine(null, {autoscroll: false})\r\n        break\r\n    }\r\n\r\n    this.handleMouseDragUntilMouseUp({\r\n      didDrag: (event) => {\r\n        this.autoscrollOnMouseDrag(event)\r\n        const screenPosition = this.screenPositionForMouseEvent(event)\r\n        model.selectToScreenPosition(screenPosition, {suppressSelectionMerge: true, autoscroll: false})\r\n        this.updateSync()\r\n      },\r\n      didStopDragging: () => {\r\n        model.finalizeSelections()\r\n        model.mergeIntersectingSelections()\r\n        this.updateSync()\r\n      }\r\n    })\r\n  }\r", "name": "screenPositionForMouseEvent", "func_location": "TextEditorComponent.didMouseDownOnContent", "args": ["event"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1761, "func_start_line": 1744}}, {"func_info": {"comment": [], "name": "TextEditorComponent.isInputEnabled", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2958, "start_line": 2956}, "call_info": {"func_end_line": 1826, "code": "  didMouseDownOnContent (event) {\r\n    const {model} = this.props\r\n    const {target, button, detail, ctrlKey, shiftKey, metaKey} = event\r\n    const platform = this.getPlatform()\r\n\r\n    // Ignore clicks on block decorations.\r\n    if (target) {\r\n      let element = target\r\n      while (element && element !== this.element) {\r\n        if (this.blockDecorationsByElement.has(element)) {\r\n          return\r\n        }\r\n\r\n        element = element.parentElement\r\n      }\r\n    }\r\n\r\n    const screenPosition = this.screenPositionForMouseEvent(event)\r\n\r\n    if (button === 1) {\r\n      model.setCursorScreenPosition(screenPosition, {autoscroll: false})\r\n\r\n      // On Linux, pasting happens on middle click. A textInput event with the\r\n      // contents of the selection clipboard will be dispatched by the browser\r\n      // automatically on mouseup.\r\n      if (platform === 'linux' && this.isInputEnabled()) model.insertText(clipboard.readText('selection'))\r\n      return\r\n    }\r\n\r\n    if (button !== 0) return\r\n\r\n    // Ctrl-click brings up the context menu on macOS\r\n    if (platform === 'darwin' && ctrlKey) return\r\n\r\n    if (target && target.matches('.fold-marker')) {\r\n      const bufferPosition = model.bufferPositionForScreenPosition(screenPosition)\r\n      model.destroyFoldsContainingBufferPositions([bufferPosition], false)\r\n      return\r\n    }\r\n\r\n    const addOrRemoveSelection = metaKey || (ctrlKey && platform !== 'darwin')\r\n\r\n    switch (detail) {\r\n      case 1:\r\n        if (addOrRemoveSelection) {\r\n          const existingSelection = model.getSelectionAtScreenPosition(screenPosition)\r\n          if (existingSelection) {\r\n            if (model.hasMultipleCursors()) existingSelection.destroy()\r\n          } else {\r\n            model.addCursorAtScreenPosition(screenPosition, {autoscroll: false})\r\n          }\r\n        } else {\r\n          if (shiftKey) {\r\n            model.selectToScreenPosition(screenPosition, {autoscroll: false})\r\n          } else {\r\n            model.setCursorScreenPosition(screenPosition, {autoscroll: false})\r\n          }\r\n        }\r\n        break\r\n      case 2:\r\n        if (addOrRemoveSelection) model.addCursorAtScreenPosition(screenPosition, {autoscroll: false})\r\n        model.getLastSelection().selectWord({autoscroll: false})\r\n        break\r\n      case 3:\r\n        if (addOrRemoveSelection) model.addCursorAtScreenPosition(screenPosition, {autoscroll: false})\r\n        model.getLastSelection().selectLine(null, {autoscroll: false})\r\n        break\r\n    }\r\n\r\n    this.handleMouseDragUntilMouseUp({\r\n      didDrag: (event) => {\r\n        this.autoscrollOnMouseDrag(event)\r\n        const screenPosition = this.screenPositionForMouseEvent(event)\r\n        model.selectToScreenPosition(screenPosition, {suppressSelectionMerge: true, autoscroll: false})\r\n        this.updateSync()\r\n      },\r\n      didStopDragging: () => {\r\n        model.finalizeSelections()\r\n        model.mergeIntersectingSelections()\r\n        this.updateSync()\r\n      }\r\n    })\r\n  }\r", "name": "isInputEnabled", "func_location": "TextEditorComponent.didMouseDownOnContent", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1769, "func_start_line": 1744}}, {"func_info": {"comment": [], "name": "TextEditorComponent.handleMouseDragUntilMouseUp", "params": [["didDrag", "didStopDragging"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1920, "start_line": 1886}, "call_info": {"func_end_line": 1826, "name": "handleMouseDragUntilMouseUp", "func_location": "TextEditorComponent.didMouseDownOnContent", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1813, "func_start_line": 1744}}, {"func_info": {"comment": [], "name": "TextEditorComponent.screenPositionForMouseEvent", "params": ["event"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1963, "start_line": 1961}, "call_info": {"func_end_line": 1884, "code": "  didMouseDownOnLineNumberGutter (event) {\r\n    const {model} = this.props\r\n    const {target, button, ctrlKey, shiftKey, metaKey} = event\r\n\r\n    // Only handle mousedown events for left mouse button\r\n    if (button !== 0) return\r\n\r\n    const clickedScreenRow = this.screenPositionForMouseEvent(event).row\r\n    const startBufferRow = model.bufferPositionForScreenPosition([clickedScreenRow, 0]).row\r\n\r\n    if (target && (target.matches('.foldable .icon-right') || target.matches('.folded .icon-right'))) {\r\n      model.toggleFoldAtBufferRow(startBufferRow)\r\n      return\r\n    }\r\n\r\n    const addOrRemoveSelection = metaKey || (ctrlKey && this.getPlatform() !== 'darwin')\r\n    const endBufferRow = model.bufferPositionForScreenPosition([clickedScreenRow, Infinity]).row\r\n    const clickedLineBufferRange = Range(Point(startBufferRow, 0), Point(endBufferRow + 1, 0))\r\n\r\n    let initialBufferRange\r\n    if (shiftKey) {\r\n      const lastSelection = model.getLastSelection()\r\n      initialBufferRange = lastSelection.getBufferRange()\r\n      lastSelection.setBufferRange(initialBufferRange.union(clickedLineBufferRange), {\r\n        reversed: clickedScreenRow < lastSelection.getScreenRange().start.row,\r\n        autoscroll: false,\r\n        preserveFolds: true,\r\n        suppressSelectionMerge: true\r\n      })\r\n    } else {\r\n      initialBufferRange = clickedLineBufferRange\r\n      if (addOrRemoveSelection) {\r\n        model.addSelectionForBufferRange(clickedLineBufferRange, {autoscroll: false, preserveFolds: true})\r\n      } else {\r\n        model.setSelectedBufferRange(clickedLineBufferRange, {autoscroll: false, preserveFolds: true})\r\n      }\r\n    }\r\n\r\n    const initialScreenRange = model.screenRangeForBufferRange(initialBufferRange)\r\n    this.handleMouseDragUntilMouseUp({\r\n      didDrag: (event) => {\r\n        this.autoscrollOnMouseDrag(event, true)\r\n        const dragRow = this.screenPositionForMouseEvent(event).row\r\n        const draggedLineScreenRange = Range(Point(dragRow, 0), Point(dragRow + 1, 0))\r\n        model.getLastSelection().setScreenRange(draggedLineScreenRange.union(initialScreenRange), {\r\n          reversed: dragRow < initialScreenRange.start.row,\r\n          autoscroll: false,\r\n          preserveFolds: true\r\n        })\r\n        this.updateSync()\r\n      },\r\n      didStopDragging: () => {\r\n        model.mergeIntersectingSelections()\r\n        this.updateSync()\r\n      }\r\n    })\r\n  }\r", "name": "screenPositionForMouseEvent", "func_location": "TextEditorComponent.didMouseDownOnLineNumberGutter", "args": ["event"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1835, "func_start_line": 1828}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getPlatform", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2966, "start_line": 2964}, "call_info": {"func_end_line": 1884, "code": "  didMouseDownOnLineNumberGutter (event) {\r\n    const {model} = this.props\r\n    const {target, button, ctrlKey, shiftKey, metaKey} = event\r\n\r\n    // Only handle mousedown events for left mouse button\r\n    if (button !== 0) return\r\n\r\n    const clickedScreenRow = this.screenPositionForMouseEvent(event).row\r\n    const startBufferRow = model.bufferPositionForScreenPosition([clickedScreenRow, 0]).row\r\n\r\n    if (target && (target.matches('.foldable .icon-right') || target.matches('.folded .icon-right'))) {\r\n      model.toggleFoldAtBufferRow(startBufferRow)\r\n      return\r\n    }\r\n\r\n    const addOrRemoveSelection = metaKey || (ctrlKey && this.getPlatform() !== 'darwin')\r\n    const endBufferRow = model.bufferPositionForScreenPosition([clickedScreenRow, Infinity]).row\r\n    const clickedLineBufferRange = Range(Point(startBufferRow, 0), Point(endBufferRow + 1, 0))\r\n\r\n    let initialBufferRange\r\n    if (shiftKey) {\r\n      const lastSelection = model.getLastSelection()\r\n      initialBufferRange = lastSelection.getBufferRange()\r\n      lastSelection.setBufferRange(initialBufferRange.union(clickedLineBufferRange), {\r\n        reversed: clickedScreenRow < lastSelection.getScreenRange().start.row,\r\n        autoscroll: false,\r\n        preserveFolds: true,\r\n        suppressSelectionMerge: true\r\n      })\r\n    } else {\r\n      initialBufferRange = clickedLineBufferRange\r\n      if (addOrRemoveSelection) {\r\n        model.addSelectionForBufferRange(clickedLineBufferRange, {autoscroll: false, preserveFolds: true})\r\n      } else {\r\n        model.setSelectedBufferRange(clickedLineBufferRange, {autoscroll: false, preserveFolds: true})\r\n      }\r\n    }\r\n\r\n    const initialScreenRange = model.screenRangeForBufferRange(initialBufferRange)\r\n    this.handleMouseDragUntilMouseUp({\r\n      didDrag: (event) => {\r\n        this.autoscrollOnMouseDrag(event, true)\r\n        const dragRow = this.screenPositionForMouseEvent(event).row\r\n        const draggedLineScreenRange = Range(Point(dragRow, 0), Point(dragRow + 1, 0))\r\n        model.getLastSelection().setScreenRange(draggedLineScreenRange.union(initialScreenRange), {\r\n          reversed: dragRow < initialScreenRange.start.row,\r\n          autoscroll: false,\r\n          preserveFolds: true\r\n        })\r\n        this.updateSync()\r\n      },\r\n      didStopDragging: () => {\r\n        model.mergeIntersectingSelections()\r\n        this.updateSync()\r\n      }\r\n    })\r\n  }\r", "name": "getPlatform", "func_location": "TextEditorComponent.didMouseDownOnLineNumberGutter", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1843, "func_start_line": 1828}}, {"func_info": {"comment": [], "name": "TextEditorComponent.handleMouseDragUntilMouseUp", "params": [["didDrag", "didStopDragging"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1920, "start_line": 1886}, "call_info": {"func_end_line": 1884, "name": "handleMouseDragUntilMouseUp", "func_location": "TextEditorComponent.didMouseDownOnLineNumberGutter", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1867, "func_start_line": 1828}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getPlatform", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2966, "start_line": 2964}, "call_info": {"func_end_line": 1552, "code": "  didMouseWheel (event) {\r\n    const scrollSensitivity = this.props.model.getScrollSensitivity() / 100\r\n\r\n    let {wheelDeltaX, wheelDeltaY} = event\r\n\r\n    if (Math.abs(wheelDeltaX) > Math.abs(wheelDeltaY)) {\r\n      wheelDeltaX = wheelDeltaX * scrollSensitivity\r\n      wheelDeltaY = 0\r\n    } else {\r\n      wheelDeltaX = 0\r\n      wheelDeltaY = wheelDeltaY * scrollSensitivity\r\n    }\r\n\r\n    if (this.getPlatform() !== 'darwin' && event.shiftKey) {\r\n      let temp = wheelDeltaX\r\n      wheelDeltaX = wheelDeltaY\r\n      wheelDeltaY = temp\r\n    }\r\n\r\n    const scrollLeftChanged = wheelDeltaX !== 0 && this.setScrollLeft(this.getScrollLeft() - wheelDeltaX)\r\n    const scrollTopChanged = wheelDeltaY !== 0 && this.setScrollTop(this.getScrollTop() - wheelDeltaY)\r\n\r\n    if (scrollLeftChanged || scrollTopChanged) this.updateSync()\r\n  }\r", "name": "getPlatform", "func_location": "TextEditorComponent.didMouseWheel", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1542, "func_start_line": 1529}}, {"func_info": {"comment": [], "name": "TextEditorComponent.setScrollLeft", "params": ["scrollLeft"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2839, "start_line": 2827}, "call_info": {"func_end_line": 1552, "code": "  didMouseWheel (event) {\r\n    const scrollSensitivity = this.props.model.getScrollSensitivity() / 100\r\n\r\n    let {wheelDeltaX, wheelDeltaY} = event\r\n\r\n    if (Math.abs(wheelDeltaX) > Math.abs(wheelDeltaY)) {\r\n      wheelDeltaX = wheelDeltaX * scrollSensitivity\r\n      wheelDeltaY = 0\r\n    } else {\r\n      wheelDeltaX = 0\r\n      wheelDeltaY = wheelDeltaY * scrollSensitivity\r\n    }\r\n\r\n    if (this.getPlatform() !== 'darwin' && event.shiftKey) {\r\n      let temp = wheelDeltaX\r\n      wheelDeltaX = wheelDeltaY\r\n      wheelDeltaY = temp\r\n    }\r\n\r\n    const scrollLeftChanged = wheelDeltaX !== 0 && this.setScrollLeft(this.getScrollLeft() - wheelDeltaX)\r\n    const scrollTopChanged = wheelDeltaY !== 0 && this.setScrollTop(this.getScrollTop() - wheelDeltaY)\r\n\r\n    if (scrollLeftChanged || scrollTopChanged) this.updateSync()\r\n  }\r", "name": "setScrollLeft", "func_location": "TextEditorComponent.didMouseWheel", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1548, "func_start_line": 1529}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollLeft", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2825, "start_line": 2823}, "call_info": {"func_end_line": 1552, "code": "  didMouseWheel (event) {\r\n    const scrollSensitivity = this.props.model.getScrollSensitivity() / 100\r\n\r\n    let {wheelDeltaX, wheelDeltaY} = event\r\n\r\n    if (Math.abs(wheelDeltaX) > Math.abs(wheelDeltaY)) {\r\n      wheelDeltaX = wheelDeltaX * scrollSensitivity\r\n      wheelDeltaY = 0\r\n    } else {\r\n      wheelDeltaX = 0\r\n      wheelDeltaY = wheelDeltaY * scrollSensitivity\r\n    }\r\n\r\n    if (this.getPlatform() !== 'darwin' && event.shiftKey) {\r\n      let temp = wheelDeltaX\r\n      wheelDeltaX = wheelDeltaY\r\n      wheelDeltaY = temp\r\n    }\r\n\r\n    const scrollLeftChanged = wheelDeltaX !== 0 && this.setScrollLeft(this.getScrollLeft() - wheelDeltaX)\r\n    const scrollTopChanged = wheelDeltaY !== 0 && this.setScrollTop(this.getScrollTop() - wheelDeltaY)\r\n\r\n    if (scrollLeftChanged || scrollTopChanged) this.updateSync()\r\n  }\r", "name": "getScrollLeft", "func_location": "TextEditorComponent.didMouseWheel", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1548, "func_start_line": 1529}}, {"func_info": {"comment": [], "name": "TextEditorComponent.setScrollTop", "params": ["scrollTop"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2809, "start_line": 2796}, "call_info": {"func_end_line": 1552, "code": "  didMouseWheel (event) {\r\n    const scrollSensitivity = this.props.model.getScrollSensitivity() / 100\r\n\r\n    let {wheelDeltaX, wheelDeltaY} = event\r\n\r\n    if (Math.abs(wheelDeltaX) > Math.abs(wheelDeltaY)) {\r\n      wheelDeltaX = wheelDeltaX * scrollSensitivity\r\n      wheelDeltaY = 0\r\n    } else {\r\n      wheelDeltaX = 0\r\n      wheelDeltaY = wheelDeltaY * scrollSensitivity\r\n    }\r\n\r\n    if (this.getPlatform() !== 'darwin' && event.shiftKey) {\r\n      let temp = wheelDeltaX\r\n      wheelDeltaX = wheelDeltaY\r\n      wheelDeltaY = temp\r\n    }\r\n\r\n    const scrollLeftChanged = wheelDeltaX !== 0 && this.setScrollLeft(this.getScrollLeft() - wheelDeltaX)\r\n    const scrollTopChanged = wheelDeltaY !== 0 && this.setScrollTop(this.getScrollTop() - wheelDeltaY)\r\n\r\n    if (scrollLeftChanged || scrollTopChanged) this.updateSync()\r\n  }\r", "name": "setScrollTop", "func_location": "TextEditorComponent.didMouseWheel", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1549, "func_start_line": 1529}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollTop", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2794, "start_line": 2791}, "call_info": {"func_end_line": 1552, "code": "  didMouseWheel (event) {\r\n    const scrollSensitivity = this.props.model.getScrollSensitivity() / 100\r\n\r\n    let {wheelDeltaX, wheelDeltaY} = event\r\n\r\n    if (Math.abs(wheelDeltaX) > Math.abs(wheelDeltaY)) {\r\n      wheelDeltaX = wheelDeltaX * scrollSensitivity\r\n      wheelDeltaY = 0\r\n    } else {\r\n      wheelDeltaX = 0\r\n      wheelDeltaY = wheelDeltaY * scrollSensitivity\r\n    }\r\n\r\n    if (this.getPlatform() !== 'darwin' && event.shiftKey) {\r\n      let temp = wheelDeltaX\r\n      wheelDeltaX = wheelDeltaY\r\n      wheelDeltaY = temp\r\n    }\r\n\r\n    const scrollLeftChanged = wheelDeltaX !== 0 && this.setScrollLeft(this.getScrollLeft() - wheelDeltaX)\r\n    const scrollTopChanged = wheelDeltaY !== 0 && this.setScrollTop(this.getScrollTop() - wheelDeltaY)\r\n\r\n    if (scrollLeftChanged || scrollTopChanged) this.updateSync()\r\n  }\r", "name": "getScrollTop", "func_location": "TextEditorComponent.didMouseWheel", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1549, "func_start_line": 1529}}, {"func_info": {"comment": [], "name": "TextEditorComponent.updateSync", "params": ["useScheduler"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 289, "start_line": 221}, "call_info": {"func_end_line": 1552, "code": "  didMouseWheel (event) {\r\n    const scrollSensitivity = this.props.model.getScrollSensitivity() / 100\r\n\r\n    let {wheelDeltaX, wheelDeltaY} = event\r\n\r\n    if (Math.abs(wheelDeltaX) > Math.abs(wheelDeltaY)) {\r\n      wheelDeltaX = wheelDeltaX * scrollSensitivity\r\n      wheelDeltaY = 0\r\n    } else {\r\n      wheelDeltaX = 0\r\n      wheelDeltaY = wheelDeltaY * scrollSensitivity\r\n    }\r\n\r\n    if (this.getPlatform() !== 'darwin' && event.shiftKey) {\r\n      let temp = wheelDeltaX\r\n      wheelDeltaX = wheelDeltaY\r\n      wheelDeltaY = temp\r\n    }\r\n\r\n    const scrollLeftChanged = wheelDeltaX !== 0 && this.setScrollLeft(this.getScrollLeft() - wheelDeltaX)\r\n    const scrollTopChanged = wheelDeltaY !== 0 && this.setScrollTop(this.getScrollTop() - wheelDeltaY)\r\n\r\n    if (scrollLeftChanged || scrollTopChanged) this.updateSync()\r\n  }\r", "name": "updateSync", "func_location": "TextEditorComponent.didMouseWheel", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1551, "func_start_line": 1529}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getPlatform", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2966, "start_line": 2964}, "call_info": {"func_end_line": 1615, "code": "  didPaste (event) {\r\n    // On Linux, Chromium translates a middle-button mouse click into a\r\n    // mousedown event *and* a paste event. Since Atom supports the middle mouse\r\n    // click as a way of closing a tab, we only want the mousedown event, not\r\n    // the paste event. And since we don't use the `paste` event for any\r\n    // behavior in Atom, we can no-op the event to eliminate this issue.\r\n    // See https://github.com/atom/atom/pull/15183#issue-248432413.\r\n    if (this.getPlatform() === 'linux') event.preventDefault()\r\n  }\r", "name": "getPlatform", "func_location": "TextEditorComponent.didPaste", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1614, "func_start_line": 1607}}, {"func_info": {"comment": [], "name": "TextEditorComponent.scheduleUpdate", "params": ["nextUpdateOnlyBlinksCursors"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 219, "start_line": 204}, "call_info": {"func_end_line": 2015, "code": "  didRequestAutoscroll (autoscroll) {\r\n    this.pendingAutoscroll = autoscroll\r\n    this.scheduleUpdate()\r\n  }\r", "name": "scheduleUpdate", "func_location": "TextEditorComponent.didRequestAutoscroll", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2014, "func_start_line": 2012}}, {"func_info": {"comment": [], "name": "TextEditorComponent.spliceLineTopIndex", "params": ["startRow", "oldExtent", "newExtent"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2586, "start_line": 2580}, "call_info": {"func_end_line": 2461, "code": "  didResetDisplayLayer () {\r\n    this.spliceLineTopIndex(0, Infinity, Infinity)\r\n    this.scheduleUpdate()\r\n  }\r", "name": "spliceLineTopIndex", "func_location": "TextEditorComponent.didResetDisplayLayer", "args": [{"type": "number"}, "Infinity", "Infinity"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2459, "func_start_line": 2458}}, {"func_info": {"comment": [], "name": "TextEditorComponent.scheduleUpdate", "params": ["nextUpdateOnlyBlinksCursors"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 219, "start_line": 204}, "call_info": {"func_end_line": 2461, "code": "  didResetDisplayLayer () {\r\n    this.spliceLineTopIndex(0, Infinity, Infinity)\r\n    this.scheduleUpdate()\r\n  }\r", "name": "scheduleUpdate", "func_location": "TextEditorComponent.didResetDisplayLayer", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2460, "func_start_line": 2458}}, {"func_info": {"comment": [], "name": "TextEditorComponent.isVisible", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2590, "start_line": 2588}, "call_info": {"func_end_line": 1570, "code": "  didResize () {\r\n    // Prevent the component from measuring the client container dimensions when\r\n    // getting spurious resize events.\r\n    if (this.isVisible()) {\r\n      const clientContainerWidthChanged = this.measureClientContainerWidth()\r\n      const clientContainerHeightChanged = this.measureClientContainerHeight()\r\n      if (clientContainerWidthChanged || clientContainerHeightChanged) {\r\n        if (clientContainerWidthChanged) {\r\n          this.remeasureAllBlockDecorations = true\r\n        }\r\n\r\n        this.resizeObserver.disconnect()\r\n        this.scheduleUpdate()\r\n        process.nextTick(() => { this.resizeObserver.observe(this.element) })\r\n      }\r\n    }\r\n  }\r", "name": "isVisible", "func_location": "TextEditorComponent.didResize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1557, "func_start_line": 1554}}, {"func_info": {"comment": [], "name": "TextEditorComponent.measureClientContainerWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2219, "start_line": 2211}, "call_info": {"func_end_line": 1570, "code": "  didResize () {\r\n    // Prevent the component from measuring the client container dimensions when\r\n    // getting spurious resize events.\r\n    if (this.isVisible()) {\r\n      const clientContainerWidthChanged = this.measureClientContainerWidth()\r\n      const clientContainerHeightChanged = this.measureClientContainerHeight()\r\n      if (clientContainerWidthChanged || clientContainerHeightChanged) {\r\n        if (clientContainerWidthChanged) {\r\n          this.remeasureAllBlockDecorations = true\r\n        }\r\n\r\n        this.resizeObserver.disconnect()\r\n        this.scheduleUpdate()\r\n        process.nextTick(() => { this.resizeObserver.observe(this.element) })\r\n      }\r\n    }\r\n  }\r", "name": "measureClientContainerWidth", "func_location": "TextEditorComponent.didResize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1558, "func_start_line": 1554}}, {"func_info": {"comment": [], "name": "TextEditorComponent.measureClientContainerHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2209, "start_line": 2201}, "call_info": {"func_end_line": 1570, "code": "  didResize () {\r\n    // Prevent the component from measuring the client container dimensions when\r\n    // getting spurious resize events.\r\n    if (this.isVisible()) {\r\n      const clientContainerWidthChanged = this.measureClientContainerWidth()\r\n      const clientContainerHeightChanged = this.measureClientContainerHeight()\r\n      if (clientContainerWidthChanged || clientContainerHeightChanged) {\r\n        if (clientContainerWidthChanged) {\r\n          this.remeasureAllBlockDecorations = true\r\n        }\r\n\r\n        this.resizeObserver.disconnect()\r\n        this.scheduleUpdate()\r\n        process.nextTick(() => { this.resizeObserver.observe(this.element) })\r\n      }\r\n    }\r\n  }\r", "name": "measureClientContainerHeight", "func_location": "TextEditorComponent.didResize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1559, "func_start_line": 1554}}, {"func_info": {"comment": [], "name": "TextEditorComponent.scheduleUpdate", "params": ["nextUpdateOnlyBlinksCursors"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 219, "start_line": 204}, "call_info": {"func_end_line": 1570, "code": "  didResize () {\r\n    // Prevent the component from measuring the client container dimensions when\r\n    // getting spurious resize events.\r\n    if (this.isVisible()) {\r\n      const clientContainerWidthChanged = this.measureClientContainerWidth()\r\n      const clientContainerHeightChanged = this.measureClientContainerHeight()\r\n      if (clientContainerWidthChanged || clientContainerHeightChanged) {\r\n        if (clientContainerWidthChanged) {\r\n          this.remeasureAllBlockDecorations = true\r\n        }\r\n\r\n        this.resizeObserver.disconnect()\r\n        this.scheduleUpdate()\r\n        process.nextTick(() => { this.resizeObserver.observe(this.element) })\r\n      }\r\n    }\r\n  }\r", "name": "scheduleUpdate", "func_location": "TextEditorComponent.didResize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1566, "func_start_line": 1554}}, {"func_info": {"comment": [], "name": "TextEditorComponent.invalidateBlockDecorationDimensions", "params": ["decoration"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2578, "start_line": 2575}, "call_info": {"func_end_line": 2573, "code": "  didResizeBlockDecorations (entries) {\r\n    if (!this.visible) return\r\n\r\n    for (let i = 0; i < entries.length; i++) {\r\n      const {target, contentRect} = entries[i]\r\n      const decoration = this.blockDecorationsByElement.get(target)\r\n      const previousHeight = this.heightsByBlockDecoration.get(decoration)\r\n      if (this.element.contains(target) && contentRect.height !== previousHeight) {\r\n        this.invalidateBlockDecorationDimensions(decoration)\r\n      }\r\n    }\r\n  }\r", "name": "invalidateBlockDecorationDimensions", "func_location": "TextEditorComponent.didResizeBlockDecorations", "args": ["decoration"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2570, "func_start_line": 2562}}, {"func_info": {"comment": [], "name": "TextEditorComponent.isVisible", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2590, "start_line": 2588}, "call_info": {"func_end_line": 1580, "code": "  didResizeGutterContainer () {\r\n    // Prevent the component from measuring the gutter dimensions when getting\r\n    // spurious resize events.\r\n    if (this.isVisible() && this.measureGutterDimensions()) {\r\n      this.gutterContainerResizeObserver.disconnect()\r\n      this.scheduleUpdate()\r\n      process.nextTick(() => { this.gutterContainerResizeObserver.observe(this.refs.gutterContainer.element) })\r\n    }\r\n  }\r", "name": "isVisible", "func_location": "TextEditorComponent.didResizeGutterContainer", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1575, "func_start_line": 1572}}, {"func_info": {"comment": [], "name": "TextEditorComponent.measureGutterDimensions", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2199, "start_line": 2175}, "call_info": {"func_end_line": 1580, "code": "  didResizeGutterContainer () {\r\n    // Prevent the component from measuring the gutter dimensions when getting\r\n    // spurious resize events.\r\n    if (this.isVisible() && this.measureGutterDimensions()) {\r\n      this.gutterContainerResizeObserver.disconnect()\r\n      this.scheduleUpdate()\r\n      process.nextTick(() => { this.gutterContainerResizeObserver.observe(this.refs.gutterContainer.element) })\r\n    }\r\n  }\r", "name": "measureGutterDimensions", "func_location": "TextEditorComponent.didResizeGutterContainer", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1575, "func_start_line": 1572}}, {"func_info": {"comment": [], "name": "TextEditorComponent.scheduleUpdate", "params": ["nextUpdateOnlyBlinksCursors"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 219, "start_line": 204}, "call_info": {"func_end_line": 1580, "code": "  didResizeGutterContainer () {\r\n    // Prevent the component from measuring the gutter dimensions when getting\r\n    // spurious resize events.\r\n    if (this.isVisible() && this.measureGutterDimensions()) {\r\n      this.gutterContainerResizeObserver.disconnect()\r\n      this.scheduleUpdate()\r\n      process.nextTick(() => { this.gutterContainerResizeObserver.observe(this.refs.gutterContainer.element) })\r\n    }\r\n  }\r", "name": "scheduleUpdate", "func_location": "TextEditorComponent.didResizeGutterContainer", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1577, "func_start_line": 1572}}, {"func_info": {"comment": [], "name": "TextEditorComponent.setScrollTop", "params": ["scrollTop"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2809, "start_line": 2796}, "call_info": {"func_end_line": 1592, "code": "  didScrollDummyScrollbar () {\r\n    let scrollTopChanged = false\r\n    let scrollLeftChanged = false\r\n    if (!this.scrollTopPending) {\r\n      scrollTopChanged = this.setScrollTop(this.refs.verticalScrollbar.element.scrollTop)\r\n    }\r\n    if (!this.scrollLeftPending) {\r\n      scrollLeftChanged = this.setScrollLeft(this.refs.horizontalScrollbar.element.scrollLeft)\r\n    }\r\n    if (scrollTopChanged || scrollLeftChanged) this.updateSync()\r\n  }\r", "name": "setScrollTop", "func_location": "TextEditorComponent.didScrollDummyScrollbar", "args": [".refs.verticalScrollbar.element.scrollTop"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1586, "func_start_line": 1582}}, {"func_info": {"comment": [], "name": "TextEditorComponent.setScrollLeft", "params": ["scrollLeft"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2839, "start_line": 2827}, "call_info": {"func_end_line": 1592, "code": "  didScrollDummyScrollbar () {\r\n    let scrollTopChanged = false\r\n    let scrollLeftChanged = false\r\n    if (!this.scrollTopPending) {\r\n      scrollTopChanged = this.setScrollTop(this.refs.verticalScrollbar.element.scrollTop)\r\n    }\r\n    if (!this.scrollLeftPending) {\r\n      scrollLeftChanged = this.setScrollLeft(this.refs.horizontalScrollbar.element.scrollLeft)\r\n    }\r\n    if (scrollTopChanged || scrollLeftChanged) this.updateSync()\r\n  }\r", "name": "setScrollLeft", "func_location": "TextEditorComponent.didScrollDummyScrollbar", "args": [".refs.horizontalScrollbar.element.scrollLeft"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1589, "func_start_line": 1582}}, {"func_info": {"comment": [], "name": "TextEditorComponent.updateSync", "params": ["useScheduler"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 289, "start_line": 221}, "call_info": {"func_end_line": 1592, "code": "  didScrollDummyScrollbar () {\r\n    let scrollTopChanged = false\r\n    let scrollLeftChanged = false\r\n    if (!this.scrollTopPending) {\r\n      scrollTopChanged = this.setScrollTop(this.refs.verticalScrollbar.element.scrollTop)\r\n    }\r\n    if (!this.scrollLeftPending) {\r\n      scrollLeftChanged = this.setScrollLeft(this.refs.horizontalScrollbar.element.scrollLeft)\r\n    }\r\n    if (scrollTopChanged || scrollLeftChanged) this.updateSync()\r\n  }\r", "name": "updateSync", "func_location": "TextEditorComponent.didScrollDummyScrollbar", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1591, "func_start_line": 1582}}, {"func_info": {"start_line": 1866, "end_line": 1881, "name": "Workspace.scan.onPathsSearched", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js"}, "call_info": {"func_end_line": 1907, "code": "        didSearchPaths (count) {\r\n          return onPathsSearched(searcher, count)\r\n        }\r", "name": "onPathsSearched", "func_location": "Workspace.scan.(unnamed_function_41).searchOptions.didSearchPaths", "args": ["searcher", "count"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1906, "func_start_line": 1905}}, {"func_info": {"comment": [], "name": "TextEditorComponent.isVisible", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2590, "start_line": 2588}, "call_info": {"func_end_line": 1465, "code": "  didShow () {\r\n    if (!this.visible && this.isVisible()) {\r\n      if (!this.hasInitialMeasurements) this.measureDimensions()\r\n      this.visible = true\r\n      this.props.model.setVisible(true)\r\n      this.resizeBlockDecorationMeasurementsArea = true\r\n      this.updateSync()\r\n      this.flushPendingLogicalScrollPosition()\r\n    }\r\n  }\r", "name": "isVisible", "func_location": "TextEditorComponent.didShow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1457, "func_start_line": 1456}}, {"func_info": {"comment": [" This method exists because it existed in the previous implementation and some", " package tests relied on it"], "name": "TextEditorComponent.measureDimensions", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2156, "start_line": 2149}, "call_info": {"func_end_line": 1465, "code": "  didShow () {\r\n    if (!this.visible && this.isVisible()) {\r\n      if (!this.hasInitialMeasurements) this.measureDimensions()\r\n      this.visible = true\r\n      this.props.model.setVisible(true)\r\n      this.resizeBlockDecorationMeasurementsArea = true\r\n      this.updateSync()\r\n      this.flushPendingLogicalScrollPosition()\r\n    }\r\n  }\r", "name": "measureDimensions", "func_location": "TextEditorComponent.didShow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1458, "func_start_line": 1456}}, {"func_info": {"comment": [], "name": "TextEditorComponent.updateSync", "params": ["useScheduler"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 289, "start_line": 221}, "call_info": {"func_end_line": 1465, "code": "  didShow () {\r\n    if (!this.visible && this.isVisible()) {\r\n      if (!this.hasInitialMeasurements) this.measureDimensions()\r\n      this.visible = true\r\n      this.props.model.setVisible(true)\r\n      this.resizeBlockDecorationMeasurementsArea = true\r\n      this.updateSync()\r\n      this.flushPendingLogicalScrollPosition()\r\n    }\r\n  }\r", "name": "updateSync", "func_location": "TextEditorComponent.didShow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1462, "func_start_line": 1456}}, {"func_info": {"comment": [], "name": "TextEditorComponent.flushPendingLogicalScrollPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2033, "start_line": 2017}, "call_info": {"func_end_line": 1465, "code": "  didShow () {\r\n    if (!this.visible && this.isVisible()) {\r\n      if (!this.hasInitialMeasurements) this.measureDimensions()\r\n      this.visible = true\r\n      this.props.model.setVisible(true)\r\n      this.resizeBlockDecorationMeasurementsArea = true\r\n      this.updateSync()\r\n      this.flushPendingLogicalScrollPosition()\r\n    }\r\n  }\r", "name": "flushPendingLogicalScrollPosition", "func_location": "TextEditorComponent.didShow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1463, "func_start_line": 1456}}, {"func_info": {"comment": [], "name": "TextEditorComponent.isInputEnabled", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2958, "start_line": 2956}, "call_info": {"func_end_line": 1654, "code": "  didTextInput (event) {\r\n    if (this.compositionCheckpoint) {\r\n      this.props.model.revertToCheckpoint(this.compositionCheckpoint)\r\n      this.compositionCheckpoint = null\r\n    }\r\n\r\n    if (this.isInputEnabled()) {\r\n      event.stopPropagation()\r\n\r\n      // WARNING: If we call preventDefault on the input of a space\r\n      // character, then the browser interprets the spacebar keypress as a\r\n      // page-down command, causing spaces to scroll elements containing\r\n      // editors. This means typing space will actually change the contents\r\n      // of the hidden input, which will cause the browser to autoscroll the\r\n      // scroll container to reveal the input if it is off screen (See\r\n      // https://github.com/atom/atom/issues/16046). To correct for this\r\n      // situation, we automatically reset the scroll position to 0,0 after\r\n      // typing a space. None of this can really be tested.\r\n      if (event.data === ' ') {\r\n        window.setImmediate(() => {\r\n          this.refs.scrollContainer.scrollTop = 0\r\n          this.refs.scrollContainer.scrollLeft = 0\r\n        })\r\n      } else {\r\n        event.preventDefault()\r\n      }\r\n\r\n      // If the input event is fired while the accented character menu is open it\r\n      // means that the user has chosen one of the accented alternatives. Thus, we\r\n      // will replace the original non accented character with the selected\r\n      // alternative.\r\n      if (this.accentedCharacterMenuIsOpen) {\r\n        this.props.model.selectLeft()\r\n      }\r\n\r\n      this.props.model.insertText(event.data, {groupUndo: true})\r\n    }\r\n  }\r", "name": "isInputEnabled", "func_location": "TextEditorComponent.didTextInput", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1623, "func_start_line": 1617}}, {"func_info": {"comment": [], "name": "TextEditorComponent.scheduleUpdate", "params": ["nextUpdateOnlyBlinksCursors"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 219, "start_line": 204}, "call_info": {"func_end_line": 1605, "code": "  didUpdateScrollbarStyles () {\r\n    if (!this.props.model.isMini()) {\r\n      this.remeasureScrollbars = true\r\n      this.scheduleUpdate()\r\n    }\r\n  }\r", "name": "scheduleUpdate", "func_location": "TextEditorComponent.didUpdateScrollbarStyles", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1603, "func_start_line": 1600}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pauseCursorBlinking", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1984, "start_line": 1981}, "call_info": {"func_end_line": 1979, "code": "  didUpdateSelections () {\r\n    this.pauseCursorBlinking()\r\n    this.scheduleUpdate()\r\n  }\r", "name": "pauseCursorBlinking", "func_location": "TextEditorComponent.didUpdateSelections", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1977, "func_start_line": 1976}}, {"func_info": {"comment": [], "name": "TextEditorComponent.scheduleUpdate", "params": ["nextUpdateOnlyBlinksCursors"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 219, "start_line": 204}, "call_info": {"func_end_line": 1979, "code": "  didUpdateSelections () {\r\n    this.pauseCursorBlinking()\r\n    this.scheduleUpdate()\r\n  }\r", "name": "scheduleUpdate", "func_location": "TextEditorComponent.didUpdateSelections", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1978, "func_start_line": 1976}}, {"func_info": {"comment": [], "name": "TextEditorComponent.scheduleUpdate", "params": ["nextUpdateOnlyBlinksCursors"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 219, "start_line": 204}, "call_info": {"func_end_line": 1598, "code": "  didUpdateStyles () {\r\n    this.remeasureCharacterDimensions = true\r\n    this.horizontalPixelPositionsByScreenLineId.clear()\r\n    this.scheduleUpdate()\r\n  }\r", "name": "scheduleUpdate", "func_location": "TextEditorComponent.didUpdateStyles", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1597, "func_start_line": 1594}}, {"func_info": {"comment": [], "name": "PackageManager.loadPackage", "params": ["nameOrPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 569, "start_line": 551}, "call_info": {"func_end_line": 275, "comment": [" Public: Disable the package with the given name.", "", " * `name` - The {String} package name.", "", " Returns the {Package} that was disabled or null if it isn't loaded."], "code": "  disablePackage (name) {\r\n    const pack = this.loadPackage(name)\r\n    if (!this.isPackageDisabled(name) && pack != null) {\r\n      pack.disable()\r\n    }\r\n    return pack\r\n  }\r", "name": "loadPackage", "func_location": "PackageManager.disablePackage", "args": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 270, "func_start_line": 269}}, {"func_info": {"comment": [" Public: Is the package with the given name disabled?", "", " * `name` - The {String} package name.", "", " Returns a {Boolean}."], "name": "PackageManager.isPackageDisabled", "params": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 284, "start_line": 282}, "call_info": {"func_end_line": 275, "comment": [" Public: Disable the package with the given name.", "", " * `name` - The {String} package name.", "", " Returns the {Package} that was disabled or null if it isn't loaded."], "code": "  disablePackage (name) {\r\n    const pack = this.loadPackage(name)\r\n    if (!this.isPackageDisabled(name) && pack != null) {\r\n      pack.disable()\r\n    }\r\n    return pack\r\n  }\r", "name": "isPackageDisabled", "func_location": "PackageManager.disablePackage", "args": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 271, "func_start_line": 269}}, {"func_info": {"comment": [], "name": "Notification.isDismissable", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js", "end_line": 97, "start_line": 95}, "call_info": {"func_end_line": 89, "comment": [" Extended: Dismisses the notification, removing it from the UI. Calling this", " programmatically will call all callbacks added via `onDidDismiss`."], "code": "  dismiss () {\r\n    if (!this.isDismissable() || this.isDismissed()) return\r\n    this.dismissed = true\r\n    this.emitter.emit('did-dismiss', this)\r\n  }\r", "name": "isDismissable", "func_location": "Notification.dismiss", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js", "line": 86, "func_start_line": 85}}, {"func_info": {"comment": [], "name": "Notification.isDismissed", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js", "end_line": 93, "start_line": 91}, "call_info": {"func_end_line": 89, "comment": [" Extended: Dismisses the notification, removing it from the UI. Calling this", " programmatically will call all callbacks added via `onDidDismiss`."], "code": "  dismiss () {\r\n    if (!this.isDismissable() || this.isDismissed()) return\r\n    this.dismissed = true\r\n    this.emitter.emit('did-dismiss', this)\r\n  }\r", "name": "isDismissed", "func_location": "Notification.dismiss", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js", "line": 86, "func_start_line": 85}}, {"func_info": {"comment": [], "name": "CommandRegistry.handleCommandEvent", "params": ["event"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js", "end_line": 399, "start_line": 309}, "call_info": {"func_end_line": 274, "comment": [" Public: Simulate the dispatch of a command on a DOM node.", "", " This can be useful for testing when you want to simulate the invocation of a", " command on a detached DOM node. Otherwise, the DOM node in question needs to", " be attached to the document so the event bubbles up to the root node to be", " processed.", "", " * `target` The DOM node at which to start bubbling the command event.", " * `commandName` {String} indicating the name of the command to dispatch."], "code": "  dispatch (target, commandName, detail) {\r\n    const event = new CustomEvent(commandName, { bubbles: true, detail })\r\n    Object.defineProperty(event, 'target', { value: target })\r\n    return this.handleCommandEvent(event)\r\n  }\r", "name": "handleCommandEvent", "func_location": "CommandRegistry.dispatch", "args": ["event"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-registry.js", "line": 273, "func_start_line": 270}}, {"func_info": {"comment": [], "name": "AtomEnvironment.restoreWindowDimensions", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 753, "start_line": 747}, "call_info": {"func_end_line": 673, "comment": [" Restore the window to its previous dimensions and show it.", "", " Restores the full screen and maximized state after the window has resized to", " prevent resize glitches."], "code": "  async displayWindow () {\r\n    await this.restoreWindowDimensions()\r\n    const steps = [\r\n      this.restoreWindowBackground(),\r\n      this.show(),\r\n      this.focus()\r\n    ]\r\n    if (this.windowDimensions && this.windowDimensions.fullScreen) {\r\n      steps.push(this.setFullScreen(true))\r\n    }\r\n    if (this.windowDimensions && this.windowDimensions.maximized && process.platform !== 'darwin') {\r\n      steps.push(this.maximize())\r\n    }\r\n    await Promise.all(steps)\r\n  }\r", "name": "restoreWindowDimensions", "func_location": "AtomEnvironment.displayWindow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 660, "func_start_line": 659}}, {"func_info": {"comment": [], "name": "AtomEnvironment.restoreWindowBackground", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 763, "start_line": 755}, "call_info": {"func_end_line": 673, "comment": [" Restore the window to its previous dimensions and show it.", "", " Restores the full screen and maximized state after the window has resized to", " prevent resize glitches."], "code": "  async displayWindow () {\r\n    await this.restoreWindowDimensions()\r\n    const steps = [\r\n      this.restoreWindowBackground(),\r\n      this.show(),\r\n      this.focus()\r\n    ]\r\n    if (this.windowDimensions && this.windowDimensions.fullScreen) {\r\n      steps.push(this.setFullScreen(true))\r\n    }\r\n    if (this.windowDimensions && this.windowDimensions.maximized && process.platform !== 'darwin') {\r\n      steps.push(this.maximize())\r\n    }\r\n    await Promise.all(steps)\r\n  }\r", "name": "restoreWindowBackground", "func_location": "AtomEnvironment.displayWindow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 662, "func_start_line": 659}}, {"func_info": {"comment": [" Extended: Show the current window."], "name": "AtomEnvironment.show", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 614, "start_line": 612}, "call_info": {"func_end_line": 673, "comment": [" Restore the window to its previous dimensions and show it.", "", " Restores the full screen and maximized state after the window has resized to", " prevent resize glitches."], "code": "  async displayWindow () {\r\n    await this.restoreWindowDimensions()\r\n    const steps = [\r\n      this.restoreWindowBackground(),\r\n      this.show(),\r\n      this.focus()\r\n    ]\r\n    if (this.windowDimensions && this.windowDimensions.fullScreen) {\r\n      steps.push(this.setFullScreen(true))\r\n    }\r\n    if (this.windowDimensions && this.windowDimensions.maximized && process.platform !== 'darwin') {\r\n      steps.push(this.maximize())\r\n    }\r\n    await Promise.all(steps)\r\n  }\r", "name": "show", "func_location": "AtomEnvironment.displayWindow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 663, "func_start_line": 659}}, {"func_info": {"comment": [" Extended: Focus the current window."], "name": "AtomEnvironment.focus", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 609, "start_line": 606}, "call_info": {"func_end_line": 673, "comment": [" Restore the window to its previous dimensions and show it.", "", " Restores the full screen and maximized state after the window has resized to", " prevent resize glitches."], "code": "  async displayWindow () {\r\n    await this.restoreWindowDimensions()\r\n    const steps = [\r\n      this.restoreWindowBackground(),\r\n      this.show(),\r\n      this.focus()\r\n    ]\r\n    if (this.windowDimensions && this.windowDimensions.fullScreen) {\r\n      steps.push(this.setFullScreen(true))\r\n    }\r\n    if (this.windowDimensions && this.windowDimensions.maximized && process.platform !== 'darwin') {\r\n      steps.push(this.maximize())\r\n    }\r\n    await Promise.all(steps)\r\n  }\r", "name": "focus", "func_location": "AtomEnvironment.displayWindow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 664, "func_start_line": 659}}, {"func_info": {"comment": [" Extended: Set the full screen state of the current window."], "name": "AtomEnvironment.setFullScreen", "params": ["fullScreen"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 648, "start_line": 646}, "call_info": {"func_end_line": 673, "comment": [" Restore the window to its previous dimensions and show it.", "", " Restores the full screen and maximized state after the window has resized to", " prevent resize glitches."], "code": "  async displayWindow () {\r\n    await this.restoreWindowDimensions()\r\n    const steps = [\r\n      this.restoreWindowBackground(),\r\n      this.show(),\r\n      this.focus()\r\n    ]\r\n    if (this.windowDimensions && this.windowDimensions.fullScreen) {\r\n      steps.push(this.setFullScreen(true))\r\n    }\r\n    if (this.windowDimensions && this.windowDimensions.maximized && process.platform !== 'darwin') {\r\n      steps.push(this.maximize())\r\n    }\r\n    await Promise.all(steps)\r\n  }\r", "name": "setFullScreen", "func_location": "AtomEnvironment.displayWindow", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 667, "func_start_line": 659}}, {"func_info": {"comment": [], "name": "AtomEnvironment.maximize", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 638, "start_line": 636}, "call_info": {"func_end_line": 673, "comment": [" Restore the window to its previous dimensions and show it.", "", " Restores the full screen and maximized state after the window has resized to", " prevent resize glitches."], "code": "  async displayWindow () {\r\n    await this.restoreWindowDimensions()\r\n    const steps = [\r\n      this.restoreWindowBackground(),\r\n      this.show(),\r\n      this.focus()\r\n    ]\r\n    if (this.windowDimensions && this.windowDimensions.fullScreen) {\r\n      steps.push(this.setFullScreen(true))\r\n    }\r\n    if (this.windowDimensions && this.windowDimensions.maximized && process.platform !== 'darwin') {\r\n      steps.push(this.maximize())\r\n    }\r\n    await Promise.all(steps)\r\n  }\r", "name": "maximize", "func_location": "AtomEnvironment.displayWindow", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 670, "func_start_line": 659}}, {"func_info": {"comment": [], "name": "ReopenProjectMenuManager.disposeProjectMenu", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js", "end_line": 117, "start_line": 112}, "call_info": {"func_end_line": 110, "code": "  dispose () {\r\n    this.subscriptions.dispose()\r\n    this.disposeProjectMenu()\r\n    if (this.reopenProjectListView != null) {\r\n      this.reopenProjectListView.dispose()\r\n    }\r\n  }\r", "name": "disposeProjectMenu", "func_location": "ReopenProjectMenuManager.dispose", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js", "line": 106, "func_start_line": 104}}, {"func_info": {"comment": [], "name": "ReopenProjectListView.cancel", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js", "end_line": 50, "start_line": 40}, "call_info": {"func_end_line": 38, "code": "  dispose () {\r\n    this.cancel()\r\n    return this.selectListView.destroy()\r\n  }\r", "name": "cancel", "func_location": "ReopenProjectListView.dispose", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js", "line": 36, "func_start_line": 35}}, {"func_info": {"comment": [], "name": "TextEditor.getApproximateLongestScreenRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 1296, "start_line": 1296}, "call_info": {"func_end_line": 318, "code": "  doBackgroundWork (deadline) {\r\n    const previousLongestRow = this.getApproximateLongestScreenRow()\r\n    if (this.displayLayer.doBackgroundWork(deadline)) {\r\n      this.backgroundWorkHandle = requestIdleCallback(this.doBackgroundWork)\r\n    } else {\r\n      this.backgroundWorkHandle = null\r\n    }\r\n\r\n    if (this.component && this.getApproximateLongestScreenRow() !== previousLongestRow) {\r\n      this.component.scheduleUpdate()\r\n    }\r\n  }\r", "name": "getApproximateLongestScreenRow", "func_location": "TextEditor.doBackgroundWork", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 308, "func_start_line": 307}}, {"func_info": {"comment": [], "name": "TextEditor.getApproximateLongestScreenRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 1296, "start_line": 1296}, "call_info": {"func_end_line": 318, "code": "  doBackgroundWork (deadline) {\r\n    const previousLongestRow = this.getApproximateLongestScreenRow()\r\n    if (this.displayLayer.doBackgroundWork(deadline)) {\r\n      this.backgroundWorkHandle = requestIdleCallback(this.doBackgroundWork)\r\n    } else {\r\n      this.backgroundWorkHandle = null\r\n    }\r\n\r\n    if (this.component && this.getApproximateLongestScreenRow() !== previousLongestRow) {\r\n      this.component.scheduleUpdate()\r\n    }\r\n  }\r", "name": "getApproximateLongestScreenRow", "func_location": "TextEditor.doBackgroundWork", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 315, "func_start_line": 307}}, {"func_info": {"comment": [], "name": "Dock.setState", "params": ["newState"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 177, "start_line": 144}, "call_info": {"func_end_line": 325, "code": "  draggedOut () {\r\n    this.setState({showDropTarget: false})\r\n    window.removeEventListener('drag', this.handleDrag)\r\n    window.removeEventListener('dragend', this.handleDragEnd)\r\n  }\r", "name": "setState", "func_location": "Dock.draggedOut", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 322, "func_start_line": 321}}, {"func_info": {"comment": [" Retrieves all the {TextBuffer}s in the project; that is, the", " buffers for all open files.", "", " Returns an {Array} of {TextBuffer}s."], "name": "Project.getBuffers", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 623, "start_line": 621}, "call_info": {"func_end_line": 760, "code": "  eachBuffer (...args) {\r\n    let subscriber\r\n    if (args.length > 1) { subscriber = args.shift() }\r\n    const callback = args.shift()\r\n\r\n    for (let buffer of this.getBuffers()) { callback(buffer) }\r\n    if (subscriber) {\r\n      return subscriber.subscribe(this, 'buffer-created', buffer => callback(buffer))\r\n    } else {\r\n      return this.on('buffer-created', buffer => callback(buffer))\r\n    }\r\n  }\r", "name": "getBuffers", "func_location": "Project.eachBuffer", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 754, "func_start_line": 749}}, {"func_info": {"comment": [], "name": "AutoUpdateManager.emitWindowEvent", "params": ["eventName", "payload"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "end_line": 101, "start_line": 97}, "call_info": {"func_end_line": 95, "code": "  emitUpdateAvailableEvent () {\r\n    if (this.releaseVersion == null) return\r\n    this.emitWindowEvent('update-available', {releaseVersion: this.releaseVersion})\r\n  }\r", "name": "emitWindowEvent", "func_location": "AutoUpdateManager.emitUpdateAvailableEvent", "args": [{"type": "string"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "line": 94, "func_start_line": 92}}, {"func_info": {"comment": [" noop callback to get async behavior"], "name": "AutoUpdateManager.getWindows", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "end_line": 177, "start_line": 175}, "call_info": {"func_end_line": 101, "code": "  emitWindowEvent (eventName, payload) {\r\n    for (let atomWindow of this.getWindows()) {\r\n      atomWindow.sendMessage(eventName, payload)\r\n    }\r\n  }\r", "name": "getWindows", "func_location": "AutoUpdateManager.emitWindowEvent", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "line": 98, "func_start_line": 97}}, {"func_info": {"comment": [], "name": "TextEditor.update", "params": ["params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 539, "start_line": 320}, "call_info": {"func_end_line": 1012, "code": "  enableKeyboardInput (enabled) {\r\n    this.update({keyboardInputEnabled: enabled})\r\n  }\r", "name": "update", "func_location": "TextEditor.enableKeyboardInput", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 1011, "func_start_line": 1010}}, {"func_info": {"comment": [], "name": "PackageManager.loadPackage", "params": ["nameOrPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 569, "start_line": 551}, "call_info": {"func_end_line": 262, "comment": ["\r\n  Section: Enabling and disabling packages\r\n  ", " Public: Enable the package with the given name.", "", " * `name` - The {String} package name.", "", " Returns the {Package} that was enabled or null if it isn't loaded."], "code": "  enablePackage (name) {\r\n    const pack = this.loadPackage(name)\r\n    if (pack != null) {\r\n      pack.enable()\r\n    }\r\n    return pack\r\n  }\r", "name": "loadPackage", "func_location": "PackageManager.enablePackage", "args": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 257, "func_start_line": 256}}, {"func_info": {"comment": [" Flattens the given menu and submenu items into an single Array.", "", " menu - A complete menu configuration object for atom-shell's menu API.", "", " Returns an Array of native menu items."], "name": "ApplicationMenu.flattenMenuItems", "params": ["menu"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "end_line": 76, "start_line": 67}, "call_info": {"func_end_line": 100, "comment": [" Public: Used to make all window related menu items are active.", "", " enable - If true enables all window specific items, if false disables all", "          window specific items."], "code": "  enableWindowSpecificItems (enable) {\r\n    for (let item of this.flattenMenuItems(this.menu)) {\r\n      if (item.metadata && item.metadata.windowSpecific) item.enabled = enable\r\n    }\r\n  }\r", "name": "flattenMenuItems", "func_location": "ApplicationMenu.enableWindowSpecificItems", "args": [".menu"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "line": 97, "func_start_line": 96}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.indentLevelForLine", "params": ["line", "tabLength"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 505, "start_line": 492}, "call_info": {"func_end_line": 695, "code": "  endRowForCodeFoldAtRow (row, tabLength, existenceOnly) {\r\n    let foldEndRow\r\n    const line = this.buffer.lineForRow(row)\r\n    if (!NON_WHITESPACE_REGEX.test(line)) return\r\n    const startIndentLevel = this.indentLevelForLine(line, tabLength)\r\n    const scopeDescriptor = this.scopeDescriptorForPosition([row, 0])\r\n    const foldEndRegex = this.foldEndRegexForScopeDescriptor(scopeDescriptor)\r\n    for (let nextRow = row + 1, end = this.buffer.getLineCount(); nextRow < end; nextRow++) {\r\n      const line = this.buffer.lineForRow(nextRow)\r\n      if (!NON_WHITESPACE_REGEX.test(line)) continue\r\n      const indentation = this.indentLevelForLine(line, tabLength)\r\n      if (indentation < startIndentLevel) {\r\n        break\r\n      } else if (indentation === startIndentLevel) {\r\n        if (foldEndRegex && foldEndRegex.searchSync(line)) foldEndRow = nextRow\r\n        break\r\n      }\r\n      foldEndRow = nextRow\r\n      if (existenceOnly) break\r\n    }\r\n    return foldEndRow\r\n  }\r", "name": "indentLevelForLine", "func_location": "TextMateLanguageMode.endRowForCodeFoldAtRow", "args": ["line", "tabLength"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 678, "func_start_line": 674}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.scopeDescriptorForPosition", "params": ["position"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 526, "start_line": 507}, "call_info": {"func_end_line": 695, "code": "  endRowForCodeFoldAtRow (row, tabLength, existenceOnly) {\r\n    let foldEndRow\r\n    const line = this.buffer.lineForRow(row)\r\n    if (!NON_WHITESPACE_REGEX.test(line)) return\r\n    const startIndentLevel = this.indentLevelForLine(line, tabLength)\r\n    const scopeDescriptor = this.scopeDescriptorForPosition([row, 0])\r\n    const foldEndRegex = this.foldEndRegexForScopeDescriptor(scopeDescriptor)\r\n    for (let nextRow = row + 1, end = this.buffer.getLineCount(); nextRow < end; nextRow++) {\r\n      const line = this.buffer.lineForRow(nextRow)\r\n      if (!NON_WHITESPACE_REGEX.test(line)) continue\r\n      const indentation = this.indentLevelForLine(line, tabLength)\r\n      if (indentation < startIndentLevel) {\r\n        break\r\n      } else if (indentation === startIndentLevel) {\r\n        if (foldEndRegex && foldEndRegex.searchSync(line)) foldEndRow = nextRow\r\n        break\r\n      }\r\n      foldEndRow = nextRow\r\n      if (existenceOnly) break\r\n    }\r\n    return foldEndRow\r\n  }\r", "name": "scopeDescriptorForPosition", "func_location": "TextMateLanguageMode.endRowForCodeFoldAtRow", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 679, "func_start_line": 674}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.foldEndRegexForScopeDescriptor", "params": ["scope"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 711, "start_line": 709}, "call_info": {"func_end_line": 695, "code": "  endRowForCodeFoldAtRow (row, tabLength, existenceOnly) {\r\n    let foldEndRow\r\n    const line = this.buffer.lineForRow(row)\r\n    if (!NON_WHITESPACE_REGEX.test(line)) return\r\n    const startIndentLevel = this.indentLevelForLine(line, tabLength)\r\n    const scopeDescriptor = this.scopeDescriptorForPosition([row, 0])\r\n    const foldEndRegex = this.foldEndRegexForScopeDescriptor(scopeDescriptor)\r\n    for (let nextRow = row + 1, end = this.buffer.getLineCount(); nextRow < end; nextRow++) {\r\n      const line = this.buffer.lineForRow(nextRow)\r\n      if (!NON_WHITESPACE_REGEX.test(line)) continue\r\n      const indentation = this.indentLevelForLine(line, tabLength)\r\n      if (indentation < startIndentLevel) {\r\n        break\r\n      } else if (indentation === startIndentLevel) {\r\n        if (foldEndRegex && foldEndRegex.searchSync(line)) foldEndRow = nextRow\r\n        break\r\n      }\r\n      foldEndRow = nextRow\r\n      if (existenceOnly) break\r\n    }\r\n    return foldEndRow\r\n  }\r", "name": "foldEndRegexForScopeDescriptor", "func_location": "TextMateLanguageMode.endRowForCodeFoldAtRow", "args": ["scopeDescriptor"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 680, "func_start_line": 674}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.indentLevelForLine", "params": ["line", "tabLength"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 505, "start_line": 492}, "call_info": {"func_end_line": 695, "code": "  endRowForCodeFoldAtRow (row, tabLength, existenceOnly) {\r\n    let foldEndRow\r\n    const line = this.buffer.lineForRow(row)\r\n    if (!NON_WHITESPACE_REGEX.test(line)) return\r\n    const startIndentLevel = this.indentLevelForLine(line, tabLength)\r\n    const scopeDescriptor = this.scopeDescriptorForPosition([row, 0])\r\n    const foldEndRegex = this.foldEndRegexForScopeDescriptor(scopeDescriptor)\r\n    for (let nextRow = row + 1, end = this.buffer.getLineCount(); nextRow < end; nextRow++) {\r\n      const line = this.buffer.lineForRow(nextRow)\r\n      if (!NON_WHITESPACE_REGEX.test(line)) continue\r\n      const indentation = this.indentLevelForLine(line, tabLength)\r\n      if (indentation < startIndentLevel) {\r\n        break\r\n      } else if (indentation === startIndentLevel) {\r\n        if (foldEndRegex && foldEndRegex.searchSync(line)) foldEndRow = nextRow\r\n        break\r\n      }\r\n      foldEndRow = nextRow\r\n      if (existenceOnly) break\r\n    }\r\n    return foldEndRow\r\n  }\r", "name": "indentLevelForLine", "func_location": "TextMateLanguageMode.endRowForCodeFoldAtRow", "args": ["line", "tabLength"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 684, "func_start_line": 674}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.isRowCommented", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 602, "start_line": 600}, "call_info": {"func_end_line": 672, "code": "  endRowForCommentFoldAtRow (row, existenceOnly) {\r\n    if (this.isRowCommented(row - 1)) return\r\n\r\n    let endRow\r\n    for (let nextRow = row + 1, end = this.buffer.getLineCount(); nextRow < end; nextRow++) {\r\n      if (!this.isRowCommented(nextRow)) break\r\n      endRow = nextRow\r\n      if (existenceOnly) break\r\n    }\r\n\r\n    return endRow\r\n  }\r", "name": "isRowCommented", "func_location": "TextMateLanguageMode.endRowForCommentFoldAtRow", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 662, "func_start_line": 661}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.isRowCommented", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 602, "start_line": 600}, "call_info": {"func_end_line": 672, "code": "  endRowForCommentFoldAtRow (row, existenceOnly) {\r\n    if (this.isRowCommented(row - 1)) return\r\n\r\n    let endRow\r\n    for (let nextRow = row + 1, end = this.buffer.getLineCount(); nextRow < end; nextRow++) {\r\n      if (!this.isRowCommented(nextRow)) break\r\n      endRow = nextRow\r\n      if (existenceOnly) break\r\n    }\r\n\r\n    return endRow\r\n  }\r", "name": "isRowCommented", "func_location": "TextMateLanguageMode.endRowForCommentFoldAtRow", "args": ["nextRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 666, "func_start_line": 661}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.isRowCommented", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 602, "start_line": 600}, "call_info": {"func_end_line": 659, "code": "  endRowForFoldAtRow (row, tabLength, existenceOnly = false) {\r\n    if (this.isRowCommented(row)) {\r\n      return this.endRowForCommentFoldAtRow(row, existenceOnly)\r\n    } else {\r\n      return this.endRowForCodeFoldAtRow(row, tabLength, existenceOnly)\r\n    }\r\n  }\r", "name": "isRowCommented", "func_location": "TextMateLanguageMode.endRowForFoldAtRow", "args": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 654, "func_start_line": 653}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.endRowForCommentFoldAtRow", "params": ["row", "existenceOnly"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 672, "start_line": 661}, "call_info": {"func_end_line": 659, "code": "  endRowForFoldAtRow (row, tabLength, existenceOnly = false) {\r\n    if (this.isRowCommented(row)) {\r\n      return this.endRowForCommentFoldAtRow(row, existenceOnly)\r\n    } else {\r\n      return this.endRowForCodeFoldAtRow(row, tabLength, existenceOnly)\r\n    }\r\n  }\r", "name": "endRowForCommentFoldAtRow", "func_location": "TextMateLanguageMode.endRowForFoldAtRow", "args": ["row", "existenceOnly"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 655, "func_start_line": 653}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.endRowForCodeFoldAtRow", "params": ["row", "tabLength", "existenceOnly"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 695, "start_line": 674}, "call_info": {"func_end_line": 659, "code": "  endRowForFoldAtRow (row, tabLength, existenceOnly = false) {\r\n    if (this.isRowCommented(row)) {\r\n      return this.endRowForCommentFoldAtRow(row, existenceOnly)\r\n    } else {\r\n      return this.endRowForCodeFoldAtRow(row, tabLength, existenceOnly)\r\n    }\r\n  }\r", "name": "endRowForCodeFoldAtRow", "func_location": "TextMateLanguageMode.endRowForFoldAtRow", "args": ["row", "tabLength", "existenceOnly"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 657, "func_start_line": 653}}, {"func_info": {"comment": [], "name": "Config.emitChangeEvent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1213, "start_line": 1211}, "call_info": {"func_end_line": 869, "code": "  endTransaction () {\r\n    this.transactDepth--\r\n    this.emitChangeEvent()\r\n  }\r", "name": "emitChangeEvent", "func_location": "Config.endTransaction", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 868, "func_start_line": 866}}, {"func_info": {"comment": ["\r\n  Section: Construction and Destruction\r\n  ", " Public: Creates a new GitRepository instance.", "", " * `path` The {String} path to the Git repository to open.", " * `options` An optional {Object} with the following keys:", "   * `refreshOnWindowFocus` A {Boolean}, `true` to refresh the index and", "     statuses when the window is focused.", "", " Returns a {GitRepository} instance or `null` if the repository could not be opened."], "name": "GitRepository.open", "params": ["path", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 72, "start_line": 65}, "call_info": {"func_end_line": 51, "code": "  static exists (path) {\r\n    const git = this.open(path)\r\n    if (git) {\r\n      git.destroy()\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r", "name": "open", "func_location": "GitRepository.exists", "args": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 44, "func_start_line": 43}}, {"func_info": {"comment": [" Public: Returns the buffer {Range} for the selection."], "name": "Selection.getBufferRange", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 81, "start_line": 79}, "call_info": {"func_end_line": 408, "comment": [" Public: Expands the newest selection to include the entire line on which", " the cursor currently rests.", "", " It also includes the newline character."], "code": "  expandOverLine (options) {\r\n    const range = this.getBufferRange().union(this.cursor.getCurrentLineBufferRange({includeNewline: true}))\r\n    this.setBufferRange(range, {autoscroll: false})\r\n    const autoscroll = options && options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.cursor.autoscroll()\r\n  }\r", "name": "getBufferRange", "func_location": "Selection.expandOverLine", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 404, "func_start_line": 403}}, {"func_info": {"comment": [" Public: Modifies the buffer {Range} for the selection.", "", " * `bufferRange` The new {Range} to select.", " * `options` (optional) {Object} with the keys:", "   * `preserveFolds` if `true`, the fold settings are preserved after the", "     selection moves.", "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new", "     range. Defaults to `true` if this is the most recently added selection,", "     `false` otherwise."], "name": "Selection.setBufferRange", "params": ["bufferRange", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 104, "start_line": 92}, "call_info": {"func_end_line": 408, "comment": [" Public: Expands the newest selection to include the entire line on which", " the cursor currently rests.", "", " It also includes the newline character."], "code": "  expandOverLine (options) {\r\n    const range = this.getBufferRange().union(this.cursor.getCurrentLineBufferRange({includeNewline: true}))\r\n    this.setBufferRange(range, {autoscroll: false})\r\n    const autoscroll = options && options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.cursor.autoscroll()\r\n  }\r", "name": "setBufferRange", "func_location": "Selection.expandOverLine", "args": ["range", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 405, "func_start_line": 403}}, {"func_info": {"comment": [], "name": "Selection.isLastSelection", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 31, "start_line": 29}, "call_info": {"func_end_line": 408, "comment": [" Public: Expands the newest selection to include the entire line on which", " the cursor currently rests.", "", " It also includes the newline character."], "code": "  expandOverLine (options) {\r\n    const range = this.getBufferRange().union(this.cursor.getCurrentLineBufferRange({includeNewline: true}))\r\n    this.setBufferRange(range, {autoscroll: false})\r\n    const autoscroll = options && options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.cursor.autoscroll()\r\n  }\r", "name": "isLastSelection", "func_location": "Selection.expandOverLine", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 406, "func_start_line": 403}}, {"func_info": {"comment": [" Public: Modifies the buffer {Range} for the selection.", "", " * `bufferRange` The new {Range} to select.", " * `options` (optional) {Object} with the keys:", "   * `preserveFolds` if `true`, the fold settings are preserved after the", "     selection moves.", "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new", "     range. Defaults to `true` if this is the most recently added selection,", "     `false` otherwise."], "name": "Selection.setBufferRange", "params": ["bufferRange", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 104, "start_line": 92}, "call_info": {"func_end_line": 380, "comment": [" Public: Expands the newest selection to include the entire word on which", " the cursors rests."], "code": "  expandOverWord (options) {\r\n    this.setBufferRange(this.getBufferRange().union(this.cursor.getCurrentWordBufferRange()), {autoscroll: false})\r\n    const autoscroll = options && options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.cursor.autoscroll()\r\n  }\r", "name": "setBufferRange", "func_location": "Selection.expandOverWord", "args": [null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 377, "func_start_line": 376}}, {"func_info": {"comment": [" Public: Returns the buffer {Range} for the selection."], "name": "Selection.getBufferRange", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 81, "start_line": 79}, "call_info": {"func_end_line": 380, "comment": [" Public: Expands the newest selection to include the entire word on which", " the cursors rests."], "code": "  expandOverWord (options) {\r\n    this.setBufferRange(this.getBufferRange().union(this.cursor.getCurrentWordBufferRange()), {autoscroll: false})\r\n    const autoscroll = options && options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.cursor.autoscroll()\r\n  }\r", "name": "getBufferRange", "func_location": "Selection.expandOverWord", "args": [null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 377, "func_start_line": 376}}, {"func_info": {"comment": [], "name": "Selection.isLastSelection", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 31, "start_line": 29}, "call_info": {"func_end_line": 380, "comment": [" Public: Expands the newest selection to include the entire word on which", " the cursors rests."], "code": "  expandOverWord (options) {\r\n    this.setBufferRange(this.getBufferRange().union(this.cursor.getCurrentWordBufferRange()), {autoscroll: false})\r\n    const autoscroll = options && options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.cursor.autoscroll()\r\n  }\r", "name": "isLastSelection", "func_location": "Selection.expandOverWord", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 378, "func_start_line": 376}}, {"func_info": {"comment": [], "name": "exitWithStatusCode", "params": ["statusCode"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/initialize-benchmark-window.js", "end_line": 113, "start_line": 110}, "call_info": {"func_end_line": 108, "code": "module.exports = async function () {\r\n  const getWindowLoadSettings = require('./get-window-load-settings')\r\n  const {test, headless, resourcePath, benchmarkPaths} = getWindowLoadSettings()\r\n  try {\r\n    const Clipboard = require('../src/clipboard')\r\n    const ApplicationDelegate = require('../src/application-delegate')\r\n    const AtomEnvironment = require('../src/atom-environment')\r\n    const TextEditor = require('../src/text-editor')\r\n    require('./electron-shims')\r\n\r\n    const exportsPath = path.join(resourcePath, 'exports')\r\n    require('module').globalPaths.push(exportsPath) // Add 'exports' to module search path.\r\n    process.env.NODE_PATH = exportsPath // Set NODE_PATH env variable since tasks may need it.\r\n\r\n    document.title = 'Benchmarks'\r\n    // Allow `document.title` to be assigned in benchmarks without actually changing the window title.\r\n    let documentTitle = null\r\n    Object.defineProperty(document, 'title', {\r\n      get () { return documentTitle },\r\n      set (title) { documentTitle = title }\r\n    })\r\n\r\n    window.addEventListener('keydown', (event) => {\r\n      // Reload: cmd-r / ctrl-r\r\n      if ((event.metaKey || event.ctrlKey) && event.keyCode === 82) {\r\n        ipcHelpers.call('window-method', 'reload')\r\n      }\r\n\r\n      // Toggle Dev Tools: cmd-alt-i (Mac) / ctrl-shift-i (Linux/Windows)\r\n      if (event.keyCode === 73) {\r\n        const isDarwin = process.platform === 'darwin'\r\n        if ((isDarwin && event.metaKey && event.altKey) || (!isDarwin && event.ctrlKey && event.shiftKey)) {\r\n          ipcHelpers.call('window-method', 'toggleDevTools')\r\n        }\r\n      }\r\n\r\n      // Close: cmd-w / ctrl-w\r\n      if ((event.metaKey || event.ctrlKey) && event.keyCode === 87) {\r\n        ipcHelpers.call('window-method', 'close')\r\n      }\r\n\r\n      // Copy: cmd-c / ctrl-c\r\n      if ((event.metaKey || event.ctrlKey) && event.keyCode === 67) {\r\n        ipcHelpers.call('window-method', 'copy')\r\n      }\r\n    }, true)\r\n\r\n    const clipboard = new Clipboard()\r\n    TextEditor.setClipboard(clipboard)\r\n    TextEditor.viewForItem = (item) => atom.views.getView(item)\r\n\r\n    const applicationDelegate = new ApplicationDelegate()\r\n    const environmentParams = {\r\n      applicationDelegate,\r\n      window,\r\n      document,\r\n      clipboard,\r\n      configDirPath: process.env.ATOM_HOME,\r\n      enablePersistence: false\r\n    }\r\n    global.atom = new AtomEnvironment(environmentParams)\r\n    global.atom.initialize(environmentParams)\r\n\r\n    // Prevent benchmarks from modifying application menus\r\n    global.atom.menu.sendToBrowserProcess = function () { }\r\n\r\n    if (headless) {\r\n      Object.defineProperties(process, {\r\n        stdout: { value: remote.process.stdout },\r\n        stderr: { value: remote.process.stderr }\r\n      })\r\n\r\n      console.log = function (...args) {\r\n        const formatted = util.format(...args)\r\n        process.stdout.write(formatted + '\\n')\r\n      }\r\n      console.warn = function (...args) {\r\n        const formatted = util.format(...args)\r\n        process.stderr.write(formatted + '\\n')\r\n      }\r\n      console.error = function (...args) {\r\n        const formatted = util.format(...args)\r\n        process.stderr.write(formatted + '\\n')\r\n      }\r\n    } else {\r\n      remote.getCurrentWindow().show()\r\n    }\r\n\r\n    const benchmarkRunner = require('../benchmarks/benchmark-runner')\r\n    const statusCode = await benchmarkRunner({test, benchmarkPaths})\r\n    if (headless) {\r\n      exitWithStatusCode(statusCode)\r\n    }\r\n  } catch (error) {\r\n    if (headless) {\r\n      console.error(error.stack || error)\r\n      exitWithStatusCode(1)\r\n    } else {\r\n      ipcHelpers.call('window-method', 'openDevTools')\r\n      throw error\r\n    }\r\n  }\r\n}\r", "name": "exitWithStatusCode", "func_location": "module.exports", "args": ["statusCode"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/initialize-benchmark-window.js", "line": 97, "func_start_line": 6}}, {"func_info": {"comment": [], "name": "console.error", "params": ["args"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/initialize-benchmark-window.js", "end_line": 89, "start_line": 86}, "call_info": {"func_end_line": 108, "code": "module.exports = async function () {\r\n  const getWindowLoadSettings = require('./get-window-load-settings')\r\n  const {test, headless, resourcePath, benchmarkPaths} = getWindowLoadSettings()\r\n  try {\r\n    const Clipboard = require('../src/clipboard')\r\n    const ApplicationDelegate = require('../src/application-delegate')\r\n    const AtomEnvironment = require('../src/atom-environment')\r\n    const TextEditor = require('../src/text-editor')\r\n    require('./electron-shims')\r\n\r\n    const exportsPath = path.join(resourcePath, 'exports')\r\n    require('module').globalPaths.push(exportsPath) // Add 'exports' to module search path.\r\n    process.env.NODE_PATH = exportsPath // Set NODE_PATH env variable since tasks may need it.\r\n\r\n    document.title = 'Benchmarks'\r\n    // Allow `document.title` to be assigned in benchmarks without actually changing the window title.\r\n    let documentTitle = null\r\n    Object.defineProperty(document, 'title', {\r\n      get () { return documentTitle },\r\n      set (title) { documentTitle = title }\r\n    })\r\n\r\n    window.addEventListener('keydown', (event) => {\r\n      // Reload: cmd-r / ctrl-r\r\n      if ((event.metaKey || event.ctrlKey) && event.keyCode === 82) {\r\n        ipcHelpers.call('window-method', 'reload')\r\n      }\r\n\r\n      // Toggle Dev Tools: cmd-alt-i (Mac) / ctrl-shift-i (Linux/Windows)\r\n      if (event.keyCode === 73) {\r\n        const isDarwin = process.platform === 'darwin'\r\n        if ((isDarwin && event.metaKey && event.altKey) || (!isDarwin && event.ctrlKey && event.shiftKey)) {\r\n          ipcHelpers.call('window-method', 'toggleDevTools')\r\n        }\r\n      }\r\n\r\n      // Close: cmd-w / ctrl-w\r\n      if ((event.metaKey || event.ctrlKey) && event.keyCode === 87) {\r\n        ipcHelpers.call('window-method', 'close')\r\n      }\r\n\r\n      // Copy: cmd-c / ctrl-c\r\n      if ((event.metaKey || event.ctrlKey) && event.keyCode === 67) {\r\n        ipcHelpers.call('window-method', 'copy')\r\n      }\r\n    }, true)\r\n\r\n    const clipboard = new Clipboard()\r\n    TextEditor.setClipboard(clipboard)\r\n    TextEditor.viewForItem = (item) => atom.views.getView(item)\r\n\r\n    const applicationDelegate = new ApplicationDelegate()\r\n    const environmentParams = {\r\n      applicationDelegate,\r\n      window,\r\n      document,\r\n      clipboard,\r\n      configDirPath: process.env.ATOM_HOME,\r\n      enablePersistence: false\r\n    }\r\n    global.atom = new AtomEnvironment(environmentParams)\r\n    global.atom.initialize(environmentParams)\r\n\r\n    // Prevent benchmarks from modifying application menus\r\n    global.atom.menu.sendToBrowserProcess = function () { }\r\n\r\n    if (headless) {\r\n      Object.defineProperties(process, {\r\n        stdout: { value: remote.process.stdout },\r\n        stderr: { value: remote.process.stderr }\r\n      })\r\n\r\n      console.log = function (...args) {\r\n        const formatted = util.format(...args)\r\n        process.stdout.write(formatted + '\\n')\r\n      }\r\n      console.warn = function (...args) {\r\n        const formatted = util.format(...args)\r\n        process.stderr.write(formatted + '\\n')\r\n      }\r\n      console.error = function (...args) {\r\n        const formatted = util.format(...args)\r\n        process.stderr.write(formatted + '\\n')\r\n      }\r\n    } else {\r\n      remote.getCurrentWindow().show()\r\n    }\r\n\r\n    const benchmarkRunner = require('../benchmarks/benchmark-runner')\r\n    const statusCode = await benchmarkRunner({test, benchmarkPaths})\r\n    if (headless) {\r\n      exitWithStatusCode(statusCode)\r\n    }\r\n  } catch (error) {\r\n    if (headless) {\r\n      console.error(error.stack || error)\r\n      exitWithStatusCode(1)\r\n    } else {\r\n      ipcHelpers.call('window-method', 'openDevTools')\r\n      throw error\r\n    }\r\n  }\r\n}\r", "name": "error", "func_location": "module.exports", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/initialize-benchmark-window.js", "line": 101, "func_start_line": 6}}, {"func_info": {"comment": [], "name": "exitWithStatusCode", "params": ["statusCode"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/initialize-benchmark-window.js", "end_line": 113, "start_line": 110}, "call_info": {"func_end_line": 108, "code": "module.exports = async function () {\r\n  const getWindowLoadSettings = require('./get-window-load-settings')\r\n  const {test, headless, resourcePath, benchmarkPaths} = getWindowLoadSettings()\r\n  try {\r\n    const Clipboard = require('../src/clipboard')\r\n    const ApplicationDelegate = require('../src/application-delegate')\r\n    const AtomEnvironment = require('../src/atom-environment')\r\n    const TextEditor = require('../src/text-editor')\r\n    require('./electron-shims')\r\n\r\n    const exportsPath = path.join(resourcePath, 'exports')\r\n    require('module').globalPaths.push(exportsPath) // Add 'exports' to module search path.\r\n    process.env.NODE_PATH = exportsPath // Set NODE_PATH env variable since tasks may need it.\r\n\r\n    document.title = 'Benchmarks'\r\n    // Allow `document.title` to be assigned in benchmarks without actually changing the window title.\r\n    let documentTitle = null\r\n    Object.defineProperty(document, 'title', {\r\n      get () { return documentTitle },\r\n      set (title) { documentTitle = title }\r\n    })\r\n\r\n    window.addEventListener('keydown', (event) => {\r\n      // Reload: cmd-r / ctrl-r\r\n      if ((event.metaKey || event.ctrlKey) && event.keyCode === 82) {\r\n        ipcHelpers.call('window-method', 'reload')\r\n      }\r\n\r\n      // Toggle Dev Tools: cmd-alt-i (Mac) / ctrl-shift-i (Linux/Windows)\r\n      if (event.keyCode === 73) {\r\n        const isDarwin = process.platform === 'darwin'\r\n        if ((isDarwin && event.metaKey && event.altKey) || (!isDarwin && event.ctrlKey && event.shiftKey)) {\r\n          ipcHelpers.call('window-method', 'toggleDevTools')\r\n        }\r\n      }\r\n\r\n      // Close: cmd-w / ctrl-w\r\n      if ((event.metaKey || event.ctrlKey) && event.keyCode === 87) {\r\n        ipcHelpers.call('window-method', 'close')\r\n      }\r\n\r\n      // Copy: cmd-c / ctrl-c\r\n      if ((event.metaKey || event.ctrlKey) && event.keyCode === 67) {\r\n        ipcHelpers.call('window-method', 'copy')\r\n      }\r\n    }, true)\r\n\r\n    const clipboard = new Clipboard()\r\n    TextEditor.setClipboard(clipboard)\r\n    TextEditor.viewForItem = (item) => atom.views.getView(item)\r\n\r\n    const applicationDelegate = new ApplicationDelegate()\r\n    const environmentParams = {\r\n      applicationDelegate,\r\n      window,\r\n      document,\r\n      clipboard,\r\n      configDirPath: process.env.ATOM_HOME,\r\n      enablePersistence: false\r\n    }\r\n    global.atom = new AtomEnvironment(environmentParams)\r\n    global.atom.initialize(environmentParams)\r\n\r\n    // Prevent benchmarks from modifying application menus\r\n    global.atom.menu.sendToBrowserProcess = function () { }\r\n\r\n    if (headless) {\r\n      Object.defineProperties(process, {\r\n        stdout: { value: remote.process.stdout },\r\n        stderr: { value: remote.process.stderr }\r\n      })\r\n\r\n      console.log = function (...args) {\r\n        const formatted = util.format(...args)\r\n        process.stdout.write(formatted + '\\n')\r\n      }\r\n      console.warn = function (...args) {\r\n        const formatted = util.format(...args)\r\n        process.stderr.write(formatted + '\\n')\r\n      }\r\n      console.error = function (...args) {\r\n        const formatted = util.format(...args)\r\n        process.stderr.write(formatted + '\\n')\r\n      }\r\n    } else {\r\n      remote.getCurrentWindow().show()\r\n    }\r\n\r\n    const benchmarkRunner = require('../benchmarks/benchmark-runner')\r\n    const statusCode = await benchmarkRunner({test, benchmarkPaths})\r\n    if (headless) {\r\n      exitWithStatusCode(statusCode)\r\n    }\r\n  } catch (error) {\r\n    if (headless) {\r\n      console.error(error.stack || error)\r\n      exitWithStatusCode(1)\r\n    } else {\r\n      ipcHelpers.call('window-method', 'openDevTools')\r\n      throw error\r\n    }\r\n  }\r\n}\r", "name": "exitWithStatusCode", "func_location": "module.exports", "args": [{"type": "number"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/initialize-benchmark-window.js", "line": 102, "func_start_line": 6}}, {"func_info": {"comment": [], "name": "Config.extractDefaultsFromSchema", "params": ["schema"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1162, "start_line": 1153}, "call_info": {"func_end_line": 1162, "code": "  extractDefaultsFromSchema (schema) {\r\n    if (schema.default != null) {\r\n      return schema.default\r\n    } else if ((schema.type === 'object') && (schema.properties != null) && isPlainObject(schema.properties)) {\r\n      const defaults = {}\r\n      const properties = schema.properties || {}\r\n      for (let key in properties) { const value = properties[key]; defaults[key] = this.extractDefaultsFromSchema(value) }\r\n      return defaults\r\n    }\r\n  }\r", "name": "extractDefaultsFromSchema", "func_location": "Config.extractDefaultsFromSchema", "args": ["value"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1159, "func_start_line": 1153}}, {"func_info": {"comment": [], "name": "indexOfGroupContainingCommand", "params": ["groups", "command", "ignoreGroup"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js", "end_line": 45, "start_line": 37}, "call_info": {"func_end_line": 154, "code": "function findEdgesInGroup (groups, i, edges) {\r\n  const group = groups[i]\r\n  for (const item of group) {\r\n    if (item.beforeGroupContaining) {\r\n      for (const command of item.beforeGroupContaining) {\r\n        const to = indexOfGroupContainingCommand(groups, command, group)\r\n        if (to !== -1) {\r\n          pushOntoMultiMap(edges, to, i)\r\n          return\r\n        }\r\n      }\r\n    }\r\n    if (item.afterGroupContaining) {\r\n      for (const command of item.afterGroupContaining) {\r\n        const to = indexOfGroupContainingCommand(groups, command, group)\r\n        if (to !== -1) {\r\n          pushOntoMultiMap(edges, i, to)\r\n          return\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r", "name": "indexOfGroupContainingCommand", "func_location": "findEdgesInGroup", "args": ["groups", "command", "group"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js", "line": 137, "func_start_line": 132}}, {"func_info": {"comment": [], "name": "indexOfGroupContainingCommand", "params": ["groups", "command", "ignoreGroup"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js", "end_line": 45, "start_line": 37}, "call_info": {"func_end_line": 154, "code": "function findEdgesInGroup (groups, i, edges) {\r\n  const group = groups[i]\r\n  for (const item of group) {\r\n    if (item.beforeGroupContaining) {\r\n      for (const command of item.beforeGroupContaining) {\r\n        const to = indexOfGroupContainingCommand(groups, command, group)\r\n        if (to !== -1) {\r\n          pushOntoMultiMap(edges, to, i)\r\n          return\r\n        }\r\n      }\r\n    }\r\n    if (item.afterGroupContaining) {\r\n      for (const command of item.afterGroupContaining) {\r\n        const to = indexOfGroupContainingCommand(groups, command, group)\r\n        if (to !== -1) {\r\n          pushOntoMultiMap(edges, i, to)\r\n          return\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r", "name": "indexOfGroupContainingCommand", "func_location": "findEdgesInGroup", "args": ["groups", "command", "group"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js", "line": 146, "func_start_line": 132}}, {"func_info": {"comment": [], "name": "normalizeLabel", "params": ["label"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js", "end_line": 73, "start_line": 68}, "call_info": {"func_end_line": 66, "code": "function findMatchingItemIndex (menu, { type, label, submenu }) {\r\n  if (type === 'separator') {\r\n    return -1\r\n  }\r\n  for (let index = 0; index < menu.length; index++) {\r\n    const item = menu[index]\r\n    if (\r\n      normalizeLabel(item.label) === normalizeLabel(label) &&\r\n      (item.submenu != null) === (submenu != null)\r\n    ) {\r\n      return index\r\n    }\r\n  }\r\n  return -1\r\n}\r", "name": "normalizeLabel", "func_location": "findMatchingItemIndex", "args": ["item.label"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js", "line": 59, "func_start_line": 52}}, {"func_info": {"comment": [], "name": "normalizeLabel", "params": ["label"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js", "end_line": 73, "start_line": 68}, "call_info": {"func_end_line": 66, "code": "function findMatchingItemIndex (menu, { type, label, submenu }) {\r\n  if (type === 'separator') {\r\n    return -1\r\n  }\r\n  for (let index = 0; index < menu.length; index++) {\r\n    const item = menu[index]\r\n    if (\r\n      normalizeLabel(item.label) === normalizeLabel(label) &&\r\n      (item.submenu != null) === (submenu != null)\r\n    ) {\r\n      return index\r\n    }\r\n  }\r\n  return -1\r\n}\r", "name": "normalizeLabel", "func_location": "findMatchingItemIndex", "args": ["item.label"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js", "line": 59, "func_start_line": 52}}, {"func_info": {"comment": [], "name": "Pane.findBottommostSibling", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 1197, "start_line": 1186}, "call_info": {"func_end_line": 1208, "comment": [" If the parent is a vertical axis, returns its last child if it is a pane;", " otherwise returns a new pane created by splitting this pane bottomward."], "code": "  findOrCreateBottommostSibling () {\r\n    const bottommostSibling = this.findBottommostSibling()\r\n    if (bottommostSibling === this) {\r\n      return this.splitDown()\r\n    } else {\r\n      return bottommostSibling\r\n    }\r\n  }\r", "name": "findBottommostSibling", "func_location": "Pane.findOrCreateBottommostSibling", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 1202, "func_start_line": 1201}}, {"func_info": {"comment": [" Public: Creates a new pane below the receiver.", "", " * `params` (optional) {Object} with the following keys:", "   * `items` (optional) {Array} of items to add to the new pane.", "   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane", "", " Returns the new {Pane}."], "name": "Pane.splitDown", "params": ["params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 1094, "start_line": 1092}, "call_info": {"func_end_line": 1208, "comment": [" If the parent is a vertical axis, returns its last child if it is a pane;", " otherwise returns a new pane created by splitting this pane bottomward."], "code": "  findOrCreateBottommostSibling () {\r\n    const bottommostSibling = this.findBottommostSibling()\r\n    if (bottommostSibling === this) {\r\n      return this.splitDown()\r\n    } else {\r\n      return bottommostSibling\r\n    }\r\n  }\r", "name": "splitDown", "func_location": "Pane.findOrCreateBottommostSibling", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 1204, "func_start_line": 1201}}, {"func_info": {"comment": [], "name": "Pane.findRightmostSibling", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 1158, "start_line": 1147}, "call_info": {"func_end_line": 1169, "comment": [" If the parent is a horizontal axis, returns its last child if it is a pane;", " otherwise returns a new pane created by splitting this pane rightward."], "code": "  findOrCreateRightmostSibling () {\r\n    const rightmostSibling = this.findRightmostSibling()\r\n    if (rightmostSibling === this) {\r\n      return this.splitRight()\r\n    } else {\r\n      return rightmostSibling\r\n    }\r\n  }\r", "name": "findRightmostSibling", "func_location": "Pane.findOrCreateRightmostSibling", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 1163, "func_start_line": 1162}}, {"func_info": {"comment": [" Public: Create a new pane to the right of this pane.", "", " * `params` (optional) {Object} with the following keys:", "   * `items` (optional) {Array} of items to add to the new pane.", "   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane", "", " Returns the new {Pane}."], "name": "Pane.splitRight", "params": ["params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 1072, "start_line": 1070}, "call_info": {"func_end_line": 1169, "comment": [" If the parent is a horizontal axis, returns its last child if it is a pane;", " otherwise returns a new pane created by splitting this pane rightward."], "code": "  findOrCreateRightmostSibling () {\r\n    const rightmostSibling = this.findRightmostSibling()\r\n    if (rightmostSibling === this) {\r\n      return this.splitRight()\r\n    } else {\r\n      return rightmostSibling\r\n    }\r\n  }\r", "name": "splitRight", "func_location": "Pane.findOrCreateRightmostSibling", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 1165, "func_start_line": 1162}}, {"func_info": {"comment": [], "name": "AtomApplication.getPackageManager", "params": ["devMode"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1106, "start_line": 1094}, "call_info": {"func_end_line": 1075, "code": "  findPackageWithName (packageName, devMode) {\r\n    return this.getPackageManager(devMode).getAvailablePackageMetadata().find(({name}) =>\r\n      name === packageName\r\n    )\r\n  }\r", "name": "getPackageManager", "func_location": "AtomApplication.findPackageWithName", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 1072, "func_start_line": 1071}}, {"func_info": {"comment": [], "name": "Package.measure", "params": ["key", "fn"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 85, "start_line": 80}, "call_info": {"func_end_line": 120, "name": "measure", "func_location": "Package.finishLoading", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 111, "func_start_line": 110}}, {"func_info": {"comment": [" Flattens the given menu and submenu items into an single Array.", "", " menu - A complete menu configuration object for atom-shell's menu API.", "", " Returns an Array of native menu items."], "name": "ApplicationMenu.flattenMenuItems", "params": ["menu"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "end_line": 76, "start_line": 67}, "call_info": {"func_end_line": 76, "comment": [" Flattens the given menu and submenu items into an single Array.", "", " menu - A complete menu configuration object for atom-shell's menu API.", "", " Returns an Array of native menu items."], "code": "  flattenMenuItems (menu) {\r\n    const object = menu.items || {}\r\n    let items = []\r\n    for (let index in object) {\r\n      const item = object[index]\r\n      items.push(item)\r\n      if (item.submenu) items = items.concat(this.flattenMenuItems(item.submenu))\r\n    }\r\n    return items\r\n  }\r", "name": "flattenMenuItems", "func_location": "ApplicationMenu.flattenMenuItems", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "line": 73, "func_start_line": 67}}, {"func_info": {"comment": [" Flattens the given menu template into an single Array.", "", " template - An object describing the menu item.", "", " Returns an Array of native menu items."], "name": "ApplicationMenu.flattenMenuTemplate", "params": ["template"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "end_line": 90, "start_line": 83}, "call_info": {"func_end_line": 90, "comment": [" Flattens the given menu template into an single Array.", "", " template - An object describing the menu item.", "", " Returns an Array of native menu items."], "code": "  flattenMenuTemplate (template) {\r\n    let items = []\r\n    for (let item of template) {\r\n      items.push(item)\r\n      if (item.submenu) items = items.concat(this.flattenMenuTemplate(item.submenu))\r\n    }\r\n    return items\r\n  }\r", "name": "flattenMenuTemplate", "func_location": "ApplicationMenu.flattenMenuTemplate", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "line": 87, "func_start_line": 83}}, {"func_info": {"comment": [], "name": "TextEditorComponent.setScrollTopRow", "params": ["scrollTopRow", "scheduleUpdate"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2864, "start_line": 2853}, "call_info": {"func_end_line": 2033, "code": "  flushPendingLogicalScrollPosition () {\r\n    let changedScrollTop = false\r\n    if (this.pendingScrollTopRow > 0) {\r\n      changedScrollTop = this.setScrollTopRow(this.pendingScrollTopRow, false)\r\n      this.pendingScrollTopRow = null\r\n    }\r\n\r\n    let changedScrollLeft = false\r\n    if (this.pendingScrollLeftColumn > 0) {\r\n      changedScrollLeft = this.setScrollLeftColumn(this.pendingScrollLeftColumn, false)\r\n      this.pendingScrollLeftColumn = null\r\n    }\r\n\r\n    if (changedScrollTop || changedScrollLeft) {\r\n      this.updateSync()\r\n    }\r\n  }\r", "name": "setScrollTopRow", "func_location": "TextEditorComponent.flushPendingLogicalScrollPosition", "args": [".pendingScrollTopRow", {"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2020, "func_start_line": 2017}}, {"func_info": {"comment": [], "name": "TextEditorComponent.setScrollLeftColumn", "params": ["scrollLeftColumn", "scheduleUpdate"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2885, "start_line": 2874}, "call_info": {"func_end_line": 2033, "code": "  flushPendingLogicalScrollPosition () {\r\n    let changedScrollTop = false\r\n    if (this.pendingScrollTopRow > 0) {\r\n      changedScrollTop = this.setScrollTopRow(this.pendingScrollTopRow, false)\r\n      this.pendingScrollTopRow = null\r\n    }\r\n\r\n    let changedScrollLeft = false\r\n    if (this.pendingScrollLeftColumn > 0) {\r\n      changedScrollLeft = this.setScrollLeftColumn(this.pendingScrollLeftColumn, false)\r\n      this.pendingScrollLeftColumn = null\r\n    }\r\n\r\n    if (changedScrollTop || changedScrollLeft) {\r\n      this.updateSync()\r\n    }\r\n  }\r", "name": "setScrollLeftColumn", "func_location": "TextEditorComponent.flushPendingLogicalScrollPosition", "args": [".pendingScrollLeftColumn", {"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2026, "func_start_line": 2017}}, {"func_info": {"comment": [], "name": "TextEditorComponent.updateSync", "params": ["useScheduler"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 289, "start_line": 221}, "call_info": {"func_end_line": 2033, "code": "  flushPendingLogicalScrollPosition () {\r\n    let changedScrollTop = false\r\n    if (this.pendingScrollTopRow > 0) {\r\n      changedScrollTop = this.setScrollTopRow(this.pendingScrollTopRow, false)\r\n      this.pendingScrollTopRow = null\r\n    }\r\n\r\n    let changedScrollLeft = false\r\n    if (this.pendingScrollLeftColumn > 0) {\r\n      changedScrollLeft = this.setScrollLeftColumn(this.pendingScrollLeftColumn, false)\r\n      this.pendingScrollLeftColumn = null\r\n    }\r\n\r\n    if (changedScrollTop || changedScrollLeft) {\r\n      this.updateSync()\r\n    }\r\n  }\r", "name": "updateSync", "func_location": "TextEditorComponent.flushPendingLogicalScrollPosition", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2031, "func_start_line": 2017}}, {"func_info": {"comment": [" Public: Makes this pane the *active* pane, causing it to gain focus."], "name": "Pane.activate", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 1016, "start_line": 1012}, "call_info": {"func_end_line": 398, "comment": [" Called by the view layer to indicate that the pane has gained focus."], "code": "  focus () {\r\n    this.focused = true\r\n    return this.activate()\r\n  }\r", "name": "activate", "func_location": "Pane.focus", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 397, "func_start_line": 395}}, {"func_info": {"comment": [], "name": "AtomApplication.getAllWindows", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 323, "start_line": 321}, "call_info": {"func_end_line": 750, "comment": [" Public: Returns the currently focused {AtomWindow} or undefined if none."], "code": "  focusedWindow () {\r\n    return this.getAllWindows().find(window => window.isFocused())\r\n  }\r", "name": "getAllWindows", "func_location": "AtomApplication.focusedWindow", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 749, "func_start_line": 748}}, {"func_info": {"comment": [], "name": "WorkspaceElement.focusPaneViewInDirection", "params": ["direction", "pane"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 238, "start_line": 234}, "call_info": {"func_end_line": 226, "code": "  focusPaneViewAbove () { this.focusPaneViewInDirection('above') }\r", "name": "focusPaneViewInDirection", "func_location": "WorkspaceElement.focusPaneViewAbove", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 226, "func_start_line": 226}}, {"func_info": {"comment": [], "name": "WorkspaceElement.focusPaneViewInDirection", "params": ["direction", "pane"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 238, "start_line": 234}, "call_info": {"func_end_line": 228, "code": "  focusPaneViewBelow () { this.focusPaneViewInDirection('below') }\r", "name": "focusPaneViewInDirection", "func_location": "WorkspaceElement.focusPaneViewBelow", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 228, "func_start_line": 228}}, {"func_info": {"comment": [], "name": "WorkspaceElement.nearestVisiblePaneInDirection", "params": ["direction", "pane"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 300, "start_line": 268}, "call_info": {"func_end_line": 238, "code": "  focusPaneViewInDirection (direction, pane) {\r\n    const activePane = this.model.getActivePane()\r\n    const paneToFocus = this.nearestVisiblePaneInDirection(direction, activePane)\r\n    paneToFocus && paneToFocus.focus()\r\n  }\r", "name": "nearestVisiblePaneInDirection", "func_location": "WorkspaceElement.focusPaneViewInDirection", "args": ["direction", "activePane"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 236, "func_start_line": 234}}, {"func_info": {"comment": [], "name": "WorkspaceElement.focusPaneViewInDirection", "params": ["direction", "pane"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 238, "start_line": 234}, "call_info": {"func_end_line": 230, "code": "  focusPaneViewOnLeft () { this.focusPaneViewInDirection('left') }\r", "name": "focusPaneViewInDirection", "func_location": "WorkspaceElement.focusPaneViewOnLeft", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 230, "func_start_line": 230}}, {"func_info": {"comment": [], "name": "WorkspaceElement.focusPaneViewInDirection", "params": ["direction", "pane"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 238, "start_line": 234}, "call_info": {"func_end_line": 232, "code": "  focusPaneViewOnRight () { this.focusPaneViewInDirection('right') }\r", "name": "focusPaneViewInDirection", "func_location": "WorkspaceElement.focusPaneViewOnRight", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 232, "func_start_line": 232}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.regexForPattern", "params": ["pattern"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 720, "start_line": 713}, "call_info": {"func_end_line": 711, "code": "  foldEndRegexForScopeDescriptor (scope) {\r\n    return this.regexForPattern(this.config.get('editor.foldEndPattern', {scope}))\r\n  }\r", "name": "regexForPattern", "func_location": "TextMateLanguageMode.foldEndRegexForScopeDescriptor", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 710, "func_start_line": 709}}, {"func_info": {"comment": ["\r\n  Section: Construction and Destruction\r\n  ", " Public: Create a {ScopeDescriptor} object.", "", " * `object` {Object}", "   * `scopes` {Array} of {String}s"], "name": "ScopeDescriptor.constructor", "params": [["scopes"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/scope-descriptor.js", "end_line": 40, "start_line": 38}, "call_info": {"func_end_line": 28, "name": "constructor", "func_location": "ScopeDescriptor.fromObject", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/scope-descriptor.js", "line": 26, "func_start_line": 22}}, {"func_info": {"comment": [], "name": "Config.getRawScopedValue", "params": ["scopeDescriptor", "keyPath", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1262, "start_line": 1244}, "call_info": {"func_end_line": 602, "comment": ["\r\n  Section: Managing Settings\r\n  ", " Essential: Retrieves the setting for the given key.", "", " ### Examples", "", " You might want to know what themes are enabled, so check `core.themes`", "", " ```coffee", " atom.config.get('core.themes')", " ```", "", " With scope descriptors you can get settings within a specific editor", " scope. For example, you might want to know `editor.tabLength` for ruby", " files.", "", " ```coffee", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " ```", "", " This setting in ruby files might be different than the global tabLength setting", "", " ```coffee", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " ```", "", " You can get the language scope descriptor via", " {TextEditor::getRootScopeDescriptor}. This will get the setting specifically", " for the editor's language.", "", " ```coffee", " atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2", " ```", "", " Additionally, you can get the setting at the specific cursor position.", "", " ```coffee", " scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()", " atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2", " ```", "", " * `keyPath` The {String} name of the key to retrieve.", " * `options` (optional) {Object}", "   * `sources` (optional) {Array} of {String} source names. If provided, only", "     values that were associated with these sources during {::set} will be used.", "   * `excludeSources` (optional) {Array} of {String} source names. If provided,", "     values that  were associated with these sources during {::set} will not", "     be used.", "   * `scope` (optional) {ScopeDescriptor} describing a path from", "     the root of the syntax tree to a token. Get one by calling", "     {editor.getLastCursor().getScopeDescriptor()}", "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)", "     for more information.", "", " Returns the value from Atom's default settings, the user's configuration", " file in the type specified by the configuration schema."], "code": "  get (...args) {\r\n    let keyPath, options, scope\r\n    if (args.length > 1) {\r\n      if ((typeof args[0] === 'string') || (args[0] == null)) {\r\n        [keyPath, options] = args;\r\n        ({scope} = options)\r\n      }\r\n    } else {\r\n      [keyPath] = args\r\n    }\r\n\r\n    if (scope != null) {\r\n      const value = this.getRawScopedValue(scope, keyPath, options)\r\n      return value != null ? value : this.getRawValue(keyPath, options)\r\n    } else {\r\n      return this.getRawValue(keyPath, options)\r\n    }\r\n  }\r", "name": "getRawScopedValue", "func_location": "Config.get", "args": ["scope", "keyPath", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 597, "func_start_line": 585}}, {"func_info": {"comment": [], "name": "Config.getRawValue", "params": ["keyPath", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1018, "start_line": 994}, "call_info": {"func_end_line": 602, "comment": ["\r\n  Section: Managing Settings\r\n  ", " Essential: Retrieves the setting for the given key.", "", " ### Examples", "", " You might want to know what themes are enabled, so check `core.themes`", "", " ```coffee", " atom.config.get('core.themes')", " ```", "", " With scope descriptors you can get settings within a specific editor", " scope. For example, you might want to know `editor.tabLength` for ruby", " files.", "", " ```coffee", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " ```", "", " This setting in ruby files might be different than the global tabLength setting", "", " ```coffee", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " ```", "", " You can get the language scope descriptor via", " {TextEditor::getRootScopeDescriptor}. This will get the setting specifically", " for the editor's language.", "", " ```coffee", " atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2", " ```", "", " Additionally, you can get the setting at the specific cursor position.", "", " ```coffee", " scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()", " atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2", " ```", "", " * `keyPath` The {String} name of the key to retrieve.", " * `options` (optional) {Object}", "   * `sources` (optional) {Array} of {String} source names. If provided, only", "     values that were associated with these sources during {::set} will be used.", "   * `excludeSources` (optional) {Array} of {String} source names. If provided,", "     values that  were associated with these sources during {::set} will not", "     be used.", "   * `scope` (optional) {ScopeDescriptor} describing a path from", "     the root of the syntax tree to a token. Get one by calling", "     {editor.getLastCursor().getScopeDescriptor()}", "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)", "     for more information.", "", " Returns the value from Atom's default settings, the user's configuration", " file in the type specified by the configuration schema."], "code": "  get (...args) {\r\n    let keyPath, options, scope\r\n    if (args.length > 1) {\r\n      if ((typeof args[0] === 'string') || (args[0] == null)) {\r\n        [keyPath, options] = args;\r\n        ({scope} = options)\r\n      }\r\n    } else {\r\n      [keyPath] = args\r\n    }\r\n\r\n    if (scope != null) {\r\n      const value = this.getRawScopedValue(scope, keyPath, options)\r\n      return value != null ? value : this.getRawValue(keyPath, options)\r\n    } else {\r\n      return this.getRawValue(keyPath, options)\r\n    }\r\n  }\r", "name": "getRawValue", "func_location": "Config.get", "args": ["keyPath", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 598, "func_start_line": 585}}, {"func_info": {"comment": [], "name": "Config.getRawValue", "params": ["keyPath", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1018, "start_line": 994}, "call_info": {"func_end_line": 602, "comment": ["\r\n  Section: Managing Settings\r\n  ", " Essential: Retrieves the setting for the given key.", "", " ### Examples", "", " You might want to know what themes are enabled, so check `core.themes`", "", " ```coffee", " atom.config.get('core.themes')", " ```", "", " With scope descriptors you can get settings within a specific editor", " scope. For example, you might want to know `editor.tabLength` for ruby", " files.", "", " ```coffee", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " ```", "", " This setting in ruby files might be different than the global tabLength setting", "", " ```coffee", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " ```", "", " You can get the language scope descriptor via", " {TextEditor::getRootScopeDescriptor}. This will get the setting specifically", " for the editor's language.", "", " ```coffee", " atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2", " ```", "", " Additionally, you can get the setting at the specific cursor position.", "", " ```coffee", " scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()", " atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2", " ```", "", " * `keyPath` The {String} name of the key to retrieve.", " * `options` (optional) {Object}", "   * `sources` (optional) {Array} of {String} source names. If provided, only", "     values that were associated with these sources during {::set} will be used.", "   * `excludeSources` (optional) {Array} of {String} source names. If provided,", "     values that  were associated with these sources during {::set} will not", "     be used.", "   * `scope` (optional) {ScopeDescriptor} describing a path from", "     the root of the syntax tree to a token. Get one by calling", "     {editor.getLastCursor().getScopeDescriptor()}", "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)", "     for more information.", "", " Returns the value from Atom's default settings, the user's configuration", " file in the type specified by the configuration schema."], "code": "  get (...args) {\r\n    let keyPath, options, scope\r\n    if (args.length > 1) {\r\n      if ((typeof args[0] === 'string') || (args[0] == null)) {\r\n        [keyPath, options] = args;\r\n        ({scope} = options)\r\n      }\r\n    } else {\r\n      [keyPath] = args\r\n    }\r\n\r\n    if (scope != null) {\r\n      const value = this.getRawScopedValue(scope, keyPath, options)\r\n      return value != null ? value : this.getRawValue(keyPath, options)\r\n    } else {\r\n      return this.getRawValue(keyPath, options)\r\n    }\r\n  }\r", "name": "getRawValue", "func_location": "Config.get", "args": ["keyPath", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 600, "func_start_line": 585}}, {"func_info": {"comment": [], "name": "rangeForNode", "params": ["node"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1192, "start_line": 1190}, "call_info": {"func_end_line": 22, "code": "        get () {\r\n          return rangeForNode(this)\r\n        }\r", "name": "rangeForNode", "func_location": "get", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 21, "func_start_line": 20}}, {"func_info": {"comment": [], "name": "FileSystemBlobStore.has", "params": ["key"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/file-system-blob-store.js", "end_line": 70, "start_line": 68}, "call_info": {"func_end_line": 77, "code": "  get (key) {\r\n    if (this.has(key)) {\r\n      this.usedKeys.add(key)\r\n      return this.getFromMemory(key) || this.getFromStorage(key)\r\n    }\r\n  }\r", "name": "has", "func_location": "FileSystemBlobStore.get", "args": ["key"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/file-system-blob-store.js", "line": 73, "func_start_line": 72}}, {"func_info": {"comment": ["\r\n  Section: Panes\r\n  ", " Extended: Get the most recently focused pane container.", "", " Returns a {Dock} or the {WorkspaceCenter}."], "name": "Workspace.getActivePaneContainer", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1426, "start_line": 1424}, "call_info": {"func_end_line": 1444, "comment": [" Extended: Get the active {Pane}.", "", " Returns a {Pane}."], "code": "  getActivePane () {\r\n    return this.getActivePaneContainer().getActivePane()\r\n  }\r", "name": "getActivePaneContainer", "func_location": "Workspace.getActivePane", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1443, "func_start_line": 1442}}, {"func_info": {"comment": [], "name": "PaneContainer.getActivePane", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 160, "start_line": 158}, "call_info": {"func_end_line": 164, "code": "  getActivePaneItem () {\r\n    return this.getActivePane().getActiveItem()\r\n  }\r", "name": "getActivePane", "func_location": "PaneContainer.getActivePaneItem", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 163, "func_start_line": 162}}, {"func_info": {"comment": ["\r\n  Section: Panes\r\n  ", " Extended: Get the most recently focused pane container.", "", " Returns a {Dock} or the {WorkspaceCenter}."], "name": "Workspace.getActivePaneContainer", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1426, "start_line": 1424}, "call_info": {"func_end_line": 1359, "comment": [" Essential: Get the active {Pane}'s active item.", "", " Returns an pane item {Object}."], "code": "  getActivePaneItem () {\r\n    return this.getActivePaneContainer().getActivePaneItem()\r\n  }\r", "name": "getActivePaneContainer", "func_location": "Workspace.getActivePaneItem", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1358, "func_start_line": 1357}}, {"func_info": {"comment": [" Essential: Get the active {Pane}'s active item.", "", " Returns an pane item {Object}."], "name": "WorkspaceCenter.getActivePaneItem", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js", "end_line": 265, "start_line": 263}, "call_info": {"func_end_line": 281, "comment": [" Essential: Get the active item if it is an {TextEditor}.", "", " Returns an {TextEditor} or `undefined` if the current active item is not an", " {TextEditor}."], "code": "  getActiveTextEditor () {\r\n    const activeItem = this.getActivePaneItem()\r\n    if (activeItem instanceof TextEditor) { return activeItem }\r\n  }\r", "name": "getActivePaneItem", "func_location": "WorkspaceCenter.getActiveTextEditor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js", "line": 279, "func_start_line": 278}}, {"func_info": {"comment": ["\r\n  Section: Pane Locations\r\n  ", " Essential: Get the {WorkspaceCenter} at the center of the editor window."], "name": "Workspace.getCenter", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1601, "start_line": 1599}, "call_info": {"func_end_line": 1375, "comment": [" Essential: Get the workspace center's active item if it is a {TextEditor}.", "", " Returns a {TextEditor} or `undefined` if the workspace center's current", " active item is not a {TextEditor}."], "code": "  getActiveTextEditor () {\r\n    const activeItem = this.getCenter().getActivePaneItem()\r\n    if (activeItem instanceof TextEditor) { return activeItem }\r\n  }\r", "name": "getCenter", "func_location": "Workspace.getActiveTextEditor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1373, "func_start_line": 1372}}, {"func_info": {"comment": [" Essential: Get the active {Pane}'s active item.", "", " Returns an pane item {Object}."], "name": "Dock.getActivePaneItem", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 651, "start_line": 649}, "call_info": {"func_end_line": 662, "comment": [" Deprecated: Get the active item if it is a {TextEditor}.", "", " Returns a {TextEditor} or `undefined` if the current active item is not a", " {TextEditor}."], "code": "  getActiveTextEditor () {\r\n    Grim.deprecate('Text editors are not allowed in docks. Use atom.workspace.getActiveTextEditor() instead.')\r\n\r\n    const activeItem = this.getActivePaneItem()\r\n    if (activeItem instanceof TextEditor) { return activeItem }\r\n  }\r", "name": "getActivePaneItem", "func_location": "Dock.getActiveTextEditor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 660, "func_start_line": 657}}, {"func_info": {"comment": [" Public: Returns an {Array} of all the active themes."], "name": "ThemeManager.getActiveThemes", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 94, "start_line": 92}, "call_info": {"func_end_line": 89, "comment": ["\r\n  Section: Accessing Active Themes\r\n  ", " Public: Returns an {Array} of {String}s of all the active theme names."], "code": "  getActiveThemeNames () {\r\n    return this.getActiveThemes().map((theme) => theme.name)\r\n  }\r", "name": "getActiveThemes", "func_location": "ThemeManager.getActiveThemeNames", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 88, "func_start_line": 87}}, {"func_info": {"comment": [" Returns the corresponding {Repository}"], "name": "GitRepository.getRepo", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 530, "start_line": 524}, "call_info": {"func_end_line": 256, "comment": [" Public: Returns the number of commits behind the current branch is from the", " its upstream remote branch.", "", " * `reference` The {String} branch reference name.", " * `path`      The {String} path in the repository to get this information for,", "   only needed if the repository contains submodules."], "code": "  getAheadBehindCount (reference, path) {\r\n    return this.getRepo(path).getAheadBehindCount(reference)\r\n  }\r", "name": "getRepo", "func_location": "GitRepository.getAheadBehindCount", "args": ["reference"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 255, "func_start_line": 254}}, {"func_info": {"comment": [], "name": "Config.getLegacyScopeDescriptorForNewScopeDescriptor", "params": ["scopeDescriptor"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 827, "start_line": 825}, "call_info": {"func_end_line": 643, "comment": [" Extended: Get all of the values for the given key-path, along with their", " associated scope selector.", "", " * `keyPath` The {String} name of the key to retrieve", " * `options` (optional) {Object} see the `options` argument to {::get}", "", " Returns an {Array} of {Object}s with the following keys:", "  * `scopeDescriptor` The {ScopeDescriptor} with which the value is associated", "  * `value` The value for the key-path"], "code": "  getAll (keyPath, options) {\r\n    let globalValue, result, scope\r\n    if (options != null) { ({scope} = options) }\r\n\r\n    if (scope != null) {\r\n      let legacyScopeDescriptor\r\n      const scopeDescriptor = ScopeDescriptor.fromObject(scope)\r\n      result = this.scopedSettingsStore.getAll(\r\n          scopeDescriptor.getScopeChain(),\r\n          keyPath,\r\n          options\r\n        )\r\n      legacyScopeDescriptor = this.getLegacyScopeDescriptorForNewScopeDescriptor(scopeDescriptor)\r\n      if (legacyScopeDescriptor) {\r\n        result.push(...Array.from(this.scopedSettingsStore.getAll(\r\n           legacyScopeDescriptor.getScopeChain(),\r\n           keyPath,\r\n           options\r\n         ) || []))\r\n      }\r\n    } else {\r\n      result = []\r\n    }\r\n\r\n    globalValue = this.getRawValue(keyPath, options)\r\n    if (globalValue) {\r\n      result.push({scopeSelector: '*', value: globalValue})\r\n    }\r\n\r\n    return result\r\n  }\r", "name": "getLegacyScopeDescriptorForNewScopeDescriptor", "func_location": "Config.getAll", "args": ["scopeDescriptor"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 625, "func_start_line": 613}}, {"func_info": {"comment": [], "name": "Config.getRawValue", "params": ["keyPath", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1018, "start_line": 994}, "call_info": {"func_end_line": 643, "comment": [" Extended: Get all of the values for the given key-path, along with their", " associated scope selector.", "", " * `keyPath` The {String} name of the key to retrieve", " * `options` (optional) {Object} see the `options` argument to {::get}", "", " Returns an {Array} of {Object}s with the following keys:", "  * `scopeDescriptor` The {ScopeDescriptor} with which the value is associated", "  * `value` The value for the key-path"], "code": "  getAll (keyPath, options) {\r\n    let globalValue, result, scope\r\n    if (options != null) { ({scope} = options) }\r\n\r\n    if (scope != null) {\r\n      let legacyScopeDescriptor\r\n      const scopeDescriptor = ScopeDescriptor.fromObject(scope)\r\n      result = this.scopedSettingsStore.getAll(\r\n          scopeDescriptor.getScopeChain(),\r\n          keyPath,\r\n          options\r\n        )\r\n      legacyScopeDescriptor = this.getLegacyScopeDescriptorForNewScopeDescriptor(scopeDescriptor)\r\n      if (legacyScopeDescriptor) {\r\n        result.push(...Array.from(this.scopedSettingsStore.getAll(\r\n           legacyScopeDescriptor.getScopeChain(),\r\n           keyPath,\r\n           options\r\n         ) || []))\r\n      }\r\n    } else {\r\n      result = []\r\n    }\r\n\r\n    globalValue = this.getRawValue(keyPath, options)\r\n    if (globalValue) {\r\n      result.push({scopeSelector: '*', value: globalValue})\r\n    }\r\n\r\n    return result\r\n  }\r", "name": "getRawValue", "func_location": "Config.getAll", "args": ["keyPath", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 637, "func_start_line": 613}}, {"func_info": {"comment": [], "name": "TextEditor.getApproximateRightmostScreenPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 1290, "start_line": 1290}, "call_info": {"func_end_line": 1296, "code": "  getApproximateLongestScreenRow () { return this.getApproximateRightmostScreenPosition().row }\r", "name": "getApproximateRightmostScreenPosition", "func_location": "TextEditor.getApproximateLongestScreenRow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 1296, "func_start_line": 1296}}, {"func_info": {"comment": [], "name": "PackageManager.getAvailablePackages", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 414, "start_line": 382}, "call_info": {"func_end_line": 380, "comment": [" Public: Returns an {Array} of {String}s of all the available package metadata."], "code": "  getAvailablePackageMetadata () {\r\n    const packages = []\r\n    for (const pack of this.getAvailablePackages()) {\r\n      const loadedPackage = this.getLoadedPackage(pack.name)\r\n      const metadata = loadedPackage != null ? loadedPackage.metadata : this.loadPackageMetadata(pack, true)\r\n      packages.push(metadata)\r\n    }\r\n    return packages\r\n  }\r", "name": "getAvailablePackages", "func_location": "PackageManager.getAvailablePackageMetadata", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 374, "func_start_line": 372}}, {"func_info": {"comment": [" Public: Get the loaded {Package} with the given name.", "", " * `name` - The {String} package name.", "", " Returns a {Package} or undefined."], "name": "PackageManager.getLoadedPackage", "params": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 341, "start_line": 339}, "call_info": {"func_end_line": 380, "comment": [" Public: Returns an {Array} of {String}s of all the available package metadata."], "code": "  getAvailablePackageMetadata () {\r\n    const packages = []\r\n    for (const pack of this.getAvailablePackages()) {\r\n      const loadedPackage = this.getLoadedPackage(pack.name)\r\n      const metadata = loadedPackage != null ? loadedPackage.metadata : this.loadPackageMetadata(pack, true)\r\n      packages.push(metadata)\r\n    }\r\n    return packages\r\n  }\r", "name": "getLoadedPackage", "func_location": "PackageManager.getAvailablePackageMetadata", "args": ["pack.name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 375, "func_start_line": 372}}, {"func_info": {"comment": [], "name": "PackageManager.loadPackageMetadata", "params": ["packagePathOrAvailablePackage", "ignoreErrors"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 882, "start_line": 839}, "call_info": {"func_end_line": 380, "comment": [" Public: Returns an {Array} of {String}s of all the available package metadata."], "code": "  getAvailablePackageMetadata () {\r\n    const packages = []\r\n    for (const pack of this.getAvailablePackages()) {\r\n      const loadedPackage = this.getLoadedPackage(pack.name)\r\n      const metadata = loadedPackage != null ? loadedPackage.metadata : this.loadPackageMetadata(pack, true)\r\n      packages.push(metadata)\r\n    }\r\n    return packages\r\n  }\r", "name": "loadPackageMetadata", "func_location": "PackageManager.getAvailablePackageMetadata", "args": ["pack", {"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 376, "func_start_line": 372}}, {"func_info": {"comment": [], "name": "PackageManager.getAvailablePackages", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 414, "start_line": 382}, "call_info": {"func_end_line": 369, "comment": [" Public: Returns an {Array} of {String}s of all the available package names."], "code": "  getAvailablePackageNames () {\r\n    return this.getAvailablePackages().map(a => a.name)\r\n  }\r", "name": "getAvailablePackages", "func_location": "PackageManager.getAvailablePackageNames", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 368, "func_start_line": 367}}, {"func_info": {"comment": [], "name": "PackageManager.getAvailablePackages", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 414, "start_line": 382}, "call_info": {"func_end_line": 364, "comment": ["\r\n  Section: Accessing available packages\r\n  ", " Public: Returns an {Array} of {String}s of all the available package paths."], "code": "  getAvailablePackagePaths () {\r\n    return this.getAvailablePackages().map(a => a.path)\r\n  }\r", "name": "getAvailablePackages", "func_location": "PackageManager.getAvailablePackagePaths", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 363, "func_start_line": 362}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 146, "comment": [" Extended: get the width of an `x` character displayed in this element.", "", " Returns a {Number} of pixels."], "code": "  getBaseCharacterWidth () {\r\n    return this.getComponent().getBaseCharacterWidth()\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.getBaseCharacterWidth", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 145, "func_start_line": 144}}, {"func_info": {"comment": [" Public: Returns the current buffer position as an Array."], "name": "Cursor.getBufferPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 93, "start_line": 91}, "call_info": {"func_end_line": 547, "comment": [" Public: Retrieves the buffer position of where the current word starts.", "", " * `options` (optional) An {Object} with the following keys:", "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"", "     (default: {::wordRegExp}).", "   * `includeNonWordCharacters` A {Boolean} indicating whether to include", "     non-word characters in the default word regex.", "     Has no effect if wordRegex is set.", "   * `allowPrevious` A {Boolean} indicating whether the beginning of the", "     previous word can be returned.", "", " Returns a {Range}."], "code": "  getBeginningOfCurrentWordBufferPosition (options = {}) {\r\n    const allowPrevious = options.allowPrevious !== false\r\n    const position = this.getBufferPosition()\r\n\r\n    const scanRange = allowPrevious\r\n      ? new Range(new Point(position.row - 1, 0), position)\r\n      : new Range(new Point(position.row, 0), position)\r\n\r\n    const ranges = this.editor.buffer.findAllInRangeSync(\r\n      options.wordRegex || this.wordRegExp(options),\r\n      scanRange\r\n    )\r\n\r\n    let result\r\n    for (let range of ranges) {\r\n      if (position.isLessThanOrEqual(range.start)) break\r\n      if (allowPrevious || position.isLessThanOrEqual(range.end)) result = Point.fromObject(range.start)\r\n    }\r\n\r\n    return result || (allowPrevious ? new Point(0, 0) : position)\r\n  }\r", "name": "getBufferPosition", "func_location": "Cursor.getBeginningOfCurrentWordBufferPosition", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 529, "func_start_line": 527}}, {"func_info": {"comment": [" Public: Get the RegExp used by the cursor to determine what a \"word\" is.", "", " * `options` (optional) {Object} with the following keys:", "   * `includeNonWordCharacters` A {Boolean} indicating whether to include", "     non-word characters in the regex. (default: true)", "", " Returns a {RegExp}."], "name": "Cursor.wordRegExp", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 681, "start_line": 674}, "call_info": {"func_end_line": 547, "comment": [" Public: Retrieves the buffer position of where the current word starts.", "", " * `options` (optional) An {Object} with the following keys:", "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"", "     (default: {::wordRegExp}).", "   * `includeNonWordCharacters` A {Boolean} indicating whether to include", "     non-word characters in the default word regex.", "     Has no effect if wordRegex is set.", "   * `allowPrevious` A {Boolean} indicating whether the beginning of the", "     previous word can be returned.", "", " Returns a {Range}."], "code": "  getBeginningOfCurrentWordBufferPosition (options = {}) {\r\n    const allowPrevious = options.allowPrevious !== false\r\n    const position = this.getBufferPosition()\r\n\r\n    const scanRange = allowPrevious\r\n      ? new Range(new Point(position.row - 1, 0), position)\r\n      : new Range(new Point(position.row, 0), position)\r\n\r\n    const ranges = this.editor.buffer.findAllInRangeSync(\r\n      options.wordRegex || this.wordRegExp(options),\r\n      scanRange\r\n    )\r\n\r\n    let result\r\n    for (let range of ranges) {\r\n      if (position.isLessThanOrEqual(range.start)) break\r\n      if (allowPrevious || position.isLessThanOrEqual(range.end)) result = Point.fromObject(range.start)\r\n    }\r\n\r\n    return result || (allowPrevious ? new Point(0, 0) : position)\r\n  }\r", "name": "wordRegExp", "func_location": "Cursor.getBeginningOfCurrentWordBufferPosition", "args": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 536, "func_start_line": 527}}, {"func_info": {"comment": [" Public: Returns the current buffer position as an Array."], "name": "Cursor.getBufferPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 93, "start_line": 91}, "call_info": {"func_end_line": 753, "code": "  getBeginningOfNextParagraphBufferPosition () {\r\n    const start = this.getBufferPosition()\r\n    const eof = this.editor.getEofBufferPosition()\r\n    const scanRange = [start, eof]\r\n\r\n    const {row, column} = eof\r\n    let position = new Point(row, column - 1)\r\n\r\n    this.editor.scanInBufferRange(EmptyLineRegExp, scanRange, ({range, stop}) => {\r\n      position = range.start.traverse(Point(1, 0))\r\n      if (!position.isEqual(start)) stop()\r\n    })\r\n    return position\r\n  }\r", "name": "getBufferPosition", "func_location": "Cursor.getBeginningOfNextParagraphBufferPosition", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 741, "func_start_line": 740}}, {"func_info": {"comment": [" Public: Returns the current buffer position as an Array."], "name": "Cursor.getBufferPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 93, "start_line": 91}, "call_info": {"func_end_line": 599, "comment": [" Public: Retrieves the buffer position of where the next word starts.", "", " * `options` (optional) {Object}", "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"", "     (default: {::wordRegExp}).", "", " Returns a {Range}"], "code": "  getBeginningOfNextWordBufferPosition (options = {}) {\r\n    const currentBufferPosition = this.getBufferPosition()\r\n    const start = this.isInsideWord(options) ? this.getEndOfCurrentWordBufferPosition(options) : currentBufferPosition\r\n    const scanRange = [start, this.editor.getEofBufferPosition()]\r\n\r\n    let beginningOfNextWordPosition\r\n    this.editor.scanInBufferRange(options.wordRegex || this.wordRegExp(), scanRange, ({range, stop}) => {\r\n      beginningOfNextWordPosition = range.start\r\n      stop()\r\n    })\r\n\r\n    return beginningOfNextWordPosition || currentBufferPosition\r\n  }\r", "name": "getBufferPosition", "func_location": "Cursor.getBeginningOfNextWordBufferPosition", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 588, "func_start_line": 587}}, {"func_info": {"comment": [" Public: Returns whether this cursor is between a word's start and end.", "", " * `options` (optional) {Object}", "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"", "     (default: {::wordRegExp}).", "", " Returns a {Boolean}"], "name": "Cursor.isInsideWord", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 183, "start_line": 178}, "call_info": {"func_end_line": 599, "comment": [" Public: Retrieves the buffer position of where the next word starts.", "", " * `options` (optional) {Object}", "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"", "     (default: {::wordRegExp}).", "", " Returns a {Range}"], "code": "  getBeginningOfNextWordBufferPosition (options = {}) {\r\n    const currentBufferPosition = this.getBufferPosition()\r\n    const start = this.isInsideWord(options) ? this.getEndOfCurrentWordBufferPosition(options) : currentBufferPosition\r\n    const scanRange = [start, this.editor.getEofBufferPosition()]\r\n\r\n    let beginningOfNextWordPosition\r\n    this.editor.scanInBufferRange(options.wordRegex || this.wordRegExp(), scanRange, ({range, stop}) => {\r\n      beginningOfNextWordPosition = range.start\r\n      stop()\r\n    })\r\n\r\n    return beginningOfNextWordPosition || currentBufferPosition\r\n  }\r", "name": "isInsideWord", "func_location": "Cursor.getBeginningOfNextWordBufferPosition", "args": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 589, "func_start_line": 587}}, {"func_info": {"comment": [" Public: Retrieves the buffer position of where the current word ends.", "", " * `options` (optional) {Object} with the following keys:", "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"", "      (default: {::wordRegExp})", "   * `includeNonWordCharacters` A Boolean indicating whether to include", "     non-word characters in the default word regex. Has no effect if", "     wordRegex is set.", "", " Returns a {Range}."], "name": "Cursor.getEndOfCurrentWordBufferPosition", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 578, "start_line": 559}, "call_info": {"func_end_line": 599, "comment": [" Public: Retrieves the buffer position of where the next word starts.", "", " * `options` (optional) {Object}", "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"", "     (default: {::wordRegExp}).", "", " Returns a {Range}"], "code": "  getBeginningOfNextWordBufferPosition (options = {}) {\r\n    const currentBufferPosition = this.getBufferPosition()\r\n    const start = this.isInsideWord(options) ? this.getEndOfCurrentWordBufferPosition(options) : currentBufferPosition\r\n    const scanRange = [start, this.editor.getEofBufferPosition()]\r\n\r\n    let beginningOfNextWordPosition\r\n    this.editor.scanInBufferRange(options.wordRegex || this.wordRegExp(), scanRange, ({range, stop}) => {\r\n      beginningOfNextWordPosition = range.start\r\n      stop()\r\n    })\r\n\r\n    return beginningOfNextWordPosition || currentBufferPosition\r\n  }\r", "name": "getEndOfCurrentWordBufferPosition", "func_location": "Cursor.getBeginningOfNextWordBufferPosition", "args": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 589, "func_start_line": 587}}, {"func_info": {"comment": [" Public: Get the RegExp used by the cursor to determine what a \"word\" is.", "", " * `options` (optional) {Object} with the following keys:", "   * `includeNonWordCharacters` A {Boolean} indicating whether to include", "     non-word characters in the regex. (default: true)", "", " Returns a {RegExp}."], "name": "Cursor.wordRegExp", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 681, "start_line": 674}, "call_info": {"func_end_line": 599, "comment": [" Public: Retrieves the buffer position of where the next word starts.", "", " * `options` (optional) {Object}", "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"", "     (default: {::wordRegExp}).", "", " Returns a {Range}"], "code": "  getBeginningOfNextWordBufferPosition (options = {}) {\r\n    const currentBufferPosition = this.getBufferPosition()\r\n    const start = this.isInsideWord(options) ? this.getEndOfCurrentWordBufferPosition(options) : currentBufferPosition\r\n    const scanRange = [start, this.editor.getEofBufferPosition()]\r\n\r\n    let beginningOfNextWordPosition\r\n    this.editor.scanInBufferRange(options.wordRegex || this.wordRegExp(), scanRange, ({range, stop}) => {\r\n      beginningOfNextWordPosition = range.start\r\n      stop()\r\n    })\r\n\r\n    return beginningOfNextWordPosition || currentBufferPosition\r\n  }\r", "name": "wordRegExp", "func_location": "Cursor.getBeginningOfNextWordBufferPosition", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 593, "func_start_line": 587}}, {"func_info": {"comment": [" Public: Returns the current buffer position as an Array."], "name": "Cursor.getBufferPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 93, "start_line": 91}, "call_info": {"func_end_line": 766, "code": "  getBeginningOfPreviousParagraphBufferPosition () {\r\n    const start = this.getBufferPosition()\r\n\r\n    const {row, column} = start\r\n    const scanRange = [[row - 1, column], [0, 0]]\r\n    let position = new Point(0, 0)\r\n    this.editor.backwardsScanInBufferRange(EmptyLineRegExp, scanRange, ({range, stop}) => {\r\n      position = range.start.traverse(Point(1, 0))\r\n      if (!position.isEqual(start)) stop()\r\n    })\r\n    return position\r\n  }\r", "name": "getBufferPosition", "func_location": "Cursor.getBeginningOfPreviousParagraphBufferPosition", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 756, "func_start_line": 755}}, {"func_info": {"comment": [], "name": "Workspace.getPanels", "params": ["location"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1814, "start_line": 1812}, "call_info": {"func_end_line": 1650, "comment": ["\r\n  Section: Panels\r\n\r\n  Panels are used to display UI related to an editor window. They are placed at one of the four\r\n  edges of the window: left, right, top or bottom. If there are multiple panels on the same window\r\n  edge they are stacked in order of priority: higher priority is closer to the center, lower\r\n  priority towards the edge.\r\n\r\n  *Note:* If your panel changes its size throughout its lifetime, consider giving it a higher\r\n  priority, allowing fixed size panels to be closer to the edge. This allows control targets to\r\n  remain more static for easier targeting by users that employ mice or trackpads. (See\r\n  [atom/atom#4834](https://github.com/atom/atom/issues/4834) for discussion.)\r\n  ", " Essential: Get an {Array} of all the panel items at the bottom of the editor window."], "code": "  getBottomPanels () {\r\n    return this.getPanels('bottom')\r\n  }\r", "name": "getPanels", "func_location": "Workspace.getBottomPanels", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1649, "func_start_line": 1648}}, {"func_info": {"comment": [" Public: Returns the current buffer position as an Array."], "name": "Cursor.getBufferPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 93, "start_line": 91}, "call_info": {"func_end_line": 113, "comment": [" Public: Returns the cursor's current buffer column."], "code": "  getBufferColumn () {\r\n    return this.getBufferPosition().column\r\n  }\r", "name": "getBufferPosition", "func_location": "Cursor.getBufferColumn", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 112, "func_start_line": 111}}, {"func_info": {"comment": [" Public: Returns the current buffer position as an Array."], "name": "Cursor.getBufferPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 93, "start_line": 91}, "call_info": {"func_end_line": 108, "comment": [" Public: Retrieves the cursor's current buffer row."], "code": "  getBufferRow () {\r\n    return this.getBufferPosition().row\r\n  }\r", "name": "getBufferPosition", "func_location": "Cursor.getBufferRow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 107, "func_start_line": 106}}, {"func_info": {"comment": [" Public: Returns the buffer {Range} for the selection."], "name": "Selection.getBufferRange", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 81, "start_line": 79}, "call_info": {"func_end_line": 116, "comment": [" Public: Returns the starting and ending buffer rows the selection is", " highlighting.", "", " Returns an {Array} of two {Number}s: the starting row, and the ending row."], "code": "  getBufferRowRange () {\r\n    const range = this.getBufferRange()\r\n    const start = range.start.row\r\n    let end = range.end.row\r\n    if (range.end.column === 0) end = Math.max(start, end - 1)\r\n    return [start, end]\r\n  }\r", "name": "getBufferRange", "func_location": "Selection.getBufferRowRange", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 111, "func_start_line": 110}}, {"func_info": {"comment": [], "name": "Package.getBuildFailureOutputStorageKey", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 1034, "start_line": 1032}, "call_info": {"func_end_line": 1017, "comment": [" Extended: If a previous rebuild failed, get the contents of stderr.", "", " Returns a {String} or null if no previous build failure occurred."], "code": "  getBuildFailureOutput () {\r\n    return global.localStorage.getItem(this.getBuildFailureOutputStorageKey())\r\n  }\r", "name": "getBuildFailureOutputStorageKey", "func_location": "Package.getBuildFailureOutput", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 1016, "func_start_line": 1015}}, {"func_info": {"comment": [" Public: Makes a path relative to the repository's working directory."], "name": "GitRepository.relativize", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 210, "start_line": 208}, "call_info": {"func_end_line": 399, "comment": [" Public: Get the cached status for the given path.", "", " * `path` A {String} path in the repository, relative or absolute.", "", " Returns a status {Number} or null if the path is not in the cache."], "code": "  getCachedPathStatus (path) {\r\n    return this.statuses[this.relativize(path)]\r\n  }\r", "name": "relativize", "func_location": "GitRepository.getCachedPathStatus", "args": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 398, "func_start_line": 397}}, {"func_info": {"comment": [" Returns the corresponding {Repository}"], "name": "GitRepository.getRepo", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 530, "start_line": 524}, "call_info": {"func_end_line": 269, "comment": [" Public: Get the cached ahead/behind commit counts for the current branch's", " upstream branch.", "", " * `path` An optional {String} path in the repository to get this information", "   for, only needed if the repository has submodules.", "", " Returns an {Object} with the following keys:", "   * `ahead`  The {Number} of commits ahead.", "   * `behind` The {Number} of commits behind."], "code": "  getCachedUpstreamAheadBehindCount (path) {\r\n    return this.getRepo(path).upstream || this.upstream\r\n  }\r", "name": "getRepo", "func_location": "GitRepository.getCachedUpstreamAheadBehindCount", "args": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 268, "func_start_line": 267}}, {"func_info": {"comment": [], "name": "createVersionAndOptionsDigest", "params": ["version", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/babel.js", "end_line": 73, "start_line": 64}, "call_info": {"func_end_line": 42, "code": "exports.getCachePath = function (sourceCode) {\r\n  if (babelVersionDirectory == null) {\r\n    var babelVersion = require('babel-core/package.json').version\r\n    babelVersionDirectory = path.join('js', 'babel', createVersionAndOptionsDigest(babelVersion, defaultOptions))\r\n  }\r\n\r\n  return path.join(\r\n    babelVersionDirectory,\r\n    crypto\r\n      .createHash('sha1')\r\n      .update(sourceCode, 'utf8')\r\n      .digest('hex') + '.js'\r\n  )\r\n}\r", "name": "createVersionAndOptionsDigest", "func_location": "exports.getCachePath", "args": [{"type": "string"}, {"type": "string"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/babel.js", "line": 32, "func_start_line": 29}}, {"func_info": {"comment": [], "name": "PackageTranspilationRegistry.getTranspilerPath", "params": ["spec"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js", "end_line": 166, "start_line": 160}, "call_info": {"func_end_line": 131, "code": "  getCachePath (sourceCode, filePath, spec) {\r\n    const transpilerPath = this.getTranspilerPath(spec)\r\n    const transpilerSource = spec._transpilerSource || fs.readFileSync(transpilerPath, 'utf8')\r\n    spec._transpilerSource = transpilerSource\r\n    const transpiler = this.getTranspiler(spec)\r\n\r\n    let hash = crypto\r\n      .createHash('sha1')\r\n      .update(JSON.stringify(spec.options || {}))\r\n      .update(transpilerSource, 'utf8')\r\n      .update(sourceCode, 'utf8')\r\n\r\n    if (transpiler && transpiler.getCacheKeyData) {\r\n      const meta = this.getMetadata(spec)\r\n      const additionalCacheData = transpiler.getCacheKeyData(sourceCode, filePath, spec.options || {}, meta)\r\n      hash.update(additionalCacheData, 'utf8')\r\n    }\r\n\r\n    return path.join('package-transpile', spec._config.name, hash.digest('hex'))\r\n  }\r", "name": "getTranspilerPath", "func_location": "PackageTranspilationRegistry.getCachePath", "args": ["spec"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js", "line": 113, "func_start_line": 112}}, {"func_info": {"comment": [], "name": "PackageTranspilationRegistry.getTranspiler", "params": ["spec"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js", "end_line": 175, "start_line": 168}, "call_info": {"func_end_line": 131, "code": "  getCachePath (sourceCode, filePath, spec) {\r\n    const transpilerPath = this.getTranspilerPath(spec)\r\n    const transpilerSource = spec._transpilerSource || fs.readFileSync(transpilerPath, 'utf8')\r\n    spec._transpilerSource = transpilerSource\r\n    const transpiler = this.getTranspiler(spec)\r\n\r\n    let hash = crypto\r\n      .createHash('sha1')\r\n      .update(JSON.stringify(spec.options || {}))\r\n      .update(transpilerSource, 'utf8')\r\n      .update(sourceCode, 'utf8')\r\n\r\n    if (transpiler && transpiler.getCacheKeyData) {\r\n      const meta = this.getMetadata(spec)\r\n      const additionalCacheData = transpiler.getCacheKeyData(sourceCode, filePath, spec.options || {}, meta)\r\n      hash.update(additionalCacheData, 'utf8')\r\n    }\r\n\r\n    return path.join('package-transpile', spec._config.name, hash.digest('hex'))\r\n  }\r", "name": "getTranspiler", "func_location": "PackageTranspilationRegistry.getCachePath", "args": ["spec"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js", "line": 116, "func_start_line": 112}}, {"func_info": {"comment": [], "name": "PackageTranspilationRegistry.getMetadata", "params": ["spec"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js", "end_line": 158, "start_line": 152}, "call_info": {"func_end_line": 131, "code": "  getCachePath (sourceCode, filePath, spec) {\r\n    const transpilerPath = this.getTranspilerPath(spec)\r\n    const transpilerSource = spec._transpilerSource || fs.readFileSync(transpilerPath, 'utf8')\r\n    spec._transpilerSource = transpilerSource\r\n    const transpiler = this.getTranspiler(spec)\r\n\r\n    let hash = crypto\r\n      .createHash('sha1')\r\n      .update(JSON.stringify(spec.options || {}))\r\n      .update(transpilerSource, 'utf8')\r\n      .update(sourceCode, 'utf8')\r\n\r\n    if (transpiler && transpiler.getCacheKeyData) {\r\n      const meta = this.getMetadata(spec)\r\n      const additionalCacheData = transpiler.getCacheKeyData(sourceCode, filePath, spec.options || {}, meta)\r\n      hash.update(additionalCacheData, 'utf8')\r\n    }\r\n\r\n    return path.join('package-transpile', spec._config.name, hash.digest('hex'))\r\n  }\r", "name": "getMetadata", "func_location": "PackageTranspilationRegistry.getCachePath", "args": ["spec"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js", "line": 125, "func_start_line": 112}}, {"func_info": {"comment": [], "name": "createVersionAndOptionsDigest", "params": ["version", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/typescript.js", "end_line": 57, "start_line": 48}, "call_info": {"func_end_line": 33, "code": "exports.getCachePath = function (sourceCode) {\r\n  if (typescriptVersionDir == null) {\r\n    var version = require('typescript-simple/package.json').version\r\n    typescriptVersionDir = path.join('ts', createVersionAndOptionsDigest(version, defaultOptions))\r\n  }\r\n\r\n  return path.join(\r\n    typescriptVersionDir,\r\n    crypto\r\n      .createHash('sha1')\r\n      .update(sourceCode, 'utf8')\r\n      .digest('hex') + '.js'\r\n  )\r\n}\r", "name": "createVersionAndOptionsDigest", "func_location": "exports.getCachePath", "args": [{"type": "string"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/typescript.js", "line": 23, "func_start_line": 20}}, {"func_info": {"comment": [], "name": "last", "params": ["array"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1208, "start_line": 1206}, "call_info": {"func_end_line": 839, "code": "  getCloseScopeIds () {\r\n    return last(this.iterators).getCloseScopeIds()\r\n  }\r", "name": "last", "func_location": "HighlightIterator.getCloseScopeIds", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 838, "func_start_line": 837}}, {"func_info": {"comment": [], "name": "TextEditorElement.updateModelFromAttributes", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 96, "start_line": 89}, "call_info": {"func_end_line": 288, "code": "  getComponent () {\r\n    if (!this.component) {\r\n      this.component = new TextEditorComponent({\r\n        element: this,\r\n        mini: this.hasAttribute('mini'),\r\n        updatedSynchronously: this.updatedSynchronously,\r\n        readOnly: this.hasAttribute('readonly')\r\n      })\r\n      this.updateModelFromAttributes()\r\n    }\r\n\r\n    return this.component\r\n  }\r", "name": "updateModelFromAttributes", "func_location": "TextEditorElement.getComponent", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 284, "func_start_line": 276}}, {"func_info": {"comment": [" Returns the corresponding {Repository}"], "name": "GitRepository.getRepo", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 530, "start_line": 524}, "call_info": {"func_end_line": 278, "comment": [" Public: Returns the git configuration value specified by the key.", "", " * `key`  The {String} key for the configuration to lookup.", " * `path` An optional {String} path in the repository to get this information", "   for, only needed if the repository has submodules."], "code": "  getConfigValue (key, path) {\r\n    return this.getRepo(path).getConfigValue(key)\r\n  }\r", "name": "getRepo", "func_location": "GitRepository.getConfigValue", "args": ["key"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 277, "func_start_line": 276}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelPositionAfterBlocksForRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2366, "start_line": 2364}, "call_info": {"func_end_line": 2686, "code": "  getContentHeight () {\r\n    return this.pixelPositionAfterBlocksForRow(this.props.model.getApproximateScreenLineCount())\r\n  }\r", "name": "pixelPositionAfterBlocksForRow", "func_location": "TextEditorComponent.getContentHeight", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2685, "func_start_line": 2684}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getLongestLineWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2610, "start_line": 2608}, "call_info": {"func_end_line": 2690, "code": "  getContentWidth () {\r\n    return Math.ceil(this.getLongestLineWidth() + this.getBaseCharacterWidth())\r\n  }\r", "name": "getLongestLineWidth", "func_location": "TextEditorComponent.getContentWidth", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2689, "func_start_line": 2688}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getBaseCharacterWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2606, "start_line": 2604}, "call_info": {"func_end_line": 2690, "code": "  getContentWidth () {\r\n    return Math.ceil(this.getLongestLineWidth() + this.getBaseCharacterWidth())\r\n  }\r", "name": "getBaseCharacterWidth", "func_location": "TextEditorComponent.getContentWidth", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2689, "func_start_line": 2688}}, {"func_info": {"comment": [" Public: Retrieves the cursor's current buffer row."], "name": "Cursor.getBufferRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 108, "start_line": 106}, "call_info": {"func_end_line": 119, "comment": [" Public: Returns the cursor's current buffer row of text excluding its line", " ending."], "code": "  getCurrentBufferLine () {\r\n    return this.editor.lineTextForBufferRow(this.getBufferRow())\r\n  }\r", "name": "getBufferRow", "func_location": "Cursor.getCurrentBufferLine", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 118, "func_start_line": 117}}, {"func_info": {"comment": [" Public: Retrieves the cursor's current buffer row."], "name": "Cursor.getBufferRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 108, "start_line": 106}, "call_info": {"func_end_line": 625, "comment": [" Public: Returns the buffer Range for the current line.", "", " * `options` (optional) {Object}", "   * `includeNewline` A {Boolean} which controls whether the Range should", "     include the newline."], "code": "  getCurrentLineBufferRange (options) {\r\n    return this.editor.bufferRangeForBufferRow(this.getBufferRow(), options)\r\n  }\r", "name": "getBufferRow", "func_location": "Cursor.getCurrentLineBufferRange", "args": [null, "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 624, "func_start_line": 623}}, {"func_info": {"comment": [" Public: Retrieves the cursor's current buffer row."], "name": "Cursor.getBufferRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 108, "start_line": 106}, "call_info": {"func_end_line": 634, "comment": [" Public: Retrieves the range for the current paragraph.", "", " A paragraph is defined as a block of text surrounded by empty lines or comments.", "", " Returns a {Range}."], "code": "  getCurrentParagraphBufferRange () {\r\n    return this.editor.rowRangeForParagraphAtBufferRow(this.getBufferRow())\r\n  }\r", "name": "getBufferRow", "func_location": "Cursor.getCurrentParagraphBufferRange", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 633, "func_start_line": 632}}, {"func_info": {"comment": [" Public: Returns the current buffer position as an Array."], "name": "Cursor.getBufferPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 93, "start_line": 91}, "call_info": {"func_end_line": 616, "comment": [" Public: Returns the buffer Range occupied by the word located under the cursor.", "", " * `options` (optional) {Object}", "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"", "     (default: {::wordRegExp})."], "code": "  getCurrentWordBufferRange (options = {}) {\r\n    const position = this.getBufferPosition()\r\n    const ranges = this.editor.buffer.findAllInRangeSync(\r\n      options.wordRegex || this.wordRegExp(options),\r\n      new Range(new Point(position.row, 0), new Point(position.row, Infinity))\r\n    )\r\n    const range = ranges.find(range =>\r\n      range.end.column >= position.column && range.start.column <= position.column\r\n    )\r\n    return range ? Range.fromObject(range) : new Range(position, position)\r\n  }\r", "name": "getBufferPosition", "func_location": "Cursor.getCurrentWordBufferRange", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 607, "func_start_line": 606}}, {"func_info": {"comment": [" Public: Get the RegExp used by the cursor to determine what a \"word\" is.", "", " * `options` (optional) {Object} with the following keys:", "   * `includeNonWordCharacters` A {Boolean} indicating whether to include", "     non-word characters in the regex. (default: true)", "", " Returns a {RegExp}."], "name": "Cursor.wordRegExp", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 681, "start_line": 674}, "call_info": {"func_end_line": 616, "comment": [" Public: Returns the buffer Range occupied by the word located under the cursor.", "", " * `options` (optional) {Object}", "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"", "     (default: {::wordRegExp})."], "code": "  getCurrentWordBufferRange (options = {}) {\r\n    const position = this.getBufferPosition()\r\n    const ranges = this.editor.buffer.findAllInRangeSync(\r\n      options.wordRegex || this.wordRegExp(options),\r\n      new Range(new Point(position.row, 0), new Point(position.row, Infinity))\r\n    )\r\n    const range = ranges.find(range =>\r\n      range.end.column >= position.column && range.start.column <= position.column\r\n    )\r\n    return range ? Range.fromObject(range) : new Range(position, position)\r\n  }\r", "name": "wordRegExp", "func_location": "Cursor.getCurrentWordBufferRange", "args": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 609, "func_start_line": 606}}, {"func_info": {"comment": [" Public: Retrieves the buffer position of where the current word starts.", "", " * `options` (optional) An {Object} with the following keys:", "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"", "     (default: {::wordRegExp}).", "   * `includeNonWordCharacters` A {Boolean} indicating whether to include", "     non-word characters in the default word regex.", "     Has no effect if wordRegex is set.", "   * `allowPrevious` A {Boolean} indicating whether the beginning of the", "     previous word can be returned.", "", " Returns a {Range}."], "name": "Cursor.getBeginningOfCurrentWordBufferPosition", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 547, "start_line": 527}, "call_info": {"func_end_line": 639, "comment": [" Public: Returns the characters preceding the cursor in the current word."], "code": "  getCurrentWordPrefix () {\r\n    return this.editor.getTextInBufferRange([this.getBeginningOfCurrentWordBufferPosition(), this.getBufferPosition()])\r\n  }\r", "name": "getBeginningOfCurrentWordBufferPosition", "func_location": "Cursor.getCurrentWordPrefix", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 638, "func_start_line": 637}}, {"func_info": {"comment": [" Public: Returns the current buffer position as an Array."], "name": "Cursor.getBufferPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 93, "start_line": 91}, "call_info": {"func_end_line": 639, "comment": [" Public: Returns the characters preceding the cursor in the current word."], "code": "  getCurrentWordPrefix () {\r\n    return this.editor.getTextInBufferRange([this.getBeginningOfCurrentWordBufferPosition(), this.getBufferPosition()])\r\n  }\r", "name": "getBufferPosition", "func_location": "Cursor.getCurrentWordPrefix", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 638, "func_start_line": 637}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 139, "comment": [" Deprecated: get the width of an `x` character displayed in this element.", "", " Returns a {Number} of pixels."], "code": "  getDefaultCharacterWidth () {\r\n    return this.getComponent().getBaseCharacterWidth()\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.getDefaultCharacterWidth", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 138, "func_start_line": 137}}, {"func_info": {"comment": [" Public: Get the load settings for the current window.", "", " Returns an {Object} containing all the load setting key/value pairs."], "name": "AtomEnvironment.getLoadSettings", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 527, "start_line": 525}, "call_info": {"func_end_line": 745, "code": "  getDefaultWindowDimensions () {\r\n    const {windowDimensions} = this.getLoadSettings()\r\n    if (windowDimensions) return windowDimensions\r\n\r\n    let dimensions\r\n    try {\r\n      dimensions = JSON.parse(localStorage.getItem('defaultWindowDimensions'))\r\n    } catch (error) {\r\n      console.warn('Error parsing default window dimensions', error)\r\n      localStorage.removeItem('defaultWindowDimensions')\r\n    }\r\n\r\n    if (dimensions && this.isValidDimensions(dimensions)) {\r\n      return dimensions\r\n    } else {\r\n      const {width, height} = this.applicationDelegate.getPrimaryDisplayWorkAreaSize()\r\n      return {x: 0, y: 0, width: Math.min(1024, width), height}\r\n    }\r\n  }\r", "name": "getLoadSettings", "func_location": "AtomEnvironment.getDefaultWindowDimensions", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 728, "func_start_line": 727}}, {"func_info": {"comment": [" Returns true if the dimensions are useable, false if they should be ignored.", " Work around for https://github.com/atom/atom-shell/issues/473"], "name": "AtomEnvironment.isValidDimensions", "params": [["x", "y", "width", "height"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 718, "start_line": 716}, "call_info": {"func_end_line": 745, "code": "  getDefaultWindowDimensions () {\r\n    const {windowDimensions} = this.getLoadSettings()\r\n    if (windowDimensions) return windowDimensions\r\n\r\n    let dimensions\r\n    try {\r\n      dimensions = JSON.parse(localStorage.getItem('defaultWindowDimensions'))\r\n    } catch (error) {\r\n      console.warn('Error parsing default window dimensions', error)\r\n      localStorage.removeItem('defaultWindowDimensions')\r\n    }\r\n\r\n    if (dimensions && this.isValidDimensions(dimensions)) {\r\n      return dimensions\r\n    } else {\r\n      const {width, height} = this.applicationDelegate.getPrimaryDisplayWorkAreaSize()\r\n      return {x: 0, y: 0, width: Math.min(1024, width), height}\r\n    }\r\n  }\r", "name": "isValidDimensions", "func_location": "AtomEnvironment.getDefaultWindowDimensions", "args": ["dimensions"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 739, "func_start_line": 727}}, {"func_info": {"comment": [], "name": "Tooltip", "params": ["element", "options", "viewRegistry"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip.js", "end_line": 22, "start_line": 12}, "call_info": {"func_end_line": 513, "code": "Tooltip.prototype.getDelegateComponent = function (element) {\r\n  var component = tooltipComponentsByElement.get(element)\r\n  if (!component) {\r\n    component = new Tooltip(element, this.getDelegateOptions(), this.viewRegistry)\r\n    tooltipComponentsByElement.set(element, component)\r\n  }\r\n  return component\r\n}\r", "name": "Tooltip", "func_location": "Tooltip.prototype.getDelegateComponent", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip.js", "line": 509, "func_start_line": 506}}, {"func_info": {"comment": [" Returns the corresponding {Repository}"], "name": "GitRepository.getRepo", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 530, "start_line": 524}, "call_info": {"func_end_line": 434, "comment": ["\r\n  Section: Retrieving Diffs\r\n  ", " Public: Retrieves the number of lines added and removed to a path.", "", " This compares the working directory contents of the path to the `HEAD`", " version.", "", " * `path` The {String} path to check.", "", " Returns an {Object} with the following keys:", "   * `added` The {Number} of added lines.", "   * `deleted` The {Number} of deleted lines."], "code": "  getDiffStats (path) {\r\n    const repo = this.getRepo(path)\r\n    return repo.getDiffStats(repo.relativize(path))\r\n  }\r", "name": "getRepo", "func_location": "GitRepository.getDiffStats", "args": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 432, "func_start_line": 431}}, {"func_info": {"comment": [" Public: Returns the currently focused {AtomWindow} or undefined if none."], "name": "AtomApplication.focusedWindow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 750, "start_line": 748}, "call_info": {"func_end_line": 773, "comment": [" Get the dimensions for opening a new window by cascading as appropriate to", " the platform."], "code": "  getDimensionsForNewWindow () {\r\n    const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n    if (!window || window.isMaximized()) return\r\n    const dimensions = window.getDimensions()\r\n    if (dimensions) {\r\n      const offset = this.getWindowOffsetForCurrentPlatform()\r\n      dimensions.x += offset\r\n      dimensions.y += offset\r\n      return dimensions\r\n    }\r\n  }\r", "name": "focusedWindow", "func_location": "AtomApplication.getDimensionsForNewWindow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 764, "func_start_line": 763}}, {"func_info": {"comment": [], "name": "AtomApplication.getLastFocusedWindow", "params": ["predicate"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 327, "start_line": 325}, "call_info": {"func_end_line": 773, "comment": [" Get the dimensions for opening a new window by cascading as appropriate to", " the platform."], "code": "  getDimensionsForNewWindow () {\r\n    const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n    if (!window || window.isMaximized()) return\r\n    const dimensions = window.getDimensions()\r\n    if (dimensions) {\r\n      const offset = this.getWindowOffsetForCurrentPlatform()\r\n      dimensions.x += offset\r\n      dimensions.y += offset\r\n      return dimensions\r\n    }\r\n  }\r", "name": "getLastFocusedWindow", "func_location": "AtomApplication.getDimensionsForNewWindow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 764, "func_start_line": 763}}, {"func_info": {"comment": [" Get the platform-specific window offset for new windows."], "name": "AtomApplication.getWindowOffsetForCurrentPlatform", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 759, "start_line": 753}, "call_info": {"func_end_line": 773, "comment": [" Get the dimensions for opening a new window by cascading as appropriate to", " the platform."], "code": "  getDimensionsForNewWindow () {\r\n    const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n    if (!window || window.isMaximized()) return\r\n    const dimensions = window.getDimensions()\r\n    if (dimensions) {\r\n      const offset = this.getWindowOffsetForCurrentPlatform()\r\n      dimensions.x += offset\r\n      dimensions.y += offset\r\n      return dimensions\r\n    }\r\n  }\r", "name": "getWindowOffsetForCurrentPlatform", "func_location": "AtomApplication.getDimensionsForNewWindow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 768, "func_start_line": 763}}, {"func_info": {"comment": [" Essential: Returns the {String} path of this editor's text buffer."], "name": "TextEditor.getPath", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 1138, "start_line": 1136}, "call_info": {"func_end_line": 1148, "code": "  getDirectoryPath () {\r\n    const fullPath = this.getPath()\r\n    if (fullPath) return path.dirname(fullPath)\r\n  }\r", "name": "getPath", "func_location": "TextEditor.getDirectoryPath", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 1146, "func_start_line": 1145}}, {"func_info": {"comment": [" Public: Makes a path relative to the repository's working directory."], "name": "GitRepository.relativize", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 210, "start_line": 208}, "call_info": {"func_end_line": 366, "comment": [" Public: Get the status of a directory in the repository's working directory.", "", " * `path` The {String} path to check.", "", " Returns a {Number} representing the status. This value can be passed to", " {::isStatusModified} or {::isStatusNew} to get more information."], "code": "  getDirectoryStatus (directoryPath) {\r\n    directoryPath = `${this.relativize(directoryPath)}/`\r\n    let directoryStatus = 0\r\n    for (let statusPath in this.statuses) {\r\n      const status = this.statuses[statusPath]\r\n      if (statusPath.startsWith(directoryPath)) directoryStatus |= status\r\n    }\r\n    return directoryStatus\r\n  }\r", "name": "relativize", "func_location": "GitRepository.getDirectoryStatus", "args": ["directoryPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 359, "func_start_line": 358}}, {"func_info": {"comment": [" Public: Returns the current buffer position as an Array."], "name": "Cursor.getBufferPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 93, "start_line": 91}, "call_info": {"func_end_line": 578, "comment": [" Public: Retrieves the buffer position of where the current word ends.", "", " * `options` (optional) {Object} with the following keys:", "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"", "      (default: {::wordRegExp})", "   * `includeNonWordCharacters` A Boolean indicating whether to include", "     non-word characters in the default word regex. Has no effect if", "     wordRegex is set.", "", " Returns a {Range}."], "code": "  getEndOfCurrentWordBufferPosition (options = {}) {\r\n    const allowNext = options.allowNext !== false\r\n    const position = this.getBufferPosition()\r\n\r\n    const scanRange = allowNext\r\n      ? new Range(position, new Point(position.row + 2, 0))\r\n      : new Range(position, new Point(position.row, Infinity))\r\n\r\n    const ranges = this.editor.buffer.findAllInRangeSync(\r\n      options.wordRegex || this.wordRegExp(options),\r\n      scanRange\r\n    )\r\n\r\n    for (let range of ranges) {\r\n      if (position.isLessThan(range.start) && !allowNext) break\r\n      if (position.isLessThan(range.end)) return Point.fromObject(range.end)\r\n    }\r\n\r\n    return allowNext ? this.editor.getEofBufferPosition() : position\r\n  }\r", "name": "getBufferPosition", "func_location": "Cursor.getEndOfCurrentWordBufferPosition", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 561, "func_start_line": 559}}, {"func_info": {"comment": [" Public: Get the RegExp used by the cursor to determine what a \"word\" is.", "", " * `options` (optional) {Object} with the following keys:", "   * `includeNonWordCharacters` A {Boolean} indicating whether to include", "     non-word characters in the regex. (default: true)", "", " Returns a {RegExp}."], "name": "Cursor.wordRegExp", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 681, "start_line": 674}, "call_info": {"func_end_line": 578, "comment": [" Public: Retrieves the buffer position of where the current word ends.", "", " * `options` (optional) {Object} with the following keys:", "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"", "      (default: {::wordRegExp})", "   * `includeNonWordCharacters` A Boolean indicating whether to include", "     non-word characters in the default word regex. Has no effect if", "     wordRegex is set.", "", " Returns a {Range}."], "code": "  getEndOfCurrentWordBufferPosition (options = {}) {\r\n    const allowNext = options.allowNext !== false\r\n    const position = this.getBufferPosition()\r\n\r\n    const scanRange = allowNext\r\n      ? new Range(position, new Point(position.row + 2, 0))\r\n      : new Range(position, new Point(position.row, Infinity))\r\n\r\n    const ranges = this.editor.buffer.findAllInRangeSync(\r\n      options.wordRegex || this.wordRegExp(options),\r\n      scanRange\r\n    )\r\n\r\n    for (let range of ranges) {\r\n      if (position.isLessThan(range.start) && !allowNext) break\r\n      if (position.isLessThan(range.end)) return Point.fromObject(range.end)\r\n    }\r\n\r\n    return allowNext ? this.editor.getEofBufferPosition() : position\r\n  }\r", "name": "wordRegExp", "func_location": "Cursor.getEndOfCurrentWordBufferPosition", "args": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 568, "func_start_line": 559}}, {"func_info": {"comment": [" Essential: Returns the {String} path of this editor's text buffer."], "name": "TextEditor.getPath", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 1138, "start_line": 1136}, "call_info": {"func_end_line": 1143, "code": "  getFileName () {\r\n    const fullPath = this.getPath()\r\n    if (fullPath) return path.basename(fullPath)\r\n  }\r", "name": "getPath", "func_location": "TextEditor.getFileName", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 1141, "func_start_line": 1140}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollLeft", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2825, "start_line": 2823}, "call_info": {"func_end_line": 2789, "code": "  getFirstVisibleColumn () {\r\n    return Math.floor(this.getScrollLeft() / this.getBaseCharacterWidth())\r\n  }\r", "name": "getScrollLeft", "func_location": "TextEditorComponent.getFirstVisibleColumn", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2788, "func_start_line": 2787}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getBaseCharacterWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2606, "start_line": 2604}, "call_info": {"func_end_line": 2789, "code": "  getFirstVisibleColumn () {\r\n    return Math.floor(this.getScrollLeft() / this.getBaseCharacterWidth())\r\n  }\r", "name": "getBaseCharacterWidth", "func_location": "TextEditorComponent.getFirstVisibleColumn", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2788, "func_start_line": 2787}}, {"func_info": {"comment": [], "name": "TextEditorComponent.rowForPixelPosition", "params": ["pixelPosition"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2348, "start_line": 2346}, "call_info": {"func_end_line": 2761, "code": "  getFirstVisibleRow () {\r\n    if (this.derivedDimensionsCache.firstVisibleRow == null) {\r\n      this.derivedDimensionsCache.firstVisibleRow = this.rowForPixelPosition(this.getScrollTop())\r\n    }\r\n\r\n    return this.derivedDimensionsCache.firstVisibleRow\r\n  }\r", "name": "rowForPixelPosition", "func_location": "TextEditorComponent.getFirstVisibleRow", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2757, "func_start_line": 2755}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollTop", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2794, "start_line": 2791}, "call_info": {"func_end_line": 2761, "code": "  getFirstVisibleRow () {\r\n    if (this.derivedDimensionsCache.firstVisibleRow == null) {\r\n      this.derivedDimensionsCache.firstVisibleRow = this.rowForPixelPosition(this.getScrollTop())\r\n    }\r\n\r\n    return this.derivedDimensionsCache.firstVisibleRow\r\n  }\r", "name": "getScrollTop", "func_location": "TextEditorComponent.getFirstVisibleRow", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2757, "func_start_line": 2755}}, {"func_info": {"comment": [], "name": "TextEditorElement.getModel", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 82, "start_line": 80}, "call_info": {"func_end_line": 344, "code": "  getFirstVisibleScreenColumn () {\r\n    return this.getModel().getFirstVisibleScreenColumn()\r\n  }\r", "name": "getModel", "func_location": "TextEditorElement.getFirstVisibleScreenColumn", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 343, "func_start_line": 342}}, {"func_info": {"comment": [], "name": "TextEditorElement.getModel", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 82, "start_line": 80}, "call_info": {"func_end_line": 316, "code": "  getFirstVisibleScreenRow () {\r\n    return this.getModel().getFirstVisibleScreenRow()\r\n  }\r", "name": "getModel", "func_location": "TextEditorElement.getFirstVisibleScreenRow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 315, "func_start_line": 314}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.endRowForFoldAtRow", "params": ["row", "tabLength", "existenceOnly"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 659, "start_line": 653}, "call_info": {"func_end_line": 619, "code": "  getFoldableRangeContainingPoint (point, tabLength) {\r\n    if (point.column >= this.buffer.lineLengthForRow(point.row)) {\r\n      const endRow = this.endRowForFoldAtRow(point.row, tabLength)\r\n      if (endRow != null) {\r\n        return Range(Point(point.row, Infinity), Point(endRow, Infinity))\r\n      }\r\n    }\r\n\r\n    for (let row = point.row - 1; row >= 0; row--) {\r\n      const endRow = this.endRowForFoldAtRow(row, tabLength)\r\n      if (endRow != null && endRow >= point.row) {\r\n        return Range(Point(row, Infinity), Point(endRow, Infinity))\r\n      }\r\n    }\r\n    return null\r\n  }\r", "name": "endRowForFoldAtRow", "func_location": "TextMateLanguageMode.getFoldableRangeContainingPoint", "args": ["point.row", "tabLength"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 606, "func_start_line": 604}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.endRowForFoldAtRow", "params": ["row", "tabLength", "existenceOnly"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 659, "start_line": 653}, "call_info": {"func_end_line": 619, "code": "  getFoldableRangeContainingPoint (point, tabLength) {\r\n    if (point.column >= this.buffer.lineLengthForRow(point.row)) {\r\n      const endRow = this.endRowForFoldAtRow(point.row, tabLength)\r\n      if (endRow != null) {\r\n        return Range(Point(point.row, Infinity), Point(endRow, Infinity))\r\n      }\r\n    }\r\n\r\n    for (let row = point.row - 1; row >= 0; row--) {\r\n      const endRow = this.endRowForFoldAtRow(row, tabLength)\r\n      if (endRow != null && endRow >= point.row) {\r\n        return Range(Point(row, Infinity), Point(endRow, Infinity))\r\n      }\r\n    }\r\n    return null\r\n  }\r", "name": "endRowForFoldAtRow", "func_location": "TextMateLanguageMode.getFoldableRangeContainingPoint", "args": ["row", "tabLength"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 613, "func_start_line": 604}}, {"func_info": {"comment": [], "name": "TreeSitterLanguageMode._forEachTreeWithRange", "params": ["range", "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 316, "start_line": 303}, "call_info": {"func_end_line": 301, "name": "_forEachTreeWithRange", "func_location": "TreeSitterLanguageMode.getFoldableRangeContainingPoint", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 283, "func_start_line": 279}}, {"func_info": {"comment": [], "name": "hasMatchingFoldSpec", "params": ["specs", "node"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1212, "start_line": 1210}, "call_info": {"func_end_line": 377, "code": "  getFoldableRangeForNode (node, grammar, existenceOnly) {\r\n    const {children} = node\r\n    const childCount = children.length\r\n\r\n    for (var i = 0, {length} = grammar.folds; i < length; i++) {\r\n      const foldSpec = grammar.folds[i]\r\n\r\n      if (foldSpec.matchers && !hasMatchingFoldSpec(foldSpec.matchers, node)) continue\r\n\r\n      let foldStart\r\n      const startEntry = foldSpec.start\r\n      if (startEntry) {\r\n        let foldStartNode\r\n        if (startEntry.index != null) {\r\n          foldStartNode = children[startEntry.index]\r\n          if (!foldStartNode || startEntry.matchers && !hasMatchingFoldSpec(startEntry.matchers, foldStartNode)) continue\r\n        } else {\r\n          foldStartNode = children.find(child => hasMatchingFoldSpec(startEntry.matchers, child))\r\n          if (!foldStartNode) continue\r\n        }\r\n        foldStart = new Point(foldStartNode.endPosition.row, Infinity)\r\n      } else {\r\n        foldStart = new Point(node.startPosition.row, Infinity)\r\n      }\r\n\r\n      let foldEnd\r\n      const endEntry = foldSpec.end\r\n      if (endEntry) {\r\n        let foldEndNode\r\n        if (endEntry.index != null) {\r\n          const index = endEntry.index < 0 ? childCount + endEntry.index : endEntry.index\r\n          foldEndNode = children[index]\r\n          if (!foldEndNode || (endEntry.type && endEntry.type !== foldEndNode.type)) continue\r\n        } else {\r\n          foldEndNode = children.find(child => hasMatchingFoldSpec(endEntry.matchers, child))\r\n          if (!foldEndNode) continue\r\n        }\r\n\r\n        if (foldEndNode.startPosition.row <= foldStart.row) continue\r\n\r\n        foldEnd = foldEndNode.startPosition\r\n        if (this.buffer.findInRangeSync(\r\n          WORD_REGEX, new Range(foldEnd, new Point(foldEnd.row, Infinity))\r\n        )) {\r\n          foldEnd = new Point(foldEnd.row - 1, Infinity)\r\n        }\r\n      } else {\r\n        const {endPosition} = node\r\n        if (endPosition.column === 0) {\r\n          foldEnd = Point(endPosition.row - 1, Infinity)\r\n        } else if (childCount > 0) {\r\n          foldEnd = endPosition\r\n        } else {\r\n          foldEnd = Point(endPosition.row, 0)\r\n        }\r\n      }\r\n\r\n      return existenceOnly ? true : new Range(foldStart, foldEnd)\r\n    }\r\n  }\r", "name": "hasMatchingFoldSpec", "func_location": "TreeSitterLanguageMode.getFoldableRangeForNode", "args": ["foldSpec.matchers", "node"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 325, "func_start_line": 318}}, {"func_info": {"comment": [], "name": "hasMatchingFoldSpec", "params": ["specs", "node"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1212, "start_line": 1210}, "call_info": {"func_end_line": 377, "code": "  getFoldableRangeForNode (node, grammar, existenceOnly) {\r\n    const {children} = node\r\n    const childCount = children.length\r\n\r\n    for (var i = 0, {length} = grammar.folds; i < length; i++) {\r\n      const foldSpec = grammar.folds[i]\r\n\r\n      if (foldSpec.matchers && !hasMatchingFoldSpec(foldSpec.matchers, node)) continue\r\n\r\n      let foldStart\r\n      const startEntry = foldSpec.start\r\n      if (startEntry) {\r\n        let foldStartNode\r\n        if (startEntry.index != null) {\r\n          foldStartNode = children[startEntry.index]\r\n          if (!foldStartNode || startEntry.matchers && !hasMatchingFoldSpec(startEntry.matchers, foldStartNode)) continue\r\n        } else {\r\n          foldStartNode = children.find(child => hasMatchingFoldSpec(startEntry.matchers, child))\r\n          if (!foldStartNode) continue\r\n        }\r\n        foldStart = new Point(foldStartNode.endPosition.row, Infinity)\r\n      } else {\r\n        foldStart = new Point(node.startPosition.row, Infinity)\r\n      }\r\n\r\n      let foldEnd\r\n      const endEntry = foldSpec.end\r\n      if (endEntry) {\r\n        let foldEndNode\r\n        if (endEntry.index != null) {\r\n          const index = endEntry.index < 0 ? childCount + endEntry.index : endEntry.index\r\n          foldEndNode = children[index]\r\n          if (!foldEndNode || (endEntry.type && endEntry.type !== foldEndNode.type)) continue\r\n        } else {\r\n          foldEndNode = children.find(child => hasMatchingFoldSpec(endEntry.matchers, child))\r\n          if (!foldEndNode) continue\r\n        }\r\n\r\n        if (foldEndNode.startPosition.row <= foldStart.row) continue\r\n\r\n        foldEnd = foldEndNode.startPosition\r\n        if (this.buffer.findInRangeSync(\r\n          WORD_REGEX, new Range(foldEnd, new Point(foldEnd.row, Infinity))\r\n        )) {\r\n          foldEnd = new Point(foldEnd.row - 1, Infinity)\r\n        }\r\n      } else {\r\n        const {endPosition} = node\r\n        if (endPosition.column === 0) {\r\n          foldEnd = Point(endPosition.row - 1, Infinity)\r\n        } else if (childCount > 0) {\r\n          foldEnd = endPosition\r\n        } else {\r\n          foldEnd = Point(endPosition.row, 0)\r\n        }\r\n      }\r\n\r\n      return existenceOnly ? true : new Range(foldStart, foldEnd)\r\n    }\r\n  }\r", "name": "hasMatchingFoldSpec", "func_location": "TreeSitterLanguageMode.getFoldableRangeForNode", "args": ["startEntry.matchers", "foldStartNode"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 333, "func_start_line": 318}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.endRowForFoldAtRow", "params": ["row", "tabLength", "existenceOnly"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 659, "start_line": 653}, "call_info": {"func_end_line": 651, "code": "  getFoldableRanges (tabLength) {\r\n    const result = []\r\n    let row = 0\r\n    const lineCount = this.buffer.getLineCount()\r\n    while (row < lineCount) {\r\n      const endRow = this.endRowForFoldAtRow(row, tabLength)\r\n      if (endRow != null) {\r\n        result.push(Range(Point(row, Infinity), Point(endRow, Infinity)))\r\n      }\r\n      row++\r\n    }\r\n    return result\r\n  }\r", "name": "endRowForFoldAtRow", "func_location": "TextMateLanguageMode.getFoldableRanges", "args": ["row", "tabLength"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 644, "func_start_line": 639}}, {"func_info": {"comment": ["*\r\n   * TODO: Make this method generate folds for nested languages (currently,\r\n   * folds are only generated for the root language layer).\r\n   "], "name": "TreeSitterLanguageMode.getFoldableRangesAtIndentLevel", "params": ["goalLevel"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 277, "start_line": 234}, "call_info": {"func_end_line": 228, "code": "  getFoldableRanges () {\r\n    return this.getFoldableRangesAtIndentLevel(null)\r\n  }\r", "name": "getFoldableRangesAtIndentLevel", "func_location": "TreeSitterLanguageMode.getFoldableRanges", "args": [{"type": "object"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 227, "func_start_line": 226}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.indentLevelForLine", "params": ["line", "tabLength"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 505, "start_line": 492}, "call_info": {"func_end_line": 637, "code": "  getFoldableRangesAtIndentLevel (indentLevel, tabLength) {\r\n    const result = []\r\n    let row = 0\r\n    const lineCount = this.buffer.getLineCount()\r\n    while (row < lineCount) {\r\n      if (this.indentLevelForLine(this.buffer.lineForRow(row), tabLength) === indentLevel) {\r\n        const endRow = this.endRowForFoldAtRow(row, tabLength)\r\n        if (endRow != null) {\r\n          result.push(Range(Point(row, Infinity), Point(endRow, Infinity)))\r\n          row = endRow + 1\r\n          continue\r\n        }\r\n      }\r\n      row++\r\n    }\r\n    return result\r\n  }\r", "name": "indentLevelForLine", "func_location": "TextMateLanguageMode.getFoldableRangesAtIndentLevel", "args": [null, "tabLength"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 626, "func_start_line": 621}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.endRowForFoldAtRow", "params": ["row", "tabLength", "existenceOnly"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 659, "start_line": 653}, "call_info": {"func_end_line": 637, "code": "  getFoldableRangesAtIndentLevel (indentLevel, tabLength) {\r\n    const result = []\r\n    let row = 0\r\n    const lineCount = this.buffer.getLineCount()\r\n    while (row < lineCount) {\r\n      if (this.indentLevelForLine(this.buffer.lineForRow(row), tabLength) === indentLevel) {\r\n        const endRow = this.endRowForFoldAtRow(row, tabLength)\r\n        if (endRow != null) {\r\n          result.push(Range(Point(row, Infinity), Point(endRow, Infinity)))\r\n          row = endRow + 1\r\n          continue\r\n        }\r\n      }\r\n      row++\r\n    }\r\n    return result\r\n  }\r", "name": "endRowForFoldAtRow", "func_location": "TextMateLanguageMode.getFoldableRangesAtIndentLevel", "args": ["row", "tabLength"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 627, "func_start_line": 621}}, {"func_info": {"comment": [], "name": "TreeSitterLanguageMode.getFoldableRangeForNode", "params": ["node", "grammar", "existenceOnly"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 377, "start_line": 318}, "call_info": {"func_end_line": 277, "comment": ["*\r\n   * TODO: Make this method generate folds for nested languages (currently,\r\n   * folds are only generated for the root language layer).\r\n   "], "code": "  getFoldableRangesAtIndentLevel (goalLevel) {\r\n    let result = []\r\n    let stack = [{node: this.tree.rootNode, level: 0}]\r\n    while (stack.length > 0) {\r\n      const {node, level} = stack.pop()\r\n\r\n      const range = this.getFoldableRangeForNode(node, this.grammar)\r\n      if (range) {\r\n        if (goalLevel == null || level === goalLevel) {\r\n          let updatedExistingRange = false\r\n          for (let i = 0, {length} = result; i < length; i++) {\r\n            if (result[i].start.row === range.start.row &&\r\n                result[i].end.row === range.end.row) {\r\n              result[i] = range\r\n              updatedExistingRange = true\r\n              break\r\n            }\r\n          }\r\n          if (!updatedExistingRange) result.push(range)\r\n        }\r\n      }\r\n\r\n      const parentStartRow = node.startPosition.row\r\n      const parentEndRow = node.endPosition.row\r\n      for (let children = node.namedChildren, i = 0, {length} = children; i < length; i++) {\r\n        const child = children[i]\r\n        const {startPosition: childStart, endPosition: childEnd} = child\r\n        if (childEnd.row > childStart.row) {\r\n          if (childStart.row === parentStartRow && childEnd.row === parentEndRow) {\r\n            stack.push({node: child, level: level})\r\n          } else {\r\n            const childLevel = range && range.containsPoint(childStart) && range.containsPoint(childEnd)\r\n              ? level + 1\r\n              : level\r\n            if (childLevel <= goalLevel || goalLevel == null) {\r\n              stack.push({node: child, level: childLevel})\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return result.sort((a, b) => a.start.row - b.start.row)\r\n  }\r", "name": "getFoldableRangeForNode", "func_location": "TreeSitterLanguageMode.getFoldableRangesAtIndentLevel", "args": ["node", ".grammar"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 240, "func_start_line": 234}}, {"func_info": {"comment": [], "name": "Workspace.getPanels", "params": ["location"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1814, "start_line": 1812}, "call_info": {"func_end_line": 1755, "comment": [" Essential: Get an {Array} of all the panel items in the footer."], "code": "  getFooterPanels () {\r\n    return this.getPanels('footer')\r\n  }\r", "name": "getPanels", "func_location": "Workspace.getFooterPanels", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1754, "func_start_line": 1753}}, {"func_info": {"comment": [], "name": "GrammarRegistry.getGrammarPathScore", "params": ["grammar", "filePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 274, "start_line": 244}, "call_info": {"func_end_line": 242, "comment": [" Extended: Returns a {Number} representing how well the grammar matches the", " `filePath` and `contents`."], "code": "  getGrammarScore (grammar, filePath, contents) {\r\n    if (contents == null && fs.isFileSync(filePath)) {\r\n      contents = fs.readFileSync(filePath, 'utf8')\r\n    }\r\n\r\n    // Initially identify matching grammars based on the filename and the first\r\n    // line of the file.\r\n    let score = this.getGrammarPathScore(grammar, filePath)\r\n    if (this.grammarMatchesPrefix(grammar, contents)) score += 0.5\r\n\r\n    // If multiple grammars match by one of the above criteria, break ties.\r\n    if (score > 0) {\r\n      // Prefer either TextMate or Tree-sitter grammars based on the user's settings.\r\n      if (grammar instanceof TreeSitterGrammar) {\r\n        if (this.shouldUseTreeSitterParser(grammar.scopeName)) {\r\n          score += 0.1\r\n        } else {\r\n          return -Infinity\r\n        }\r\n      }\r\n\r\n      // Prefer grammars with matching content regexes. Prefer a grammar with no content regex\r\n      // over one with a non-matching content regex.\r\n      if (grammar.contentRegex) {\r\n        if (grammar.contentRegex.test(contents)) {\r\n          score += 0.05\r\n        } else {\r\n          score -= 0.05\r\n        }\r\n      }\r\n\r\n      // Prefer grammars that the user has manually installed over bundled grammars.\r\n      if (!grammar.bundledPackage) score += 0.01\r\n    }\r\n\r\n    return score\r\n  }\r", "name": "getGrammarPathScore", "func_location": "GrammarRegistry.getGrammarScore", "args": ["grammar", "filePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 213, "func_start_line": 206}}, {"func_info": {"comment": [], "name": "GrammarRegistry.grammarMatchesPrefix", "params": ["grammar", "contents"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 303, "start_line": 276}, "call_info": {"func_end_line": 242, "comment": [" Extended: Returns a {Number} representing how well the grammar matches the", " `filePath` and `contents`."], "code": "  getGrammarScore (grammar, filePath, contents) {\r\n    if (contents == null && fs.isFileSync(filePath)) {\r\n      contents = fs.readFileSync(filePath, 'utf8')\r\n    }\r\n\r\n    // Initially identify matching grammars based on the filename and the first\r\n    // line of the file.\r\n    let score = this.getGrammarPathScore(grammar, filePath)\r\n    if (this.grammarMatchesPrefix(grammar, contents)) score += 0.5\r\n\r\n    // If multiple grammars match by one of the above criteria, break ties.\r\n    if (score > 0) {\r\n      // Prefer either TextMate or Tree-sitter grammars based on the user's settings.\r\n      if (grammar instanceof TreeSitterGrammar) {\r\n        if (this.shouldUseTreeSitterParser(grammar.scopeName)) {\r\n          score += 0.1\r\n        } else {\r\n          return -Infinity\r\n        }\r\n      }\r\n\r\n      // Prefer grammars with matching content regexes. Prefer a grammar with no content regex\r\n      // over one with a non-matching content regex.\r\n      if (grammar.contentRegex) {\r\n        if (grammar.contentRegex.test(contents)) {\r\n          score += 0.05\r\n        } else {\r\n          score -= 0.05\r\n        }\r\n      }\r\n\r\n      // Prefer grammars that the user has manually installed over bundled grammars.\r\n      if (!grammar.bundledPackage) score += 0.01\r\n    }\r\n\r\n    return score\r\n  }\r", "name": "grammarMatchesPrefix", "func_location": "GrammarRegistry.getGrammarScore", "args": ["grammar", "contents"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 214, "func_start_line": 206}}, {"func_info": {"comment": [], "name": "GrammarRegistry.shouldUseTreeSitterParser", "params": ["languageId"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 584, "start_line": 579}, "call_info": {"func_end_line": 242, "comment": [" Extended: Returns a {Number} representing how well the grammar matches the", " `filePath` and `contents`."], "code": "  getGrammarScore (grammar, filePath, contents) {\r\n    if (contents == null && fs.isFileSync(filePath)) {\r\n      contents = fs.readFileSync(filePath, 'utf8')\r\n    }\r\n\r\n    // Initially identify matching grammars based on the filename and the first\r\n    // line of the file.\r\n    let score = this.getGrammarPathScore(grammar, filePath)\r\n    if (this.grammarMatchesPrefix(grammar, contents)) score += 0.5\r\n\r\n    // If multiple grammars match by one of the above criteria, break ties.\r\n    if (score > 0) {\r\n      // Prefer either TextMate or Tree-sitter grammars based on the user's settings.\r\n      if (grammar instanceof TreeSitterGrammar) {\r\n        if (this.shouldUseTreeSitterParser(grammar.scopeName)) {\r\n          score += 0.1\r\n        } else {\r\n          return -Infinity\r\n        }\r\n      }\r\n\r\n      // Prefer grammars with matching content regexes. Prefer a grammar with no content regex\r\n      // over one with a non-matching content regex.\r\n      if (grammar.contentRegex) {\r\n        if (grammar.contentRegex.test(contents)) {\r\n          score += 0.05\r\n        } else {\r\n          score -= 0.05\r\n        }\r\n      }\r\n\r\n      // Prefer grammars that the user has manually installed over bundled grammars.\r\n      if (!grammar.bundledPackage) score += 0.01\r\n    }\r\n\r\n    return score\r\n  }\r", "name": "shouldUseTreeSitterParser", "func_location": "GrammarRegistry.getGrammarScore", "args": ["grammar.scopeName"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 220, "func_start_line": 206}}, {"func_info": {"comment": [], "name": "Workspace.getPanels", "params": ["location"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1814, "start_line": 1812}, "call_info": {"func_end_line": 1734, "comment": [" Essential: Get an {Array} of all the panel items in the header."], "code": "  getHeaderPanels () {\r\n    return this.getPanels('header')\r\n  }\r", "name": "getPanels", "func_location": "Workspace.getHeaderPanels", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1733, "func_start_line": 1732}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 124, "code": "  getHeight () {\r\n    return this.getComponent().getScrollContainerHeight()\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.getHeight", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 123, "func_start_line": 122}}, {"func_info": {"comment": [], "name": "DecorationManager.getDecorations", "params": ["propertyFilter"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js", "end_line": 56, "start_line": 40}, "call_info": {"func_end_line": 68, "code": "  getHighlightDecorations (propertyFilter) {\r\n    return this.getDecorations(propertyFilter).filter(decoration => decoration.isType('highlight'))\r\n  }\r", "name": "getDecorations", "func_location": "DecorationManager.getHighlightDecorations", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js", "line": 67, "func_start_line": 66}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollContainerClientWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2638, "start_line": 2636}, "call_info": {"func_end_line": 2117, "code": "  getHorizontalAutoscrollMargin () {\r\n    const maxMarginInBaseCharacters = Math.floor(\r\n      (this.getScrollContainerClientWidth() / this.getBaseCharacterWidth() - 1) / 2\r\n    )\r\n    const marginInBaseCharacters = Math.min(\r\n      this.props.model.horizontalScrollMargin,\r\n      maxMarginInBaseCharacters\r\n    )\r\n    return marginInBaseCharacters * this.getBaseCharacterWidth()\r\n  }\r", "name": "getScrollContainerClientWidth", "func_location": "TextEditorComponent.getHorizontalAutoscrollMargin", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2110, "func_start_line": 2108}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getBaseCharacterWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2606, "start_line": 2604}, "call_info": {"func_end_line": 2117, "code": "  getHorizontalAutoscrollMargin () {\r\n    const maxMarginInBaseCharacters = Math.floor(\r\n      (this.getScrollContainerClientWidth() / this.getBaseCharacterWidth() - 1) / 2\r\n    )\r\n    const marginInBaseCharacters = Math.min(\r\n      this.props.model.horizontalScrollMargin,\r\n      maxMarginInBaseCharacters\r\n    )\r\n    return marginInBaseCharacters * this.getBaseCharacterWidth()\r\n  }\r", "name": "getBaseCharacterWidth", "func_location": "TextEditorComponent.getHorizontalAutoscrollMargin", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2110, "func_start_line": 2108}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getBaseCharacterWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2606, "start_line": 2604}, "call_info": {"func_end_line": 2117, "code": "  getHorizontalAutoscrollMargin () {\r\n    const maxMarginInBaseCharacters = Math.floor(\r\n      (this.getScrollContainerClientWidth() / this.getBaseCharacterWidth() - 1) / 2\r\n    )\r\n    const marginInBaseCharacters = Math.min(\r\n      this.props.model.horizontalScrollMargin,\r\n      maxMarginInBaseCharacters\r\n    )\r\n    return marginInBaseCharacters * this.getBaseCharacterWidth()\r\n  }\r", "name": "getBaseCharacterWidth", "func_location": "TextEditorComponent.getHorizontalAutoscrollMargin", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2116, "func_start_line": 2108}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 166, "code": "  getHorizontalScrollbarHeight () {\r\n    return this.getComponent().getHorizontalScrollbarHeight()\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.getHorizontalScrollbarHeight", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 165, "func_start_line": 164}}, {"func_info": {"comment": [" Public: Returns an {Array} of all the active themes."], "name": "ThemeManager.getActiveThemes", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 94, "start_line": 92}, "call_info": {"func_end_line": 402, "code": "  getImportPaths () {\r\n    let themePaths\r\n    const activeThemes = this.getActiveThemes()\r\n    if (activeThemes.length > 0) {\r\n      themePaths = (activeThemes.filter((theme) => theme).map((theme) => theme.getStylesheetsPath()))\r\n    } else {\r\n      themePaths = []\r\n      for (const themeName of this.getEnabledThemeNames()) {\r\n        const themePath = this.packageManager.resolvePackagePath(themeName)\r\n        if (themePath) {\r\n          const deprecatedPath = path.join(themePath, 'stylesheets')\r\n          if (fs.isDirectorySync(deprecatedPath)) {\r\n            themePaths.push(deprecatedPath)\r\n          } else {\r\n            themePaths.push(path.join(themePath, 'styles'))\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return themePaths.filter(themePath => fs.isDirectorySync(themePath))\r\n  }\r", "name": "getActiveThemes", "func_location": "ThemeManager.getImportPaths", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 383, "func_start_line": 381}}, {"func_info": {"comment": [" Public: Get the enabled theme names from the config.", "", " Returns an array of theme names in the order that they should be activated."], "name": "ThemeManager.getEnabledThemeNames", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 152, "start_line": 117}, "call_info": {"func_end_line": 402, "code": "  getImportPaths () {\r\n    let themePaths\r\n    const activeThemes = this.getActiveThemes()\r\n    if (activeThemes.length > 0) {\r\n      themePaths = (activeThemes.filter((theme) => theme).map((theme) => theme.getStylesheetsPath()))\r\n    } else {\r\n      themePaths = []\r\n      for (const themeName of this.getEnabledThemeNames()) {\r\n        const themePath = this.packageManager.resolvePackagePath(themeName)\r\n        if (themePath) {\r\n          const deprecatedPath = path.join(themePath, 'stylesheets')\r\n          if (fs.isDirectorySync(deprecatedPath)) {\r\n            themePaths.push(deprecatedPath)\r\n          } else {\r\n            themePaths.push(path.join(themePath, 'styles'))\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return themePaths.filter(themePath => fs.isDirectorySync(themePath))\r\n  }\r", "name": "getEnabledThemeNames", "func_location": "ThemeManager.getImportPaths", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 388, "func_start_line": 381}}, {"func_info": {"comment": [], "name": "Package.getIncompatibleNativeModulesStorageKey", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 1039, "start_line": 1036}, "call_info": {"func_end_line": 1083, "comment": [" Get the incompatible native modules that this package depends on.", " This recurses through all dependencies and requires all modules that", " contain a `.node` file.", "", " This information is cached in local storage on a per package/version basis", " to minimize the impact on startup time."], "code": "  getIncompatibleNativeModules () {\r\n    if (!this.packageManager.devMode) {\r\n      try {\r\n        const arrayAsString = global.localStorage.getItem(this.getIncompatibleNativeModulesStorageKey())\r\n        if (arrayAsString) return JSON.parse(arrayAsString)\r\n      } catch (error1) {}\r\n    }\r\n\r\n    const incompatibleNativeModules = []\r\n    for (let nativeModulePath of this.getNativeModuleDependencyPaths()) {\r\n      try {\r\n        require(nativeModulePath)\r\n      } catch (error) {\r\n        let version\r\n        try {\r\n          ({version} = require(`${nativeModulePath}/package.json`))\r\n        } catch (error2) {}\r\n        incompatibleNativeModules.push({\r\n          path: nativeModulePath,\r\n          name: path.basename(nativeModulePath),\r\n          version,\r\n          error: error.message\r\n        })\r\n      }\r\n    }\r\n\r\n    global.localStorage.setItem(\r\n      this.getIncompatibleNativeModulesStorageKey(),\r\n      JSON.stringify(incompatibleNativeModules)\r\n    )\r\n\r\n    return incompatibleNativeModules\r\n  }\r", "name": "getIncompatibleNativeModulesStorageKey", "func_location": "Package.getIncompatibleNativeModules", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 1054, "func_start_line": 1051}}, {"func_info": {"comment": [" Get an array of all the native modules that this package depends on.", "", " First try to get this information from", " @metadata._atomModuleCache.extensions. If @metadata._atomModuleCache doesn't", " exist, recurse through all dependencies."], "name": "Package.getNativeModuleDependencyPaths", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 963, "start_line": 937}, "call_info": {"func_end_line": 1083, "comment": [" Get the incompatible native modules that this package depends on.", " This recurses through all dependencies and requires all modules that", " contain a `.node` file.", "", " This information is cached in local storage on a per package/version basis", " to minimize the impact on startup time."], "code": "  getIncompatibleNativeModules () {\r\n    if (!this.packageManager.devMode) {\r\n      try {\r\n        const arrayAsString = global.localStorage.getItem(this.getIncompatibleNativeModulesStorageKey())\r\n        if (arrayAsString) return JSON.parse(arrayAsString)\r\n      } catch (error1) {}\r\n    }\r\n\r\n    const incompatibleNativeModules = []\r\n    for (let nativeModulePath of this.getNativeModuleDependencyPaths()) {\r\n      try {\r\n        require(nativeModulePath)\r\n      } catch (error) {\r\n        let version\r\n        try {\r\n          ({version} = require(`${nativeModulePath}/package.json`))\r\n        } catch (error2) {}\r\n        incompatibleNativeModules.push({\r\n          path: nativeModulePath,\r\n          name: path.basename(nativeModulePath),\r\n          version,\r\n          error: error.message\r\n        })\r\n      }\r\n    }\r\n\r\n    global.localStorage.setItem(\r\n      this.getIncompatibleNativeModulesStorageKey(),\r\n      JSON.stringify(incompatibleNativeModules)\r\n    )\r\n\r\n    return incompatibleNativeModules\r\n  }\r", "name": "getNativeModuleDependencyPaths", "func_location": "Package.getIncompatibleNativeModules", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 1060, "func_start_line": 1051}}, {"func_info": {"comment": [], "name": "Package.getIncompatibleNativeModulesStorageKey", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 1039, "start_line": 1036}, "call_info": {"func_end_line": 1083, "comment": [" Get the incompatible native modules that this package depends on.", " This recurses through all dependencies and requires all modules that", " contain a `.node` file.", "", " This information is cached in local storage on a per package/version basis", " to minimize the impact on startup time."], "code": "  getIncompatibleNativeModules () {\r\n    if (!this.packageManager.devMode) {\r\n      try {\r\n        const arrayAsString = global.localStorage.getItem(this.getIncompatibleNativeModulesStorageKey())\r\n        if (arrayAsString) return JSON.parse(arrayAsString)\r\n      } catch (error1) {}\r\n    }\r\n\r\n    const incompatibleNativeModules = []\r\n    for (let nativeModulePath of this.getNativeModuleDependencyPaths()) {\r\n      try {\r\n        require(nativeModulePath)\r\n      } catch (error) {\r\n        let version\r\n        try {\r\n          ({version} = require(`${nativeModulePath}/package.json`))\r\n        } catch (error2) {}\r\n        incompatibleNativeModules.push({\r\n          path: nativeModulePath,\r\n          name: path.basename(nativeModulePath),\r\n          version,\r\n          error: error.message\r\n        })\r\n      }\r\n    }\r\n\r\n    global.localStorage.setItem(\r\n      this.getIncompatibleNativeModulesStorageKey(),\r\n      JSON.stringify(incompatibleNativeModules)\r\n    )\r\n\r\n    return incompatibleNativeModules\r\n  }\r", "name": "getIncompatibleNativeModulesStorageKey", "func_location": "Package.getIncompatibleNativeModules", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 1078, "func_start_line": 1051}}, {"func_info": {"comment": [" Public: Returns the cursor's current buffer column."], "name": "Cursor.getBufferColumn", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 113, "start_line": 111}, "call_info": {"func_end_line": 192, "comment": [" Public: Returns the indentation level of the current line."], "code": "  getIndentLevel () {\r\n    if (this.editor.getSoftTabs()) {\r\n      return this.getBufferColumn() / this.editor.getTabLength()\r\n    } else {\r\n      return this.getBufferColumn()\r\n    }\r\n  }\r", "name": "getBufferColumn", "func_location": "Cursor.getIndentLevel", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 188, "func_start_line": 186}}, {"func_info": {"comment": [" Public: Returns the cursor's current buffer column."], "name": "Cursor.getBufferColumn", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 113, "start_line": 111}, "call_info": {"func_end_line": 192, "comment": [" Public: Returns the indentation level of the current line."], "code": "  getIndentLevel () {\r\n    if (this.editor.getSoftTabs()) {\r\n      return this.getBufferColumn() / this.editor.getTabLength()\r\n    } else {\r\n      return this.getBufferColumn()\r\n    }\r\n  }\r", "name": "getBufferColumn", "func_location": "Cursor.getIndentLevel", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 190, "func_start_line": 186}}, {"func_info": {"comment": [], "name": "getPreferredSize", "params": ["item", "location"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 837, "start_line": 825}, "call_info": {"func_end_line": 414, "code": "  getInitialSize () {\r\n    // The item may not have been activated yet. If that's the case, just use the first item.\r\n    const activePaneItem = this.paneContainer.getActivePaneItem() || this.paneContainer.getPaneItems()[0]\r\n    // If there are items, we should have an explicit width; if not, we shouldn't.\r\n    return activePaneItem\r\n      ? getPreferredSize(activePaneItem, this.location) || DEFAULT_INITIAL_SIZE\r\n      : null\r\n  }\r", "name": "getPreferredSize", "func_location": "Dock.getInitialSize", "args": ["activePaneItem", ".location"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 412, "func_start_line": 407}}, {"func_info": {"comment": [], "name": "humanizeKeystrokes", "params": ["keystroke"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip-manager.js", "end_line": 197, "start_line": 193}, "call_info": {"func_end_line": 203, "code": "function getKeystroke (bindings) {\r\n  if (bindings && bindings.length) {\r\n    return `<span class=\"keystroke\">${humanizeKeystrokes(bindings[0].keystrokes)}</span>`\r\n  }\r\n}\r", "name": "humanizeKeystrokes", "func_location": "getKeystroke", "args": ["bindings..keystrokes"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip-manager.js", "line": 201, "func_start_line": 199}}, {"func_info": {"comment": [" Essential: Returns a {Number} representing the number of screen lines in the", " editor. This accounts for folds."], "name": "TextEditor.getScreenLineCount", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 1217, "start_line": 1217}, "call_info": {"func_end_line": 1227, "comment": [" Essential: Returns a {Number} representing the last zero-indexed screen row", " number of the editor."], "code": "  getLastScreenRow () { return this.getScreenLineCount() - 1 }\r", "name": "getScreenLineCount", "func_location": "TextEditor.getLastScreenRow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 1227, "func_start_line": 1227}}, {"func_info": {"comment": [], "name": "TextEditorComponent.rowForPixelPosition", "params": ["pixelPosition"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2348, "start_line": 2346}, "call_info": {"func_end_line": 2772, "code": "  getLastVisibleRow () {\r\n    if (this.derivedDimensionsCache.lastVisibleRow == null) {\r\n      this.derivedDimensionsCache.lastVisibleRow = Math.min(\r\n        this.props.model.getApproximateScreenLineCount() - 1,\r\n        this.rowForPixelPosition(this.getScrollBottom())\r\n      )\r\n    }\r\n\r\n    return this.derivedDimensionsCache.lastVisibleRow\r\n  }\r", "name": "rowForPixelPosition", "func_location": "TextEditorComponent.getLastVisibleRow", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2767, "func_start_line": 2763}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollBottom", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2817, "start_line": 2815}, "call_info": {"func_end_line": 2772, "code": "  getLastVisibleRow () {\r\n    if (this.derivedDimensionsCache.lastVisibleRow == null) {\r\n      this.derivedDimensionsCache.lastVisibleRow = Math.min(\r\n        this.props.model.getApproximateScreenLineCount() - 1,\r\n        this.rowForPixelPosition(this.getScrollBottom())\r\n      )\r\n    }\r\n\r\n    return this.derivedDimensionsCache.lastVisibleRow\r\n  }\r", "name": "getScrollBottom", "func_location": "TextEditorComponent.getLastVisibleRow", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2767, "func_start_line": 2763}}, {"func_info": {"comment": [], "name": "TextEditorElement.getModel", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 82, "start_line": 80}, "call_info": {"func_end_line": 320, "code": "  getLastVisibleScreenRow () {\r\n    return this.getModel().getLastVisibleScreenRow()\r\n  }\r", "name": "getModel", "func_location": "TextEditorElement.getLastVisibleScreenRow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 319, "func_start_line": 318}}, {"func_info": {"comment": [], "name": "Workspace.getPanels", "params": ["location"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1814, "start_line": 1812}, "call_info": {"func_end_line": 1671, "comment": [" Essential: Get an {Array} of all the panel items to the left of the editor window."], "code": "  getLeftPanels () {\r\n    return this.getPanels('left')\r\n  }\r", "name": "getPanels", "func_location": "Workspace.getLeftPanels", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1670, "func_start_line": 1669}}, {"func_info": {"comment": [], "name": "DecorationManager.getDecorations", "params": ["propertyFilter"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js", "end_line": 56, "start_line": 40}, "call_info": {"func_end_line": 60, "code": "  getLineDecorations (propertyFilter) {\r\n    return this.getDecorations(propertyFilter).filter(decoration => decoration.isType('line'))\r\n  }\r", "name": "getDecorations", "func_location": "DecorationManager.getLineDecorations", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js", "line": 59, "func_start_line": 58}}, {"func_info": {"comment": [" Returns the corresponding {Repository}"], "name": "GitRepository.getRepo", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 530, "start_line": 524}, "call_info": {"func_end_line": 453, "comment": [" Public: Retrieves the line diffs comparing the `HEAD` version of the given", " path and the given text.", "", " * `path` The {String} path relative to the repository.", " * `text` The {String} to compare against the `HEAD` contents", "", " Returns an {Array} of hunk {Object}s with the following keys:", "   * `oldStart` The line {Number} of the old hunk.", "   * `newStart` The line {Number} of the new hunk.", "   * `oldLines` The {Number} of lines in the old hunk.", "   * `newLines` The {Number} of lines in the new hunk"], "code": "  getLineDiffs (path, text) {\r\n    // Ignore eol of line differences on windows so that files checked in as\r\n    // LF don't report every line modified when the text contains CRLF endings.\r\n    const options = {ignoreEolWhitespace: process.platform === 'win32'}\r\n    const repo = this.getRepo(path)\r\n    return repo.getLineDiffs(repo.relativize(path), text, options)\r\n  }\r", "name": "getRepo", "func_location": "GitRepository.getLineDiffs", "args": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 451, "func_start_line": 447}}, {"func_info": {"comment": [], "name": "DecorationManager.getDecorations", "params": ["propertyFilter"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js", "end_line": 56, "start_line": 40}, "call_info": {"func_end_line": 64, "code": "  getLineNumberDecorations (propertyFilter) {\r\n    return this.getDecorations(propertyFilter).filter(decoration => decoration.isType('line-number'))\r\n  }\r", "name": "getDecorations", "func_location": "DecorationManager.getLineNumberDecorations", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js", "line": 63, "func_start_line": 62}}, {"func_info": {"comment": ["\r\n  Section: Accessing loaded packages\r\n  ", " Public: Get an {Array} of all the loaded {Package}s"], "name": "PackageManager.getLoadedPackages", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 325, "start_line": 323}, "call_info": {"func_end_line": 332, "comment": [" Get packages for a certain package type", "", " * `types` an {Array} of {String}s like ['atom', 'textmate']."], "code": "  getLoadedPackagesForTypes (types) {\r\n    return this.getLoadedPackages().filter(p => types.includes(p.getType()))\r\n  }\r", "name": "getLoadedPackages", "func_location": "PackageManager.getLoadedPackagesForTypes", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 331, "func_start_line": 330}}, {"func_info": {"comment": [" Public: Returns an {Array} of all the loaded themes."], "name": "ThemeManager.getLoadedThemes", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 80, "start_line": 78}, "call_info": {"func_end_line": 75, "comment": ["\r\n  Section: Accessing Loaded Themes\r\n  ", " Public: Returns an {Array} of {String}s of all the loaded theme names."], "code": "  getLoadedThemeNames () {\r\n    return this.getLoadedThemes().map((theme) => theme.name)\r\n  }\r", "name": "getLoadedThemes", "func_location": "ThemeManager.getLoadedThemeNames", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 74, "func_start_line": 73}}, {"func_info": {"comment": [], "name": "TextEditor.getRightmostScreenPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 1288, "start_line": 1288}, "call_info": {"func_end_line": 1294, "code": "  getLongestScreenRow () { return this.getRightmostScreenPosition().row }\r", "name": "getRightmostScreenPosition", "func_location": "TextEditor.getLongestScreenRow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 1294, "func_start_line": 1294}}, {"func_info": {"comment": [" Essential: Returns the {String} path of this editor's text buffer."], "name": "TextEditor.getPath", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 1138, "start_line": 1136}, "call_info": {"func_end_line": 1133, "comment": [" Essential: Get unique title for display in other parts of the UI, such as", " the window title.", "", " If the editor's buffer is unsaved, its title is \"untitled\"", " If the editor's buffer is saved, its unique title is formatted as one", " of the following,", " * \"<filename>\" when it is the only editing buffer with this file name.", " * \"<filename> \u2014 <unique-dir-prefix>\" when other buffers have this file name.", "", " Returns a {String}"], "code": "  getLongTitle () {\r\n    if (this.getPath()) {\r\n      const fileName = this.getFileName()\r\n\r\n      let myPathSegments\r\n      const openEditorPathSegmentsWithSameFilename = []\r\n      for (const textEditor of atom.workspace.getTextEditors()) {\r\n        if (textEditor.getFileName() === fileName) {\r\n          const pathSegments = fs.tildify(textEditor.getDirectoryPath()).split(path.sep)\r\n          openEditorPathSegmentsWithSameFilename.push(pathSegments)\r\n          if (textEditor === this) myPathSegments = pathSegments\r\n        }\r\n      }\r\n\r\n      if (!myPathSegments || openEditorPathSegmentsWithSameFilename.length === 1) return fileName\r\n\r\n      let commonPathSegmentCount\r\n      for (let i = 0, {length} = myPathSegments; i < length; i++) {\r\n        const myPathSegment = myPathSegments[i]\r\n        if (openEditorPathSegmentsWithSameFilename.some(segments => (segments.length === i + 1) || (segments[i] !== myPathSegment))) {\r\n          commonPathSegmentCount = i\r\n          break\r\n        }\r\n      }\r\n\r\n      return `${fileName} \\u2014 ${path.join(...myPathSegments.slice(commonPathSegmentCount))}`\r\n    } else {\r\n      return 'untitled'\r\n    }\r\n  }\r", "name": "getPath", "func_location": "TextEditor.getLongTitle", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 1105, "func_start_line": 1104}}, {"func_info": {"comment": [], "name": "TextEditor.getFileName", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 1143, "start_line": 1140}, "call_info": {"func_end_line": 1133, "comment": [" Essential: Get unique title for display in other parts of the UI, such as", " the window title.", "", " If the editor's buffer is unsaved, its title is \"untitled\"", " If the editor's buffer is saved, its unique title is formatted as one", " of the following,", " * \"<filename>\" when it is the only editing buffer with this file name.", " * \"<filename> \u2014 <unique-dir-prefix>\" when other buffers have this file name.", "", " Returns a {String}"], "code": "  getLongTitle () {\r\n    if (this.getPath()) {\r\n      const fileName = this.getFileName()\r\n\r\n      let myPathSegments\r\n      const openEditorPathSegmentsWithSameFilename = []\r\n      for (const textEditor of atom.workspace.getTextEditors()) {\r\n        if (textEditor.getFileName() === fileName) {\r\n          const pathSegments = fs.tildify(textEditor.getDirectoryPath()).split(path.sep)\r\n          openEditorPathSegmentsWithSameFilename.push(pathSegments)\r\n          if (textEditor === this) myPathSegments = pathSegments\r\n        }\r\n      }\r\n\r\n      if (!myPathSegments || openEditorPathSegmentsWithSameFilename.length === 1) return fileName\r\n\r\n      let commonPathSegmentCount\r\n      for (let i = 0, {length} = myPathSegments; i < length; i++) {\r\n        const myPathSegment = myPathSegments[i]\r\n        if (openEditorPathSegmentsWithSameFilename.some(segments => (segments.length === i + 1) || (segments[i] !== myPathSegment))) {\r\n          commonPathSegmentCount = i\r\n          break\r\n        }\r\n      }\r\n\r\n      return `${fileName} \\u2014 ${path.join(...myPathSegments.slice(commonPathSegmentCount))}`\r\n    } else {\r\n      return 'untitled'\r\n    }\r\n  }\r", "name": "getFileName", "func_location": "TextEditor.getLongTitle", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 1106, "func_start_line": 1104}}, {"func_info": {"comment": [], "name": "TextEditor.getRightmostScreenPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 1288, "start_line": 1288}, "call_info": {"func_end_line": 1292, "code": "  getMaxScreenLineLength () { return this.getRightmostScreenPosition().column }\r", "name": "getRightmostScreenPosition", "func_location": "TextEditor.getMaxScreenLineLength", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 1292, "func_start_line": 1292}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2682, "start_line": 2672}, "call_info": {"func_end_line": 2843, "code": "  getMaxScrollLeft () {\r\n    return Math.round(Math.max(0, this.getScrollWidth() - this.getScrollContainerClientWidth()))\r\n  }\r", "name": "getScrollWidth", "func_location": "TextEditorComponent.getMaxScrollLeft", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2842, "func_start_line": 2841}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollContainerClientWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2638, "start_line": 2636}, "call_info": {"func_end_line": 2843, "code": "  getMaxScrollLeft () {\r\n    return Math.round(Math.max(0, this.getScrollWidth() - this.getScrollContainerClientWidth()))\r\n  }\r", "name": "getScrollContainerClientWidth", "func_location": "TextEditorComponent.getMaxScrollLeft", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2842, "func_start_line": 2841}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2670, "start_line": 2659}, "call_info": {"func_end_line": 2813, "code": "  getMaxScrollTop () {\r\n    return Math.round(Math.max(0, this.getScrollHeight() - this.getScrollContainerClientHeight()))\r\n  }\r", "name": "getScrollHeight", "func_location": "TextEditorComponent.getMaxScrollTop", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2812, "func_start_line": 2811}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollContainerClientHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2642, "start_line": 2640}, "call_info": {"func_end_line": 2813, "code": "  getMaxScrollTop () {\r\n    return Math.round(Math.max(0, this.getScrollHeight() - this.getScrollContainerClientHeight()))\r\n  }\r", "name": "getScrollContainerClientHeight", "func_location": "TextEditorComponent.getMaxScrollTop", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2812, "func_start_line": 2811}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 150, "code": "  getMaxScrollTop () {\r\n    return this.getComponent().getMaxScrollTop()\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.getMaxScrollTop", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 149, "func_start_line": 148}}, {"func_info": {"comment": [], "name": "Workspace.getPanels", "params": ["location"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1814, "start_line": 1812}, "call_info": {"func_end_line": 1776, "comment": [" Essential: Get an {Array} of all the modal panel items"], "code": "  getModalPanels () {\r\n    return this.getPanels('modal')\r\n  }\r", "name": "getPanels", "func_location": "Workspace.getModalPanels", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1775, "func_start_line": 1774}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 82, "code": "  getModel () {\r\n    return this.getComponent().props.model\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.getModel", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 81, "func_start_line": 80}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 78, "comment": [" Extended: Get a promise that resolves the next time the element's DOM", " is updated in any way.", "", " This can be useful when you've made a change to the model and need to", " be sure this change has been flushed to the DOM.", "", " Returns a {Promise}."], "code": "  getNextUpdatePromise () {\r\n    return this.getComponent().getNextUpdatePromise()\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.getNextUpdatePromise", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 77, "func_start_line": 76}}, {"func_info": {"comment": [" Public: Returns the current buffer position as an Array."], "name": "Cursor.getBufferPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 93, "start_line": 91}, "call_info": {"func_end_line": 513, "comment": [" Public: Returns buffer position of the next word boundary. It might be on", " the current word, or the previous word.", "", " * `options` (optional) {Object} with the following keys:", "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"", "      (default: {::wordRegExp})"], "code": "  getNextWordBoundaryBufferPosition (options = {}) {\r\n    const currentBufferPosition = this.getBufferPosition()\r\n    const scanRange = Range(currentBufferPosition, this.editor.getEofBufferPosition())\r\n\r\n    const range = this.editor.buffer.findInRangeSync(\r\n      options.wordRegex || this.wordRegExp(),\r\n      scanRange\r\n    )\r\n\r\n    if (range) {\r\n      if (range.start.row > currentBufferPosition.row) {\r\n        return Point(range.start.row, 0)\r\n      } else if (currentBufferPosition.isLessThan(range.start)) {\r\n        return Point.fromObject(range.start)\r\n      } else {\r\n        return Point.fromObject(range.end)\r\n      }\r\n    } else {\r\n      return currentBufferPosition\r\n    }\r\n  }\r", "name": "getBufferPosition", "func_location": "Cursor.getNextWordBoundaryBufferPosition", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 494, "func_start_line": 493}}, {"func_info": {"comment": [" Public: Get the RegExp used by the cursor to determine what a \"word\" is.", "", " * `options` (optional) {Object} with the following keys:", "   * `includeNonWordCharacters` A {Boolean} indicating whether to include", "     non-word characters in the regex. (default: true)", "", " Returns a {RegExp}."], "name": "Cursor.wordRegExp", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 681, "start_line": 674}, "call_info": {"func_end_line": 513, "comment": [" Public: Returns buffer position of the next word boundary. It might be on", " the current word, or the previous word.", "", " * `options` (optional) {Object} with the following keys:", "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"", "      (default: {::wordRegExp})"], "code": "  getNextWordBoundaryBufferPosition (options = {}) {\r\n    const currentBufferPosition = this.getBufferPosition()\r\n    const scanRange = Range(currentBufferPosition, this.editor.getEofBufferPosition())\r\n\r\n    const range = this.editor.buffer.findInRangeSync(\r\n      options.wordRegex || this.wordRegExp(),\r\n      scanRange\r\n    )\r\n\r\n    if (range) {\r\n      if (range.start.row > currentBufferPosition.row) {\r\n        return Point(range.start.row, 0)\r\n      } else if (currentBufferPosition.isLessThan(range.start)) {\r\n        return Point.fromObject(range.start)\r\n      } else {\r\n        return Point.fromObject(range.end)\r\n      }\r\n    } else {\r\n      return currentBufferPosition\r\n    }\r\n  }\r", "name": "wordRegExp", "func_location": "Cursor.getNextWordBoundaryBufferPosition", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 498, "func_start_line": 493}}, {"func_info": {"comment": [" Public: Returns the current buffer position as an Array."], "name": "Cursor.getBufferPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 93, "start_line": 91}, "call_info": {"func_end_line": 718, "comment": ["\r\n  Section: Private\r\n  "], "code": "  getNonWordCharacters () {\r\n    return this.editor.getNonWordCharacters(this.getBufferPosition())\r\n  }\r", "name": "getBufferPosition", "func_location": "Cursor.getNonWordCharacters", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 717, "func_start_line": 716}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.scopeDescriptorForPosition", "params": ["position"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 526, "start_line": 507}, "call_info": {"func_end_line": 66, "code": "  getNonWordCharacters (position) {\r\n    const scope = this.scopeDescriptorForPosition(position)\r\n    return this.config.get('editor.nonWordCharacters', {scope})\r\n  }\r", "name": "scopeDescriptorForPosition", "func_location": "TextMateLanguageMode.getNonWordCharacters", "args": ["position"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 64, "func_start_line": 63}}, {"func_info": {"comment": [], "name": "last", "params": ["array"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1208, "start_line": 1206}, "call_info": {"func_end_line": 843, "code": "  getOpenScopeIds () {\r\n    return last(this.iterators).getOpenScopeIds()\r\n  }\r", "name": "last", "func_location": "HighlightIterator.getOpenScopeIds", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 842, "func_start_line": 841}}, {"func_info": {"comment": [], "name": "extend", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip.js", "end_line": 561, "start_line": 550}, "call_info": {"func_end_line": 141, "code": "Tooltip.prototype.getOptions = function (options) {\r\n  options = extend({}, this.getDefaults(), options)\r\n\r\n  if (options.delay && typeof options.delay === 'number') {\r\n    options.delay = {\r\n      show: options.delay,\r\n      hide: options.delay\r\n    }\r\n  }\r\n\r\n  return options\r\n}\r", "name": "extend", "func_location": "Tooltip.prototype.getOptions", "args": [null, null, "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip.js", "line": 131, "func_start_line": 130}}, {"func_info": {"comment": [" Public: Returns the git configuration value specified by the key.", "", " * `key`  The {String} key for the configuration to lookup.", " * `path` An optional {String} path in the repository to get this information", "   for, only needed if the repository has submodules."], "name": "GitRepository.getConfigValue", "params": ["key", "path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 278, "start_line": 276}, "call_info": {"func_end_line": 286, "comment": [" Public: Returns the origin url of the repository.", "", " * `path` (optional) {String} path in the repository to get this information", "   for, only needed if the repository has submodules."], "code": "  getOriginURL (path) {\r\n    return this.getConfigValue('remote.origin.url', path)\r\n  }\r", "name": "getConfigValue", "func_location": "GitRepository.getOriginURL", "args": [{"type": "string"}, "path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 285, "func_start_line": 284}}, {"func_info": {"comment": [" Essential: Get all text editors in the workspace.", "", " Returns an {Array} of {TextEditor}s."], "name": "Workspace.getTextEditors", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1366, "start_line": 1364}, "call_info": {"func_end_line": 408, "code": "  getPackageNamesWithActiveGrammars () {\r\n    const packageNames = []\r\n    const addGrammar = ({includedGrammarScopes, packageName} = {}) => {\r\n      if (!packageName) { return }\r\n      // Prevent cycles\r\n      if (packageNames.indexOf(packageName) !== -1) { return }\r\n\r\n      packageNames.push(packageName)\r\n      for (let scopeName of includedGrammarScopes != null ? includedGrammarScopes : []) {\r\n        addGrammar(this.grammarRegistry.grammarForScopeName(scopeName))\r\n      }\r\n    }\r\n\r\n    const editors = this.getTextEditors()\r\n    for (let editor of editors) { addGrammar(editor.getGrammar()) }\r\n\r\n    if (editors.length > 0) {\r\n      for (let grammar of this.grammarRegistry.getGrammars()) {\r\n        if (grammar.injectionSelector) {\r\n          addGrammar(grammar)\r\n        }\r\n      }\r\n    }\r\n\r\n    return _.uniq(packageNames)\r\n  }\r", "name": "getTextEditors", "func_location": "Workspace.getPackageNamesWithActiveGrammars", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 396, "func_start_line": 383}}, {"func_info": {"comment": [], "name": "PaneContainer.getRoot", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 129, "start_line": 129}, "call_info": {"func_end_line": 156, "code": "  getPaneItems () {\r\n    return this.getRoot().getItems()\r\n  }\r", "name": "getRoot", "func_location": "PaneContainer.getPaneItems", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 155, "func_start_line": 154}}, {"func_info": {"comment": [], "name": "Workspace.getPaneContainers", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1625, "start_line": 1618}, "call_info": {"func_end_line": 1352, "comment": ["\r\n  Section: Pane Items\r\n  ", " Essential: Get all pane items in the workspace.", "", " Returns an {Array} of items."], "code": "  getPaneItems () {\r\n    return _.flatten(this.getPaneContainers().map(container => container.getPaneItems()))\r\n  }\r", "name": "getPaneContainers", "func_location": "Workspace.getPaneItems", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1351, "func_start_line": 1350}}, {"func_info": {"comment": [], "name": "PaneContainer.getRoot", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 129, "start_line": 129}, "call_info": {"func_end_line": 152, "code": "  getPanes () {\r\n    if (this.alive) {\r\n      return this.getRoot().getPanes()\r\n    } else {\r\n      return []\r\n    }\r\n  }\r", "name": "getRoot", "func_location": "PaneContainer.getPanes", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 148, "func_start_line": 146}}, {"func_info": {"comment": [], "name": "Workspace.getPaneContainers", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1625, "start_line": 1618}, "call_info": {"func_end_line": 1433, "comment": [" Extended: Get all panes in the workspace.", "", " Returns an {Array} of {Pane}s."], "code": "  getPanes () {\r\n    return _.flatten(this.getPaneContainers().map(container => container.getPanes()))\r\n  }\r", "name": "getPaneContainers", "func_location": "Workspace.getPanes", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1432, "func_start_line": 1431}}, {"func_info": {"comment": [" Returns the corresponding {Repository}"], "name": "GitRepository.getRepo", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 530, "start_line": 524}, "call_info": {"func_end_line": 191, "comment": [" Public: Returns the {String} path of the repository."], "code": "  getPath () {\r\n    if (this.path == null) {\r\n      this.path = fs.absolute(this.getRepo().getPath())\r\n    }\r\n    return this.path\r\n  }\r", "name": "getRepo", "func_location": "GitRepository.getPath", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 188, "func_start_line": 186}}, {"func_info": {"comment": [" Returns the corresponding {Repository}"], "name": "GitRepository.getRepo", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 530, "start_line": 524}, "call_info": {"func_end_line": 390, "comment": [" Public: Get the status of a single path in the repository.", "", " * `path` A {String} repository-relative path.", "", " Returns a {Number} representing the status. This value can be passed to", " {::isStatusModified} or {::isStatusNew} to get more information."], "code": "  getPathStatus (path) {\r\n    const repo = this.getRepo(path)\r\n    const relativePath = this.relativize(path)\r\n    const currentPathStatus = this.statuses[relativePath] || 0\r\n    let pathStatus = repo.getStatus(repo.relativize(path)) || 0\r\n    if (repo.isStatusIgnored(pathStatus)) pathStatus = 0\r\n    if (pathStatus > 0) {\r\n      this.statuses[relativePath] = pathStatus\r\n    } else {\r\n      delete this.statuses[relativePath]\r\n    }\r\n    if (currentPathStatus !== pathStatus) {\r\n      this.emitter.emit('did-change-status', {path, pathStatus})\r\n    }\r\n\r\n    return pathStatus\r\n  }\r", "name": "getRepo", "func_location": "GitRepository.getPathStatus", "args": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 375, "func_start_line": 374}}, {"func_info": {"comment": [" Public: Makes a path relative to the repository's working directory."], "name": "GitRepository.relativize", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 210, "start_line": 208}, "call_info": {"func_end_line": 390, "comment": [" Public: Get the status of a single path in the repository.", "", " * `path` A {String} repository-relative path.", "", " Returns a {Number} representing the status. This value can be passed to", " {::isStatusModified} or {::isStatusNew} to get more information."], "code": "  getPathStatus (path) {\r\n    const repo = this.getRepo(path)\r\n    const relativePath = this.relativize(path)\r\n    const currentPathStatus = this.statuses[relativePath] || 0\r\n    let pathStatus = repo.getStatus(repo.relativize(path)) || 0\r\n    if (repo.isStatusIgnored(pathStatus)) pathStatus = 0\r\n    if (pathStatus > 0) {\r\n      this.statuses[relativePath] = pathStatus\r\n    } else {\r\n      delete this.statuses[relativePath]\r\n    }\r\n    if (currentPathStatus !== pathStatus) {\r\n      this.emitter.emit('did-change-status', {path, pathStatus})\r\n    }\r\n\r\n    return pathStatus\r\n  }\r", "name": "relativize", "func_location": "GitRepository.getPathStatus", "args": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 376, "func_start_line": 374}}, {"func_info": {"comment": [], "name": "last", "params": ["array"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1208, "start_line": 1206}, "call_info": {"func_end_line": 835, "code": "  getPosition () {\r\n    return last(this.iterators).getPosition()\r\n  }\r", "name": "last", "func_location": "HighlightIterator.getPosition", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 834, "func_start_line": 833}}, {"func_info": {"comment": [" Public: Returns the current buffer position as an Array."], "name": "Cursor.getBufferPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 93, "start_line": 91}, "call_info": {"func_end_line": 485, "comment": ["\r\n  Section: Local Positions and Ranges\r\n  ", " Public: Returns buffer position of previous word boundary. It might be on", " the current word, or the previous word.", "", " * `options` (optional) {Object} with the following keys:", "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"", "      (default: {::wordRegExp})"], "code": "  getPreviousWordBoundaryBufferPosition (options = {}) {\r\n    const currentBufferPosition = this.getBufferPosition()\r\n    const previousNonBlankRow = this.editor.buffer.previousNonBlankRow(currentBufferPosition.row)\r\n    const scanRange = Range(Point(previousNonBlankRow || 0, 0), currentBufferPosition)\r\n\r\n    const ranges = this.editor.buffer.findAllInRangeSync(\r\n      options.wordRegex || this.wordRegExp(),\r\n      scanRange\r\n    )\r\n\r\n    const range = ranges[ranges.length - 1]\r\n    if (range) {\r\n      if (range.start.row < currentBufferPosition.row && currentBufferPosition.column > 0) {\r\n        return Point(currentBufferPosition.row, 0)\r\n      } else if (currentBufferPosition.isGreaterThan(range.end)) {\r\n        return Point.fromObject(range.end)\r\n      } else {\r\n        return Point.fromObject(range.start)\r\n      }\r\n    } else {\r\n      return currentBufferPosition\r\n    }\r\n  }\r", "name": "getBufferPosition", "func_location": "Cursor.getPreviousWordBoundaryBufferPosition", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 464, "func_start_line": 463}}, {"func_info": {"comment": [" Public: Get the RegExp used by the cursor to determine what a \"word\" is.", "", " * `options` (optional) {Object} with the following keys:", "   * `includeNonWordCharacters` A {Boolean} indicating whether to include", "     non-word characters in the regex. (default: true)", "", " Returns a {RegExp}."], "name": "Cursor.wordRegExp", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 681, "start_line": 674}, "call_info": {"func_end_line": 485, "comment": ["\r\n  Section: Local Positions and Ranges\r\n  ", " Public: Returns buffer position of previous word boundary. It might be on", " the current word, or the previous word.", "", " * `options` (optional) {Object} with the following keys:", "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"", "      (default: {::wordRegExp})"], "code": "  getPreviousWordBoundaryBufferPosition (options = {}) {\r\n    const currentBufferPosition = this.getBufferPosition()\r\n    const previousNonBlankRow = this.editor.buffer.previousNonBlankRow(currentBufferPosition.row)\r\n    const scanRange = Range(Point(previousNonBlankRow || 0, 0), currentBufferPosition)\r\n\r\n    const ranges = this.editor.buffer.findAllInRangeSync(\r\n      options.wordRegex || this.wordRegExp(),\r\n      scanRange\r\n    )\r\n\r\n    const range = ranges[ranges.length - 1]\r\n    if (range) {\r\n      if (range.start.row < currentBufferPosition.row && currentBufferPosition.column > 0) {\r\n        return Point(currentBufferPosition.row, 0)\r\n      } else if (currentBufferPosition.isGreaterThan(range.end)) {\r\n        return Point.fromObject(range.end)\r\n      } else {\r\n        return Point.fromObject(range.start)\r\n      }\r\n    } else {\r\n      return currentBufferPosition\r\n    }\r\n  }\r", "name": "wordRegExp", "func_location": "Cursor.getPreviousWordBoundaryBufferPosition", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 469, "func_start_line": 463}}, {"func_info": {"comment": [], "name": "arrayEquivalent", "params": ["a", "b"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "end_line": 115, "start_line": 109}, "call_info": {"func_end_line": 91, "code": "  getProject (paths) {\r\n    for (var i = 0; i < this.projects.length; i++) {\r\n      if (arrayEquivalent(paths, this.projects[i].paths)) {\r\n        return this.projects[i]\r\n      }\r\n    }\r\n\r\n    return null\r\n  }\r", "name": "arrayEquivalent", "func_location": "HistoryManager.getProject", "args": ["paths", ".projects.i.paths"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "line": 85, "func_start_line": 83}}, {"func_info": {"comment": ["\r\n  Section - Syntax Tree APIs\r\n  "], "name": "TreeSitterLanguageMode.getSyntaxNodeContainingRange", "params": ["range", "where"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 385, "start_line": 383}, "call_info": {"func_end_line": 414, "code": "  getRangeForSyntaxNodeContainingRange (range, where) {\r\n    const node = this.getSyntaxNodeContainingRange(range, where)\r\n    return node && node.range\r\n  }\r", "name": "getSyntaxNodeContainingRange", "func_location": "TreeSitterLanguageMode.getRangeForSyntaxNodeContainingRange", "args": ["range", "where"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 412, "func_start_line": 411}}, {"func_info": {"comment": [], "name": "NodeRangeSet._pushRange", "params": ["previousRanges", "newRanges", "newRange"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1160, "start_line": 1144}, "call_info": {"func_end_line": 1142, "name": "_pushRange", "func_location": "NodeRangeSet.getRanges", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 1120, "func_start_line": 1109}}, {"func_info": {"comment": [], "name": "NodeRangeSet._pushRange", "params": ["previousRanges", "newRanges", "newRange"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1160, "start_line": 1144}, "call_info": {"func_end_line": 1142, "name": "_pushRange", "func_location": "NodeRangeSet.getRanges", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 1132, "func_start_line": 1109}}, {"func_info": {"comment": [], "name": "Config.getLegacyScopeDescriptorForNewScopeDescriptor", "params": ["scopeDescriptor"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 827, "start_line": 825}, "call_info": {"func_end_line": 1262, "code": "  getRawScopedValue (scopeDescriptor, keyPath, options) {\r\n    scopeDescriptor = ScopeDescriptor.fromObject(scopeDescriptor)\r\n    const result = this.scopedSettingsStore.getPropertyValue(\r\n      scopeDescriptor.getScopeChain(),\r\n      keyPath,\r\n      options\r\n    )\r\n\r\n    const legacyScopeDescriptor = this.getLegacyScopeDescriptorForNewScopeDescriptor(scopeDescriptor)\r\n    if (result != null) {\r\n      return result\r\n    } else if (legacyScopeDescriptor) {\r\n      return this.scopedSettingsStore.getPropertyValue(\r\n        legacyScopeDescriptor.getScopeChain(),\r\n        keyPath,\r\n        options\r\n      )\r\n    }\r\n  }\r", "name": "getLegacyScopeDescriptorForNewScopeDescriptor", "func_location": "Config.getRawScopedValue", "args": ["scopeDescriptor"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1252, "func_start_line": 1244}}, {"func_info": {"comment": [], "name": "Config.deepClone", "params": ["object"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1102, "start_line": 1092}, "call_info": {"func_end_line": 1018, "code": "  getRawValue (keyPath, options = {}) {\r\n    let value\r\n    if (!options.excludeSources || !options.excludeSources.includes(this.mainSource)) {\r\n      value = getValueAtKeyPath(this.settings, keyPath)\r\n      if (this.projectFile != null) {\r\n        const projectValue = getValueAtKeyPath(this.projectSettings, keyPath)\r\n        value = (projectValue === undefined) ? value : projectValue\r\n      }\r\n    }\r\n\r\n    let defaultValue\r\n    if (!options.sources || options.sources.length === 0) {\r\n      defaultValue = getValueAtKeyPath(this.defaultSettings, keyPath)\r\n    }\r\n\r\n    if (value != null) {\r\n      value = this.deepClone(value)\r\n      if (isPlainObject(value) && isPlainObject(defaultValue)) {\r\n        this.deepDefaults(value, defaultValue)\r\n      }\r\n      return value\r\n    } else {\r\n      return this.deepClone(defaultValue)\r\n    }\r\n  }\r", "name": "deepClone", "func_location": "Config.getRawValue", "args": ["value"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1010, "func_start_line": 994}}, {"func_info": {"comment": [], "name": "Config.deepDefaults", "params": ["target"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1120, "start_line": 1104}, "call_info": {"func_end_line": 1018, "code": "  getRawValue (keyPath, options = {}) {\r\n    let value\r\n    if (!options.excludeSources || !options.excludeSources.includes(this.mainSource)) {\r\n      value = getValueAtKeyPath(this.settings, keyPath)\r\n      if (this.projectFile != null) {\r\n        const projectValue = getValueAtKeyPath(this.projectSettings, keyPath)\r\n        value = (projectValue === undefined) ? value : projectValue\r\n      }\r\n    }\r\n\r\n    let defaultValue\r\n    if (!options.sources || options.sources.length === 0) {\r\n      defaultValue = getValueAtKeyPath(this.defaultSettings, keyPath)\r\n    }\r\n\r\n    if (value != null) {\r\n      value = this.deepClone(value)\r\n      if (isPlainObject(value) && isPlainObject(defaultValue)) {\r\n        this.deepDefaults(value, defaultValue)\r\n      }\r\n      return value\r\n    } else {\r\n      return this.deepClone(defaultValue)\r\n    }\r\n  }\r", "name": "deepDefaults", "func_location": "Config.getRawValue", "args": ["value", "defaultValue"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1012, "func_start_line": 994}}, {"func_info": {"comment": [], "name": "Config.deepClone", "params": ["object"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1102, "start_line": 1092}, "call_info": {"func_end_line": 1018, "code": "  getRawValue (keyPath, options = {}) {\r\n    let value\r\n    if (!options.excludeSources || !options.excludeSources.includes(this.mainSource)) {\r\n      value = getValueAtKeyPath(this.settings, keyPath)\r\n      if (this.projectFile != null) {\r\n        const projectValue = getValueAtKeyPath(this.projectSettings, keyPath)\r\n        value = (projectValue === undefined) ? value : projectValue\r\n      }\r\n    }\r\n\r\n    let defaultValue\r\n    if (!options.sources || options.sources.length === 0) {\r\n      defaultValue = getValueAtKeyPath(this.defaultSettings, keyPath)\r\n    }\r\n\r\n    if (value != null) {\r\n      value = this.deepClone(value)\r\n      if (isPlainObject(value) && isPlainObject(defaultValue)) {\r\n        this.deepDefaults(value, defaultValue)\r\n      }\r\n      return value\r\n    } else {\r\n      return this.deepClone(defaultValue)\r\n    }\r\n  }\r", "name": "deepClone", "func_location": "Config.getRawValue", "args": ["defaultValue"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1016, "func_start_line": 994}}, {"func_info": {"comment": [" Returns the corresponding {Repository}"], "name": "GitRepository.getRepo", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 530, "start_line": 524}, "call_info": {"func_end_line": 310, "comment": [" Public: Gets all the local and remote references.", "", " * `path` An optional {String} path in the repository to get this information", "   for, only needed if the repository has submodules.", "", " Returns an {Object} with the following keys:", "  * `heads`   An {Array} of head reference names.", "  * `remotes` An {Array} of remote reference names.", "  * `tags`    An {Array} of tag reference names."], "code": "  getReferences (path) {\r\n    return this.getRepo(path).getReferences()\r\n  }\r", "name": "getRepo", "func_location": "GitRepository.getReferences", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 309, "func_start_line": 308}}, {"func_info": {"comment": [" Returns the corresponding {Repository}"], "name": "GitRepository.getRepo", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 530, "start_line": 524}, "call_info": {"func_end_line": 319, "comment": [" Public: Returns the current {String} SHA for the given reference.", "", " * `reference` The {String} reference to get the target of.", " * `path` An optional {String} path in the repo to get the reference target", "   for. Only needed if the repository contains submodules."], "code": "  getReferenceTarget (reference, path) {\r\n    return this.getRepo(path).getReferenceTarget(reference)\r\n  }\r", "name": "getRepo", "func_location": "GitRepository.getReferenceTarget", "args": ["reference"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 318, "func_start_line": 317}}, {"func_info": {"comment": [" Public: Get the version of the Atom application.", "", " Returns the version text {String}."], "name": "AtomEnvironment.getVersion", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 486, "start_line": 483}, "call_info": {"func_end_line": 504, "comment": [" Public: Gets the release channel of the Atom application.", "", " Returns the release channel as a {String}. Will return a specific release channel", " name like 'beta' or 'nightly' if one is found in the Atom version or 'stable'", " otherwise."], "code": "  getReleaseChannel () {\r\n    // This matches stable, dev (with or without commit hash) and any other\r\n    // release channel following the pattern '1.00.0-channel0'\r\n    const match = this.getVersion().match(/\\d+\\.\\d+\\.\\d+(-([a-z]+)(\\d+|-\\w{4,})?)?$/)\r\n    if (!match) {\r\n      return 'unrecognized'\r\n    } else if (match[2]) {\r\n      return match[2]\r\n    }\r\n\r\n    return 'stable'\r\n  }\r", "name": "getVersion", "func_location": "AtomEnvironment.getReleaseChannel", "args": [{"type": "object"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 496, "func_start_line": 493}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedStartRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2726, "start_line": 2720}, "call_info": {"func_end_line": 2737, "code": "  getRenderedEndRow () {\r\n    if (this.derivedDimensionsCache.renderedEndRow == null) {\r\n      this.derivedDimensionsCache.renderedEndRow = Math.min(\r\n        this.props.model.getApproximateScreenLineCount(),\r\n        this.getRenderedStartRow() + this.getVisibleTileCount() * this.getRowsPerTile()\r\n      )\r\n    }\r\n\r\n    return this.derivedDimensionsCache.renderedEndRow\r\n  }\r", "name": "getRenderedStartRow", "func_location": "TextEditorComponent.getRenderedEndRow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2732, "func_start_line": 2728}}, {"func_info": {"comment": [" We may render more tiles than needed if some contain block decorations,", " but keeping this calculation simple ensures the number of tiles remains", " fixed for a given editor height, which eliminates situations where a", " tile is repeatedly added and removed during scrolling in certain", " combinations of editor height and line height."], "name": "TextEditorComponent.getVisibleTileCount", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2785, "start_line": 2779}, "call_info": {"func_end_line": 2737, "code": "  getRenderedEndRow () {\r\n    if (this.derivedDimensionsCache.renderedEndRow == null) {\r\n      this.derivedDimensionsCache.renderedEndRow = Math.min(\r\n        this.props.model.getApproximateScreenLineCount(),\r\n        this.getRenderedStartRow() + this.getVisibleTileCount() * this.getRowsPerTile()\r\n      )\r\n    }\r\n\r\n    return this.derivedDimensionsCache.renderedEndRow\r\n  }\r", "name": "getVisibleTileCount", "func_location": "TextEditorComponent.getRenderedEndRow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2732, "func_start_line": 2728}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRowsPerTile", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2714, "start_line": 2712}, "call_info": {"func_end_line": 2737, "code": "  getRenderedEndRow () {\r\n    if (this.derivedDimensionsCache.renderedEndRow == null) {\r\n      this.derivedDimensionsCache.renderedEndRow = Math.min(\r\n        this.props.model.getApproximateScreenLineCount(),\r\n        this.getRenderedStartRow() + this.getVisibleTileCount() * this.getRowsPerTile()\r\n      )\r\n    }\r\n\r\n    return this.derivedDimensionsCache.renderedEndRow\r\n  }\r", "name": "getRowsPerTile", "func_location": "TextEditorComponent.getRenderedEndRow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2732, "func_start_line": 2728}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedEndRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2737, "start_line": 2728}, "call_info": {"func_end_line": 2745, "code": "  getRenderedRowCount () {\r\n    if (this.derivedDimensionsCache.renderedRowCount == null) {\r\n      this.derivedDimensionsCache.renderedRowCount = Math.max(0, this.getRenderedEndRow() - this.getRenderedStartRow())\r\n    }\r\n\r\n    return this.derivedDimensionsCache.renderedRowCount\r\n  }\r", "name": "getRenderedEndRow", "func_location": "TextEditorComponent.getRenderedRowCount", "args": [{"type": "number"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2741, "func_start_line": 2739}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedStartRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2726, "start_line": 2720}, "call_info": {"func_end_line": 2745, "code": "  getRenderedRowCount () {\r\n    if (this.derivedDimensionsCache.renderedRowCount == null) {\r\n      this.derivedDimensionsCache.renderedRowCount = Math.max(0, this.getRenderedEndRow() - this.getRenderedStartRow())\r\n    }\r\n\r\n    return this.derivedDimensionsCache.renderedRowCount\r\n  }\r", "name": "getRenderedStartRow", "func_location": "TextEditorComponent.getRenderedRowCount", "args": [{"type": "number"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2741, "func_start_line": 2739}}, {"func_info": {"comment": [], "name": "TextEditorComponent.tileStartRowForRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2718, "start_line": 2716}, "call_info": {"func_end_line": 2726, "code": "  getRenderedStartRow () {\r\n    if (this.derivedDimensionsCache.renderedStartRow == null) {\r\n      this.derivedDimensionsCache.renderedStartRow = this.tileStartRowForRow(this.getFirstVisibleRow())\r\n    }\r\n\r\n    return this.derivedDimensionsCache.renderedStartRow\r\n  }\r", "name": "tileStartRowForRow", "func_location": "TextEditorComponent.getRenderedStartRow", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2722, "func_start_line": 2720}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getFirstVisibleRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2761, "start_line": 2755}, "call_info": {"func_end_line": 2726, "code": "  getRenderedStartRow () {\r\n    if (this.derivedDimensionsCache.renderedStartRow == null) {\r\n      this.derivedDimensionsCache.renderedStartRow = this.tileStartRowForRow(this.getFirstVisibleRow())\r\n    }\r\n\r\n    return this.derivedDimensionsCache.renderedStartRow\r\n  }\r", "name": "getFirstVisibleRow", "func_location": "TextEditorComponent.getRenderedStartRow", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2722, "func_start_line": 2720}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedRowCount", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2745, "start_line": 2739}, "call_info": {"func_end_line": 2753, "code": "  getRenderedTileCount () {\r\n    if (this.derivedDimensionsCache.renderedTileCount == null) {\r\n      this.derivedDimensionsCache.renderedTileCount = Math.ceil(this.getRenderedRowCount() / this.getRowsPerTile())\r\n    }\r\n\r\n    return this.derivedDimensionsCache.renderedTileCount\r\n  }\r", "name": "getRenderedRowCount", "func_location": "TextEditorComponent.getRenderedTileCount", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2749, "func_start_line": 2747}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRowsPerTile", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2714, "start_line": 2712}, "call_info": {"func_end_line": 2753, "code": "  getRenderedTileCount () {\r\n    if (this.derivedDimensionsCache.renderedTileCount == null) {\r\n      this.derivedDimensionsCache.renderedTileCount = Math.ceil(this.getRenderedRowCount() / this.getRowsPerTile())\r\n    }\r\n\r\n    return this.derivedDimensionsCache.renderedTileCount\r\n  }\r", "name": "getRowsPerTile", "func_location": "TextEditorComponent.getRenderedTileCount", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2749, "func_start_line": 2747}}, {"func_info": {"comment": [], "name": "Workspace.getPanels", "params": ["location"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1814, "start_line": 1812}, "call_info": {"func_end_line": 1692, "comment": [" Essential: Get an {Array} of all the panel items to the right of the editor window."], "code": "  getRightPanels () {\r\n    return this.getPanels('right')\r\n  }\r", "name": "getPanels", "func_location": "Workspace.getRightPanels", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1691, "func_start_line": 1690}}, {"func_info": {"comment": [" Public: Returns the current buffer position as an Array."], "name": "Cursor.getBufferPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 93, "start_line": 91}, "call_info": {"func_end_line": 199, "comment": [" Public: Retrieves the scope descriptor for the cursor's current position.", "", " Returns a {ScopeDescriptor}"], "code": "  getScopeDescriptor () {\r\n    return this.editor.scopeDescriptorForBufferPosition(this.getBufferPosition())\r\n  }\r", "name": "getBufferPosition", "func_location": "Cursor.getScopeDescriptor", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 198, "func_start_line": 197}}, {"func_info": {"comment": [" Public: Returns the screen position of the cursor as a {Point}."], "name": "Cursor.getScreenPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 75, "start_line": 73}, "call_info": {"func_end_line": 103, "comment": [" Public: Returns the cursor's current screen column."], "code": "  getScreenColumn () {\r\n    return this.getScreenPosition().column\r\n  }\r", "name": "getScreenPosition", "func_location": "Cursor.getScreenColumn", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 102, "func_start_line": 101}}, {"func_info": {"comment": [" Public: Returns the screen position of the cursor as a {Point}."], "name": "Cursor.getScreenPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 75, "start_line": 73}, "call_info": {"func_end_line": 733, "code": "  getScreenRange () {\r\n    const {row, column} = this.getScreenPosition()\r\n    return new Range(new Point(row, column), new Point(row, column + 1))\r\n  }\r", "name": "getScreenPosition", "func_location": "Cursor.getScreenRange", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 731, "func_start_line": 730}}, {"func_info": {"comment": [" Public: Returns the screen position of the cursor as a {Point}."], "name": "Cursor.getScreenPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 75, "start_line": 73}, "call_info": {"func_end_line": 98, "comment": [" Public: Returns the cursor's current screen row."], "code": "  getScreenRow () {\r\n    return this.getScreenPosition().row\r\n  }\r", "name": "getScreenPosition", "func_location": "Cursor.getScreenRow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 97, "func_start_line": 96}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollTop", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2794, "start_line": 2791}, "call_info": {"func_end_line": 2817, "code": "  getScrollBottom () {\r\n    return this.getScrollTop() + this.getScrollContainerClientHeight()\r\n  }\r", "name": "getScrollTop", "func_location": "TextEditorComponent.getScrollBottom", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2816, "func_start_line": 2815}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollContainerClientHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2642, "start_line": 2640}, "call_info": {"func_end_line": 2817, "code": "  getScrollBottom () {\r\n    return this.getScrollTop() + this.getScrollContainerClientHeight()\r\n  }\r", "name": "getScrollContainerClientHeight", "func_location": "TextEditorComponent.getScrollBottom", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2816, "func_start_line": 2815}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 180, "code": "  getScrollBottom () {\r\n    return this.getComponent().getScrollBottom()\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.getScrollBottom", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 179, "func_start_line": 178}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollContainerHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2634, "start_line": 2628}, "call_info": {"func_end_line": 2642, "code": "  getScrollContainerClientHeight () {\r\n    return this.getScrollContainerHeight() - this.getHorizontalScrollbarHeight()\r\n  }\r", "name": "getScrollContainerHeight", "func_location": "TextEditorComponent.getScrollContainerClientHeight", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2641, "func_start_line": 2640}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getHorizontalScrollbarHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2710, "start_line": 2708}, "call_info": {"func_end_line": 2642, "code": "  getScrollContainerClientHeight () {\r\n    return this.getScrollContainerHeight() - this.getHorizontalScrollbarHeight()\r\n  }\r", "name": "getHorizontalScrollbarHeight", "func_location": "TextEditorComponent.getScrollContainerClientHeight", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2641, "func_start_line": 2640}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollContainerWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2626, "start_line": 2620}, "call_info": {"func_end_line": 2638, "code": "  getScrollContainerClientWidth () {\r\n    return this.getScrollContainerWidth() - this.getVerticalScrollbarWidth()\r\n  }\r", "name": "getScrollContainerWidth", "func_location": "TextEditorComponent.getScrollContainerClientWidth", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2637, "func_start_line": 2636}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getVerticalScrollbarWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2706, "start_line": 2704}, "call_info": {"func_end_line": 2638, "code": "  getScrollContainerClientWidth () {\r\n    return this.getScrollContainerWidth() - this.getVerticalScrollbarWidth()\r\n  }\r", "name": "getVerticalScrollbarWidth", "func_location": "TextEditorComponent.getScrollContainerClientWidth", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2637, "func_start_line": 2636}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollContainerClientWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2638, "start_line": 2636}, "call_info": {"func_end_line": 2694, "code": "  getScrollContainerClientWidthInBaseCharacters () {\r\n    return Math.floor(this.getScrollContainerClientWidth() / this.getBaseCharacterWidth())\r\n  }\r", "name": "getScrollContainerClientWidth", "func_location": "TextEditorComponent.getScrollContainerClientWidthInBaseCharacters", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2693, "func_start_line": 2692}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getBaseCharacterWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2606, "start_line": 2604}, "call_info": {"func_end_line": 2694, "code": "  getScrollContainerClientWidthInBaseCharacters () {\r\n    return Math.floor(this.getScrollContainerClientWidth() / this.getBaseCharacterWidth())\r\n  }\r", "name": "getBaseCharacterWidth", "func_location": "TextEditorComponent.getScrollContainerClientWidthInBaseCharacters", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2693, "func_start_line": 2692}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2670, "start_line": 2659}, "call_info": {"func_end_line": 2634, "code": "  getScrollContainerHeight () {\r\n    if (this.props.model.getAutoHeight()) {\r\n      return this.getScrollHeight() + this.getHorizontalScrollbarHeight()\r\n    } else {\r\n      return this.getClientContainerHeight()\r\n    }\r\n  }\r", "name": "getScrollHeight", "func_location": "TextEditorComponent.getScrollContainerHeight", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2630, "func_start_line": 2628}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getHorizontalScrollbarHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2710, "start_line": 2708}, "call_info": {"func_end_line": 2634, "code": "  getScrollContainerHeight () {\r\n    if (this.props.model.getAutoHeight()) {\r\n      return this.getScrollHeight() + this.getHorizontalScrollbarHeight()\r\n    } else {\r\n      return this.getClientContainerHeight()\r\n    }\r\n  }\r", "name": "getHorizontalScrollbarHeight", "func_location": "TextEditorComponent.getScrollContainerHeight", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2630, "func_start_line": 2628}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getClientContainerHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2614, "start_line": 2612}, "call_info": {"func_end_line": 2634, "code": "  getScrollContainerHeight () {\r\n    if (this.props.model.getAutoHeight()) {\r\n      return this.getScrollHeight() + this.getHorizontalScrollbarHeight()\r\n    } else {\r\n      return this.getClientContainerHeight()\r\n    }\r\n  }\r", "name": "getClientContainerHeight", "func_location": "TextEditorComponent.getScrollContainerHeight", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2632, "func_start_line": 2628}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2682, "start_line": 2672}, "call_info": {"func_end_line": 2626, "code": "  getScrollContainerWidth () {\r\n    if (this.props.model.getAutoWidth()) {\r\n      return this.getScrollWidth()\r\n    } else {\r\n      return this.getClientContainerWidth() - this.getGutterContainerWidth()\r\n    }\r\n  }\r", "name": "getScrollWidth", "func_location": "TextEditorComponent.getScrollContainerWidth", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2622, "func_start_line": 2620}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getClientContainerWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2618, "start_line": 2616}, "call_info": {"func_end_line": 2626, "code": "  getScrollContainerWidth () {\r\n    if (this.props.model.getAutoWidth()) {\r\n      return this.getScrollWidth()\r\n    } else {\r\n      return this.getClientContainerWidth() - this.getGutterContainerWidth()\r\n    }\r\n  }\r", "name": "getClientContainerWidth", "func_location": "TextEditorComponent.getScrollContainerWidth", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2624, "func_start_line": 2620}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getGutterContainerWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2698, "start_line": 2696}, "call_info": {"func_end_line": 2626, "code": "  getScrollContainerWidth () {\r\n    if (this.props.model.getAutoWidth()) {\r\n      return this.getScrollWidth()\r\n    } else {\r\n      return this.getClientContainerWidth() - this.getGutterContainerWidth()\r\n    }\r\n  }\r", "name": "getGutterContainerWidth", "func_location": "TextEditorComponent.getScrollContainerWidth", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2624, "func_start_line": 2620}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getContentHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2686, "start_line": 2684}, "call_info": {"func_end_line": 2670, "code": "  getScrollHeight () {\r\n    if (this.props.model.getScrollPastEnd()) {\r\n      return this.getContentHeight() + Math.max(\r\n        3 * this.getLineHeight(),\r\n        this.getScrollContainerClientHeight() - (3 * this.getLineHeight())\r\n      )\r\n    } else if (this.props.model.getAutoHeight()) {\r\n      return this.getContentHeight()\r\n    } else {\r\n      return Math.max(this.getContentHeight(), this.getScrollContainerClientHeight())\r\n    }\r\n  }\r", "name": "getContentHeight", "func_location": "TextEditorComponent.getScrollHeight", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2661, "func_start_line": 2659}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getLineHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2602, "start_line": 2600}, "call_info": {"func_end_line": 2670, "code": "  getScrollHeight () {\r\n    if (this.props.model.getScrollPastEnd()) {\r\n      return this.getContentHeight() + Math.max(\r\n        3 * this.getLineHeight(),\r\n        this.getScrollContainerClientHeight() - (3 * this.getLineHeight())\r\n      )\r\n    } else if (this.props.model.getAutoHeight()) {\r\n      return this.getContentHeight()\r\n    } else {\r\n      return Math.max(this.getContentHeight(), this.getScrollContainerClientHeight())\r\n    }\r\n  }\r", "name": "getLineHeight", "func_location": "TextEditorComponent.getScrollHeight", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2662, "func_start_line": 2659}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollContainerClientHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2642, "start_line": 2640}, "call_info": {"func_end_line": 2670, "code": "  getScrollHeight () {\r\n    if (this.props.model.getScrollPastEnd()) {\r\n      return this.getContentHeight() + Math.max(\r\n        3 * this.getLineHeight(),\r\n        this.getScrollContainerClientHeight() - (3 * this.getLineHeight())\r\n      )\r\n    } else if (this.props.model.getAutoHeight()) {\r\n      return this.getContentHeight()\r\n    } else {\r\n      return Math.max(this.getContentHeight(), this.getScrollContainerClientHeight())\r\n    }\r\n  }\r", "name": "getScrollContainerClientHeight", "func_location": "TextEditorComponent.getScrollHeight", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2663, "func_start_line": 2659}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getLineHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2602, "start_line": 2600}, "call_info": {"func_end_line": 2670, "code": "  getScrollHeight () {\r\n    if (this.props.model.getScrollPastEnd()) {\r\n      return this.getContentHeight() + Math.max(\r\n        3 * this.getLineHeight(),\r\n        this.getScrollContainerClientHeight() - (3 * this.getLineHeight())\r\n      )\r\n    } else if (this.props.model.getAutoHeight()) {\r\n      return this.getContentHeight()\r\n    } else {\r\n      return Math.max(this.getContentHeight(), this.getScrollContainerClientHeight())\r\n    }\r\n  }\r", "name": "getLineHeight", "func_location": "TextEditorComponent.getScrollHeight", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2663, "func_start_line": 2659}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getContentHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2686, "start_line": 2684}, "call_info": {"func_end_line": 2670, "code": "  getScrollHeight () {\r\n    if (this.props.model.getScrollPastEnd()) {\r\n      return this.getContentHeight() + Math.max(\r\n        3 * this.getLineHeight(),\r\n        this.getScrollContainerClientHeight() - (3 * this.getLineHeight())\r\n      )\r\n    } else if (this.props.model.getAutoHeight()) {\r\n      return this.getContentHeight()\r\n    } else {\r\n      return Math.max(this.getContentHeight(), this.getScrollContainerClientHeight())\r\n    }\r\n  }\r", "name": "getContentHeight", "func_location": "TextEditorComponent.getScrollHeight", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2666, "func_start_line": 2659}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getContentHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2686, "start_line": 2684}, "call_info": {"func_end_line": 2670, "code": "  getScrollHeight () {\r\n    if (this.props.model.getScrollPastEnd()) {\r\n      return this.getContentHeight() + Math.max(\r\n        3 * this.getLineHeight(),\r\n        this.getScrollContainerClientHeight() - (3 * this.getLineHeight())\r\n      )\r\n    } else if (this.props.model.getAutoHeight()) {\r\n      return this.getContentHeight()\r\n    } else {\r\n      return Math.max(this.getContentHeight(), this.getScrollContainerClientHeight())\r\n    }\r\n  }\r", "name": "getContentHeight", "func_location": "TextEditorComponent.getScrollHeight", "args": [null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2668, "func_start_line": 2659}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollContainerClientHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2642, "start_line": 2640}, "call_info": {"func_end_line": 2670, "code": "  getScrollHeight () {\r\n    if (this.props.model.getScrollPastEnd()) {\r\n      return this.getContentHeight() + Math.max(\r\n        3 * this.getLineHeight(),\r\n        this.getScrollContainerClientHeight() - (3 * this.getLineHeight())\r\n      )\r\n    } else if (this.props.model.getAutoHeight()) {\r\n      return this.getContentHeight()\r\n    } else {\r\n      return Math.max(this.getContentHeight(), this.getScrollContainerClientHeight())\r\n    }\r\n  }\r", "name": "getScrollContainerClientHeight", "func_location": "TextEditorComponent.getScrollHeight", "args": [null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2668, "func_start_line": 2659}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 154, "code": "  getScrollHeight () {\r\n    return this.getComponent().getScrollHeight()\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.getScrollHeight", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 153, "func_start_line": 152}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 188, "code": "  getScrollLeft () {\r\n    return this.getComponent().getScrollLeft()\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.getScrollLeft", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 187, "func_start_line": 186}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getLongestLineWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2610, "start_line": 2608}, "call_info": {"func_end_line": 2893, "code": "  getScrollLeftColumn () {\r\n    if (this.hasInitialMeasurements && this.getLongestLineWidth() != null) {\r\n      return Math.round(this.getScrollLeft() / this.getBaseCharacterWidth())\r\n    } else {\r\n      return this.pendingScrollLeftColumn || 0\r\n    }\r\n  }\r", "name": "getLongestLineWidth", "func_location": "TextEditorComponent.getScrollLeftColumn", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2888, "func_start_line": 2887}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollLeft", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2825, "start_line": 2823}, "call_info": {"func_end_line": 2893, "code": "  getScrollLeftColumn () {\r\n    if (this.hasInitialMeasurements && this.getLongestLineWidth() != null) {\r\n      return Math.round(this.getScrollLeft() / this.getBaseCharacterWidth())\r\n    } else {\r\n      return this.pendingScrollLeftColumn || 0\r\n    }\r\n  }\r", "name": "getScrollLeft", "func_location": "TextEditorComponent.getScrollLeftColumn", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2889, "func_start_line": 2887}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getBaseCharacterWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2606, "start_line": 2604}, "call_info": {"func_end_line": 2893, "code": "  getScrollLeftColumn () {\r\n    if (this.hasInitialMeasurements && this.getLongestLineWidth() != null) {\r\n      return Math.round(this.getScrollLeft() / this.getBaseCharacterWidth())\r\n    } else {\r\n      return this.pendingScrollLeftColumn || 0\r\n    }\r\n  }\r", "name": "getBaseCharacterWidth", "func_location": "TextEditorComponent.getScrollLeftColumn", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2889, "func_start_line": 2887}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollLeft", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2825, "start_line": 2823}, "call_info": {"func_end_line": 2847, "code": "  getScrollRight () {\r\n    return this.getScrollLeft() + this.getScrollContainerClientWidth()\r\n  }\r", "name": "getScrollLeft", "func_location": "TextEditorComponent.getScrollRight", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2846, "func_start_line": 2845}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollContainerClientWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2638, "start_line": 2636}, "call_info": {"func_end_line": 2847, "code": "  getScrollRight () {\r\n    return this.getScrollLeft() + this.getScrollContainerClientWidth()\r\n  }\r", "name": "getScrollContainerClientWidth", "func_location": "TextEditorComponent.getScrollRight", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2846, "func_start_line": 2845}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 198, "code": "  getScrollRight () {\r\n    return this.getComponent().getScrollRight()\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.getScrollRight", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 197, "func_start_line": 196}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getMaxScrollTop", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2813, "start_line": 2811}, "call_info": {"func_end_line": 2794, "code": "  getScrollTop () {\r\n    this.scrollTop = Math.min(this.getMaxScrollTop(), this.scrollTop)\r\n    return this.scrollTop\r\n  }\r", "name": "getMaxScrollTop", "func_location": "TextEditorComponent.getScrollTop", "args": [null, ".scrollTop"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2792, "func_start_line": 2791}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 170, "code": "  getScrollTop () {\r\n    return this.getComponent().getScrollTop()\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.getScrollTop", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 169, "func_start_line": 168}}, {"func_info": {"comment": [], "name": "TextEditorComponent.rowForPixelPosition", "params": ["pixelPosition"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2348, "start_line": 2346}, "call_info": {"func_end_line": 2872, "code": "  getScrollTopRow () {\r\n    if (this.hasInitialMeasurements) {\r\n      return this.rowForPixelPosition(this.getScrollTop())\r\n    } else {\r\n      return this.pendingScrollTopRow || 0\r\n    }\r\n  }\r", "name": "rowForPixelPosition", "func_location": "TextEditorComponent.getScrollTopRow", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2868, "func_start_line": 2866}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollTop", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2794, "start_line": 2791}, "call_info": {"func_end_line": 2872, "code": "  getScrollTopRow () {\r\n    if (this.hasInitialMeasurements) {\r\n      return this.rowForPixelPosition(this.getScrollTop())\r\n    } else {\r\n      return this.pendingScrollTopRow || 0\r\n    }\r\n  }\r", "name": "getScrollTop", "func_location": "TextEditorComponent.getScrollTopRow", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2868, "func_start_line": 2866}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollContainerClientWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2638, "start_line": 2636}, "call_info": {"func_end_line": 2682, "code": "  getScrollWidth () {\r\n    const {model} = this.props\r\n\r\n    if (model.isSoftWrapped()) {\r\n      return this.getScrollContainerClientWidth()\r\n    } else if (model.getAutoWidth()) {\r\n      return this.getContentWidth()\r\n    } else {\r\n      return Math.max(this.getContentWidth(), this.getScrollContainerClientWidth())\r\n    }\r\n  }\r", "name": "getScrollContainerClientWidth", "func_location": "TextEditorComponent.getScrollWidth", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2676, "func_start_line": 2672}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getContentWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2690, "start_line": 2688}, "call_info": {"func_end_line": 2682, "code": "  getScrollWidth () {\r\n    const {model} = this.props\r\n\r\n    if (model.isSoftWrapped()) {\r\n      return this.getScrollContainerClientWidth()\r\n    } else if (model.getAutoWidth()) {\r\n      return this.getContentWidth()\r\n    } else {\r\n      return Math.max(this.getContentWidth(), this.getScrollContainerClientWidth())\r\n    }\r\n  }\r", "name": "getContentWidth", "func_location": "TextEditorComponent.getScrollWidth", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2678, "func_start_line": 2672}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getContentWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2690, "start_line": 2688}, "call_info": {"func_end_line": 2682, "code": "  getScrollWidth () {\r\n    const {model} = this.props\r\n\r\n    if (model.isSoftWrapped()) {\r\n      return this.getScrollContainerClientWidth()\r\n    } else if (model.getAutoWidth()) {\r\n      return this.getContentWidth()\r\n    } else {\r\n      return Math.max(this.getContentWidth(), this.getScrollContainerClientWidth())\r\n    }\r\n  }\r", "name": "getContentWidth", "func_location": "TextEditorComponent.getScrollWidth", "args": [null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2680, "func_start_line": 2672}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollContainerClientWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2638, "start_line": 2636}, "call_info": {"func_end_line": 2682, "code": "  getScrollWidth () {\r\n    const {model} = this.props\r\n\r\n    if (model.isSoftWrapped()) {\r\n      return this.getScrollContainerClientWidth()\r\n    } else if (model.getAutoWidth()) {\r\n      return this.getContentWidth()\r\n    } else {\r\n      return Math.max(this.getContentWidth(), this.getScrollContainerClientWidth())\r\n    }\r\n  }\r", "name": "getScrollContainerClientWidth", "func_location": "TextEditorComponent.getScrollWidth", "args": [null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2680, "func_start_line": 2672}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 158, "code": "  getScrollWidth () {\r\n    return this.getComponent().getScrollWidth()\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.getScrollWidth", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 157, "func_start_line": 156}}, {"func_info": {"comment": [" Returns the corresponding {Repository}"], "name": "GitRepository.getRepo", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 530, "start_line": 524}, "call_info": {"func_end_line": 229, "comment": [" Public: Retrieves a shortened version of the HEAD reference value.", "", " This removes the leading segments of `refs/heads`, `refs/tags`, or", " `refs/remotes`.  It also shortens the SHA-1 of a detached `HEAD` to 7", " characters.", "", " * `path` An optional {String} path in the repository to get this information", "   for, only needed if the repository contains submodules.", "", " Returns a {String}."], "code": "  getShortHead (path) {\r\n    return this.getRepo(path).getShortHead()\r\n  }\r", "name": "getRepo", "func_location": "GitRepository.getShortHead", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 228, "func_start_line": 227}}, {"func_info": {"comment": [], "name": "getWidthOrHeight", "params": ["location"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 823, "start_line": 821}, "call_info": {"func_end_line": 743, "code": "  getSize () {\r\n    if (!this.size) {\r\n      this.size = this.element.getBoundingClientRect()[getWidthOrHeight(this.props.location)]\r\n    }\r\n    return this.size\r\n  }\r", "name": "getWidthOrHeight", "func_location": "DockResizeHandle.getSize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 740, "func_start_line": 738}}, {"func_info": {"comment": [], "name": "Package.getStylesheetsPath", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 541, "start_line": 539}, "call_info": {"func_end_line": 562, "code": "  getStylesheetPaths () {\r\n    if (this.bundledPackage &&\r\n        this.packageManager.packagesCache[this.name] &&\r\n        this.packageManager.packagesCache[this.name].styleSheetPaths) {\r\n      const {styleSheetPaths} = this.packageManager.packagesCache[this.name]\r\n      return styleSheetPaths.map(styleSheetPath => path.join(this.path, styleSheetPath))\r\n    } else {\r\n      let indexStylesheet\r\n      const stylesheetDirPath = this.getStylesheetsPath()\r\n      if (this.metadata.mainStyleSheet) {\r\n        return [fs.resolve(this.path, this.metadata.mainStyleSheet)]\r\n      } else if (this.metadata.styleSheets) {\r\n        return this.metadata.styleSheets.map(name => fs.resolve(stylesheetDirPath, name, ['css', 'less', '']))\r\n      } else if ((indexStylesheet = fs.resolve(this.path, 'index', ['css', 'less']))) {\r\n        return [indexStylesheet]\r\n      } else {\r\n        return fs.listSync(stylesheetDirPath, ['css', 'less'])\r\n      }\r\n    }\r\n  }\r", "name": "getStylesheetsPath", "func_location": "Package.getStylesheetPaths", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 551, "func_start_line": 543}}, {"func_info": {"comment": [], "name": "TreeSitterLanguageMode._forEachTreeWithRange", "params": ["range", "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 316, "start_line": 303}, "call_info": {"func_end_line": 409, "name": "_forEachTreeWithRange", "func_location": "TreeSitterLanguageMode.getSyntaxNodeAndGrammarContainingRange", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 394, "func_start_line": 387}}, {"func_info": {"comment": ["\r\n  Section - Syntax Tree APIs\r\n  "], "name": "TreeSitterLanguageMode.getSyntaxNodeContainingRange", "params": ["range", "where"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 385, "start_line": 383}, "call_info": {"func_end_line": 418, "code": "  getSyntaxNodeAtPosition (position, where) {\r\n    return this.getSyntaxNodeContainingRange(new Range(position, position), where)\r\n  }\r", "name": "getSyntaxNodeContainingRange", "func_location": "TreeSitterLanguageMode.getSyntaxNodeAtPosition", "args": [null, "where"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 417, "func_start_line": 416}}, {"func_info": {"comment": [], "name": "TreeSitterLanguageMode.getSyntaxNodeAndGrammarContainingRange", "params": ["range", "where"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 409, "start_line": 387}, "call_info": {"func_end_line": 385, "comment": ["\r\n  Section - Syntax Tree APIs\r\n  "], "code": "  getSyntaxNodeContainingRange (range, where = _ => true) {\r\n    return this.getSyntaxNodeAndGrammarContainingRange(range, where).node\r\n  }\r", "name": "getSyntaxNodeAndGrammarContainingRange", "func_location": "TreeSitterLanguageMode.getSyntaxNodeContainingRange", "args": ["range", "where"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 384, "func_start_line": 383}}, {"func_info": {"comment": [" Public: Returns the current buffer position as an Array."], "name": "Cursor.getBufferPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 93, "start_line": 91}, "call_info": {"func_end_line": 206, "comment": [" Public: Retrieves the syntax tree scope descriptor for the cursor's current position.", "", " Returns a {ScopeDescriptor}"], "code": "  getSyntaxTreeScopeDescriptor () {\r\n    return this.editor.syntaxTreeScopeDescriptorForBufferPosition(this.getBufferPosition())\r\n  }\r", "name": "getBufferPosition", "func_location": "Cursor.getSyntaxTreeScopeDescriptor", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 205, "func_start_line": 204}}, {"func_info": {"comment": [" Public: Returns the buffer {Range} for the selection."], "name": "Selection.getBufferRange", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 81, "start_line": 79}, "call_info": {"func_end_line": 159, "comment": [" Public: Returns the text in the selection."], "code": "  getText () {\r\n    return this.editor.buffer.getTextInRange(this.getBufferRange())\r\n  }\r", "name": "getBufferRange", "func_location": "Selection.getText", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 158, "func_start_line": 157}}, {"func_info": {"comment": ["\r\n  Section: Pane Items\r\n  ", " Essential: Get all pane items in the workspace center.", "", " Returns an {Array} of items."], "name": "WorkspaceCenter.getPaneItems", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js", "end_line": 258, "start_line": 256}, "call_info": {"func_end_line": 272, "comment": [" Essential: Get all text editors in the workspace center.", "", " Returns an {Array} of {TextEditor}s."], "code": "  getTextEditors () {\r\n    return this.getPaneItems().filter(item => item instanceof TextEditor)\r\n  }\r", "name": "getPaneItems", "func_location": "WorkspaceCenter.getTextEditors", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js", "line": 271, "func_start_line": 270}}, {"func_info": {"comment": ["\r\n  Section: Pane Items\r\n  ", " Essential: Get all pane items in the workspace.", "", " Returns an {Array} of items."], "name": "Workspace.getPaneItems", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1352, "start_line": 1350}, "call_info": {"func_end_line": 1366, "comment": [" Essential: Get all text editors in the workspace.", "", " Returns an {Array} of {TextEditor}s."], "code": "  getTextEditors () {\r\n    return this.getPaneItems().filter(item => item instanceof TextEditor)\r\n  }\r", "name": "getPaneItems", "func_location": "Workspace.getTextEditors", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1365, "func_start_line": 1364}}, {"func_info": {"comment": [], "name": "TextEditor.getFileName", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 1143, "start_line": 1140}, "call_info": {"func_end_line": 1092, "comment": ["\r\n  Section: File Details\r\n  ", " Essential: Get the editor's title for display in other parts of the", " UI such as the tabs.", "", " If the editor's buffer is saved, its title is the file name. If it is", " unsaved, its title is \"untitled\".", "", " Returns a {String}."], "code": "  getTitle () {\r\n    return this.getFileName() || 'untitled'\r\n  }\r", "name": "getFileName", "func_location": "TextEditor.getTitle", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 1091, "func_start_line": 1090}}, {"func_info": {"comment": [], "name": "Workspace.getPanels", "params": ["location"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1814, "start_line": 1812}, "call_info": {"func_end_line": 1713, "comment": [" Essential: Get an {Array} of all the panel items at the top of the editor window."], "code": "  getTopPanels () {\r\n    return this.getPanels('top')\r\n  }\r", "name": "getPanels", "func_location": "Workspace.getTopPanels", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1712, "func_start_line": 1711}}, {"func_info": {"comment": [], "name": "PackageTranspilationRegistry.getTranspilerPath", "params": ["spec"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js", "end_line": 166, "start_line": 160}, "call_info": {"func_end_line": 175, "code": "  getTranspiler (spec) {\r\n    const transpilerPath = this.getTranspilerPath(spec)\r\n    if (transpilerPath) {\r\n      const transpiler = require(transpilerPath)\r\n      this.transpilerPaths[transpilerPath] = true\r\n      return transpiler\r\n    }\r\n  }\r", "name": "getTranspilerPath", "func_location": "PackageTranspilationRegistry.getTranspiler", "args": ["spec"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js", "line": 169, "func_start_line": 168}}, {"func_info": {"comment": [" Returns the corresponding {Repository}"], "name": "GitRepository.getRepo", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 530, "start_line": 524}, "call_info": {"func_end_line": 297, "comment": [" Public: Returns the upstream branch for the current HEAD, or null if there", " is no upstream branch for the current HEAD.", "", " * `path` An optional {String} path in the repo to get this information for,", "   only needed if the repository contains submodules.", "", " Returns a {String} branch name such as `refs/remotes/origin/master`."], "code": "  getUpstreamBranch (path) {\r\n    return this.getRepo(path).getUpstreamBranch()\r\n  }\r", "name": "getRepo", "func_location": "GitRepository.getUpstreamBranch", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 296, "func_start_line": 295}}, {"func_info": {"comment": [], "name": "AtomEnvironment.getConfigDirPath", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1291, "start_line": 1288}, "call_info": {"func_end_line": 1296, "code": "  getUserInitScriptPath () {\r\n    const initScriptPath = fs.resolve(this.getConfigDirPath(), 'init', ['js', 'coffee'])\r\n    return initScriptPath || path.join(this.getConfigDirPath(), 'init.coffee')\r\n  }\r", "name": "getConfigDirPath", "func_location": "AtomEnvironment.getUserInitScriptPath", "args": [null, {"type": "string"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 1294, "func_start_line": 1293}}, {"func_info": {"comment": [], "name": "AtomEnvironment.getConfigDirPath", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1291, "start_line": 1288}, "call_info": {"func_end_line": 1296, "code": "  getUserInitScriptPath () {\r\n    const initScriptPath = fs.resolve(this.getConfigDirPath(), 'init', ['js', 'coffee'])\r\n    return initScriptPath || path.join(this.getConfigDirPath(), 'init.coffee')\r\n  }\r", "name": "getConfigDirPath", "func_location": "AtomEnvironment.getUserInitScriptPath", "args": [null, {"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 1295, "func_start_line": 1293}}, {"func_info": {"comment": [" Public: Get the load settings for the current window.", "", " Returns an {Object} containing all the load setting key/value pairs."], "name": "AtomEnvironment.getLoadSettings", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 527, "start_line": 525}, "call_info": {"func_end_line": 486, "comment": [" Public: Get the version of the Atom application.", "", " Returns the version text {String}."], "code": "  getVersion () {\r\n    if (this.appVersion == null) this.appVersion = this.getLoadSettings().appVersion\r\n    return this.appVersion\r\n  }\r", "name": "getLoadSettings", "func_location": "AtomEnvironment.getVersion", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 484, "func_start_line": 483}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollContainerClientHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2642, "start_line": 2640}, "call_info": {"func_end_line": 2106, "code": "  getVerticalAutoscrollMargin () {\r\n    const maxMarginInLines = Math.floor(\r\n      (this.getScrollContainerClientHeight() / this.getLineHeight() - 1) / 2\r\n    )\r\n    const marginInLines = Math.min(\r\n      this.props.model.verticalScrollMargin,\r\n      maxMarginInLines\r\n    )\r\n    return marginInLines * this.getLineHeight()\r\n  }\r", "name": "getScrollContainerClientHeight", "func_location": "TextEditorComponent.getVerticalAutoscrollMargin", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2099, "func_start_line": 2097}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getLineHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2602, "start_line": 2600}, "call_info": {"func_end_line": 2106, "code": "  getVerticalAutoscrollMargin () {\r\n    const maxMarginInLines = Math.floor(\r\n      (this.getScrollContainerClientHeight() / this.getLineHeight() - 1) / 2\r\n    )\r\n    const marginInLines = Math.min(\r\n      this.props.model.verticalScrollMargin,\r\n      maxMarginInLines\r\n    )\r\n    return marginInLines * this.getLineHeight()\r\n  }\r", "name": "getLineHeight", "func_location": "TextEditorComponent.getVerticalAutoscrollMargin", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2099, "func_start_line": 2097}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getLineHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2602, "start_line": 2600}, "call_info": {"func_end_line": 2106, "code": "  getVerticalAutoscrollMargin () {\r\n    const maxMarginInLines = Math.floor(\r\n      (this.getScrollContainerClientHeight() / this.getLineHeight() - 1) / 2\r\n    )\r\n    const marginInLines = Math.min(\r\n      this.props.model.verticalScrollMargin,\r\n      maxMarginInLines\r\n    )\r\n    return marginInLines * this.getLineHeight()\r\n  }\r", "name": "getLineHeight", "func_location": "TextEditorComponent.getVerticalAutoscrollMargin", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2105, "func_start_line": 2097}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 162, "code": "  getVerticalScrollbarWidth () {\r\n    return this.getComponent().getVerticalScrollbarWidth()\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.getVerticalScrollbarWidth", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 161, "func_start_line": 160}}, {"func_info": {"comment": [], "name": "ViewRegistry.createView", "params": ["object"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/view-registry.js", "end_line": 185, "start_line": 133}, "call_info": {"func_end_line": 131, "comment": [" Essential: Get the view associated with an object in the workspace.", "", " If you're just *using* the workspace, you shouldn't need to access the view", " layer, but view layer access may be necessary if you want to perform DOM", " manipulation that isn't supported via the model API.", "", " ## View Resolution Algorithm", "", " The view associated with the object is resolved using the following", " sequence", "", "  1. Is the object an instance of `HTMLElement`? If true, return the object.", "  2. Does the object have a method named `getElement` that returns an", "     instance of `HTMLElement`? If true, return that value.", "  3. Does the object have a property named `element` with a value which is", "     an instance of `HTMLElement`? If true, return the property value.", "  4. Is the object a jQuery object, indicated by the presence of a `jquery`", "     property? If true, return the root DOM element (i.e. `object[0]`).", "  5. Has a view provider been registered for the object? If true, use the", "     provider to create a view associated with the object, and return the", "     view.", "", " If no associated view is returned by the sequence an error is thrown.", "", " Returns a DOM element."], "code": "  getView (object) {\r\n    if (object == null) { return }\r\n\r\n    let view = this.views.get(object)\r\n    if (!view) {\r\n      view = this.createView(object)\r\n      this.views.set(object, view)\r\n    }\r\n    return view\r\n  }\r", "name": "createView", "func_location": "ViewRegistry.getView", "args": ["object"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/view-registry.js", "line": 127, "func_start_line": 122}}, {"func_info": {"comment": ["\r\n  Section: Pane Locations\r\n  ", " Essential: Get the {WorkspaceCenter} at the center of the editor window."], "name": "Workspace.getCenter", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1601, "start_line": 1599}, "call_info": {"func_end_line": 1631, "code": "  getVisiblePaneContainers () {\r\n    const center = this.getCenter()\r\n    return atom.workspace.getPaneContainers()\r\n      .filter(container => container === center || container.isVisible())\r\n  }\r", "name": "getCenter", "func_location": "Workspace.getVisiblePaneContainers", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1628, "func_start_line": 1627}}, {"func_info": {"comment": [], "name": "Workspace.getVisiblePaneContainers", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1631, "start_line": 1627}, "call_info": {"func_end_line": 1437, "code": "  getVisiblePanes () {\r\n    return _.flatten(this.getVisiblePaneContainers().map(container => container.getPanes()))\r\n  }\r", "name": "getVisiblePaneContainers", "func_location": "Workspace.getVisiblePanes", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1436, "func_start_line": 1435}}, {"func_info": {"comment": [], "name": "TextEditorElement.getModel", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 82, "start_line": 80}, "call_info": {"func_end_line": 324, "code": "  getVisibleRowRange () {\r\n    return this.getModel().getVisibleRowRange()\r\n  }\r", "name": "getModel", "func_location": "TextEditorElement.getVisibleRowRange", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 323, "func_start_line": 322}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollContainerHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2634, "start_line": 2628}, "call_info": {"func_end_line": 2785, "comment": [" We may render more tiles than needed if some contain block decorations,", " but keeping this calculation simple ensures the number of tiles remains", " fixed for a given editor height, which eliminates situations where a", " tile is repeatedly added and removed during scrolling in certain", " combinations of editor height and line height."], "code": "  getVisibleTileCount () {\r\n    if (this.derivedDimensionsCache.visibleTileCount == null) {\r\n      const editorHeightInTiles = this.getScrollContainerHeight() / this.getLineHeight() / this.getRowsPerTile()\r\n      this.derivedDimensionsCache.visibleTileCount = Math.ceil(editorHeightInTiles) + 1\r\n    }\r\n    return this.derivedDimensionsCache.visibleTileCount\r\n  }\r", "name": "getScrollContainerHeight", "func_location": "TextEditorComponent.getVisibleTileCount", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2781, "func_start_line": 2779}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getLineHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2602, "start_line": 2600}, "call_info": {"func_end_line": 2785, "comment": [" We may render more tiles than needed if some contain block decorations,", " but keeping this calculation simple ensures the number of tiles remains", " fixed for a given editor height, which eliminates situations where a", " tile is repeatedly added and removed during scrolling in certain", " combinations of editor height and line height."], "code": "  getVisibleTileCount () {\r\n    if (this.derivedDimensionsCache.visibleTileCount == null) {\r\n      const editorHeightInTiles = this.getScrollContainerHeight() / this.getLineHeight() / this.getRowsPerTile()\r\n      this.derivedDimensionsCache.visibleTileCount = Math.ceil(editorHeightInTiles) + 1\r\n    }\r\n    return this.derivedDimensionsCache.visibleTileCount\r\n  }\r", "name": "getLineHeight", "func_location": "TextEditorComponent.getVisibleTileCount", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2781, "func_start_line": 2779}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRowsPerTile", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2714, "start_line": 2712}, "call_info": {"func_end_line": 2785, "comment": [" We may render more tiles than needed if some contain block decorations,", " but keeping this calculation simple ensures the number of tiles remains", " fixed for a given editor height, which eliminates situations where a", " tile is repeatedly added and removed during scrolling in certain", " combinations of editor height and line height."], "code": "  getVisibleTileCount () {\r\n    if (this.derivedDimensionsCache.visibleTileCount == null) {\r\n      const editorHeightInTiles = this.getScrollContainerHeight() / this.getLineHeight() / this.getRowsPerTile()\r\n      this.derivedDimensionsCache.visibleTileCount = Math.ceil(editorHeightInTiles) + 1\r\n    }\r\n    return this.derivedDimensionsCache.visibleTileCount\r\n  }\r", "name": "getRowsPerTile", "func_location": "TextEditorComponent.getVisibleTileCount", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2781, "func_start_line": 2779}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 116, "code": "  getWidth () {\r\n    return this.getComponent().getScrollContainerWidth()\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.getWidth", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 115, "func_start_line": 114}}, {"func_info": {"comment": [" Extended: Get the current window"], "name": "AtomEnvironment.getCurrentWindow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 598, "start_line": 596}, "call_info": {"func_end_line": 688, "comment": [" Get the dimensions of this window.", "", " Returns an {Object} with the following keys:", "   * `x`      The window's x-position {Number}.", "   * `y`      The window's y-position {Number}.", "   * `width`  The window's width {Number}.", "   * `height` The window's height {Number}."], "code": "  getWindowDimensions () {\r\n    const browserWindow = this.getCurrentWindow()\r\n    const [x, y] = browserWindow.getPosition()\r\n    const [width, height] = browserWindow.getSize()\r\n    const maximized = browserWindow.isMaximized()\r\n    return {x, y, width, height, maximized}\r\n  }\r", "name": "getCurrentWindow", "func_location": "AtomEnvironment.getWindowDimensions", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 683, "func_start_line": 682}}, {"func_info": {"comment": [" Returns the corresponding {Repository}"], "name": "GitRepository.getRepo", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 530, "start_line": 524}, "call_info": {"func_end_line": 196, "comment": [" Public: Returns the {String} working directory path of the repository."], "code": "  getWorkingDirectory () {\r\n    return this.getRepo().getWorkingDirectory()\r\n  }\r", "name": "getRepo", "func_location": "GitRepository.getWorkingDirectory", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 195, "func_start_line": 194}}, {"func_info": {"comment": [], "name": "GrammarRegistry.shouldUseTreeSitterParser", "params": ["languageId"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 584, "start_line": 579}, "call_info": {"func_end_line": 326, "code": "  grammarForId (languageId) {\r\n    if (!languageId) return null\r\n    if (this.shouldUseTreeSitterParser(languageId)) {\r\n      return (\r\n        this.treeSitterGrammarsById[languageId] ||\r\n        this.textmateRegistry.grammarForScopeName(languageId)\r\n      )\r\n    } else {\r\n      return (\r\n        this.textmateRegistry.grammarForScopeName(languageId) ||\r\n        this.treeSitterGrammarsById[languageId]\r\n      )\r\n    }\r\n  }\r", "name": "shouldUseTreeSitterParser", "func_location": "GrammarRegistry.grammarForId", "args": ["languageId"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 315, "func_start_line": 313}}, {"func_info": {"comment": [], "name": "GrammarRegistry.grammarForId", "params": ["languageId"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 326, "start_line": 313}, "call_info": {"func_end_line": 454, "code": "  grammarForScopeName (scopeName) {\r\n    return this.grammarForId(scopeName)\r\n  }\r", "name": "grammarForId", "func_location": "GrammarRegistry.grammarForScopeName", "args": ["scopeName"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 453, "func_start_line": 452}}, {"func_info": {"comment": [" Extended: Get the `languageId` that has been explicitly assigned to", " to the given buffer, if any.", "", " Returns a {String} id of the language"], "name": "GrammarRegistry.getAssignedLanguageId", "params": ["buffer"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 151, "start_line": 149}, "call_info": {"func_end_line": 337, "comment": [" Deprecated: Get the grammar override for the given file path.", "", " * `filePath` A {String} file path.", "", " Returns a {String} such as `\"source.js\"`."], "code": "  grammarOverrideForPath (filePath) {\r\n    Grim.deprecate('Use buffer.getLanguageMode().getLanguageId() instead')\r\n    const buffer = atom.project.findBufferForPath(filePath)\r\n    if (buffer) return this.getAssignedLanguageId(buffer)\r\n  }\r", "name": "getAssignedLanguageId", "func_location": "GrammarRegistry.grammarOverrideForPath", "args": ["buffer"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 336, "func_start_line": 333}}, {"func_info": {"comment": [], "name": "WorkspaceElement.checkCleanupDockHoverEvents", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 208, "start_line": 204}, "call_info": {"func_end_line": 176, "code": "  handleCenterEnter (event) {\r\n    // Just re-entering the center isn't enough to hide the dock toggle buttons, since they poke\r\n    // into the center and we want to give an affordance.\r\n    this.cursorInCenter = true\r\n    this.checkCleanupDockHoverEvents()\r\n  }\r", "name": "checkCleanupDockHoverEvents", "func_location": "WorkspaceElement.handleCenterEnter", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 175, "func_start_line": 171}}, {"func_info": {"comment": [], "name": "WorkspaceElement.updateHoveredDock", "params": ["mousePosition"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 202, "start_line": 194}, "call_info": {"func_end_line": 184, "code": "  handleCenterLeave (event) {\r\n    // If the cursor leaves the center, we start listening to determine whether one of the docs is\r\n    // being hovered.\r\n    this.cursorInCenter = false\r\n    this.updateHoveredDock({x: event.pageX, y: event.pageY})\r\n    window.addEventListener('dragend', this.handleDockDragEnd)\r\n  }\r", "name": "updateHoveredDock", "func_location": "WorkspaceElement.handleCenterLeave", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 182, "func_start_line": 178}}, {"func_info": {"comment": [], "name": "Dock.setState", "params": ["newState"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 177, "start_line": 144}, "call_info": {"func_end_line": 255, "code": "  handleDidAddPaneItem () {\r\n    if (this.state.size == null) {\r\n      this.setState({size: this.getInitialSize()})\r\n    }\r\n  }\r", "name": "setState", "func_location": "Dock.handleDidAddPaneItem", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 253, "func_start_line": 251}}, {"func_info": {"comment": [], "name": "Dock.getInitialSize", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 414, "start_line": 407}, "call_info": {"func_end_line": 255, "code": "  handleDidAddPaneItem () {\r\n    if (this.state.size == null) {\r\n      this.setState({size: this.getInitialSize()})\r\n    }\r\n  }\r", "name": "getInitialSize", "func_location": "Dock.handleDidAddPaneItem", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 253, "func_start_line": 251}}, {"func_info": {"comment": [], "name": "Dock.setState", "params": ["newState"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 177, "start_line": 144}, "call_info": {"func_end_line": 262, "code": "  handleDidRemovePaneItem () {\r\n    // Hide the dock if you remove the last item.\r\n    if (this.paneContainer.getPaneItems().length === 0) {\r\n      this.setState({visible: false, hovered: false, size: null})\r\n    }\r\n  }\r", "name": "setState", "func_location": "Dock.handleDidRemovePaneItem", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 260, "func_start_line": 257}}, {"func_info": {"comment": [], "name": "WorkspaceElement.updateHoveredDock", "params": ["mousePosition"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 202, "start_line": 194}, "call_info": {"func_end_line": 192, "code": "  handleDockDragEnd (event) {\r\n    this.updateHoveredDock({x: event.pageX, y: event.pageY})\r\n  }\r", "name": "updateHoveredDock", "func_location": "WorkspaceElement.handleDockDragEnd", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 191, "func_start_line": 190}}, {"func_info": {"comment": [" Determine whether the cursor is within the dock hover area. This isn't as simple as just using", " mouseenter/leave because we want to be a little more forgiving. For example, if the cursor is", " over the footer, we want to show the bottom dock's toggle button. Also note that our criteria", " for detecting entry are different than detecting exit but, in order for us to avoid jitter, the", " area considered when detecting exit MUST fully encompass the area considered when detecting", " entry."], "name": "Dock.pointWithinHoverArea", "params": ["point", "detectingExit"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 405, "start_line": 333}, "call_info": {"func_end_line": 315, "code": "  handleDrag (event) {\r\n    if (!this.pointWithinHoverArea({x: event.pageX, y: event.pageY}, true)) {\r\n      this.draggedOut()\r\n    }\r\n  }\r", "name": "pointWithinHoverArea", "func_location": "Dock.handleDrag", "args": [null, {"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 312, "func_start_line": 311}}, {"func_info": {"comment": [], "name": "Dock.draggedOut", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 325, "start_line": 321}, "call_info": {"func_end_line": 315, "code": "  handleDrag (event) {\r\n    if (!this.pointWithinHoverArea({x: event.pageX, y: event.pageY}, true)) {\r\n      this.draggedOut()\r\n    }\r\n  }\r", "name": "draggedOut", "func_location": "Dock.handleDrag", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 313, "func_start_line": 311}}, {"func_info": {"comment": [], "name": "WorkspaceElement.dragEnded", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 169, "start_line": 165}, "call_info": {"func_end_line": 159, "code": "  handleDragEnd (event) {\r\n    this.dragEnded()\r\n  }\r", "name": "dragEnded", "func_location": "WorkspaceElement.handleDragEnd", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 158, "func_start_line": 157}}, {"func_info": {"comment": [], "name": "Dock.draggedOut", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 325, "start_line": 321}, "call_info": {"func_end_line": 319, "code": "  handleDragEnd () {\r\n    this.draggedOut()\r\n  }\r", "name": "draggedOut", "func_location": "Dock.handleDragEnd", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 318, "func_start_line": 317}}, {"func_info": {"comment": [], "name": "isTab", "params": ["element"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 358, "start_line": 351}, "call_info": {"func_end_line": 155, "code": "  handleDragStart (event) {\r\n    if (!isTab(event.target)) return\r\n    const {item} = event.target\r\n    if (!item) return\r\n    this.model.setDraggingItem(item)\r\n    window.addEventListener('dragend', this.handleDragEnd, true)\r\n    window.addEventListener('drop', this.handleDrop, true)\r\n  }\r", "name": "isTab", "func_location": "WorkspaceElement.handleDragStart", "args": ["event.target"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 149, "func_start_line": 148}}, {"func_info": {"comment": [], "name": "WorkspaceElement.dragEnded", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 169, "start_line": 165}, "call_info": {"func_end_line": 163, "code": "  handleDrop (event) {\r\n    this.dragEnded()\r\n  }\r", "name": "dragEnded", "func_location": "WorkspaceElement.handleDrop", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 162, "func_start_line": 161}}, {"func_info": {"comment": [], "name": "WorkspaceElement.updateHoveredDock", "params": ["mousePosition"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 202, "start_line": 194}, "call_info": {"func_end_line": 188, "code": "  handleEdgesMouseMove (event) {\r\n    this.updateHoveredDock({x: event.pageX, y: event.pageY})\r\n  }\r", "name": "updateHoveredDock", "func_location": "WorkspaceElement.handleEdgesMouseMove", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 187, "func_start_line": 186}}, {"func_info": {"comment": [], "name": "AtomWindow.setupContextMenu", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "end_line": 150, "start_line": 144}, "call_info": {"func_end_line": 225, "code": "  handleEvents () {\r\n    this.browserWindow.on('close', async event => {\r\n      if (!this.atomApplication.quitting && !this.unloading) {\r\n        event.preventDefault()\r\n        this.unloading = true\r\n        this.atomApplication.saveCurrentWindowOptions(false)\r\n        if (await this.prepareToUnload()) this.close()\r\n      }\r\n    })\r\n\r\n    this.browserWindow.on('closed', () => {\r\n      this.fileRecoveryService.didCloseWindow(this)\r\n      this.atomApplication.removeWindow(this)\r\n      this.resolveClosedPromise()\r\n    })\r\n\r\n    this.browserWindow.on('unresponsive', () => {\r\n      if (this.isSpec) return\r\n      dialog.showMessageBox(this.browserWindow, {\r\n        type: 'warning',\r\n        buttons: ['Force Close', 'Keep Waiting'],\r\n        cancelId: 1, // Canceling should be the least destructive action\r\n        message: 'Editor is not responding',\r\n        detail:\r\n          'The editor is not responding. Would you like to force close it or just keep waiting?'\r\n      }, response => { if (response === 0) this.browserWindow.destroy() })\r\n    })\r\n\r\n    this.browserWindow.webContents.on('crashed', async () => {\r\n      if (this.headless) {\r\n        console.log('Renderer process crashed, exiting')\r\n        this.atomApplication.exit(100)\r\n        return\r\n      }\r\n\r\n      await this.fileRecoveryService.didCrashWindow(this)\r\n      dialog.showMessageBox(this.browserWindow, {\r\n        type: 'warning',\r\n        buttons: ['Close Window', 'Reload', 'Keep It Open'],\r\n        cancelId: 2, // Canceling should be the least destructive action\r\n        message: 'The editor has crashed',\r\n        detail: 'Please report this issue to https://github.com/atom/atom'\r\n      }, response => {\r\n        switch (response) {\r\n          case 0: return this.browserWindow.destroy()\r\n          case 1: return this.browserWindow.reload()\r\n        }\r\n      })\r\n    })\r\n\r\n    this.browserWindow.webContents.on('will-navigate', (event, url) => {\r\n      if (url !== this.browserWindow.webContents.getURL()) event.preventDefault()\r\n    })\r\n\r\n    this.setupContextMenu()\r\n\r\n    // Spec window's web view should always have focus\r\n    if (this.isSpec) this.browserWindow.on('blur', () => this.browserWindow.focusOnWebView())\r\n  }\r", "name": "setupContextMenu", "func_location": "AtomWindow.handleEvents", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "line": 221, "func_start_line": 167}}, {"func_info": {"comment": ["\r\n  Section: Helper Methods\r\n  ", " Helper method to pass data line by line.", "", " * `stream` The Stream to read from.", " * `onLines` The callback to call with each line of data.", " * `onDone` The callback to call when the stream has closed."], "name": "BufferedProcess.bufferStream", "params": ["stream", "onLines", "onDone"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "end_line": 157, "start_line": 134}, "call_info": {"func_end_line": 295, "name": "bufferStream", "func_location": "BufferedProcess.handleEvents", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "line": 269, "func_start_line": 252}}, {"func_info": {"comment": ["\r\n  Section: Helper Methods\r\n  ", " Helper method to pass data line by line.", "", " * `stream` The Stream to read from.", " * `onLines` The callback to call with each line of data.", " * `onDone` The callback to call when the stream has closed."], "name": "BufferedProcess.bufferStream", "params": ["stream", "onLines", "onDone"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "end_line": 157, "start_line": 134}, "call_info": {"func_end_line": 295, "name": "bufferStream", "func_location": "BufferedProcess.handleEvents", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "line": 277, "func_start_line": 252}}, {"func_info": {"comment": [" Public: Open the given path in the focused window when the event is", " triggered.", "", " A new window will be created if there is no currently focused window.", "", " eventName - The event to listen for.", " pathToOpen - The path to open when the event is triggered."], "name": "AtomApplication.openPathOnEvent", "params": ["eventName", "pathToOpen"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 729, "start_line": 720}, "call_info": {"func_end_line": 634, "comment": [" Registers basic application commands, non-idempotent."], "code": "  handleEvents () {\r\n    const getLoadSettings = () => {\r\n      const window = this.focusedWindow()\r\n      return {devMode: window && window.devMode, safeMode: window && window.safeMode}\r\n    }\r\n\r\n    this.on('application:quit', () => app.quit())\r\n    this.on('application:new-window', () => this.openPath(getLoadSettings()))\r\n    this.on('application:new-file', () => (this.focusedWindow() || this).openPath())\r\n    this.on('application:open-dev', () => this.promptForPathToOpen('all', {devMode: true}))\r\n    this.on('application:open-safe', () => this.promptForPathToOpen('all', {safeMode: true}))\r\n    this.on('application:inspect', ({x, y, atomWindow}) => {\r\n      if (!atomWindow) atomWindow = this.focusedWindow()\r\n      if (atomWindow) atomWindow.browserWindow.inspectElement(x, y)\r\n    })\r\n\r\n    this.on('application:open-documentation', () => shell.openExternal('http://flight-manual.atom.io'))\r\n    this.on('application:open-discussions', () => shell.openExternal('https://discuss.atom.io'))\r\n    this.on('application:open-faq', () => shell.openExternal('https://atom.io/faq'))\r\n    this.on('application:open-terms-of-use', () => shell.openExternal('https://atom.io/terms'))\r\n    this.on('application:report-issue', () => shell.openExternal('https://github.com/atom/atom/blob/master/CONTRIBUTING.md#reporting-bugs'))\r\n    this.on('application:search-issues', () => shell.openExternal('https://github.com/search?q=+is%3Aissue+user%3Aatom'))\r\n\r\n    this.on('application:install-update', () => {\r\n      this.quitting = true\r\n      this.autoUpdateManager.install()\r\n    })\r\n\r\n    this.on('application:check-for-update', () => this.autoUpdateManager.check())\r\n\r\n    if (process.platform === 'darwin') {\r\n      this.on('application:bring-all-windows-to-front', () => Menu.sendActionToFirstResponder('arrangeInFront:'))\r\n      this.on('application:hide', () => Menu.sendActionToFirstResponder('hide:'))\r\n      this.on('application:hide-other-applications', () => Menu.sendActionToFirstResponder('hideOtherApplications:'))\r\n      this.on('application:minimize', () => Menu.sendActionToFirstResponder('performMiniaturize:'))\r\n      this.on('application:unhide-all-applications', () => Menu.sendActionToFirstResponder('unhideAllApplications:'))\r\n      this.on('application:zoom', () => Menu.sendActionToFirstResponder('zoom:'))\r\n    } else {\r\n      this.on('application:minimize', () => {\r\n        const window = this.focusedWindow()\r\n        if (window) window.minimize()\r\n      })\r\n      this.on('application:zoom', function () {\r\n        const window = this.focusedWindow()\r\n        if (window) window.maximize()\r\n      })\r\n    }\r\n\r\n    this.openPathOnEvent('application:about', 'atom://about')\r\n    this.openPathOnEvent('application:show-settings', 'atom://config')\r\n    this.openPathOnEvent('application:open-your-config', 'atom://.atom/config')\r\n    this.openPathOnEvent('application:open-your-init-script', 'atom://.atom/init-script')\r\n    this.openPathOnEvent('application:open-your-keymap', 'atom://.atom/keymap')\r\n    this.openPathOnEvent('application:open-your-snippets', 'atom://.atom/snippets')\r\n    this.openPathOnEvent('application:open-your-stylesheet', 'atom://.atom/stylesheet')\r\n    this.openPathOnEvent('application:open-license', path.join(process.resourcesPath, 'LICENSE.md'))\r\n\r\n    this.configFile.onDidChange(settings => {\r\n      for (let window of this.getAllWindows()) {\r\n        window.didChangeUserSettings(settings)\r\n      }\r\n      this.config.resetUserSettings(settings)\r\n    })\r\n\r\n    this.configFile.onDidError(message => {\r\n      const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n      if (window) window.didFailToReadUserSettings(message)\r\n    })\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'before-quit', async event => {\r\n      let resolveBeforeQuitPromise\r\n      this.lastBeforeQuitPromise = new Promise(resolve => { resolveBeforeQuitPromise = resolve })\r\n\r\n      if (!this.quitting) {\r\n        this.quitting = true\r\n        event.preventDefault()\r\n        const windowUnloadPromises = this.getAllWindows().map(async window => {\r\n          const unloaded = await window.prepareToUnload()\r\n          if (unloaded) {\r\n            window.close()\r\n            await window.closedPromise\r\n          }\r\n          return unloaded\r\n        })\r\n        const windowUnloadedResults = await Promise.all(windowUnloadPromises)\r\n        if (windowUnloadedResults.every(Boolean)) {\r\n          app.quit()\r\n        } else {\r\n          this.quitting = false\r\n        }\r\n      }\r\n\r\n      resolveBeforeQuitPromise()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'will-quit', () => {\r\n      this.killAllProcesses()\r\n      this.deleteSocketFile()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-file', (event, pathToOpen) => {\r\n      event.preventDefault()\r\n      this.openPath({pathToOpen})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-url', (event, urlToOpen) => {\r\n      event.preventDefault()\r\n      this.openUrl({urlToOpen, devMode: this.devMode, safeMode: this.safeMode})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'activate', (event, hasVisibleWindows) => {\r\n      if (hasVisibleWindows) return\r\n      if (event) event.preventDefault()\r\n      this.emit('application:new-window')\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'restart-application', () => {\r\n      this.restart()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'resolve-proxy', (event, requestId, url) => {\r\n      event.sender.session.resolveProxy(url, proxy => {\r\n        if (!event.sender.isDestroyed()) event.sender.send('did-resolve-proxy', requestId, proxy)\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-history-manager', event => {\r\n      for (let atomWindow of this.getAllWindows()) {\r\n        const {webContents} = atomWindow.browserWindow\r\n        if (webContents !== event.sender) webContents.send('did-change-history-manager')\r\n      }\r\n    }))\r\n\r\n    // A request from the associated render process to open a new render process.\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open', (event, options) => {\r\n      const window = this.atomWindowForEvent(event)\r\n      if (options) {\r\n        if (typeof options.pathsToOpen === 'string') {\r\n          options.pathsToOpen = [options.pathsToOpen]\r\n        }\r\n\r\n        if (options.pathsToOpen && options.pathsToOpen.length > 0) {\r\n          options.window = window\r\n          this.openPaths(options)\r\n        } else {\r\n          this.addWindow(new AtomWindow(this, this.fileRecoveryService, options))\r\n        }\r\n      } else {\r\n        this.promptForPathToOpen('all', {window})\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'update-application-menu', (event, template, menu) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      if (this.applicationMenu) this.applicationMenu.update(window, template, menu)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-package-specs', (event, packageSpecPath, options = {}) => {\r\n      this.runTests(Object.assign({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [packageSpecPath],\r\n        headless: false\r\n      }, options))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-benchmarks', (event, benchmarksPath) => {\r\n      this.runBenchmarks({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [benchmarksPath],\r\n        headless: false,\r\n        test: false\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'command', (event, command) => {\r\n      this.emit(command)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open-command', (event, command, defaultPath) => {\r\n      switch (command) {\r\n        case 'application:open':\r\n          return this.promptForPathToOpen('all', getLoadSettings(), defaultPath)\r\n        case 'application:open-file':\r\n          return this.promptForPathToOpen('file', getLoadSettings(), defaultPath)\r\n        case 'application:open-folder':\r\n          return this.promptForPathToOpen('folder', getLoadSettings(), defaultPath)\r\n        default:\r\n          return console.log(`Invalid open-command received: ${command}`)\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'window-command', (event, command, ...args) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      return window.emit(command, ...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('window-method', (browserWindow, method, ...args) => {\r\n      const window = this.atomWindowForBrowserWindow(browserWindow)\r\n      if (window) window[method](...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'pick-folder', (event, responseChannel) => {\r\n      this.promptForPath('folder', paths => event.sender.send(responseChannel, paths))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-size', (window, width, height) => {\r\n      window.setSize(width, height)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-position', (window, x, y) => {\r\n      window.setPosition(x, y)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-user-settings', (window, settings, filePath) => {\r\n      if (!this.quitting) {\r\n        return ConfigFile.at(filePath || this.configFilePath).update(JSON.parse(settings))\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('center-window', window => window.center()))\r\n    this.disposable.add(ipcHelpers.respondTo('focus-window', window => window.focus()))\r\n    this.disposable.add(ipcHelpers.respondTo('show-window', window => window.show()))\r\n    this.disposable.add(ipcHelpers.respondTo('hide-window', window => window.hide()))\r\n    this.disposable.add(ipcHelpers.respondTo('get-temporary-window-state', window => window.temporaryState))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-temporary-window-state', (win, state) => {\r\n      win.temporaryState = state\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-text-to-selection-clipboard', (event, text) =>\r\n      clipboard.writeText(text, 'selection')\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stdout', (event, output) =>\r\n      process.stdout.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stderr', (event, output) =>\r\n      process.stderr.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'add-recent-document', (event, filename) =>\r\n      app.addRecentDocument(filename)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'execute-javascript-in-dev-tools', (event, code) =>\r\n      event.sender.devToolsWebContents && event.sender.devToolsWebContents.executeJavaScript(code)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-state', event => {\r\n      event.returnValue = this.autoUpdateManager.getState()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-error', event => {\r\n      event.returnValue = this.autoUpdateManager.getErrorMessage()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('will-save-path', (window, path) =>\r\n      this.fileRecoveryService.willSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('did-save-path', (window, path) =>\r\n      this.fileRecoveryService.didSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-paths', () =>\r\n      this.saveCurrentWindowOptions(false)\r\n    ))\r\n\r\n    this.disposable.add(this.disableZoomOnDisplayChange())\r\n  }\r", "name": "openPathOnEvent", "func_location": "AtomApplication.handleEvents", "args": [{"type": "string"}, {"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 412, "func_start_line": 364}}, {"func_info": {"comment": [" Public: Open the given path in the focused window when the event is", " triggered.", "", " A new window will be created if there is no currently focused window.", "", " eventName - The event to listen for.", " pathToOpen - The path to open when the event is triggered."], "name": "AtomApplication.openPathOnEvent", "params": ["eventName", "pathToOpen"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 729, "start_line": 720}, "call_info": {"func_end_line": 634, "comment": [" Registers basic application commands, non-idempotent."], "code": "  handleEvents () {\r\n    const getLoadSettings = () => {\r\n      const window = this.focusedWindow()\r\n      return {devMode: window && window.devMode, safeMode: window && window.safeMode}\r\n    }\r\n\r\n    this.on('application:quit', () => app.quit())\r\n    this.on('application:new-window', () => this.openPath(getLoadSettings()))\r\n    this.on('application:new-file', () => (this.focusedWindow() || this).openPath())\r\n    this.on('application:open-dev', () => this.promptForPathToOpen('all', {devMode: true}))\r\n    this.on('application:open-safe', () => this.promptForPathToOpen('all', {safeMode: true}))\r\n    this.on('application:inspect', ({x, y, atomWindow}) => {\r\n      if (!atomWindow) atomWindow = this.focusedWindow()\r\n      if (atomWindow) atomWindow.browserWindow.inspectElement(x, y)\r\n    })\r\n\r\n    this.on('application:open-documentation', () => shell.openExternal('http://flight-manual.atom.io'))\r\n    this.on('application:open-discussions', () => shell.openExternal('https://discuss.atom.io'))\r\n    this.on('application:open-faq', () => shell.openExternal('https://atom.io/faq'))\r\n    this.on('application:open-terms-of-use', () => shell.openExternal('https://atom.io/terms'))\r\n    this.on('application:report-issue', () => shell.openExternal('https://github.com/atom/atom/blob/master/CONTRIBUTING.md#reporting-bugs'))\r\n    this.on('application:search-issues', () => shell.openExternal('https://github.com/search?q=+is%3Aissue+user%3Aatom'))\r\n\r\n    this.on('application:install-update', () => {\r\n      this.quitting = true\r\n      this.autoUpdateManager.install()\r\n    })\r\n\r\n    this.on('application:check-for-update', () => this.autoUpdateManager.check())\r\n\r\n    if (process.platform === 'darwin') {\r\n      this.on('application:bring-all-windows-to-front', () => Menu.sendActionToFirstResponder('arrangeInFront:'))\r\n      this.on('application:hide', () => Menu.sendActionToFirstResponder('hide:'))\r\n      this.on('application:hide-other-applications', () => Menu.sendActionToFirstResponder('hideOtherApplications:'))\r\n      this.on('application:minimize', () => Menu.sendActionToFirstResponder('performMiniaturize:'))\r\n      this.on('application:unhide-all-applications', () => Menu.sendActionToFirstResponder('unhideAllApplications:'))\r\n      this.on('application:zoom', () => Menu.sendActionToFirstResponder('zoom:'))\r\n    } else {\r\n      this.on('application:minimize', () => {\r\n        const window = this.focusedWindow()\r\n        if (window) window.minimize()\r\n      })\r\n      this.on('application:zoom', function () {\r\n        const window = this.focusedWindow()\r\n        if (window) window.maximize()\r\n      })\r\n    }\r\n\r\n    this.openPathOnEvent('application:about', 'atom://about')\r\n    this.openPathOnEvent('application:show-settings', 'atom://config')\r\n    this.openPathOnEvent('application:open-your-config', 'atom://.atom/config')\r\n    this.openPathOnEvent('application:open-your-init-script', 'atom://.atom/init-script')\r\n    this.openPathOnEvent('application:open-your-keymap', 'atom://.atom/keymap')\r\n    this.openPathOnEvent('application:open-your-snippets', 'atom://.atom/snippets')\r\n    this.openPathOnEvent('application:open-your-stylesheet', 'atom://.atom/stylesheet')\r\n    this.openPathOnEvent('application:open-license', path.join(process.resourcesPath, 'LICENSE.md'))\r\n\r\n    this.configFile.onDidChange(settings => {\r\n      for (let window of this.getAllWindows()) {\r\n        window.didChangeUserSettings(settings)\r\n      }\r\n      this.config.resetUserSettings(settings)\r\n    })\r\n\r\n    this.configFile.onDidError(message => {\r\n      const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n      if (window) window.didFailToReadUserSettings(message)\r\n    })\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'before-quit', async event => {\r\n      let resolveBeforeQuitPromise\r\n      this.lastBeforeQuitPromise = new Promise(resolve => { resolveBeforeQuitPromise = resolve })\r\n\r\n      if (!this.quitting) {\r\n        this.quitting = true\r\n        event.preventDefault()\r\n        const windowUnloadPromises = this.getAllWindows().map(async window => {\r\n          const unloaded = await window.prepareToUnload()\r\n          if (unloaded) {\r\n            window.close()\r\n            await window.closedPromise\r\n          }\r\n          return unloaded\r\n        })\r\n        const windowUnloadedResults = await Promise.all(windowUnloadPromises)\r\n        if (windowUnloadedResults.every(Boolean)) {\r\n          app.quit()\r\n        } else {\r\n          this.quitting = false\r\n        }\r\n      }\r\n\r\n      resolveBeforeQuitPromise()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'will-quit', () => {\r\n      this.killAllProcesses()\r\n      this.deleteSocketFile()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-file', (event, pathToOpen) => {\r\n      event.preventDefault()\r\n      this.openPath({pathToOpen})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-url', (event, urlToOpen) => {\r\n      event.preventDefault()\r\n      this.openUrl({urlToOpen, devMode: this.devMode, safeMode: this.safeMode})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'activate', (event, hasVisibleWindows) => {\r\n      if (hasVisibleWindows) return\r\n      if (event) event.preventDefault()\r\n      this.emit('application:new-window')\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'restart-application', () => {\r\n      this.restart()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'resolve-proxy', (event, requestId, url) => {\r\n      event.sender.session.resolveProxy(url, proxy => {\r\n        if (!event.sender.isDestroyed()) event.sender.send('did-resolve-proxy', requestId, proxy)\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-history-manager', event => {\r\n      for (let atomWindow of this.getAllWindows()) {\r\n        const {webContents} = atomWindow.browserWindow\r\n        if (webContents !== event.sender) webContents.send('did-change-history-manager')\r\n      }\r\n    }))\r\n\r\n    // A request from the associated render process to open a new render process.\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open', (event, options) => {\r\n      const window = this.atomWindowForEvent(event)\r\n      if (options) {\r\n        if (typeof options.pathsToOpen === 'string') {\r\n          options.pathsToOpen = [options.pathsToOpen]\r\n        }\r\n\r\n        if (options.pathsToOpen && options.pathsToOpen.length > 0) {\r\n          options.window = window\r\n          this.openPaths(options)\r\n        } else {\r\n          this.addWindow(new AtomWindow(this, this.fileRecoveryService, options))\r\n        }\r\n      } else {\r\n        this.promptForPathToOpen('all', {window})\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'update-application-menu', (event, template, menu) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      if (this.applicationMenu) this.applicationMenu.update(window, template, menu)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-package-specs', (event, packageSpecPath, options = {}) => {\r\n      this.runTests(Object.assign({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [packageSpecPath],\r\n        headless: false\r\n      }, options))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-benchmarks', (event, benchmarksPath) => {\r\n      this.runBenchmarks({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [benchmarksPath],\r\n        headless: false,\r\n        test: false\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'command', (event, command) => {\r\n      this.emit(command)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open-command', (event, command, defaultPath) => {\r\n      switch (command) {\r\n        case 'application:open':\r\n          return this.promptForPathToOpen('all', getLoadSettings(), defaultPath)\r\n        case 'application:open-file':\r\n          return this.promptForPathToOpen('file', getLoadSettings(), defaultPath)\r\n        case 'application:open-folder':\r\n          return this.promptForPathToOpen('folder', getLoadSettings(), defaultPath)\r\n        default:\r\n          return console.log(`Invalid open-command received: ${command}`)\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'window-command', (event, command, ...args) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      return window.emit(command, ...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('window-method', (browserWindow, method, ...args) => {\r\n      const window = this.atomWindowForBrowserWindow(browserWindow)\r\n      if (window) window[method](...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'pick-folder', (event, responseChannel) => {\r\n      this.promptForPath('folder', paths => event.sender.send(responseChannel, paths))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-size', (window, width, height) => {\r\n      window.setSize(width, height)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-position', (window, x, y) => {\r\n      window.setPosition(x, y)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-user-settings', (window, settings, filePath) => {\r\n      if (!this.quitting) {\r\n        return ConfigFile.at(filePath || this.configFilePath).update(JSON.parse(settings))\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('center-window', window => window.center()))\r\n    this.disposable.add(ipcHelpers.respondTo('focus-window', window => window.focus()))\r\n    this.disposable.add(ipcHelpers.respondTo('show-window', window => window.show()))\r\n    this.disposable.add(ipcHelpers.respondTo('hide-window', window => window.hide()))\r\n    this.disposable.add(ipcHelpers.respondTo('get-temporary-window-state', window => window.temporaryState))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-temporary-window-state', (win, state) => {\r\n      win.temporaryState = state\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-text-to-selection-clipboard', (event, text) =>\r\n      clipboard.writeText(text, 'selection')\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stdout', (event, output) =>\r\n      process.stdout.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stderr', (event, output) =>\r\n      process.stderr.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'add-recent-document', (event, filename) =>\r\n      app.addRecentDocument(filename)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'execute-javascript-in-dev-tools', (event, code) =>\r\n      event.sender.devToolsWebContents && event.sender.devToolsWebContents.executeJavaScript(code)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-state', event => {\r\n      event.returnValue = this.autoUpdateManager.getState()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-error', event => {\r\n      event.returnValue = this.autoUpdateManager.getErrorMessage()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('will-save-path', (window, path) =>\r\n      this.fileRecoveryService.willSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('did-save-path', (window, path) =>\r\n      this.fileRecoveryService.didSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-paths', () =>\r\n      this.saveCurrentWindowOptions(false)\r\n    ))\r\n\r\n    this.disposable.add(this.disableZoomOnDisplayChange())\r\n  }\r", "name": "openPathOnEvent", "func_location": "AtomApplication.handleEvents", "args": [{"type": "string"}, {"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 413, "func_start_line": 364}}, {"func_info": {"comment": [" Public: Open the given path in the focused window when the event is", " triggered.", "", " A new window will be created if there is no currently focused window.", "", " eventName - The event to listen for.", " pathToOpen - The path to open when the event is triggered."], "name": "AtomApplication.openPathOnEvent", "params": ["eventName", "pathToOpen"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 729, "start_line": 720}, "call_info": {"func_end_line": 634, "comment": [" Registers basic application commands, non-idempotent."], "code": "  handleEvents () {\r\n    const getLoadSettings = () => {\r\n      const window = this.focusedWindow()\r\n      return {devMode: window && window.devMode, safeMode: window && window.safeMode}\r\n    }\r\n\r\n    this.on('application:quit', () => app.quit())\r\n    this.on('application:new-window', () => this.openPath(getLoadSettings()))\r\n    this.on('application:new-file', () => (this.focusedWindow() || this).openPath())\r\n    this.on('application:open-dev', () => this.promptForPathToOpen('all', {devMode: true}))\r\n    this.on('application:open-safe', () => this.promptForPathToOpen('all', {safeMode: true}))\r\n    this.on('application:inspect', ({x, y, atomWindow}) => {\r\n      if (!atomWindow) atomWindow = this.focusedWindow()\r\n      if (atomWindow) atomWindow.browserWindow.inspectElement(x, y)\r\n    })\r\n\r\n    this.on('application:open-documentation', () => shell.openExternal('http://flight-manual.atom.io'))\r\n    this.on('application:open-discussions', () => shell.openExternal('https://discuss.atom.io'))\r\n    this.on('application:open-faq', () => shell.openExternal('https://atom.io/faq'))\r\n    this.on('application:open-terms-of-use', () => shell.openExternal('https://atom.io/terms'))\r\n    this.on('application:report-issue', () => shell.openExternal('https://github.com/atom/atom/blob/master/CONTRIBUTING.md#reporting-bugs'))\r\n    this.on('application:search-issues', () => shell.openExternal('https://github.com/search?q=+is%3Aissue+user%3Aatom'))\r\n\r\n    this.on('application:install-update', () => {\r\n      this.quitting = true\r\n      this.autoUpdateManager.install()\r\n    })\r\n\r\n    this.on('application:check-for-update', () => this.autoUpdateManager.check())\r\n\r\n    if (process.platform === 'darwin') {\r\n      this.on('application:bring-all-windows-to-front', () => Menu.sendActionToFirstResponder('arrangeInFront:'))\r\n      this.on('application:hide', () => Menu.sendActionToFirstResponder('hide:'))\r\n      this.on('application:hide-other-applications', () => Menu.sendActionToFirstResponder('hideOtherApplications:'))\r\n      this.on('application:minimize', () => Menu.sendActionToFirstResponder('performMiniaturize:'))\r\n      this.on('application:unhide-all-applications', () => Menu.sendActionToFirstResponder('unhideAllApplications:'))\r\n      this.on('application:zoom', () => Menu.sendActionToFirstResponder('zoom:'))\r\n    } else {\r\n      this.on('application:minimize', () => {\r\n        const window = this.focusedWindow()\r\n        if (window) window.minimize()\r\n      })\r\n      this.on('application:zoom', function () {\r\n        const window = this.focusedWindow()\r\n        if (window) window.maximize()\r\n      })\r\n    }\r\n\r\n    this.openPathOnEvent('application:about', 'atom://about')\r\n    this.openPathOnEvent('application:show-settings', 'atom://config')\r\n    this.openPathOnEvent('application:open-your-config', 'atom://.atom/config')\r\n    this.openPathOnEvent('application:open-your-init-script', 'atom://.atom/init-script')\r\n    this.openPathOnEvent('application:open-your-keymap', 'atom://.atom/keymap')\r\n    this.openPathOnEvent('application:open-your-snippets', 'atom://.atom/snippets')\r\n    this.openPathOnEvent('application:open-your-stylesheet', 'atom://.atom/stylesheet')\r\n    this.openPathOnEvent('application:open-license', path.join(process.resourcesPath, 'LICENSE.md'))\r\n\r\n    this.configFile.onDidChange(settings => {\r\n      for (let window of this.getAllWindows()) {\r\n        window.didChangeUserSettings(settings)\r\n      }\r\n      this.config.resetUserSettings(settings)\r\n    })\r\n\r\n    this.configFile.onDidError(message => {\r\n      const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n      if (window) window.didFailToReadUserSettings(message)\r\n    })\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'before-quit', async event => {\r\n      let resolveBeforeQuitPromise\r\n      this.lastBeforeQuitPromise = new Promise(resolve => { resolveBeforeQuitPromise = resolve })\r\n\r\n      if (!this.quitting) {\r\n        this.quitting = true\r\n        event.preventDefault()\r\n        const windowUnloadPromises = this.getAllWindows().map(async window => {\r\n          const unloaded = await window.prepareToUnload()\r\n          if (unloaded) {\r\n            window.close()\r\n            await window.closedPromise\r\n          }\r\n          return unloaded\r\n        })\r\n        const windowUnloadedResults = await Promise.all(windowUnloadPromises)\r\n        if (windowUnloadedResults.every(Boolean)) {\r\n          app.quit()\r\n        } else {\r\n          this.quitting = false\r\n        }\r\n      }\r\n\r\n      resolveBeforeQuitPromise()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'will-quit', () => {\r\n      this.killAllProcesses()\r\n      this.deleteSocketFile()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-file', (event, pathToOpen) => {\r\n      event.preventDefault()\r\n      this.openPath({pathToOpen})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-url', (event, urlToOpen) => {\r\n      event.preventDefault()\r\n      this.openUrl({urlToOpen, devMode: this.devMode, safeMode: this.safeMode})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'activate', (event, hasVisibleWindows) => {\r\n      if (hasVisibleWindows) return\r\n      if (event) event.preventDefault()\r\n      this.emit('application:new-window')\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'restart-application', () => {\r\n      this.restart()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'resolve-proxy', (event, requestId, url) => {\r\n      event.sender.session.resolveProxy(url, proxy => {\r\n        if (!event.sender.isDestroyed()) event.sender.send('did-resolve-proxy', requestId, proxy)\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-history-manager', event => {\r\n      for (let atomWindow of this.getAllWindows()) {\r\n        const {webContents} = atomWindow.browserWindow\r\n        if (webContents !== event.sender) webContents.send('did-change-history-manager')\r\n      }\r\n    }))\r\n\r\n    // A request from the associated render process to open a new render process.\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open', (event, options) => {\r\n      const window = this.atomWindowForEvent(event)\r\n      if (options) {\r\n        if (typeof options.pathsToOpen === 'string') {\r\n          options.pathsToOpen = [options.pathsToOpen]\r\n        }\r\n\r\n        if (options.pathsToOpen && options.pathsToOpen.length > 0) {\r\n          options.window = window\r\n          this.openPaths(options)\r\n        } else {\r\n          this.addWindow(new AtomWindow(this, this.fileRecoveryService, options))\r\n        }\r\n      } else {\r\n        this.promptForPathToOpen('all', {window})\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'update-application-menu', (event, template, menu) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      if (this.applicationMenu) this.applicationMenu.update(window, template, menu)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-package-specs', (event, packageSpecPath, options = {}) => {\r\n      this.runTests(Object.assign({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [packageSpecPath],\r\n        headless: false\r\n      }, options))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-benchmarks', (event, benchmarksPath) => {\r\n      this.runBenchmarks({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [benchmarksPath],\r\n        headless: false,\r\n        test: false\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'command', (event, command) => {\r\n      this.emit(command)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open-command', (event, command, defaultPath) => {\r\n      switch (command) {\r\n        case 'application:open':\r\n          return this.promptForPathToOpen('all', getLoadSettings(), defaultPath)\r\n        case 'application:open-file':\r\n          return this.promptForPathToOpen('file', getLoadSettings(), defaultPath)\r\n        case 'application:open-folder':\r\n          return this.promptForPathToOpen('folder', getLoadSettings(), defaultPath)\r\n        default:\r\n          return console.log(`Invalid open-command received: ${command}`)\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'window-command', (event, command, ...args) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      return window.emit(command, ...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('window-method', (browserWindow, method, ...args) => {\r\n      const window = this.atomWindowForBrowserWindow(browserWindow)\r\n      if (window) window[method](...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'pick-folder', (event, responseChannel) => {\r\n      this.promptForPath('folder', paths => event.sender.send(responseChannel, paths))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-size', (window, width, height) => {\r\n      window.setSize(width, height)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-position', (window, x, y) => {\r\n      window.setPosition(x, y)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-user-settings', (window, settings, filePath) => {\r\n      if (!this.quitting) {\r\n        return ConfigFile.at(filePath || this.configFilePath).update(JSON.parse(settings))\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('center-window', window => window.center()))\r\n    this.disposable.add(ipcHelpers.respondTo('focus-window', window => window.focus()))\r\n    this.disposable.add(ipcHelpers.respondTo('show-window', window => window.show()))\r\n    this.disposable.add(ipcHelpers.respondTo('hide-window', window => window.hide()))\r\n    this.disposable.add(ipcHelpers.respondTo('get-temporary-window-state', window => window.temporaryState))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-temporary-window-state', (win, state) => {\r\n      win.temporaryState = state\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-text-to-selection-clipboard', (event, text) =>\r\n      clipboard.writeText(text, 'selection')\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stdout', (event, output) =>\r\n      process.stdout.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stderr', (event, output) =>\r\n      process.stderr.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'add-recent-document', (event, filename) =>\r\n      app.addRecentDocument(filename)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'execute-javascript-in-dev-tools', (event, code) =>\r\n      event.sender.devToolsWebContents && event.sender.devToolsWebContents.executeJavaScript(code)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-state', event => {\r\n      event.returnValue = this.autoUpdateManager.getState()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-error', event => {\r\n      event.returnValue = this.autoUpdateManager.getErrorMessage()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('will-save-path', (window, path) =>\r\n      this.fileRecoveryService.willSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('did-save-path', (window, path) =>\r\n      this.fileRecoveryService.didSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-paths', () =>\r\n      this.saveCurrentWindowOptions(false)\r\n    ))\r\n\r\n    this.disposable.add(this.disableZoomOnDisplayChange())\r\n  }\r", "name": "openPathOnEvent", "func_location": "AtomApplication.handleEvents", "args": [{"type": "string"}, {"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 414, "func_start_line": 364}}, {"func_info": {"comment": [" Public: Open the given path in the focused window when the event is", " triggered.", "", " A new window will be created if there is no currently focused window.", "", " eventName - The event to listen for.", " pathToOpen - The path to open when the event is triggered."], "name": "AtomApplication.openPathOnEvent", "params": ["eventName", "pathToOpen"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 729, "start_line": 720}, "call_info": {"func_end_line": 634, "comment": [" Registers basic application commands, non-idempotent."], "code": "  handleEvents () {\r\n    const getLoadSettings = () => {\r\n      const window = this.focusedWindow()\r\n      return {devMode: window && window.devMode, safeMode: window && window.safeMode}\r\n    }\r\n\r\n    this.on('application:quit', () => app.quit())\r\n    this.on('application:new-window', () => this.openPath(getLoadSettings()))\r\n    this.on('application:new-file', () => (this.focusedWindow() || this).openPath())\r\n    this.on('application:open-dev', () => this.promptForPathToOpen('all', {devMode: true}))\r\n    this.on('application:open-safe', () => this.promptForPathToOpen('all', {safeMode: true}))\r\n    this.on('application:inspect', ({x, y, atomWindow}) => {\r\n      if (!atomWindow) atomWindow = this.focusedWindow()\r\n      if (atomWindow) atomWindow.browserWindow.inspectElement(x, y)\r\n    })\r\n\r\n    this.on('application:open-documentation', () => shell.openExternal('http://flight-manual.atom.io'))\r\n    this.on('application:open-discussions', () => shell.openExternal('https://discuss.atom.io'))\r\n    this.on('application:open-faq', () => shell.openExternal('https://atom.io/faq'))\r\n    this.on('application:open-terms-of-use', () => shell.openExternal('https://atom.io/terms'))\r\n    this.on('application:report-issue', () => shell.openExternal('https://github.com/atom/atom/blob/master/CONTRIBUTING.md#reporting-bugs'))\r\n    this.on('application:search-issues', () => shell.openExternal('https://github.com/search?q=+is%3Aissue+user%3Aatom'))\r\n\r\n    this.on('application:install-update', () => {\r\n      this.quitting = true\r\n      this.autoUpdateManager.install()\r\n    })\r\n\r\n    this.on('application:check-for-update', () => this.autoUpdateManager.check())\r\n\r\n    if (process.platform === 'darwin') {\r\n      this.on('application:bring-all-windows-to-front', () => Menu.sendActionToFirstResponder('arrangeInFront:'))\r\n      this.on('application:hide', () => Menu.sendActionToFirstResponder('hide:'))\r\n      this.on('application:hide-other-applications', () => Menu.sendActionToFirstResponder('hideOtherApplications:'))\r\n      this.on('application:minimize', () => Menu.sendActionToFirstResponder('performMiniaturize:'))\r\n      this.on('application:unhide-all-applications', () => Menu.sendActionToFirstResponder('unhideAllApplications:'))\r\n      this.on('application:zoom', () => Menu.sendActionToFirstResponder('zoom:'))\r\n    } else {\r\n      this.on('application:minimize', () => {\r\n        const window = this.focusedWindow()\r\n        if (window) window.minimize()\r\n      })\r\n      this.on('application:zoom', function () {\r\n        const window = this.focusedWindow()\r\n        if (window) window.maximize()\r\n      })\r\n    }\r\n\r\n    this.openPathOnEvent('application:about', 'atom://about')\r\n    this.openPathOnEvent('application:show-settings', 'atom://config')\r\n    this.openPathOnEvent('application:open-your-config', 'atom://.atom/config')\r\n    this.openPathOnEvent('application:open-your-init-script', 'atom://.atom/init-script')\r\n    this.openPathOnEvent('application:open-your-keymap', 'atom://.atom/keymap')\r\n    this.openPathOnEvent('application:open-your-snippets', 'atom://.atom/snippets')\r\n    this.openPathOnEvent('application:open-your-stylesheet', 'atom://.atom/stylesheet')\r\n    this.openPathOnEvent('application:open-license', path.join(process.resourcesPath, 'LICENSE.md'))\r\n\r\n    this.configFile.onDidChange(settings => {\r\n      for (let window of this.getAllWindows()) {\r\n        window.didChangeUserSettings(settings)\r\n      }\r\n      this.config.resetUserSettings(settings)\r\n    })\r\n\r\n    this.configFile.onDidError(message => {\r\n      const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n      if (window) window.didFailToReadUserSettings(message)\r\n    })\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'before-quit', async event => {\r\n      let resolveBeforeQuitPromise\r\n      this.lastBeforeQuitPromise = new Promise(resolve => { resolveBeforeQuitPromise = resolve })\r\n\r\n      if (!this.quitting) {\r\n        this.quitting = true\r\n        event.preventDefault()\r\n        const windowUnloadPromises = this.getAllWindows().map(async window => {\r\n          const unloaded = await window.prepareToUnload()\r\n          if (unloaded) {\r\n            window.close()\r\n            await window.closedPromise\r\n          }\r\n          return unloaded\r\n        })\r\n        const windowUnloadedResults = await Promise.all(windowUnloadPromises)\r\n        if (windowUnloadedResults.every(Boolean)) {\r\n          app.quit()\r\n        } else {\r\n          this.quitting = false\r\n        }\r\n      }\r\n\r\n      resolveBeforeQuitPromise()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'will-quit', () => {\r\n      this.killAllProcesses()\r\n      this.deleteSocketFile()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-file', (event, pathToOpen) => {\r\n      event.preventDefault()\r\n      this.openPath({pathToOpen})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-url', (event, urlToOpen) => {\r\n      event.preventDefault()\r\n      this.openUrl({urlToOpen, devMode: this.devMode, safeMode: this.safeMode})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'activate', (event, hasVisibleWindows) => {\r\n      if (hasVisibleWindows) return\r\n      if (event) event.preventDefault()\r\n      this.emit('application:new-window')\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'restart-application', () => {\r\n      this.restart()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'resolve-proxy', (event, requestId, url) => {\r\n      event.sender.session.resolveProxy(url, proxy => {\r\n        if (!event.sender.isDestroyed()) event.sender.send('did-resolve-proxy', requestId, proxy)\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-history-manager', event => {\r\n      for (let atomWindow of this.getAllWindows()) {\r\n        const {webContents} = atomWindow.browserWindow\r\n        if (webContents !== event.sender) webContents.send('did-change-history-manager')\r\n      }\r\n    }))\r\n\r\n    // A request from the associated render process to open a new render process.\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open', (event, options) => {\r\n      const window = this.atomWindowForEvent(event)\r\n      if (options) {\r\n        if (typeof options.pathsToOpen === 'string') {\r\n          options.pathsToOpen = [options.pathsToOpen]\r\n        }\r\n\r\n        if (options.pathsToOpen && options.pathsToOpen.length > 0) {\r\n          options.window = window\r\n          this.openPaths(options)\r\n        } else {\r\n          this.addWindow(new AtomWindow(this, this.fileRecoveryService, options))\r\n        }\r\n      } else {\r\n        this.promptForPathToOpen('all', {window})\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'update-application-menu', (event, template, menu) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      if (this.applicationMenu) this.applicationMenu.update(window, template, menu)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-package-specs', (event, packageSpecPath, options = {}) => {\r\n      this.runTests(Object.assign({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [packageSpecPath],\r\n        headless: false\r\n      }, options))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-benchmarks', (event, benchmarksPath) => {\r\n      this.runBenchmarks({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [benchmarksPath],\r\n        headless: false,\r\n        test: false\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'command', (event, command) => {\r\n      this.emit(command)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open-command', (event, command, defaultPath) => {\r\n      switch (command) {\r\n        case 'application:open':\r\n          return this.promptForPathToOpen('all', getLoadSettings(), defaultPath)\r\n        case 'application:open-file':\r\n          return this.promptForPathToOpen('file', getLoadSettings(), defaultPath)\r\n        case 'application:open-folder':\r\n          return this.promptForPathToOpen('folder', getLoadSettings(), defaultPath)\r\n        default:\r\n          return console.log(`Invalid open-command received: ${command}`)\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'window-command', (event, command, ...args) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      return window.emit(command, ...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('window-method', (browserWindow, method, ...args) => {\r\n      const window = this.atomWindowForBrowserWindow(browserWindow)\r\n      if (window) window[method](...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'pick-folder', (event, responseChannel) => {\r\n      this.promptForPath('folder', paths => event.sender.send(responseChannel, paths))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-size', (window, width, height) => {\r\n      window.setSize(width, height)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-position', (window, x, y) => {\r\n      window.setPosition(x, y)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-user-settings', (window, settings, filePath) => {\r\n      if (!this.quitting) {\r\n        return ConfigFile.at(filePath || this.configFilePath).update(JSON.parse(settings))\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('center-window', window => window.center()))\r\n    this.disposable.add(ipcHelpers.respondTo('focus-window', window => window.focus()))\r\n    this.disposable.add(ipcHelpers.respondTo('show-window', window => window.show()))\r\n    this.disposable.add(ipcHelpers.respondTo('hide-window', window => window.hide()))\r\n    this.disposable.add(ipcHelpers.respondTo('get-temporary-window-state', window => window.temporaryState))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-temporary-window-state', (win, state) => {\r\n      win.temporaryState = state\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-text-to-selection-clipboard', (event, text) =>\r\n      clipboard.writeText(text, 'selection')\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stdout', (event, output) =>\r\n      process.stdout.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stderr', (event, output) =>\r\n      process.stderr.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'add-recent-document', (event, filename) =>\r\n      app.addRecentDocument(filename)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'execute-javascript-in-dev-tools', (event, code) =>\r\n      event.sender.devToolsWebContents && event.sender.devToolsWebContents.executeJavaScript(code)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-state', event => {\r\n      event.returnValue = this.autoUpdateManager.getState()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-error', event => {\r\n      event.returnValue = this.autoUpdateManager.getErrorMessage()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('will-save-path', (window, path) =>\r\n      this.fileRecoveryService.willSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('did-save-path', (window, path) =>\r\n      this.fileRecoveryService.didSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-paths', () =>\r\n      this.saveCurrentWindowOptions(false)\r\n    ))\r\n\r\n    this.disposable.add(this.disableZoomOnDisplayChange())\r\n  }\r", "name": "openPathOnEvent", "func_location": "AtomApplication.handleEvents", "args": [{"type": "string"}, {"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 415, "func_start_line": 364}}, {"func_info": {"comment": [" Public: Open the given path in the focused window when the event is", " triggered.", "", " A new window will be created if there is no currently focused window.", "", " eventName - The event to listen for.", " pathToOpen - The path to open when the event is triggered."], "name": "AtomApplication.openPathOnEvent", "params": ["eventName", "pathToOpen"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 729, "start_line": 720}, "call_info": {"func_end_line": 634, "comment": [" Registers basic application commands, non-idempotent."], "code": "  handleEvents () {\r\n    const getLoadSettings = () => {\r\n      const window = this.focusedWindow()\r\n      return {devMode: window && window.devMode, safeMode: window && window.safeMode}\r\n    }\r\n\r\n    this.on('application:quit', () => app.quit())\r\n    this.on('application:new-window', () => this.openPath(getLoadSettings()))\r\n    this.on('application:new-file', () => (this.focusedWindow() || this).openPath())\r\n    this.on('application:open-dev', () => this.promptForPathToOpen('all', {devMode: true}))\r\n    this.on('application:open-safe', () => this.promptForPathToOpen('all', {safeMode: true}))\r\n    this.on('application:inspect', ({x, y, atomWindow}) => {\r\n      if (!atomWindow) atomWindow = this.focusedWindow()\r\n      if (atomWindow) atomWindow.browserWindow.inspectElement(x, y)\r\n    })\r\n\r\n    this.on('application:open-documentation', () => shell.openExternal('http://flight-manual.atom.io'))\r\n    this.on('application:open-discussions', () => shell.openExternal('https://discuss.atom.io'))\r\n    this.on('application:open-faq', () => shell.openExternal('https://atom.io/faq'))\r\n    this.on('application:open-terms-of-use', () => shell.openExternal('https://atom.io/terms'))\r\n    this.on('application:report-issue', () => shell.openExternal('https://github.com/atom/atom/blob/master/CONTRIBUTING.md#reporting-bugs'))\r\n    this.on('application:search-issues', () => shell.openExternal('https://github.com/search?q=+is%3Aissue+user%3Aatom'))\r\n\r\n    this.on('application:install-update', () => {\r\n      this.quitting = true\r\n      this.autoUpdateManager.install()\r\n    })\r\n\r\n    this.on('application:check-for-update', () => this.autoUpdateManager.check())\r\n\r\n    if (process.platform === 'darwin') {\r\n      this.on('application:bring-all-windows-to-front', () => Menu.sendActionToFirstResponder('arrangeInFront:'))\r\n      this.on('application:hide', () => Menu.sendActionToFirstResponder('hide:'))\r\n      this.on('application:hide-other-applications', () => Menu.sendActionToFirstResponder('hideOtherApplications:'))\r\n      this.on('application:minimize', () => Menu.sendActionToFirstResponder('performMiniaturize:'))\r\n      this.on('application:unhide-all-applications', () => Menu.sendActionToFirstResponder('unhideAllApplications:'))\r\n      this.on('application:zoom', () => Menu.sendActionToFirstResponder('zoom:'))\r\n    } else {\r\n      this.on('application:minimize', () => {\r\n        const window = this.focusedWindow()\r\n        if (window) window.minimize()\r\n      })\r\n      this.on('application:zoom', function () {\r\n        const window = this.focusedWindow()\r\n        if (window) window.maximize()\r\n      })\r\n    }\r\n\r\n    this.openPathOnEvent('application:about', 'atom://about')\r\n    this.openPathOnEvent('application:show-settings', 'atom://config')\r\n    this.openPathOnEvent('application:open-your-config', 'atom://.atom/config')\r\n    this.openPathOnEvent('application:open-your-init-script', 'atom://.atom/init-script')\r\n    this.openPathOnEvent('application:open-your-keymap', 'atom://.atom/keymap')\r\n    this.openPathOnEvent('application:open-your-snippets', 'atom://.atom/snippets')\r\n    this.openPathOnEvent('application:open-your-stylesheet', 'atom://.atom/stylesheet')\r\n    this.openPathOnEvent('application:open-license', path.join(process.resourcesPath, 'LICENSE.md'))\r\n\r\n    this.configFile.onDidChange(settings => {\r\n      for (let window of this.getAllWindows()) {\r\n        window.didChangeUserSettings(settings)\r\n      }\r\n      this.config.resetUserSettings(settings)\r\n    })\r\n\r\n    this.configFile.onDidError(message => {\r\n      const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n      if (window) window.didFailToReadUserSettings(message)\r\n    })\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'before-quit', async event => {\r\n      let resolveBeforeQuitPromise\r\n      this.lastBeforeQuitPromise = new Promise(resolve => { resolveBeforeQuitPromise = resolve })\r\n\r\n      if (!this.quitting) {\r\n        this.quitting = true\r\n        event.preventDefault()\r\n        const windowUnloadPromises = this.getAllWindows().map(async window => {\r\n          const unloaded = await window.prepareToUnload()\r\n          if (unloaded) {\r\n            window.close()\r\n            await window.closedPromise\r\n          }\r\n          return unloaded\r\n        })\r\n        const windowUnloadedResults = await Promise.all(windowUnloadPromises)\r\n        if (windowUnloadedResults.every(Boolean)) {\r\n          app.quit()\r\n        } else {\r\n          this.quitting = false\r\n        }\r\n      }\r\n\r\n      resolveBeforeQuitPromise()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'will-quit', () => {\r\n      this.killAllProcesses()\r\n      this.deleteSocketFile()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-file', (event, pathToOpen) => {\r\n      event.preventDefault()\r\n      this.openPath({pathToOpen})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-url', (event, urlToOpen) => {\r\n      event.preventDefault()\r\n      this.openUrl({urlToOpen, devMode: this.devMode, safeMode: this.safeMode})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'activate', (event, hasVisibleWindows) => {\r\n      if (hasVisibleWindows) return\r\n      if (event) event.preventDefault()\r\n      this.emit('application:new-window')\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'restart-application', () => {\r\n      this.restart()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'resolve-proxy', (event, requestId, url) => {\r\n      event.sender.session.resolveProxy(url, proxy => {\r\n        if (!event.sender.isDestroyed()) event.sender.send('did-resolve-proxy', requestId, proxy)\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-history-manager', event => {\r\n      for (let atomWindow of this.getAllWindows()) {\r\n        const {webContents} = atomWindow.browserWindow\r\n        if (webContents !== event.sender) webContents.send('did-change-history-manager')\r\n      }\r\n    }))\r\n\r\n    // A request from the associated render process to open a new render process.\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open', (event, options) => {\r\n      const window = this.atomWindowForEvent(event)\r\n      if (options) {\r\n        if (typeof options.pathsToOpen === 'string') {\r\n          options.pathsToOpen = [options.pathsToOpen]\r\n        }\r\n\r\n        if (options.pathsToOpen && options.pathsToOpen.length > 0) {\r\n          options.window = window\r\n          this.openPaths(options)\r\n        } else {\r\n          this.addWindow(new AtomWindow(this, this.fileRecoveryService, options))\r\n        }\r\n      } else {\r\n        this.promptForPathToOpen('all', {window})\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'update-application-menu', (event, template, menu) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      if (this.applicationMenu) this.applicationMenu.update(window, template, menu)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-package-specs', (event, packageSpecPath, options = {}) => {\r\n      this.runTests(Object.assign({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [packageSpecPath],\r\n        headless: false\r\n      }, options))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-benchmarks', (event, benchmarksPath) => {\r\n      this.runBenchmarks({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [benchmarksPath],\r\n        headless: false,\r\n        test: false\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'command', (event, command) => {\r\n      this.emit(command)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open-command', (event, command, defaultPath) => {\r\n      switch (command) {\r\n        case 'application:open':\r\n          return this.promptForPathToOpen('all', getLoadSettings(), defaultPath)\r\n        case 'application:open-file':\r\n          return this.promptForPathToOpen('file', getLoadSettings(), defaultPath)\r\n        case 'application:open-folder':\r\n          return this.promptForPathToOpen('folder', getLoadSettings(), defaultPath)\r\n        default:\r\n          return console.log(`Invalid open-command received: ${command}`)\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'window-command', (event, command, ...args) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      return window.emit(command, ...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('window-method', (browserWindow, method, ...args) => {\r\n      const window = this.atomWindowForBrowserWindow(browserWindow)\r\n      if (window) window[method](...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'pick-folder', (event, responseChannel) => {\r\n      this.promptForPath('folder', paths => event.sender.send(responseChannel, paths))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-size', (window, width, height) => {\r\n      window.setSize(width, height)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-position', (window, x, y) => {\r\n      window.setPosition(x, y)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-user-settings', (window, settings, filePath) => {\r\n      if (!this.quitting) {\r\n        return ConfigFile.at(filePath || this.configFilePath).update(JSON.parse(settings))\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('center-window', window => window.center()))\r\n    this.disposable.add(ipcHelpers.respondTo('focus-window', window => window.focus()))\r\n    this.disposable.add(ipcHelpers.respondTo('show-window', window => window.show()))\r\n    this.disposable.add(ipcHelpers.respondTo('hide-window', window => window.hide()))\r\n    this.disposable.add(ipcHelpers.respondTo('get-temporary-window-state', window => window.temporaryState))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-temporary-window-state', (win, state) => {\r\n      win.temporaryState = state\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-text-to-selection-clipboard', (event, text) =>\r\n      clipboard.writeText(text, 'selection')\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stdout', (event, output) =>\r\n      process.stdout.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stderr', (event, output) =>\r\n      process.stderr.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'add-recent-document', (event, filename) =>\r\n      app.addRecentDocument(filename)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'execute-javascript-in-dev-tools', (event, code) =>\r\n      event.sender.devToolsWebContents && event.sender.devToolsWebContents.executeJavaScript(code)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-state', event => {\r\n      event.returnValue = this.autoUpdateManager.getState()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-error', event => {\r\n      event.returnValue = this.autoUpdateManager.getErrorMessage()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('will-save-path', (window, path) =>\r\n      this.fileRecoveryService.willSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('did-save-path', (window, path) =>\r\n      this.fileRecoveryService.didSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-paths', () =>\r\n      this.saveCurrentWindowOptions(false)\r\n    ))\r\n\r\n    this.disposable.add(this.disableZoomOnDisplayChange())\r\n  }\r", "name": "openPathOnEvent", "func_location": "AtomApplication.handleEvents", "args": [{"type": "string"}, {"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 416, "func_start_line": 364}}, {"func_info": {"comment": [" Public: Open the given path in the focused window when the event is", " triggered.", "", " A new window will be created if there is no currently focused window.", "", " eventName - The event to listen for.", " pathToOpen - The path to open when the event is triggered."], "name": "AtomApplication.openPathOnEvent", "params": ["eventName", "pathToOpen"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 729, "start_line": 720}, "call_info": {"func_end_line": 634, "comment": [" Registers basic application commands, non-idempotent."], "code": "  handleEvents () {\r\n    const getLoadSettings = () => {\r\n      const window = this.focusedWindow()\r\n      return {devMode: window && window.devMode, safeMode: window && window.safeMode}\r\n    }\r\n\r\n    this.on('application:quit', () => app.quit())\r\n    this.on('application:new-window', () => this.openPath(getLoadSettings()))\r\n    this.on('application:new-file', () => (this.focusedWindow() || this).openPath())\r\n    this.on('application:open-dev', () => this.promptForPathToOpen('all', {devMode: true}))\r\n    this.on('application:open-safe', () => this.promptForPathToOpen('all', {safeMode: true}))\r\n    this.on('application:inspect', ({x, y, atomWindow}) => {\r\n      if (!atomWindow) atomWindow = this.focusedWindow()\r\n      if (atomWindow) atomWindow.browserWindow.inspectElement(x, y)\r\n    })\r\n\r\n    this.on('application:open-documentation', () => shell.openExternal('http://flight-manual.atom.io'))\r\n    this.on('application:open-discussions', () => shell.openExternal('https://discuss.atom.io'))\r\n    this.on('application:open-faq', () => shell.openExternal('https://atom.io/faq'))\r\n    this.on('application:open-terms-of-use', () => shell.openExternal('https://atom.io/terms'))\r\n    this.on('application:report-issue', () => shell.openExternal('https://github.com/atom/atom/blob/master/CONTRIBUTING.md#reporting-bugs'))\r\n    this.on('application:search-issues', () => shell.openExternal('https://github.com/search?q=+is%3Aissue+user%3Aatom'))\r\n\r\n    this.on('application:install-update', () => {\r\n      this.quitting = true\r\n      this.autoUpdateManager.install()\r\n    })\r\n\r\n    this.on('application:check-for-update', () => this.autoUpdateManager.check())\r\n\r\n    if (process.platform === 'darwin') {\r\n      this.on('application:bring-all-windows-to-front', () => Menu.sendActionToFirstResponder('arrangeInFront:'))\r\n      this.on('application:hide', () => Menu.sendActionToFirstResponder('hide:'))\r\n      this.on('application:hide-other-applications', () => Menu.sendActionToFirstResponder('hideOtherApplications:'))\r\n      this.on('application:minimize', () => Menu.sendActionToFirstResponder('performMiniaturize:'))\r\n      this.on('application:unhide-all-applications', () => Menu.sendActionToFirstResponder('unhideAllApplications:'))\r\n      this.on('application:zoom', () => Menu.sendActionToFirstResponder('zoom:'))\r\n    } else {\r\n      this.on('application:minimize', () => {\r\n        const window = this.focusedWindow()\r\n        if (window) window.minimize()\r\n      })\r\n      this.on('application:zoom', function () {\r\n        const window = this.focusedWindow()\r\n        if (window) window.maximize()\r\n      })\r\n    }\r\n\r\n    this.openPathOnEvent('application:about', 'atom://about')\r\n    this.openPathOnEvent('application:show-settings', 'atom://config')\r\n    this.openPathOnEvent('application:open-your-config', 'atom://.atom/config')\r\n    this.openPathOnEvent('application:open-your-init-script', 'atom://.atom/init-script')\r\n    this.openPathOnEvent('application:open-your-keymap', 'atom://.atom/keymap')\r\n    this.openPathOnEvent('application:open-your-snippets', 'atom://.atom/snippets')\r\n    this.openPathOnEvent('application:open-your-stylesheet', 'atom://.atom/stylesheet')\r\n    this.openPathOnEvent('application:open-license', path.join(process.resourcesPath, 'LICENSE.md'))\r\n\r\n    this.configFile.onDidChange(settings => {\r\n      for (let window of this.getAllWindows()) {\r\n        window.didChangeUserSettings(settings)\r\n      }\r\n      this.config.resetUserSettings(settings)\r\n    })\r\n\r\n    this.configFile.onDidError(message => {\r\n      const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n      if (window) window.didFailToReadUserSettings(message)\r\n    })\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'before-quit', async event => {\r\n      let resolveBeforeQuitPromise\r\n      this.lastBeforeQuitPromise = new Promise(resolve => { resolveBeforeQuitPromise = resolve })\r\n\r\n      if (!this.quitting) {\r\n        this.quitting = true\r\n        event.preventDefault()\r\n        const windowUnloadPromises = this.getAllWindows().map(async window => {\r\n          const unloaded = await window.prepareToUnload()\r\n          if (unloaded) {\r\n            window.close()\r\n            await window.closedPromise\r\n          }\r\n          return unloaded\r\n        })\r\n        const windowUnloadedResults = await Promise.all(windowUnloadPromises)\r\n        if (windowUnloadedResults.every(Boolean)) {\r\n          app.quit()\r\n        } else {\r\n          this.quitting = false\r\n        }\r\n      }\r\n\r\n      resolveBeforeQuitPromise()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'will-quit', () => {\r\n      this.killAllProcesses()\r\n      this.deleteSocketFile()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-file', (event, pathToOpen) => {\r\n      event.preventDefault()\r\n      this.openPath({pathToOpen})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-url', (event, urlToOpen) => {\r\n      event.preventDefault()\r\n      this.openUrl({urlToOpen, devMode: this.devMode, safeMode: this.safeMode})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'activate', (event, hasVisibleWindows) => {\r\n      if (hasVisibleWindows) return\r\n      if (event) event.preventDefault()\r\n      this.emit('application:new-window')\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'restart-application', () => {\r\n      this.restart()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'resolve-proxy', (event, requestId, url) => {\r\n      event.sender.session.resolveProxy(url, proxy => {\r\n        if (!event.sender.isDestroyed()) event.sender.send('did-resolve-proxy', requestId, proxy)\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-history-manager', event => {\r\n      for (let atomWindow of this.getAllWindows()) {\r\n        const {webContents} = atomWindow.browserWindow\r\n        if (webContents !== event.sender) webContents.send('did-change-history-manager')\r\n      }\r\n    }))\r\n\r\n    // A request from the associated render process to open a new render process.\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open', (event, options) => {\r\n      const window = this.atomWindowForEvent(event)\r\n      if (options) {\r\n        if (typeof options.pathsToOpen === 'string') {\r\n          options.pathsToOpen = [options.pathsToOpen]\r\n        }\r\n\r\n        if (options.pathsToOpen && options.pathsToOpen.length > 0) {\r\n          options.window = window\r\n          this.openPaths(options)\r\n        } else {\r\n          this.addWindow(new AtomWindow(this, this.fileRecoveryService, options))\r\n        }\r\n      } else {\r\n        this.promptForPathToOpen('all', {window})\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'update-application-menu', (event, template, menu) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      if (this.applicationMenu) this.applicationMenu.update(window, template, menu)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-package-specs', (event, packageSpecPath, options = {}) => {\r\n      this.runTests(Object.assign({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [packageSpecPath],\r\n        headless: false\r\n      }, options))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-benchmarks', (event, benchmarksPath) => {\r\n      this.runBenchmarks({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [benchmarksPath],\r\n        headless: false,\r\n        test: false\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'command', (event, command) => {\r\n      this.emit(command)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open-command', (event, command, defaultPath) => {\r\n      switch (command) {\r\n        case 'application:open':\r\n          return this.promptForPathToOpen('all', getLoadSettings(), defaultPath)\r\n        case 'application:open-file':\r\n          return this.promptForPathToOpen('file', getLoadSettings(), defaultPath)\r\n        case 'application:open-folder':\r\n          return this.promptForPathToOpen('folder', getLoadSettings(), defaultPath)\r\n        default:\r\n          return console.log(`Invalid open-command received: ${command}`)\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'window-command', (event, command, ...args) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      return window.emit(command, ...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('window-method', (browserWindow, method, ...args) => {\r\n      const window = this.atomWindowForBrowserWindow(browserWindow)\r\n      if (window) window[method](...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'pick-folder', (event, responseChannel) => {\r\n      this.promptForPath('folder', paths => event.sender.send(responseChannel, paths))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-size', (window, width, height) => {\r\n      window.setSize(width, height)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-position', (window, x, y) => {\r\n      window.setPosition(x, y)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-user-settings', (window, settings, filePath) => {\r\n      if (!this.quitting) {\r\n        return ConfigFile.at(filePath || this.configFilePath).update(JSON.parse(settings))\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('center-window', window => window.center()))\r\n    this.disposable.add(ipcHelpers.respondTo('focus-window', window => window.focus()))\r\n    this.disposable.add(ipcHelpers.respondTo('show-window', window => window.show()))\r\n    this.disposable.add(ipcHelpers.respondTo('hide-window', window => window.hide()))\r\n    this.disposable.add(ipcHelpers.respondTo('get-temporary-window-state', window => window.temporaryState))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-temporary-window-state', (win, state) => {\r\n      win.temporaryState = state\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-text-to-selection-clipboard', (event, text) =>\r\n      clipboard.writeText(text, 'selection')\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stdout', (event, output) =>\r\n      process.stdout.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stderr', (event, output) =>\r\n      process.stderr.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'add-recent-document', (event, filename) =>\r\n      app.addRecentDocument(filename)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'execute-javascript-in-dev-tools', (event, code) =>\r\n      event.sender.devToolsWebContents && event.sender.devToolsWebContents.executeJavaScript(code)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-state', event => {\r\n      event.returnValue = this.autoUpdateManager.getState()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-error', event => {\r\n      event.returnValue = this.autoUpdateManager.getErrorMessage()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('will-save-path', (window, path) =>\r\n      this.fileRecoveryService.willSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('did-save-path', (window, path) =>\r\n      this.fileRecoveryService.didSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-paths', () =>\r\n      this.saveCurrentWindowOptions(false)\r\n    ))\r\n\r\n    this.disposable.add(this.disableZoomOnDisplayChange())\r\n  }\r", "name": "openPathOnEvent", "func_location": "AtomApplication.handleEvents", "args": [{"type": "string"}, {"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 417, "func_start_line": 364}}, {"func_info": {"comment": [" Public: Open the given path in the focused window when the event is", " triggered.", "", " A new window will be created if there is no currently focused window.", "", " eventName - The event to listen for.", " pathToOpen - The path to open when the event is triggered."], "name": "AtomApplication.openPathOnEvent", "params": ["eventName", "pathToOpen"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 729, "start_line": 720}, "call_info": {"func_end_line": 634, "comment": [" Registers basic application commands, non-idempotent."], "code": "  handleEvents () {\r\n    const getLoadSettings = () => {\r\n      const window = this.focusedWindow()\r\n      return {devMode: window && window.devMode, safeMode: window && window.safeMode}\r\n    }\r\n\r\n    this.on('application:quit', () => app.quit())\r\n    this.on('application:new-window', () => this.openPath(getLoadSettings()))\r\n    this.on('application:new-file', () => (this.focusedWindow() || this).openPath())\r\n    this.on('application:open-dev', () => this.promptForPathToOpen('all', {devMode: true}))\r\n    this.on('application:open-safe', () => this.promptForPathToOpen('all', {safeMode: true}))\r\n    this.on('application:inspect', ({x, y, atomWindow}) => {\r\n      if (!atomWindow) atomWindow = this.focusedWindow()\r\n      if (atomWindow) atomWindow.browserWindow.inspectElement(x, y)\r\n    })\r\n\r\n    this.on('application:open-documentation', () => shell.openExternal('http://flight-manual.atom.io'))\r\n    this.on('application:open-discussions', () => shell.openExternal('https://discuss.atom.io'))\r\n    this.on('application:open-faq', () => shell.openExternal('https://atom.io/faq'))\r\n    this.on('application:open-terms-of-use', () => shell.openExternal('https://atom.io/terms'))\r\n    this.on('application:report-issue', () => shell.openExternal('https://github.com/atom/atom/blob/master/CONTRIBUTING.md#reporting-bugs'))\r\n    this.on('application:search-issues', () => shell.openExternal('https://github.com/search?q=+is%3Aissue+user%3Aatom'))\r\n\r\n    this.on('application:install-update', () => {\r\n      this.quitting = true\r\n      this.autoUpdateManager.install()\r\n    })\r\n\r\n    this.on('application:check-for-update', () => this.autoUpdateManager.check())\r\n\r\n    if (process.platform === 'darwin') {\r\n      this.on('application:bring-all-windows-to-front', () => Menu.sendActionToFirstResponder('arrangeInFront:'))\r\n      this.on('application:hide', () => Menu.sendActionToFirstResponder('hide:'))\r\n      this.on('application:hide-other-applications', () => Menu.sendActionToFirstResponder('hideOtherApplications:'))\r\n      this.on('application:minimize', () => Menu.sendActionToFirstResponder('performMiniaturize:'))\r\n      this.on('application:unhide-all-applications', () => Menu.sendActionToFirstResponder('unhideAllApplications:'))\r\n      this.on('application:zoom', () => Menu.sendActionToFirstResponder('zoom:'))\r\n    } else {\r\n      this.on('application:minimize', () => {\r\n        const window = this.focusedWindow()\r\n        if (window) window.minimize()\r\n      })\r\n      this.on('application:zoom', function () {\r\n        const window = this.focusedWindow()\r\n        if (window) window.maximize()\r\n      })\r\n    }\r\n\r\n    this.openPathOnEvent('application:about', 'atom://about')\r\n    this.openPathOnEvent('application:show-settings', 'atom://config')\r\n    this.openPathOnEvent('application:open-your-config', 'atom://.atom/config')\r\n    this.openPathOnEvent('application:open-your-init-script', 'atom://.atom/init-script')\r\n    this.openPathOnEvent('application:open-your-keymap', 'atom://.atom/keymap')\r\n    this.openPathOnEvent('application:open-your-snippets', 'atom://.atom/snippets')\r\n    this.openPathOnEvent('application:open-your-stylesheet', 'atom://.atom/stylesheet')\r\n    this.openPathOnEvent('application:open-license', path.join(process.resourcesPath, 'LICENSE.md'))\r\n\r\n    this.configFile.onDidChange(settings => {\r\n      for (let window of this.getAllWindows()) {\r\n        window.didChangeUserSettings(settings)\r\n      }\r\n      this.config.resetUserSettings(settings)\r\n    })\r\n\r\n    this.configFile.onDidError(message => {\r\n      const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n      if (window) window.didFailToReadUserSettings(message)\r\n    })\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'before-quit', async event => {\r\n      let resolveBeforeQuitPromise\r\n      this.lastBeforeQuitPromise = new Promise(resolve => { resolveBeforeQuitPromise = resolve })\r\n\r\n      if (!this.quitting) {\r\n        this.quitting = true\r\n        event.preventDefault()\r\n        const windowUnloadPromises = this.getAllWindows().map(async window => {\r\n          const unloaded = await window.prepareToUnload()\r\n          if (unloaded) {\r\n            window.close()\r\n            await window.closedPromise\r\n          }\r\n          return unloaded\r\n        })\r\n        const windowUnloadedResults = await Promise.all(windowUnloadPromises)\r\n        if (windowUnloadedResults.every(Boolean)) {\r\n          app.quit()\r\n        } else {\r\n          this.quitting = false\r\n        }\r\n      }\r\n\r\n      resolveBeforeQuitPromise()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'will-quit', () => {\r\n      this.killAllProcesses()\r\n      this.deleteSocketFile()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-file', (event, pathToOpen) => {\r\n      event.preventDefault()\r\n      this.openPath({pathToOpen})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-url', (event, urlToOpen) => {\r\n      event.preventDefault()\r\n      this.openUrl({urlToOpen, devMode: this.devMode, safeMode: this.safeMode})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'activate', (event, hasVisibleWindows) => {\r\n      if (hasVisibleWindows) return\r\n      if (event) event.preventDefault()\r\n      this.emit('application:new-window')\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'restart-application', () => {\r\n      this.restart()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'resolve-proxy', (event, requestId, url) => {\r\n      event.sender.session.resolveProxy(url, proxy => {\r\n        if (!event.sender.isDestroyed()) event.sender.send('did-resolve-proxy', requestId, proxy)\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-history-manager', event => {\r\n      for (let atomWindow of this.getAllWindows()) {\r\n        const {webContents} = atomWindow.browserWindow\r\n        if (webContents !== event.sender) webContents.send('did-change-history-manager')\r\n      }\r\n    }))\r\n\r\n    // A request from the associated render process to open a new render process.\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open', (event, options) => {\r\n      const window = this.atomWindowForEvent(event)\r\n      if (options) {\r\n        if (typeof options.pathsToOpen === 'string') {\r\n          options.pathsToOpen = [options.pathsToOpen]\r\n        }\r\n\r\n        if (options.pathsToOpen && options.pathsToOpen.length > 0) {\r\n          options.window = window\r\n          this.openPaths(options)\r\n        } else {\r\n          this.addWindow(new AtomWindow(this, this.fileRecoveryService, options))\r\n        }\r\n      } else {\r\n        this.promptForPathToOpen('all', {window})\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'update-application-menu', (event, template, menu) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      if (this.applicationMenu) this.applicationMenu.update(window, template, menu)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-package-specs', (event, packageSpecPath, options = {}) => {\r\n      this.runTests(Object.assign({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [packageSpecPath],\r\n        headless: false\r\n      }, options))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-benchmarks', (event, benchmarksPath) => {\r\n      this.runBenchmarks({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [benchmarksPath],\r\n        headless: false,\r\n        test: false\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'command', (event, command) => {\r\n      this.emit(command)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open-command', (event, command, defaultPath) => {\r\n      switch (command) {\r\n        case 'application:open':\r\n          return this.promptForPathToOpen('all', getLoadSettings(), defaultPath)\r\n        case 'application:open-file':\r\n          return this.promptForPathToOpen('file', getLoadSettings(), defaultPath)\r\n        case 'application:open-folder':\r\n          return this.promptForPathToOpen('folder', getLoadSettings(), defaultPath)\r\n        default:\r\n          return console.log(`Invalid open-command received: ${command}`)\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'window-command', (event, command, ...args) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      return window.emit(command, ...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('window-method', (browserWindow, method, ...args) => {\r\n      const window = this.atomWindowForBrowserWindow(browserWindow)\r\n      if (window) window[method](...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'pick-folder', (event, responseChannel) => {\r\n      this.promptForPath('folder', paths => event.sender.send(responseChannel, paths))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-size', (window, width, height) => {\r\n      window.setSize(width, height)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-position', (window, x, y) => {\r\n      window.setPosition(x, y)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-user-settings', (window, settings, filePath) => {\r\n      if (!this.quitting) {\r\n        return ConfigFile.at(filePath || this.configFilePath).update(JSON.parse(settings))\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('center-window', window => window.center()))\r\n    this.disposable.add(ipcHelpers.respondTo('focus-window', window => window.focus()))\r\n    this.disposable.add(ipcHelpers.respondTo('show-window', window => window.show()))\r\n    this.disposable.add(ipcHelpers.respondTo('hide-window', window => window.hide()))\r\n    this.disposable.add(ipcHelpers.respondTo('get-temporary-window-state', window => window.temporaryState))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-temporary-window-state', (win, state) => {\r\n      win.temporaryState = state\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-text-to-selection-clipboard', (event, text) =>\r\n      clipboard.writeText(text, 'selection')\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stdout', (event, output) =>\r\n      process.stdout.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stderr', (event, output) =>\r\n      process.stderr.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'add-recent-document', (event, filename) =>\r\n      app.addRecentDocument(filename)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'execute-javascript-in-dev-tools', (event, code) =>\r\n      event.sender.devToolsWebContents && event.sender.devToolsWebContents.executeJavaScript(code)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-state', event => {\r\n      event.returnValue = this.autoUpdateManager.getState()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-error', event => {\r\n      event.returnValue = this.autoUpdateManager.getErrorMessage()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('will-save-path', (window, path) =>\r\n      this.fileRecoveryService.willSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('did-save-path', (window, path) =>\r\n      this.fileRecoveryService.didSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-paths', () =>\r\n      this.saveCurrentWindowOptions(false)\r\n    ))\r\n\r\n    this.disposable.add(this.disableZoomOnDisplayChange())\r\n  }\r", "name": "openPathOnEvent", "func_location": "AtomApplication.handleEvents", "args": [{"type": "string"}, {"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 418, "func_start_line": 364}}, {"func_info": {"comment": [" Public: Open the given path in the focused window when the event is", " triggered.", "", " A new window will be created if there is no currently focused window.", "", " eventName - The event to listen for.", " pathToOpen - The path to open when the event is triggered."], "name": "AtomApplication.openPathOnEvent", "params": ["eventName", "pathToOpen"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 729, "start_line": 720}, "call_info": {"func_end_line": 634, "comment": [" Registers basic application commands, non-idempotent."], "code": "  handleEvents () {\r\n    const getLoadSettings = () => {\r\n      const window = this.focusedWindow()\r\n      return {devMode: window && window.devMode, safeMode: window && window.safeMode}\r\n    }\r\n\r\n    this.on('application:quit', () => app.quit())\r\n    this.on('application:new-window', () => this.openPath(getLoadSettings()))\r\n    this.on('application:new-file', () => (this.focusedWindow() || this).openPath())\r\n    this.on('application:open-dev', () => this.promptForPathToOpen('all', {devMode: true}))\r\n    this.on('application:open-safe', () => this.promptForPathToOpen('all', {safeMode: true}))\r\n    this.on('application:inspect', ({x, y, atomWindow}) => {\r\n      if (!atomWindow) atomWindow = this.focusedWindow()\r\n      if (atomWindow) atomWindow.browserWindow.inspectElement(x, y)\r\n    })\r\n\r\n    this.on('application:open-documentation', () => shell.openExternal('http://flight-manual.atom.io'))\r\n    this.on('application:open-discussions', () => shell.openExternal('https://discuss.atom.io'))\r\n    this.on('application:open-faq', () => shell.openExternal('https://atom.io/faq'))\r\n    this.on('application:open-terms-of-use', () => shell.openExternal('https://atom.io/terms'))\r\n    this.on('application:report-issue', () => shell.openExternal('https://github.com/atom/atom/blob/master/CONTRIBUTING.md#reporting-bugs'))\r\n    this.on('application:search-issues', () => shell.openExternal('https://github.com/search?q=+is%3Aissue+user%3Aatom'))\r\n\r\n    this.on('application:install-update', () => {\r\n      this.quitting = true\r\n      this.autoUpdateManager.install()\r\n    })\r\n\r\n    this.on('application:check-for-update', () => this.autoUpdateManager.check())\r\n\r\n    if (process.platform === 'darwin') {\r\n      this.on('application:bring-all-windows-to-front', () => Menu.sendActionToFirstResponder('arrangeInFront:'))\r\n      this.on('application:hide', () => Menu.sendActionToFirstResponder('hide:'))\r\n      this.on('application:hide-other-applications', () => Menu.sendActionToFirstResponder('hideOtherApplications:'))\r\n      this.on('application:minimize', () => Menu.sendActionToFirstResponder('performMiniaturize:'))\r\n      this.on('application:unhide-all-applications', () => Menu.sendActionToFirstResponder('unhideAllApplications:'))\r\n      this.on('application:zoom', () => Menu.sendActionToFirstResponder('zoom:'))\r\n    } else {\r\n      this.on('application:minimize', () => {\r\n        const window = this.focusedWindow()\r\n        if (window) window.minimize()\r\n      })\r\n      this.on('application:zoom', function () {\r\n        const window = this.focusedWindow()\r\n        if (window) window.maximize()\r\n      })\r\n    }\r\n\r\n    this.openPathOnEvent('application:about', 'atom://about')\r\n    this.openPathOnEvent('application:show-settings', 'atom://config')\r\n    this.openPathOnEvent('application:open-your-config', 'atom://.atom/config')\r\n    this.openPathOnEvent('application:open-your-init-script', 'atom://.atom/init-script')\r\n    this.openPathOnEvent('application:open-your-keymap', 'atom://.atom/keymap')\r\n    this.openPathOnEvent('application:open-your-snippets', 'atom://.atom/snippets')\r\n    this.openPathOnEvent('application:open-your-stylesheet', 'atom://.atom/stylesheet')\r\n    this.openPathOnEvent('application:open-license', path.join(process.resourcesPath, 'LICENSE.md'))\r\n\r\n    this.configFile.onDidChange(settings => {\r\n      for (let window of this.getAllWindows()) {\r\n        window.didChangeUserSettings(settings)\r\n      }\r\n      this.config.resetUserSettings(settings)\r\n    })\r\n\r\n    this.configFile.onDidError(message => {\r\n      const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n      if (window) window.didFailToReadUserSettings(message)\r\n    })\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'before-quit', async event => {\r\n      let resolveBeforeQuitPromise\r\n      this.lastBeforeQuitPromise = new Promise(resolve => { resolveBeforeQuitPromise = resolve })\r\n\r\n      if (!this.quitting) {\r\n        this.quitting = true\r\n        event.preventDefault()\r\n        const windowUnloadPromises = this.getAllWindows().map(async window => {\r\n          const unloaded = await window.prepareToUnload()\r\n          if (unloaded) {\r\n            window.close()\r\n            await window.closedPromise\r\n          }\r\n          return unloaded\r\n        })\r\n        const windowUnloadedResults = await Promise.all(windowUnloadPromises)\r\n        if (windowUnloadedResults.every(Boolean)) {\r\n          app.quit()\r\n        } else {\r\n          this.quitting = false\r\n        }\r\n      }\r\n\r\n      resolveBeforeQuitPromise()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'will-quit', () => {\r\n      this.killAllProcesses()\r\n      this.deleteSocketFile()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-file', (event, pathToOpen) => {\r\n      event.preventDefault()\r\n      this.openPath({pathToOpen})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-url', (event, urlToOpen) => {\r\n      event.preventDefault()\r\n      this.openUrl({urlToOpen, devMode: this.devMode, safeMode: this.safeMode})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'activate', (event, hasVisibleWindows) => {\r\n      if (hasVisibleWindows) return\r\n      if (event) event.preventDefault()\r\n      this.emit('application:new-window')\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'restart-application', () => {\r\n      this.restart()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'resolve-proxy', (event, requestId, url) => {\r\n      event.sender.session.resolveProxy(url, proxy => {\r\n        if (!event.sender.isDestroyed()) event.sender.send('did-resolve-proxy', requestId, proxy)\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-history-manager', event => {\r\n      for (let atomWindow of this.getAllWindows()) {\r\n        const {webContents} = atomWindow.browserWindow\r\n        if (webContents !== event.sender) webContents.send('did-change-history-manager')\r\n      }\r\n    }))\r\n\r\n    // A request from the associated render process to open a new render process.\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open', (event, options) => {\r\n      const window = this.atomWindowForEvent(event)\r\n      if (options) {\r\n        if (typeof options.pathsToOpen === 'string') {\r\n          options.pathsToOpen = [options.pathsToOpen]\r\n        }\r\n\r\n        if (options.pathsToOpen && options.pathsToOpen.length > 0) {\r\n          options.window = window\r\n          this.openPaths(options)\r\n        } else {\r\n          this.addWindow(new AtomWindow(this, this.fileRecoveryService, options))\r\n        }\r\n      } else {\r\n        this.promptForPathToOpen('all', {window})\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'update-application-menu', (event, template, menu) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      if (this.applicationMenu) this.applicationMenu.update(window, template, menu)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-package-specs', (event, packageSpecPath, options = {}) => {\r\n      this.runTests(Object.assign({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [packageSpecPath],\r\n        headless: false\r\n      }, options))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-benchmarks', (event, benchmarksPath) => {\r\n      this.runBenchmarks({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [benchmarksPath],\r\n        headless: false,\r\n        test: false\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'command', (event, command) => {\r\n      this.emit(command)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open-command', (event, command, defaultPath) => {\r\n      switch (command) {\r\n        case 'application:open':\r\n          return this.promptForPathToOpen('all', getLoadSettings(), defaultPath)\r\n        case 'application:open-file':\r\n          return this.promptForPathToOpen('file', getLoadSettings(), defaultPath)\r\n        case 'application:open-folder':\r\n          return this.promptForPathToOpen('folder', getLoadSettings(), defaultPath)\r\n        default:\r\n          return console.log(`Invalid open-command received: ${command}`)\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'window-command', (event, command, ...args) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      return window.emit(command, ...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('window-method', (browserWindow, method, ...args) => {\r\n      const window = this.atomWindowForBrowserWindow(browserWindow)\r\n      if (window) window[method](...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'pick-folder', (event, responseChannel) => {\r\n      this.promptForPath('folder', paths => event.sender.send(responseChannel, paths))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-size', (window, width, height) => {\r\n      window.setSize(width, height)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-position', (window, x, y) => {\r\n      window.setPosition(x, y)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-user-settings', (window, settings, filePath) => {\r\n      if (!this.quitting) {\r\n        return ConfigFile.at(filePath || this.configFilePath).update(JSON.parse(settings))\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('center-window', window => window.center()))\r\n    this.disposable.add(ipcHelpers.respondTo('focus-window', window => window.focus()))\r\n    this.disposable.add(ipcHelpers.respondTo('show-window', window => window.show()))\r\n    this.disposable.add(ipcHelpers.respondTo('hide-window', window => window.hide()))\r\n    this.disposable.add(ipcHelpers.respondTo('get-temporary-window-state', window => window.temporaryState))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-temporary-window-state', (win, state) => {\r\n      win.temporaryState = state\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-text-to-selection-clipboard', (event, text) =>\r\n      clipboard.writeText(text, 'selection')\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stdout', (event, output) =>\r\n      process.stdout.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stderr', (event, output) =>\r\n      process.stderr.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'add-recent-document', (event, filename) =>\r\n      app.addRecentDocument(filename)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'execute-javascript-in-dev-tools', (event, code) =>\r\n      event.sender.devToolsWebContents && event.sender.devToolsWebContents.executeJavaScript(code)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-state', event => {\r\n      event.returnValue = this.autoUpdateManager.getState()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-error', event => {\r\n      event.returnValue = this.autoUpdateManager.getErrorMessage()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('will-save-path', (window, path) =>\r\n      this.fileRecoveryService.willSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('did-save-path', (window, path) =>\r\n      this.fileRecoveryService.didSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-paths', () =>\r\n      this.saveCurrentWindowOptions(false)\r\n    ))\r\n\r\n    this.disposable.add(this.disableZoomOnDisplayChange())\r\n  }\r", "name": "openPathOnEvent", "func_location": "AtomApplication.handleEvents", "args": [{"type": "string"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 419, "func_start_line": 364}}, {"func_info": {"comment": [], "name": "AtomApplication.disableZoomOnDisplayChange", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1386, "start_line": 1372}, "call_info": {"func_end_line": 634, "comment": [" Registers basic application commands, non-idempotent."], "code": "  handleEvents () {\r\n    const getLoadSettings = () => {\r\n      const window = this.focusedWindow()\r\n      return {devMode: window && window.devMode, safeMode: window && window.safeMode}\r\n    }\r\n\r\n    this.on('application:quit', () => app.quit())\r\n    this.on('application:new-window', () => this.openPath(getLoadSettings()))\r\n    this.on('application:new-file', () => (this.focusedWindow() || this).openPath())\r\n    this.on('application:open-dev', () => this.promptForPathToOpen('all', {devMode: true}))\r\n    this.on('application:open-safe', () => this.promptForPathToOpen('all', {safeMode: true}))\r\n    this.on('application:inspect', ({x, y, atomWindow}) => {\r\n      if (!atomWindow) atomWindow = this.focusedWindow()\r\n      if (atomWindow) atomWindow.browserWindow.inspectElement(x, y)\r\n    })\r\n\r\n    this.on('application:open-documentation', () => shell.openExternal('http://flight-manual.atom.io'))\r\n    this.on('application:open-discussions', () => shell.openExternal('https://discuss.atom.io'))\r\n    this.on('application:open-faq', () => shell.openExternal('https://atom.io/faq'))\r\n    this.on('application:open-terms-of-use', () => shell.openExternal('https://atom.io/terms'))\r\n    this.on('application:report-issue', () => shell.openExternal('https://github.com/atom/atom/blob/master/CONTRIBUTING.md#reporting-bugs'))\r\n    this.on('application:search-issues', () => shell.openExternal('https://github.com/search?q=+is%3Aissue+user%3Aatom'))\r\n\r\n    this.on('application:install-update', () => {\r\n      this.quitting = true\r\n      this.autoUpdateManager.install()\r\n    })\r\n\r\n    this.on('application:check-for-update', () => this.autoUpdateManager.check())\r\n\r\n    if (process.platform === 'darwin') {\r\n      this.on('application:bring-all-windows-to-front', () => Menu.sendActionToFirstResponder('arrangeInFront:'))\r\n      this.on('application:hide', () => Menu.sendActionToFirstResponder('hide:'))\r\n      this.on('application:hide-other-applications', () => Menu.sendActionToFirstResponder('hideOtherApplications:'))\r\n      this.on('application:minimize', () => Menu.sendActionToFirstResponder('performMiniaturize:'))\r\n      this.on('application:unhide-all-applications', () => Menu.sendActionToFirstResponder('unhideAllApplications:'))\r\n      this.on('application:zoom', () => Menu.sendActionToFirstResponder('zoom:'))\r\n    } else {\r\n      this.on('application:minimize', () => {\r\n        const window = this.focusedWindow()\r\n        if (window) window.minimize()\r\n      })\r\n      this.on('application:zoom', function () {\r\n        const window = this.focusedWindow()\r\n        if (window) window.maximize()\r\n      })\r\n    }\r\n\r\n    this.openPathOnEvent('application:about', 'atom://about')\r\n    this.openPathOnEvent('application:show-settings', 'atom://config')\r\n    this.openPathOnEvent('application:open-your-config', 'atom://.atom/config')\r\n    this.openPathOnEvent('application:open-your-init-script', 'atom://.atom/init-script')\r\n    this.openPathOnEvent('application:open-your-keymap', 'atom://.atom/keymap')\r\n    this.openPathOnEvent('application:open-your-snippets', 'atom://.atom/snippets')\r\n    this.openPathOnEvent('application:open-your-stylesheet', 'atom://.atom/stylesheet')\r\n    this.openPathOnEvent('application:open-license', path.join(process.resourcesPath, 'LICENSE.md'))\r\n\r\n    this.configFile.onDidChange(settings => {\r\n      for (let window of this.getAllWindows()) {\r\n        window.didChangeUserSettings(settings)\r\n      }\r\n      this.config.resetUserSettings(settings)\r\n    })\r\n\r\n    this.configFile.onDidError(message => {\r\n      const window = this.focusedWindow() || this.getLastFocusedWindow()\r\n      if (window) window.didFailToReadUserSettings(message)\r\n    })\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'before-quit', async event => {\r\n      let resolveBeforeQuitPromise\r\n      this.lastBeforeQuitPromise = new Promise(resolve => { resolveBeforeQuitPromise = resolve })\r\n\r\n      if (!this.quitting) {\r\n        this.quitting = true\r\n        event.preventDefault()\r\n        const windowUnloadPromises = this.getAllWindows().map(async window => {\r\n          const unloaded = await window.prepareToUnload()\r\n          if (unloaded) {\r\n            window.close()\r\n            await window.closedPromise\r\n          }\r\n          return unloaded\r\n        })\r\n        const windowUnloadedResults = await Promise.all(windowUnloadPromises)\r\n        if (windowUnloadedResults.every(Boolean)) {\r\n          app.quit()\r\n        } else {\r\n          this.quitting = false\r\n        }\r\n      }\r\n\r\n      resolveBeforeQuitPromise()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'will-quit', () => {\r\n      this.killAllProcesses()\r\n      this.deleteSocketFile()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-file', (event, pathToOpen) => {\r\n      event.preventDefault()\r\n      this.openPath({pathToOpen})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'open-url', (event, urlToOpen) => {\r\n      event.preventDefault()\r\n      this.openUrl({urlToOpen, devMode: this.devMode, safeMode: this.safeMode})\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(app, 'activate', (event, hasVisibleWindows) => {\r\n      if (hasVisibleWindows) return\r\n      if (event) event.preventDefault()\r\n      this.emit('application:new-window')\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'restart-application', () => {\r\n      this.restart()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'resolve-proxy', (event, requestId, url) => {\r\n      event.sender.session.resolveProxy(url, proxy => {\r\n        if (!event.sender.isDestroyed()) event.sender.send('did-resolve-proxy', requestId, proxy)\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-history-manager', event => {\r\n      for (let atomWindow of this.getAllWindows()) {\r\n        const {webContents} = atomWindow.browserWindow\r\n        if (webContents !== event.sender) webContents.send('did-change-history-manager')\r\n      }\r\n    }))\r\n\r\n    // A request from the associated render process to open a new render process.\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open', (event, options) => {\r\n      const window = this.atomWindowForEvent(event)\r\n      if (options) {\r\n        if (typeof options.pathsToOpen === 'string') {\r\n          options.pathsToOpen = [options.pathsToOpen]\r\n        }\r\n\r\n        if (options.pathsToOpen && options.pathsToOpen.length > 0) {\r\n          options.window = window\r\n          this.openPaths(options)\r\n        } else {\r\n          this.addWindow(new AtomWindow(this, this.fileRecoveryService, options))\r\n        }\r\n      } else {\r\n        this.promptForPathToOpen('all', {window})\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'update-application-menu', (event, template, menu) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      if (this.applicationMenu) this.applicationMenu.update(window, template, menu)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-package-specs', (event, packageSpecPath, options = {}) => {\r\n      this.runTests(Object.assign({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [packageSpecPath],\r\n        headless: false\r\n      }, options))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'run-benchmarks', (event, benchmarksPath) => {\r\n      this.runBenchmarks({\r\n        resourcePath: this.devResourcePath,\r\n        pathsToOpen: [benchmarksPath],\r\n        headless: false,\r\n        test: false\r\n      })\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'command', (event, command) => {\r\n      this.emit(command)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'open-command', (event, command, defaultPath) => {\r\n      switch (command) {\r\n        case 'application:open':\r\n          return this.promptForPathToOpen('all', getLoadSettings(), defaultPath)\r\n        case 'application:open-file':\r\n          return this.promptForPathToOpen('file', getLoadSettings(), defaultPath)\r\n        case 'application:open-folder':\r\n          return this.promptForPathToOpen('folder', getLoadSettings(), defaultPath)\r\n        default:\r\n          return console.log(`Invalid open-command received: ${command}`)\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'window-command', (event, command, ...args) => {\r\n      const window = BrowserWindow.fromWebContents(event.sender)\r\n      return window.emit(command, ...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('window-method', (browserWindow, method, ...args) => {\r\n      const window = this.atomWindowForBrowserWindow(browserWindow)\r\n      if (window) window[method](...args)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'pick-folder', (event, responseChannel) => {\r\n      this.promptForPath('folder', paths => event.sender.send(responseChannel, paths))\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-size', (window, width, height) => {\r\n      window.setSize(width, height)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-window-position', (window, x, y) => {\r\n      window.setPosition(x, y)\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-user-settings', (window, settings, filePath) => {\r\n      if (!this.quitting) {\r\n        return ConfigFile.at(filePath || this.configFilePath).update(JSON.parse(settings))\r\n      }\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('center-window', window => window.center()))\r\n    this.disposable.add(ipcHelpers.respondTo('focus-window', window => window.focus()))\r\n    this.disposable.add(ipcHelpers.respondTo('show-window', window => window.show()))\r\n    this.disposable.add(ipcHelpers.respondTo('hide-window', window => window.hide()))\r\n    this.disposable.add(ipcHelpers.respondTo('get-temporary-window-state', window => window.temporaryState))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('set-temporary-window-state', (win, state) => {\r\n      win.temporaryState = state\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-text-to-selection-clipboard', (event, text) =>\r\n      clipboard.writeText(text, 'selection')\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stdout', (event, output) =>\r\n      process.stdout.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'write-to-stderr', (event, output) =>\r\n      process.stderr.write(output)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'add-recent-document', (event, filename) =>\r\n      app.addRecentDocument(filename)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'execute-javascript-in-dev-tools', (event, code) =>\r\n      event.sender.devToolsWebContents && event.sender.devToolsWebContents.executeJavaScript(code)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-state', event => {\r\n      event.returnValue = this.autoUpdateManager.getState()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'get-auto-update-manager-error', event => {\r\n      event.returnValue = this.autoUpdateManager.getErrorMessage()\r\n    }))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('will-save-path', (window, path) =>\r\n      this.fileRecoveryService.willSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.respondTo('did-save-path', (window, path) =>\r\n      this.fileRecoveryService.didSavePath(window, path)\r\n    ))\r\n\r\n    this.disposable.add(ipcHelpers.on(ipcMain, 'did-change-paths', () =>\r\n      this.saveCurrentWindowOptions(false)\r\n    ))\r\n\r\n    this.disposable.add(this.disableZoomOnDisplayChange())\r\n  }\r", "name": "disableZoomOnDisplayChange", "func_location": "AtomApplication.handleEvents", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 633, "func_start_line": 364}}, {"func_info": {"comment": [], "name": "WindowEventHandler.eachTabIndexedElement", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js", "end_line": 131, "start_line": 125}, "call_info": {"func_end_line": 157, "name": "eachTabIndexedElement", "func_location": "WindowEventHandler.handleFocusNext", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js", "line": 140, "func_start_line": 133}}, {"func_info": {"comment": [], "name": "WindowEventHandler.eachTabIndexedElement", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js", "end_line": 131, "start_line": 125}, "call_info": {"func_end_line": 183, "name": "eachTabIndexedElement", "func_location": "WindowEventHandler.handleFocusPrevious", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js", "line": 166, "func_start_line": 159}}, {"func_info": {"comment": [], "name": "Dock.handleMouseUp", "params": ["event"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 303, "start_line": 299}, "call_info": {"func_end_line": 297, "code": "  handleMouseMove (event) {\r\n    if (event.buttons === 0) { // We missed the mouseup event. For some reason it happens on Windows\r\n      this.handleMouseUp(event)\r\n      return\r\n    }\r\n\r\n    let size = 0\r\n    switch (this.location) {\r\n      case 'left':\r\n        size = event.pageX - this.element.getBoundingClientRect().left\r\n        break\r\n      case 'bottom':\r\n        size = this.element.getBoundingClientRect().bottom - event.pageY\r\n        break\r\n      case 'right':\r\n        size = this.element.getBoundingClientRect().right - event.pageX\r\n        break\r\n    }\r\n    this.setState({size})\r\n  }\r", "name": "handleMouseUp", "func_location": "Dock.handleMouseMove", "args": ["event"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 280, "func_start_line": 278}}, {"func_info": {"comment": [], "name": "Dock.setState", "params": ["newState"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 177, "start_line": 144}, "call_info": {"func_end_line": 297, "code": "  handleMouseMove (event) {\r\n    if (event.buttons === 0) { // We missed the mouseup event. For some reason it happens on Windows\r\n      this.handleMouseUp(event)\r\n      return\r\n    }\r\n\r\n    let size = 0\r\n    switch (this.location) {\r\n      case 'left':\r\n        size = event.pageX - this.element.getBoundingClientRect().left\r\n        break\r\n      case 'bottom':\r\n        size = this.element.getBoundingClientRect().bottom - event.pageY\r\n        break\r\n      case 'right':\r\n        size = this.element.getBoundingClientRect().right - event.pageX\r\n        break\r\n    }\r\n    this.setState({size})\r\n  }\r", "name": "setState", "func_location": "Dock.handleMouseMove", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 296, "func_start_line": 278}}, {"func_info": {"comment": [], "name": "Dock.setState", "params": ["newState"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 177, "start_line": 144}, "call_info": {"func_end_line": 303, "code": "  handleMouseUp (event) {\r\n    window.removeEventListener('mousemove', this.handleMouseMove)\r\n    window.removeEventListener('mouseup', this.handleMouseUp)\r\n    this.setState({resizing: false})\r\n  }\r", "name": "setState", "func_location": "Dock.handleMouseUp", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 302, "func_start_line": 299}}, {"func_info": {"comment": [], "name": "Dock.setState", "params": ["newState"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 177, "start_line": 144}, "call_info": {"func_end_line": 268, "code": "  handleResizeHandleDragStart () {\r\n    window.addEventListener('mousemove', this.handleMouseMove)\r\n    window.addEventListener('mouseup', this.handleMouseUp)\r\n    this.setState({resizing: true})\r\n  }\r", "name": "setState", "func_location": "Dock.handleResizeHandleDragStart", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 267, "func_start_line": 264}}, {"func_info": {"comment": [" Essential: Get the active {Pane}'s active item.", "", " Returns an pane item {Object}."], "name": "Dock.getActivePaneItem", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 651, "start_line": 649}, "call_info": {"func_end_line": 276, "code": "  handleResizeToFit () {\r\n    const item = this.getActivePaneItem()\r\n    if (item) {\r\n      const size = getPreferredSize(item, this.getLocation())\r\n      if (size != null) this.setState({size})\r\n    }\r\n  }\r", "name": "getActivePaneItem", "func_location": "Dock.handleResizeToFit", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 271, "func_start_line": 270}}, {"func_info": {"comment": [], "name": "getPreferredSize", "params": ["item", "location"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 837, "start_line": 825}, "call_info": {"func_end_line": 276, "code": "  handleResizeToFit () {\r\n    const item = this.getActivePaneItem()\r\n    if (item) {\r\n      const size = getPreferredSize(item, this.getLocation())\r\n      if (size != null) this.setState({size})\r\n    }\r\n  }\r", "name": "getPreferredSize", "func_location": "Dock.handleResizeToFit", "args": ["item", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 273, "func_start_line": 270}}, {"func_info": {"comment": [], "name": "Dock.getLocation", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 92, "start_line": 90}, "call_info": {"func_end_line": 276, "code": "  handleResizeToFit () {\r\n    const item = this.getActivePaneItem()\r\n    if (item) {\r\n      const size = getPreferredSize(item, this.getLocation())\r\n      if (size != null) this.setState({size})\r\n    }\r\n  }\r", "name": "getLocation", "func_location": "Dock.handleResizeToFit", "args": ["item", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 273, "func_start_line": 270}}, {"func_info": {"comment": [], "name": "Dock.setState", "params": ["newState"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 177, "start_line": 144}, "call_info": {"func_end_line": 276, "code": "  handleResizeToFit () {\r\n    const item = this.getActivePaneItem()\r\n    if (item) {\r\n      const size = getPreferredSize(item, this.getLocation())\r\n      if (size != null) this.setState({size})\r\n    }\r\n  }\r", "name": "setState", "func_location": "Dock.handleResizeToFit", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 274, "func_start_line": 270}}, {"func_info": {"comment": [], "name": "AtomWindow.isSpecWindow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "end_line": 384, "start_line": 382}, "call_info": {"func_end_line": 364, "code": "  handlesAtomCommands () {\r\n    return !this.isSpecWindow() && this.isWebViewFocused()\r\n  }\r", "name": "isSpecWindow", "func_location": "AtomWindow.handlesAtomCommands", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "line": 363, "func_start_line": 362}}, {"func_info": {"comment": [], "name": "AtomWindow.isWebViewFocused", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "end_line": 380, "start_line": 378}, "call_info": {"func_end_line": 364, "code": "  handlesAtomCommands () {\r\n    return !this.isSpecWindow() && this.isWebViewFocused()\r\n  }\r", "name": "isWebViewFocused", "func_location": "AtomWindow.handlesAtomCommands", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "line": 363, "func_start_line": 362}}, {"func_info": {"comment": [], "name": "Pane.getMessageForErrorCode", "params": ["errorCode"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 1259, "start_line": 1246}, "call_info": {"func_end_line": 1244, "code": "  handleSaveError (error, item) {\r\n    const itemPath = error.path || (typeof item.getPath === 'function' && item.getPath())\r\n    const addWarningWithPath = (message, options) => {\r\n      if (itemPath) message = `${message} '${itemPath}'`\r\n      this.notificationManager.addWarning(message, options)\r\n    }\r\n\r\n    const customMessage = this.getMessageForErrorCode(error.code)\r\n    if (customMessage != null) {\r\n      addWarningWithPath(`Unable to save file: ${customMessage}`)\r\n    } else if (error.code === 'EISDIR' || (error.message && error.message.endsWith('is a directory'))) {\r\n      return this.notificationManager.addWarning(`Unable to save file: ${error.message}`)\r\n    } else if (['EPERM', 'EBUSY', 'UNKNOWN', 'EEXIST', 'ELOOP', 'EAGAIN'].includes(error.code)) {\r\n      addWarningWithPath('Unable to save file', {detail: error.message})\r\n    } else {\r\n      const errorMatch = /ENOTDIR, not a directory '([^']+)'/.exec(error.message)\r\n      if (errorMatch) {\r\n        const fileName = errorMatch[1]\r\n        this.notificationManager.addWarning(`Unable to save file: A directory in the path '${fileName}' could not be written to`)\r\n      } else {\r\n        throw error\r\n      }\r\n    }\r\n  }\r", "name": "getMessageForErrorCode", "func_location": "Pane.handleSaveError", "args": ["error.code"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 1228, "func_start_line": 1221}}, {"func_info": {"comment": [], "name": "Dock.setState", "params": ["newState"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 177, "start_line": 144}, "call_info": {"func_end_line": 309, "code": "  handleToggleButtonDragEnter () {\r\n    this.setState({showDropTarget: true})\r\n    window.addEventListener('drag', this.handleDrag)\r\n    window.addEventListener('dragend', this.handleDragEnd)\r\n  }\r", "name": "setState", "func_location": "Dock.handleToggleButtonDragEnter", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 306, "func_start_line": 305}}, {"func_info": {"comment": [], "name": "Package.activate", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 210, "start_line": 189}, "call_info": {"func_end_line": 424, "code": "  handleURI (methodName, args) {\r\n    this.activate().then(() => {\r\n      if (this.mainModule[methodName]) this.mainModule[methodName].apply(this.mainModule, args)\r\n    })\r\n    if (!this.mainActivated) this.activateNow()\r\n  }\r", "name": "activate", "func_location": "Package.handleURI", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 420, "func_start_line": 419}}, {"func_info": {"comment": [], "name": "Package.activateNow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 236, "start_line": 212}, "call_info": {"func_end_line": 424, "code": "  handleURI (methodName, args) {\r\n    this.activate().then(() => {\r\n      if (this.mainModule[methodName]) this.mainModule[methodName].apply(this.mainModule, args)\r\n    })\r\n    if (!this.mainActivated) this.activateNow()\r\n  }\r", "name": "activateNow", "func_location": "Package.handleURI", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 423, "func_start_line": 419}}, {"func_info": {"comment": [], "name": "Package.getActivationCommands", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 888, "start_line": 870}, "call_info": {"func_end_line": 821, "code": "  hasActivationCommands () {\r\n    const object = this.getActivationCommands()\r\n    for (let selector in object) {\r\n      const commands = object[selector]\r\n      if (commands.length > 0) return true\r\n    }\r\n    return false\r\n  }\r", "name": "getActivationCommands", "func_location": "Package.hasActivationCommands", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 815, "func_start_line": 814}}, {"func_info": {"comment": [], "name": "Package.getActivationHooks", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 917, "start_line": 901}, "call_info": {"func_end_line": 812, "code": "  hasActivationHooks () {\r\n    const hooks = this.getActivationHooks()\r\n    return hooks && hooks.length > 0\r\n  }\r", "name": "getActivationHooks", "func_location": "Package.hasActivationHooks", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 810, "func_start_line": 809}}, {"func_info": {"comment": [], "name": "PackageManager.loadPackageMetadata", "params": ["packagePathOrAvailablePackage", "ignoreErrors"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 882, "start_line": 839}, "call_info": {"func_end_line": 435, "code": "  hasAtomEngine (packagePath) {\r\n    const metadata = this.loadPackageMetadata(packagePath, true)\r\n    return metadata != null && metadata.engines != null && metadata.engines.atom != null\r\n  }\r", "name": "loadPackageMetadata", "func_location": "PackageManager.hasAtomEngine", "args": ["packagePath", {"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 433, "func_start_line": 432}}, {"func_info": {"comment": [" Public: Returns the current {String} SHA for the given reference.", "", " * `reference` The {String} reference to get the target of.", " * `path` An optional {String} path in the repo to get the reference target", "   for. Only needed if the repository contains submodules."], "name": "GitRepository.getReferenceTarget", "params": ["reference", "path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 319, "start_line": 317}, "call_info": {"func_end_line": 215, "comment": [" Public: Returns true if the given branch exists."], "code": "  hasBranch (branch) {\r\n    return this.getReferenceTarget(`refs/heads/${branch}`) != null\r\n  }\r", "name": "getReferenceTarget", "func_location": "GitRepository.hasBranch", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 214, "func_start_line": 213}}, {"func_info": {"comment": [], "name": "Package.getURIHandler", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 921, "start_line": 919}, "call_info": {"func_end_line": 826, "code": "  hasDeferredURIHandler () {\r\n    const handler = this.getURIHandler()\r\n    return handler && handler.deferActivation !== false\r\n  }\r", "name": "getURIHandler", "func_location": "Package.hasDeferredURIHandler", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 824, "func_start_line": 823}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 216, "code": "  hasFocus () {\r\n    return this.getComponent().focused\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.hasFocus", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 215, "func_start_line": 214}}, {"func_info": {"comment": [" Public: Returns the current buffer position as an Array."], "name": "Cursor.getBufferPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 93, "start_line": 91}, "call_info": {"func_end_line": 220, "comment": [" Public: Returns true if this cursor has no non-whitespace characters before", " its current position."], "code": "  hasPrecedingCharactersOnLine () {\r\n    const bufferPosition = this.getBufferPosition()\r\n    const line = this.editor.lineTextForBufferRow(bufferPosition.row)\r\n    const firstCharacterColumn = line.search(/\\S/)\r\n\r\n    if (firstCharacterColumn === -1) {\r\n      return false\r\n    } else {\r\n      return bufferPosition.column > firstCharacterColumn\r\n    }\r\n  }\r", "name": "getBufferPosition", "func_location": "Cursor.hasPrecedingCharactersOnLine", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 211, "func_start_line": 210}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelPositionAfterBlocksForRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2366, "start_line": 2364}, "call_info": {"func_end_line": 2358, "code": "  heightForBlockDecorationsAfterRow (row) {\r\n    const currentRowBottom = this.pixelPositionAfterBlocksForRow(row) + this.getLineHeight()\r\n    const nextRowTop = this.pixelPositionBeforeBlocksForRow(row + 1)\r\n    return nextRowTop - currentRowBottom\r\n  }\r", "name": "pixelPositionAfterBlocksForRow", "func_location": "TextEditorComponent.heightForBlockDecorationsAfterRow", "args": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2355, "func_start_line": 2354}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getLineHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2602, "start_line": 2600}, "call_info": {"func_end_line": 2358, "code": "  heightForBlockDecorationsAfterRow (row) {\r\n    const currentRowBottom = this.pixelPositionAfterBlocksForRow(row) + this.getLineHeight()\r\n    const nextRowTop = this.pixelPositionBeforeBlocksForRow(row + 1)\r\n    return nextRowTop - currentRowBottom\r\n  }\r", "name": "getLineHeight", "func_location": "TextEditorComponent.heightForBlockDecorationsAfterRow", "args": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2355, "func_start_line": 2354}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelPositionBeforeBlocksForRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2362, "start_line": 2360}, "call_info": {"func_end_line": 2358, "code": "  heightForBlockDecorationsAfterRow (row) {\r\n    const currentRowBottom = this.pixelPositionAfterBlocksForRow(row) + this.getLineHeight()\r\n    const nextRowTop = this.pixelPositionBeforeBlocksForRow(row + 1)\r\n    return nextRowTop - currentRowBottom\r\n  }\r", "name": "pixelPositionBeforeBlocksForRow", "func_location": "TextEditorComponent.heightForBlockDecorationsAfterRow", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2356, "func_start_line": 2354}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelPositionAfterBlocksForRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2366, "start_line": 2364}, "call_info": {"func_end_line": 2352, "code": "  heightForBlockDecorationsBeforeRow (row) {\r\n    return this.pixelPositionAfterBlocksForRow(row) - this.pixelPositionBeforeBlocksForRow(row)\r\n  }\r", "name": "pixelPositionAfterBlocksForRow", "func_location": "TextEditorComponent.heightForBlockDecorationsBeforeRow", "args": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2351, "func_start_line": 2350}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelPositionBeforeBlocksForRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2362, "start_line": 2360}, "call_info": {"func_end_line": 2352, "code": "  heightForBlockDecorationsBeforeRow (row) {\r\n    return this.pixelPositionAfterBlocksForRow(row) - this.pixelPositionBeforeBlocksForRow(row)\r\n  }\r", "name": "pixelPositionBeforeBlocksForRow", "func_location": "TextEditorComponent.heightForBlockDecorationsBeforeRow", "args": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2351, "func_start_line": 2350}}, {"func_info": {"comment": [], "name": "Workspace.getPaneContainers", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1625, "start_line": 1618}, "call_info": {"func_end_line": 1116, "comment": [" Essential: Search the workspace for items matching the given URI and hide them.", "", " * `itemOrURI` The item to hide or a {String} containing the URI", "   of the item to hide.", "", " Returns a {Boolean} indicating whether any items were found (and hidden)."], "code": "  hide (itemOrURI) {\r\n    let foundItems = false\r\n\r\n    // If any visible item has the given URI, hide it\r\n    for (const container of this.getPaneContainers()) {\r\n      const isCenter = container === this.getCenter()\r\n      if (isCenter || container.isVisible()) {\r\n        for (const pane of container.getPanes()) {\r\n          const activeItem = pane.getActiveItem()\r\n          const foundItem = (\r\n            activeItem != null && (\r\n              activeItem === itemOrURI ||\r\n              typeof activeItem.getURI === 'function' && activeItem.getURI() === itemOrURI\r\n            )\r\n          )\r\n          if (foundItem) {\r\n            foundItems = true\r\n            // We can't really hide the center so we just destroy the item.\r\n            if (isCenter) {\r\n              pane.destroyItem(activeItem)\r\n            } else {\r\n              container.hide()\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return foundItems\r\n  }\r", "name": "getPaneContainers", "func_location": "Workspace.hide", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1091, "func_start_line": 1087}}, {"func_info": {"comment": ["\r\n  Section: Pane Locations\r\n  ", " Essential: Get the {WorkspaceCenter} at the center of the editor window."], "name": "Workspace.getCenter", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1601, "start_line": 1599}, "call_info": {"func_end_line": 1116, "comment": [" Essential: Search the workspace for items matching the given URI and hide them.", "", " * `itemOrURI` The item to hide or a {String} containing the URI", "   of the item to hide.", "", " Returns a {Boolean} indicating whether any items were found (and hidden)."], "code": "  hide (itemOrURI) {\r\n    let foundItems = false\r\n\r\n    // If any visible item has the given URI, hide it\r\n    for (const container of this.getPaneContainers()) {\r\n      const isCenter = container === this.getCenter()\r\n      if (isCenter || container.isVisible()) {\r\n        for (const pane of container.getPanes()) {\r\n          const activeItem = pane.getActiveItem()\r\n          const foundItem = (\r\n            activeItem != null && (\r\n              activeItem === itemOrURI ||\r\n              typeof activeItem.getURI === 'function' && activeItem.getURI() === itemOrURI\r\n            )\r\n          )\r\n          if (foundItem) {\r\n            foundItems = true\r\n            // We can't really hide the center so we just destroy the item.\r\n            if (isCenter) {\r\n              pane.destroyItem(activeItem)\r\n            } else {\r\n              container.hide()\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return foundItems\r\n  }\r", "name": "getCenter", "func_location": "Workspace.hide", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1092, "func_start_line": 1087}}, {"func_info": {"comment": [], "name": "Dock.setState", "params": ["newState"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 177, "start_line": 144}, "call_info": {"func_end_line": 127, "comment": [" Extended: Hide the dock and activate the {WorkspaceCenter} if the dock was", " was previously focused."], "code": "  hide () {\r\n    this.setState({visible: false})\r\n  }\r", "name": "setState", "func_location": "Dock.hide", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 126, "func_start_line": 125}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.regexForPattern", "params": ["pattern"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 720, "start_line": 713}, "call_info": {"func_end_line": 699, "code": "  increaseIndentRegexForScopeDescriptor (scope) {\r\n    return this.regexForPattern(this.config.get('editor.increaseIndentPattern', {scope}))\r\n  }\r", "name": "regexForPattern", "func_location": "TextMateLanguageMode.increaseIndentRegexForScopeDescriptor", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 698, "func_start_line": 697}}, {"func_info": {"comment": [], "name": "Pane.getContainer", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 128, "start_line": 128}, "call_info": {"func_end_line": 162, "code": "  increaseSize () {\r\n    if (this.getContainer().getPanes().length > 1) {\r\n      this.setFlexScale(this.getFlexScale() * 1.1)\r\n    }\r\n  }\r", "name": "getContainer", "func_location": "Pane.increaseSize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 159, "func_start_line": 158}}, {"func_info": {"comment": [], "name": "Pane.setFlexScale", "params": ["flexScale"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 154, "start_line": 150}, "call_info": {"func_end_line": 162, "code": "  increaseSize () {\r\n    if (this.getContainer().getPanes().length > 1) {\r\n      this.setFlexScale(this.getFlexScale() * 1.1)\r\n    }\r\n  }\r", "name": "setFlexScale", "func_location": "Pane.increaseSize", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 160, "func_start_line": 158}}, {"func_info": {"comment": [], "name": "Pane.getFlexScale", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 156, "start_line": 156}, "call_info": {"func_end_line": 162, "code": "  increaseSize () {\r\n    if (this.getContainer().getPanes().length > 1) {\r\n      this.setFlexScale(this.getFlexScale() * 1.1)\r\n    }\r\n  }\r", "name": "getFlexScale", "func_location": "Pane.increaseSize", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 160, "func_start_line": 158}}, {"func_info": {"comment": [" Public: Get the load settings for the current window.", "", " Returns an {Object} containing all the load setting key/value pairs."], "name": "AtomEnvironment.getLoadSettings", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 527, "start_line": 525}, "call_info": {"func_end_line": 459, "comment": ["\r\n  Section: Atom Details\r\n  ", " Public: Returns a {Boolean} that is `true` if the current window is in development mode."], "code": "  inDevMode () {\r\n    if (this.devMode == null) this.devMode = this.getLoadSettings().devMode\r\n    return this.devMode\r\n  }\r", "name": "getLoadSettings", "func_location": "AtomEnvironment.inDevMode", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 457, "func_start_line": 456}}, {"func_info": {"comment": [], "name": "extend", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip.js", "end_line": 561, "start_line": 550}, "call_info": {"func_end_line": 106, "code": "Tooltip.prototype.init = function (element, options) {\r\n  this.enabled = true\r\n  this.element = element\r\n  this.options = this.getOptions(options)\r\n  this.disposables = new EventKit.CompositeDisposable()\r\n  this.mutationObserver = new MutationObserver(this.handleMutations.bind(this))\r\n\r\n  if (this.options.viewport) {\r\n    if (typeof this.options.viewport === 'function') {\r\n      this.viewport = this.options.viewport.call(this, this.element)\r\n    } else {\r\n      this.viewport = document.querySelector(this.options.viewport.selector || this.options.viewport)\r\n    }\r\n  }\r\n  this.inState = {click: false, hover: false, focus: false}\r\n\r\n  if (this.element instanceof document.constructor && !this.options.selector) {\r\n    throw new Error('`selector` option must be specified when initializing tooltip on the window.document object!')\r\n  }\r\n\r\n  var triggers = this.options.trigger.split(' ')\r\n\r\n  for (var i = triggers.length; i--;) {\r\n    var trigger = triggers[i]\r\n\r\n    if (trigger === 'click') {\r\n      this.disposables.add(listen(this.element, 'click', this.options.selector, this.toggle.bind(this)))\r\n      this.hideOnClickOutsideOfTooltip = (event) => {\r\n        const tooltipElement = this.getTooltipElement()\r\n        if (tooltipElement === event.target) return\r\n        if (tooltipElement.contains(event.target)) return\r\n        if (this.element === event.target) return\r\n        if (this.element.contains(event.target)) return\r\n        this.hide()\r\n      }\r\n    } else if (trigger === 'manual') {\r\n      this.show()\r\n    } else {\r\n      var eventIn, eventOut\r\n\r\n      if (trigger === 'hover') {\r\n        this.hideOnKeydownOutsideOfTooltip = () => this.hide()\r\n        if (this.options.selector) {\r\n          eventIn = 'mouseover'\r\n          eventOut = 'mouseout'\r\n        } else {\r\n          eventIn = 'mouseenter'\r\n          eventOut = 'mouseleave'\r\n        }\r\n      } else {\r\n        eventIn = 'focusin'\r\n        eventOut = 'focusout'\r\n      }\r\n\r\n      this.disposables.add(listen(this.element, eventIn, this.options.selector, this.enter.bind(this)))\r\n      this.disposables.add(listen(this.element, eventOut, this.options.selector, this.leave.bind(this)))\r\n    }\r\n  }\r\n\r\n  this.options.selector\r\n    ? (this._options = extend({}, this.options, { trigger: 'manual', selector: '' }))\r\n    : this.fixTitle()\r\n}\r", "name": "extend", "func_location": "Tooltip.prototype.init", "args": [null, ".options", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tooltip.js", "line": 104, "func_start_line": 44}}, {"func_info": {"comment": [], "name": "AutoUpdateManager.scheduleUpdateCheck", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "end_line": 127, "start_line": 118}, "call_info": {"func_end_line": 90, "code": "  initialize () {\r\n    if (process.platform === 'win32') {\r\n      const archSuffix = process.arch === 'ia32' ? '' : `-${process.arch}`\r\n      this.feedUrl = `https://atom.io/api/updates${archSuffix}?version=${this.version}`\r\n      autoUpdater = require('./auto-updater-win32')\r\n    } else {\r\n      this.feedUrl = `https://atom.io/api/updates?version=${this.version}`;\r\n      ({autoUpdater} = require('electron'))\r\n    }\r\n\r\n    autoUpdater.on('error', (event, message) => {\r\n      this.setState(ErrorState, message)\r\n      this.emitWindowEvent('update-error')\r\n      console.error(`Error Downloading Update: ${message}`)\r\n    })\r\n\r\n    autoUpdater.setFeedURL(this.feedUrl)\r\n\r\n    autoUpdater.on('checking-for-update', () => {\r\n      this.setState(CheckingState)\r\n      this.emitWindowEvent('checking-for-update')\r\n    })\r\n\r\n    autoUpdater.on('update-not-available', () => {\r\n      this.setState(NoUpdateAvailableState)\r\n      this.emitWindowEvent('update-not-available')\r\n    })\r\n\r\n    autoUpdater.on('update-available', () => {\r\n      this.setState(DownloadingState)\r\n      // We use sendMessage to send an event called 'update-available' in 'update-downloaded'\r\n      // once the update download is complete. This mismatch between the electron\r\n      // autoUpdater events is unfortunate but in the interest of not changing the\r\n      // one existing event handled by applicationDelegate\r\n      this.emitWindowEvent('did-begin-downloading-update')\r\n      this.emit('did-begin-download')\r\n    })\r\n\r\n    autoUpdater.on('update-downloaded', (event, releaseNotes, releaseVersion) => {\r\n      this.releaseVersion = releaseVersion\r\n      this.setState(UpdateAvailableState)\r\n      this.emitUpdateAvailableEvent()\r\n    })\r\n\r\n    this.config.onDidChange('core.automaticallyUpdate', ({newValue}) => {\r\n      if (newValue) {\r\n        this.scheduleUpdateCheck()\r\n      } else {\r\n        this.cancelScheduledUpdateCheck()\r\n      }\r\n    })\r\n\r\n    if (this.config.get('core.automaticallyUpdate')) this.scheduleUpdateCheck()\r\n\r\n    switch (process.platform) {\r\n      case 'win32':\r\n        if (!autoUpdater.supportsUpdates()) {\r\n          this.setState(UnsupportedState)\r\n        }\r\n        break\r\n      case 'linux':\r\n        this.setState(UnsupportedState)\r\n    }\r\n  }\r", "name": "scheduleUpdateCheck", "func_location": "AutoUpdateManager.initialize", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "line": 79, "func_start_line": 27}}, {"func_info": {"comment": [], "name": "AutoUpdateManager.setState", "params": ["state", "errorMessage"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "end_line": 108, "start_line": 103}, "call_info": {"func_end_line": 90, "code": "  initialize () {\r\n    if (process.platform === 'win32') {\r\n      const archSuffix = process.arch === 'ia32' ? '' : `-${process.arch}`\r\n      this.feedUrl = `https://atom.io/api/updates${archSuffix}?version=${this.version}`\r\n      autoUpdater = require('./auto-updater-win32')\r\n    } else {\r\n      this.feedUrl = `https://atom.io/api/updates?version=${this.version}`;\r\n      ({autoUpdater} = require('electron'))\r\n    }\r\n\r\n    autoUpdater.on('error', (event, message) => {\r\n      this.setState(ErrorState, message)\r\n      this.emitWindowEvent('update-error')\r\n      console.error(`Error Downloading Update: ${message}`)\r\n    })\r\n\r\n    autoUpdater.setFeedURL(this.feedUrl)\r\n\r\n    autoUpdater.on('checking-for-update', () => {\r\n      this.setState(CheckingState)\r\n      this.emitWindowEvent('checking-for-update')\r\n    })\r\n\r\n    autoUpdater.on('update-not-available', () => {\r\n      this.setState(NoUpdateAvailableState)\r\n      this.emitWindowEvent('update-not-available')\r\n    })\r\n\r\n    autoUpdater.on('update-available', () => {\r\n      this.setState(DownloadingState)\r\n      // We use sendMessage to send an event called 'update-available' in 'update-downloaded'\r\n      // once the update download is complete. This mismatch between the electron\r\n      // autoUpdater events is unfortunate but in the interest of not changing the\r\n      // one existing event handled by applicationDelegate\r\n      this.emitWindowEvent('did-begin-downloading-update')\r\n      this.emit('did-begin-download')\r\n    })\r\n\r\n    autoUpdater.on('update-downloaded', (event, releaseNotes, releaseVersion) => {\r\n      this.releaseVersion = releaseVersion\r\n      this.setState(UpdateAvailableState)\r\n      this.emitUpdateAvailableEvent()\r\n    })\r\n\r\n    this.config.onDidChange('core.automaticallyUpdate', ({newValue}) => {\r\n      if (newValue) {\r\n        this.scheduleUpdateCheck()\r\n      } else {\r\n        this.cancelScheduledUpdateCheck()\r\n      }\r\n    })\r\n\r\n    if (this.config.get('core.automaticallyUpdate')) this.scheduleUpdateCheck()\r\n\r\n    switch (process.platform) {\r\n      case 'win32':\r\n        if (!autoUpdater.supportsUpdates()) {\r\n          this.setState(UnsupportedState)\r\n        }\r\n        break\r\n      case 'linux':\r\n        this.setState(UnsupportedState)\r\n    }\r\n  }\r", "name": "setState", "func_location": "AutoUpdateManager.initialize", "args": ["UnsupportedState"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "line": 84, "func_start_line": 27}}, {"func_info": {"comment": [], "name": "AutoUpdateManager.setState", "params": ["state", "errorMessage"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "end_line": 108, "start_line": 103}, "call_info": {"func_end_line": 90, "code": "  initialize () {\r\n    if (process.platform === 'win32') {\r\n      const archSuffix = process.arch === 'ia32' ? '' : `-${process.arch}`\r\n      this.feedUrl = `https://atom.io/api/updates${archSuffix}?version=${this.version}`\r\n      autoUpdater = require('./auto-updater-win32')\r\n    } else {\r\n      this.feedUrl = `https://atom.io/api/updates?version=${this.version}`;\r\n      ({autoUpdater} = require('electron'))\r\n    }\r\n\r\n    autoUpdater.on('error', (event, message) => {\r\n      this.setState(ErrorState, message)\r\n      this.emitWindowEvent('update-error')\r\n      console.error(`Error Downloading Update: ${message}`)\r\n    })\r\n\r\n    autoUpdater.setFeedURL(this.feedUrl)\r\n\r\n    autoUpdater.on('checking-for-update', () => {\r\n      this.setState(CheckingState)\r\n      this.emitWindowEvent('checking-for-update')\r\n    })\r\n\r\n    autoUpdater.on('update-not-available', () => {\r\n      this.setState(NoUpdateAvailableState)\r\n      this.emitWindowEvent('update-not-available')\r\n    })\r\n\r\n    autoUpdater.on('update-available', () => {\r\n      this.setState(DownloadingState)\r\n      // We use sendMessage to send an event called 'update-available' in 'update-downloaded'\r\n      // once the update download is complete. This mismatch between the electron\r\n      // autoUpdater events is unfortunate but in the interest of not changing the\r\n      // one existing event handled by applicationDelegate\r\n      this.emitWindowEvent('did-begin-downloading-update')\r\n      this.emit('did-begin-download')\r\n    })\r\n\r\n    autoUpdater.on('update-downloaded', (event, releaseNotes, releaseVersion) => {\r\n      this.releaseVersion = releaseVersion\r\n      this.setState(UpdateAvailableState)\r\n      this.emitUpdateAvailableEvent()\r\n    })\r\n\r\n    this.config.onDidChange('core.automaticallyUpdate', ({newValue}) => {\r\n      if (newValue) {\r\n        this.scheduleUpdateCheck()\r\n      } else {\r\n        this.cancelScheduledUpdateCheck()\r\n      }\r\n    })\r\n\r\n    if (this.config.get('core.automaticallyUpdate')) this.scheduleUpdateCheck()\r\n\r\n    switch (process.platform) {\r\n      case 'win32':\r\n        if (!autoUpdater.supportsUpdates()) {\r\n          this.setState(UnsupportedState)\r\n        }\r\n        break\r\n      case 'linux':\r\n        this.setState(UnsupportedState)\r\n    }\r\n  }\r", "name": "setState", "func_location": "AutoUpdateManager.initialize", "args": ["UnsupportedState"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js", "line": 88, "func_start_line": 27}}, {"func_info": {"comment": [], "name": "WorkspaceElement.initializeContent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 34, "start_line": 22}, "call_info": {"func_end_line": 140, "code": "  initialize (model, {config, project, styleManager, viewRegistry}) {\r\n    this.handleCenterEnter = this.handleCenterEnter.bind(this)\r\n    this.handleCenterLeave = this.handleCenterLeave.bind(this)\r\n    this.handleEdgesMouseMove = _.throttle(this.handleEdgesMouseMove.bind(this), 100)\r\n    this.handleDockDragEnd = this.handleDockDragEnd.bind(this)\r\n    this.handleDragStart = this.handleDragStart.bind(this)\r\n    this.handleDragEnd = this.handleDragEnd.bind(this)\r\n    this.handleDrop = this.handleDrop.bind(this)\r\n\r\n    this.model = model\r\n    this.viewRegistry = viewRegistry\r\n    this.project = project\r\n    this.config = config\r\n    this.styleManager = styleManager\r\n    if (this.viewRegistry == null) { throw new Error('Must pass a viewRegistry parameter when initializing WorkspaceElements') }\r\n    if (this.project == null) { throw new Error('Must pass a project parameter when initializing WorkspaceElements') }\r\n    if (this.config == null) { throw new Error('Must pass a config parameter when initializing WorkspaceElements') }\r\n    if (this.styleManager == null) { throw new Error('Must pass a styleManager parameter when initializing WorkspaceElements') }\r\n\r\n    this.subscriptions = new CompositeDisposable(\r\n      new Disposable(() => {\r\n        this.paneContainer.removeEventListener('mouseenter', this.handleCenterEnter)\r\n        this.paneContainer.removeEventListener('mouseleave', this.handleCenterLeave)\r\n        window.removeEventListener('mousemove', this.handleEdgesMouseMove)\r\n        window.removeEventListener('dragend', this.handleDockDragEnd)\r\n        window.removeEventListener('dragstart', this.handleDragStart)\r\n        window.removeEventListener('dragend', this.handleDragEnd, true)\r\n        window.removeEventListener('drop', this.handleDrop, true)\r\n      }),\r\n      ...[this.model.getLeftDock(), this.model.getRightDock(), this.model.getBottomDock()]\r\n        .map(dock => dock.onDidChangeHovered(hovered => {\r\n          if (hovered) this.hoveredDock = dock\r\n          else if (dock === this.hoveredDock) this.hoveredDock = null\r\n          this.checkCleanupDockHoverEvents()\r\n        }))\r\n    )\r\n    this.initializeContent()\r\n    this.observeScrollbarStyle()\r\n    this.observeTextEditorFontConfig()\r\n\r\n    this.paneContainer = this.model.getCenter().paneContainer.getElement()\r\n    this.verticalAxis.appendChild(this.paneContainer)\r\n    this.addEventListener('focus', this.handleFocus.bind(this))\r\n\r\n    this.addEventListener('mousewheel', this.handleMousewheel.bind(this), true)\r\n    window.addEventListener('dragstart', this.handleDragStart)\r\n    window.addEventListener('mousemove', this.handleEdgesMouseMove)\r\n\r\n    this.panelContainers = {\r\n      top: this.model.panelContainers.top.getElement(),\r\n      left: this.model.panelContainers.left.getElement(),\r\n      right: this.model.panelContainers.right.getElement(),\r\n      bottom: this.model.panelContainers.bottom.getElement(),\r\n      header: this.model.panelContainers.header.getElement(),\r\n      footer: this.model.panelContainers.footer.getElement(),\r\n      modal: this.model.panelContainers.modal.getElement()\r\n    }\r\n\r\n    this.horizontalAxis.insertBefore(this.panelContainers.left, this.verticalAxis)\r\n    this.horizontalAxis.appendChild(this.panelContainers.right)\r\n\r\n    this.verticalAxis.insertBefore(this.panelContainers.top, this.paneContainer)\r\n    this.verticalAxis.appendChild(this.panelContainers.bottom)\r\n\r\n    this.insertBefore(this.panelContainers.header, this.horizontalAxis)\r\n    this.appendChild(this.panelContainers.footer)\r\n\r\n    this.appendChild(this.panelContainers.modal)\r\n\r\n    this.paneContainer.addEventListener('mouseenter', this.handleCenterEnter)\r\n    this.paneContainer.addEventListener('mouseleave', this.handleCenterLeave)\r\n\r\n    return this\r\n  }\r", "name": "initializeContent", "func_location": "WorkspaceElement.initialize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 103, "func_start_line": 67}}, {"func_info": {"comment": [], "name": "WorkspaceElement.observeScrollbarStyle", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 49, "start_line": 36}, "call_info": {"func_end_line": 140, "code": "  initialize (model, {config, project, styleManager, viewRegistry}) {\r\n    this.handleCenterEnter = this.handleCenterEnter.bind(this)\r\n    this.handleCenterLeave = this.handleCenterLeave.bind(this)\r\n    this.handleEdgesMouseMove = _.throttle(this.handleEdgesMouseMove.bind(this), 100)\r\n    this.handleDockDragEnd = this.handleDockDragEnd.bind(this)\r\n    this.handleDragStart = this.handleDragStart.bind(this)\r\n    this.handleDragEnd = this.handleDragEnd.bind(this)\r\n    this.handleDrop = this.handleDrop.bind(this)\r\n\r\n    this.model = model\r\n    this.viewRegistry = viewRegistry\r\n    this.project = project\r\n    this.config = config\r\n    this.styleManager = styleManager\r\n    if (this.viewRegistry == null) { throw new Error('Must pass a viewRegistry parameter when initializing WorkspaceElements') }\r\n    if (this.project == null) { throw new Error('Must pass a project parameter when initializing WorkspaceElements') }\r\n    if (this.config == null) { throw new Error('Must pass a config parameter when initializing WorkspaceElements') }\r\n    if (this.styleManager == null) { throw new Error('Must pass a styleManager parameter when initializing WorkspaceElements') }\r\n\r\n    this.subscriptions = new CompositeDisposable(\r\n      new Disposable(() => {\r\n        this.paneContainer.removeEventListener('mouseenter', this.handleCenterEnter)\r\n        this.paneContainer.removeEventListener('mouseleave', this.handleCenterLeave)\r\n        window.removeEventListener('mousemove', this.handleEdgesMouseMove)\r\n        window.removeEventListener('dragend', this.handleDockDragEnd)\r\n        window.removeEventListener('dragstart', this.handleDragStart)\r\n        window.removeEventListener('dragend', this.handleDragEnd, true)\r\n        window.removeEventListener('drop', this.handleDrop, true)\r\n      }),\r\n      ...[this.model.getLeftDock(), this.model.getRightDock(), this.model.getBottomDock()]\r\n        .map(dock => dock.onDidChangeHovered(hovered => {\r\n          if (hovered) this.hoveredDock = dock\r\n          else if (dock === this.hoveredDock) this.hoveredDock = null\r\n          this.checkCleanupDockHoverEvents()\r\n        }))\r\n    )\r\n    this.initializeContent()\r\n    this.observeScrollbarStyle()\r\n    this.observeTextEditorFontConfig()\r\n\r\n    this.paneContainer = this.model.getCenter().paneContainer.getElement()\r\n    this.verticalAxis.appendChild(this.paneContainer)\r\n    this.addEventListener('focus', this.handleFocus.bind(this))\r\n\r\n    this.addEventListener('mousewheel', this.handleMousewheel.bind(this), true)\r\n    window.addEventListener('dragstart', this.handleDragStart)\r\n    window.addEventListener('mousemove', this.handleEdgesMouseMove)\r\n\r\n    this.panelContainers = {\r\n      top: this.model.panelContainers.top.getElement(),\r\n      left: this.model.panelContainers.left.getElement(),\r\n      right: this.model.panelContainers.right.getElement(),\r\n      bottom: this.model.panelContainers.bottom.getElement(),\r\n      header: this.model.panelContainers.header.getElement(),\r\n      footer: this.model.panelContainers.footer.getElement(),\r\n      modal: this.model.panelContainers.modal.getElement()\r\n    }\r\n\r\n    this.horizontalAxis.insertBefore(this.panelContainers.left, this.verticalAxis)\r\n    this.horizontalAxis.appendChild(this.panelContainers.right)\r\n\r\n    this.verticalAxis.insertBefore(this.panelContainers.top, this.paneContainer)\r\n    this.verticalAxis.appendChild(this.panelContainers.bottom)\r\n\r\n    this.insertBefore(this.panelContainers.header, this.horizontalAxis)\r\n    this.appendChild(this.panelContainers.footer)\r\n\r\n    this.appendChild(this.panelContainers.modal)\r\n\r\n    this.paneContainer.addEventListener('mouseenter', this.handleCenterEnter)\r\n    this.paneContainer.addEventListener('mouseleave', this.handleCenterLeave)\r\n\r\n    return this\r\n  }\r", "name": "observeScrollbarStyle", "func_location": "WorkspaceElement.initialize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 104, "func_start_line": 67}}, {"func_info": {"comment": [], "name": "WorkspaceElement.observeTextEditorFontConfig", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 56, "start_line": 51}, "call_info": {"func_end_line": 140, "code": "  initialize (model, {config, project, styleManager, viewRegistry}) {\r\n    this.handleCenterEnter = this.handleCenterEnter.bind(this)\r\n    this.handleCenterLeave = this.handleCenterLeave.bind(this)\r\n    this.handleEdgesMouseMove = _.throttle(this.handleEdgesMouseMove.bind(this), 100)\r\n    this.handleDockDragEnd = this.handleDockDragEnd.bind(this)\r\n    this.handleDragStart = this.handleDragStart.bind(this)\r\n    this.handleDragEnd = this.handleDragEnd.bind(this)\r\n    this.handleDrop = this.handleDrop.bind(this)\r\n\r\n    this.model = model\r\n    this.viewRegistry = viewRegistry\r\n    this.project = project\r\n    this.config = config\r\n    this.styleManager = styleManager\r\n    if (this.viewRegistry == null) { throw new Error('Must pass a viewRegistry parameter when initializing WorkspaceElements') }\r\n    if (this.project == null) { throw new Error('Must pass a project parameter when initializing WorkspaceElements') }\r\n    if (this.config == null) { throw new Error('Must pass a config parameter when initializing WorkspaceElements') }\r\n    if (this.styleManager == null) { throw new Error('Must pass a styleManager parameter when initializing WorkspaceElements') }\r\n\r\n    this.subscriptions = new CompositeDisposable(\r\n      new Disposable(() => {\r\n        this.paneContainer.removeEventListener('mouseenter', this.handleCenterEnter)\r\n        this.paneContainer.removeEventListener('mouseleave', this.handleCenterLeave)\r\n        window.removeEventListener('mousemove', this.handleEdgesMouseMove)\r\n        window.removeEventListener('dragend', this.handleDockDragEnd)\r\n        window.removeEventListener('dragstart', this.handleDragStart)\r\n        window.removeEventListener('dragend', this.handleDragEnd, true)\r\n        window.removeEventListener('drop', this.handleDrop, true)\r\n      }),\r\n      ...[this.model.getLeftDock(), this.model.getRightDock(), this.model.getBottomDock()]\r\n        .map(dock => dock.onDidChangeHovered(hovered => {\r\n          if (hovered) this.hoveredDock = dock\r\n          else if (dock === this.hoveredDock) this.hoveredDock = null\r\n          this.checkCleanupDockHoverEvents()\r\n        }))\r\n    )\r\n    this.initializeContent()\r\n    this.observeScrollbarStyle()\r\n    this.observeTextEditorFontConfig()\r\n\r\n    this.paneContainer = this.model.getCenter().paneContainer.getElement()\r\n    this.verticalAxis.appendChild(this.paneContainer)\r\n    this.addEventListener('focus', this.handleFocus.bind(this))\r\n\r\n    this.addEventListener('mousewheel', this.handleMousewheel.bind(this), true)\r\n    window.addEventListener('dragstart', this.handleDragStart)\r\n    window.addEventListener('mousemove', this.handleEdgesMouseMove)\r\n\r\n    this.panelContainers = {\r\n      top: this.model.panelContainers.top.getElement(),\r\n      left: this.model.panelContainers.left.getElement(),\r\n      right: this.model.panelContainers.right.getElement(),\r\n      bottom: this.model.panelContainers.bottom.getElement(),\r\n      header: this.model.panelContainers.header.getElement(),\r\n      footer: this.model.panelContainers.footer.getElement(),\r\n      modal: this.model.panelContainers.modal.getElement()\r\n    }\r\n\r\n    this.horizontalAxis.insertBefore(this.panelContainers.left, this.verticalAxis)\r\n    this.horizontalAxis.appendChild(this.panelContainers.right)\r\n\r\n    this.verticalAxis.insertBefore(this.panelContainers.top, this.paneContainer)\r\n    this.verticalAxis.appendChild(this.panelContainers.bottom)\r\n\r\n    this.insertBefore(this.panelContainers.header, this.horizontalAxis)\r\n    this.appendChild(this.panelContainers.footer)\r\n\r\n    this.appendChild(this.panelContainers.modal)\r\n\r\n    this.paneContainer.addEventListener('mouseenter', this.handleCenterEnter)\r\n    this.paneContainer.addEventListener('mouseleave', this.handleCenterLeave)\r\n\r\n    return this\r\n  }\r", "name": "observeTextEditorFontConfig", "func_location": "WorkspaceElement.initialize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 105, "func_start_line": 67}}, {"func_info": {"comment": [], "name": "ProtocolHandlerInstaller.isSupported", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js", "end_line": 12, "start_line": 10}, "call_info": {"func_end_line": 52, "code": "  initialize (config, notifications) {\r\n    if (!this.isSupported()) {\r\n      return\r\n    }\r\n\r\n    const behaviorWhenNotProtocolClient = config.get(SETTING)\r\n    switch (behaviorWhenNotProtocolClient) {\r\n      case PROMPT:\r\n        if (!this.isDefaultProtocolClient()) {\r\n          this.promptToBecomeProtocolClient(config, notifications)\r\n        }\r\n        break\r\n      case ALWAYS:\r\n        if (!this.isDefaultProtocolClient()) {\r\n          this.setAsDefaultProtocolClient()\r\n        }\r\n        break\r\n      case NEVER:\r\n        if (process.platform === 'win32') {\r\n          // Only win32 supports deregistration\r\n          const Registry = require('winreg')\r\n          const commandKey = new Registry({hive: 'HKCR', key: `\\\\atom`})\r\n          commandKey.destroy((_err, _val) => { /* no op */ })\r\n        }\r\n        break\r\n      default:\r\n        // Do nothing\r\n    }\r\n  }\r", "name": "isSupported", "func_location": "ProtocolHandlerInstaller.initialize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js", "line": 25, "func_start_line": 24}}, {"func_info": {"comment": [], "name": "ProtocolHandlerInstaller.isDefaultProtocolClient", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js", "end_line": 16, "start_line": 14}, "call_info": {"func_end_line": 52, "code": "  initialize (config, notifications) {\r\n    if (!this.isSupported()) {\r\n      return\r\n    }\r\n\r\n    const behaviorWhenNotProtocolClient = config.get(SETTING)\r\n    switch (behaviorWhenNotProtocolClient) {\r\n      case PROMPT:\r\n        if (!this.isDefaultProtocolClient()) {\r\n          this.promptToBecomeProtocolClient(config, notifications)\r\n        }\r\n        break\r\n      case ALWAYS:\r\n        if (!this.isDefaultProtocolClient()) {\r\n          this.setAsDefaultProtocolClient()\r\n        }\r\n        break\r\n      case NEVER:\r\n        if (process.platform === 'win32') {\r\n          // Only win32 supports deregistration\r\n          const Registry = require('winreg')\r\n          const commandKey = new Registry({hive: 'HKCR', key: `\\\\atom`})\r\n          commandKey.destroy((_err, _val) => { /* no op */ })\r\n        }\r\n        break\r\n      default:\r\n        // Do nothing\r\n    }\r\n  }\r", "name": "isDefaultProtocolClient", "func_location": "ProtocolHandlerInstaller.initialize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js", "line": 32, "func_start_line": 24}}, {"func_info": {"comment": [" Do nothing"], "name": "ProtocolHandlerInstaller.promptToBecomeProtocolClient", "params": ["config", "notifications"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js", "end_line": 100, "start_line": 54}, "call_info": {"func_end_line": 52, "code": "  initialize (config, notifications) {\r\n    if (!this.isSupported()) {\r\n      return\r\n    }\r\n\r\n    const behaviorWhenNotProtocolClient = config.get(SETTING)\r\n    switch (behaviorWhenNotProtocolClient) {\r\n      case PROMPT:\r\n        if (!this.isDefaultProtocolClient()) {\r\n          this.promptToBecomeProtocolClient(config, notifications)\r\n        }\r\n        break\r\n      case ALWAYS:\r\n        if (!this.isDefaultProtocolClient()) {\r\n          this.setAsDefaultProtocolClient()\r\n        }\r\n        break\r\n      case NEVER:\r\n        if (process.platform === 'win32') {\r\n          // Only win32 supports deregistration\r\n          const Registry = require('winreg')\r\n          const commandKey = new Registry({hive: 'HKCR', key: `\\\\atom`})\r\n          commandKey.destroy((_err, _val) => { /* no op */ })\r\n        }\r\n        break\r\n      default:\r\n        // Do nothing\r\n    }\r\n  }\r", "name": "promptToBecomeProtocolClient", "func_location": "ProtocolHandlerInstaller.initialize", "args": ["config", "notifications"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js", "line": 33, "func_start_line": 24}}, {"func_info": {"comment": [], "name": "ProtocolHandlerInstaller.isDefaultProtocolClient", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js", "end_line": 16, "start_line": 14}, "call_info": {"func_end_line": 52, "code": "  initialize (config, notifications) {\r\n    if (!this.isSupported()) {\r\n      return\r\n    }\r\n\r\n    const behaviorWhenNotProtocolClient = config.get(SETTING)\r\n    switch (behaviorWhenNotProtocolClient) {\r\n      case PROMPT:\r\n        if (!this.isDefaultProtocolClient()) {\r\n          this.promptToBecomeProtocolClient(config, notifications)\r\n        }\r\n        break\r\n      case ALWAYS:\r\n        if (!this.isDefaultProtocolClient()) {\r\n          this.setAsDefaultProtocolClient()\r\n        }\r\n        break\r\n      case NEVER:\r\n        if (process.platform === 'win32') {\r\n          // Only win32 supports deregistration\r\n          const Registry = require('winreg')\r\n          const commandKey = new Registry({hive: 'HKCR', key: `\\\\atom`})\r\n          commandKey.destroy((_err, _val) => { /* no op */ })\r\n        }\r\n        break\r\n      default:\r\n        // Do nothing\r\n    }\r\n  }\r", "name": "isDefaultProtocolClient", "func_location": "ProtocolHandlerInstaller.initialize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js", "line": 37, "func_start_line": 24}}, {"func_info": {"comment": [], "name": "ProtocolHandlerInstaller.setAsDefaultProtocolClient", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js", "end_line": 22, "start_line": 18}, "call_info": {"func_end_line": 52, "code": "  initialize (config, notifications) {\r\n    if (!this.isSupported()) {\r\n      return\r\n    }\r\n\r\n    const behaviorWhenNotProtocolClient = config.get(SETTING)\r\n    switch (behaviorWhenNotProtocolClient) {\r\n      case PROMPT:\r\n        if (!this.isDefaultProtocolClient()) {\r\n          this.promptToBecomeProtocolClient(config, notifications)\r\n        }\r\n        break\r\n      case ALWAYS:\r\n        if (!this.isDefaultProtocolClient()) {\r\n          this.setAsDefaultProtocolClient()\r\n        }\r\n        break\r\n      case NEVER:\r\n        if (process.platform === 'win32') {\r\n          // Only win32 supports deregistration\r\n          const Registry = require('winreg')\r\n          const commandKey = new Registry({hive: 'HKCR', key: `\\\\atom`})\r\n          commandKey.destroy((_err, _val) => { /* no op */ })\r\n        }\r\n        break\r\n      default:\r\n        // Do nothing\r\n    }\r\n  }\r", "name": "setAsDefaultProtocolClient", "func_location": "ProtocolHandlerInstaller.initialize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js", "line": 38, "func_start_line": 24}}, {"func_info": {"comment": [" Public: Get the load settings for the current window.", "", " Returns an {Object} containing all the load setting key/value pairs."], "name": "AtomEnvironment.getLoadSettings", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 527, "start_line": 525}, "call_info": {"func_end_line": 274, "code": "  initialize (params = {}) {\r\n    // This will force TextEditorElement to register the custom element, so that\r\n    // using `document.createElement('atom-text-editor')` works if it's called\r\n    // before opening a buffer.\r\n    require('./text-editor-element')\r\n\r\n    this.window = params.window\r\n    this.document = params.document\r\n    this.blobStore = params.blobStore\r\n    this.configDirPath = params.configDirPath\r\n\r\n    const {devMode, safeMode, resourcePath, userSettings, projectSpecification} = this.getLoadSettings()\r\n\r\n    ConfigSchema.projectHome = {\r\n      type: 'string',\r\n      default: path.join(fs.getHomeDirectory(), 'github'),\r\n      description: 'The directory where projects are assumed to be located. Packages created using the Package Generator will be stored here by default.'\r\n    }\r\n\r\n    this.config.initialize({\r\n      mainSource: this.enablePersistence && path.join(this.configDirPath, 'config.cson'),\r\n      projectHomeSchema: ConfigSchema.projectHome\r\n    })\r\n    this.config.resetUserSettings(userSettings)\r\n\r\n    if (projectSpecification != null && projectSpecification.config != null) {\r\n      this.project.replace(projectSpecification)\r\n    }\r\n\r\n    this.menu.initialize({resourcePath})\r\n    this.contextMenu.initialize({resourcePath, devMode})\r\n\r\n    this.keymaps.configDirPath = this.configDirPath\r\n    this.keymaps.resourcePath = resourcePath\r\n    this.keymaps.devMode = devMode\r\n    if (!this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.commands.attach(this.window)\r\n\r\n    this.styles.initialize({configDirPath: this.configDirPath})\r\n    this.packages.initialize({devMode, configDirPath: this.configDirPath, resourcePath, safeMode})\r\n    this.themes.initialize({configDirPath: this.configDirPath, resourcePath, safeMode, devMode})\r\n\r\n    this.commandInstaller.initialize(this.getVersion())\r\n    this.uriHandlerRegistry.registerHostHandler('core', CoreURIHandlers.create(this))\r\n    this.autoUpdater.initialize()\r\n\r\n    this.protocolHandlerInstaller.initialize(this.config, this.notifications)\r\n\r\n    this.themes.loadBaseStylesheets()\r\n    this.initialStyleElements = this.styles.getSnapshot()\r\n    if (params.onlyLoadBaseStyleSheets) this.themes.initialLoadComplete = true\r\n    this.setBodyPlatformClass()\r\n\r\n    this.stylesElement = this.styles.buildStylesElement()\r\n    this.document.head.appendChild(this.stylesElement)\r\n\r\n    this.keymaps.subscribeToFileReadFailure()\r\n\r\n    this.installUncaughtErrorHandler()\r\n    this.attachSaveStateListeners()\r\n    this.windowEventHandler.initialize(this.window, this.document)\r\n\r\n    const didChangeStyles = this.didChangeStyles.bind(this)\r\n    this.disposables.add(this.styles.onDidAddStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidUpdateStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidRemoveStyleElement(didChangeStyles))\r\n\r\n    this.observeAutoHideMenuBar()\r\n\r\n    this.disposables.add(this.applicationDelegate.onDidChangeHistoryManager(() => this.history.loadState()))\r\n  }\r", "name": "getLoadSettings", "func_location": "AtomEnvironment.initialize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 212, "func_start_line": 201}}, {"func_info": {"comment": [" Public: Get the version of the Atom application.", "", " Returns the version text {String}."], "name": "AtomEnvironment.getVersion", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 486, "start_line": 483}, "call_info": {"func_end_line": 274, "code": "  initialize (params = {}) {\r\n    // This will force TextEditorElement to register the custom element, so that\r\n    // using `document.createElement('atom-text-editor')` works if it's called\r\n    // before opening a buffer.\r\n    require('./text-editor-element')\r\n\r\n    this.window = params.window\r\n    this.document = params.document\r\n    this.blobStore = params.blobStore\r\n    this.configDirPath = params.configDirPath\r\n\r\n    const {devMode, safeMode, resourcePath, userSettings, projectSpecification} = this.getLoadSettings()\r\n\r\n    ConfigSchema.projectHome = {\r\n      type: 'string',\r\n      default: path.join(fs.getHomeDirectory(), 'github'),\r\n      description: 'The directory where projects are assumed to be located. Packages created using the Package Generator will be stored here by default.'\r\n    }\r\n\r\n    this.config.initialize({\r\n      mainSource: this.enablePersistence && path.join(this.configDirPath, 'config.cson'),\r\n      projectHomeSchema: ConfigSchema.projectHome\r\n    })\r\n    this.config.resetUserSettings(userSettings)\r\n\r\n    if (projectSpecification != null && projectSpecification.config != null) {\r\n      this.project.replace(projectSpecification)\r\n    }\r\n\r\n    this.menu.initialize({resourcePath})\r\n    this.contextMenu.initialize({resourcePath, devMode})\r\n\r\n    this.keymaps.configDirPath = this.configDirPath\r\n    this.keymaps.resourcePath = resourcePath\r\n    this.keymaps.devMode = devMode\r\n    if (!this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.commands.attach(this.window)\r\n\r\n    this.styles.initialize({configDirPath: this.configDirPath})\r\n    this.packages.initialize({devMode, configDirPath: this.configDirPath, resourcePath, safeMode})\r\n    this.themes.initialize({configDirPath: this.configDirPath, resourcePath, safeMode, devMode})\r\n\r\n    this.commandInstaller.initialize(this.getVersion())\r\n    this.uriHandlerRegistry.registerHostHandler('core', CoreURIHandlers.create(this))\r\n    this.autoUpdater.initialize()\r\n\r\n    this.protocolHandlerInstaller.initialize(this.config, this.notifications)\r\n\r\n    this.themes.loadBaseStylesheets()\r\n    this.initialStyleElements = this.styles.getSnapshot()\r\n    if (params.onlyLoadBaseStyleSheets) this.themes.initialLoadComplete = true\r\n    this.setBodyPlatformClass()\r\n\r\n    this.stylesElement = this.styles.buildStylesElement()\r\n    this.document.head.appendChild(this.stylesElement)\r\n\r\n    this.keymaps.subscribeToFileReadFailure()\r\n\r\n    this.installUncaughtErrorHandler()\r\n    this.attachSaveStateListeners()\r\n    this.windowEventHandler.initialize(this.window, this.document)\r\n\r\n    const didChangeStyles = this.didChangeStyles.bind(this)\r\n    this.disposables.add(this.styles.onDidAddStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidUpdateStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidRemoveStyleElement(didChangeStyles))\r\n\r\n    this.observeAutoHideMenuBar()\r\n\r\n    this.disposables.add(this.applicationDelegate.onDidChangeHistoryManager(() => this.history.loadState()))\r\n  }\r", "name": "getVersion", "func_location": "AtomEnvironment.initialize", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 246, "func_start_line": 201}}, {"func_info": {"comment": [], "name": "AtomEnvironment.setBodyPlatformClass", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1328, "start_line": 1326}, "call_info": {"func_end_line": 274, "code": "  initialize (params = {}) {\r\n    // This will force TextEditorElement to register the custom element, so that\r\n    // using `document.createElement('atom-text-editor')` works if it's called\r\n    // before opening a buffer.\r\n    require('./text-editor-element')\r\n\r\n    this.window = params.window\r\n    this.document = params.document\r\n    this.blobStore = params.blobStore\r\n    this.configDirPath = params.configDirPath\r\n\r\n    const {devMode, safeMode, resourcePath, userSettings, projectSpecification} = this.getLoadSettings()\r\n\r\n    ConfigSchema.projectHome = {\r\n      type: 'string',\r\n      default: path.join(fs.getHomeDirectory(), 'github'),\r\n      description: 'The directory where projects are assumed to be located. Packages created using the Package Generator will be stored here by default.'\r\n    }\r\n\r\n    this.config.initialize({\r\n      mainSource: this.enablePersistence && path.join(this.configDirPath, 'config.cson'),\r\n      projectHomeSchema: ConfigSchema.projectHome\r\n    })\r\n    this.config.resetUserSettings(userSettings)\r\n\r\n    if (projectSpecification != null && projectSpecification.config != null) {\r\n      this.project.replace(projectSpecification)\r\n    }\r\n\r\n    this.menu.initialize({resourcePath})\r\n    this.contextMenu.initialize({resourcePath, devMode})\r\n\r\n    this.keymaps.configDirPath = this.configDirPath\r\n    this.keymaps.resourcePath = resourcePath\r\n    this.keymaps.devMode = devMode\r\n    if (!this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.commands.attach(this.window)\r\n\r\n    this.styles.initialize({configDirPath: this.configDirPath})\r\n    this.packages.initialize({devMode, configDirPath: this.configDirPath, resourcePath, safeMode})\r\n    this.themes.initialize({configDirPath: this.configDirPath, resourcePath, safeMode, devMode})\r\n\r\n    this.commandInstaller.initialize(this.getVersion())\r\n    this.uriHandlerRegistry.registerHostHandler('core', CoreURIHandlers.create(this))\r\n    this.autoUpdater.initialize()\r\n\r\n    this.protocolHandlerInstaller.initialize(this.config, this.notifications)\r\n\r\n    this.themes.loadBaseStylesheets()\r\n    this.initialStyleElements = this.styles.getSnapshot()\r\n    if (params.onlyLoadBaseStyleSheets) this.themes.initialLoadComplete = true\r\n    this.setBodyPlatformClass()\r\n\r\n    this.stylesElement = this.styles.buildStylesElement()\r\n    this.document.head.appendChild(this.stylesElement)\r\n\r\n    this.keymaps.subscribeToFileReadFailure()\r\n\r\n    this.installUncaughtErrorHandler()\r\n    this.attachSaveStateListeners()\r\n    this.windowEventHandler.initialize(this.window, this.document)\r\n\r\n    const didChangeStyles = this.didChangeStyles.bind(this)\r\n    this.disposables.add(this.styles.onDidAddStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidUpdateStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidRemoveStyleElement(didChangeStyles))\r\n\r\n    this.observeAutoHideMenuBar()\r\n\r\n    this.disposables.add(this.applicationDelegate.onDidChangeHistoryManager(() => this.history.loadState()))\r\n  }\r", "name": "setBodyPlatformClass", "func_location": "AtomEnvironment.initialize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 255, "func_start_line": 201}}, {"func_info": {"comment": [], "name": "AtomEnvironment.installUncaughtErrorHandler", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 945, "start_line": 922}, "call_info": {"func_end_line": 274, "code": "  initialize (params = {}) {\r\n    // This will force TextEditorElement to register the custom element, so that\r\n    // using `document.createElement('atom-text-editor')` works if it's called\r\n    // before opening a buffer.\r\n    require('./text-editor-element')\r\n\r\n    this.window = params.window\r\n    this.document = params.document\r\n    this.blobStore = params.blobStore\r\n    this.configDirPath = params.configDirPath\r\n\r\n    const {devMode, safeMode, resourcePath, userSettings, projectSpecification} = this.getLoadSettings()\r\n\r\n    ConfigSchema.projectHome = {\r\n      type: 'string',\r\n      default: path.join(fs.getHomeDirectory(), 'github'),\r\n      description: 'The directory where projects are assumed to be located. Packages created using the Package Generator will be stored here by default.'\r\n    }\r\n\r\n    this.config.initialize({\r\n      mainSource: this.enablePersistence && path.join(this.configDirPath, 'config.cson'),\r\n      projectHomeSchema: ConfigSchema.projectHome\r\n    })\r\n    this.config.resetUserSettings(userSettings)\r\n\r\n    if (projectSpecification != null && projectSpecification.config != null) {\r\n      this.project.replace(projectSpecification)\r\n    }\r\n\r\n    this.menu.initialize({resourcePath})\r\n    this.contextMenu.initialize({resourcePath, devMode})\r\n\r\n    this.keymaps.configDirPath = this.configDirPath\r\n    this.keymaps.resourcePath = resourcePath\r\n    this.keymaps.devMode = devMode\r\n    if (!this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.commands.attach(this.window)\r\n\r\n    this.styles.initialize({configDirPath: this.configDirPath})\r\n    this.packages.initialize({devMode, configDirPath: this.configDirPath, resourcePath, safeMode})\r\n    this.themes.initialize({configDirPath: this.configDirPath, resourcePath, safeMode, devMode})\r\n\r\n    this.commandInstaller.initialize(this.getVersion())\r\n    this.uriHandlerRegistry.registerHostHandler('core', CoreURIHandlers.create(this))\r\n    this.autoUpdater.initialize()\r\n\r\n    this.protocolHandlerInstaller.initialize(this.config, this.notifications)\r\n\r\n    this.themes.loadBaseStylesheets()\r\n    this.initialStyleElements = this.styles.getSnapshot()\r\n    if (params.onlyLoadBaseStyleSheets) this.themes.initialLoadComplete = true\r\n    this.setBodyPlatformClass()\r\n\r\n    this.stylesElement = this.styles.buildStylesElement()\r\n    this.document.head.appendChild(this.stylesElement)\r\n\r\n    this.keymaps.subscribeToFileReadFailure()\r\n\r\n    this.installUncaughtErrorHandler()\r\n    this.attachSaveStateListeners()\r\n    this.windowEventHandler.initialize(this.window, this.document)\r\n\r\n    const didChangeStyles = this.didChangeStyles.bind(this)\r\n    this.disposables.add(this.styles.onDidAddStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidUpdateStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidRemoveStyleElement(didChangeStyles))\r\n\r\n    this.observeAutoHideMenuBar()\r\n\r\n    this.disposables.add(this.applicationDelegate.onDidChangeHistoryManager(() => this.history.loadState()))\r\n  }\r", "name": "installUncaughtErrorHandler", "func_location": "AtomEnvironment.initialize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 262, "func_start_line": 201}}, {"func_info": {"comment": [], "name": "AtomEnvironment.attachSaveStateListeners", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 292, "start_line": 280}, "call_info": {"func_end_line": 274, "code": "  initialize (params = {}) {\r\n    // This will force TextEditorElement to register the custom element, so that\r\n    // using `document.createElement('atom-text-editor')` works if it's called\r\n    // before opening a buffer.\r\n    require('./text-editor-element')\r\n\r\n    this.window = params.window\r\n    this.document = params.document\r\n    this.blobStore = params.blobStore\r\n    this.configDirPath = params.configDirPath\r\n\r\n    const {devMode, safeMode, resourcePath, userSettings, projectSpecification} = this.getLoadSettings()\r\n\r\n    ConfigSchema.projectHome = {\r\n      type: 'string',\r\n      default: path.join(fs.getHomeDirectory(), 'github'),\r\n      description: 'The directory where projects are assumed to be located. Packages created using the Package Generator will be stored here by default.'\r\n    }\r\n\r\n    this.config.initialize({\r\n      mainSource: this.enablePersistence && path.join(this.configDirPath, 'config.cson'),\r\n      projectHomeSchema: ConfigSchema.projectHome\r\n    })\r\n    this.config.resetUserSettings(userSettings)\r\n\r\n    if (projectSpecification != null && projectSpecification.config != null) {\r\n      this.project.replace(projectSpecification)\r\n    }\r\n\r\n    this.menu.initialize({resourcePath})\r\n    this.contextMenu.initialize({resourcePath, devMode})\r\n\r\n    this.keymaps.configDirPath = this.configDirPath\r\n    this.keymaps.resourcePath = resourcePath\r\n    this.keymaps.devMode = devMode\r\n    if (!this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.commands.attach(this.window)\r\n\r\n    this.styles.initialize({configDirPath: this.configDirPath})\r\n    this.packages.initialize({devMode, configDirPath: this.configDirPath, resourcePath, safeMode})\r\n    this.themes.initialize({configDirPath: this.configDirPath, resourcePath, safeMode, devMode})\r\n\r\n    this.commandInstaller.initialize(this.getVersion())\r\n    this.uriHandlerRegistry.registerHostHandler('core', CoreURIHandlers.create(this))\r\n    this.autoUpdater.initialize()\r\n\r\n    this.protocolHandlerInstaller.initialize(this.config, this.notifications)\r\n\r\n    this.themes.loadBaseStylesheets()\r\n    this.initialStyleElements = this.styles.getSnapshot()\r\n    if (params.onlyLoadBaseStyleSheets) this.themes.initialLoadComplete = true\r\n    this.setBodyPlatformClass()\r\n\r\n    this.stylesElement = this.styles.buildStylesElement()\r\n    this.document.head.appendChild(this.stylesElement)\r\n\r\n    this.keymaps.subscribeToFileReadFailure()\r\n\r\n    this.installUncaughtErrorHandler()\r\n    this.attachSaveStateListeners()\r\n    this.windowEventHandler.initialize(this.window, this.document)\r\n\r\n    const didChangeStyles = this.didChangeStyles.bind(this)\r\n    this.disposables.add(this.styles.onDidAddStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidUpdateStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidRemoveStyleElement(didChangeStyles))\r\n\r\n    this.observeAutoHideMenuBar()\r\n\r\n    this.disposables.add(this.applicationDelegate.onDidChangeHistoryManager(() => this.history.loadState()))\r\n  }\r", "name": "attachSaveStateListeners", "func_location": "AtomEnvironment.initialize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 263, "func_start_line": 201}}, {"func_info": {"comment": [], "name": "AtomEnvironment.observeAutoHideMenuBar", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 333, "start_line": 328}, "call_info": {"func_end_line": 274, "code": "  initialize (params = {}) {\r\n    // This will force TextEditorElement to register the custom element, so that\r\n    // using `document.createElement('atom-text-editor')` works if it's called\r\n    // before opening a buffer.\r\n    require('./text-editor-element')\r\n\r\n    this.window = params.window\r\n    this.document = params.document\r\n    this.blobStore = params.blobStore\r\n    this.configDirPath = params.configDirPath\r\n\r\n    const {devMode, safeMode, resourcePath, userSettings, projectSpecification} = this.getLoadSettings()\r\n\r\n    ConfigSchema.projectHome = {\r\n      type: 'string',\r\n      default: path.join(fs.getHomeDirectory(), 'github'),\r\n      description: 'The directory where projects are assumed to be located. Packages created using the Package Generator will be stored here by default.'\r\n    }\r\n\r\n    this.config.initialize({\r\n      mainSource: this.enablePersistence && path.join(this.configDirPath, 'config.cson'),\r\n      projectHomeSchema: ConfigSchema.projectHome\r\n    })\r\n    this.config.resetUserSettings(userSettings)\r\n\r\n    if (projectSpecification != null && projectSpecification.config != null) {\r\n      this.project.replace(projectSpecification)\r\n    }\r\n\r\n    this.menu.initialize({resourcePath})\r\n    this.contextMenu.initialize({resourcePath, devMode})\r\n\r\n    this.keymaps.configDirPath = this.configDirPath\r\n    this.keymaps.resourcePath = resourcePath\r\n    this.keymaps.devMode = devMode\r\n    if (!this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.commands.attach(this.window)\r\n\r\n    this.styles.initialize({configDirPath: this.configDirPath})\r\n    this.packages.initialize({devMode, configDirPath: this.configDirPath, resourcePath, safeMode})\r\n    this.themes.initialize({configDirPath: this.configDirPath, resourcePath, safeMode, devMode})\r\n\r\n    this.commandInstaller.initialize(this.getVersion())\r\n    this.uriHandlerRegistry.registerHostHandler('core', CoreURIHandlers.create(this))\r\n    this.autoUpdater.initialize()\r\n\r\n    this.protocolHandlerInstaller.initialize(this.config, this.notifications)\r\n\r\n    this.themes.loadBaseStylesheets()\r\n    this.initialStyleElements = this.styles.getSnapshot()\r\n    if (params.onlyLoadBaseStyleSheets) this.themes.initialLoadComplete = true\r\n    this.setBodyPlatformClass()\r\n\r\n    this.stylesElement = this.styles.buildStylesElement()\r\n    this.document.head.appendChild(this.stylesElement)\r\n\r\n    this.keymaps.subscribeToFileReadFailure()\r\n\r\n    this.installUncaughtErrorHandler()\r\n    this.attachSaveStateListeners()\r\n    this.windowEventHandler.initialize(this.window, this.document)\r\n\r\n    const didChangeStyles = this.didChangeStyles.bind(this)\r\n    this.disposables.add(this.styles.onDidAddStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidUpdateStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidRemoveStyleElement(didChangeStyles))\r\n\r\n    this.observeAutoHideMenuBar()\r\n\r\n    this.disposables.add(this.applicationDelegate.onDidChangeHistoryManager(() => this.history.loadState()))\r\n  }\r", "name": "observeAutoHideMenuBar", "func_location": "AtomEnvironment.initialize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 271, "func_start_line": 201}}, {"func_info": {"comment": [" Creates server to listen for additional atom application launches.", "", " You can run the atom command multiple times, but after the first launch", " the other launches will just pass their information to this server and then", " close immediately."], "name": "AtomApplication.listenForArgumentsFromNewProcess", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 346, "start_line": 334}, "call_info": {"func_end_line": 161, "comment": [" This stuff was previously done in the constructor, but we want to be able to construct this object", " for testing purposes without booting up the world. As you add tests, feel free to move instantiation", " of these various sub-objects into the constructor, but you'll need to remove the side-effects they", " perform during their construction, adding an initialize method that you call here."], "code": "  async initialize (options) {\r\n    global.atomApplication = this\r\n\r\n    // DEPRECATED: This can be removed at some point (added in 1.13)\r\n    // It converts `useCustomTitleBar: true` to `titleBar: \"custom\"`\r\n    if (process.platform === 'darwin' && this.config.get('core.useCustomTitleBar')) {\r\n      this.config.unset('core.useCustomTitleBar')\r\n      this.config.set('core.titleBar', 'custom')\r\n    }\r\n\r\n    this.applicationMenu = new ApplicationMenu(this.version, this.autoUpdateManager)\r\n    this.atomProtocolHandler = new AtomProtocolHandler(this.resourcePath, this.safeMode)\r\n\r\n    this.listenForArgumentsFromNewProcess()\r\n    this.setupDockMenu()\r\n\r\n    const result = await this.launch(options)\r\n    this.autoUpdateManager.initialize()\r\n    return result\r\n  }\r", "name": "listenForArgumentsFromNewProcess", "func_location": "AtomApplication.initialize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 155, "func_start_line": 142}}, {"func_info": {"comment": [], "name": "AtomApplication.setupDockMenu", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 642, "start_line": 636}, "call_info": {"func_end_line": 161, "comment": [" This stuff was previously done in the constructor, but we want to be able to construct this object", " for testing purposes without booting up the world. As you add tests, feel free to move instantiation", " of these various sub-objects into the constructor, but you'll need to remove the side-effects they", " perform during their construction, adding an initialize method that you call here."], "code": "  async initialize (options) {\r\n    global.atomApplication = this\r\n\r\n    // DEPRECATED: This can be removed at some point (added in 1.13)\r\n    // It converts `useCustomTitleBar: true` to `titleBar: \"custom\"`\r\n    if (process.platform === 'darwin' && this.config.get('core.useCustomTitleBar')) {\r\n      this.config.unset('core.useCustomTitleBar')\r\n      this.config.set('core.titleBar', 'custom')\r\n    }\r\n\r\n    this.applicationMenu = new ApplicationMenu(this.version, this.autoUpdateManager)\r\n    this.atomProtocolHandler = new AtomProtocolHandler(this.resourcePath, this.safeMode)\r\n\r\n    this.listenForArgumentsFromNewProcess()\r\n    this.setupDockMenu()\r\n\r\n    const result = await this.launch(options)\r\n    this.autoUpdateManager.initialize()\r\n    return result\r\n  }\r", "name": "setupDockMenu", "func_location": "AtomApplication.initialize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 156, "func_start_line": 142}}, {"func_info": {"comment": [], "name": "AtomApplication.launch", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 205, "start_line": 172}, "call_info": {"func_end_line": 161, "comment": [" This stuff was previously done in the constructor, but we want to be able to construct this object", " for testing purposes without booting up the world. As you add tests, feel free to move instantiation", " of these various sub-objects into the constructor, but you'll need to remove the side-effects they", " perform during their construction, adding an initialize method that you call here."], "code": "  async initialize (options) {\r\n    global.atomApplication = this\r\n\r\n    // DEPRECATED: This can be removed at some point (added in 1.13)\r\n    // It converts `useCustomTitleBar: true` to `titleBar: \"custom\"`\r\n    if (process.platform === 'darwin' && this.config.get('core.useCustomTitleBar')) {\r\n      this.config.unset('core.useCustomTitleBar')\r\n      this.config.set('core.titleBar', 'custom')\r\n    }\r\n\r\n    this.applicationMenu = new ApplicationMenu(this.version, this.autoUpdateManager)\r\n    this.atomProtocolHandler = new AtomProtocolHandler(this.resourcePath, this.safeMode)\r\n\r\n    this.listenForArgumentsFromNewProcess()\r\n    this.setupDockMenu()\r\n\r\n    const result = await this.launch(options)\r\n    this.autoUpdateManager.initialize()\r\n    return result\r\n  }\r", "name": "launch", "func_location": "AtomApplication.initialize", "args": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 158, "func_start_line": 142}}, {"func_info": {"comment": [], "name": "WindowEventHandler.addEventListener", "params": ["target", "eventName", "handler"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js", "end_line": 107, "start_line": 102}, "call_info": {"func_end_line": 67, "code": "  initialize (window, document) {\r\n    this.window = window\r\n    this.document = document\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.window, {\r\n      'window:toggle-full-screen': this.handleWindowToggleFullScreen,\r\n      'window:close': this.handleWindowClose,\r\n      'window:reload': this.handleWindowReload,\r\n      'window:toggle-dev-tools': this.handleWindowToggleDevTools\r\n    }))\r\n\r\n    if (['win32', 'linux'].includes(process.platform)) {\r\n      this.subscriptions.add(this.atomEnvironment.commands.add(this.window,\r\n        {'window:toggle-menu-bar': this.handleWindowToggleMenuBar})\r\n      )\r\n    }\r\n\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.document, {\r\n      'core:focus-next': this.handleFocusNext,\r\n      'core:focus-previous': this.handleFocusPrevious\r\n    }))\r\n\r\n    this.addEventListener(this.window, 'beforeunload', this.handleWindowBeforeunload)\r\n    this.addEventListener(this.window, 'focus', this.handleWindowFocus)\r\n    this.addEventListener(this.window, 'blur', this.handleWindowBlur)\r\n    this.addEventListener(this.window, 'resize', this.handleWindowResize)\r\n\r\n    this.addEventListener(this.document, 'keyup', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'keydown', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'drop', this.handleDocumentDrop)\r\n    this.addEventListener(this.document, 'dragover', this.handleDocumentDragover)\r\n    this.addEventListener(this.document, 'contextmenu', this.handleDocumentContextmenu)\r\n    this.subscriptions.add(listen(this.document, 'click', 'a', this.handleLinkClick))\r\n    this.subscriptions.add(listen(this.document, 'submit', 'form', this.handleFormSubmit))\r\n\r\n    this.subscriptions.add(this.applicationDelegate.onDidEnterFullScreen(this.handleEnterFullScreen))\r\n    this.subscriptions.add(this.applicationDelegate.onDidLeaveFullScreen(this.handleLeaveFullScreen))\r\n  }\r", "name": "addEventListener", "func_location": "WindowEventHandler.initialize", "args": [".window", {"type": "string"}, ".handleWindowBeforeunload"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js", "line": 52, "func_start_line": 31}}, {"func_info": {"comment": [], "name": "WindowEventHandler.addEventListener", "params": ["target", "eventName", "handler"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js", "end_line": 107, "start_line": 102}, "call_info": {"func_end_line": 67, "code": "  initialize (window, document) {\r\n    this.window = window\r\n    this.document = document\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.window, {\r\n      'window:toggle-full-screen': this.handleWindowToggleFullScreen,\r\n      'window:close': this.handleWindowClose,\r\n      'window:reload': this.handleWindowReload,\r\n      'window:toggle-dev-tools': this.handleWindowToggleDevTools\r\n    }))\r\n\r\n    if (['win32', 'linux'].includes(process.platform)) {\r\n      this.subscriptions.add(this.atomEnvironment.commands.add(this.window,\r\n        {'window:toggle-menu-bar': this.handleWindowToggleMenuBar})\r\n      )\r\n    }\r\n\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.document, {\r\n      'core:focus-next': this.handleFocusNext,\r\n      'core:focus-previous': this.handleFocusPrevious\r\n    }))\r\n\r\n    this.addEventListener(this.window, 'beforeunload', this.handleWindowBeforeunload)\r\n    this.addEventListener(this.window, 'focus', this.handleWindowFocus)\r\n    this.addEventListener(this.window, 'blur', this.handleWindowBlur)\r\n    this.addEventListener(this.window, 'resize', this.handleWindowResize)\r\n\r\n    this.addEventListener(this.document, 'keyup', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'keydown', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'drop', this.handleDocumentDrop)\r\n    this.addEventListener(this.document, 'dragover', this.handleDocumentDragover)\r\n    this.addEventListener(this.document, 'contextmenu', this.handleDocumentContextmenu)\r\n    this.subscriptions.add(listen(this.document, 'click', 'a', this.handleLinkClick))\r\n    this.subscriptions.add(listen(this.document, 'submit', 'form', this.handleFormSubmit))\r\n\r\n    this.subscriptions.add(this.applicationDelegate.onDidEnterFullScreen(this.handleEnterFullScreen))\r\n    this.subscriptions.add(this.applicationDelegate.onDidLeaveFullScreen(this.handleLeaveFullScreen))\r\n  }\r", "name": "addEventListener", "func_location": "WindowEventHandler.initialize", "args": [".window", {"type": "string"}, ".handleWindowFocus"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js", "line": 53, "func_start_line": 31}}, {"func_info": {"comment": [], "name": "WindowEventHandler.addEventListener", "params": ["target", "eventName", "handler"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js", "end_line": 107, "start_line": 102}, "call_info": {"func_end_line": 67, "code": "  initialize (window, document) {\r\n    this.window = window\r\n    this.document = document\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.window, {\r\n      'window:toggle-full-screen': this.handleWindowToggleFullScreen,\r\n      'window:close': this.handleWindowClose,\r\n      'window:reload': this.handleWindowReload,\r\n      'window:toggle-dev-tools': this.handleWindowToggleDevTools\r\n    }))\r\n\r\n    if (['win32', 'linux'].includes(process.platform)) {\r\n      this.subscriptions.add(this.atomEnvironment.commands.add(this.window,\r\n        {'window:toggle-menu-bar': this.handleWindowToggleMenuBar})\r\n      )\r\n    }\r\n\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.document, {\r\n      'core:focus-next': this.handleFocusNext,\r\n      'core:focus-previous': this.handleFocusPrevious\r\n    }))\r\n\r\n    this.addEventListener(this.window, 'beforeunload', this.handleWindowBeforeunload)\r\n    this.addEventListener(this.window, 'focus', this.handleWindowFocus)\r\n    this.addEventListener(this.window, 'blur', this.handleWindowBlur)\r\n    this.addEventListener(this.window, 'resize', this.handleWindowResize)\r\n\r\n    this.addEventListener(this.document, 'keyup', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'keydown', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'drop', this.handleDocumentDrop)\r\n    this.addEventListener(this.document, 'dragover', this.handleDocumentDragover)\r\n    this.addEventListener(this.document, 'contextmenu', this.handleDocumentContextmenu)\r\n    this.subscriptions.add(listen(this.document, 'click', 'a', this.handleLinkClick))\r\n    this.subscriptions.add(listen(this.document, 'submit', 'form', this.handleFormSubmit))\r\n\r\n    this.subscriptions.add(this.applicationDelegate.onDidEnterFullScreen(this.handleEnterFullScreen))\r\n    this.subscriptions.add(this.applicationDelegate.onDidLeaveFullScreen(this.handleLeaveFullScreen))\r\n  }\r", "name": "addEventListener", "func_location": "WindowEventHandler.initialize", "args": [".window", {"type": "string"}, ".handleWindowBlur"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js", "line": 54, "func_start_line": 31}}, {"func_info": {"comment": [], "name": "WindowEventHandler.addEventListener", "params": ["target", "eventName", "handler"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js", "end_line": 107, "start_line": 102}, "call_info": {"func_end_line": 67, "code": "  initialize (window, document) {\r\n    this.window = window\r\n    this.document = document\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.window, {\r\n      'window:toggle-full-screen': this.handleWindowToggleFullScreen,\r\n      'window:close': this.handleWindowClose,\r\n      'window:reload': this.handleWindowReload,\r\n      'window:toggle-dev-tools': this.handleWindowToggleDevTools\r\n    }))\r\n\r\n    if (['win32', 'linux'].includes(process.platform)) {\r\n      this.subscriptions.add(this.atomEnvironment.commands.add(this.window,\r\n        {'window:toggle-menu-bar': this.handleWindowToggleMenuBar})\r\n      )\r\n    }\r\n\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.document, {\r\n      'core:focus-next': this.handleFocusNext,\r\n      'core:focus-previous': this.handleFocusPrevious\r\n    }))\r\n\r\n    this.addEventListener(this.window, 'beforeunload', this.handleWindowBeforeunload)\r\n    this.addEventListener(this.window, 'focus', this.handleWindowFocus)\r\n    this.addEventListener(this.window, 'blur', this.handleWindowBlur)\r\n    this.addEventListener(this.window, 'resize', this.handleWindowResize)\r\n\r\n    this.addEventListener(this.document, 'keyup', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'keydown', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'drop', this.handleDocumentDrop)\r\n    this.addEventListener(this.document, 'dragover', this.handleDocumentDragover)\r\n    this.addEventListener(this.document, 'contextmenu', this.handleDocumentContextmenu)\r\n    this.subscriptions.add(listen(this.document, 'click', 'a', this.handleLinkClick))\r\n    this.subscriptions.add(listen(this.document, 'submit', 'form', this.handleFormSubmit))\r\n\r\n    this.subscriptions.add(this.applicationDelegate.onDidEnterFullScreen(this.handleEnterFullScreen))\r\n    this.subscriptions.add(this.applicationDelegate.onDidLeaveFullScreen(this.handleLeaveFullScreen))\r\n  }\r", "name": "addEventListener", "func_location": "WindowEventHandler.initialize", "args": [".window", {"type": "string"}, ".handleWindowResize"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js", "line": 55, "func_start_line": 31}}, {"func_info": {"comment": [], "name": "WindowEventHandler.addEventListener", "params": ["target", "eventName", "handler"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js", "end_line": 107, "start_line": 102}, "call_info": {"func_end_line": 67, "code": "  initialize (window, document) {\r\n    this.window = window\r\n    this.document = document\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.window, {\r\n      'window:toggle-full-screen': this.handleWindowToggleFullScreen,\r\n      'window:close': this.handleWindowClose,\r\n      'window:reload': this.handleWindowReload,\r\n      'window:toggle-dev-tools': this.handleWindowToggleDevTools\r\n    }))\r\n\r\n    if (['win32', 'linux'].includes(process.platform)) {\r\n      this.subscriptions.add(this.atomEnvironment.commands.add(this.window,\r\n        {'window:toggle-menu-bar': this.handleWindowToggleMenuBar})\r\n      )\r\n    }\r\n\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.document, {\r\n      'core:focus-next': this.handleFocusNext,\r\n      'core:focus-previous': this.handleFocusPrevious\r\n    }))\r\n\r\n    this.addEventListener(this.window, 'beforeunload', this.handleWindowBeforeunload)\r\n    this.addEventListener(this.window, 'focus', this.handleWindowFocus)\r\n    this.addEventListener(this.window, 'blur', this.handleWindowBlur)\r\n    this.addEventListener(this.window, 'resize', this.handleWindowResize)\r\n\r\n    this.addEventListener(this.document, 'keyup', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'keydown', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'drop', this.handleDocumentDrop)\r\n    this.addEventListener(this.document, 'dragover', this.handleDocumentDragover)\r\n    this.addEventListener(this.document, 'contextmenu', this.handleDocumentContextmenu)\r\n    this.subscriptions.add(listen(this.document, 'click', 'a', this.handleLinkClick))\r\n    this.subscriptions.add(listen(this.document, 'submit', 'form', this.handleFormSubmit))\r\n\r\n    this.subscriptions.add(this.applicationDelegate.onDidEnterFullScreen(this.handleEnterFullScreen))\r\n    this.subscriptions.add(this.applicationDelegate.onDidLeaveFullScreen(this.handleLeaveFullScreen))\r\n  }\r", "name": "addEventListener", "func_location": "WindowEventHandler.initialize", "args": [".document", {"type": "string"}, ".handleDocumentKeyEvent"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js", "line": 57, "func_start_line": 31}}, {"func_info": {"comment": [], "name": "WindowEventHandler.addEventListener", "params": ["target", "eventName", "handler"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js", "end_line": 107, "start_line": 102}, "call_info": {"func_end_line": 67, "code": "  initialize (window, document) {\r\n    this.window = window\r\n    this.document = document\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.window, {\r\n      'window:toggle-full-screen': this.handleWindowToggleFullScreen,\r\n      'window:close': this.handleWindowClose,\r\n      'window:reload': this.handleWindowReload,\r\n      'window:toggle-dev-tools': this.handleWindowToggleDevTools\r\n    }))\r\n\r\n    if (['win32', 'linux'].includes(process.platform)) {\r\n      this.subscriptions.add(this.atomEnvironment.commands.add(this.window,\r\n        {'window:toggle-menu-bar': this.handleWindowToggleMenuBar})\r\n      )\r\n    }\r\n\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.document, {\r\n      'core:focus-next': this.handleFocusNext,\r\n      'core:focus-previous': this.handleFocusPrevious\r\n    }))\r\n\r\n    this.addEventListener(this.window, 'beforeunload', this.handleWindowBeforeunload)\r\n    this.addEventListener(this.window, 'focus', this.handleWindowFocus)\r\n    this.addEventListener(this.window, 'blur', this.handleWindowBlur)\r\n    this.addEventListener(this.window, 'resize', this.handleWindowResize)\r\n\r\n    this.addEventListener(this.document, 'keyup', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'keydown', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'drop', this.handleDocumentDrop)\r\n    this.addEventListener(this.document, 'dragover', this.handleDocumentDragover)\r\n    this.addEventListener(this.document, 'contextmenu', this.handleDocumentContextmenu)\r\n    this.subscriptions.add(listen(this.document, 'click', 'a', this.handleLinkClick))\r\n    this.subscriptions.add(listen(this.document, 'submit', 'form', this.handleFormSubmit))\r\n\r\n    this.subscriptions.add(this.applicationDelegate.onDidEnterFullScreen(this.handleEnterFullScreen))\r\n    this.subscriptions.add(this.applicationDelegate.onDidLeaveFullScreen(this.handleLeaveFullScreen))\r\n  }\r", "name": "addEventListener", "func_location": "WindowEventHandler.initialize", "args": [".document", {"type": "string"}, ".handleDocumentKeyEvent"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js", "line": 58, "func_start_line": 31}}, {"func_info": {"comment": [], "name": "WindowEventHandler.addEventListener", "params": ["target", "eventName", "handler"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js", "end_line": 107, "start_line": 102}, "call_info": {"func_end_line": 67, "code": "  initialize (window, document) {\r\n    this.window = window\r\n    this.document = document\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.window, {\r\n      'window:toggle-full-screen': this.handleWindowToggleFullScreen,\r\n      'window:close': this.handleWindowClose,\r\n      'window:reload': this.handleWindowReload,\r\n      'window:toggle-dev-tools': this.handleWindowToggleDevTools\r\n    }))\r\n\r\n    if (['win32', 'linux'].includes(process.platform)) {\r\n      this.subscriptions.add(this.atomEnvironment.commands.add(this.window,\r\n        {'window:toggle-menu-bar': this.handleWindowToggleMenuBar})\r\n      )\r\n    }\r\n\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.document, {\r\n      'core:focus-next': this.handleFocusNext,\r\n      'core:focus-previous': this.handleFocusPrevious\r\n    }))\r\n\r\n    this.addEventListener(this.window, 'beforeunload', this.handleWindowBeforeunload)\r\n    this.addEventListener(this.window, 'focus', this.handleWindowFocus)\r\n    this.addEventListener(this.window, 'blur', this.handleWindowBlur)\r\n    this.addEventListener(this.window, 'resize', this.handleWindowResize)\r\n\r\n    this.addEventListener(this.document, 'keyup', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'keydown', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'drop', this.handleDocumentDrop)\r\n    this.addEventListener(this.document, 'dragover', this.handleDocumentDragover)\r\n    this.addEventListener(this.document, 'contextmenu', this.handleDocumentContextmenu)\r\n    this.subscriptions.add(listen(this.document, 'click', 'a', this.handleLinkClick))\r\n    this.subscriptions.add(listen(this.document, 'submit', 'form', this.handleFormSubmit))\r\n\r\n    this.subscriptions.add(this.applicationDelegate.onDidEnterFullScreen(this.handleEnterFullScreen))\r\n    this.subscriptions.add(this.applicationDelegate.onDidLeaveFullScreen(this.handleLeaveFullScreen))\r\n  }\r", "name": "addEventListener", "func_location": "WindowEventHandler.initialize", "args": [".document", {"type": "string"}, ".handleDocumentDrop"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js", "line": 59, "func_start_line": 31}}, {"func_info": {"comment": [], "name": "WindowEventHandler.addEventListener", "params": ["target", "eventName", "handler"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js", "end_line": 107, "start_line": 102}, "call_info": {"func_end_line": 67, "code": "  initialize (window, document) {\r\n    this.window = window\r\n    this.document = document\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.window, {\r\n      'window:toggle-full-screen': this.handleWindowToggleFullScreen,\r\n      'window:close': this.handleWindowClose,\r\n      'window:reload': this.handleWindowReload,\r\n      'window:toggle-dev-tools': this.handleWindowToggleDevTools\r\n    }))\r\n\r\n    if (['win32', 'linux'].includes(process.platform)) {\r\n      this.subscriptions.add(this.atomEnvironment.commands.add(this.window,\r\n        {'window:toggle-menu-bar': this.handleWindowToggleMenuBar})\r\n      )\r\n    }\r\n\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.document, {\r\n      'core:focus-next': this.handleFocusNext,\r\n      'core:focus-previous': this.handleFocusPrevious\r\n    }))\r\n\r\n    this.addEventListener(this.window, 'beforeunload', this.handleWindowBeforeunload)\r\n    this.addEventListener(this.window, 'focus', this.handleWindowFocus)\r\n    this.addEventListener(this.window, 'blur', this.handleWindowBlur)\r\n    this.addEventListener(this.window, 'resize', this.handleWindowResize)\r\n\r\n    this.addEventListener(this.document, 'keyup', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'keydown', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'drop', this.handleDocumentDrop)\r\n    this.addEventListener(this.document, 'dragover', this.handleDocumentDragover)\r\n    this.addEventListener(this.document, 'contextmenu', this.handleDocumentContextmenu)\r\n    this.subscriptions.add(listen(this.document, 'click', 'a', this.handleLinkClick))\r\n    this.subscriptions.add(listen(this.document, 'submit', 'form', this.handleFormSubmit))\r\n\r\n    this.subscriptions.add(this.applicationDelegate.onDidEnterFullScreen(this.handleEnterFullScreen))\r\n    this.subscriptions.add(this.applicationDelegate.onDidLeaveFullScreen(this.handleLeaveFullScreen))\r\n  }\r", "name": "addEventListener", "func_location": "WindowEventHandler.initialize", "args": [".document", {"type": "string"}, ".handleDocumentDragover"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js", "line": 60, "func_start_line": 31}}, {"func_info": {"comment": [], "name": "WindowEventHandler.addEventListener", "params": ["target", "eventName", "handler"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js", "end_line": 107, "start_line": 102}, "call_info": {"func_end_line": 67, "code": "  initialize (window, document) {\r\n    this.window = window\r\n    this.document = document\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.window, {\r\n      'window:toggle-full-screen': this.handleWindowToggleFullScreen,\r\n      'window:close': this.handleWindowClose,\r\n      'window:reload': this.handleWindowReload,\r\n      'window:toggle-dev-tools': this.handleWindowToggleDevTools\r\n    }))\r\n\r\n    if (['win32', 'linux'].includes(process.platform)) {\r\n      this.subscriptions.add(this.atomEnvironment.commands.add(this.window,\r\n        {'window:toggle-menu-bar': this.handleWindowToggleMenuBar})\r\n      )\r\n    }\r\n\r\n    this.subscriptions.add(this.atomEnvironment.commands.add(this.document, {\r\n      'core:focus-next': this.handleFocusNext,\r\n      'core:focus-previous': this.handleFocusPrevious\r\n    }))\r\n\r\n    this.addEventListener(this.window, 'beforeunload', this.handleWindowBeforeunload)\r\n    this.addEventListener(this.window, 'focus', this.handleWindowFocus)\r\n    this.addEventListener(this.window, 'blur', this.handleWindowBlur)\r\n    this.addEventListener(this.window, 'resize', this.handleWindowResize)\r\n\r\n    this.addEventListener(this.document, 'keyup', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'keydown', this.handleDocumentKeyEvent)\r\n    this.addEventListener(this.document, 'drop', this.handleDocumentDrop)\r\n    this.addEventListener(this.document, 'dragover', this.handleDocumentDragover)\r\n    this.addEventListener(this.document, 'contextmenu', this.handleDocumentContextmenu)\r\n    this.subscriptions.add(listen(this.document, 'click', 'a', this.handleLinkClick))\r\n    this.subscriptions.add(listen(this.document, 'submit', 'form', this.handleFormSubmit))\r\n\r\n    this.subscriptions.add(this.applicationDelegate.onDidEnterFullScreen(this.handleEnterFullScreen))\r\n    this.subscriptions.add(this.applicationDelegate.onDidLeaveFullScreen(this.handleLeaveFullScreen))\r\n  }\r", "name": "addEventListener", "func_location": "WindowEventHandler.initialize", "args": [".document", {"type": "string"}, ".handleDocumentContextmenu"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/window-event-handler.js", "line": 61, "func_start_line": 31}}, {"func_info": {"comment": [], "name": "Package.measure", "params": ["key", "fn"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 85, "start_line": 80}, "call_info": {"func_end_line": 187, "name": "measure", "func_location": "Package.initializeIfNeeded", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 172, "func_start_line": 170}}, {"func_info": {"comment": [" Public: Get the load settings for the current window.", "", " Returns an {Object} containing all the load setting key/value pairs."], "name": "AtomEnvironment.getLoadSettings", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 527, "start_line": 525}, "call_info": {"func_end_line": 465, "comment": [" Public: Returns a {Boolean} that is `true` if the current window is in safe mode."], "code": "  inSafeMode () {\r\n    if (this.safeMode == null) this.safeMode = this.getLoadSettings().safeMode\r\n    return this.safeMode\r\n  }\r", "name": "getLoadSettings", "func_location": "AtomEnvironment.inSafeMode", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 463, "func_start_line": 462}}, {"func_info": {"comment": [], "name": "PaneAxis.addChild", "params": ["child", "index"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js", "end_line": 123, "start_line": 117}, "call_info": {"func_end_line": 171, "code": "  insertChildAfter (currentChild, newChild) {\r\n    const index = this.children.indexOf(currentChild)\r\n    return this.addChild(newChild, index + 1)\r\n  }\r", "name": "addChild", "func_location": "PaneAxis.insertChildAfter", "args": ["newChild", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js", "line": 170, "func_start_line": 168}}, {"func_info": {"comment": [], "name": "PaneAxis.addChild", "params": ["child", "index"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js", "end_line": 123, "start_line": 117}, "call_info": {"func_end_line": 166, "code": "  insertChildBefore (currentChild, newChild) {\r\n    const index = this.children.indexOf(currentChild)\r\n    return this.addChild(newChild, index)\r\n  }\r", "name": "addChild", "func_location": "PaneAxis.insertChildBefore", "args": ["newChild", "index"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js", "line": 165, "func_start_line": 163}}, {"func_info": {"comment": [" Essential: For each selection, replace the selected text with the given text.", "", " * `text` A {String} representing the text to insert.", " * `options` (optional) See {Selection::insertText}.", "", " Returns a {Range} when the text has been inserted. Returns a {Boolean} `false` when the text has not been inserted."], "name": "TextEditor.insertText", "params": ["text", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 1389, "start_line": 1367}, "call_info": {"func_end_line": 1397, "comment": [" Essential: For each selection, replace the selected text with a newline.", "", " * `options` (optional) {Object}", "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)"], "code": "  insertNewline (options = {}) {\r\n    return this.insertText('\\n', options)\r\n  }\r", "name": "insertText", "func_location": "TextEditor.insertNewline", "args": [{"type": "string"}, "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 1396, "func_start_line": 1395}}, {"func_info": {"comment": [" Private: Ensure that the {TextEditor} is not marked read-only before allowing a buffer modification to occur. if", " the editor is read-only, require an explicit opt-in option to proceed (`bypassReadOnly`) or throw an Error."], "name": "Selection.ensureWritable", "params": ["methodName", "opts"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 427, "start_line": 412}, "call_info": {"func_end_line": 513, "comment": ["\r\n  Section: Modifying the selected text\r\n  ", " Public: Replaces text at the current selection.", "", " * `text` A {String} representing the text to add", " * `options` (optional) {Object} with keys:", "   * `select` If `true`, selects the newly added text.", "   * `autoIndent` If `true`, indents all inserted text appropriately.", "   * `autoIndentNewline` If `true`, indent newline appropriately.", "   * `autoDecreaseIndent` If `true`, decreases indent level appropriately", "     (for example, when a closing bracket is inserted).", "   * `preserveTrailingLineIndentation` By default, when pasting multiple", "   lines, Atom attempts to preserve the relative indent level between the", "   first line and trailing lines, even if the indent level of the first", "   line has changed from the copied text. If this option is `true`, this", "   behavior is suppressed.", "     level between the first lines and the trailing lines.", "   * `normalizeLineEndings` (optional) {Boolean} (default: true)", "   * `undo` *Deprecated* If `skip`, skips the undo stack for this operation. This property is deprecated. Call groupLastChanges() on the {TextBuffer} afterward instead.", "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)"], "code": "  insertText (text, options = {}) {\r\n    if (!this.ensureWritable('insertText', options)) return\r\n\r\n    let desiredIndentLevel, indentAdjustment\r\n    const oldBufferRange = this.getBufferRange()\r\n    const wasReversed = this.isReversed()\r\n    this.clear(options)\r\n\r\n    let autoIndentFirstLine = false\r\n    const precedingText = this.editor.getTextInRange([[oldBufferRange.start.row, 0], oldBufferRange.start])\r\n    const remainingLines = text.split('\\n')\r\n    const firstInsertedLine = remainingLines.shift()\r\n\r\n    if (options.indentBasis != null && !options.preserveTrailingLineIndentation) {\r\n      indentAdjustment = this.editor.indentLevelForLine(precedingText) - options.indentBasis\r\n      this.adjustIndent(remainingLines, indentAdjustment)\r\n    }\r\n\r\n    const textIsAutoIndentable = (text === '\\n') || (text === '\\r\\n') || NonWhitespaceRegExp.test(text)\r\n    if (options.autoIndent && textIsAutoIndentable && !NonWhitespaceRegExp.test(precedingText) && (remainingLines.length > 0)) {\r\n      autoIndentFirstLine = true\r\n      const firstLine = precedingText + firstInsertedLine\r\n      const languageMode = this.editor.buffer.getLanguageMode()\r\n      desiredIndentLevel = (\r\n        languageMode.suggestedIndentForLineAtBufferRow &&\r\n        languageMode.suggestedIndentForLineAtBufferRow(\r\n          oldBufferRange.start.row,\r\n          firstLine,\r\n          this.editor.getTabLength()\r\n        )\r\n      )\r\n      if (desiredIndentLevel != null) {\r\n        indentAdjustment = desiredIndentLevel - this.editor.indentLevelForLine(firstLine)\r\n        this.adjustIndent(remainingLines, indentAdjustment)\r\n      }\r\n    }\r\n\r\n    text = firstInsertedLine\r\n    if (remainingLines.length > 0) text += `\\n${remainingLines.join('\\n')}`\r\n\r\n    const newBufferRange = this.editor.buffer.setTextInRange(oldBufferRange, text, pick(options, 'undo', 'normalizeLineEndings'))\r\n\r\n    if (options.select) {\r\n      this.setBufferRange(newBufferRange, {reversed: wasReversed})\r\n    } else {\r\n      if (wasReversed) this.cursor.setBufferPosition(newBufferRange.end)\r\n    }\r\n\r\n    if (autoIndentFirstLine) {\r\n      this.editor.setIndentationForBufferRow(oldBufferRange.start.row, desiredIndentLevel)\r\n    }\r\n\r\n    if (options.autoIndentNewline && (text === '\\n')) {\r\n      this.editor.autoIndentBufferRow(newBufferRange.end.row, {preserveLeadingWhitespace: true, skipBlankLines: false})\r\n    } else if (options.autoDecreaseIndent && NonWhitespaceRegExp.test(text)) {\r\n      this.editor.autoDecreaseIndentForBufferRow(newBufferRange.start.row)\r\n    }\r\n\r\n    const autoscroll = options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.autoscroll()\r\n\r\n    return newBufferRange\r\n  }\r", "name": "ensureWritable", "func_location": "Selection.insertText", "args": [{"type": "string"}, "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 452, "func_start_line": 451}}, {"func_info": {"comment": [" Public: Returns the buffer {Range} for the selection."], "name": "Selection.getBufferRange", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 81, "start_line": 79}, "call_info": {"func_end_line": 513, "comment": ["\r\n  Section: Modifying the selected text\r\n  ", " Public: Replaces text at the current selection.", "", " * `text` A {String} representing the text to add", " * `options` (optional) {Object} with keys:", "   * `select` If `true`, selects the newly added text.", "   * `autoIndent` If `true`, indents all inserted text appropriately.", "   * `autoIndentNewline` If `true`, indent newline appropriately.", "   * `autoDecreaseIndent` If `true`, decreases indent level appropriately", "     (for example, when a closing bracket is inserted).", "   * `preserveTrailingLineIndentation` By default, when pasting multiple", "   lines, Atom attempts to preserve the relative indent level between the", "   first line and trailing lines, even if the indent level of the first", "   line has changed from the copied text. If this option is `true`, this", "   behavior is suppressed.", "     level between the first lines and the trailing lines.", "   * `normalizeLineEndings` (optional) {Boolean} (default: true)", "   * `undo` *Deprecated* If `skip`, skips the undo stack for this operation. This property is deprecated. Call groupLastChanges() on the {TextBuffer} afterward instead.", "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)"], "code": "  insertText (text, options = {}) {\r\n    if (!this.ensureWritable('insertText', options)) return\r\n\r\n    let desiredIndentLevel, indentAdjustment\r\n    const oldBufferRange = this.getBufferRange()\r\n    const wasReversed = this.isReversed()\r\n    this.clear(options)\r\n\r\n    let autoIndentFirstLine = false\r\n    const precedingText = this.editor.getTextInRange([[oldBufferRange.start.row, 0], oldBufferRange.start])\r\n    const remainingLines = text.split('\\n')\r\n    const firstInsertedLine = remainingLines.shift()\r\n\r\n    if (options.indentBasis != null && !options.preserveTrailingLineIndentation) {\r\n      indentAdjustment = this.editor.indentLevelForLine(precedingText) - options.indentBasis\r\n      this.adjustIndent(remainingLines, indentAdjustment)\r\n    }\r\n\r\n    const textIsAutoIndentable = (text === '\\n') || (text === '\\r\\n') || NonWhitespaceRegExp.test(text)\r\n    if (options.autoIndent && textIsAutoIndentable && !NonWhitespaceRegExp.test(precedingText) && (remainingLines.length > 0)) {\r\n      autoIndentFirstLine = true\r\n      const firstLine = precedingText + firstInsertedLine\r\n      const languageMode = this.editor.buffer.getLanguageMode()\r\n      desiredIndentLevel = (\r\n        languageMode.suggestedIndentForLineAtBufferRow &&\r\n        languageMode.suggestedIndentForLineAtBufferRow(\r\n          oldBufferRange.start.row,\r\n          firstLine,\r\n          this.editor.getTabLength()\r\n        )\r\n      )\r\n      if (desiredIndentLevel != null) {\r\n        indentAdjustment = desiredIndentLevel - this.editor.indentLevelForLine(firstLine)\r\n        this.adjustIndent(remainingLines, indentAdjustment)\r\n      }\r\n    }\r\n\r\n    text = firstInsertedLine\r\n    if (remainingLines.length > 0) text += `\\n${remainingLines.join('\\n')}`\r\n\r\n    const newBufferRange = this.editor.buffer.setTextInRange(oldBufferRange, text, pick(options, 'undo', 'normalizeLineEndings'))\r\n\r\n    if (options.select) {\r\n      this.setBufferRange(newBufferRange, {reversed: wasReversed})\r\n    } else {\r\n      if (wasReversed) this.cursor.setBufferPosition(newBufferRange.end)\r\n    }\r\n\r\n    if (autoIndentFirstLine) {\r\n      this.editor.setIndentationForBufferRow(oldBufferRange.start.row, desiredIndentLevel)\r\n    }\r\n\r\n    if (options.autoIndentNewline && (text === '\\n')) {\r\n      this.editor.autoIndentBufferRow(newBufferRange.end.row, {preserveLeadingWhitespace: true, skipBlankLines: false})\r\n    } else if (options.autoDecreaseIndent && NonWhitespaceRegExp.test(text)) {\r\n      this.editor.autoDecreaseIndentForBufferRow(newBufferRange.start.row)\r\n    }\r\n\r\n    const autoscroll = options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.autoscroll()\r\n\r\n    return newBufferRange\r\n  }\r", "name": "getBufferRange", "func_location": "Selection.insertText", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 455, "func_start_line": 451}}, {"func_info": {"comment": [" Public: Determines if the ending position of a marker is greater than the", " starting position.", "", " This can happen when, for example, you highlight text \"up\" in a {TextBuffer}."], "name": "Selection.isReversed", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 149, "start_line": 147}, "call_info": {"func_end_line": 513, "comment": ["\r\n  Section: Modifying the selected text\r\n  ", " Public: Replaces text at the current selection.", "", " * `text` A {String} representing the text to add", " * `options` (optional) {Object} with keys:", "   * `select` If `true`, selects the newly added text.", "   * `autoIndent` If `true`, indents all inserted text appropriately.", "   * `autoIndentNewline` If `true`, indent newline appropriately.", "   * `autoDecreaseIndent` If `true`, decreases indent level appropriately", "     (for example, when a closing bracket is inserted).", "   * `preserveTrailingLineIndentation` By default, when pasting multiple", "   lines, Atom attempts to preserve the relative indent level between the", "   first line and trailing lines, even if the indent level of the first", "   line has changed from the copied text. If this option is `true`, this", "   behavior is suppressed.", "     level between the first lines and the trailing lines.", "   * `normalizeLineEndings` (optional) {Boolean} (default: true)", "   * `undo` *Deprecated* If `skip`, skips the undo stack for this operation. This property is deprecated. Call groupLastChanges() on the {TextBuffer} afterward instead.", "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)"], "code": "  insertText (text, options = {}) {\r\n    if (!this.ensureWritable('insertText', options)) return\r\n\r\n    let desiredIndentLevel, indentAdjustment\r\n    const oldBufferRange = this.getBufferRange()\r\n    const wasReversed = this.isReversed()\r\n    this.clear(options)\r\n\r\n    let autoIndentFirstLine = false\r\n    const precedingText = this.editor.getTextInRange([[oldBufferRange.start.row, 0], oldBufferRange.start])\r\n    const remainingLines = text.split('\\n')\r\n    const firstInsertedLine = remainingLines.shift()\r\n\r\n    if (options.indentBasis != null && !options.preserveTrailingLineIndentation) {\r\n      indentAdjustment = this.editor.indentLevelForLine(precedingText) - options.indentBasis\r\n      this.adjustIndent(remainingLines, indentAdjustment)\r\n    }\r\n\r\n    const textIsAutoIndentable = (text === '\\n') || (text === '\\r\\n') || NonWhitespaceRegExp.test(text)\r\n    if (options.autoIndent && textIsAutoIndentable && !NonWhitespaceRegExp.test(precedingText) && (remainingLines.length > 0)) {\r\n      autoIndentFirstLine = true\r\n      const firstLine = precedingText + firstInsertedLine\r\n      const languageMode = this.editor.buffer.getLanguageMode()\r\n      desiredIndentLevel = (\r\n        languageMode.suggestedIndentForLineAtBufferRow &&\r\n        languageMode.suggestedIndentForLineAtBufferRow(\r\n          oldBufferRange.start.row,\r\n          firstLine,\r\n          this.editor.getTabLength()\r\n        )\r\n      )\r\n      if (desiredIndentLevel != null) {\r\n        indentAdjustment = desiredIndentLevel - this.editor.indentLevelForLine(firstLine)\r\n        this.adjustIndent(remainingLines, indentAdjustment)\r\n      }\r\n    }\r\n\r\n    text = firstInsertedLine\r\n    if (remainingLines.length > 0) text += `\\n${remainingLines.join('\\n')}`\r\n\r\n    const newBufferRange = this.editor.buffer.setTextInRange(oldBufferRange, text, pick(options, 'undo', 'normalizeLineEndings'))\r\n\r\n    if (options.select) {\r\n      this.setBufferRange(newBufferRange, {reversed: wasReversed})\r\n    } else {\r\n      if (wasReversed) this.cursor.setBufferPosition(newBufferRange.end)\r\n    }\r\n\r\n    if (autoIndentFirstLine) {\r\n      this.editor.setIndentationForBufferRow(oldBufferRange.start.row, desiredIndentLevel)\r\n    }\r\n\r\n    if (options.autoIndentNewline && (text === '\\n')) {\r\n      this.editor.autoIndentBufferRow(newBufferRange.end.row, {preserveLeadingWhitespace: true, skipBlankLines: false})\r\n    } else if (options.autoDecreaseIndent && NonWhitespaceRegExp.test(text)) {\r\n      this.editor.autoDecreaseIndentForBufferRow(newBufferRange.start.row)\r\n    }\r\n\r\n    const autoscroll = options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.autoscroll()\r\n\r\n    return newBufferRange\r\n  }\r", "name": "isReversed", "func_location": "Selection.insertText", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 456, "func_start_line": 451}}, {"func_info": {"comment": ["\r\n  Section: Modifying the selected range\r\n  ", " Public: Clears the selection, moving the marker to the head.", "", " * `options` (optional) {Object} with the following keys:", "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new", "     range. Defaults to `true` if this is the most recently added selection,", "     `false` otherwise."], "name": "Selection.clear", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 205, "start_line": 197}, "call_info": {"func_end_line": 513, "comment": ["\r\n  Section: Modifying the selected text\r\n  ", " Public: Replaces text at the current selection.", "", " * `text` A {String} representing the text to add", " * `options` (optional) {Object} with keys:", "   * `select` If `true`, selects the newly added text.", "   * `autoIndent` If `true`, indents all inserted text appropriately.", "   * `autoIndentNewline` If `true`, indent newline appropriately.", "   * `autoDecreaseIndent` If `true`, decreases indent level appropriately", "     (for example, when a closing bracket is inserted).", "   * `preserveTrailingLineIndentation` By default, when pasting multiple", "   lines, Atom attempts to preserve the relative indent level between the", "   first line and trailing lines, even if the indent level of the first", "   line has changed from the copied text. If this option is `true`, this", "   behavior is suppressed.", "     level between the first lines and the trailing lines.", "   * `normalizeLineEndings` (optional) {Boolean} (default: true)", "   * `undo` *Deprecated* If `skip`, skips the undo stack for this operation. This property is deprecated. Call groupLastChanges() on the {TextBuffer} afterward instead.", "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)"], "code": "  insertText (text, options = {}) {\r\n    if (!this.ensureWritable('insertText', options)) return\r\n\r\n    let desiredIndentLevel, indentAdjustment\r\n    const oldBufferRange = this.getBufferRange()\r\n    const wasReversed = this.isReversed()\r\n    this.clear(options)\r\n\r\n    let autoIndentFirstLine = false\r\n    const precedingText = this.editor.getTextInRange([[oldBufferRange.start.row, 0], oldBufferRange.start])\r\n    const remainingLines = text.split('\\n')\r\n    const firstInsertedLine = remainingLines.shift()\r\n\r\n    if (options.indentBasis != null && !options.preserveTrailingLineIndentation) {\r\n      indentAdjustment = this.editor.indentLevelForLine(precedingText) - options.indentBasis\r\n      this.adjustIndent(remainingLines, indentAdjustment)\r\n    }\r\n\r\n    const textIsAutoIndentable = (text === '\\n') || (text === '\\r\\n') || NonWhitespaceRegExp.test(text)\r\n    if (options.autoIndent && textIsAutoIndentable && !NonWhitespaceRegExp.test(precedingText) && (remainingLines.length > 0)) {\r\n      autoIndentFirstLine = true\r\n      const firstLine = precedingText + firstInsertedLine\r\n      const languageMode = this.editor.buffer.getLanguageMode()\r\n      desiredIndentLevel = (\r\n        languageMode.suggestedIndentForLineAtBufferRow &&\r\n        languageMode.suggestedIndentForLineAtBufferRow(\r\n          oldBufferRange.start.row,\r\n          firstLine,\r\n          this.editor.getTabLength()\r\n        )\r\n      )\r\n      if (desiredIndentLevel != null) {\r\n        indentAdjustment = desiredIndentLevel - this.editor.indentLevelForLine(firstLine)\r\n        this.adjustIndent(remainingLines, indentAdjustment)\r\n      }\r\n    }\r\n\r\n    text = firstInsertedLine\r\n    if (remainingLines.length > 0) text += `\\n${remainingLines.join('\\n')}`\r\n\r\n    const newBufferRange = this.editor.buffer.setTextInRange(oldBufferRange, text, pick(options, 'undo', 'normalizeLineEndings'))\r\n\r\n    if (options.select) {\r\n      this.setBufferRange(newBufferRange, {reversed: wasReversed})\r\n    } else {\r\n      if (wasReversed) this.cursor.setBufferPosition(newBufferRange.end)\r\n    }\r\n\r\n    if (autoIndentFirstLine) {\r\n      this.editor.setIndentationForBufferRow(oldBufferRange.start.row, desiredIndentLevel)\r\n    }\r\n\r\n    if (options.autoIndentNewline && (text === '\\n')) {\r\n      this.editor.autoIndentBufferRow(newBufferRange.end.row, {preserveLeadingWhitespace: true, skipBlankLines: false})\r\n    } else if (options.autoDecreaseIndent && NonWhitespaceRegExp.test(text)) {\r\n      this.editor.autoDecreaseIndentForBufferRow(newBufferRange.start.row)\r\n    }\r\n\r\n    const autoscroll = options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.autoscroll()\r\n\r\n    return newBufferRange\r\n  }\r", "name": "clear", "func_location": "Selection.insertText", "args": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 457, "func_start_line": 451}}, {"func_info": {"comment": [" Public: Modifies the buffer {Range} for the selection.", "", " * `bufferRange` The new {Range} to select.", " * `options` (optional) {Object} with the keys:", "   * `preserveFolds` if `true`, the fold settings are preserved after the", "     selection moves.", "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new", "     range. Defaults to `true` if this is the most recently added selection,", "     `false` otherwise."], "name": "Selection.setBufferRange", "params": ["bufferRange", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 104, "start_line": 92}, "call_info": {"func_end_line": 513, "comment": ["\r\n  Section: Modifying the selected text\r\n  ", " Public: Replaces text at the current selection.", "", " * `text` A {String} representing the text to add", " * `options` (optional) {Object} with keys:", "   * `select` If `true`, selects the newly added text.", "   * `autoIndent` If `true`, indents all inserted text appropriately.", "   * `autoIndentNewline` If `true`, indent newline appropriately.", "   * `autoDecreaseIndent` If `true`, decreases indent level appropriately", "     (for example, when a closing bracket is inserted).", "   * `preserveTrailingLineIndentation` By default, when pasting multiple", "   lines, Atom attempts to preserve the relative indent level between the", "   first line and trailing lines, even if the indent level of the first", "   line has changed from the copied text. If this option is `true`, this", "   behavior is suppressed.", "     level between the first lines and the trailing lines.", "   * `normalizeLineEndings` (optional) {Boolean} (default: true)", "   * `undo` *Deprecated* If `skip`, skips the undo stack for this operation. This property is deprecated. Call groupLastChanges() on the {TextBuffer} afterward instead.", "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)"], "code": "  insertText (text, options = {}) {\r\n    if (!this.ensureWritable('insertText', options)) return\r\n\r\n    let desiredIndentLevel, indentAdjustment\r\n    const oldBufferRange = this.getBufferRange()\r\n    const wasReversed = this.isReversed()\r\n    this.clear(options)\r\n\r\n    let autoIndentFirstLine = false\r\n    const precedingText = this.editor.getTextInRange([[oldBufferRange.start.row, 0], oldBufferRange.start])\r\n    const remainingLines = text.split('\\n')\r\n    const firstInsertedLine = remainingLines.shift()\r\n\r\n    if (options.indentBasis != null && !options.preserveTrailingLineIndentation) {\r\n      indentAdjustment = this.editor.indentLevelForLine(precedingText) - options.indentBasis\r\n      this.adjustIndent(remainingLines, indentAdjustment)\r\n    }\r\n\r\n    const textIsAutoIndentable = (text === '\\n') || (text === '\\r\\n') || NonWhitespaceRegExp.test(text)\r\n    if (options.autoIndent && textIsAutoIndentable && !NonWhitespaceRegExp.test(precedingText) && (remainingLines.length > 0)) {\r\n      autoIndentFirstLine = true\r\n      const firstLine = precedingText + firstInsertedLine\r\n      const languageMode = this.editor.buffer.getLanguageMode()\r\n      desiredIndentLevel = (\r\n        languageMode.suggestedIndentForLineAtBufferRow &&\r\n        languageMode.suggestedIndentForLineAtBufferRow(\r\n          oldBufferRange.start.row,\r\n          firstLine,\r\n          this.editor.getTabLength()\r\n        )\r\n      )\r\n      if (desiredIndentLevel != null) {\r\n        indentAdjustment = desiredIndentLevel - this.editor.indentLevelForLine(firstLine)\r\n        this.adjustIndent(remainingLines, indentAdjustment)\r\n      }\r\n    }\r\n\r\n    text = firstInsertedLine\r\n    if (remainingLines.length > 0) text += `\\n${remainingLines.join('\\n')}`\r\n\r\n    const newBufferRange = this.editor.buffer.setTextInRange(oldBufferRange, text, pick(options, 'undo', 'normalizeLineEndings'))\r\n\r\n    if (options.select) {\r\n      this.setBufferRange(newBufferRange, {reversed: wasReversed})\r\n    } else {\r\n      if (wasReversed) this.cursor.setBufferPosition(newBufferRange.end)\r\n    }\r\n\r\n    if (autoIndentFirstLine) {\r\n      this.editor.setIndentationForBufferRow(oldBufferRange.start.row, desiredIndentLevel)\r\n    }\r\n\r\n    if (options.autoIndentNewline && (text === '\\n')) {\r\n      this.editor.autoIndentBufferRow(newBufferRange.end.row, {preserveLeadingWhitespace: true, skipBlankLines: false})\r\n    } else if (options.autoDecreaseIndent && NonWhitespaceRegExp.test(text)) {\r\n      this.editor.autoDecreaseIndentForBufferRow(newBufferRange.start.row)\r\n    }\r\n\r\n    const autoscroll = options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.autoscroll()\r\n\r\n    return newBufferRange\r\n  }\r", "name": "setBufferRange", "func_location": "Selection.insertText", "args": ["newBufferRange", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 494, "func_start_line": 451}}, {"func_info": {"comment": [], "name": "Selection.isLastSelection", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 31, "start_line": 29}, "call_info": {"func_end_line": 513, "comment": ["\r\n  Section: Modifying the selected text\r\n  ", " Public: Replaces text at the current selection.", "", " * `text` A {String} representing the text to add", " * `options` (optional) {Object} with keys:", "   * `select` If `true`, selects the newly added text.", "   * `autoIndent` If `true`, indents all inserted text appropriately.", "   * `autoIndentNewline` If `true`, indent newline appropriately.", "   * `autoDecreaseIndent` If `true`, decreases indent level appropriately", "     (for example, when a closing bracket is inserted).", "   * `preserveTrailingLineIndentation` By default, when pasting multiple", "   lines, Atom attempts to preserve the relative indent level between the", "   first line and trailing lines, even if the indent level of the first", "   line has changed from the copied text. If this option is `true`, this", "   behavior is suppressed.", "     level between the first lines and the trailing lines.", "   * `normalizeLineEndings` (optional) {Boolean} (default: true)", "   * `undo` *Deprecated* If `skip`, skips the undo stack for this operation. This property is deprecated. Call groupLastChanges() on the {TextBuffer} afterward instead.", "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)"], "code": "  insertText (text, options = {}) {\r\n    if (!this.ensureWritable('insertText', options)) return\r\n\r\n    let desiredIndentLevel, indentAdjustment\r\n    const oldBufferRange = this.getBufferRange()\r\n    const wasReversed = this.isReversed()\r\n    this.clear(options)\r\n\r\n    let autoIndentFirstLine = false\r\n    const precedingText = this.editor.getTextInRange([[oldBufferRange.start.row, 0], oldBufferRange.start])\r\n    const remainingLines = text.split('\\n')\r\n    const firstInsertedLine = remainingLines.shift()\r\n\r\n    if (options.indentBasis != null && !options.preserveTrailingLineIndentation) {\r\n      indentAdjustment = this.editor.indentLevelForLine(precedingText) - options.indentBasis\r\n      this.adjustIndent(remainingLines, indentAdjustment)\r\n    }\r\n\r\n    const textIsAutoIndentable = (text === '\\n') || (text === '\\r\\n') || NonWhitespaceRegExp.test(text)\r\n    if (options.autoIndent && textIsAutoIndentable && !NonWhitespaceRegExp.test(precedingText) && (remainingLines.length > 0)) {\r\n      autoIndentFirstLine = true\r\n      const firstLine = precedingText + firstInsertedLine\r\n      const languageMode = this.editor.buffer.getLanguageMode()\r\n      desiredIndentLevel = (\r\n        languageMode.suggestedIndentForLineAtBufferRow &&\r\n        languageMode.suggestedIndentForLineAtBufferRow(\r\n          oldBufferRange.start.row,\r\n          firstLine,\r\n          this.editor.getTabLength()\r\n        )\r\n      )\r\n      if (desiredIndentLevel != null) {\r\n        indentAdjustment = desiredIndentLevel - this.editor.indentLevelForLine(firstLine)\r\n        this.adjustIndent(remainingLines, indentAdjustment)\r\n      }\r\n    }\r\n\r\n    text = firstInsertedLine\r\n    if (remainingLines.length > 0) text += `\\n${remainingLines.join('\\n')}`\r\n\r\n    const newBufferRange = this.editor.buffer.setTextInRange(oldBufferRange, text, pick(options, 'undo', 'normalizeLineEndings'))\r\n\r\n    if (options.select) {\r\n      this.setBufferRange(newBufferRange, {reversed: wasReversed})\r\n    } else {\r\n      if (wasReversed) this.cursor.setBufferPosition(newBufferRange.end)\r\n    }\r\n\r\n    if (autoIndentFirstLine) {\r\n      this.editor.setIndentationForBufferRow(oldBufferRange.start.row, desiredIndentLevel)\r\n    }\r\n\r\n    if (options.autoIndentNewline && (text === '\\n')) {\r\n      this.editor.autoIndentBufferRow(newBufferRange.end.row, {preserveLeadingWhitespace: true, skipBlankLines: false})\r\n    } else if (options.autoDecreaseIndent && NonWhitespaceRegExp.test(text)) {\r\n      this.editor.autoDecreaseIndentForBufferRow(newBufferRange.start.row)\r\n    }\r\n\r\n    const autoscroll = options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.autoscroll()\r\n\r\n    return newBufferRange\r\n  }\r", "name": "isLastSelection", "func_location": "Selection.insertText", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 509, "func_start_line": 451}}, {"func_info": {"comment": [" Public: Get the load settings for the current window.", "", " Returns an {Object} containing all the load setting key/value pairs."], "name": "AtomEnvironment.getLoadSettings", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 527, "start_line": 525}, "call_info": {"func_end_line": 471, "comment": [" Public: Returns a {Boolean} that is `true` if the current window is running specs."], "code": "  inSpecMode () {\r\n    if (this.specMode == null) this.specMode = this.getLoadSettings().isSpec\r\n    return this.specMode\r\n  }\r", "name": "getLoadSettings", "func_location": "AtomEnvironment.inSpecMode", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 469, "func_start_line": 468}}, {"func_info": {"comment": [], "name": "NativeCompileCache.savePreviousModuleCompile", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/native-compile-cache.js", "end_line": 35, "start_line": 33}, "call_info": {"func_end_line": 27, "code": "  install () {\r\n    this.savePreviousModuleCompile()\r\n    this.overrideModuleCompile()\r\n  }\r", "name": "savePreviousModuleCompile", "func_location": "NativeCompileCache.install", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/native-compile-cache.js", "line": 25, "func_start_line": 24}}, {"func_info": {"comment": [], "name": "NativeCompileCache.overrideModuleCompile", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/native-compile-cache.js", "end_line": 89, "start_line": 37}, "call_info": {"func_end_line": 27, "code": "  install () {\r\n    this.savePreviousModuleCompile()\r\n    this.overrideModuleCompile()\r\n  }\r", "name": "overrideModuleCompile", "func_location": "NativeCompileCache.install", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/native-compile-cache.js", "line": 26, "func_start_line": 24}}, {"func_info": {"comment": [], "name": "CommandInstaller.installCommand", "params": ["commandPath", "commandName", "askForPrivilege", "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js", "end_line": 91, "start_line": 74}, "call_info": {"func_end_line": 72, "name": "installCommand", "func_location": "CommandInstaller.installApmCommand", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js", "line": 66, "func_start_line": 65}}, {"func_info": {"comment": [], "name": "CommandInstaller.getResourcesDirectory", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js", "end_line": 20, "start_line": 18}, "call_info": {"func_end_line": 72, "code": "  installApmCommand (askForPrivilege, callback) {\r\n    this.installCommand(\r\n      path.join(this.getResourcesDirectory(), 'app', 'apm', 'node_modules', '.bin', 'apm'),\r\n      this.getCommandNameForChannel('apm'),\r\n      askForPrivilege,\r\n      callback\r\n    )\r\n  }\r", "name": "getResourcesDirectory", "func_location": "CommandInstaller.installApmCommand", "args": [null, {"type": "string"}, {"type": "string"}, {"type": "string"}, {"type": "string"}, {"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js", "line": 67, "func_start_line": 65}}, {"func_info": {"comment": [], "name": "CommandInstaller.getCommandNameForChannel", "params": ["commandName"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js", "end_line": 54, "start_line": 42}, "call_info": {"func_end_line": 72, "code": "  installApmCommand (askForPrivilege, callback) {\r\n    this.installCommand(\r\n      path.join(this.getResourcesDirectory(), 'app', 'apm', 'node_modules', '.bin', 'apm'),\r\n      this.getCommandNameForChannel('apm'),\r\n      askForPrivilege,\r\n      callback\r\n    )\r\n  }\r", "name": "getCommandNameForChannel", "func_location": "CommandInstaller.installApmCommand", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js", "line": 68, "func_start_line": 65}}, {"func_info": {"comment": [], "name": "CommandInstaller.installCommand", "params": ["commandPath", "commandName", "askForPrivilege", "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js", "end_line": 91, "start_line": 74}, "call_info": {"func_end_line": 63, "name": "installCommand", "func_location": "CommandInstaller.installAtomCommand", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js", "line": 57, "func_start_line": 56}}, {"func_info": {"comment": [], "name": "CommandInstaller.getResourcesDirectory", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js", "end_line": 20, "start_line": 18}, "call_info": {"func_end_line": 63, "code": "  installAtomCommand (askForPrivilege, callback) {\r\n    this.installCommand(\r\n      path.join(this.getResourcesDirectory(), 'app', 'atom.sh'),\r\n      this.getCommandNameForChannel('atom'),\r\n      askForPrivilege,\r\n      callback\r\n    )\r\n  }\r", "name": "getResourcesDirectory", "func_location": "CommandInstaller.installAtomCommand", "args": [null, {"type": "string"}, {"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js", "line": 58, "func_start_line": 56}}, {"func_info": {"comment": [], "name": "CommandInstaller.getCommandNameForChannel", "params": ["commandName"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js", "end_line": 54, "start_line": 42}, "call_info": {"func_end_line": 63, "code": "  installAtomCommand (askForPrivilege, callback) {\r\n    this.installCommand(\r\n      path.join(this.getResourcesDirectory(), 'app', 'atom.sh'),\r\n      this.getCommandNameForChannel('atom'),\r\n      askForPrivilege,\r\n      callback\r\n    )\r\n  }\r", "name": "getCommandNameForChannel", "func_location": "CommandInstaller.installAtomCommand", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js", "line": 59, "func_start_line": 56}}, {"func_info": {"comment": [], "name": "CommandInstaller.getInstallDirectory", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js", "end_line": 16, "start_line": 14}, "call_info": {"func_end_line": 91, "code": "  installCommand (commandPath, commandName, askForPrivilege, callback) {\r\n    if (process.platform !== 'darwin') return callback()\r\n\r\n    const destinationPath = path.join(this.getInstallDirectory(), commandName)\r\n\r\n    fs.readlink(destinationPath, (error, realpath) => {\r\n      if (error && error.code !== 'ENOENT') return callback(error)\r\n      if (realpath === commandPath) return callback(null, commandName)\r\n      this.createSymlink(fs, commandPath, destinationPath, error => {\r\n        if (error && error.code === 'EACCES' && askForPrivilege) {\r\n          const fsAdmin = require('fs-admin')\r\n          this.createSymlink(fsAdmin, commandPath, destinationPath, (error) => { callback(error, commandName) })\r\n        } else {\r\n          callback(error)\r\n        }\r\n      })\r\n    })\r\n  }\r", "name": "getInstallDirectory", "func_location": "CommandInstaller.installCommand", "args": [null, "commandName"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js", "line": 77, "func_start_line": 74}}, {"func_info": {"comment": [], "name": "CommandInstaller.installAtomCommand", "params": ["askForPrivilege", "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js", "end_line": 63, "start_line": 56}, "call_info": {"func_end_line": 40, "name": "installAtomCommand", "func_location": "CommandInstaller.installShellCommandsInteractively", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/command-installer.js", "line": 30, "func_start_line": 22}}, {"func_info": {"comment": [" Public: Returns the buffer {Range} for the selection."], "name": "Selection.getBufferRange", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 81, "start_line": 79}, "call_info": {"func_end_line": 168, "comment": [" Public: Identifies if a selection intersects with a given buffer range.", "", " * `bufferRange` A {Range} to check against.", "", " Returns a {Boolean}"], "code": "  intersectsBufferRange (bufferRange) {\r\n    return this.getBufferRange().intersectsWith(bufferRange)\r\n  }\r", "name": "getBufferRange", "func_location": "Selection.intersectsBufferRange", "args": ["bufferRange"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 167, "func_start_line": 166}}, {"func_info": {"comment": ["\r\n  Section: Managing the selection range\r\n  ", " Public: Returns the screen {Range} for the selection."], "name": "Selection.getScreenRange", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 68, "start_line": 66}, "call_info": {"func_end_line": 176, "code": "  intersectsScreenRow (screenRow) {\r\n    return this.getScreenRange().intersectsRow(screenRow)\r\n  }\r", "name": "getScreenRange", "func_location": "Selection.intersectsScreenRow", "args": ["screenRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 175, "func_start_line": 174}}, {"func_info": {"comment": ["\r\n  Section: Managing the selection range\r\n  ", " Public: Returns the screen {Range} for the selection."], "name": "Selection.getScreenRange", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 68, "start_line": 66}, "call_info": {"func_end_line": 172, "code": "  intersectsScreenRowRange (startRow, endRow) {\r\n    return this.getScreenRange().intersectsRowRange(startRow, endRow)\r\n  }\r", "name": "getScreenRange", "func_location": "Selection.intersectsScreenRowRange", "args": ["startRow", "endRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 171, "func_start_line": 170}}, {"func_info": {"comment": [], "name": "TextEditorElement.getFirstVisibleScreenRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 316, "start_line": 314}, "call_info": {"func_end_line": 331, "code": "  intersectsVisibleRowRange (startRow, endRow) {\r\n    return !(\r\n      endRow <= this.getFirstVisibleScreenRow() ||\r\n      this.getLastVisibleScreenRow() <= startRow\r\n    )\r\n  }\r", "name": "getFirstVisibleScreenRow", "func_location": "TextEditorElement.intersectsVisibleRowRange", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 328, "func_start_line": 326}}, {"func_info": {"comment": [], "name": "TextEditorElement.getLastVisibleScreenRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 320, "start_line": 318}, "call_info": {"func_end_line": 331, "code": "  intersectsVisibleRowRange (startRow, endRow) {\r\n    return !(\r\n      endRow <= this.getFirstVisibleScreenRow() ||\r\n      this.getLastVisibleScreenRow() <= startRow\r\n    )\r\n  }\r", "name": "getLastVisibleScreenRow", "func_location": "TextEditorElement.intersectsVisibleRowRange", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 329, "func_start_line": 326}}, {"func_info": {"comment": [" Public: Returns the buffer {Range} for the selection."], "name": "Selection.getBufferRange", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 81, "start_line": 79}, "call_info": {"func_end_line": 185, "comment": [" Public: Identifies if a selection intersects with another selection.", "", " * `otherSelection` A {Selection} to check against.", "", " Returns a {Boolean}"], "code": "  intersectsWith (otherSelection, exclusive) {\r\n    return this.getBufferRange().intersectsWith(otherSelection.getBufferRange(), exclusive)\r\n  }\r", "name": "getBufferRange", "func_location": "Selection.intersectsWith", "args": [null, "exclusive"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 184, "func_start_line": 183}}, {"func_info": {"comment": [], "name": "TextEditorComponent.scheduleUpdate", "params": ["nextUpdateOnlyBlinksCursors"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 219, "start_line": 204}, "call_info": {"func_end_line": 2578, "code": "  invalidateBlockDecorationDimensions (decoration) {\r\n    this.blockDecorationsToMeasure.add(decoration)\r\n    this.scheduleUpdate()\r\n  }\r", "name": "scheduleUpdate", "func_location": "TextEditorComponent.invalidateBlockDecorationDimensions", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2577, "func_start_line": 2575}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 308, "comment": [" Experimental: Invalidate the passed block {Decoration}'s dimensions,", " forcing them to be recalculated and the surrounding content to be adjusted", " on the next animation frame.", "", " * {blockDecoration} A {Decoration} representing the block decoration you", " want to update the dimensions of."], "code": "  invalidateBlockDecorationDimensions () {\r\n    this.getComponent().invalidateBlockDecorationDimensions(...arguments)\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.invalidateBlockDecorationDimensions", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 307, "func_start_line": 306}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.tokenizeInBackground", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 280, "start_line": 272}, "call_info": {"func_end_line": 340, "code": "  invalidateRow (row) {\r\n    this.invalidRows.push(row)\r\n    this.invalidRows.sort((a, b) => a - b)\r\n    this.tokenizeInBackground()\r\n  }\r", "name": "tokenizeInBackground", "func_location": "TextMateLanguageMode.invalidateRow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 339, "func_start_line": 336}}, {"func_info": {"comment": [" Public: Returns the current buffer position as an Array."], "name": "Cursor.getBufferPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 93, "start_line": 91}, "call_info": {"func_end_line": 124, "comment": [" Public: Returns whether the cursor is at the start of a line."], "code": "  isAtBeginningOfLine () {\r\n    return this.getBufferPosition().column === 0\r\n  }\r", "name": "getBufferPosition", "func_location": "Cursor.isAtBeginningOfLine", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 123, "func_start_line": 122}}, {"func_info": {"comment": [" Public: Returns the current buffer position as an Array."], "name": "Cursor.getBufferPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 93, "start_line": 91}, "call_info": {"func_end_line": 129, "comment": [" Public: Returns whether the cursor is on the line return character."], "code": "  isAtEndOfLine () {\r\n    return this.getBufferPosition().isEqual(this.getCurrentLineBufferRange().end)\r\n  }\r", "name": "getBufferPosition", "func_location": "Cursor.isAtEndOfLine", "args": [".end"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 128, "func_start_line": 127}}, {"func_info": {"comment": [" Public: Returns the buffer Range for the current line.", "", " * `options` (optional) {Object}", "   * `includeNewline` A {Boolean} which controls whether the Range should", "     include the newline."], "name": "Cursor.getCurrentLineBufferRange", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 625, "start_line": 623}, "call_info": {"func_end_line": 129, "comment": [" Public: Returns whether the cursor is on the line return character."], "code": "  isAtEndOfLine () {\r\n    return this.getBufferPosition().isEqual(this.getCurrentLineBufferRange().end)\r\n  }\r", "name": "getCurrentLineBufferRange", "func_location": "Cursor.isAtEndOfLine", "args": [".end"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 128, "func_start_line": 127}}, {"func_info": {"comment": [" Public: Returns whether the cursor is at the start of a line."], "name": "Cursor.isAtBeginningOfLine", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 124, "start_line": 122}, "call_info": {"func_end_line": 169, "comment": [" Public: Returns whether the cursor is currently between a word and non-word", " character. The non-word characters are defined by the", " `editor.nonWordCharacters` config value.", "", " This method returns false if the character before or after the cursor is", " whitespace.", "", " Returns a Boolean."], "code": "  isBetweenWordAndNonWord () {\r\n    if (this.isAtBeginningOfLine() || this.isAtEndOfLine()) return false\r\n\r\n    const {row, column} = this.getBufferPosition()\r\n    const range = [[row, column - 1], [row, column + 1]]\r\n    const text = this.editor.getTextInBufferRange(range)\r\n    if (/\\s/.test(text[0]) || /\\s/.test(text[1])) return false\r\n\r\n    const nonWordCharacters = this.getNonWordCharacters()\r\n    return nonWordCharacters.includes(text[0]) !== nonWordCharacters.includes(text[1])\r\n  }\r", "name": "isAtBeginningOfLine", "func_location": "Cursor.isBetweenWordAndNonWord", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 160, "func_start_line": 159}}, {"func_info": {"comment": [" Public: Returns whether the cursor is on the line return character."], "name": "Cursor.isAtEndOfLine", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 129, "start_line": 127}, "call_info": {"func_end_line": 169, "comment": [" Public: Returns whether the cursor is currently between a word and non-word", " character. The non-word characters are defined by the", " `editor.nonWordCharacters` config value.", "", " This method returns false if the character before or after the cursor is", " whitespace.", "", " Returns a Boolean."], "code": "  isBetweenWordAndNonWord () {\r\n    if (this.isAtBeginningOfLine() || this.isAtEndOfLine()) return false\r\n\r\n    const {row, column} = this.getBufferPosition()\r\n    const range = [[row, column - 1], [row, column + 1]]\r\n    const text = this.editor.getTextInBufferRange(range)\r\n    if (/\\s/.test(text[0]) || /\\s/.test(text[1])) return false\r\n\r\n    const nonWordCharacters = this.getNonWordCharacters()\r\n    return nonWordCharacters.includes(text[0]) !== nonWordCharacters.includes(text[1])\r\n  }\r", "name": "isAtEndOfLine", "func_location": "Cursor.isBetweenWordAndNonWord", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 160, "func_start_line": 159}}, {"func_info": {"comment": [" Public: Returns the current buffer position as an Array."], "name": "Cursor.getBufferPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 93, "start_line": 91}, "call_info": {"func_end_line": 169, "comment": [" Public: Returns whether the cursor is currently between a word and non-word", " character. The non-word characters are defined by the", " `editor.nonWordCharacters` config value.", "", " This method returns false if the character before or after the cursor is", " whitespace.", "", " Returns a Boolean."], "code": "  isBetweenWordAndNonWord () {\r\n    if (this.isAtBeginningOfLine() || this.isAtEndOfLine()) return false\r\n\r\n    const {row, column} = this.getBufferPosition()\r\n    const range = [[row, column - 1], [row, column + 1]]\r\n    const text = this.editor.getTextInBufferRange(range)\r\n    if (/\\s/.test(text[0]) || /\\s/.test(text[1])) return false\r\n\r\n    const nonWordCharacters = this.getNonWordCharacters()\r\n    return nonWordCharacters.includes(text[0]) !== nonWordCharacters.includes(text[1])\r\n  }\r", "name": "getBufferPosition", "func_location": "Cursor.isBetweenWordAndNonWord", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 162, "func_start_line": 159}}, {"func_info": {"comment": ["\r\n  Section: Private\r\n  "], "name": "Cursor.getNonWordCharacters", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 718, "start_line": 716}, "call_info": {"func_end_line": 169, "comment": [" Public: Returns whether the cursor is currently between a word and non-word", " character. The non-word characters are defined by the", " `editor.nonWordCharacters` config value.", "", " This method returns false if the character before or after the cursor is", " whitespace.", "", " Returns a Boolean."], "code": "  isBetweenWordAndNonWord () {\r\n    if (this.isAtBeginningOfLine() || this.isAtEndOfLine()) return false\r\n\r\n    const {row, column} = this.getBufferPosition()\r\n    const range = [[row, column - 1], [row, column + 1]]\r\n    const text = this.editor.getTextInBufferRange(range)\r\n    if (/\\s/.test(text[0]) || /\\s/.test(text[1])) return false\r\n\r\n    const nonWordCharacters = this.getNonWordCharacters()\r\n    return nonWordCharacters.includes(text[0]) !== nonWordCharacters.includes(text[1])\r\n  }\r", "name": "getNonWordCharacters", "func_location": "Cursor.isBetweenWordAndNonWord", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 167, "func_start_line": 159}}, {"func_info": {"comment": [], "name": "PackageManager.getPackageDependencies", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 430, "start_line": 428}, "call_info": {"func_end_line": 222, "comment": [" Public: Is the package with the given name bundled with Atom?", "", " * `name` - The {String} package name.", "", " Returns a {Boolean}."], "code": "  isBundledPackage (name) {\r\n    return this.getPackageDependencies().hasOwnProperty(name)\r\n  }\r", "name": "getPackageDependencies", "func_location": "PackageManager.isBundledPackage", "args": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 221, "func_start_line": 220}}, {"func_info": {"comment": [], "name": "Package.getMainModulePath", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 803, "start_line": 786}, "call_info": {"func_end_line": 989, "comment": ["\r\n  Section: Native Module Compatibility\r\n  ", " Extended: Are all native modules depended on by this package correctly", " compiled against the current version of Atom?", "", " Incompatible packages cannot be activated.", "", " Returns a {Boolean}, true if compatible, false if incompatible."], "code": "  isCompatible () {\r\n    if (this.compatible == null) {\r\n      if (this.preloadedPackage) {\r\n        this.compatible = true\r\n      } else if (this.getMainModulePath()) {\r\n        this.incompatibleModules = this.getIncompatibleNativeModules()\r\n        this.compatible =\r\n          this.incompatibleModules.length === 0 &&\r\n          this.getBuildFailureOutput() == null\r\n      } else {\r\n        this.compatible = true\r\n      }\r\n    }\r\n    return this.compatible\r\n  }\r", "name": "getMainModulePath", "func_location": "Package.isCompatible", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 979, "func_start_line": 975}}, {"func_info": {"comment": [" Get the incompatible native modules that this package depends on.", " This recurses through all dependencies and requires all modules that", " contain a `.node` file.", "", " This information is cached in local storage on a per package/version basis", " to minimize the impact on startup time."], "name": "Package.getIncompatibleNativeModules", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 1083, "start_line": 1051}, "call_info": {"func_end_line": 989, "comment": ["\r\n  Section: Native Module Compatibility\r\n  ", " Extended: Are all native modules depended on by this package correctly", " compiled against the current version of Atom?", "", " Incompatible packages cannot be activated.", "", " Returns a {Boolean}, true if compatible, false if incompatible."], "code": "  isCompatible () {\r\n    if (this.compatible == null) {\r\n      if (this.preloadedPackage) {\r\n        this.compatible = true\r\n      } else if (this.getMainModulePath()) {\r\n        this.incompatibleModules = this.getIncompatibleNativeModules()\r\n        this.compatible =\r\n          this.incompatibleModules.length === 0 &&\r\n          this.getBuildFailureOutput() == null\r\n      } else {\r\n        this.compatible = true\r\n      }\r\n    }\r\n    return this.compatible\r\n  }\r", "name": "getIncompatibleNativeModules", "func_location": "Package.isCompatible", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 980, "func_start_line": 975}}, {"func_info": {"comment": [" Extended: If a previous rebuild failed, get the contents of stderr.", "", " Returns a {String} or null if no previous build failure occurred."], "name": "Package.getBuildFailureOutput", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 1017, "start_line": 1015}, "call_info": {"func_end_line": 989, "comment": ["\r\n  Section: Native Module Compatibility\r\n  ", " Extended: Are all native modules depended on by this package correctly", " compiled against the current version of Atom?", "", " Incompatible packages cannot be activated.", "", " Returns a {Boolean}, true if compatible, false if incompatible."], "code": "  isCompatible () {\r\n    if (this.compatible == null) {\r\n      if (this.preloadedPackage) {\r\n        this.compatible = true\r\n      } else if (this.getMainModulePath()) {\r\n        this.incompatibleModules = this.getIncompatibleNativeModules()\r\n        this.compatible =\r\n          this.incompatibleModules.length === 0 &&\r\n          this.getBuildFailureOutput() == null\r\n      } else {\r\n        this.compatible = true\r\n      }\r\n    }\r\n    return this.compatible\r\n  }\r", "name": "getBuildFailureOutput", "func_location": "Package.isCompatible", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 983, "func_start_line": 975}}, {"func_info": {"comment": [], "name": "PaneContainer.isAlive", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 39, "start_line": 39}, "call_info": {"func_end_line": 41, "code": "  isDestroyed () { return !this.isAlive() }\r", "name": "isAlive", "func_location": "PaneContainer.isDestroyed", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 41, "func_start_line": 41}}, {"func_info": {"comment": [], "name": "Pane.isAlive", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 1041, "start_line": 1041}, "call_info": {"func_end_line": 1046, "comment": [" Public: Determine whether this pane has been destroyed.", "", " Returns a {Boolean}."], "code": "  isDestroyed () { return !this.isAlive() }\r", "name": "isAlive", "func_location": "Pane.isDestroyed", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 1046, "func_start_line": 1046}}, {"func_info": {"comment": [" Public: Returns the buffer {Range} for the selection."], "name": "Selection.getBufferRange", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 81, "start_line": 79}, "call_info": {"func_end_line": 141, "comment": ["\r\n  Section: Info about the selection\r\n  ", " Public: Determines if the selection contains anything."], "code": "  isEmpty () {\r\n    return this.getBufferRange().isEmpty()\r\n  }\r", "name": "getBufferRange", "func_location": "Selection.isEmpty", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 140, "func_start_line": 139}}, {"func_info": {"comment": [" Public: Returns the {String} message."], "name": "Notification.getMessage", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js", "end_line": 67, "start_line": 65}, "call_info": {"func_end_line": 81, "code": "  isEqual (other) {\r\n    return (this.getMessage() === other.getMessage()) &&\r\n      (this.getType() === other.getType()) &&\r\n      (this.getDetail() === other.getDetail())\r\n  }\r", "name": "getMessage", "func_location": "Notification.isEqual", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js", "line": 78, "func_start_line": 77}}, {"func_info": {"comment": ["\r\n  Section: Methods\r\n  ", " Public: Returns the {String} type."], "name": "Notification.getType", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js", "end_line": 62, "start_line": 60}, "call_info": {"func_end_line": 81, "code": "  isEqual (other) {\r\n    return (this.getMessage() === other.getMessage()) &&\r\n      (this.getType() === other.getType()) &&\r\n      (this.getDetail() === other.getDetail())\r\n  }\r", "name": "getType", "func_location": "Notification.isEqual", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js", "line": 79, "func_start_line": 77}}, {"func_info": {"comment": [], "name": "Notification.getDetail", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js", "end_line": 75, "start_line": 73}, "call_info": {"func_end_line": 81, "code": "  isEqual (other) {\r\n    return (this.getMessage() === other.getMessage()) &&\r\n      (this.getType() === other.getType()) &&\r\n      (this.getDetail() === other.getDetail())\r\n  }\r", "name": "getDetail", "func_location": "Notification.isEqual", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/notification.js", "line": 80, "func_start_line": 77}}, {"func_info": {"comment": [" Essential: Parse a {String} or {Object} into a {Color}.", "", " * `value` A {String} such as `'white'`, `#ff00ff`, or", "   `'rgba(255, 15, 60, .75)'` or an {Object} with `red`, `green`, `blue`,", "   and `alpha` properties.", "", " Returns a {Color} or `null` if it cannot be parsed."], "name": "Color.parse", "params": ["value"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js", "end_line": 36, "start_line": 14}, "call_info": {"func_end_line": 109, "code": "  isEqual (color) {\r\n    if (this === color) {\r\n      return true\r\n    }\r\n\r\n    if (!(color instanceof Color)) {\r\n      color = Color.parse(color)\r\n    }\r\n\r\n    if (color == null) {\r\n      return false\r\n    }\r\n\r\n    return color.red === this.red && color.blue === this.blue && color.green === this.green && color.alpha === this.alpha\r\n  }\r", "name": "parse", "func_location": "Color.isEqual", "args": ["color"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js", "line": 101, "func_start_line": 95}}, {"func_info": {"comment": [" Public: Get the load settings for the current window.", "", " Returns an {Object} containing all the load setting key/value pairs."], "name": "AtomEnvironment.getLoadSettings", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 527, "start_line": 525}, "call_info": {"func_end_line": 478, "comment": [" Returns a {Boolean} indicating whether this the first time the window's been", " loaded."], "code": "  isFirstLoad () {\r\n    if (this.firstLoad == null) this.firstLoad = this.getLoadSettings().firstLoad\r\n    return this.firstLoad\r\n  }\r", "name": "getLoadSettings", "func_location": "AtomEnvironment.isFirstLoad", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 476, "func_start_line": 475}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.endRowForFoldAtRow", "params": ["row", "tabLength", "existenceOnly"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 659, "start_line": 653}, "call_info": {"func_end_line": 382, "code": "  isFoldableAtRow (row) {\r\n    return this.endRowForFoldAtRow(row, 1, true) != null\r\n  }\r", "name": "endRowForFoldAtRow", "func_location": "TextMateLanguageMode.isFoldableAtRow", "args": ["row", {"type": "number"}, {"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 381, "func_start_line": 380}}, {"func_info": {"comment": [], "name": "TreeSitterLanguageMode.getFoldableRangeContainingPoint", "params": ["point", "tabLength", "existenceOnly"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 301, "start_line": 279}, "call_info": {"func_end_line": 224, "comment": ["\r\n  Section - Folding\r\n  "], "code": "  isFoldableAtRow (row) {\r\n    if (this.isFoldableCache[row] != null) return this.isFoldableCache[row]\r\n    const result = this.getFoldableRangeContainingPoint(Point(row, Infinity), 0, true) != null\r\n    this.isFoldableCache[row] = result\r\n    return result\r\n  }\r", "name": "getFoldableRangeContainingPoint", "func_location": "TreeSitterLanguageMode.isFoldableAtRow", "args": [null, {"type": "number"}, {"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 221, "func_start_line": 219}}, {"func_info": {"comment": [" Public: Returns the current buffer position as an Array."], "name": "Cursor.getBufferPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 93, "start_line": 91}, "call_info": {"func_end_line": 183, "comment": [" Public: Returns whether this cursor is between a word's start and end.", "", " * `options` (optional) {Object}", "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"", "     (default: {::wordRegExp}).", "", " Returns a {Boolean}"], "code": "  isInsideWord (options) {\r\n    const {row, column} = this.getBufferPosition()\r\n    const range = [[row, column], [row, Infinity]]\r\n    const text = this.editor.getTextInBufferRange(range)\r\n    return text.search((options && options.wordRegex) || this.wordRegExp()) === 0\r\n  }\r", "name": "getBufferPosition", "func_location": "Cursor.isInsideWord", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 179, "func_start_line": 178}}, {"func_info": {"comment": [" Public: Get the RegExp used by the cursor to determine what a \"word\" is.", "", " * `options` (optional) {Object} with the following keys:", "   * `includeNonWordCharacters` A {Boolean} indicating whether to include", "     non-word characters in the regex. (default: true)", "", " Returns a {RegExp}."], "name": "Cursor.wordRegExp", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 681, "start_line": 674}, "call_info": {"func_end_line": 183, "comment": [" Public: Returns whether this cursor is between a word's start and end.", "", " * `options` (optional) {Object}", "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"", "     (default: {::wordRegExp}).", "", " Returns a {Boolean}"], "code": "  isInsideWord (options) {\r\n    const {row, column} = this.getBufferPosition()\r\n    const range = [[row, column], [row, Infinity]]\r\n    const text = this.editor.getTextInBufferRange(range)\r\n    return text.search((options && options.wordRegex) || this.wordRegExp()) === 0\r\n  }\r", "name": "wordRegExp", "func_location": "Cursor.isInsideWord", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 182, "func_start_line": 178}}, {"func_info": {"comment": [], "name": "Pane.getContainer", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 128, "start_line": 128}, "call_info": {"func_end_line": 148, "comment": [" Private: Determine whether the given item is allowed to exist in this pane.", "", " * `item` the Item", "", " Returns a {Boolean}."], "code": "  isItemAllowed (item) {\r\n    if (typeof item.getAllowedLocations !== 'function') {\r\n      return true\r\n    } else {\r\n      return item.getAllowedLocations().includes(this.getContainer().getLocation())\r\n    }\r\n  }\r", "name": "getContainer", "func_location": "Pane.isItemAllowed", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 146, "func_start_line": 142}}, {"func_info": {"comment": [" Public: Get the active {Package} with the given name.", "", " * `name` - The {String} package name.", "", " Returns a {Package} or undefined."], "name": "PackageManager.getActivePackage", "params": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 302, "start_line": 300}, "call_info": {"func_end_line": 311, "comment": [" Public: Is the {Package} with the given name active?", "", " * `name` - The {String} package name.", "", " Returns a {Boolean}."], "code": "  isPackageActive (name) {\r\n    return (this.getActivePackage(name) != null)\r\n  }\r", "name": "getActivePackage", "func_location": "PackageManager.isPackageActive", "args": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 310, "func_start_line": 309}}, {"func_info": {"comment": [" Public: Get the loaded {Package} with the given name.", "", " * `name` - The {String} package name.", "", " Returns a {Package} or undefined."], "name": "PackageManager.getLoadedPackage", "params": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 341, "start_line": 339}, "call_info": {"func_end_line": 350, "comment": [" Public: Is the package with the given name loaded?", "", " * `name` - The {String} package name.", "", " Returns a {Boolean}."], "code": "  isPackageLoaded (name) {\r\n    return this.getLoadedPackage(name) != null\r\n  }\r", "name": "getLoadedPackage", "func_location": "PackageManager.isPackageLoaded", "args": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 349, "func_start_line": 348}}, {"func_info": {"comment": [" Returns the corresponding {Repository}"], "name": "GitRepository.getRepo", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 530, "start_line": 524}, "call_info": {"func_end_line": 350, "comment": [" Public: Is the given path ignored?", "", " * `path` The {String} path to check.", "", " Returns a {Boolean} that's true if the `path` is ignored."], "code": "  isPathIgnored (path) {\r\n    return this.getRepo().isIgnored(this.relativize(path))\r\n  }\r", "name": "getRepo", "func_location": "GitRepository.isPathIgnored", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 349, "func_start_line": 348}}, {"func_info": {"comment": [" Public: Makes a path relative to the repository's working directory."], "name": "GitRepository.relativize", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 210, "start_line": 208}, "call_info": {"func_end_line": 350, "comment": [" Public: Is the given path ignored?", "", " * `path` The {String} path to check.", "", " Returns a {Boolean} that's true if the `path` is ignored."], "code": "  isPathIgnored (path) {\r\n    return this.getRepo().isIgnored(this.relativize(path))\r\n  }\r", "name": "relativize", "func_location": "GitRepository.isPathIgnored", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 349, "func_start_line": 348}}, {"func_info": {"comment": [" Public: Returns true if the given status indicates modification.", "", " * `status` A {Number} representing the status.", "", " Returns a {Boolean} that's true if the `status` indicates modification."], "name": "GitRepository.isStatusModified", "params": ["status"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 406, "start_line": 406}, "call_info": {"func_end_line": 332, "comment": ["\r\n  Section: Reading Status\r\n  ", " Public: Returns true if the given path is modified.", "", " * `path` The {String} path to check.", "", " Returns a {Boolean} that's true if the `path` is modified."], "code": "  isPathModified (path) {\r\n    return this.isStatusModified(this.getPathStatus(path))\r\n  }\r", "name": "isStatusModified", "func_location": "GitRepository.isPathModified", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 331, "func_start_line": 330}}, {"func_info": {"comment": [" Public: Get the status of a single path in the repository.", "", " * `path` A {String} repository-relative path.", "", " Returns a {Number} representing the status. This value can be passed to", " {::isStatusModified} or {::isStatusNew} to get more information."], "name": "GitRepository.getPathStatus", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 390, "start_line": 374}, "call_info": {"func_end_line": 332, "comment": ["\r\n  Section: Reading Status\r\n  ", " Public: Returns true if the given path is modified.", "", " * `path` The {String} path to check.", "", " Returns a {Boolean} that's true if the `path` is modified."], "code": "  isPathModified (path) {\r\n    return this.isStatusModified(this.getPathStatus(path))\r\n  }\r", "name": "getPathStatus", "func_location": "GitRepository.isPathModified", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 331, "func_start_line": 330}}, {"func_info": {"comment": [], "name": "Project.findBufferForPath", "params": ["filePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 633, "start_line": 631}, "call_info": {"func_end_line": 629, "comment": [" Is the buffer for the given path modified?"], "code": "  isPathModified (filePath) {\r\n    const bufferForPath = this.findBufferForPath(this.resolvePath(filePath))\r\n    return bufferForPath && bufferForPath.isModified()\r\n  }\r", "name": "findBufferForPath", "func_location": "Project.isPathModified", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 627, "func_start_line": 626}}, {"func_info": {"comment": [], "name": "Project.resolvePath", "params": ["uri"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 530, "start_line": 514}, "call_info": {"func_end_line": 629, "comment": [" Is the buffer for the given path modified?"], "code": "  isPathModified (filePath) {\r\n    const bufferForPath = this.findBufferForPath(this.resolvePath(filePath))\r\n    return bufferForPath && bufferForPath.isModified()\r\n  }\r", "name": "resolvePath", "func_location": "Project.isPathModified", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 627, "func_start_line": 626}}, {"func_info": {"comment": [" Public: Returns true if the given status indicates a new path.", "", " * `status` A {Number} representing the status.", "", " Returns a {Boolean} that's true if the `status` indicates a new path."], "name": "GitRepository.isStatusNew", "params": ["status"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 415, "start_line": 413}, "call_info": {"func_end_line": 341, "comment": [" Public: Returns true if the given path is new.", "", " * `path` The {String} path to check.", "", " Returns a {Boolean} that's true if the `path` is new."], "code": "  isPathNew (path) {\r\n    return this.isStatusNew(this.getPathStatus(path))\r\n  }\r", "name": "isStatusNew", "func_location": "GitRepository.isPathNew", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 340, "func_start_line": 339}}, {"func_info": {"comment": [" Public: Get the status of a single path in the repository.", "", " * `path` A {String} repository-relative path.", "", " Returns a {Number} representing the status. This value can be passed to", " {::isStatusModified} or {::isStatusNew} to get more information."], "name": "GitRepository.getPathStatus", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 390, "start_line": 374}, "call_info": {"func_end_line": 341, "comment": [" Public: Returns true if the given path is new.", "", " * `path` The {String} path to check.", "", " Returns a {Boolean} that's true if the `path` is new."], "code": "  isPathNew (path) {\r\n    return this.isStatusNew(this.getPathStatus(path))\r\n  }\r", "name": "getPathStatus", "func_location": "GitRepository.isPathNew", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 340, "func_start_line": 339}}, {"func_info": {"comment": [" Public: Returns the {String} working directory path of the repository."], "name": "GitRepository.getWorkingDirectory", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 196, "start_line": 194}, "call_info": {"func_end_line": 205, "comment": [" Public: Returns true if at the root, false if in a subfolder of the", " repository."], "code": "  isProjectAtRoot () {\r\n    if (this.projectAtRoot == null) {\r\n      this.projectAtRoot = this.project && this.project.relativize(this.getWorkingDirectory()) === ''\r\n    }\r\n    return this.projectAtRoot\r\n  }\r", "name": "getWorkingDirectory", "func_location": "GitRepository.isProjectAtRoot", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 202, "func_start_line": 200}}, {"func_info": {"comment": [" Public: Gets the release channel of the Atom application.", "", " Returns the release channel as a {String}. Will return a specific release channel", " name like 'beta' or 'nightly' if one is found in the Atom version or 'stable'", " otherwise."], "name": "AtomEnvironment.getReleaseChannel", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 504, "start_line": 493}, "call_info": {"func_end_line": 509, "comment": [" Public: Returns a {Boolean} that is `true` if the current version is an official release."], "code": "  isReleasedVersion () {\r\n    return this.getReleaseChannel().match(/stable|beta|nightly/) != null\r\n  }\r", "name": "getReleaseChannel", "func_location": "AtomEnvironment.isReleasedVersion", "args": [{"type": "object"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 508, "func_start_line": 507}}, {"func_info": {"comment": ["\r\n  Section - Private\r\n  "], "name": "TreeSitterLanguageMode.firstNonWhitespaceRange", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 528, "start_line": 526}, "call_info": {"func_end_line": 175, "code": "  isRowCommented (row) {\r\n    const range = this.firstNonWhitespaceRange(row)\r\n    if (range) {\r\n      const firstNode = this.getSyntaxNodeContainingRange(range)\r\n      if (firstNode) return firstNode.type.includes('comment')\r\n    }\r\n    return false\r\n  }\r", "name": "firstNonWhitespaceRange", "func_location": "TreeSitterLanguageMode.isRowCommented", "args": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 169, "func_start_line": 168}}, {"func_info": {"comment": ["\r\n  Section - Syntax Tree APIs\r\n  "], "name": "TreeSitterLanguageMode.getSyntaxNodeContainingRange", "params": ["range", "where"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 385, "start_line": 383}, "call_info": {"func_end_line": 175, "code": "  isRowCommented (row) {\r\n    const range = this.firstNonWhitespaceRange(row)\r\n    if (range) {\r\n      const firstNode = this.getSyntaxNodeContainingRange(range)\r\n      if (firstNode) return firstNode.type.includes('comment')\r\n    }\r\n    return false\r\n  }\r", "name": "getSyntaxNodeContainingRange", "func_location": "TreeSitterLanguageMode.isRowCommented", "args": ["range"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 171, "func_start_line": 168}}, {"func_info": {"comment": ["\r\n  Section: Managing the selection range\r\n  ", " Public: Returns the screen {Range} for the selection."], "name": "Selection.getScreenRange", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 68, "start_line": 66}, "call_info": {"func_end_line": 154, "comment": [" Public: Returns whether the selection is a single line or not."], "code": "  isSingleScreenLine () {\r\n    return this.getScreenRange().isSingleLine()\r\n  }\r", "name": "getScreenRange", "func_location": "Selection.isSingleScreenLine", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 153, "func_start_line": 152}}, {"func_info": {"comment": [" Returns the corresponding {Repository}"], "name": "GitRepository.getRepo", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 530, "start_line": 524}, "call_info": {"func_end_line": 406, "comment": [" Public: Returns true if the given status indicates modification.", "", " * `status` A {Number} representing the status.", "", " Returns a {Boolean} that's true if the `status` indicates modification."], "code": "  isStatusModified (status) { return this.getRepo().isStatusModified(status) }\r", "name": "getRepo", "func_location": "GitRepository.isStatusModified", "args": ["status"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 406, "func_start_line": 406}}, {"func_info": {"comment": [" Returns the corresponding {Repository}"], "name": "GitRepository.getRepo", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 530, "start_line": 524}, "call_info": {"func_end_line": 415, "comment": [" Public: Returns true if the given status indicates a new path.", "", " * `status` A {Number} representing the status.", "", " Returns a {Boolean} that's true if the `status` indicates a new path."], "code": "  isStatusNew (status) {\r\n    return this.getRepo().isStatusNew(status)\r\n  }\r", "name": "getRepo", "func_location": "GitRepository.isStatusNew", "args": ["status"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 414, "func_start_line": 413}}, {"func_info": {"comment": [" Returns the corresponding {Repository}"], "name": "GitRepository.getRepo", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 530, "start_line": 524}, "call_info": {"func_end_line": 246, "comment": [" Public: Is the given path a submodule in the repository?", "", " * `path` The {String} path to check.", "", " Returns a {Boolean}."], "code": "  isSubmodule (filePath) {\r\n    if (!filePath) return false\r\n\r\n    const repo = this.getRepo(filePath)\r\n    if (repo.isSubmodule(repo.relativize(filePath))) {\r\n      return true\r\n    } else {\r\n      // Check if the filePath is a working directory in a repo that isn't the root.\r\n      return repo !== this.getRepo() && repo.relativize(path.join(filePath, 'dir')) === 'dir'\r\n    }\r\n  }\r", "name": "getRepo", "func_location": "GitRepository.isSubmodule", "args": ["filePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 239, "func_start_line": 236}}, {"func_info": {"comment": [" Returns the corresponding {Repository}"], "name": "GitRepository.getRepo", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 530, "start_line": 524}, "call_info": {"func_end_line": 246, "comment": [" Public: Is the given path a submodule in the repository?", "", " * `path` The {String} path to check.", "", " Returns a {Boolean}."], "code": "  isSubmodule (filePath) {\r\n    if (!filePath) return false\r\n\r\n    const repo = this.getRepo(filePath)\r\n    if (repo.isSubmodule(repo.relativize(filePath))) {\r\n      return true\r\n    } else {\r\n      // Check if the filePath is a working directory in a repo that isn't the root.\r\n      return repo !== this.getRepo() && repo.relativize(path.join(filePath, 'dir')) === 'dir'\r\n    }\r\n  }\r", "name": "getRepo", "func_location": "GitRepository.isSubmodule", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 244, "func_start_line": 236}}, {"func_info": {"comment": [" Public: Returns the current buffer position as an Array."], "name": "Cursor.getBufferPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 93, "start_line": 91}, "call_info": {"func_end_line": 149, "comment": [" Public: Identifies if the cursor is surrounded by whitespace.", "", " \"Surrounded\" here means that the character directly before and after the", " cursor are both whitespace.", "", " Returns a {Boolean}."], "code": "  isSurroundedByWhitespace () {\r\n    const {row, column} = this.getBufferPosition()\r\n    const range = [[row, column - 1], [row, column + 1]]\r\n    return /^\\s+$/.test(this.editor.getTextInBufferRange(range))\r\n  }\r", "name": "getBufferPosition", "func_location": "Cursor.isSurroundedByWhitespace", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 146, "func_start_line": 145}}, {"func_info": {"comment": [" Private: Check if the `decorationProperties.type` matches `type`", "", " * `decorationProperties` {Object} eg. `{type: 'line-number', class: 'my-new-class'}`", " * `type` {String} type like `'line-number'`, `'line'`, etc. `type` can also", "   be an {Array} of {String}s, where it will return true if the decoration's", "   type matches any in the array.", "", " Returns {Boolean}", " Note: 'line-number' is a special subtype of the 'gutter' type. I.e., a", " 'line-number' is a 'gutter', but a 'gutter' is not a 'line-number'."], "name": "Decoration.isType", "params": ["decorationProperties", "type"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration.js", "end_line": 68, "start_line": 49}, "call_info": {"func_end_line": 144, "comment": [" Public: Check if this decoration is of type `type`", "", " * `type` {String} type like `'line-number'`, `'line'`, etc. `type` can also", "   be an {Array} of {String}s, where it will return true if the decoration's", "   type matches any in the array.", "", " Returns {Boolean}"], "code": "  isType (type) {\r\n    return Decoration.isType(this.properties, type)\r\n  }\r", "name": "isType", "func_location": "Decoration.isType", "args": [".properties", "type"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration.js", "line": 143, "func_start_line": 142}}, {"func_info": {"comment": [" Kill all child processes of the spawned cmd.exe process on Windows.", "", " This is required since killing the cmd.exe does not terminate child", " processes."], "name": "BufferedProcess.killOnWindows", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "end_line": 205, "start_line": 163}, "call_info": {"func_end_line": 242, "comment": [" Public: Terminate the process."], "code": "  kill () {\r\n    if (this.killed) return\r\n\r\n    this.killed = true\r\n    if (process.platform === 'win32') {\r\n      this.killOnWindows()\r\n    } else {\r\n      this.killProcess()\r\n    }\r\n  }\r", "name": "killOnWindows", "func_location": "BufferedProcess.kill", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "line": 238, "func_start_line": 233}}, {"func_info": {"comment": [], "name": "BufferedProcess.killProcess", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "end_line": 210, "start_line": 207}, "call_info": {"func_end_line": 242, "comment": [" Public: Terminate the process."], "code": "  kill () {\r\n    if (this.killed) return\r\n\r\n    this.killed = true\r\n    if (process.platform === 'win32') {\r\n      this.killOnWindows()\r\n    } else {\r\n      this.killProcess()\r\n    }\r\n  }\r", "name": "killProcess", "func_location": "BufferedProcess.kill", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "line": 240, "func_start_line": 233}}, {"func_info": {"comment": [], "name": "AtomApplication.killProcessesForWindow", "params": ["window"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 941, "start_line": 934}, "call_info": {"func_end_line": 932, "comment": [" Kill all processes associated with opened windows."], "code": "  killAllProcesses () {\r\n    for (let window of this.waitSessionsByWindow.keys()) {\r\n      this.killProcessesForWindow(window)\r\n    }\r\n  }\r", "name": "killProcessesForWindow", "func_location": "AtomApplication.killAllProcesses", "args": ["window"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 930, "func_start_line": 928}}, {"func_info": {"comment": [], "name": "BufferedProcess.killProcess", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "end_line": 210, "start_line": 207}, "call_info": {"func_end_line": 205, "comment": [" Kill all child processes of the spawned cmd.exe process on Windows.", "", " This is required since killing the cmd.exe does not terminate child", " processes."], "code": "  killOnWindows () {\r\n    if (!this.process) return\r\n\r\n    const parentPid = this.process.pid\r\n    const cmd = 'wmic'\r\n    const args = [\r\n      'process',\r\n      'where',\r\n      `(ParentProcessId=${parentPid})`,\r\n      'get',\r\n      'processid'\r\n    ]\r\n\r\n    let wmicProcess\r\n\r\n    try {\r\n      wmicProcess = ChildProcess.spawn(cmd, args)\r\n    } catch (spawnError) {\r\n      this.killProcess()\r\n      return\r\n    }\r\n\r\n    wmicProcess.on('error', () => {}) // ignore errors\r\n\r\n    let output = ''\r\n    wmicProcess.stdout.on('data', (data) => {\r\n      output += data\r\n    })\r\n    wmicProcess.stdout.on('close', () => {\r\n      for (let pid of output.split(/\\s+/)) {\r\n        if (!/^\\d{1,10}$/.test(pid)) continue\r\n        pid = parseInt(pid, 10)\r\n\r\n        if (!pid || pid === parentPid) continue\r\n\r\n        try {\r\n          process.kill(pid)\r\n        } catch (error) {}\r\n      }\r\n\r\n      this.killProcess()\r\n    })\r\n  }\r", "name": "killProcess", "func_location": "BufferedProcess.killOnWindows", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "line": 181, "func_start_line": 163}}, {"func_info": {"comment": [" Kill the process with the given pid."], "name": "AtomApplication.killProcess", "params": ["pid"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 966, "start_line": 957}, "call_info": {"func_end_line": 941, "code": "  killProcessesForWindow (window) {\r\n    const sessions = this.waitSessionsByWindow.get(window)\r\n    if (!sessions) return\r\n    for (const session of sessions) {\r\n      this.killProcess(session.pid)\r\n    }\r\n    this.waitSessionsByWindow.delete(window)\r\n  }\r", "name": "killProcess", "func_location": "AtomApplication.killProcessesForWindow", "args": ["session.pid"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 938, "func_start_line": 934}}, {"func_info": {"comment": [], "name": "AtomApplication.loadPreviousWindowOptions", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 996, "start_line": 983}, "call_info": {"func_end_line": 205, "code": "  async launch (options) {\r\n    if (!this.configFilePromise) {\r\n      this.configFilePromise = this.configFile.watch()\r\n      this.disposable.add(await this.configFilePromise)\r\n      this.config.onDidChange('core.titleBar', () => this.promptForRestart())\r\n      this.config.onDidChange('core.colorProfile', () => this.promptForRestart())\r\n    }\r\n\r\n    const optionsForWindowsToOpen = []\r\n\r\n    let shouldReopenPreviousWindows = false\r\n\r\n    if (options.test || options.benchmark || options.benchmarkTest) {\r\n      optionsForWindowsToOpen.push(options)\r\n    } else if ((options.pathsToOpen && options.pathsToOpen.length > 0) ||\r\n               (options.urlsToOpen && options.urlsToOpen.length > 0)) {\r\n      optionsForWindowsToOpen.push(options)\r\n      shouldReopenPreviousWindows = this.config.get('core.restorePreviousWindowsOnStart') === 'always'\r\n    } else {\r\n      shouldReopenPreviousWindows = this.config.get('core.restorePreviousWindowsOnStart') !== 'no'\r\n    }\r\n\r\n    if (shouldReopenPreviousWindows) {\r\n      for (const previousOptions of await this.loadPreviousWindowOptions()) {\r\n        optionsForWindowsToOpen.push(Object.assign({}, options, previousOptions))\r\n      }\r\n    }\r\n\r\n    if (optionsForWindowsToOpen.length === 0) {\r\n      optionsForWindowsToOpen.push(options)\r\n    }\r\n\r\n    return optionsForWindowsToOpen.map(options => this.openWithOptions(options))\r\n  }\r", "name": "loadPreviousWindowOptions", "func_location": "AtomApplication.launch", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 195, "func_start_line": 172}}, {"func_info": {"comment": [], "name": "TextEditor.screenLineForScreenRow", "params": ["screenRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 1274, "start_line": 1272}, "call_info": {"func_end_line": 1242, "comment": [" Essential: Returns a {String} representing the contents of the line at the", " given screen row.", "", " * `screenRow` A {Number} representing a zero-indexed screen row."], "code": "  lineTextForScreenRow (screenRow) {\r\n    const screenLine = this.screenLineForScreenRow(screenRow)\r\n    if (screenLine) return screenLine.lineText\r\n  }\r", "name": "screenLineForScreenRow", "func_location": "TextEditor.lineTextForScreenRow", "args": ["screenRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 1240, "func_start_line": 1239}}, {"func_info": {"comment": [], "name": "AtomApplication.deleteSocketFile", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 361, "start_line": 348}, "call_info": {"func_end_line": 346, "comment": [" Creates server to listen for additional atom application launches.", "", " You can run the atom command multiple times, but after the first launch", " the other launches will just pass their information to this server and then", " close immediately."], "code": "  listenForArgumentsFromNewProcess () {\r\n    if (!this.socketPath) return\r\n\r\n    this.deleteSocketFile()\r\n    const server = net.createServer(connection => {\r\n      let data = ''\r\n      connection.on('data', chunk => { data += chunk })\r\n      connection.on('end', () => this.openWithOptions(JSON.parse(data)))\r\n    })\r\n\r\n    server.listen(this.socketPath)\r\n    server.on('error', error => console.error('Application server failed', error))\r\n  }\r", "name": "deleteSocketFile", "func_location": "AtomApplication.listenForArgumentsFromNewProcess", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 337, "func_start_line": 334}}, {"func_info": {"comment": [], "name": "Package.measure", "params": ["key", "fn"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 85, "start_line": 80}, "call_info": {"func_end_line": 144, "name": "measure", "func_location": "Package.load", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 123, "func_start_line": 122}}, {"func_info": {"comment": [], "name": "FileSystemBlobStore.reset", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/file-system-blob-store.js", "end_line": 26, "start_line": 21}, "call_info": {"func_end_line": 42, "code": "  load () {\r\n    if (!fs.existsSync(this.blobMapFilename)) {\r\n      return\r\n    }\r\n    if (!fs.existsSync(this.blobFilename)) {\r\n      return\r\n    }\r\n\r\n    try {\r\n      this.storedBlob = fs.readFileSync(this.blobFilename)\r\n      this.storedBlobMap = JSON.parse(fs.readFileSync(this.blobMapFilename))\r\n    } catch (e) {\r\n      this.reset()\r\n    }\r\n  }\r", "name": "reset", "func_location": "FileSystemBlobStore.load", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/file-system-blob-store.js", "line": 40, "func_start_line": 28}}, {"func_info": {"comment": [" Public: Get the loaded {Package} with the given name.", "", " * `name` - The {String} package name.", "", " Returns a {Package} or undefined."], "name": "PackageManager.getLoadedPackage", "params": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 341, "start_line": 339}, "call_info": {"func_end_line": 635, "code": "  loadAvailablePackage (availablePackage, disabledPackageNames) {\r\n    const preloadedPackage = this.preloadedPackages[availablePackage.name]\r\n\r\n    if (disabledPackageNames != null && disabledPackageNames.has(availablePackage.name)) {\r\n      if (preloadedPackage != null) {\r\n        preloadedPackage.deactivate()\r\n        delete preloadedPackage[availablePackage.name]\r\n      }\r\n      return null\r\n    }\r\n\r\n    const loadedPackage = this.getLoadedPackage(availablePackage.name)\r\n    if (loadedPackage != null) {\r\n      return loadedPackage\r\n    }\r\n\r\n    if (preloadedPackage != null) {\r\n      if (availablePackage.isBundled) {\r\n        preloadedPackage.finishLoading()\r\n        this.loadedPackages[availablePackage.name] = preloadedPackage\r\n        return preloadedPackage\r\n      } else {\r\n        preloadedPackage.deactivate()\r\n        delete preloadedPackage[availablePackage.name]\r\n      }\r\n    }\r\n\r\n    let metadata\r\n    try {\r\n      metadata = this.loadPackageMetadata(availablePackage) || {}\r\n    } catch (error) {\r\n      this.handleMetadataError(error, availablePackage.path)\r\n      return null\r\n    }\r\n\r\n    if (!availablePackage.isBundled && this.isDeprecatedPackage(metadata.name, metadata.version)) {\r\n      console.warn(`Could not load ${metadata.name}@${metadata.version} because it uses deprecated APIs that have been removed.`)\r\n      return null\r\n    }\r\n\r\n    const options = {\r\n      path: availablePackage.path,\r\n      name: availablePackage.name,\r\n      metadata,\r\n      bundledPackage: availablePackage.isBundled,\r\n      packageManager: this,\r\n      config: this.config,\r\n      styleManager: this.styleManager,\r\n      commandRegistry: this.commandRegistry,\r\n      keymapManager: this.keymapManager,\r\n      notificationManager: this.notificationManager,\r\n      grammarRegistry: this.grammarRegistry,\r\n      themeManager: this.themeManager,\r\n      menuManager: this.menuManager,\r\n      contextMenuManager: this.contextMenuManager,\r\n      deserializerManager: this.deserializerManager,\r\n      viewRegistry: this.viewRegistry\r\n    }\r\n\r\n    const pack = metadata.theme ? new ThemePackage(options) : new Package(options)\r\n    pack.load()\r\n    this.loadedPackages[pack.name] = pack\r\n    this.emitter.emit('did-load-package', pack)\r\n    return pack\r\n  }\r", "name": "getLoadedPackage", "func_location": "PackageManager.loadAvailablePackage", "args": ["availablePackage.name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 582, "func_start_line": 571}}, {"func_info": {"comment": [], "name": "PackageManager.loadPackageMetadata", "params": ["packagePathOrAvailablePackage", "ignoreErrors"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 882, "start_line": 839}, "call_info": {"func_end_line": 635, "code": "  loadAvailablePackage (availablePackage, disabledPackageNames) {\r\n    const preloadedPackage = this.preloadedPackages[availablePackage.name]\r\n\r\n    if (disabledPackageNames != null && disabledPackageNames.has(availablePackage.name)) {\r\n      if (preloadedPackage != null) {\r\n        preloadedPackage.deactivate()\r\n        delete preloadedPackage[availablePackage.name]\r\n      }\r\n      return null\r\n    }\r\n\r\n    const loadedPackage = this.getLoadedPackage(availablePackage.name)\r\n    if (loadedPackage != null) {\r\n      return loadedPackage\r\n    }\r\n\r\n    if (preloadedPackage != null) {\r\n      if (availablePackage.isBundled) {\r\n        preloadedPackage.finishLoading()\r\n        this.loadedPackages[availablePackage.name] = preloadedPackage\r\n        return preloadedPackage\r\n      } else {\r\n        preloadedPackage.deactivate()\r\n        delete preloadedPackage[availablePackage.name]\r\n      }\r\n    }\r\n\r\n    let metadata\r\n    try {\r\n      metadata = this.loadPackageMetadata(availablePackage) || {}\r\n    } catch (error) {\r\n      this.handleMetadataError(error, availablePackage.path)\r\n      return null\r\n    }\r\n\r\n    if (!availablePackage.isBundled && this.isDeprecatedPackage(metadata.name, metadata.version)) {\r\n      console.warn(`Could not load ${metadata.name}@${metadata.version} because it uses deprecated APIs that have been removed.`)\r\n      return null\r\n    }\r\n\r\n    const options = {\r\n      path: availablePackage.path,\r\n      name: availablePackage.name,\r\n      metadata,\r\n      bundledPackage: availablePackage.isBundled,\r\n      packageManager: this,\r\n      config: this.config,\r\n      styleManager: this.styleManager,\r\n      commandRegistry: this.commandRegistry,\r\n      keymapManager: this.keymapManager,\r\n      notificationManager: this.notificationManager,\r\n      grammarRegistry: this.grammarRegistry,\r\n      themeManager: this.themeManager,\r\n      menuManager: this.menuManager,\r\n      contextMenuManager: this.contextMenuManager,\r\n      deserializerManager: this.deserializerManager,\r\n      viewRegistry: this.viewRegistry\r\n    }\r\n\r\n    const pack = metadata.theme ? new ThemePackage(options) : new Package(options)\r\n    pack.load()\r\n    this.loadedPackages[pack.name] = pack\r\n    this.emitter.emit('did-load-package', pack)\r\n    return pack\r\n  }\r", "name": "loadPackageMetadata", "func_location": "PackageManager.loadAvailablePackage", "args": ["availablePackage"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 600, "func_start_line": 571}}, {"func_info": {"comment": [], "name": "PackageManager.handleMetadataError", "params": ["error", "packagePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 805, "start_line": 799}, "call_info": {"func_end_line": 635, "code": "  loadAvailablePackage (availablePackage, disabledPackageNames) {\r\n    const preloadedPackage = this.preloadedPackages[availablePackage.name]\r\n\r\n    if (disabledPackageNames != null && disabledPackageNames.has(availablePackage.name)) {\r\n      if (preloadedPackage != null) {\r\n        preloadedPackage.deactivate()\r\n        delete preloadedPackage[availablePackage.name]\r\n      }\r\n      return null\r\n    }\r\n\r\n    const loadedPackage = this.getLoadedPackage(availablePackage.name)\r\n    if (loadedPackage != null) {\r\n      return loadedPackage\r\n    }\r\n\r\n    if (preloadedPackage != null) {\r\n      if (availablePackage.isBundled) {\r\n        preloadedPackage.finishLoading()\r\n        this.loadedPackages[availablePackage.name] = preloadedPackage\r\n        return preloadedPackage\r\n      } else {\r\n        preloadedPackage.deactivate()\r\n        delete preloadedPackage[availablePackage.name]\r\n      }\r\n    }\r\n\r\n    let metadata\r\n    try {\r\n      metadata = this.loadPackageMetadata(availablePackage) || {}\r\n    } catch (error) {\r\n      this.handleMetadataError(error, availablePackage.path)\r\n      return null\r\n    }\r\n\r\n    if (!availablePackage.isBundled && this.isDeprecatedPackage(metadata.name, metadata.version)) {\r\n      console.warn(`Could not load ${metadata.name}@${metadata.version} because it uses deprecated APIs that have been removed.`)\r\n      return null\r\n    }\r\n\r\n    const options = {\r\n      path: availablePackage.path,\r\n      name: availablePackage.name,\r\n      metadata,\r\n      bundledPackage: availablePackage.isBundled,\r\n      packageManager: this,\r\n      config: this.config,\r\n      styleManager: this.styleManager,\r\n      commandRegistry: this.commandRegistry,\r\n      keymapManager: this.keymapManager,\r\n      notificationManager: this.notificationManager,\r\n      grammarRegistry: this.grammarRegistry,\r\n      themeManager: this.themeManager,\r\n      menuManager: this.menuManager,\r\n      contextMenuManager: this.contextMenuManager,\r\n      deserializerManager: this.deserializerManager,\r\n      viewRegistry: this.viewRegistry\r\n    }\r\n\r\n    const pack = metadata.theme ? new ThemePackage(options) : new Package(options)\r\n    pack.load()\r\n    this.loadedPackages[pack.name] = pack\r\n    this.emitter.emit('did-load-package', pack)\r\n    return pack\r\n  }\r", "name": "handleMetadataError", "func_location": "PackageManager.loadAvailablePackage", "args": ["error", "availablePackage.path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 602, "func_start_line": 571}}, {"func_info": {"comment": [], "name": "PackageManager.isDeprecatedPackage", "params": ["name", "version"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 239, "start_line": 224}, "call_info": {"func_end_line": 635, "code": "  loadAvailablePackage (availablePackage, disabledPackageNames) {\r\n    const preloadedPackage = this.preloadedPackages[availablePackage.name]\r\n\r\n    if (disabledPackageNames != null && disabledPackageNames.has(availablePackage.name)) {\r\n      if (preloadedPackage != null) {\r\n        preloadedPackage.deactivate()\r\n        delete preloadedPackage[availablePackage.name]\r\n      }\r\n      return null\r\n    }\r\n\r\n    const loadedPackage = this.getLoadedPackage(availablePackage.name)\r\n    if (loadedPackage != null) {\r\n      return loadedPackage\r\n    }\r\n\r\n    if (preloadedPackage != null) {\r\n      if (availablePackage.isBundled) {\r\n        preloadedPackage.finishLoading()\r\n        this.loadedPackages[availablePackage.name] = preloadedPackage\r\n        return preloadedPackage\r\n      } else {\r\n        preloadedPackage.deactivate()\r\n        delete preloadedPackage[availablePackage.name]\r\n      }\r\n    }\r\n\r\n    let metadata\r\n    try {\r\n      metadata = this.loadPackageMetadata(availablePackage) || {}\r\n    } catch (error) {\r\n      this.handleMetadataError(error, availablePackage.path)\r\n      return null\r\n    }\r\n\r\n    if (!availablePackage.isBundled && this.isDeprecatedPackage(metadata.name, metadata.version)) {\r\n      console.warn(`Could not load ${metadata.name}@${metadata.version} because it uses deprecated APIs that have been removed.`)\r\n      return null\r\n    }\r\n\r\n    const options = {\r\n      path: availablePackage.path,\r\n      name: availablePackage.name,\r\n      metadata,\r\n      bundledPackage: availablePackage.isBundled,\r\n      packageManager: this,\r\n      config: this.config,\r\n      styleManager: this.styleManager,\r\n      commandRegistry: this.commandRegistry,\r\n      keymapManager: this.keymapManager,\r\n      notificationManager: this.notificationManager,\r\n      grammarRegistry: this.grammarRegistry,\r\n      themeManager: this.themeManager,\r\n      menuManager: this.menuManager,\r\n      contextMenuManager: this.contextMenuManager,\r\n      deserializerManager: this.deserializerManager,\r\n      viewRegistry: this.viewRegistry\r\n    }\r\n\r\n    const pack = metadata.theme ? new ThemePackage(options) : new Package(options)\r\n    pack.load()\r\n    this.loadedPackages[pack.name] = pack\r\n    this.emitter.emit('did-load-package', pack)\r\n    return pack\r\n  }\r", "name": "isDeprecatedPackage", "func_location": "PackageManager.loadAvailablePackage", "args": ["metadata.name", "metadata.version"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 606, "func_start_line": 571}}, {"func_info": {"comment": [], "name": "ThemeManager.reloadBaseStylesheets", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 226, "start_line": 224}, "call_info": {"func_end_line": 222, "code": "  loadBaseStylesheets () {\r\n    this.reloadBaseStylesheets()\r\n  }\r", "name": "reloadBaseStylesheets", "func_location": "ThemeManager.loadBaseStylesheets", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 221, "func_start_line": 220}}, {"func_info": {"comment": [], "name": "loadDependencies", "params": ["modulePath", "rootPath", "rootMetadata", "moduleCache"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js", "end_line": 84, "start_line": 52}, "call_info": {"func_end_line": 84, "code": "function loadDependencies (modulePath, rootPath, rootMetadata, moduleCache) {\r\n  const fs = require('fs-plus')\r\n\r\n  for (let childPath of fs.listSync(path.join(modulePath, 'node_modules'))) {\r\n    if (path.basename(childPath) === '.bin') continue\r\n    if (rootPath === modulePath && (rootMetadata.packageDependencies && rootMetadata.packageDependencies.hasOwnProperty(path.basename(childPath)))) {\r\n      continue\r\n    }\r\n\r\n    const childMetadataPath = path.join(childPath, 'package.json')\r\n    if (!fs.isFileSync(childMetadataPath)) continue\r\n\r\n    const childMetadata = JSON.parse(fs.readFileSync(childMetadataPath))\r\n    if (childMetadata && childMetadata.version) {\r\n      var mainPath\r\n      try {\r\n        mainPath = require.resolve(childPath)\r\n      } catch (error) {\r\n        mainPath = null\r\n      }\r\n\r\n      if (mainPath) {\r\n        moduleCache.dependencies.push({\r\n          name: childMetadata.name,\r\n          version: childMetadata.version,\r\n          path: path.relative(rootPath, mainPath)\r\n        })\r\n      }\r\n\r\n      loadDependencies(childPath, rootPath, rootMetadata, moduleCache)\r\n    }\r\n  }\r\n}\r", "name": "loadDependencies", "func_location": "loadDependencies", "args": ["childPath", "rootPath", "rootMetadata", "moduleCache"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js", "line": 81, "func_start_line": 52}}, {"func_info": {"comment": [], "name": "loadFolderCompatibility", "params": ["modulePath", "rootPath", "rootMetadata", "moduleCache"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js", "end_line": 126, "start_line": 86}, "call_info": {"func_end_line": 126, "code": "function loadFolderCompatibility (modulePath, rootPath, rootMetadata, moduleCache) {\r\n  const fs = require('fs-plus')\r\n\r\n  const metadataPath = path.join(modulePath, 'package.json')\r\n  if (!fs.isFileSync(metadataPath)) return\r\n\r\n  const metadata = JSON.parse(fs.readFileSync(metadataPath))\r\n  const dependencies = metadata.dependencies || {}\r\n\r\n  for (let name in dependencies) {\r\n    if (!semver.validRange(dependencies[name])) {\r\n      delete dependencies[name]\r\n    }\r\n  }\r\n\r\n  const onDirectory = childPath => path.basename(childPath) !== 'node_modules'\r\n\r\n  const extensions = ['.js', '.coffee', '.json', '.node']\r\n  let paths = {}\r\n  function onFile (childPath) {\r\n    const needle = path.extname(childPath)\r\n    if (extensions.includes(needle)) {\r\n      const relativePath = path.relative(rootPath, path.dirname(childPath))\r\n      paths[relativePath] = true\r\n    }\r\n  }\r\n  fs.traverseTreeSync(modulePath, onFile, onDirectory)\r\n\r\n  paths = Object.keys(paths)\r\n  if (paths.length > 0 && Object.keys(dependencies).length > 0) {\r\n    moduleCache.folders.push({paths, dependencies})\r\n  }\r\n\r\n  for (let childPath of fs.listSync(path.join(modulePath, 'node_modules'))) {\r\n    if (path.basename(childPath) === '.bin') continue\r\n    if (rootPath === modulePath && (rootMetadata.packageDependencies && rootMetadata.packageDependencies.hasOwnProperty(path.basename(childPath)))) {\r\n      continue\r\n    }\r\n    loadFolderCompatibility(childPath, rootPath, rootMetadata, moduleCache)\r\n  }\r\n}\r", "name": "loadFolderCompatibility", "func_location": "loadFolderCompatibility", "args": ["childPath", "rootPath", "rootMetadata", "moduleCache"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js", "line": 124, "func_start_line": 86}}, {"func_info": {"comment": [" Extended: Read a grammar asynchronously but don't add it to the registry.", "", " * `grammarPath` A {String} absolute file path to a grammar file.", " * `callback` A {Function} to call when read with the following arguments:", "   * `error` An {Error}, may be null.", "   * `grammar` A {Grammar} or null if an error occured.", "", " Returns undefined."], "name": "GrammarRegistry.readGrammar", "params": ["grammarPath", "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 527, "start_line": 517}, "call_info": {"func_end_line": 496, "name": "readGrammar", "func_location": "GrammarRegistry.loadGrammar", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 491, "func_start_line": 490}}, {"func_info": {"comment": [" Extended: Read a grammar synchronously but don't add it to the registry.", "", " * `grammarPath` A {String} absolute file path to a grammar file.", "", " Returns a {Grammar}."], "name": "GrammarRegistry.readGrammarSync", "params": ["grammarPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 536, "start_line": 534}, "call_info": {"func_end_line": 507, "comment": [" Extended: Read a grammar synchronously and add it to this registry.", "", " * `grammarPath` A {String} absolute file path to a grammar file.", "", " Returns a {Grammar}."], "code": "  loadGrammarSync (grammarPath) {\r\n    const grammar = this.readGrammarSync(grammarPath)\r\n    this.addGrammar(grammar)\r\n    return grammar\r\n  }\r", "name": "readGrammarSync", "func_location": "GrammarRegistry.loadGrammarSync", "args": ["grammarPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 504, "func_start_line": 503}}, {"func_info": {"comment": [], "name": "GrammarRegistry.addGrammar", "params": ["grammar"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 470, "start_line": 456}, "call_info": {"func_end_line": 507, "comment": [" Extended: Read a grammar synchronously and add it to this registry.", "", " * `grammarPath` A {String} absolute file path to a grammar file.", "", " Returns a {Grammar}."], "code": "  loadGrammarSync (grammarPath) {\r\n    const grammar = this.readGrammarSync(grammarPath)\r\n    this.addGrammar(grammar)\r\n    return grammar\r\n  }\r", "name": "addGrammar", "func_location": "GrammarRegistry.loadGrammarSync", "args": ["grammar"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 505, "func_start_line": 503}}, {"func_info": {"comment": [], "name": "Package.getKeymapPaths", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 475, "start_line": 468}, "call_info": {"func_end_line": 451, "code": "  loadKeymaps () {\r\n    if (this.bundledPackage && this.packageManager.packagesCache[this.name]) {\r\n      this.keymaps = []\r\n      for (const keymapPath in this.packageManager.packagesCache[this.name].keymaps) {\r\n        const keymapObject = this.packageManager.packagesCache[this.name].keymaps[keymapPath]\r\n        this.keymaps.push([`core:${keymapPath}`, keymapObject])\r\n      }\r\n    } else {\r\n      this.keymaps = this.getKeymapPaths().map((keymapPath) => [\r\n        keymapPath,\r\n        CSON.readFileSync(keymapPath, {allowDuplicateKeys: false}) || {}\r\n      ])\r\n    }\r\n  }\r", "name": "getKeymapPaths", "func_location": "Package.loadKeymaps", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 446, "func_start_line": 438}}, {"func_info": {"comment": [], "name": "ThemeManager.getImportPaths", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 402, "start_line": 381}, "call_info": {"func_end_line": 298, "code": "  loadLessStylesheet (lessStylesheetPath, importFallbackVariables = false) {\r\n    if (this.lessCache == null) {\r\n      this.lessCache = new LessCompileCache({\r\n        resourcePath: this.resourcePath,\r\n        lessSourcesByRelativeFilePath: this.lessSourcesByRelativeFilePath,\r\n        importedFilePathsByRelativeImportPath: this.importedFilePathsByRelativeImportPath,\r\n        importPaths: this.getImportPaths()\r\n      })\r\n    }\r\n\r\n    try {\r\n      if (importFallbackVariables) {\r\n        const baseVarImports = `\\\r\n@import \"variables/ui-variables\";\r\n@import \"variables/syntax-variables\";\\\r\n`\r\n        const relativeFilePath = path.relative(this.resourcePath, lessStylesheetPath)\r\n        const lessSource = this.lessSourcesByRelativeFilePath[relativeFilePath]\r\n\r\n        let content, digest\r\n        if (lessSource != null) {\r\n          ({ content } = lessSource);\r\n          ({ digest } = lessSource)\r\n        } else {\r\n          content = baseVarImports + '\\n' + fs.readFileSync(lessStylesheetPath, 'utf8')\r\n          digest = null\r\n        }\r\n\r\n        return this.lessCache.cssForFile(lessStylesheetPath, content, digest)\r\n      } else {\r\n        return this.lessCache.read(lessStylesheetPath)\r\n      }\r\n    } catch (error) {\r\n      let detail, message\r\n      error.less = true\r\n      if (error.line != null) {\r\n        // Adjust line numbers for import fallbacks\r\n        if (importFallbackVariables) { error.line -= 2 }\r\n\r\n        message = `Error compiling Less stylesheet: \\`${lessStylesheetPath}\\``\r\n        detail = `Line number: ${error.line}\\n${error.message}`\r\n      } else {\r\n        message = `Error loading Less stylesheet: \\`${lessStylesheetPath}\\``\r\n        detail = error.message\r\n      }\r\n\r\n      this.notificationManager.addError(message, {detail, dismissable: true})\r\n      throw error\r\n    }\r\n  }\r", "name": "getImportPaths", "func_location": "ThemeManager.loadLessStylesheet", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 255, "func_start_line": 249}}, {"func_info": {"comment": [], "name": "Package.getMenuPaths", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 484, "start_line": 477}, "call_info": {"func_end_line": 466, "code": "  loadMenus () {\r\n    if (this.bundledPackage && this.packageManager.packagesCache[this.name]) {\r\n      this.menus = []\r\n      for (const menuPath in this.packageManager.packagesCache[this.name].menus) {\r\n        const menuObject = this.packageManager.packagesCache[this.name].menus[menuPath]\r\n        this.menus.push([`core:${menuPath}`, menuObject])\r\n      }\r\n    } else {\r\n      this.menus = this.getMenuPaths().map((menuPath) => [\r\n        menuPath,\r\n        CSON.readFileSync(menuPath) || {}\r\n      ])\r\n    }\r\n  }\r", "name": "getMenuPaths", "func_location": "Package.loadMenus", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 461, "func_start_line": 453}}, {"func_info": {"comment": [" Public: Get the loaded {Package} with the given name.", "", " * `name` - The {String} package name.", "", " Returns a {Package} or undefined."], "name": "PackageManager.getLoadedPackage", "params": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 341, "start_line": 339}, "call_info": {"func_end_line": 569, "code": "  loadPackage (nameOrPath) {\r\n    if (path.basename(nameOrPath)[0].match(/^\\./)) { // primarily to skip .git folder\r\n      return null\r\n    }\r\n\r\n    const pack = this.getLoadedPackage(nameOrPath)\r\n    if (pack) {\r\n      return pack\r\n    }\r\n\r\n    const packagePath = this.resolvePackagePath(nameOrPath)\r\n    if (packagePath) {\r\n      const name = path.basename(nameOrPath)\r\n      return this.loadAvailablePackage({name, path: packagePath, isBundled: this.isBundledPackagePath(packagePath)})\r\n    }\r\n\r\n    console.warn(`Could not resolve '${nameOrPath}' to a package path`)\r\n    return null\r\n  }\r", "name": "getLoadedPackage", "func_location": "PackageManager.loadPackage", "args": ["nameOrPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 556, "func_start_line": 551}}, {"func_info": {"comment": ["\r\n  Section: General package data\r\n  ", " Public: Resolve the given package name to a path on disk.", "", " * `name` - The {String} package name.", "", " Return a {String} folder path or undefined if it could not be resolved."], "name": "PackageManager.resolvePackagePath", "params": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 213, "start_line": 197}, "call_info": {"func_end_line": 569, "code": "  loadPackage (nameOrPath) {\r\n    if (path.basename(nameOrPath)[0].match(/^\\./)) { // primarily to skip .git folder\r\n      return null\r\n    }\r\n\r\n    const pack = this.getLoadedPackage(nameOrPath)\r\n    if (pack) {\r\n      return pack\r\n    }\r\n\r\n    const packagePath = this.resolvePackagePath(nameOrPath)\r\n    if (packagePath) {\r\n      const name = path.basename(nameOrPath)\r\n      return this.loadAvailablePackage({name, path: packagePath, isBundled: this.isBundledPackagePath(packagePath)})\r\n    }\r\n\r\n    console.warn(`Could not resolve '${nameOrPath}' to a package path`)\r\n    return null\r\n  }\r", "name": "resolvePackagePath", "func_location": "PackageManager.loadPackage", "args": ["nameOrPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 561, "func_start_line": 551}}, {"func_info": {"comment": [], "name": "PackageManager.loadAvailablePackage", "params": ["availablePackage", "disabledPackageNames"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 635, "start_line": 571}, "call_info": {"func_end_line": 569, "code": "  loadPackage (nameOrPath) {\r\n    if (path.basename(nameOrPath)[0].match(/^\\./)) { // primarily to skip .git folder\r\n      return null\r\n    }\r\n\r\n    const pack = this.getLoadedPackage(nameOrPath)\r\n    if (pack) {\r\n      return pack\r\n    }\r\n\r\n    const packagePath = this.resolvePackagePath(nameOrPath)\r\n    if (packagePath) {\r\n      const name = path.basename(nameOrPath)\r\n      return this.loadAvailablePackage({name, path: packagePath, isBundled: this.isBundledPackagePath(packagePath)})\r\n    }\r\n\r\n    console.warn(`Could not resolve '${nameOrPath}' to a package path`)\r\n    return null\r\n  }\r", "name": "loadAvailablePackage", "func_location": "PackageManager.loadPackage", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 564, "func_start_line": 551}}, {"func_info": {"comment": [], "name": "PackageManager.isBundledPackagePath", "params": ["packagePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 837, "start_line": 827}, "call_info": {"func_end_line": 569, "code": "  loadPackage (nameOrPath) {\r\n    if (path.basename(nameOrPath)[0].match(/^\\./)) { // primarily to skip .git folder\r\n      return null\r\n    }\r\n\r\n    const pack = this.getLoadedPackage(nameOrPath)\r\n    if (pack) {\r\n      return pack\r\n    }\r\n\r\n    const packagePath = this.resolvePackagePath(nameOrPath)\r\n    if (packagePath) {\r\n      const name = path.basename(nameOrPath)\r\n      return this.loadAvailablePackage({name, path: packagePath, isBundled: this.isBundledPackagePath(packagePath)})\r\n    }\r\n\r\n    console.warn(`Could not resolve '${nameOrPath}' to a package path`)\r\n    return null\r\n  }\r", "name": "isBundledPackagePath", "func_location": "PackageManager.loadPackage", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 564, "func_start_line": 551}}, {"func_info": {"comment": [], "name": "PackageManager.isBundledPackagePath", "params": ["packagePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 837, "start_line": 827}, "call_info": {"func_end_line": 882, "code": "  loadPackageMetadata (packagePathOrAvailablePackage, ignoreErrors = false) {\r\n    let isBundled, packageName, packagePath\r\n    if (typeof packagePathOrAvailablePackage === 'object') {\r\n      const availablePackage = packagePathOrAvailablePackage\r\n      packageName = availablePackage.name\r\n      packagePath = availablePackage.path\r\n      isBundled = availablePackage.isBundled\r\n    } else {\r\n      packagePath = packagePathOrAvailablePackage\r\n      packageName = path.basename(packagePath)\r\n      isBundled = this.isBundledPackagePath(packagePath)\r\n    }\r\n\r\n    let metadata\r\n    if (isBundled && this.packagesCache[packageName] != null) {\r\n      metadata = this.packagesCache[packageName].metadata\r\n    }\r\n\r\n    if (metadata == null) {\r\n      const metadataPath = CSON.resolve(path.join(packagePath, 'package'))\r\n      if (metadataPath) {\r\n        try {\r\n          metadata = CSON.readFileSync(metadataPath)\r\n          this.normalizePackageMetadata(metadata)\r\n        } catch (error) {\r\n          if (!ignoreErrors) { throw error }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (metadata == null) {\r\n      metadata = {}\r\n    }\r\n\r\n    if (typeof metadata.name !== 'string' || metadata.name.length <= 0) {\r\n      metadata.name = packageName\r\n    }\r\n\r\n    if (metadata.repository && metadata.repository.type === 'git' && typeof metadata.repository.url === 'string') {\r\n      metadata.repository.url = metadata.repository.url.replace(/(^git\\+)|(\\.git$)/g, '')\r\n    }\r\n\r\n    return metadata\r\n  }\r", "name": "isBundledPackagePath", "func_location": "PackageManager.loadPackageMetadata", "args": ["packagePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 849, "func_start_line": 839}}, {"func_info": {"comment": [], "name": "PackageManager.normalizePackageMetadata", "params": ["metadata"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 889, "start_line": 884}, "call_info": {"func_end_line": 882, "code": "  loadPackageMetadata (packagePathOrAvailablePackage, ignoreErrors = false) {\r\n    let isBundled, packageName, packagePath\r\n    if (typeof packagePathOrAvailablePackage === 'object') {\r\n      const availablePackage = packagePathOrAvailablePackage\r\n      packageName = availablePackage.name\r\n      packagePath = availablePackage.path\r\n      isBundled = availablePackage.isBundled\r\n    } else {\r\n      packagePath = packagePathOrAvailablePackage\r\n      packageName = path.basename(packagePath)\r\n      isBundled = this.isBundledPackagePath(packagePath)\r\n    }\r\n\r\n    let metadata\r\n    if (isBundled && this.packagesCache[packageName] != null) {\r\n      metadata = this.packagesCache[packageName].metadata\r\n    }\r\n\r\n    if (metadata == null) {\r\n      const metadataPath = CSON.resolve(path.join(packagePath, 'package'))\r\n      if (metadataPath) {\r\n        try {\r\n          metadata = CSON.readFileSync(metadataPath)\r\n          this.normalizePackageMetadata(metadata)\r\n        } catch (error) {\r\n          if (!ignoreErrors) { throw error }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (metadata == null) {\r\n      metadata = {}\r\n    }\r\n\r\n    if (typeof metadata.name !== 'string' || metadata.name.length <= 0) {\r\n      metadata.name = packageName\r\n    }\r\n\r\n    if (metadata.repository && metadata.repository.type === 'git' && typeof metadata.repository.url === 'string') {\r\n      metadata.repository.url = metadata.repository.url.replace(/(^git\\+)|(\\.git$)/g, '')\r\n    }\r\n\r\n    return metadata\r\n  }\r", "name": "normalizePackageMetadata", "func_location": "PackageManager.loadPackageMetadata", "args": ["metadata"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 862, "func_start_line": 839}}, {"func_info": {"comment": [], "name": "HistoryManager.didChangeProjects", "params": ["args"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "end_line": 53, "start_line": 51}, "call_info": {"func_end_line": 101, "code": "  async loadState () {\r\n    const history = await this.stateStore.load('history-manager')\r\n    if (history && history.projects) {\r\n      this.projects = history.projects.filter(p => Array.isArray(p.paths) && p.paths.length > 0).map(p => new HistoryProject(p.paths, new Date(p.lastOpened)))\r\n      this.didChangeProjects({reloaded: true})\r\n    } else {\r\n      this.projects = []\r\n    }\r\n  }\r", "name": "didChangeProjects", "func_location": "HistoryManager.loadState", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "line": 97, "func_start_line": 93}}, {"func_info": {"comment": [], "name": "AtomEnvironment.getStateKey", "params": ["paths"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1286, "start_line": 1279}, "call_info": {"func_end_line": 1221, "code": "  loadState (stateKey) {\r\n    if (this.enablePersistence) {\r\n      if (!stateKey) stateKey = this.getStateKey(this.getLoadSettings().initialPaths)\r\n      if (stateKey) {\r\n        return this.stateStore.load(stateKey)\r\n      } else {\r\n        return this.applicationDelegate.getTemporaryWindowState()\r\n      }\r\n    } else {\r\n      return Promise.resolve(null)\r\n    }\r\n  }\r", "name": "getStateKey", "func_location": "AtomEnvironment.loadState", "args": [".initialPaths"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 1212, "func_start_line": 1210}}, {"func_info": {"comment": [" Public: Get the load settings for the current window.", "", " Returns an {Object} containing all the load setting key/value pairs."], "name": "AtomEnvironment.getLoadSettings", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 527, "start_line": 525}, "call_info": {"func_end_line": 1221, "code": "  loadState (stateKey) {\r\n    if (this.enablePersistence) {\r\n      if (!stateKey) stateKey = this.getStateKey(this.getLoadSettings().initialPaths)\r\n      if (stateKey) {\r\n        return this.stateStore.load(stateKey)\r\n      } else {\r\n        return this.applicationDelegate.getTemporaryWindowState()\r\n      }\r\n    } else {\r\n      return Promise.resolve(null)\r\n    }\r\n  }\r", "name": "getLoadSettings", "func_location": "AtomEnvironment.loadState", "args": [".initialPaths"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 1212, "func_start_line": 1210}}, {"func_info": {"comment": [], "name": "ThemeManager.loadLessStylesheet", "params": ["lessStylesheetPath", "importFallbackVariables"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 298, "start_line": 249}, "call_info": {"func_end_line": 247, "code": "  loadStylesheet (stylesheetPath, importFallbackVariables) {\r\n    if (path.extname(stylesheetPath) === '.less') {\r\n      return this.loadLessStylesheet(stylesheetPath, importFallbackVariables)\r\n    } else {\r\n      return fs.readFileSync(stylesheetPath, 'utf8')\r\n    }\r\n  }\r", "name": "loadLessStylesheet", "func_location": "ThemeManager.loadStylesheet", "args": ["stylesheetPath", "importFallbackVariables"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 243, "func_start_line": 241}}, {"func_info": {"comment": [], "name": "Package.getStylesheetPaths", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 562, "start_line": 543}, "call_info": {"func_end_line": 490, "code": "  loadStylesheets () {\r\n    this.stylesheets = this.getStylesheetPaths().map(stylesheetPath =>\r\n      [stylesheetPath, this.themeManager.loadStylesheet(stylesheetPath, true)]\r\n    )\r\n  }\r", "name": "getStylesheetPaths", "func_location": "Package.loadStylesheets", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 487, "func_start_line": 486}}, {"func_info": {"comment": [], "name": "ThemeManager.unwatchUserStylesheet", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 183, "start_line": 177}, "call_info": {"func_end_line": 218, "code": "  loadUserStylesheet () {\r\n    this.unwatchUserStylesheet()\r\n\r\n    const userStylesheetPath = this.styleManager.getUserStyleSheetPath()\r\n    if (!fs.isFileSync(userStylesheetPath)) { return }\r\n\r\n    try {\r\n      this.userStylesheetFile = new File(userStylesheetPath)\r\n      this.userStylesheetSubscriptions = new CompositeDisposable()\r\n      const reloadStylesheet = () => this.loadUserStylesheet()\r\n      this.userStylesheetSubscriptions.add(this.userStylesheetFile.onDidChange(reloadStylesheet))\r\n      this.userStylesheetSubscriptions.add(this.userStylesheetFile.onDidRename(reloadStylesheet))\r\n      this.userStylesheetSubscriptions.add(this.userStylesheetFile.onDidDelete(reloadStylesheet))\r\n    } catch (error) {\r\n      const message = `\\\r\nUnable to watch path: \\`${path.basename(userStylesheetPath)}\\`. Make sure\r\nyou have permissions to \\`${userStylesheetPath}\\`.\r\n\r\nOn linux there are currently problems with watch sizes. See\r\n[this document][watches] for more info.\r\n[watches]:https://github.com/atom/atom/blob/master/docs/build-instructions/linux.md#typeerror-unable-to-watch-path\\\r\n`\r\n      this.notificationManager.addError(message, {dismissable: true})\r\n    }\r\n\r\n    let userStylesheetContents\r\n    try {\r\n      userStylesheetContents = this.loadStylesheet(userStylesheetPath, true)\r\n    } catch (error) {\r\n      return\r\n    }\r\n\r\n    this.userStyleSheetDisposable = this.styleManager.addStyleSheet(userStylesheetContents, {sourcePath: userStylesheetPath, priority: 2})\r\n  }\r", "name": "unwatchUserStylesheet", "func_location": "ThemeManager.loadUserStylesheet", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 186, "func_start_line": 185}}, {"func_info": {"comment": [], "name": "ThemeManager.loadStylesheet", "params": ["stylesheetPath", "importFallbackVariables"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 247, "start_line": 241}, "call_info": {"func_end_line": 218, "code": "  loadUserStylesheet () {\r\n    this.unwatchUserStylesheet()\r\n\r\n    const userStylesheetPath = this.styleManager.getUserStyleSheetPath()\r\n    if (!fs.isFileSync(userStylesheetPath)) { return }\r\n\r\n    try {\r\n      this.userStylesheetFile = new File(userStylesheetPath)\r\n      this.userStylesheetSubscriptions = new CompositeDisposable()\r\n      const reloadStylesheet = () => this.loadUserStylesheet()\r\n      this.userStylesheetSubscriptions.add(this.userStylesheetFile.onDidChange(reloadStylesheet))\r\n      this.userStylesheetSubscriptions.add(this.userStylesheetFile.onDidRename(reloadStylesheet))\r\n      this.userStylesheetSubscriptions.add(this.userStylesheetFile.onDidDelete(reloadStylesheet))\r\n    } catch (error) {\r\n      const message = `\\\r\nUnable to watch path: \\`${path.basename(userStylesheetPath)}\\`. Make sure\r\nyou have permissions to \\`${userStylesheetPath}\\`.\r\n\r\nOn linux there are currently problems with watch sizes. See\r\n[this document][watches] for more info.\r\n[watches]:https://github.com/atom/atom/blob/master/docs/build-instructions/linux.md#typeerror-unable-to-watch-path\\\r\n`\r\n      this.notificationManager.addError(message, {dismissable: true})\r\n    }\r\n\r\n    let userStylesheetContents\r\n    try {\r\n      userStylesheetContents = this.loadStylesheet(userStylesheetPath, true)\r\n    } catch (error) {\r\n      return\r\n    }\r\n\r\n    this.userStyleSheetDisposable = this.styleManager.addStyleSheet(userStylesheetContents, {sourcePath: userStylesheetPath, priority: 2})\r\n  }\r", "name": "loadStylesheet", "func_location": "ThemeManager.loadUserStylesheet", "args": ["userStylesheetPath", {"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 212, "func_start_line": 185}}, {"func_info": {"comment": [" Essential: Returns a {String} representing the contents of the line at the", " given screen row.", "", " * `screenRow` A {Number} representing a zero-indexed screen row."], "name": "TextEditor.lineTextForScreenRow", "params": ["screenRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 1242, "start_line": 1239}, "call_info": {"func_end_line": 1249, "code": "  logScreenLines (start = 0, end = this.getLastScreenRow()) {\r\n    for (let row = start; row <= end; row++) {\r\n      const line = this.lineTextForScreenRow(row)\r\n      console.log(row, this.bufferRowForScreenRow(row), line, line.length)\r\n    }\r\n  }\r", "name": "lineTextForScreenRow", "func_location": "TextEditor.logScreenLines", "args": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 1246, "func_start_line": 1244}}, {"func_info": {"comment": [], "name": "TextEditor.bufferRowForScreenRow", "params": ["screenRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 1278, "start_line": 1276}, "call_info": {"func_end_line": 1249, "code": "  logScreenLines (start = 0, end = this.getLastScreenRow()) {\r\n    for (let row = start; row <= end; row++) {\r\n      const line = this.lineTextForScreenRow(row)\r\n      console.log(row, this.bufferRowForScreenRow(row), line, line.length)\r\n    }\r\n  }\r", "name": "bufferRowForScreenRow", "func_location": "TextEditor.logScreenLines", "args": ["row", null, "line", "line.length"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 1247, "func_start_line": 1244}}, {"func_info": {"comment": [], "name": "last", "params": ["array"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1208, "start_line": 1206}, "call_info": {"func_end_line": 859, "code": "  logState () {\r\n    const iterator = last(this.iterators)\r\n    if (iterator.treeCursor) {\r\n      console.log(\r\n        iterator.getPosition(),\r\n        iterator.treeCursor.nodeType,\r\n        new Range(\r\n          iterator.languageLayer.tree.rootNode.startPosition,\r\n          iterator.languageLayer.tree.rootNode.endPosition\r\n        ).toString()\r\n      )\r\n      console.log('close', iterator.closeTags.map(id => this.languageMode.grammar.scopeNameForScopeId(id)))\r\n      console.log('open', iterator.openTags.map(id => this.languageMode.grammar.scopeNameForScopeId(id)))\r\n    }\r\n  }\r", "name": "last", "func_location": "HighlightIterator.logState", "args": [".iterators"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 846, "func_start_line": 845}}, {"func_info": {"comment": [], "name": "TextEditorRegistry.updateAndMonitorEditorSettings", "params": ["editor", "oldLanguageMode"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js", "end_line": 222, "start_line": 218}, "call_info": {"func_end_line": 177, "comment": [" Keep a {TextEditor}'s configuration in sync with Atom's settings.", "", " * `editor` The editor whose configuration will be maintained.", "", " Returns a {Disposable} that can be used to stop updating the editor's", " configuration."], "code": "  maintainConfig (editor) {\r\n    if (this.editorsWithMaintainedConfig.has(editor)) {\r\n      return new Disposable(noop)\r\n    }\r\n    this.editorsWithMaintainedConfig.add(editor)\r\n\r\n    this.updateAndMonitorEditorSettings(editor)\r\n    const languageChangeSubscription = editor.buffer.onDidChangeLanguageMode((newLanguageMode, oldLanguageMode) => {\r\n      this.updateAndMonitorEditorSettings(editor, oldLanguageMode)\r\n    })\r\n    this.subscriptions.add(languageChangeSubscription)\r\n\r\n    const updateTabTypes = () => {\r\n      const configOptions = {scope: editor.getRootScopeDescriptor()}\r\n      editor.setSoftTabs(shouldEditorUseSoftTabs(\r\n        editor,\r\n        this.config.get('editor.tabType', configOptions),\r\n        this.config.get('editor.softTabs', configOptions)\r\n      ))\r\n    }\r\n\r\n    updateTabTypes()\r\n    const tokenizeSubscription = editor.onDidTokenize(updateTabTypes)\r\n    this.subscriptions.add(tokenizeSubscription)\r\n\r\n    return new Disposable(() => {\r\n      this.editorsWithMaintainedConfig.delete(editor)\r\n      tokenizeSubscription.dispose()\r\n      languageChangeSubscription.dispose()\r\n      this.subscriptions.remove(languageChangeSubscription)\r\n      this.subscriptions.remove(tokenizeSubscription)\r\n    })\r\n  }\r", "name": "updateAndMonitorEditorSettings", "func_location": "TextEditorRegistry.maintainConfig", "args": ["editor"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js", "line": 151, "func_start_line": 145}}, {"func_info": {"comment": [" Extended: Force a {TextBuffer} to use a different grammar than the", " one that would otherwise be selected for it.", "", " * `buffer` The {TextBuffer} whose grammar will be set.", " * `languageId` The {String} id of the desired language.", "", " Returns a {Boolean} that indicates whether the language was successfully", " found."], "name": "GrammarRegistry.assignLanguageMode", "params": ["buffer", "languageId"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 143, "start_line": 124}, "call_info": {"func_end_line": 114, "comment": [" Extended: set a {TextBuffer}'s language mode based on its path and content,", " and continue to update its language mode as grammars are added or updated, or", " the buffer's file path changes.", "", " * `buffer` The {TextBuffer} whose language mode will be maintained.", "", " Returns a {Disposable} that can be used to stop updating the buffer's", " language mode."], "code": "  maintainLanguageMode (buffer) {\r\n    this.grammarScoresByBuffer.set(buffer, null)\r\n\r\n    const languageOverride = this.languageOverridesByBufferId.get(buffer.id)\r\n    if (languageOverride) {\r\n      this.assignLanguageMode(buffer, languageOverride)\r\n    } else {\r\n      this.autoAssignLanguageMode(buffer)\r\n    }\r\n\r\n    const pathChangeSubscription = buffer.onDidChangePath(() => {\r\n      this.grammarScoresByBuffer.delete(buffer)\r\n      if (!this.languageOverridesByBufferId.has(buffer.id)) {\r\n        this.autoAssignLanguageMode(buffer)\r\n      }\r\n    })\r\n\r\n    const destroySubscription = buffer.onDidDestroy(() => {\r\n      this.grammarScoresByBuffer.delete(buffer)\r\n      this.languageOverridesByBufferId.delete(buffer.id)\r\n      this.subscriptions.remove(destroySubscription)\r\n      this.subscriptions.remove(pathChangeSubscription)\r\n    })\r\n\r\n    this.subscriptions.add(pathChangeSubscription, destroySubscription)\r\n\r\n    return new Disposable(() => {\r\n      destroySubscription.dispose()\r\n      pathChangeSubscription.dispose()\r\n      this.subscriptions.remove(pathChangeSubscription)\r\n      this.subscriptions.remove(destroySubscription)\r\n      this.grammarScoresByBuffer.delete(buffer)\r\n      this.languageOverridesByBufferId.delete(buffer.id)\r\n    })\r\n  }\r", "name": "assignLanguageMode", "func_location": "GrammarRegistry.maintainLanguageMode", "args": ["buffer", "languageOverride"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 85, "func_start_line": 80}}, {"func_info": {"comment": [" Extended: Remove any language mode override that has been set for the", " given {TextBuffer}. This will assign to the buffer the best language", " mode available.", "", " * `buffer` The {TextBuffer}."], "name": "GrammarRegistry.autoAssignLanguageMode", "params": ["buffer"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 168, "start_line": 158}, "call_info": {"func_end_line": 114, "comment": [" Extended: set a {TextBuffer}'s language mode based on its path and content,", " and continue to update its language mode as grammars are added or updated, or", " the buffer's file path changes.", "", " * `buffer` The {TextBuffer} whose language mode will be maintained.", "", " Returns a {Disposable} that can be used to stop updating the buffer's", " language mode."], "code": "  maintainLanguageMode (buffer) {\r\n    this.grammarScoresByBuffer.set(buffer, null)\r\n\r\n    const languageOverride = this.languageOverridesByBufferId.get(buffer.id)\r\n    if (languageOverride) {\r\n      this.assignLanguageMode(buffer, languageOverride)\r\n    } else {\r\n      this.autoAssignLanguageMode(buffer)\r\n    }\r\n\r\n    const pathChangeSubscription = buffer.onDidChangePath(() => {\r\n      this.grammarScoresByBuffer.delete(buffer)\r\n      if (!this.languageOverridesByBufferId.has(buffer.id)) {\r\n        this.autoAssignLanguageMode(buffer)\r\n      }\r\n    })\r\n\r\n    const destroySubscription = buffer.onDidDestroy(() => {\r\n      this.grammarScoresByBuffer.delete(buffer)\r\n      this.languageOverridesByBufferId.delete(buffer.id)\r\n      this.subscriptions.remove(destroySubscription)\r\n      this.subscriptions.remove(pathChangeSubscription)\r\n    })\r\n\r\n    this.subscriptions.add(pathChangeSubscription, destroySubscription)\r\n\r\n    return new Disposable(() => {\r\n      destroySubscription.dispose()\r\n      pathChangeSubscription.dispose()\r\n      this.subscriptions.remove(pathChangeSubscription)\r\n      this.subscriptions.remove(destroySubscription)\r\n      this.grammarScoresByBuffer.delete(buffer)\r\n      this.languageOverridesByBufferId.delete(buffer.id)\r\n    })\r\n  }\r", "name": "autoAssignLanguageMode", "func_location": "GrammarRegistry.maintainLanguageMode", "args": ["buffer"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 87, "func_start_line": 80}}, {"func_info": {"comment": [], "name": "Config.makeValueConformToSchema", "params": ["keyPath", "value", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1178, "start_line": 1164}, "call_info": {"func_end_line": 1178, "code": "  makeValueConformToSchema (keyPath, value, options) {\r\n    if (options != null ? options.suppressException : undefined) {\r\n      try {\r\n        return this.makeValueConformToSchema(keyPath, value)\r\n      } catch (e) {\r\n        return undefined\r\n      }\r\n    } else {\r\n      let schema\r\n      if ((schema = this.getSchema(keyPath)) == null) {\r\n        if (schema === false) { throw new Error(`Illegal key path ${keyPath}`) }\r\n      }\r\n      return this.constructor.executeSchemaEnforcers(keyPath, value, schema)\r\n    }\r\n  }\r", "name": "makeValueConformToSchema", "func_location": "Config.makeValueConformToSchema", "args": ["keyPath", "value"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1167, "func_start_line": 1164}}, {"func_info": {"comment": [" Extended: Retrieve the schema for a specific key path. The schema will tell", " you what type the keyPath expects, and other metadata about the config", " option.", "", " * `keyPath` The {String} name of the key.", "", " Returns an {Object} eg. `{type: 'integer', default: 23, minimum: 1}`.", " Returns `null` when the keyPath has no schema specified, but is accessible", " from the root schema."], "name": "Config.getSchema", "params": ["keyPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 805, "start_line": 783}, "call_info": {"func_end_line": 1178, "code": "  makeValueConformToSchema (keyPath, value, options) {\r\n    if (options != null ? options.suppressException : undefined) {\r\n      try {\r\n        return this.makeValueConformToSchema(keyPath, value)\r\n      } catch (e) {\r\n        return undefined\r\n      }\r\n    } else {\r\n      let schema\r\n      if ((schema = this.getSchema(keyPath)) == null) {\r\n        if (schema === false) { throw new Error(`Illegal key path ${keyPath}`) }\r\n      }\r\n      return this.constructor.executeSchemaEnforcers(keyPath, value, schema)\r\n    }\r\n  }\r", "name": "getSchema", "func_location": "Config.makeValueConformToSchema", "args": ["keyPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1173, "func_start_line": 1164}}, {"func_info": {"comment": [" Private: Parse a selector into parts.", "          If already parsed, returns the selector unmodified.", "", " * `selector` a {String|Array<String>} specifying what to match", " Returns selector parts, an {Array<String>}."], "name": "parse", "params": ["selector"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selectors.js", "end_line": 14, "start_line": 10}, "call_info": {"func_end_line": 29, "comment": [" Essential: Return a matcher function for a selector.", "", " * selector, a {String} selector", " Returns {(scope: String) -> Boolean}, a matcher function returning", " true iff the scope matches the selector."], "code": "function matcherForSelector (selector) {\r\n  const parts = parse(selector)\r\n  if (typeof parts === 'function') return parts\r\n  return selector\r\n    ? scope => isSubset(parts, parse(scope))\r\n    : always\r\n}\r", "name": "parse", "func_location": "matcherForSelector", "args": ["selector"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selectors.js", "line": 24, "func_start_line": 23}}, {"func_info": {"comment": [], "name": "TextEditorComponent.updateSyncBeforeMeasuringContent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 387, "start_line": 364}, "call_info": {"func_end_line": 362, "code": "  measureBlockDecorations () {\r\n    if (this.remeasureAllBlockDecorations) {\r\n      this.remeasureAllBlockDecorations = false\r\n\r\n      const decorations = this.props.model.getDecorations()\r\n      for (var i = 0; i < decorations.length; i++) {\r\n        const decoration = decorations[i]\r\n        const marker = decoration.getMarker()\r\n        if (marker.isValid() && decoration.getProperties().type === 'block') {\r\n          this.blockDecorationsToMeasure.add(decoration)\r\n        }\r\n      }\r\n\r\n      // Update the width of the line tiles to ensure block decorations are\r\n      // measured with the most recent width.\r\n      if (this.blockDecorationsToMeasure.size > 0) {\r\n        this.updateSyncBeforeMeasuringContent()\r\n      }\r\n    }\r\n\r\n    if (this.blockDecorationsToMeasure.size > 0) {\r\n      const {blockDecorationMeasurementArea} = this.refs\r\n      const sentinelElements = new Set()\r\n\r\n      blockDecorationMeasurementArea.appendChild(document.createElement('div'))\r\n      this.blockDecorationsToMeasure.forEach((decoration) => {\r\n        const {item} = decoration.getProperties()\r\n        const decorationElement = TextEditor.viewForItem(item)\r\n        if (document.contains(decorationElement)) {\r\n          const parentElement = decorationElement.parentElement\r\n\r\n          if (!decorationElement.previousSibling) {\r\n            const sentinelElement = this.blockDecorationSentinel.cloneNode()\r\n            parentElement.insertBefore(sentinelElement, decorationElement)\r\n            sentinelElements.add(sentinelElement)\r\n          }\r\n\r\n          if (!decorationElement.nextSibling) {\r\n            const sentinelElement = this.blockDecorationSentinel.cloneNode()\r\n            parentElement.appendChild(sentinelElement)\r\n            sentinelElements.add(sentinelElement)\r\n          }\r\n\r\n          this.didMeasureVisibleBlockDecoration = true\r\n        } else {\r\n          blockDecorationMeasurementArea.appendChild(this.blockDecorationSentinel.cloneNode())\r\n          blockDecorationMeasurementArea.appendChild(decorationElement)\r\n          blockDecorationMeasurementArea.appendChild(this.blockDecorationSentinel.cloneNode())\r\n        }\r\n      })\r\n\r\n      if (this.resizeBlockDecorationMeasurementsArea) {\r\n        this.resizeBlockDecorationMeasurementsArea = false\r\n        this.refs.blockDecorationMeasurementArea.style.width = this.getScrollWidth() + 'px'\r\n      }\r\n\r\n      this.blockDecorationsToMeasure.forEach((decoration) => {\r\n        const {item} = decoration.getProperties()\r\n        const decorationElement = TextEditor.viewForItem(item)\r\n        const {previousSibling, nextSibling} = decorationElement\r\n        const height = nextSibling.getBoundingClientRect().top - previousSibling.getBoundingClientRect().bottom\r\n        this.heightsByBlockDecoration.set(decoration, height)\r\n        this.lineTopIndex.resizeBlock(decoration, height)\r\n      })\r\n\r\n      sentinelElements.forEach((sentinelElement) => sentinelElement.remove())\r\n      while (blockDecorationMeasurementArea.firstChild) {\r\n        blockDecorationMeasurementArea.firstChild.remove()\r\n      }\r\n      this.blockDecorationsToMeasure.clear()\r\n    }\r\n  }\r", "name": "updateSyncBeforeMeasuringContent", "func_location": "TextEditorComponent.measureBlockDecorations", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 307, "func_start_line": 291}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2682, "start_line": 2672}, "call_info": {"func_end_line": 362, "code": "  measureBlockDecorations () {\r\n    if (this.remeasureAllBlockDecorations) {\r\n      this.remeasureAllBlockDecorations = false\r\n\r\n      const decorations = this.props.model.getDecorations()\r\n      for (var i = 0; i < decorations.length; i++) {\r\n        const decoration = decorations[i]\r\n        const marker = decoration.getMarker()\r\n        if (marker.isValid() && decoration.getProperties().type === 'block') {\r\n          this.blockDecorationsToMeasure.add(decoration)\r\n        }\r\n      }\r\n\r\n      // Update the width of the line tiles to ensure block decorations are\r\n      // measured with the most recent width.\r\n      if (this.blockDecorationsToMeasure.size > 0) {\r\n        this.updateSyncBeforeMeasuringContent()\r\n      }\r\n    }\r\n\r\n    if (this.blockDecorationsToMeasure.size > 0) {\r\n      const {blockDecorationMeasurementArea} = this.refs\r\n      const sentinelElements = new Set()\r\n\r\n      blockDecorationMeasurementArea.appendChild(document.createElement('div'))\r\n      this.blockDecorationsToMeasure.forEach((decoration) => {\r\n        const {item} = decoration.getProperties()\r\n        const decorationElement = TextEditor.viewForItem(item)\r\n        if (document.contains(decorationElement)) {\r\n          const parentElement = decorationElement.parentElement\r\n\r\n          if (!decorationElement.previousSibling) {\r\n            const sentinelElement = this.blockDecorationSentinel.cloneNode()\r\n            parentElement.insertBefore(sentinelElement, decorationElement)\r\n            sentinelElements.add(sentinelElement)\r\n          }\r\n\r\n          if (!decorationElement.nextSibling) {\r\n            const sentinelElement = this.blockDecorationSentinel.cloneNode()\r\n            parentElement.appendChild(sentinelElement)\r\n            sentinelElements.add(sentinelElement)\r\n          }\r\n\r\n          this.didMeasureVisibleBlockDecoration = true\r\n        } else {\r\n          blockDecorationMeasurementArea.appendChild(this.blockDecorationSentinel.cloneNode())\r\n          blockDecorationMeasurementArea.appendChild(decorationElement)\r\n          blockDecorationMeasurementArea.appendChild(this.blockDecorationSentinel.cloneNode())\r\n        }\r\n      })\r\n\r\n      if (this.resizeBlockDecorationMeasurementsArea) {\r\n        this.resizeBlockDecorationMeasurementsArea = false\r\n        this.refs.blockDecorationMeasurementArea.style.width = this.getScrollWidth() + 'px'\r\n      }\r\n\r\n      this.blockDecorationsToMeasure.forEach((decoration) => {\r\n        const {item} = decoration.getProperties()\r\n        const decorationElement = TextEditor.viewForItem(item)\r\n        const {previousSibling, nextSibling} = decorationElement\r\n        const height = nextSibling.getBoundingClientRect().top - previousSibling.getBoundingClientRect().bottom\r\n        this.heightsByBlockDecoration.set(decoration, height)\r\n        this.lineTopIndex.resizeBlock(decoration, height)\r\n      })\r\n\r\n      sentinelElements.forEach((sentinelElement) => sentinelElement.remove())\r\n      while (blockDecorationMeasurementArea.firstChild) {\r\n        blockDecorationMeasurementArea.firstChild.remove()\r\n      }\r\n      this.blockDecorationsToMeasure.clear()\r\n    }\r\n  }\r", "name": "getScrollWidth", "func_location": "TextEditorComponent.measureBlockDecorations", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 344, "func_start_line": 291}}, {"func_info": {"comment": [], "name": "TextEditorComponent.measureGutterDimensions", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2199, "start_line": 2175}, "call_info": {"func_end_line": 424, "code": "  measureContentDuringUpdateSync () {\r\n    let gutterDimensionsChanged = false\r\n    if (this.remeasureGutterDimensions) {\r\n      gutterDimensionsChanged = this.measureGutterDimensions()\r\n      this.remeasureGutterDimensions = false\r\n    }\r\n    const wasHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    this.measureLongestLineWidth()\r\n    this.measureHorizontalPositions()\r\n    this.updateAbsolutePositionedDecorations()\r\n\r\n    const isHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    if (this.pendingAutoscroll) {\r\n      this.derivedDimensionsCache = {}\r\n      const {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollHorizontally(screenRange, options)\r\n\r\n      if (!wasHorizontalScrollbarVisible && isHorizontalScrollbarVisible) {\r\n        this.autoscrollVertically(screenRange, options)\r\n      }\r\n      this.pendingAutoscroll = null\r\n    }\r\n\r\n    this.linesToMeasure.clear()\r\n    this.measuredContent = true\r\n\r\n    return gutterDimensionsChanged || wasHorizontalScrollbarVisible !== isHorizontalScrollbarVisible\r\n  }\r", "name": "measureGutterDimensions", "func_location": "TextEditorComponent.measureContentDuringUpdateSync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 392, "func_start_line": 389}}, {"func_info": {"comment": [], "name": "TextEditorComponent.canScrollHorizontally", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2657, "start_line": 2651}, "call_info": {"func_end_line": 424, "code": "  measureContentDuringUpdateSync () {\r\n    let gutterDimensionsChanged = false\r\n    if (this.remeasureGutterDimensions) {\r\n      gutterDimensionsChanged = this.measureGutterDimensions()\r\n      this.remeasureGutterDimensions = false\r\n    }\r\n    const wasHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    this.measureLongestLineWidth()\r\n    this.measureHorizontalPositions()\r\n    this.updateAbsolutePositionedDecorations()\r\n\r\n    const isHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    if (this.pendingAutoscroll) {\r\n      this.derivedDimensionsCache = {}\r\n      const {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollHorizontally(screenRange, options)\r\n\r\n      if (!wasHorizontalScrollbarVisible && isHorizontalScrollbarVisible) {\r\n        this.autoscrollVertically(screenRange, options)\r\n      }\r\n      this.pendingAutoscroll = null\r\n    }\r\n\r\n    this.linesToMeasure.clear()\r\n    this.measuredContent = true\r\n\r\n    return gutterDimensionsChanged || wasHorizontalScrollbarVisible !== isHorizontalScrollbarVisible\r\n  }\r", "name": "canScrollHorizontally", "func_location": "TextEditorComponent.measureContentDuringUpdateSync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 396, "func_start_line": 389}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getHorizontalScrollbarHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2710, "start_line": 2708}, "call_info": {"func_end_line": 424, "code": "  measureContentDuringUpdateSync () {\r\n    let gutterDimensionsChanged = false\r\n    if (this.remeasureGutterDimensions) {\r\n      gutterDimensionsChanged = this.measureGutterDimensions()\r\n      this.remeasureGutterDimensions = false\r\n    }\r\n    const wasHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    this.measureLongestLineWidth()\r\n    this.measureHorizontalPositions()\r\n    this.updateAbsolutePositionedDecorations()\r\n\r\n    const isHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    if (this.pendingAutoscroll) {\r\n      this.derivedDimensionsCache = {}\r\n      const {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollHorizontally(screenRange, options)\r\n\r\n      if (!wasHorizontalScrollbarVisible && isHorizontalScrollbarVisible) {\r\n        this.autoscrollVertically(screenRange, options)\r\n      }\r\n      this.pendingAutoscroll = null\r\n    }\r\n\r\n    this.linesToMeasure.clear()\r\n    this.measuredContent = true\r\n\r\n    return gutterDimensionsChanged || wasHorizontalScrollbarVisible !== isHorizontalScrollbarVisible\r\n  }\r", "name": "getHorizontalScrollbarHeight", "func_location": "TextEditorComponent.measureContentDuringUpdateSync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 397, "func_start_line": 389}}, {"func_info": {"comment": [], "name": "TextEditorComponent.measureLongestLineWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2237, "start_line": 2231}, "call_info": {"func_end_line": 424, "code": "  measureContentDuringUpdateSync () {\r\n    let gutterDimensionsChanged = false\r\n    if (this.remeasureGutterDimensions) {\r\n      gutterDimensionsChanged = this.measureGutterDimensions()\r\n      this.remeasureGutterDimensions = false\r\n    }\r\n    const wasHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    this.measureLongestLineWidth()\r\n    this.measureHorizontalPositions()\r\n    this.updateAbsolutePositionedDecorations()\r\n\r\n    const isHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    if (this.pendingAutoscroll) {\r\n      this.derivedDimensionsCache = {}\r\n      const {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollHorizontally(screenRange, options)\r\n\r\n      if (!wasHorizontalScrollbarVisible && isHorizontalScrollbarVisible) {\r\n        this.autoscrollVertically(screenRange, options)\r\n      }\r\n      this.pendingAutoscroll = null\r\n    }\r\n\r\n    this.linesToMeasure.clear()\r\n    this.measuredContent = true\r\n\r\n    return gutterDimensionsChanged || wasHorizontalScrollbarVisible !== isHorizontalScrollbarVisible\r\n  }\r", "name": "measureLongestLineWidth", "func_location": "TextEditorComponent.measureContentDuringUpdateSync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 400, "func_start_line": 389}}, {"func_info": {"comment": [], "name": "TextEditorComponent.measureHorizontalPositions", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2292, "start_line": 2259}, "call_info": {"func_end_line": 424, "code": "  measureContentDuringUpdateSync () {\r\n    let gutterDimensionsChanged = false\r\n    if (this.remeasureGutterDimensions) {\r\n      gutterDimensionsChanged = this.measureGutterDimensions()\r\n      this.remeasureGutterDimensions = false\r\n    }\r\n    const wasHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    this.measureLongestLineWidth()\r\n    this.measureHorizontalPositions()\r\n    this.updateAbsolutePositionedDecorations()\r\n\r\n    const isHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    if (this.pendingAutoscroll) {\r\n      this.derivedDimensionsCache = {}\r\n      const {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollHorizontally(screenRange, options)\r\n\r\n      if (!wasHorizontalScrollbarVisible && isHorizontalScrollbarVisible) {\r\n        this.autoscrollVertically(screenRange, options)\r\n      }\r\n      this.pendingAutoscroll = null\r\n    }\r\n\r\n    this.linesToMeasure.clear()\r\n    this.measuredContent = true\r\n\r\n    return gutterDimensionsChanged || wasHorizontalScrollbarVisible !== isHorizontalScrollbarVisible\r\n  }\r", "name": "measureHorizontalPositions", "func_location": "TextEditorComponent.measureContentDuringUpdateSync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 401, "func_start_line": 389}}, {"func_info": {"comment": [], "name": "TextEditorComponent.updateAbsolutePositionedDecorations", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1325, "start_line": 1321}, "call_info": {"func_end_line": 424, "code": "  measureContentDuringUpdateSync () {\r\n    let gutterDimensionsChanged = false\r\n    if (this.remeasureGutterDimensions) {\r\n      gutterDimensionsChanged = this.measureGutterDimensions()\r\n      this.remeasureGutterDimensions = false\r\n    }\r\n    const wasHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    this.measureLongestLineWidth()\r\n    this.measureHorizontalPositions()\r\n    this.updateAbsolutePositionedDecorations()\r\n\r\n    const isHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    if (this.pendingAutoscroll) {\r\n      this.derivedDimensionsCache = {}\r\n      const {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollHorizontally(screenRange, options)\r\n\r\n      if (!wasHorizontalScrollbarVisible && isHorizontalScrollbarVisible) {\r\n        this.autoscrollVertically(screenRange, options)\r\n      }\r\n      this.pendingAutoscroll = null\r\n    }\r\n\r\n    this.linesToMeasure.clear()\r\n    this.measuredContent = true\r\n\r\n    return gutterDimensionsChanged || wasHorizontalScrollbarVisible !== isHorizontalScrollbarVisible\r\n  }\r", "name": "updateAbsolutePositionedDecorations", "func_location": "TextEditorComponent.measureContentDuringUpdateSync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 402, "func_start_line": 389}}, {"func_info": {"comment": [], "name": "TextEditorComponent.canScrollHorizontally", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2657, "start_line": 2651}, "call_info": {"func_end_line": 424, "code": "  measureContentDuringUpdateSync () {\r\n    let gutterDimensionsChanged = false\r\n    if (this.remeasureGutterDimensions) {\r\n      gutterDimensionsChanged = this.measureGutterDimensions()\r\n      this.remeasureGutterDimensions = false\r\n    }\r\n    const wasHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    this.measureLongestLineWidth()\r\n    this.measureHorizontalPositions()\r\n    this.updateAbsolutePositionedDecorations()\r\n\r\n    const isHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    if (this.pendingAutoscroll) {\r\n      this.derivedDimensionsCache = {}\r\n      const {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollHorizontally(screenRange, options)\r\n\r\n      if (!wasHorizontalScrollbarVisible && isHorizontalScrollbarVisible) {\r\n        this.autoscrollVertically(screenRange, options)\r\n      }\r\n      this.pendingAutoscroll = null\r\n    }\r\n\r\n    this.linesToMeasure.clear()\r\n    this.measuredContent = true\r\n\r\n    return gutterDimensionsChanged || wasHorizontalScrollbarVisible !== isHorizontalScrollbarVisible\r\n  }\r", "name": "canScrollHorizontally", "func_location": "TextEditorComponent.measureContentDuringUpdateSync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 405, "func_start_line": 389}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getHorizontalScrollbarHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2710, "start_line": 2708}, "call_info": {"func_end_line": 424, "code": "  measureContentDuringUpdateSync () {\r\n    let gutterDimensionsChanged = false\r\n    if (this.remeasureGutterDimensions) {\r\n      gutterDimensionsChanged = this.measureGutterDimensions()\r\n      this.remeasureGutterDimensions = false\r\n    }\r\n    const wasHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    this.measureLongestLineWidth()\r\n    this.measureHorizontalPositions()\r\n    this.updateAbsolutePositionedDecorations()\r\n\r\n    const isHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    if (this.pendingAutoscroll) {\r\n      this.derivedDimensionsCache = {}\r\n      const {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollHorizontally(screenRange, options)\r\n\r\n      if (!wasHorizontalScrollbarVisible && isHorizontalScrollbarVisible) {\r\n        this.autoscrollVertically(screenRange, options)\r\n      }\r\n      this.pendingAutoscroll = null\r\n    }\r\n\r\n    this.linesToMeasure.clear()\r\n    this.measuredContent = true\r\n\r\n    return gutterDimensionsChanged || wasHorizontalScrollbarVisible !== isHorizontalScrollbarVisible\r\n  }\r", "name": "getHorizontalScrollbarHeight", "func_location": "TextEditorComponent.measureContentDuringUpdateSync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 406, "func_start_line": 389}}, {"func_info": {"comment": [], "name": "TextEditorComponent.autoscrollHorizontally", "params": ["screenRange", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2095, "start_line": 2071}, "call_info": {"func_end_line": 424, "code": "  measureContentDuringUpdateSync () {\r\n    let gutterDimensionsChanged = false\r\n    if (this.remeasureGutterDimensions) {\r\n      gutterDimensionsChanged = this.measureGutterDimensions()\r\n      this.remeasureGutterDimensions = false\r\n    }\r\n    const wasHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    this.measureLongestLineWidth()\r\n    this.measureHorizontalPositions()\r\n    this.updateAbsolutePositionedDecorations()\r\n\r\n    const isHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    if (this.pendingAutoscroll) {\r\n      this.derivedDimensionsCache = {}\r\n      const {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollHorizontally(screenRange, options)\r\n\r\n      if (!wasHorizontalScrollbarVisible && isHorizontalScrollbarVisible) {\r\n        this.autoscrollVertically(screenRange, options)\r\n      }\r\n      this.pendingAutoscroll = null\r\n    }\r\n\r\n    this.linesToMeasure.clear()\r\n    this.measuredContent = true\r\n\r\n    return gutterDimensionsChanged || wasHorizontalScrollbarVisible !== isHorizontalScrollbarVisible\r\n  }\r", "name": "autoscrollHorizontally", "func_location": "TextEditorComponent.measureContentDuringUpdateSync", "args": ["screenRange", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 412, "func_start_line": 389}}, {"func_info": {"comment": [], "name": "TextEditorComponent.autoscrollVertically", "params": ["screenRange", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2069, "start_line": 2035}, "call_info": {"func_end_line": 424, "code": "  measureContentDuringUpdateSync () {\r\n    let gutterDimensionsChanged = false\r\n    if (this.remeasureGutterDimensions) {\r\n      gutterDimensionsChanged = this.measureGutterDimensions()\r\n      this.remeasureGutterDimensions = false\r\n    }\r\n    const wasHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    this.measureLongestLineWidth()\r\n    this.measureHorizontalPositions()\r\n    this.updateAbsolutePositionedDecorations()\r\n\r\n    const isHorizontalScrollbarVisible = (\r\n      this.canScrollHorizontally() &&\r\n      this.getHorizontalScrollbarHeight() > 0\r\n    )\r\n\r\n    if (this.pendingAutoscroll) {\r\n      this.derivedDimensionsCache = {}\r\n      const {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollHorizontally(screenRange, options)\r\n\r\n      if (!wasHorizontalScrollbarVisible && isHorizontalScrollbarVisible) {\r\n        this.autoscrollVertically(screenRange, options)\r\n      }\r\n      this.pendingAutoscroll = null\r\n    }\r\n\r\n    this.linesToMeasure.clear()\r\n    this.measuredContent = true\r\n\r\n    return gutterDimensionsChanged || wasHorizontalScrollbarVisible !== isHorizontalScrollbarVisible\r\n  }\r", "name": "autoscrollVertically", "func_location": "TextEditorComponent.measureContentDuringUpdateSync", "args": ["screenRange", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 415, "func_start_line": 389}}, {"func_info": {"comment": [], "name": "TextEditorComponent.measureCharacterDimensions", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2173, "start_line": 2158}, "call_info": {"func_end_line": 2156, "comment": [" This method exists because it existed in the previous implementation and some", " package tests relied on it"], "code": "  measureDimensions () {\r\n    this.measureCharacterDimensions()\r\n    this.measureGutterDimensions()\r\n    this.measureClientContainerHeight()\r\n    this.measureClientContainerWidth()\r\n    this.measureScrollbarDimensions()\r\n    this.hasInitialMeasurements = true\r\n  }\r", "name": "measureCharacterDimensions", "func_location": "TextEditorComponent.measureDimensions", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2150, "func_start_line": 2149}}, {"func_info": {"comment": [], "name": "TextEditorComponent.measureGutterDimensions", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2199, "start_line": 2175}, "call_info": {"func_end_line": 2156, "comment": [" This method exists because it existed in the previous implementation and some", " package tests relied on it"], "code": "  measureDimensions () {\r\n    this.measureCharacterDimensions()\r\n    this.measureGutterDimensions()\r\n    this.measureClientContainerHeight()\r\n    this.measureClientContainerWidth()\r\n    this.measureScrollbarDimensions()\r\n    this.hasInitialMeasurements = true\r\n  }\r", "name": "measureGutterDimensions", "func_location": "TextEditorComponent.measureDimensions", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2151, "func_start_line": 2149}}, {"func_info": {"comment": [], "name": "TextEditorComponent.measureClientContainerHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2209, "start_line": 2201}, "call_info": {"func_end_line": 2156, "comment": [" This method exists because it existed in the previous implementation and some", " package tests relied on it"], "code": "  measureDimensions () {\r\n    this.measureCharacterDimensions()\r\n    this.measureGutterDimensions()\r\n    this.measureClientContainerHeight()\r\n    this.measureClientContainerWidth()\r\n    this.measureScrollbarDimensions()\r\n    this.hasInitialMeasurements = true\r\n  }\r", "name": "measureClientContainerHeight", "func_location": "TextEditorComponent.measureDimensions", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2152, "func_start_line": 2149}}, {"func_info": {"comment": [], "name": "TextEditorComponent.measureClientContainerWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2219, "start_line": 2211}, "call_info": {"func_end_line": 2156, "comment": [" This method exists because it existed in the previous implementation and some", " package tests relied on it"], "code": "  measureDimensions () {\r\n    this.measureCharacterDimensions()\r\n    this.measureGutterDimensions()\r\n    this.measureClientContainerHeight()\r\n    this.measureClientContainerWidth()\r\n    this.measureScrollbarDimensions()\r\n    this.hasInitialMeasurements = true\r\n  }\r", "name": "measureClientContainerWidth", "func_location": "TextEditorComponent.measureDimensions", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2153, "func_start_line": 2149}}, {"func_info": {"comment": [], "name": "TextEditorComponent.measureScrollbarDimensions", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2229, "start_line": 2221}, "call_info": {"func_end_line": 2156, "comment": [" This method exists because it existed in the previous implementation and some", " package tests relied on it"], "code": "  measureDimensions () {\r\n    this.measureCharacterDimensions()\r\n    this.measureGutterDimensions()\r\n    this.measureClientContainerHeight()\r\n    this.measureClientContainerWidth()\r\n    this.measureScrollbarDimensions()\r\n    this.hasInitialMeasurements = true\r\n  }\r", "name": "measureScrollbarDimensions", "func_location": "TextEditorComponent.measureDimensions", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2154, "func_start_line": 2149}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 108, "code": "  measureDimensions () {\r\n    this.getComponent().measureDimensions()\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.measureDimensions", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 107, "func_start_line": 106}}, {"func_info": {"comment": [], "name": "clientRectForRange", "params": ["textNode", "startIndex", "endIndex"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4340, "start_line": 4335}, "call_info": {"func_end_line": 2344, "code": "  measureHorizontalPositionsOnLine (lineNode, textNodes, columnsToMeasure, positions) {\r\n    let lineNodeClientLeft = -1\r\n    let textNodeStartColumn = 0\r\n    let textNodesIndex = 0\r\n    let lastTextNodeRight = null\r\n\r\n    columnLoop: // eslint-disable-line no-labels\r\n    for (let columnsIndex = 0; columnsIndex < columnsToMeasure.length; columnsIndex++) {\r\n      const nextColumnToMeasure = columnsToMeasure[columnsIndex]\r\n      while (textNodesIndex < textNodes.length) {\r\n        if (nextColumnToMeasure === 0) {\r\n          positions.set(0, 0)\r\n          continue columnLoop // eslint-disable-line no-labels\r\n        }\r\n\r\n        if (positions.has(nextColumnToMeasure)) continue columnLoop // eslint-disable-line no-labels\r\n        const textNode = textNodes[textNodesIndex]\r\n        const textNodeEndColumn = textNodeStartColumn + textNode.textContent.length\r\n\r\n        if (nextColumnToMeasure < textNodeEndColumn) {\r\n          let clientPixelPosition\r\n          if (nextColumnToMeasure === textNodeStartColumn) {\r\n            clientPixelPosition = clientRectForRange(textNode, 0, 1).left\r\n          } else {\r\n            clientPixelPosition = clientRectForRange(textNode, 0, nextColumnToMeasure - textNodeStartColumn).right\r\n          }\r\n\r\n          if (lineNodeClientLeft === -1) {\r\n            lineNodeClientLeft = lineNode.getBoundingClientRect().left\r\n          }\r\n\r\n          positions.set(nextColumnToMeasure, Math.round(clientPixelPosition - lineNodeClientLeft))\r\n          continue columnLoop // eslint-disable-line no-labels\r\n        } else {\r\n          textNodesIndex++\r\n          textNodeStartColumn = textNodeEndColumn\r\n        }\r\n      }\r\n\r\n      if (lastTextNodeRight == null) {\r\n        const lastTextNode = textNodes[textNodes.length - 1]\r\n        lastTextNodeRight = clientRectForRange(lastTextNode, 0, lastTextNode.textContent.length).right\r\n      }\r\n\r\n      if (lineNodeClientLeft === -1) {\r\n        lineNodeClientLeft = lineNode.getBoundingClientRect().left\r\n      }\r\n\r\n      positions.set(nextColumnToMeasure, Math.round(lastTextNodeRight - lineNodeClientLeft))\r\n    }\r\n  }\r", "name": "clientRectForRange", "func_location": "TextEditorComponent.measureHorizontalPositionsOnLine", "args": ["textNode", {"type": "number"}, {"type": "number"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2316, "func_start_line": 2294}}, {"func_info": {"comment": [], "name": "clientRectForRange", "params": ["textNode", "startIndex", "endIndex"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4340, "start_line": 4335}, "call_info": {"func_end_line": 2344, "code": "  measureHorizontalPositionsOnLine (lineNode, textNodes, columnsToMeasure, positions) {\r\n    let lineNodeClientLeft = -1\r\n    let textNodeStartColumn = 0\r\n    let textNodesIndex = 0\r\n    let lastTextNodeRight = null\r\n\r\n    columnLoop: // eslint-disable-line no-labels\r\n    for (let columnsIndex = 0; columnsIndex < columnsToMeasure.length; columnsIndex++) {\r\n      const nextColumnToMeasure = columnsToMeasure[columnsIndex]\r\n      while (textNodesIndex < textNodes.length) {\r\n        if (nextColumnToMeasure === 0) {\r\n          positions.set(0, 0)\r\n          continue columnLoop // eslint-disable-line no-labels\r\n        }\r\n\r\n        if (positions.has(nextColumnToMeasure)) continue columnLoop // eslint-disable-line no-labels\r\n        const textNode = textNodes[textNodesIndex]\r\n        const textNodeEndColumn = textNodeStartColumn + textNode.textContent.length\r\n\r\n        if (nextColumnToMeasure < textNodeEndColumn) {\r\n          let clientPixelPosition\r\n          if (nextColumnToMeasure === textNodeStartColumn) {\r\n            clientPixelPosition = clientRectForRange(textNode, 0, 1).left\r\n          } else {\r\n            clientPixelPosition = clientRectForRange(textNode, 0, nextColumnToMeasure - textNodeStartColumn).right\r\n          }\r\n\r\n          if (lineNodeClientLeft === -1) {\r\n            lineNodeClientLeft = lineNode.getBoundingClientRect().left\r\n          }\r\n\r\n          positions.set(nextColumnToMeasure, Math.round(clientPixelPosition - lineNodeClientLeft))\r\n          continue columnLoop // eslint-disable-line no-labels\r\n        } else {\r\n          textNodesIndex++\r\n          textNodeStartColumn = textNodeEndColumn\r\n        }\r\n      }\r\n\r\n      if (lastTextNodeRight == null) {\r\n        const lastTextNode = textNodes[textNodes.length - 1]\r\n        lastTextNodeRight = clientRectForRange(lastTextNode, 0, lastTextNode.textContent.length).right\r\n      }\r\n\r\n      if (lineNodeClientLeft === -1) {\r\n        lineNodeClientLeft = lineNode.getBoundingClientRect().left\r\n      }\r\n\r\n      positions.set(nextColumnToMeasure, Math.round(lastTextNodeRight - lineNodeClientLeft))\r\n    }\r\n  }\r", "name": "clientRectForRange", "func_location": "TextEditorComponent.measureHorizontalPositionsOnLine", "args": ["textNode", {"type": "number"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2318, "func_start_line": 2294}}, {"func_info": {"comment": [], "name": "clientRectForRange", "params": ["textNode", "startIndex", "endIndex"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4340, "start_line": 4335}, "call_info": {"func_end_line": 2344, "code": "  measureHorizontalPositionsOnLine (lineNode, textNodes, columnsToMeasure, positions) {\r\n    let lineNodeClientLeft = -1\r\n    let textNodeStartColumn = 0\r\n    let textNodesIndex = 0\r\n    let lastTextNodeRight = null\r\n\r\n    columnLoop: // eslint-disable-line no-labels\r\n    for (let columnsIndex = 0; columnsIndex < columnsToMeasure.length; columnsIndex++) {\r\n      const nextColumnToMeasure = columnsToMeasure[columnsIndex]\r\n      while (textNodesIndex < textNodes.length) {\r\n        if (nextColumnToMeasure === 0) {\r\n          positions.set(0, 0)\r\n          continue columnLoop // eslint-disable-line no-labels\r\n        }\r\n\r\n        if (positions.has(nextColumnToMeasure)) continue columnLoop // eslint-disable-line no-labels\r\n        const textNode = textNodes[textNodesIndex]\r\n        const textNodeEndColumn = textNodeStartColumn + textNode.textContent.length\r\n\r\n        if (nextColumnToMeasure < textNodeEndColumn) {\r\n          let clientPixelPosition\r\n          if (nextColumnToMeasure === textNodeStartColumn) {\r\n            clientPixelPosition = clientRectForRange(textNode, 0, 1).left\r\n          } else {\r\n            clientPixelPosition = clientRectForRange(textNode, 0, nextColumnToMeasure - textNodeStartColumn).right\r\n          }\r\n\r\n          if (lineNodeClientLeft === -1) {\r\n            lineNodeClientLeft = lineNode.getBoundingClientRect().left\r\n          }\r\n\r\n          positions.set(nextColumnToMeasure, Math.round(clientPixelPosition - lineNodeClientLeft))\r\n          continue columnLoop // eslint-disable-line no-labels\r\n        } else {\r\n          textNodesIndex++\r\n          textNodeStartColumn = textNodeEndColumn\r\n        }\r\n      }\r\n\r\n      if (lastTextNodeRight == null) {\r\n        const lastTextNode = textNodes[textNodes.length - 1]\r\n        lastTextNodeRight = clientRectForRange(lastTextNode, 0, lastTextNode.textContent.length).right\r\n      }\r\n\r\n      if (lineNodeClientLeft === -1) {\r\n        lineNodeClientLeft = lineNode.getBoundingClientRect().left\r\n      }\r\n\r\n      positions.set(nextColumnToMeasure, Math.round(lastTextNodeRight - lineNodeClientLeft))\r\n    }\r\n  }\r", "name": "clientRectForRange", "func_location": "TextEditorComponent.measureHorizontalPositionsOnLine", "args": ["lastTextNode", {"type": "number"}, "lastTextNode.textContent.length"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2335, "func_start_line": 2294}}, {"func_info": {"comment": [], "name": "cloneMenuItem", "params": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js", "end_line": 96, "start_line": 75}, "call_info": {"func_end_line": 32, "code": "function merge (menu, item, itemSpecificity = Infinity) {\r\n  item = cloneMenuItem(item)\r\n  ItemSpecificities.set(item, itemSpecificity)\r\n  const matchingItemIndex = findMatchingItemIndex(menu, item)\r\n\r\n  if (matchingItemIndex === -1) {\r\n    addItemToMenu(item, menu)\r\n    return\r\n  }\r\n\r\n  const matchingItem = menu[matchingItemIndex]\r\n  if (item.submenu != null) {\r\n    for (let submenuItem of item.submenu) {\r\n      merge(matchingItem.submenu, submenuItem, itemSpecificity)\r\n    }\r\n  } else if (itemSpecificity && itemSpecificity >= ItemSpecificities.get(matchingItem)) {\r\n    menu[matchingItemIndex] = item\r\n  }\r\n}\r", "name": "cloneMenuItem", "func_location": "merge", "args": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js", "line": 15, "func_start_line": 14}}, {"func_info": {"comment": [], "name": "findMatchingItemIndex", "params": ["menu", ["type", "label", "submenu"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js", "end_line": 66, "start_line": 52}, "call_info": {"func_end_line": 32, "code": "function merge (menu, item, itemSpecificity = Infinity) {\r\n  item = cloneMenuItem(item)\r\n  ItemSpecificities.set(item, itemSpecificity)\r\n  const matchingItemIndex = findMatchingItemIndex(menu, item)\r\n\r\n  if (matchingItemIndex === -1) {\r\n    addItemToMenu(item, menu)\r\n    return\r\n  }\r\n\r\n  const matchingItem = menu[matchingItemIndex]\r\n  if (item.submenu != null) {\r\n    for (let submenuItem of item.submenu) {\r\n      merge(matchingItem.submenu, submenuItem, itemSpecificity)\r\n    }\r\n  } else if (itemSpecificity && itemSpecificity >= ItemSpecificities.get(matchingItem)) {\r\n    menu[matchingItemIndex] = item\r\n  }\r\n}\r", "name": "findMatchingItemIndex", "func_location": "merge", "args": ["menu", "item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js", "line": 17, "func_start_line": 14}}, {"func_info": {"comment": [" Add an item to a menu, ensuring separators are not duplicated."], "name": "addItemToMenu", "params": ["item", "menu"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js", "end_line": 12, "start_line": 6}, "call_info": {"func_end_line": 32, "code": "function merge (menu, item, itemSpecificity = Infinity) {\r\n  item = cloneMenuItem(item)\r\n  ItemSpecificities.set(item, itemSpecificity)\r\n  const matchingItemIndex = findMatchingItemIndex(menu, item)\r\n\r\n  if (matchingItemIndex === -1) {\r\n    addItemToMenu(item, menu)\r\n    return\r\n  }\r\n\r\n  const matchingItem = menu[matchingItemIndex]\r\n  if (item.submenu != null) {\r\n    for (let submenuItem of item.submenu) {\r\n      merge(matchingItem.submenu, submenuItem, itemSpecificity)\r\n    }\r\n  } else if (itemSpecificity && itemSpecificity >= ItemSpecificities.get(matchingItem)) {\r\n    menu[matchingItemIndex] = item\r\n  }\r\n}\r", "name": "addItemToMenu", "func_location": "merge", "args": ["item", "menu"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js", "line": 20, "func_start_line": 14}}, {"func_info": {"comment": [], "name": "merge", "params": ["menu", "item", "itemSpecificity"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js", "end_line": 32, "start_line": 14}, "call_info": {"func_end_line": 32, "code": "function merge (menu, item, itemSpecificity = Infinity) {\r\n  item = cloneMenuItem(item)\r\n  ItemSpecificities.set(item, itemSpecificity)\r\n  const matchingItemIndex = findMatchingItemIndex(menu, item)\r\n\r\n  if (matchingItemIndex === -1) {\r\n    addItemToMenu(item, menu)\r\n    return\r\n  }\r\n\r\n  const matchingItem = menu[matchingItemIndex]\r\n  if (item.submenu != null) {\r\n    for (let submenuItem of item.submenu) {\r\n      merge(matchingItem.submenu, submenuItem, itemSpecificity)\r\n    }\r\n  } else if (itemSpecificity && itemSpecificity >= ItemSpecificities.get(matchingItem)) {\r\n    menu[matchingItemIndex] = item\r\n  }\r\n}\r", "name": "merge", "func_location": "merge", "args": ["matchingItem.submenu", "submenuItem", "itemSpecificity"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js", "line": 27, "func_start_line": 14}}, {"func_info": {"comment": [], "name": "attemptToMergeAGroup", "params": ["groups"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js", "end_line": 91, "start_line": 71}, "call_info": {"func_end_line": 101, "comment": [" Merge groups based on before/after positions", " Mutates both the array of groups, and the individual group arrays."], "code": "function mergeGroups (groups) {\r\n  let mergedAGroup = true\r\n  while (mergedAGroup) {\r\n    mergedAGroup = attemptToMergeAGroup(groups)\r\n  }\r\n  return groups\r\n}\r", "name": "attemptToMergeAGroup", "func_location": "mergeGroups", "args": ["groups"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js", "line": 98, "func_start_line": 95}}, {"func_info": {"comment": [], "name": "mergeTable", "params": ["table", "defaultTable", "mergeIndices"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js", "end_line": 174, "start_line": 154}, "call_info": {"func_end_line": 174, "code": "function mergeTable (table, defaultTable, mergeIndices = true) {\r\n  if (mergeIndices && defaultTable.indices) {\r\n    if (!table.indices) table.indices = {}\r\n    for (let key in defaultTable.indices) {\r\n      if (!table.indices[key]) table.indices[key] = {}\r\n      mergeTable(table.indices[key], defaultTable.indices[key])\r\n    }\r\n  }\r\n\r\n  if (defaultTable.parents) {\r\n    if (!table.parents) table.parents = {}\r\n    for (let key in defaultTable.parents) {\r\n      if (!table.parents[key]) table.parents[key] = {}\r\n      mergeTable(table.parents[key], defaultTable.parents[key])\r\n    }\r\n  }\r\n\r\n  if (defaultTable.result != null && table.result == null) {\r\n    table.result = defaultTable.result\r\n  }\r\n}\r", "name": "mergeTable", "func_location": "mergeTable", "args": ["table.indices.key", "defaultTable.indices.key"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js", "line": 159, "func_start_line": 154}}, {"func_info": {"comment": [], "name": "mergeTable", "params": ["table", "defaultTable", "mergeIndices"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js", "end_line": 174, "start_line": 154}, "call_info": {"func_end_line": 174, "code": "function mergeTable (table, defaultTable, mergeIndices = true) {\r\n  if (mergeIndices && defaultTable.indices) {\r\n    if (!table.indices) table.indices = {}\r\n    for (let key in defaultTable.indices) {\r\n      if (!table.indices[key]) table.indices[key] = {}\r\n      mergeTable(table.indices[key], defaultTable.indices[key])\r\n    }\r\n  }\r\n\r\n  if (defaultTable.parents) {\r\n    if (!table.parents) table.parents = {}\r\n    for (let key in defaultTable.parents) {\r\n      if (!table.parents[key]) table.parents[key] = {}\r\n      mergeTable(table.parents[key], defaultTable.parents[key])\r\n    }\r\n  }\r\n\r\n  if (defaultTable.result != null && table.result == null) {\r\n    table.result = defaultTable.result\r\n  }\r\n}\r", "name": "mergeTable", "func_location": "mergeTable", "args": ["table.parents.key", "defaultTable.parents.key"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js", "line": 167, "func_start_line": 154}}, {"func_info": {"comment": [], "name": "WorkspaceElement.nearestVisiblePaneInDirection", "params": ["direction", "pane"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 300, "start_line": 268}, "call_info": {"func_end_line": 266, "code": "  moveActiveItemToNearestPaneInDirection (direction, params) {\r\n    const activePane = this.model.getActivePane()\r\n    const nearestPaneView = this.nearestVisiblePaneInDirection(direction, activePane)\r\n    if (nearestPaneView == null) { return }\r\n    if (params && params.keepOriginal) {\r\n      activePane.getContainer().copyActiveItemToPane(nearestPaneView.getModel())\r\n    } else {\r\n      activePane.getContainer().moveActiveItemToPane(nearestPaneView.getModel())\r\n    }\r\n    nearestPaneView.focus()\r\n  }\r", "name": "nearestVisiblePaneInDirection", "func_location": "WorkspaceElement.moveActiveItemToNearestPaneInDirection", "args": ["direction", "activePane"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 258, "func_start_line": 256}}, {"func_info": {"comment": [], "name": "WorkspaceElement.moveActiveItemToNearestPaneInDirection", "params": ["direction", "params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 266, "start_line": 256}, "call_info": {"func_end_line": 242, "code": "  moveActiveItemToPaneAbove (params) {\r\n    this.moveActiveItemToNearestPaneInDirection('above', params)\r\n  }\r", "name": "moveActiveItemToNearestPaneInDirection", "func_location": "WorkspaceElement.moveActiveItemToPaneAbove", "args": [{"type": "string"}, "params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 241, "func_start_line": 240}}, {"func_info": {"comment": [], "name": "WorkspaceElement.moveActiveItemToNearestPaneInDirection", "params": ["direction", "params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 266, "start_line": 256}, "call_info": {"func_end_line": 246, "code": "  moveActiveItemToPaneBelow (params) {\r\n    this.moveActiveItemToNearestPaneInDirection('below', params)\r\n  }\r", "name": "moveActiveItemToNearestPaneInDirection", "func_location": "WorkspaceElement.moveActiveItemToPaneBelow", "args": [{"type": "string"}, "params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 245, "func_start_line": 244}}, {"func_info": {"comment": [], "name": "WorkspaceElement.moveActiveItemToNearestPaneInDirection", "params": ["direction", "params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 266, "start_line": 256}, "call_info": {"func_end_line": 250, "code": "  moveActiveItemToPaneOnLeft (params) {\r\n    this.moveActiveItemToNearestPaneInDirection('left', params)\r\n  }\r", "name": "moveActiveItemToNearestPaneInDirection", "func_location": "WorkspaceElement.moveActiveItemToPaneOnLeft", "args": [{"type": "string"}, "params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 249, "func_start_line": 248}}, {"func_info": {"comment": [], "name": "WorkspaceElement.moveActiveItemToNearestPaneInDirection", "params": ["direction", "params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 266, "start_line": 256}, "call_info": {"func_end_line": 254, "code": "  moveActiveItemToPaneOnRight (params) {\r\n    this.moveActiveItemToNearestPaneInDirection('right', params)\r\n  }\r", "name": "moveActiveItemToNearestPaneInDirection", "func_location": "WorkspaceElement.moveActiveItemToPaneOnRight", "args": [{"type": "string"}, "params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 253, "func_start_line": 252}}, {"func_info": {"comment": [" Add item (or move item) to the end of the itemStack"], "name": "Pane.addItemToStack", "params": ["newItem"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 464, "start_line": 459}, "call_info": {"func_end_line": 510, "comment": [" Moves the active item to the end of the itemStack once the ctrl key is lifted"], "code": "  moveActiveItemToTopOfStack () {\r\n    delete this.itemStackIndex\r\n    this.addItemToStack(this.activeItem)\r\n    this.emitter.emit('done-choosing-mru-item')\r\n  }\r", "name": "addItemToStack", "func_location": "Pane.moveActiveItemToTopOfStack", "args": [".activeItem"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 508, "func_start_line": 506}}, {"func_info": {"comment": [" Public: Returns the screen position of the cursor as a {Point}."], "name": "Cursor.getScreenPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 75, "start_line": 73}, "call_info": {"func_end_line": 273, "comment": [" Public: Moves the cursor down one screen row.", "", " * `rowCount` (optional) {Number} number of rows to move (default: 1)", " * `options` (optional) {Object} with the following keys:", "   * `moveToEndOfSelection` if true, move to the left of the selection if a", "     selection exists."], "code": "  moveDown (rowCount = 1, {moveToEndOfSelection} = {}) {\r\n    let row, column\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      ({row, column} = range.end)\r\n    } else {\r\n      ({row, column} = this.getScreenPosition())\r\n    }\r\n\r\n    if (this.goalColumn != null) column = this.goalColumn\r\n    this.setScreenPosition({row: row + rowCount, column}, {skipSoftWrapIndentation: true})\r\n    this.goalColumn = column\r\n  }\r", "name": "getScreenPosition", "func_location": "Cursor.moveDown", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 267, "func_start_line": 261}}, {"func_info": {"comment": ["\r\n  Section: Managing Cursor Position\r\n  ", " Public: Moves a cursor to a given screen position.", "", " * `screenPosition` {Array} of two numbers: the screen row, and the screen column.", " * `options` (optional) {Object} with the following keys:", "   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever", "     the cursor moves to."], "name": "Cursor.setScreenPosition", "params": ["screenPosition", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 70, "start_line": 66}, "call_info": {"func_end_line": 273, "comment": [" Public: Moves the cursor down one screen row.", "", " * `rowCount` (optional) {Number} number of rows to move (default: 1)", " * `options` (optional) {Object} with the following keys:", "   * `moveToEndOfSelection` if true, move to the left of the selection if a", "     selection exists."], "code": "  moveDown (rowCount = 1, {moveToEndOfSelection} = {}) {\r\n    let row, column\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      ({row, column} = range.end)\r\n    } else {\r\n      ({row, column} = this.getScreenPosition())\r\n    }\r\n\r\n    if (this.goalColumn != null) column = this.goalColumn\r\n    this.setScreenPosition({row: row + rowCount, column}, {skipSoftWrapIndentation: true})\r\n    this.goalColumn = column\r\n  }\r", "name": "setScreenPosition", "func_location": "Cursor.moveDown", "args": [null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 271, "func_start_line": 261}}, {"func_info": {"comment": [" Public: Get the index of the active item.", "", " Returns a {Number}."], "name": "Pane.getActiveItemIndex", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 555, "start_line": 553}, "call_info": {"func_end_line": 548, "comment": [" Public: Move the active tab to the left"], "code": "  moveItemLeft () {\r\n    const index = this.getActiveItemIndex()\r\n    const leftItemIndex = index - 1\r\n    if (leftItemIndex >= 0) return this.moveItem(this.getActiveItem(), leftItemIndex)\r\n  }\r", "name": "getActiveItemIndex", "func_location": "Pane.moveItemLeft", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 545, "func_start_line": 544}}, {"func_info": {"comment": [" Public: Move the given item to the given index.", "", " * `item` The item to move.", " * `index` {Number} indicating the index to which to move the item."], "name": "Pane.moveItem", "params": ["item", "newIndex"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 725, "start_line": 720}, "call_info": {"func_end_line": 548, "comment": [" Public: Move the active tab to the left"], "code": "  moveItemLeft () {\r\n    const index = this.getActiveItemIndex()\r\n    const leftItemIndex = index - 1\r\n    if (leftItemIndex >= 0) return this.moveItem(this.getActiveItem(), leftItemIndex)\r\n  }\r", "name": "moveItem", "func_location": "Pane.moveItemLeft", "args": [null, "leftItemIndex"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 547, "func_start_line": 544}}, {"func_info": {"comment": [" Public: Get the active pane item in this pane.", "", " Returns a pane item."], "name": "Pane.getActiveItem", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 432, "start_line": 432}, "call_info": {"func_end_line": 548, "comment": [" Public: Move the active tab to the left"], "code": "  moveItemLeft () {\r\n    const index = this.getActiveItemIndex()\r\n    const leftItemIndex = index - 1\r\n    if (leftItemIndex >= 0) return this.moveItem(this.getActiveItem(), leftItemIndex)\r\n  }\r", "name": "getActiveItem", "func_location": "Pane.moveItemLeft", "args": [null, "leftItemIndex"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 547, "func_start_line": 544}}, {"func_info": {"comment": [" Public: Get the index of the active item.", "", " Returns a {Number}."], "name": "Pane.getActiveItemIndex", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 555, "start_line": 553}, "call_info": {"func_end_line": 541, "comment": [" Public: Move the active tab to the right."], "code": "  moveItemRight () {\r\n    const index = this.getActiveItemIndex()\r\n    const rightItemIndex = index + 1\r\n    if (rightItemIndex <= this.items.length - 1) this.moveItem(this.getActiveItem(), rightItemIndex)\r\n  }\r", "name": "getActiveItemIndex", "func_location": "Pane.moveItemRight", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 538, "func_start_line": 537}}, {"func_info": {"comment": [" Public: Move the given item to the given index.", "", " * `item` The item to move.", " * `index` {Number} indicating the index to which to move the item."], "name": "Pane.moveItem", "params": ["item", "newIndex"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 725, "start_line": 720}, "call_info": {"func_end_line": 541, "comment": [" Public: Move the active tab to the right."], "code": "  moveItemRight () {\r\n    const index = this.getActiveItemIndex()\r\n    const rightItemIndex = index + 1\r\n    if (rightItemIndex <= this.items.length - 1) this.moveItem(this.getActiveItem(), rightItemIndex)\r\n  }\r", "name": "moveItem", "func_location": "Pane.moveItemRight", "args": [null, "rightItemIndex"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 540, "func_start_line": 537}}, {"func_info": {"comment": [" Public: Get the active pane item in this pane.", "", " Returns a pane item."], "name": "Pane.getActiveItem", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 432, "start_line": 432}, "call_info": {"func_end_line": 541, "comment": [" Public: Move the active tab to the right."], "code": "  moveItemRight () {\r\n    const index = this.getActiveItemIndex()\r\n    const rightItemIndex = index + 1\r\n    if (rightItemIndex <= this.items.length - 1) this.moveItem(this.getActiveItem(), rightItemIndex)\r\n  }\r", "name": "getActiveItem", "func_location": "Pane.moveItemRight", "args": [null, "rightItemIndex"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 540, "func_start_line": 537}}, {"func_info": {"comment": [], "name": "Pane.removeItem", "params": ["item", "moved"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 705, "start_line": 684}, "call_info": {"func_end_line": 736, "comment": [" Public: Move the given item to the given index on another pane.", "", " * `item` The item to move.", " * `pane` {Pane} to which to move the item.", " * `index` {Number} indicating the index to which to move the item in the", "   given pane."], "code": "  moveItemToPane (item, pane, index) {\r\n    this.removeItem(item, true)\r\n    return pane.addItem(item, {index, moved: true})\r\n  }\r", "name": "removeItem", "func_location": "Pane.moveItemToPane", "args": ["item", {"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 734, "func_start_line": 733}}, {"func_info": {"comment": ["\r\n  Section: Managing Cursor Position\r\n  ", " Public: Moves a cursor to a given screen position.", "", " * `screenPosition` {Array} of two numbers: the screen row, and the screen column.", " * `options` (optional) {Object} with the following keys:", "   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever", "     the cursor moves to."], "name": "Cursor.setScreenPosition", "params": ["screenPosition", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 70, "start_line": 66}, "call_info": {"func_end_line": 297, "comment": [" Public: Moves the cursor left one screen column.", "", " * `columnCount` (optional) {Number} number of columns to move (default: 1)", " * `options` (optional) {Object} with the following keys:", "   * `moveToEndOfSelection` if true, move to the left of the selection if a", "     selection exists."], "code": "  moveLeft (columnCount = 1, {moveToEndOfSelection} = {}) {\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      this.setScreenPosition(range.start)\r\n    } else {\r\n      let {row, column} = this.getScreenPosition()\r\n\r\n      while (columnCount > column && row > 0) {\r\n        columnCount -= column\r\n        column = this.editor.lineLengthForScreenRow(--row)\r\n        columnCount-- // subtract 1 for the row move\r\n      }\r\n\r\n      column = column - columnCount\r\n      this.setScreenPosition({row, column}, {clipDirection: 'backward'})\r\n    }\r\n  }\r", "name": "setScreenPosition", "func_location": "Cursor.moveLeft", "args": ["range.start"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 284, "func_start_line": 281}}, {"func_info": {"comment": [" Public: Returns the screen position of the cursor as a {Point}."], "name": "Cursor.getScreenPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 75, "start_line": 73}, "call_info": {"func_end_line": 297, "comment": [" Public: Moves the cursor left one screen column.", "", " * `columnCount` (optional) {Number} number of columns to move (default: 1)", " * `options` (optional) {Object} with the following keys:", "   * `moveToEndOfSelection` if true, move to the left of the selection if a", "     selection exists."], "code": "  moveLeft (columnCount = 1, {moveToEndOfSelection} = {}) {\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      this.setScreenPosition(range.start)\r\n    } else {\r\n      let {row, column} = this.getScreenPosition()\r\n\r\n      while (columnCount > column && row > 0) {\r\n        columnCount -= column\r\n        column = this.editor.lineLengthForScreenRow(--row)\r\n        columnCount-- // subtract 1 for the row move\r\n      }\r\n\r\n      column = column - columnCount\r\n      this.setScreenPosition({row, column}, {clipDirection: 'backward'})\r\n    }\r\n  }\r", "name": "getScreenPosition", "func_location": "Cursor.moveLeft", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 286, "func_start_line": 281}}, {"func_info": {"comment": ["\r\n  Section: Managing Cursor Position\r\n  ", " Public: Moves a cursor to a given screen position.", "", " * `screenPosition` {Array} of two numbers: the screen row, and the screen column.", " * `options` (optional) {Object} with the following keys:", "   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever", "     the cursor moves to."], "name": "Cursor.setScreenPosition", "params": ["screenPosition", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 70, "start_line": 66}, "call_info": {"func_end_line": 297, "comment": [" Public: Moves the cursor left one screen column.", "", " * `columnCount` (optional) {Number} number of columns to move (default: 1)", " * `options` (optional) {Object} with the following keys:", "   * `moveToEndOfSelection` if true, move to the left of the selection if a", "     selection exists."], "code": "  moveLeft (columnCount = 1, {moveToEndOfSelection} = {}) {\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      this.setScreenPosition(range.start)\r\n    } else {\r\n      let {row, column} = this.getScreenPosition()\r\n\r\n      while (columnCount > column && row > 0) {\r\n        columnCount -= column\r\n        column = this.editor.lineLengthForScreenRow(--row)\r\n        columnCount-- // subtract 1 for the row move\r\n      }\r\n\r\n      column = column - columnCount\r\n      this.setScreenPosition({row, column}, {clipDirection: 'backward'})\r\n    }\r\n  }\r", "name": "setScreenPosition", "func_location": "Cursor.moveLeft", "args": [null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 295, "func_start_line": 281}}, {"func_info": {"comment": ["\r\n  Section: Managing Cursor Position\r\n  ", " Public: Moves a cursor to a given screen position.", "", " * `screenPosition` {Array} of two numbers: the screen row, and the screen column.", " * `options` (optional) {Object} with the following keys:", "   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever", "     the cursor moves to."], "name": "Cursor.setScreenPosition", "params": ["screenPosition", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 70, "start_line": 66}, "call_info": {"func_end_line": 327, "comment": [" Public: Moves the cursor right one screen column.", "", " * `columnCount` (optional) {Number} number of columns to move (default: 1)", " * `options` (optional) {Object} with the following keys:", "   * `moveToEndOfSelection` if true, move to the right of the selection if a", "     selection exists."], "code": "  moveRight (columnCount = 1, {moveToEndOfSelection} = {}) {\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      this.setScreenPosition(range.end)\r\n    } else {\r\n      let {row, column} = this.getScreenPosition()\r\n      const maxLines = this.editor.getScreenLineCount()\r\n      let rowLength = this.editor.lineLengthForScreenRow(row)\r\n      let columnsRemainingInLine = rowLength - column\r\n\r\n      while (columnCount > columnsRemainingInLine && row < maxLines - 1) {\r\n        columnCount -= columnsRemainingInLine\r\n        columnCount-- // subtract 1 for the row move\r\n\r\n        column = 0\r\n        rowLength = this.editor.lineLengthForScreenRow(++row)\r\n        columnsRemainingInLine = rowLength\r\n      }\r\n\r\n      column = column + columnCount\r\n      this.setScreenPosition({row, column}, {clipDirection: 'forward'})\r\n    }\r\n  }\r", "name": "setScreenPosition", "func_location": "Cursor.moveRight", "args": ["range.end"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 308, "func_start_line": 305}}, {"func_info": {"comment": [" Public: Returns the screen position of the cursor as a {Point}."], "name": "Cursor.getScreenPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 75, "start_line": 73}, "call_info": {"func_end_line": 327, "comment": [" Public: Moves the cursor right one screen column.", "", " * `columnCount` (optional) {Number} number of columns to move (default: 1)", " * `options` (optional) {Object} with the following keys:", "   * `moveToEndOfSelection` if true, move to the right of the selection if a", "     selection exists."], "code": "  moveRight (columnCount = 1, {moveToEndOfSelection} = {}) {\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      this.setScreenPosition(range.end)\r\n    } else {\r\n      let {row, column} = this.getScreenPosition()\r\n      const maxLines = this.editor.getScreenLineCount()\r\n      let rowLength = this.editor.lineLengthForScreenRow(row)\r\n      let columnsRemainingInLine = rowLength - column\r\n\r\n      while (columnCount > columnsRemainingInLine && row < maxLines - 1) {\r\n        columnCount -= columnsRemainingInLine\r\n        columnCount-- // subtract 1 for the row move\r\n\r\n        column = 0\r\n        rowLength = this.editor.lineLengthForScreenRow(++row)\r\n        columnsRemainingInLine = rowLength\r\n      }\r\n\r\n      column = column + columnCount\r\n      this.setScreenPosition({row, column}, {clipDirection: 'forward'})\r\n    }\r\n  }\r", "name": "getScreenPosition", "func_location": "Cursor.moveRight", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 310, "func_start_line": 305}}, {"func_info": {"comment": ["\r\n  Section: Managing Cursor Position\r\n  ", " Public: Moves a cursor to a given screen position.", "", " * `screenPosition` {Array} of two numbers: the screen row, and the screen column.", " * `options` (optional) {Object} with the following keys:", "   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever", "     the cursor moves to."], "name": "Cursor.setScreenPosition", "params": ["screenPosition", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 70, "start_line": 66}, "call_info": {"func_end_line": 327, "comment": [" Public: Moves the cursor right one screen column.", "", " * `columnCount` (optional) {Number} number of columns to move (default: 1)", " * `options` (optional) {Object} with the following keys:", "   * `moveToEndOfSelection` if true, move to the right of the selection if a", "     selection exists."], "code": "  moveRight (columnCount = 1, {moveToEndOfSelection} = {}) {\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      this.setScreenPosition(range.end)\r\n    } else {\r\n      let {row, column} = this.getScreenPosition()\r\n      const maxLines = this.editor.getScreenLineCount()\r\n      let rowLength = this.editor.lineLengthForScreenRow(row)\r\n      let columnsRemainingInLine = rowLength - column\r\n\r\n      while (columnCount > columnsRemainingInLine && row < maxLines - 1) {\r\n        columnCount -= columnsRemainingInLine\r\n        columnCount-- // subtract 1 for the row move\r\n\r\n        column = 0\r\n        rowLength = this.editor.lineLengthForScreenRow(++row)\r\n        columnsRemainingInLine = rowLength\r\n      }\r\n\r\n      column = column + columnCount\r\n      this.setScreenPosition({row, column}, {clipDirection: 'forward'})\r\n    }\r\n  }\r", "name": "setScreenPosition", "func_location": "Cursor.moveRight", "args": [null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 325, "func_start_line": 305}}, {"func_info": {"comment": [" Public: Moves a cursor to a given buffer position.", "", " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.", " * `options` (optional) {Object} with the following keys:", "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new", "     position. Defaults to `true` if this is the most recently added cursor,", "     `false` otherwise."], "name": "Cursor.setBufferPosition", "params": ["bufferPosition", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 88, "start_line": 84}, "call_info": {"func_end_line": 349, "comment": [" Public: Moves the cursor to the beginning of the buffer line."], "code": "  moveToBeginningOfLine () {\r\n    this.setBufferPosition([this.getBufferRow(), 0])\r\n  }\r", "name": "setBufferPosition", "func_location": "Cursor.moveToBeginningOfLine", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 348, "func_start_line": 347}}, {"func_info": {"comment": [" Public: Retrieves the cursor's current buffer row."], "name": "Cursor.getBufferRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 108, "start_line": 106}, "call_info": {"func_end_line": 349, "comment": [" Public: Moves the cursor to the beginning of the buffer line."], "code": "  moveToBeginningOfLine () {\r\n    this.setBufferPosition([this.getBufferRow(), 0])\r\n  }\r", "name": "getBufferRow", "func_location": "Cursor.moveToBeginningOfLine", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 348, "func_start_line": 347}}, {"func_info": {"comment": [], "name": "Cursor.getBeginningOfNextParagraphBufferPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 753, "start_line": 740}, "call_info": {"func_end_line": 445, "comment": [" Public: Moves the cursor to the beginning of the next paragraph"], "code": "  moveToBeginningOfNextParagraph () {\r\n    const position = this.getBeginningOfNextParagraphBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r", "name": "getBeginningOfNextParagraphBufferPosition", "func_location": "Cursor.moveToBeginningOfNextParagraph", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 443, "func_start_line": 442}}, {"func_info": {"comment": [" Public: Moves a cursor to a given buffer position.", "", " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.", " * `options` (optional) {Object} with the following keys:", "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new", "     position. Defaults to `true` if this is the most recently added cursor,", "     `false` otherwise."], "name": "Cursor.setBufferPosition", "params": ["bufferPosition", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 88, "start_line": 84}, "call_info": {"func_end_line": 445, "comment": [" Public: Moves the cursor to the beginning of the next paragraph"], "code": "  moveToBeginningOfNextParagraph () {\r\n    const position = this.getBeginningOfNextParagraphBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r", "name": "setBufferPosition", "func_location": "Cursor.moveToBeginningOfNextParagraph", "args": ["position"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 444, "func_start_line": 442}}, {"func_info": {"comment": [" Public: Retrieves the buffer position of where the next word starts.", "", " * `options` (optional) {Object}", "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"", "     (default: {::wordRegExp}).", "", " Returns a {Range}"], "name": "Cursor.getBeginningOfNextWordBufferPosition", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 599, "start_line": 587}, "call_info": {"func_end_line": 400, "comment": [" Public: Moves the cursor to the beginning of the next word."], "code": "  moveToBeginningOfNextWord () {\r\n    const position = this.getBeginningOfNextWordBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r", "name": "getBeginningOfNextWordBufferPosition", "func_location": "Cursor.moveToBeginningOfNextWord", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 398, "func_start_line": 397}}, {"func_info": {"comment": [" Public: Moves a cursor to a given buffer position.", "", " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.", " * `options` (optional) {Object} with the following keys:", "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new", "     position. Defaults to `true` if this is the most recently added cursor,", "     `false` otherwise."], "name": "Cursor.setBufferPosition", "params": ["bufferPosition", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 88, "start_line": 84}, "call_info": {"func_end_line": 400, "comment": [" Public: Moves the cursor to the beginning of the next word."], "code": "  moveToBeginningOfNextWord () {\r\n    const position = this.getBeginningOfNextWordBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r", "name": "setBufferPosition", "func_location": "Cursor.moveToBeginningOfNextWord", "args": ["position"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 399, "func_start_line": 397}}, {"func_info": {"comment": [], "name": "Cursor.getBeginningOfPreviousParagraphBufferPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 766, "start_line": 755}, "call_info": {"func_end_line": 451, "comment": [" Public: Moves the cursor to the beginning of the previous paragraph"], "code": "  moveToBeginningOfPreviousParagraph () {\r\n    const position = this.getBeginningOfPreviousParagraphBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r", "name": "getBeginningOfPreviousParagraphBufferPosition", "func_location": "Cursor.moveToBeginningOfPreviousParagraph", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 449, "func_start_line": 448}}, {"func_info": {"comment": [" Public: Moves a cursor to a given buffer position.", "", " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.", " * `options` (optional) {Object} with the following keys:", "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new", "     position. Defaults to `true` if this is the most recently added cursor,", "     `false` otherwise."], "name": "Cursor.setBufferPosition", "params": ["bufferPosition", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 88, "start_line": 84}, "call_info": {"func_end_line": 451, "comment": [" Public: Moves the cursor to the beginning of the previous paragraph"], "code": "  moveToBeginningOfPreviousParagraph () {\r\n    const position = this.getBeginningOfPreviousParagraphBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r", "name": "setBufferPosition", "func_location": "Cursor.moveToBeginningOfPreviousParagraph", "args": ["position"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 450, "func_start_line": 448}}, {"func_info": {"comment": ["\r\n  Section: Managing Cursor Position\r\n  ", " Public: Moves a cursor to a given screen position.", "", " * `screenPosition` {Array} of two numbers: the screen row, and the screen column.", " * `options` (optional) {Object} with the following keys:", "   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever", "     the cursor moves to."], "name": "Cursor.setScreenPosition", "params": ["screenPosition", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 70, "start_line": 66}, "call_info": {"func_end_line": 344, "comment": [" Public: Moves the cursor to the beginning of the line."], "code": "  moveToBeginningOfScreenLine () {\r\n    this.setScreenPosition([this.getScreenRow(), 0])\r\n  }\r", "name": "setScreenPosition", "func_location": "Cursor.moveToBeginningOfScreenLine", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 343, "func_start_line": 342}}, {"func_info": {"comment": [" Public: Returns the cursor's current screen row."], "name": "Cursor.getScreenRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 98, "start_line": 96}, "call_info": {"func_end_line": 344, "comment": [" Public: Moves the cursor to the beginning of the line."], "code": "  moveToBeginningOfScreenLine () {\r\n    this.setScreenPosition([this.getScreenRow(), 0])\r\n  }\r", "name": "getScreenRow", "func_location": "Cursor.moveToBeginningOfScreenLine", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 343, "func_start_line": 342}}, {"func_info": {"comment": [" Public: Moves a cursor to a given buffer position.", "", " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.", " * `options` (optional) {Object} with the following keys:", "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new", "     position. Defaults to `true` if this is the most recently added cursor,", "     `false` otherwise."], "name": "Cursor.setBufferPosition", "params": ["bufferPosition", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 88, "start_line": 84}, "call_info": {"func_end_line": 388, "comment": [" Public: Moves the cursor to the beginning of the word."], "code": "  moveToBeginningOfWord () {\r\n    this.setBufferPosition(this.getBeginningOfCurrentWordBufferPosition())\r\n  }\r", "name": "setBufferPosition", "func_location": "Cursor.moveToBeginningOfWord", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 387, "func_start_line": 386}}, {"func_info": {"comment": [" Public: Retrieves the buffer position of where the current word starts.", "", " * `options` (optional) An {Object} with the following keys:", "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"", "     (default: {::wordRegExp}).", "   * `includeNonWordCharacters` A {Boolean} indicating whether to include", "     non-word characters in the default word regex.", "     Has no effect if wordRegex is set.", "   * `allowPrevious` A {Boolean} indicating whether the beginning of the", "     previous word can be returned.", "", " Returns a {Range}."], "name": "Cursor.getBeginningOfCurrentWordBufferPosition", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 547, "start_line": 527}, "call_info": {"func_end_line": 388, "comment": [" Public: Moves the cursor to the beginning of the word."], "code": "  moveToBeginningOfWord () {\r\n    this.setBufferPosition(this.getBeginningOfCurrentWordBufferPosition())\r\n  }\r", "name": "getBeginningOfCurrentWordBufferPosition", "func_location": "Cursor.moveToBeginningOfWord", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 387, "func_start_line": 386}}, {"func_info": {"comment": [" Public: Moves a cursor to a given buffer position.", "", " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.", " * `options` (optional) {Object} with the following keys:", "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new", "     position. Defaults to `true` if this is the most recently added cursor,", "     `false` otherwise."], "name": "Cursor.setBufferPosition", "params": ["bufferPosition", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 88, "start_line": 84}, "call_info": {"func_end_line": 339, "comment": [" Public: Moves the cursor to the bottom of the buffer."], "code": "  moveToBottom () {\r\n    const column = this.goalColumn\r\n    this.setBufferPosition(this.editor.getEofBufferPosition())\r\n    this.goalColumn = column\r\n  }\r", "name": "setBufferPosition", "func_location": "Cursor.moveToBottom", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 337, "func_start_line": 335}}, {"func_info": {"comment": [" Public: Moves a cursor to a given buffer position.", "", " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.", " * `options` (optional) {Object} with the following keys:", "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new", "     position. Defaults to `true` if this is the most recently added cursor,", "     `false` otherwise."], "name": "Cursor.setBufferPosition", "params": ["bufferPosition", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 88, "start_line": 84}, "call_info": {"func_end_line": 383, "comment": [" Public: Moves the cursor to the end of the buffer line."], "code": "  moveToEndOfLine () {\r\n    this.setBufferPosition([this.getBufferRow(), Infinity])\r\n  }\r", "name": "setBufferPosition", "func_location": "Cursor.moveToEndOfLine", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 382, "func_start_line": 381}}, {"func_info": {"comment": [" Public: Retrieves the cursor's current buffer row."], "name": "Cursor.getBufferRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 108, "start_line": 106}, "call_info": {"func_end_line": 383, "comment": [" Public: Moves the cursor to the end of the buffer line."], "code": "  moveToEndOfLine () {\r\n    this.setBufferPosition([this.getBufferRow(), Infinity])\r\n  }\r", "name": "getBufferRow", "func_location": "Cursor.moveToEndOfLine", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 382, "func_start_line": 381}}, {"func_info": {"comment": ["\r\n  Section: Managing Cursor Position\r\n  ", " Public: Moves a cursor to a given screen position.", "", " * `screenPosition` {Array} of two numbers: the screen row, and the screen column.", " * `options` (optional) {Object} with the following keys:", "   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever", "     the cursor moves to."], "name": "Cursor.setScreenPosition", "params": ["screenPosition", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 70, "start_line": 66}, "call_info": {"func_end_line": 378, "comment": [" Public: Moves the cursor to the end of the line."], "code": "  moveToEndOfScreenLine () {\r\n    this.setScreenPosition([this.getScreenRow(), Infinity])\r\n  }\r", "name": "setScreenPosition", "func_location": "Cursor.moveToEndOfScreenLine", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 377, "func_start_line": 376}}, {"func_info": {"comment": [" Public: Returns the cursor's current screen row."], "name": "Cursor.getScreenRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 98, "start_line": 96}, "call_info": {"func_end_line": 378, "comment": [" Public: Moves the cursor to the end of the line."], "code": "  moveToEndOfScreenLine () {\r\n    this.setScreenPosition([this.getScreenRow(), Infinity])\r\n  }\r", "name": "getScreenRow", "func_location": "Cursor.moveToEndOfScreenLine", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 377, "func_start_line": 376}}, {"func_info": {"comment": [" Public: Retrieves the buffer position of where the current word ends.", "", " * `options` (optional) {Object} with the following keys:", "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"", "      (default: {::wordRegExp})", "   * `includeNonWordCharacters` A Boolean indicating whether to include", "     non-word characters in the default word regex. Has no effect if", "     wordRegex is set.", "", " Returns a {Range}."], "name": "Cursor.getEndOfCurrentWordBufferPosition", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 578, "start_line": 559}, "call_info": {"func_end_line": 394, "comment": [" Public: Moves the cursor to the end of the word."], "code": "  moveToEndOfWord () {\r\n    const position = this.getEndOfCurrentWordBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r", "name": "getEndOfCurrentWordBufferPosition", "func_location": "Cursor.moveToEndOfWord", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 392, "func_start_line": 391}}, {"func_info": {"comment": [" Public: Moves a cursor to a given buffer position.", "", " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.", " * `options` (optional) {Object} with the following keys:", "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new", "     position. Defaults to `true` if this is the most recently added cursor,", "     `false` otherwise."], "name": "Cursor.setBufferPosition", "params": ["bufferPosition", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 88, "start_line": 84}, "call_info": {"func_end_line": 394, "comment": [" Public: Moves the cursor to the end of the word."], "code": "  moveToEndOfWord () {\r\n    const position = this.getEndOfCurrentWordBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r", "name": "setBufferPosition", "func_location": "Cursor.moveToEndOfWord", "args": ["position"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 393, "func_start_line": 391}}, {"func_info": {"comment": [" Public: Returns the cursor's current screen row."], "name": "Cursor.getScreenRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 98, "start_line": 96}, "call_info": {"func_end_line": 373, "comment": [" Public: Moves the cursor to the beginning of the first character in the", " line."], "code": "  moveToFirstCharacterOfLine () {\r\n    let targetBufferColumn\r\n    const screenRow = this.getScreenRow()\r\n    const screenLineStart = this.editor.clipScreenPosition([screenRow, 0], {skipSoftWrapIndentation: true})\r\n    const screenLineEnd = [screenRow, Infinity]\r\n    const screenLineBufferRange = this.editor.bufferRangeForScreenRange([screenLineStart, screenLineEnd])\r\n\r\n    let firstCharacterColumn = null\r\n    this.editor.scanInBufferRange(/\\S/, screenLineBufferRange, ({range, stop}) => {\r\n      firstCharacterColumn = range.start.column\r\n      stop()\r\n    })\r\n\r\n    if (firstCharacterColumn != null && firstCharacterColumn !== this.getBufferColumn()) {\r\n      targetBufferColumn = firstCharacterColumn\r\n    } else {\r\n      targetBufferColumn = screenLineBufferRange.start.column\r\n    }\r\n\r\n    this.setBufferPosition([screenLineBufferRange.start.row, targetBufferColumn])\r\n  }\r", "name": "getScreenRow", "func_location": "Cursor.moveToFirstCharacterOfLine", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 355, "func_start_line": 353}}, {"func_info": {"comment": [" Public: Returns the cursor's current buffer column."], "name": "Cursor.getBufferColumn", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 113, "start_line": 111}, "call_info": {"func_end_line": 373, "comment": [" Public: Moves the cursor to the beginning of the first character in the", " line."], "code": "  moveToFirstCharacterOfLine () {\r\n    let targetBufferColumn\r\n    const screenRow = this.getScreenRow()\r\n    const screenLineStart = this.editor.clipScreenPosition([screenRow, 0], {skipSoftWrapIndentation: true})\r\n    const screenLineEnd = [screenRow, Infinity]\r\n    const screenLineBufferRange = this.editor.bufferRangeForScreenRange([screenLineStart, screenLineEnd])\r\n\r\n    let firstCharacterColumn = null\r\n    this.editor.scanInBufferRange(/\\S/, screenLineBufferRange, ({range, stop}) => {\r\n      firstCharacterColumn = range.start.column\r\n      stop()\r\n    })\r\n\r\n    if (firstCharacterColumn != null && firstCharacterColumn !== this.getBufferColumn()) {\r\n      targetBufferColumn = firstCharacterColumn\r\n    } else {\r\n      targetBufferColumn = screenLineBufferRange.start.column\r\n    }\r\n\r\n    this.setBufferPosition([screenLineBufferRange.start.row, targetBufferColumn])\r\n  }\r", "name": "getBufferColumn", "func_location": "Cursor.moveToFirstCharacterOfLine", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 366, "func_start_line": 353}}, {"func_info": {"comment": [" Public: Moves a cursor to a given buffer position.", "", " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.", " * `options` (optional) {Object} with the following keys:", "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new", "     position. Defaults to `true` if this is the most recently added cursor,", "     `false` otherwise."], "name": "Cursor.setBufferPosition", "params": ["bufferPosition", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 88, "start_line": 84}, "call_info": {"func_end_line": 373, "comment": [" Public: Moves the cursor to the beginning of the first character in the", " line."], "code": "  moveToFirstCharacterOfLine () {\r\n    let targetBufferColumn\r\n    const screenRow = this.getScreenRow()\r\n    const screenLineStart = this.editor.clipScreenPosition([screenRow, 0], {skipSoftWrapIndentation: true})\r\n    const screenLineEnd = [screenRow, Infinity]\r\n    const screenLineBufferRange = this.editor.bufferRangeForScreenRange([screenLineStart, screenLineEnd])\r\n\r\n    let firstCharacterColumn = null\r\n    this.editor.scanInBufferRange(/\\S/, screenLineBufferRange, ({range, stop}) => {\r\n      firstCharacterColumn = range.start.column\r\n      stop()\r\n    })\r\n\r\n    if (firstCharacterColumn != null && firstCharacterColumn !== this.getBufferColumn()) {\r\n      targetBufferColumn = firstCharacterColumn\r\n    } else {\r\n      targetBufferColumn = screenLineBufferRange.start.column\r\n    }\r\n\r\n    this.setBufferPosition([screenLineBufferRange.start.row, targetBufferColumn])\r\n  }\r", "name": "setBufferPosition", "func_location": "Cursor.moveToFirstCharacterOfLine", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 372, "func_start_line": 353}}, {"func_info": {"comment": [" Public: Get the RegExp used by the cursor to determine what a \"subword\" is.", "", " * `options` (optional) {Object} with the following keys:", "   * `backwards` A {Boolean} indicating whether to look forwards or backwards", "     for the next subword. (default: false)", "", " Returns a {RegExp}."], "name": "Cursor.subwordRegExp", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 710, "start_line": 690}, "call_info": {"func_end_line": 426, "comment": [" Public: Moves the cursor to the next subword boundary."], "code": "  moveToNextSubwordBoundary () {\r\n    const options = {wordRegex: this.subwordRegExp()}\r\n    const position = this.getNextWordBoundaryBufferPosition(options)\r\n    if (position) this.setBufferPosition(position)\r\n  }\r", "name": "subwordRegExp", "func_location": "Cursor.moveToNextSubwordBoundary", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 423, "func_start_line": 422}}, {"func_info": {"comment": [" Public: Returns buffer position of the next word boundary. It might be on", " the current word, or the previous word.", "", " * `options` (optional) {Object} with the following keys:", "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"", "      (default: {::wordRegExp})"], "name": "Cursor.getNextWordBoundaryBufferPosition", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 513, "start_line": 493}, "call_info": {"func_end_line": 426, "comment": [" Public: Moves the cursor to the next subword boundary."], "code": "  moveToNextSubwordBoundary () {\r\n    const options = {wordRegex: this.subwordRegExp()}\r\n    const position = this.getNextWordBoundaryBufferPosition(options)\r\n    if (position) this.setBufferPosition(position)\r\n  }\r", "name": "getNextWordBoundaryBufferPosition", "func_location": "Cursor.moveToNextSubwordBoundary", "args": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 424, "func_start_line": 422}}, {"func_info": {"comment": [" Public: Moves a cursor to a given buffer position.", "", " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.", " * `options` (optional) {Object} with the following keys:", "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new", "     position. Defaults to `true` if this is the most recently added cursor,", "     `false` otherwise."], "name": "Cursor.setBufferPosition", "params": ["bufferPosition", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 88, "start_line": 84}, "call_info": {"func_end_line": 426, "comment": [" Public: Moves the cursor to the next subword boundary."], "code": "  moveToNextSubwordBoundary () {\r\n    const options = {wordRegex: this.subwordRegExp()}\r\n    const position = this.getNextWordBoundaryBufferPosition(options)\r\n    if (position) this.setBufferPosition(position)\r\n  }\r", "name": "setBufferPosition", "func_location": "Cursor.moveToNextSubwordBoundary", "args": ["position"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 425, "func_start_line": 422}}, {"func_info": {"comment": [" Public: Returns buffer position of the next word boundary. It might be on", " the current word, or the previous word.", "", " * `options` (optional) {Object} with the following keys:", "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"", "      (default: {::wordRegExp})"], "name": "Cursor.getNextWordBoundaryBufferPosition", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 513, "start_line": 493}, "call_info": {"func_end_line": 412, "comment": [" Public: Moves the cursor to the next word boundary."], "code": "  moveToNextWordBoundary () {\r\n    const position = this.getNextWordBoundaryBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r", "name": "getNextWordBoundaryBufferPosition", "func_location": "Cursor.moveToNextWordBoundary", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 410, "func_start_line": 409}}, {"func_info": {"comment": [" Public: Moves a cursor to a given buffer position.", "", " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.", " * `options` (optional) {Object} with the following keys:", "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new", "     position. Defaults to `true` if this is the most recently added cursor,", "     `false` otherwise."], "name": "Cursor.setBufferPosition", "params": ["bufferPosition", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 88, "start_line": 84}, "call_info": {"func_end_line": 412, "comment": [" Public: Moves the cursor to the next word boundary."], "code": "  moveToNextWordBoundary () {\r\n    const position = this.getNextWordBoundaryBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r", "name": "setBufferPosition", "func_location": "Cursor.moveToNextWordBoundary", "args": ["position"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 411, "func_start_line": 409}}, {"func_info": {"comment": [" Public: Get the RegExp used by the cursor to determine what a \"subword\" is.", "", " * `options` (optional) {Object} with the following keys:", "   * `backwards` A {Boolean} indicating whether to look forwards or backwards", "     for the next subword. (default: false)", "", " Returns a {RegExp}."], "name": "Cursor.subwordRegExp", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 710, "start_line": 690}, "call_info": {"func_end_line": 419, "comment": [" Public: Moves the cursor to the previous subword boundary."], "code": "  moveToPreviousSubwordBoundary () {\r\n    const options = {wordRegex: this.subwordRegExp({backwards: true})}\r\n    const position = this.getPreviousWordBoundaryBufferPosition(options)\r\n    if (position) this.setBufferPosition(position)\r\n  }\r", "name": "subwordRegExp", "func_location": "Cursor.moveToPreviousSubwordBoundary", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 416, "func_start_line": 415}}, {"func_info": {"comment": ["\r\n  Section: Local Positions and Ranges\r\n  ", " Public: Returns buffer position of previous word boundary. It might be on", " the current word, or the previous word.", "", " * `options` (optional) {Object} with the following keys:", "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"", "      (default: {::wordRegExp})"], "name": "Cursor.getPreviousWordBoundaryBufferPosition", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 485, "start_line": 463}, "call_info": {"func_end_line": 419, "comment": [" Public: Moves the cursor to the previous subword boundary."], "code": "  moveToPreviousSubwordBoundary () {\r\n    const options = {wordRegex: this.subwordRegExp({backwards: true})}\r\n    const position = this.getPreviousWordBoundaryBufferPosition(options)\r\n    if (position) this.setBufferPosition(position)\r\n  }\r", "name": "getPreviousWordBoundaryBufferPosition", "func_location": "Cursor.moveToPreviousSubwordBoundary", "args": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 417, "func_start_line": 415}}, {"func_info": {"comment": [" Public: Moves a cursor to a given buffer position.", "", " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.", " * `options` (optional) {Object} with the following keys:", "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new", "     position. Defaults to `true` if this is the most recently added cursor,", "     `false` otherwise."], "name": "Cursor.setBufferPosition", "params": ["bufferPosition", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 88, "start_line": 84}, "call_info": {"func_end_line": 419, "comment": [" Public: Moves the cursor to the previous subword boundary."], "code": "  moveToPreviousSubwordBoundary () {\r\n    const options = {wordRegex: this.subwordRegExp({backwards: true})}\r\n    const position = this.getPreviousWordBoundaryBufferPosition(options)\r\n    if (position) this.setBufferPosition(position)\r\n  }\r", "name": "setBufferPosition", "func_location": "Cursor.moveToPreviousSubwordBoundary", "args": ["position"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 418, "func_start_line": 415}}, {"func_info": {"comment": ["\r\n  Section: Local Positions and Ranges\r\n  ", " Public: Returns buffer position of previous word boundary. It might be on", " the current word, or the previous word.", "", " * `options` (optional) {Object} with the following keys:", "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"", "      (default: {::wordRegExp})"], "name": "Cursor.getPreviousWordBoundaryBufferPosition", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 485, "start_line": 463}, "call_info": {"func_end_line": 406, "comment": [" Public: Moves the cursor to the previous word boundary."], "code": "  moveToPreviousWordBoundary () {\r\n    const position = this.getPreviousWordBoundaryBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r", "name": "getPreviousWordBoundaryBufferPosition", "func_location": "Cursor.moveToPreviousWordBoundary", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 404, "func_start_line": 403}}, {"func_info": {"comment": [" Public: Moves a cursor to a given buffer position.", "", " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.", " * `options` (optional) {Object} with the following keys:", "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new", "     position. Defaults to `true` if this is the most recently added cursor,", "     `false` otherwise."], "name": "Cursor.setBufferPosition", "params": ["bufferPosition", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 88, "start_line": 84}, "call_info": {"func_end_line": 406, "comment": [" Public: Moves the cursor to the previous word boundary."], "code": "  moveToPreviousWordBoundary () {\r\n    const position = this.getPreviousWordBoundaryBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r", "name": "setBufferPosition", "func_location": "Cursor.moveToPreviousWordBoundary", "args": ["position"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 405, "func_start_line": 403}}, {"func_info": {"comment": [], "name": "TextMateHighlightIterator.isAtTagBoundary", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 865, "start_line": 863}, "call_info": {"func_end_line": 836, "code": "  moveToSuccessor () {\r\n    this.openScopeIds = []\r\n    this.closeScopeIds = []\r\n    while (true) {\r\n      if (this.tagIndex === this.currentLineTags.length) {\r\n        if (this.isAtTagBoundary()) {\r\n          break\r\n        } else if (!this.moveToNextLine()) {\r\n          return false\r\n        }\r\n      } else {\r\n        const tag = this.currentLineTags[this.tagIndex]\r\n        if (tag >= 0) {\r\n          if (this.isAtTagBoundary()) {\r\n            break\r\n          } else {\r\n            this.position = Point(this.position.row, Math.min(\r\n              this.currentLineLength,\r\n              this.position.column + this.currentLineTags[this.tagIndex]\r\n            ))\r\n          }\r\n        } else {\r\n          const scopeId = fromFirstMateScopeId(tag)\r\n          if ((tag & 1) === 0) {\r\n            if (this.openScopeIds.length > 0) {\r\n              break\r\n            } else {\r\n              this.closeScopeIds.push(scopeId)\r\n            }\r\n          } else {\r\n            this.openScopeIds.push(scopeId)\r\n          }\r\n        }\r\n        this.tagIndex++\r\n      }\r\n    }\r\n    return true\r\n  }\r", "name": "isAtTagBoundary", "func_location": "TextMateHighlightIterator.moveToSuccessor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 804, "func_start_line": 799}}, {"func_info": {"comment": [], "name": "TextMateHighlightIterator.moveToNextLine", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 861, "start_line": 850}, "call_info": {"func_end_line": 836, "code": "  moveToSuccessor () {\r\n    this.openScopeIds = []\r\n    this.closeScopeIds = []\r\n    while (true) {\r\n      if (this.tagIndex === this.currentLineTags.length) {\r\n        if (this.isAtTagBoundary()) {\r\n          break\r\n        } else if (!this.moveToNextLine()) {\r\n          return false\r\n        }\r\n      } else {\r\n        const tag = this.currentLineTags[this.tagIndex]\r\n        if (tag >= 0) {\r\n          if (this.isAtTagBoundary()) {\r\n            break\r\n          } else {\r\n            this.position = Point(this.position.row, Math.min(\r\n              this.currentLineLength,\r\n              this.position.column + this.currentLineTags[this.tagIndex]\r\n            ))\r\n          }\r\n        } else {\r\n          const scopeId = fromFirstMateScopeId(tag)\r\n          if ((tag & 1) === 0) {\r\n            if (this.openScopeIds.length > 0) {\r\n              break\r\n            } else {\r\n              this.closeScopeIds.push(scopeId)\r\n            }\r\n          } else {\r\n            this.openScopeIds.push(scopeId)\r\n          }\r\n        }\r\n        this.tagIndex++\r\n      }\r\n    }\r\n    return true\r\n  }\r", "name": "moveToNextLine", "func_location": "TextMateHighlightIterator.moveToSuccessor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 806, "func_start_line": 799}}, {"func_info": {"comment": [], "name": "TextMateHighlightIterator.isAtTagBoundary", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 865, "start_line": 863}, "call_info": {"func_end_line": 836, "code": "  moveToSuccessor () {\r\n    this.openScopeIds = []\r\n    this.closeScopeIds = []\r\n    while (true) {\r\n      if (this.tagIndex === this.currentLineTags.length) {\r\n        if (this.isAtTagBoundary()) {\r\n          break\r\n        } else if (!this.moveToNextLine()) {\r\n          return false\r\n        }\r\n      } else {\r\n        const tag = this.currentLineTags[this.tagIndex]\r\n        if (tag >= 0) {\r\n          if (this.isAtTagBoundary()) {\r\n            break\r\n          } else {\r\n            this.position = Point(this.position.row, Math.min(\r\n              this.currentLineLength,\r\n              this.position.column + this.currentLineTags[this.tagIndex]\r\n            ))\r\n          }\r\n        } else {\r\n          const scopeId = fromFirstMateScopeId(tag)\r\n          if ((tag & 1) === 0) {\r\n            if (this.openScopeIds.length > 0) {\r\n              break\r\n            } else {\r\n              this.closeScopeIds.push(scopeId)\r\n            }\r\n          } else {\r\n            this.openScopeIds.push(scopeId)\r\n          }\r\n        }\r\n        this.tagIndex++\r\n      }\r\n    }\r\n    return true\r\n  }\r", "name": "isAtTagBoundary", "func_location": "TextMateHighlightIterator.moveToSuccessor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 812, "func_start_line": 799}}, {"func_info": {"comment": [], "name": "LayerHighlightIterator._moveRight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1050, "start_line": 1042}, "call_info": {"func_end_line": 965, "code": "  moveToSuccessor () {\r\n    this.closeTags.length = 0\r\n    this.openTags.length = 0\r\n\r\n    while (!this.done && !this.closeTags.length && !this.openTags.length) {\r\n      if (this.atEnd) {\r\n        if (this._moveRight()) {\r\n          const scopeId = this._currentScopeId()\r\n          if (scopeId) this.openTags.push(scopeId)\r\n          this.atEnd = false\r\n          this._moveDown()\r\n        } else if (this._moveUp(true)) {\r\n          this.atEnd = true\r\n        } else {\r\n          this.done = true\r\n        }\r\n      } else if (!this._moveDown()) {\r\n        const scopeId = this._currentScopeId()\r\n        if (scopeId) this.closeTags.push(scopeId)\r\n        this.atEnd = true\r\n        this._moveUp(false)\r\n      }\r\n    }\r\n  }\r", "name": "_moveRight", "func_location": "LayerHighlightIterator.moveToSuccessor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 948, "func_start_line": 942}}, {"func_info": {"comment": [], "name": "LayerHighlightIterator._currentScopeId", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1062, "start_line": 1052}, "call_info": {"func_end_line": 965, "code": "  moveToSuccessor () {\r\n    this.closeTags.length = 0\r\n    this.openTags.length = 0\r\n\r\n    while (!this.done && !this.closeTags.length && !this.openTags.length) {\r\n      if (this.atEnd) {\r\n        if (this._moveRight()) {\r\n          const scopeId = this._currentScopeId()\r\n          if (scopeId) this.openTags.push(scopeId)\r\n          this.atEnd = false\r\n          this._moveDown()\r\n        } else if (this._moveUp(true)) {\r\n          this.atEnd = true\r\n        } else {\r\n          this.done = true\r\n        }\r\n      } else if (!this._moveDown()) {\r\n        const scopeId = this._currentScopeId()\r\n        if (scopeId) this.closeTags.push(scopeId)\r\n        this.atEnd = true\r\n        this._moveUp(false)\r\n      }\r\n    }\r\n  }\r", "name": "_currentScopeId", "func_location": "LayerHighlightIterator.moveToSuccessor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 949, "func_start_line": 942}}, {"func_info": {"comment": [], "name": "LayerHighlightIterator._moveDown", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1040, "start_line": 1016}, "call_info": {"func_end_line": 965, "code": "  moveToSuccessor () {\r\n    this.closeTags.length = 0\r\n    this.openTags.length = 0\r\n\r\n    while (!this.done && !this.closeTags.length && !this.openTags.length) {\r\n      if (this.atEnd) {\r\n        if (this._moveRight()) {\r\n          const scopeId = this._currentScopeId()\r\n          if (scopeId) this.openTags.push(scopeId)\r\n          this.atEnd = false\r\n          this._moveDown()\r\n        } else if (this._moveUp(true)) {\r\n          this.atEnd = true\r\n        } else {\r\n          this.done = true\r\n        }\r\n      } else if (!this._moveDown()) {\r\n        const scopeId = this._currentScopeId()\r\n        if (scopeId) this.closeTags.push(scopeId)\r\n        this.atEnd = true\r\n        this._moveUp(false)\r\n      }\r\n    }\r\n  }\r", "name": "_moveDown", "func_location": "LayerHighlightIterator.moveToSuccessor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 952, "func_start_line": 942}}, {"func_info": {"comment": [" Private methods"], "name": "LayerHighlightIterator._moveUp", "params": ["atLastChild"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1014, "start_line": 996}, "call_info": {"func_end_line": 965, "code": "  moveToSuccessor () {\r\n    this.closeTags.length = 0\r\n    this.openTags.length = 0\r\n\r\n    while (!this.done && !this.closeTags.length && !this.openTags.length) {\r\n      if (this.atEnd) {\r\n        if (this._moveRight()) {\r\n          const scopeId = this._currentScopeId()\r\n          if (scopeId) this.openTags.push(scopeId)\r\n          this.atEnd = false\r\n          this._moveDown()\r\n        } else if (this._moveUp(true)) {\r\n          this.atEnd = true\r\n        } else {\r\n          this.done = true\r\n        }\r\n      } else if (!this._moveDown()) {\r\n        const scopeId = this._currentScopeId()\r\n        if (scopeId) this.closeTags.push(scopeId)\r\n        this.atEnd = true\r\n        this._moveUp(false)\r\n      }\r\n    }\r\n  }\r", "name": "_moveUp", "func_location": "LayerHighlightIterator.moveToSuccessor", "args": [{"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 953, "func_start_line": 942}}, {"func_info": {"comment": [], "name": "LayerHighlightIterator._moveDown", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1040, "start_line": 1016}, "call_info": {"func_end_line": 965, "code": "  moveToSuccessor () {\r\n    this.closeTags.length = 0\r\n    this.openTags.length = 0\r\n\r\n    while (!this.done && !this.closeTags.length && !this.openTags.length) {\r\n      if (this.atEnd) {\r\n        if (this._moveRight()) {\r\n          const scopeId = this._currentScopeId()\r\n          if (scopeId) this.openTags.push(scopeId)\r\n          this.atEnd = false\r\n          this._moveDown()\r\n        } else if (this._moveUp(true)) {\r\n          this.atEnd = true\r\n        } else {\r\n          this.done = true\r\n        }\r\n      } else if (!this._moveDown()) {\r\n        const scopeId = this._currentScopeId()\r\n        if (scopeId) this.closeTags.push(scopeId)\r\n        this.atEnd = true\r\n        this._moveUp(false)\r\n      }\r\n    }\r\n  }\r", "name": "_moveDown", "func_location": "LayerHighlightIterator.moveToSuccessor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 958, "func_start_line": 942}}, {"func_info": {"comment": [], "name": "LayerHighlightIterator._currentScopeId", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1062, "start_line": 1052}, "call_info": {"func_end_line": 965, "code": "  moveToSuccessor () {\r\n    this.closeTags.length = 0\r\n    this.openTags.length = 0\r\n\r\n    while (!this.done && !this.closeTags.length && !this.openTags.length) {\r\n      if (this.atEnd) {\r\n        if (this._moveRight()) {\r\n          const scopeId = this._currentScopeId()\r\n          if (scopeId) this.openTags.push(scopeId)\r\n          this.atEnd = false\r\n          this._moveDown()\r\n        } else if (this._moveUp(true)) {\r\n          this.atEnd = true\r\n        } else {\r\n          this.done = true\r\n        }\r\n      } else if (!this._moveDown()) {\r\n        const scopeId = this._currentScopeId()\r\n        if (scopeId) this.closeTags.push(scopeId)\r\n        this.atEnd = true\r\n        this._moveUp(false)\r\n      }\r\n    }\r\n  }\r", "name": "_currentScopeId", "func_location": "LayerHighlightIterator.moveToSuccessor", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 959, "func_start_line": 942}}, {"func_info": {"comment": [" Private methods"], "name": "LayerHighlightIterator._moveUp", "params": ["atLastChild"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1014, "start_line": 996}, "call_info": {"func_end_line": 965, "code": "  moveToSuccessor () {\r\n    this.closeTags.length = 0\r\n    this.openTags.length = 0\r\n\r\n    while (!this.done && !this.closeTags.length && !this.openTags.length) {\r\n      if (this.atEnd) {\r\n        if (this._moveRight()) {\r\n          const scopeId = this._currentScopeId()\r\n          if (scopeId) this.openTags.push(scopeId)\r\n          this.atEnd = false\r\n          this._moveDown()\r\n        } else if (this._moveUp(true)) {\r\n          this.atEnd = true\r\n        } else {\r\n          this.done = true\r\n        }\r\n      } else if (!this._moveDown()) {\r\n        const scopeId = this._currentScopeId()\r\n        if (scopeId) this.closeTags.push(scopeId)\r\n        this.atEnd = true\r\n        this._moveUp(false)\r\n      }\r\n    }\r\n  }\r", "name": "_moveUp", "func_location": "LayerHighlightIterator.moveToSuccessor", "args": [{"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 962, "func_start_line": 942}}, {"func_info": {"comment": [" Public: Moves a cursor to a given buffer position.", "", " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.", " * `options` (optional) {Object} with the following keys:", "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new", "     position. Defaults to `true` if this is the most recently added cursor,", "     `false` otherwise."], "name": "Cursor.setBufferPosition", "params": ["bufferPosition", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 88, "start_line": 84}, "call_info": {"func_end_line": 332, "comment": [" Public: Moves the cursor to the top of the buffer."], "code": "  moveToTop () {\r\n    this.setBufferPosition([0, 0])\r\n  }\r", "name": "setBufferPosition", "func_location": "Cursor.moveToTop", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 331, "func_start_line": 330}}, {"func_info": {"comment": [" Public: Returns the screen position of the cursor as a {Point}."], "name": "Cursor.getScreenPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 75, "start_line": 73}, "call_info": {"func_end_line": 253, "comment": ["\r\n  Section: Moving the Cursor\r\n  ", " Public: Moves the cursor up one screen row.", "", " * `rowCount` (optional) {Number} number of rows to move (default: 1)", " * `options` (optional) {Object} with the following keys:", "   * `moveToEndOfSelection` if true, move to the left of the selection if a", "     selection exists."], "code": "  moveUp (rowCount = 1, {moveToEndOfSelection} = {}) {\r\n    let row, column\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      ({row, column} = range.start)\r\n    } else {\r\n      ({row, column} = this.getScreenPosition())\r\n    }\r\n\r\n    if (this.goalColumn != null) column = this.goalColumn\r\n    this.setScreenPosition({row: row - rowCount, column}, {skipSoftWrapIndentation: true})\r\n    this.goalColumn = column\r\n  }\r", "name": "getScreenPosition", "func_location": "Cursor.moveUp", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 247, "func_start_line": 241}}, {"func_info": {"comment": ["\r\n  Section: Managing Cursor Position\r\n  ", " Public: Moves a cursor to a given screen position.", "", " * `screenPosition` {Array} of two numbers: the screen row, and the screen column.", " * `options` (optional) {Object} with the following keys:", "   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever", "     the cursor moves to."], "name": "Cursor.setScreenPosition", "params": ["screenPosition", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 70, "start_line": 66}, "call_info": {"func_end_line": 253, "comment": ["\r\n  Section: Moving the Cursor\r\n  ", " Public: Moves the cursor up one screen row.", "", " * `rowCount` (optional) {Number} number of rows to move (default: 1)", " * `options` (optional) {Object} with the following keys:", "   * `moveToEndOfSelection` if true, move to the left of the selection if a", "     selection exists."], "code": "  moveUp (rowCount = 1, {moveToEndOfSelection} = {}) {\r\n    let row, column\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      ({row, column} = range.start)\r\n    } else {\r\n      ({row, column} = this.getScreenPosition())\r\n    }\r\n\r\n    if (this.goalColumn != null) column = this.goalColumn\r\n    this.setScreenPosition({row: row - rowCount, column}, {skipSoftWrapIndentation: true})\r\n    this.goalColumn = column\r\n  }\r", "name": "setScreenPosition", "func_location": "Cursor.moveUp", "args": [null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 251, "func_start_line": 241}}, {"func_info": {"comment": [], "name": "WorkspaceElement.boundingBoxForPaneView", "params": ["paneView"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 311, "start_line": 302}, "call_info": {"func_end_line": 300, "code": "  nearestVisiblePaneInDirection (direction, pane) {\r\n    const distance = function (pointA, pointB) {\r\n      const x = pointB.x - pointA.x\r\n      const y = pointB.y - pointA.y\r\n      return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))\r\n    }\r\n\r\n    const paneView = pane.getElement()\r\n    const box = this.boundingBoxForPaneView(paneView)\r\n\r\n    const paneViews = atom.workspace.getVisiblePanes()\r\n      .map(otherPane => otherPane.getElement())\r\n      .filter(otherPaneView => {\r\n        const otherBox = this.boundingBoxForPaneView(otherPaneView)\r\n        switch (direction) {\r\n          case 'left': return otherBox.right.x <= box.left.x\r\n          case 'right': return otherBox.left.x >= box.right.x\r\n          case 'above': return otherBox.bottom.y <= box.top.y\r\n          case 'below': return otherBox.top.y >= box.bottom.y\r\n        }\r\n      }).sort((paneViewA, paneViewB) => {\r\n        const boxA = this.boundingBoxForPaneView(paneViewA)\r\n        const boxB = this.boundingBoxForPaneView(paneViewB)\r\n        switch (direction) {\r\n          case 'left': return distance(box.left, boxA.right) - distance(box.left, boxB.right)\r\n          case 'right': return distance(box.right, boxA.left) - distance(box.right, boxB.left)\r\n          case 'above': return distance(box.top, boxA.bottom) - distance(box.top, boxB.bottom)\r\n          case 'below': return distance(box.bottom, boxA.top) - distance(box.bottom, boxB.top)\r\n        }\r\n      })\r\n\r\n    return paneViews[0]\r\n  }\r", "name": "boundingBoxForPaneView", "func_location": "WorkspaceElement.nearestVisiblePaneInDirection", "args": ["paneView"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 276, "func_start_line": 268}}, {"func_info": {"comment": [], "name": "matcherForSpec", "params": ["spec"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js", "end_line": 144, "start_line": 128}, "call_info": {"func_end_line": 157, "code": "function normalizeFoldSpecification (spec) {\r\n  if (spec.type) {\r\n    if (Array.isArray(spec.type)) {\r\n      spec.matchers = spec.type.map(matcherForSpec)\r\n    } else {\r\n      spec.matchers = [matcherForSpec(spec.type)]\r\n    }\r\n  }\r\n\r\n  if (spec.start) normalizeFoldSpecification(spec.start)\r\n  if (spec.end) normalizeFoldSpecification(spec.end)\r\n}\r", "name": "matcherForSpec", "func_location": "normalizeFoldSpecification", "args": ["spec.type"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js", "line": 151, "func_start_line": 146}}, {"func_info": {"comment": [], "name": "normalizeFoldSpecification", "params": ["spec"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js", "end_line": 157, "start_line": 146}, "call_info": {"func_end_line": 157, "code": "function normalizeFoldSpecification (spec) {\r\n  if (spec.type) {\r\n    if (Array.isArray(spec.type)) {\r\n      spec.matchers = spec.type.map(matcherForSpec)\r\n    } else {\r\n      spec.matchers = [matcherForSpec(spec.type)]\r\n    }\r\n  }\r\n\r\n  if (spec.start) normalizeFoldSpecification(spec.start)\r\n  if (spec.end) normalizeFoldSpecification(spec.end)\r\n}\r", "name": "normalizeFoldSpecification", "func_location": "normalizeFoldSpecification", "args": ["spec.start"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js", "line": 155, "func_start_line": 146}}, {"func_info": {"comment": [], "name": "normalizeFoldSpecification", "params": ["spec"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js", "end_line": 157, "start_line": 146}, "call_info": {"func_end_line": 157, "code": "function normalizeFoldSpecification (spec) {\r\n  if (spec.type) {\r\n    if (Array.isArray(spec.type)) {\r\n      spec.matchers = spec.type.map(matcherForSpec)\r\n    } else {\r\n      spec.matchers = [matcherForSpec(spec.type)]\r\n    }\r\n  }\r\n\r\n  if (spec.start) normalizeFoldSpecification(spec.start)\r\n  if (spec.end) normalizeFoldSpecification(spec.end)\r\n}\r", "name": "normalizeFoldSpecification", "func_location": "normalizeFoldSpecification", "args": ["spec.end"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-grammar.js", "line": 156, "func_start_line": 146}}, {"func_info": {"comment": [], "name": "Config.observeScopedKeyPath", "params": ["scope", "keyPath", "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1267, "start_line": 1264}, "call_info": {"func_end_line": 487, "comment": ["\r\n  Section: Config Subscription\r\n  ", " Essential: Add a listener for changes to a given key path. This is different", " than {::onDidChange} in that it will immediately call your callback with the", " current value of the config entry.", "", " ### Examples", "", " You might want to be notified when the themes change. We'll watch", " `core.themes` for changes", "", " ```coffee", " atom.config.observe 'core.themes', (value) ->", "   # do stuff with value", " ```", "", " * `keyPath` {String} name of the key to observe", " * `options` (optional) {Object}", "   * `scope` (optional) {ScopeDescriptor} describing a path from", "     the root of the syntax tree to a token. Get one by calling", "     {editor.getLastCursor().getScopeDescriptor()}. See {::get} for examples.", "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)", "     for more information.", " * `callback` {Function} to call when the value of the key changes.", "   * `value` the new value of the key", "", " Returns a {Disposable} with the following keys on which you can call", " `.dispose()` to unsubscribe."], "code": "  observe (...args) {\r\n    let callback, keyPath, options, scopeDescriptor\r\n    if (args.length === 2) {\r\n      [keyPath, callback] = args\r\n    } else if ((args.length === 3) && (_.isString(args[0]) && _.isObject(args[1]))) {\r\n      [keyPath, options, callback] = args\r\n      scopeDescriptor = options.scope\r\n    } else {\r\n      console.error('An unsupported form of Config::observe is being used. See https://atom.io/docs/api/latest/Config for details')\r\n      return\r\n    }\r\n\r\n    if (scopeDescriptor != null) {\r\n      return this.observeScopedKeyPath(scopeDescriptor, keyPath, callback)\r\n    } else {\r\n      return this.observeKeyPath(keyPath, options != null ? options : {}, callback)\r\n    }\r\n  }\r", "name": "observeScopedKeyPath", "func_location": "Config.observe", "args": ["scopeDescriptor", "keyPath", "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 483, "func_start_line": 470}}, {"func_info": {"comment": [], "name": "Config.observeKeyPath", "params": ["keyPath", "options", "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1044, "start_line": 1041}, "call_info": {"func_end_line": 487, "comment": ["\r\n  Section: Config Subscription\r\n  ", " Essential: Add a listener for changes to a given key path. This is different", " than {::onDidChange} in that it will immediately call your callback with the", " current value of the config entry.", "", " ### Examples", "", " You might want to be notified when the themes change. We'll watch", " `core.themes` for changes", "", " ```coffee", " atom.config.observe 'core.themes', (value) ->", "   # do stuff with value", " ```", "", " * `keyPath` {String} name of the key to observe", " * `options` (optional) {Object}", "   * `scope` (optional) {ScopeDescriptor} describing a path from", "     the root of the syntax tree to a token. Get one by calling", "     {editor.getLastCursor().getScopeDescriptor()}. See {::get} for examples.", "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)", "     for more information.", " * `callback` {Function} to call when the value of the key changes.", "   * `value` the new value of the key", "", " Returns a {Disposable} with the following keys on which you can call", " `.dispose()` to unsubscribe."], "code": "  observe (...args) {\r\n    let callback, keyPath, options, scopeDescriptor\r\n    if (args.length === 2) {\r\n      [keyPath, callback] = args\r\n    } else if ((args.length === 3) && (_.isString(args[0]) && _.isObject(args[1]))) {\r\n      [keyPath, options, callback] = args\r\n      scopeDescriptor = options.scope\r\n    } else {\r\n      console.error('An unsupported form of Config::observe is being used. See https://atom.io/docs/api/latest/Config for details')\r\n      return\r\n    }\r\n\r\n    if (scopeDescriptor != null) {\r\n      return this.observeScopedKeyPath(scopeDescriptor, keyPath, callback)\r\n    } else {\r\n      return this.observeKeyPath(keyPath, options != null ? options : {}, callback)\r\n    }\r\n  }\r", "name": "observeKeyPath", "func_location": "Config.observe", "args": ["keyPath", null, "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 485, "func_start_line": 470}}, {"func_info": {"comment": ["\r\n  Section: Lifecycle\r\n  ", " Public: Determine whether the pane is active.", "", " Returns a {Boolean}."], "name": "Pane.isActive", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 1009, "start_line": 1007}, "call_info": {"func_end_line": 258, "comment": [" Public: Invoke the given callback with the current and future values of the", " {::isActive} property.", "", " * `callback` {Function} to be called with the current and future values of", "   the {::isActive} property.", "   * `active` {Boolean} indicating whether the pane is active.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  observeActive (callback) {\r\n    callback(this.isActive())\r\n    return this.onDidChangeActive(callback)\r\n  }\r", "name": "isActive", "func_location": "Pane.observeActive", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 256, "func_start_line": 255}}, {"func_info": {"comment": [" Public: Invoke the given callback when the value of the {::isActive}", " property changes.", "", " * `callback` {Function} to be called when the value of the {::isActive}", "   property changes.", "   * `active` {Boolean} indicating whether the pane is active.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "name": "Pane.onDidChangeActive", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 245, "start_line": 240}, "call_info": {"func_end_line": 258, "comment": [" Public: Invoke the given callback with the current and future values of the", " {::isActive} property.", "", " * `callback` {Function} to be called with the current and future values of", "   the {::isActive} property.", "   * `active` {Boolean} indicating whether the pane is active.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  observeActive (callback) {\r\n    callback(this.isActive())\r\n    return this.onDidChangeActive(callback)\r\n  }\r", "name": "onDidChangeActive", "func_location": "Pane.observeActive", "args": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 257, "func_start_line": 255}}, {"func_info": {"comment": [" Public: Get the active pane item in this pane.", "", " Returns a pane item."], "name": "Pane.getActiveItem", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 432, "start_line": 432}, "call_info": {"func_end_line": 379, "comment": [" Public: Invoke the given callback with the current and future values of", " {::getActiveItem}.", "", " * `callback` {Function} to be called with the current and future active", "   items.", "   * `activeItem` The current active item.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  observeActiveItem (callback) {\r\n    callback(this.getActiveItem())\r\n    return this.onDidChangeActiveItem(callback)\r\n  }\r", "name": "getActiveItem", "func_location": "Pane.observeActiveItem", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 377, "func_start_line": 376}}, {"func_info": {"comment": [" Public: Invoke the given callback when the value of {::getActiveItem}", " changes.", "", " * `callback` {Function} to be called with when the active item changes.", "   * `activeItem` The current active item.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "name": "Pane.onDidChangeActiveItem", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 330, "start_line": 328}, "call_info": {"func_end_line": 379, "comment": [" Public: Invoke the given callback with the current and future values of", " {::getActiveItem}.", "", " * `callback` {Function} to be called with the current and future active", "   items.", "   * `activeItem` The current active item.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  observeActiveItem (callback) {\r\n    callback(this.getActiveItem())\r\n    return this.onDidChangeActiveItem(callback)\r\n  }\r", "name": "onDidChangeActiveItem", "func_location": "Pane.observeActiveItem", "args": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 378, "func_start_line": 376}}, {"func_info": {"comment": [], "name": "PaneContainer.getActivePane", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 160, "start_line": 158}, "call_info": {"func_end_line": 97, "code": "  observeActivePane (fn) {\r\n    fn(this.getActivePane())\r\n    return this.onDidChangeActivePane(fn)\r\n  }\r", "name": "getActivePane", "func_location": "PaneContainer.observeActivePane", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 95, "func_start_line": 94}}, {"func_info": {"comment": [], "name": "PaneContainer.onDidChangeActivePane", "params": ["fn"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 88, "start_line": 86}, "call_info": {"func_end_line": 97, "code": "  observeActivePane (fn) {\r\n    fn(this.getActivePane())\r\n    return this.onDidChangeActivePane(fn)\r\n  }\r", "name": "onDidChangeActivePane", "func_location": "PaneContainer.observeActivePane", "args": ["fn"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 96, "func_start_line": 94}}, {"func_info": {"comment": [" Extended: Get the active {Pane}.", "", " Returns a {Pane}."], "name": "Workspace.getActivePane", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1444, "start_line": 1442}, "call_info": {"func_end_line": 815, "comment": [" Extended: Invoke the given callback with the current active pane and when", " the active pane changes.", "", " * `callback` {Function} to be called with the current and future active#", "   panes.", "   * `pane` A {Pane} that is the current return value of {::getActivePane}.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  observeActivePane (callback) {\r\n    callback(this.getActivePane())\r\n    return this.onDidChangeActivePane(callback)\r\n  }\r", "name": "getActivePane", "func_location": "Workspace.observeActivePane", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 813, "func_start_line": 812}}, {"func_info": {"comment": [" Extended: Invoke the given callback when the active pane changes.", "", " * `callback` {Function} to be called when the active pane changes.", "   * `pane` A {Pane} that is the current return value of {::getActivePane}.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "name": "Workspace.onDidChangeActivePane", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 802, "start_line": 800}, "call_info": {"func_end_line": 815, "comment": [" Extended: Invoke the given callback with the current active pane and when", " the active pane changes.", "", " * `callback` {Function} to be called with the current and future active#", "   panes.", "   * `pane` A {Pane} that is the current return value of {::getActivePane}.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  observeActivePane (callback) {\r\n    callback(this.getActivePane())\r\n    return this.onDidChangeActivePane(callback)\r\n  }\r", "name": "onDidChangeActivePane", "func_location": "Workspace.observeActivePane", "args": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 814, "func_start_line": 812}}, {"func_info": {"comment": [], "name": "PaneContainer.getActivePaneItem", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 164, "start_line": 162}, "call_info": {"func_end_line": 119, "code": "  observeActivePaneItem (fn) {\r\n    fn(this.getActivePaneItem())\r\n    return this.onDidChangeActivePaneItem(fn)\r\n  }\r", "name": "getActivePaneItem", "func_location": "PaneContainer.observeActivePaneItem", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 117, "func_start_line": 116}}, {"func_info": {"comment": [], "name": "PaneContainer.onDidChangeActivePaneItem", "params": ["fn"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 110, "start_line": 108}, "call_info": {"func_end_line": 119, "code": "  observeActivePaneItem (fn) {\r\n    fn(this.getActivePaneItem())\r\n    return this.onDidChangeActivePaneItem(fn)\r\n  }\r", "name": "onDidChangeActivePaneItem", "func_location": "PaneContainer.observeActivePaneItem", "args": ["fn"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 118, "func_start_line": 116}}, {"func_info": {"comment": [" Essential: Get the active {Pane}'s active item.", "", " Returns an pane item {Object}."], "name": "Workspace.getActivePaneItem", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1359, "start_line": 1357}, "call_info": {"func_end_line": 706, "comment": [" Essential: Invoke the given callback with the current active pane item and", " with all future active pane items in the workspace.", "", " * `callback` {Function} to be called when the active pane item changes.", "   * `item` The current active pane item.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  observeActivePaneItem (callback) {\r\n    callback(this.getActivePaneItem())\r\n    return this.onDidChangeActivePaneItem(callback)\r\n  }\r", "name": "getActivePaneItem", "func_location": "Workspace.observeActivePaneItem", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 704, "func_start_line": 703}}, {"func_info": {"comment": [" Essential: Invoke the given callback when the active pane item changes.", "", " Because observers are invoked synchronously, it's important not to perform", " any expensive operations via this method. Consider", " {::onDidStopChangingActivePaneItem} to delay operations until after changes", " stop occurring.", "", " * `callback` {Function} to be called when the active pane item changes.", "   * `item` The active pane item.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "name": "Workspace.onDidChangeActivePaneItem", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 664, "start_line": 662}, "call_info": {"func_end_line": 706, "comment": [" Essential: Invoke the given callback with the current active pane item and", " with all future active pane items in the workspace.", "", " * `callback` {Function} to be called when the active pane item changes.", "   * `item` The current active pane item.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  observeActivePaneItem (callback) {\r\n    callback(this.getActivePaneItem())\r\n    return this.onDidChangeActivePaneItem(callback)\r\n  }\r", "name": "onDidChangeActivePaneItem", "func_location": "Workspace.observeActivePaneItem", "args": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 705, "func_start_line": 703}}, {"func_info": {"comment": [" Essential: Get the workspace center's active item if it is a {TextEditor}.", "", " Returns a {TextEditor} or `undefined` if the workspace center's current", " active item is not a {TextEditor}."], "name": "Workspace.getActiveTextEditor", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1375, "start_line": 1372}, "call_info": {"func_end_line": 721, "comment": [" Essential: Invoke the given callback with the current active text editor", " (if any), with all future active text editors, and when there is no longer", " an active text editor.", "", " * `callback` {Function} to be called when the active text editor changes.", "   * `editor` The active {TextEditor} or undefined if there is not an", "      active text editor.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  observeActiveTextEditor (callback) {\r\n    callback(this.getActiveTextEditor())\r\n\r\n    return this.onDidChangeActiveTextEditor(callback)\r\n  }\r", "name": "getActiveTextEditor", "func_location": "Workspace.observeActiveTextEditor", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 718, "func_start_line": 717}}, {"func_info": {"comment": [" Essential: Invoke the given callback when a text editor becomes the active", " text editor and when there is no longer an active text editor.", "", " * `callback` {Function} to be called when the active text editor changes.", "   * `editor` The active {TextEditor} or undefined if there is no longer an", "      active text editor.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "name": "Workspace.onDidChangeActiveTextEditor", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 694, "start_line": 692}, "call_info": {"func_end_line": 721, "comment": [" Essential: Invoke the given callback with the current active text editor", " (if any), with all future active text editors, and when there is no longer", " an active text editor.", "", " * `callback` {Function} to be called when the active text editor changes.", "   * `editor` The active {TextEditor} or undefined if there is not an", "      active text editor.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  observeActiveTextEditor (callback) {\r\n    callback(this.getActiveTextEditor())\r\n\r\n    return this.onDidChangeActiveTextEditor(callback)\r\n  }\r", "name": "onDidChangeActiveTextEditor", "func_location": "Workspace.observeActiveTextEditor", "args": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 720, "func_start_line": 717}}, {"func_info": {"comment": [], "name": "AtomEnvironment.setAutoHideMenuBar", "params": ["autoHide"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1333, "start_line": 1330}, "call_info": {"func_end_line": 333, "code": "  observeAutoHideMenuBar () {\r\n    this.disposables.add(this.config.onDidChange('core.autoHideMenuBar', ({newValue}) => {\r\n      this.setAutoHideMenuBar(newValue)\r\n    }))\r\n    if (this.config.get('core.autoHideMenuBar')) this.setAutoHideMenuBar(true)\r\n  }\r", "name": "setAutoHideMenuBar", "func_location": "AtomEnvironment.observeAutoHideMenuBar", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 332, "func_start_line": 328}}, {"func_info": {"comment": [], "name": "TextEditorComponent.addBlockDecoration", "params": ["decoration", "subscribeToChanges"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2560, "start_line": 2508}, "call_info": {"func_end_line": 2506, "code": "  observeBlockDecorations () {\r\n    const {model} = this.props\r\n    const decorations = model.getDecorations({type: 'block'})\r\n    for (let i = 0; i < decorations.length; i++) {\r\n      this.addBlockDecoration(decorations[i])\r\n    }\r\n  }\r", "name": "addBlockDecoration", "func_location": "TextEditorComponent.observeBlockDecorations", "args": ["decorations.i"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2504, "func_start_line": 2500}}, {"func_info": {"comment": [" Retrieves all the {TextBuffer}s in the project; that is, the", " buffers for all open files.", "", " Returns an {Array} of {TextBuffer}s."], "name": "Project.getBuffers", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 623, "start_line": 621}, "call_info": {"func_end_line": 193, "comment": [" Public: Invoke the given callback with all current and future text", " buffers in the project.", "", " * `callback` {Function} to be called with current and future text buffers.", "   * `buffer` A {TextBuffer} item.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  observeBuffers (callback) {\r\n    for (let buffer of this.getBuffers()) { callback(buffer) }\r\n    return this.onDidAddBuffer(callback)\r\n  }\r", "name": "getBuffers", "func_location": "Project.observeBuffers", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 191, "func_start_line": 190}}, {"func_info": {"comment": [" Public: Invoke the given callback when a text buffer is added to the", " project.", "", " * `callback` {Function} to be called when a text buffer is added.", "   * `buffer` A {TextBuffer} item.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "name": "Project.onDidAddBuffer", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 181, "start_line": 179}, "call_info": {"func_end_line": 193, "comment": [" Public: Invoke the given callback with all current and future text", " buffers in the project.", "", " * `callback` {Function} to be called with current and future text buffers.", "   * `buffer` A {TextBuffer} item.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  observeBuffers (callback) {\r\n    for (let buffer of this.getBuffers()) { callback(buffer) }\r\n    return this.onDidAddBuffer(callback)\r\n  }\r", "name": "onDidAddBuffer", "func_location": "Project.observeBuffers", "args": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 192, "func_start_line": 190}}, {"func_info": {"comment": [" Extended: Calls your `callback` when a {Cursor} is added to the editor.", "", " * `callback` {Function}", "   * `cursor` {Cursor} that was added", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "name": "TextEditor.onDidAddCursor", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 847, "start_line": 845}, "call_info": {"func_end_line": 837, "comment": [" Extended: Calls your `callback` when a {Cursor} is added to the editor.", " Immediately calls your callback for each existing cursor.", "", " * `callback` {Function}", "   * `cursor` {Cursor} that was added", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  observeCursors (callback) {\r\n    this.getCursors().forEach(callback)\r\n    return this.onDidAddCursor(callback)\r\n  }\r", "name": "onDidAddCursor", "func_location": "TextEditor.observeCursors", "args": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 836, "func_start_line": 834}}, {"func_info": {"comment": [], "name": "DecorationManager.getDecorations", "params": ["propertyFilter"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js", "end_line": 56, "start_line": 40}, "call_info": {"func_end_line": 26, "code": "  observeDecorations (callback) {\r\n    const decorations = this.getDecorations()\r\n    for (let i = 0; i < decorations.length; i++) {\r\n      callback(decorations[i])\r\n    }\r\n    return this.onDidAddDecoration(callback)\r\n  }\r", "name": "getDecorations", "func_location": "DecorationManager.observeDecorations", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js", "line": 21, "func_start_line": 20}}, {"func_info": {"comment": [], "name": "DecorationManager.onDidAddDecoration", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js", "end_line": 30, "start_line": 28}, "call_info": {"func_end_line": 26, "code": "  observeDecorations (callback) {\r\n    const decorations = this.getDecorations()\r\n    for (let i = 0; i < decorations.length; i++) {\r\n      callback(decorations[i])\r\n    }\r\n    return this.onDidAddDecoration(callback)\r\n  }\r", "name": "onDidAddDecoration", "func_location": "DecorationManager.observeDecorations", "args": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration-manager.js", "line": 25, "func_start_line": 20}}, {"func_info": {"comment": [], "name": "PaneAxis.onDidChangeFlexScale", "params": ["fn"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js", "end_line": 110, "start_line": 108}, "call_info": {"func_end_line": 115, "code": "  observeFlexScale (fn) {\r\n    fn(this.flexScale)\r\n    return this.onDidChangeFlexScale(fn)\r\n  }\r", "name": "onDidChangeFlexScale", "func_location": "PaneAxis.observeFlexScale", "args": ["fn"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js", "line": 114, "func_start_line": 112}}, {"func_info": {"comment": ["\r\n  Section: Event Subscription\r\n  ", " Public: Invoke the given callback when the pane resizes", "", " The callback will be invoked when pane's flexScale property changes.", " Use {::getFlexScale} to get the current value.", "", " * `callback` {Function} to be called when the pane is resized", "   * `flexScale` {Number} representing the panes `flex-grow`; ability for a", "     flex item to grow if necessary.", "", " Returns a {Disposable} on which '.dispose()' can be called to unsubscribe."], "name": "Pane.onDidChangeFlexScale", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 186, "start_line": 184}, "call_info": {"func_end_line": 200, "comment": [" Public: Invoke the given callback with the current and future values of", " {::getFlexScale}.", "", " * `callback` {Function} to be called with the current and future values of", "   the {::getFlexScale} property.", "   * `flexScale` {Number} representing the panes `flex-grow`; ability for a", "     flex item to grow if necessary.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  observeFlexScale (callback) {\r\n    callback(this.flexScale)\r\n    return this.onDidChangeFlexScale(callback)\r\n  }\r", "name": "onDidChangeFlexScale", "func_location": "Pane.observeFlexScale", "args": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 199, "func_start_line": 197}}, {"func_info": {"comment": [" Extended: Calls your `callback` when the grammar that interprets and", " colorizes the text has been changed.", "", " * `callback` {Function}", "   * `grammar` {Grammar}", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "name": "TextEditor.onDidChangeGrammar", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 763, "start_line": 759}, "call_info": {"func_end_line": 750, "comment": [" Extended: Calls your `callback` when the grammar that interprets and", " colorizes the text has been changed. Immediately calls your callback with", " the current grammar.", "", " * `callback` {Function}", "   * `grammar` {Grammar}", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  observeGrammar (callback) {\r\n    callback(this.getGrammar())\r\n    return this.onDidChangeGrammar(callback)\r\n  }\r", "name": "onDidChangeGrammar", "func_location": "TextEditor.observeGrammar", "args": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 749, "func_start_line": 747}}, {"func_info": {"comment": [], "name": "GutterContainer.getGutters", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/gutter-container.js", "end_line": 57, "start_line": 55}, "call_info": {"func_end_line": 69, "code": "  observeGutters (callback) {\r\n    for (let gutter of this.getGutters()) { callback(gutter) }\r\n    return this.onDidAddGutter(callback)\r\n  }\r", "name": "getGutters", "func_location": "GutterContainer.observeGutters", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/gutter-container.js", "line": 67, "func_start_line": 66}}, {"func_info": {"comment": [], "name": "GutterContainer.onDidAddGutter", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/gutter-container.js", "end_line": 73, "start_line": 71}, "call_info": {"func_end_line": 69, "code": "  observeGutters (callback) {\r\n    for (let gutter of this.getGutters()) { callback(gutter) }\r\n    return this.onDidAddGutter(callback)\r\n  }\r", "name": "onDidAddGutter", "func_location": "GutterContainer.observeGutters", "args": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/gutter-container.js", "line": 68, "func_start_line": 66}}, {"func_info": {"comment": ["\r\n  Section: Items\r\n  ", " Public: Get the items in this pane.", "", " Returns an {Array} of items."], "name": "Pane.getItems", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 427, "start_line": 425}, "call_info": {"func_end_line": 319, "comment": [" Public: Invoke the given callback with all current and future items.", "", " * `callback` {Function} to be called with current and future items.", "   * `item` An item that is present in {::getItems} at the time of", "     subscription or that is added at some later time.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  observeItems (callback) {\r\n    for (let item of this.getItems()) {\r\n      callback(item)\r\n    }\r\n    return this.onDidAddItem(({item}) => callback(item))\r\n  }\r", "name": "getItems", "func_location": "Pane.observeItems", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 315, "func_start_line": 314}}, {"func_info": {"comment": [" Public: Invoke the given callback when an item is added to the pane.", "", " * `callback` {Function} to be called with when items are added.", "   * `event` {Object} with the following keys:", "     * `item` The added pane item.", "     * `index` {Number} indicating where the item is located.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "name": "Pane.onDidAddItem", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 270, "start_line": 268}, "call_info": {"func_end_line": 319, "comment": [" Public: Invoke the given callback with all current and future items.", "", " * `callback` {Function} to be called with current and future items.", "   * `item` An item that is present in {::getItems} at the time of", "     subscription or that is added at some later time.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  observeItems (callback) {\r\n    for (let item of this.getItems()) {\r\n      callback(item)\r\n    }\r\n    return this.onDidAddItem(({item}) => callback(item))\r\n  }\r", "name": "onDidAddItem", "func_location": "Pane.observeItems", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 318, "func_start_line": 314}}, {"func_info": {"comment": ["\r\n  Section: Managing Settings\r\n  ", " Essential: Retrieves the setting for the given key.", "", " ### Examples", "", " You might want to know what themes are enabled, so check `core.themes`", "", " ```coffee", " atom.config.get('core.themes')", " ```", "", " With scope descriptors you can get settings within a specific editor", " scope. For example, you might want to know `editor.tabLength` for ruby", " files.", "", " ```coffee", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " ```", "", " This setting in ruby files might be different than the global tabLength setting", "", " ```coffee", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " ```", "", " You can get the language scope descriptor via", " {TextEditor::getRootScopeDescriptor}. This will get the setting specifically", " for the editor's language.", "", " ```coffee", " atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2", " ```", "", " Additionally, you can get the setting at the specific cursor position.", "", " ```coffee", " scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()", " atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2", " ```", "", " * `keyPath` The {String} name of the key to retrieve.", " * `options` (optional) {Object}", "   * `sources` (optional) {Array} of {String} source names. If provided, only", "     values that were associated with these sources during {::set} will be used.", "   * `excludeSources` (optional) {Array} of {String} source names. If provided,", "     values that  were associated with these sources during {::set} will not", "     be used.", "   * `scope` (optional) {ScopeDescriptor} describing a path from", "     the root of the syntax tree to a token. Get one by calling", "     {editor.getLastCursor().getScopeDescriptor()}", "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)", "     for more information.", "", " Returns the value from Atom's default settings, the user's configuration", " file in the type specified by the configuration schema."], "name": "Config.get", "params": ["args"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 602, "start_line": 585}, "call_info": {"func_end_line": 1044, "code": "  observeKeyPath (keyPath, options, callback) {\r\n    callback(this.get(keyPath))\r\n    return this.onDidChangeKeyPath(keyPath, event => callback(event.newValue))\r\n  }\r", "name": "get", "func_location": "Config.observeKeyPath", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1042, "func_start_line": 1041}}, {"func_info": {"comment": [], "name": "Config.onDidChangeKeyPath", "params": ["keyPath", "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1056, "start_line": 1046}, "call_info": {"func_end_line": 1044, "code": "  observeKeyPath (keyPath, options, callback) {\r\n    callback(this.get(keyPath))\r\n    return this.onDidChangeKeyPath(keyPath, event => callback(event.newValue))\r\n  }\r", "name": "onDidChangeKeyPath", "func_location": "Config.observeKeyPath", "args": ["keyPath", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1043, "func_start_line": 1041}}, {"func_info": {"comment": [], "name": "PaneContainer.getPaneItems", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 156, "start_line": 154}, "call_info": {"func_end_line": 106, "code": "  observePaneItems (fn) {\r\n    for (let item of this.getPaneItems()) { fn(item) }\r\n    return this.onDidAddPaneItem(({item}) => fn(item))\r\n  }\r", "name": "getPaneItems", "func_location": "PaneContainer.observePaneItems", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 104, "func_start_line": 103}}, {"func_info": {"comment": [], "name": "PaneContainer.onDidAddPaneItem", "params": ["fn"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 101, "start_line": 99}, "call_info": {"func_end_line": 106, "code": "  observePaneItems (fn) {\r\n    for (let item of this.getPaneItems()) { fn(item) }\r\n    return this.onDidAddPaneItem(({item}) => fn(item))\r\n  }\r", "name": "onDidAddPaneItem", "func_location": "PaneContainer.observePaneItems", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 105, "func_start_line": 103}}, {"func_info": {"comment": [], "name": "Workspace.getPaneContainers", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1625, "start_line": 1618}, "call_info": {"func_end_line": 649, "comment": [" Essential: Invoke the given callback with all current and future panes items", " in the workspace.", "", " * `callback` {Function} to be called with current and future pane items.", "   * `item` An item that is present in {::getPaneItems} at the time of", "      subscription or that is added at some later time.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  observePaneItems (callback) {\r\n    return new CompositeDisposable(\r\n      ...this.getPaneContainers().map(container => container.observePaneItems(callback))\r\n    )\r\n  }\r", "name": "getPaneContainers", "func_location": "Workspace.observePaneItems", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 647, "func_start_line": 645}}, {"func_info": {"comment": [], "name": "PaneContainer.getPanes", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 152, "start_line": 146}, "call_info": {"func_end_line": 76, "code": "  observePanes (fn) {\r\n    for (let pane of this.getPanes()) { fn(pane) }\r\n    return this.onDidAddPane(({pane}) => fn(pane))\r\n  }\r", "name": "getPanes", "func_location": "PaneContainer.observePanes", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 74, "func_start_line": 73}}, {"func_info": {"comment": [], "name": "PaneContainer.onDidAddPane", "params": ["fn"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 71, "start_line": 69}, "call_info": {"func_end_line": 76, "code": "  observePanes (fn) {\r\n    for (let pane of this.getPanes()) { fn(pane) }\r\n    return this.onDidAddPane(({pane}) => fn(pane))\r\n  }\r", "name": "onDidAddPane", "func_location": "PaneContainer.observePanes", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 75, "func_start_line": 73}}, {"func_info": {"comment": [], "name": "Workspace.getPaneContainers", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1625, "start_line": 1618}, "call_info": {"func_end_line": 792, "comment": [" Extended: Invoke the given callback with all current and future panes in the", " workspace.", "", " * `callback` {Function} to be called with current and future panes.", "   * `pane` A {Pane} that is present in {::getPanes} at the time of", "      subscription or that is added at some later time.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  observePanes (callback) {\r\n    return new CompositeDisposable(\r\n      ...this.getPaneContainers().map(container => container.observePanes(callback))\r\n    )\r\n  }\r", "name": "getPaneContainers", "func_location": "Workspace.observePanes", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 790, "func_start_line": 788}}, {"func_info": {"comment": [" Public: Invoke the given callback when a repository is added to the", " project.", "", " * `callback` {Function} to be called when a repository is added.", "   * `repository` A {GitRepository}.", "", " Returns a {Disposable} on which `.dispose()` can be called to", " unsubscribe."], "name": "Project.onDidAddRepository", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 267, "start_line": 265}, "call_info": {"func_end_line": 255, "comment": [" Public: Invoke the given callback with all current and future", " repositories in the project.", "", " * `callback` {Function} to be called with current and future", "    repositories.", "   * `repository` A {GitRepository} that is present at the time of", "     subscription or that is added at some later time.", "", " Returns a {Disposable} on which `.dispose()` can be called to", " unsubscribe."], "code": "  observeRepositories (callback) {\r\n    for (const repo of this.repositories) {\r\n      if (repo != null) {\r\n        callback(repo)\r\n      }\r\n    }\r\n\r\n    return this.onDidAddRepository(callback)\r\n  }\r", "name": "onDidAddRepository", "func_location": "Project.observeRepositories", "args": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 254, "func_start_line": 247}}, {"func_info": {"comment": [], "name": "PaneContainer.getRoot", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 129, "start_line": 129}, "call_info": {"func_end_line": 67, "code": "  observeRoot (fn) {\r\n    fn(this.getRoot())\r\n    return this.onDidChangeRoot(fn)\r\n  }\r", "name": "getRoot", "func_location": "PaneContainer.observeRoot", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 65, "func_start_line": 64}}, {"func_info": {"comment": [], "name": "PaneContainer.onDidChangeRoot", "params": ["fn"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 62, "start_line": 60}, "call_info": {"func_end_line": 67, "code": "  observeRoot (fn) {\r\n    fn(this.getRoot())\r\n    return this.onDidChangeRoot(fn)\r\n  }\r", "name": "onDidChangeRoot", "func_location": "PaneContainer.observeRoot", "args": ["fn"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 66, "func_start_line": 64}}, {"func_info": {"comment": ["\r\n  Section: Managing Settings\r\n  ", " Essential: Retrieves the setting for the given key.", "", " ### Examples", "", " You might want to know what themes are enabled, so check `core.themes`", "", " ```coffee", " atom.config.get('core.themes')", " ```", "", " With scope descriptors you can get settings within a specific editor", " scope. For example, you might want to know `editor.tabLength` for ruby", " files.", "", " ```coffee", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " ```", "", " This setting in ruby files might be different than the global tabLength setting", "", " ```coffee", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " ```", "", " You can get the language scope descriptor via", " {TextEditor::getRootScopeDescriptor}. This will get the setting specifically", " for the editor's language.", "", " ```coffee", " atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2", " ```", "", " Additionally, you can get the setting at the specific cursor position.", "", " ```coffee", " scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()", " atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2", " ```", "", " * `keyPath` The {String} name of the key to retrieve.", " * `options` (optional) {Object}", "   * `sources` (optional) {Array} of {String} source names. If provided, only", "     values that were associated with these sources during {::set} will be used.", "   * `excludeSources` (optional) {Array} of {String} source names. If provided,", "     values that  were associated with these sources during {::set} will not", "     be used.", "   * `scope` (optional) {ScopeDescriptor} describing a path from", "     the root of the syntax tree to a token. Get one by calling", "     {editor.getLastCursor().getScopeDescriptor()}", "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)", "     for more information.", "", " Returns the value from Atom's default settings, the user's configuration", " file in the type specified by the configuration schema."], "name": "Config.get", "params": ["args"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 602, "start_line": 585}, "call_info": {"func_end_line": 1267, "code": "  observeScopedKeyPath (scope, keyPath, callback) {\r\n    callback(this.get(keyPath, {scope}))\r\n    return this.onDidChangeScopedKeyPath(scope, keyPath, event => callback(event.newValue))\r\n  }\r", "name": "get", "func_location": "Config.observeScopedKeyPath", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1265, "func_start_line": 1264}}, {"func_info": {"comment": [], "name": "Config.onDidChangeScopedKeyPath", "params": ["scope", "keyPath", "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1279, "start_line": 1269}, "call_info": {"func_end_line": 1267, "code": "  observeScopedKeyPath (scope, keyPath, callback) {\r\n    callback(this.get(keyPath, {scope}))\r\n    return this.onDidChangeScopedKeyPath(scope, keyPath, event => callback(event.newValue))\r\n  }\r", "name": "onDidChangeScopedKeyPath", "func_location": "Config.observeScopedKeyPath", "args": ["scope", "keyPath", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1266, "func_start_line": 1264}}, {"func_info": {"comment": [" Extended: Calls your `callback` when a {Selection} is added to the editor.", "", " * `callback` {Function}", "   * `selection` {Selection} that was added", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "name": "TextEditor.onDidAddSelection", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 879, "start_line": 877}, "call_info": {"func_end_line": 869, "comment": [" Extended: Calls your `callback` when a {Selection} is added to the editor.", " Immediately calls your callback for each existing selection.", "", " * `callback` {Function}", "   * `selection` {Selection} that was added", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  observeSelections (callback) {\r\n    this.getSelections().forEach(callback)\r\n    return this.onDidAddSelection(callback)\r\n  }\r", "name": "onDidAddSelection", "func_location": "TextEditor.observeSelections", "args": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 868, "func_start_line": 866}}, {"func_info": {"comment": ["\r\n  Section: Reading Style Elements\r\n  ", " Extended: Get all loaded style elements."], "name": "StyleManager.getStyleElements", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js", "end_line": 115, "start_line": 113}, "call_info": {"func_end_line": 55, "comment": ["\r\n  Section: Event Subscription\r\n  ", " Extended: Invoke `callback` for all current and future style elements.", "", " * `callback` {Function} that is called with style elements.", "   * `styleElement` An `HTMLStyleElement` instance. The `.sheet` property", "     will be null because this element isn't attached to the DOM. If you want", "     to attach this element to the DOM, be sure to clone it first by calling", "     `.cloneNode(true)` on it. The style element will also have the following", "     non-standard properties:", "     * `sourcePath` A {String} containing the path from which the style", "       element was loaded.", "     * `context` A {String} indicating the target context of the style", "       element.", "", " Returns a {Disposable} on which `.dispose()` can be called to cancel the", " subscription."], "code": "  observeStyleElements (callback) {\r\n    for (let styleElement of this.getStyleElements()) {\r\n      callback(styleElement)\r\n    }\r\n\r\n    return this.onDidAddStyleElement(callback)\r\n  }\r", "name": "getStyleElements", "func_location": "StyleManager.observeStyleElements", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js", "line": 50, "func_start_line": 49}}, {"func_info": {"comment": [" Extended: Invoke `callback` when a style element is added.", "", " * `callback` {Function} that is called with style elements.", "   * `styleElement` An `HTMLStyleElement` instance. The `.sheet` property", "     will be null because this element isn't attached to the DOM. If you want", "     to attach this element to the DOM, be sure to clone it first by calling", "     `.cloneNode(true)` on it. The style element will also have the following", "     non-standard properties:", "     * `sourcePath` A {String} containing the path from which the style", "       element was loaded.", "     * `context` A {String} indicating the target context of the style", "       element.", "", " Returns a {Disposable} on which `.dispose()` can be called to cancel the", " subscription."], "name": "StyleManager.onDidAddStyleElement", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js", "end_line": 74, "start_line": 72}, "call_info": {"func_end_line": 55, "comment": ["\r\n  Section: Event Subscription\r\n  ", " Extended: Invoke `callback` for all current and future style elements.", "", " * `callback` {Function} that is called with style elements.", "   * `styleElement` An `HTMLStyleElement` instance. The `.sheet` property", "     will be null because this element isn't attached to the DOM. If you want", "     to attach this element to the DOM, be sure to clone it first by calling", "     `.cloneNode(true)` on it. The style element will also have the following", "     non-standard properties:", "     * `sourcePath` A {String} containing the path from which the style", "       element was loaded.", "     * `context` A {String} indicating the target context of the style", "       element.", "", " Returns a {Disposable} on which `.dispose()` can be called to cancel the", " subscription."], "code": "  observeStyleElements (callback) {\r\n    for (let styleElement of this.getStyleElements()) {\r\n      callback(styleElement)\r\n    }\r\n\r\n    return this.onDidAddStyleElement(callback)\r\n  }\r", "name": "onDidAddStyleElement", "func_location": "StyleManager.observeStyleElements", "args": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js", "line": 54, "func_start_line": 49}}, {"func_info": {"comment": [], "name": "WorkspaceElement.updateGlobalTextEditorStyleSheet", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "end_line": 65, "start_line": 58}, "call_info": {"func_end_line": 56, "code": "  observeTextEditorFontConfig () {\r\n    this.updateGlobalTextEditorStyleSheet()\r\n    this.subscriptions.add(this.config.onDidChange('editor.fontSize', this.updateGlobalTextEditorStyleSheet.bind(this)))\r\n    this.subscriptions.add(this.config.onDidChange('editor.fontFamily', this.updateGlobalTextEditorStyleSheet.bind(this)))\r\n    this.subscriptions.add(this.config.onDidChange('editor.lineHeight', this.updateGlobalTextEditorStyleSheet.bind(this)))\r\n  }\r", "name": "updateGlobalTextEditorStyleSheet", "func_location": "WorkspaceElement.observeTextEditorFontConfig", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-element.js", "line": 52, "func_start_line": 51}}, {"func_info": {"comment": [" Essential: Get all text editors in the workspace center.", "", " Returns an {Array} of {TextEditor}s."], "name": "WorkspaceCenter.getTextEditors", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js", "end_line": 272, "start_line": 270}, "call_info": {"func_end_line": 61, "comment": ["\r\n  Section: Event Subscription\r\n  ", " Essential: Invoke the given callback with all current and future text", " editors in the workspace center.", "", " * `callback` {Function} to be called with current and future text editors.", "   * `editor` An {TextEditor} that is present in {::getTextEditors} at the time", "     of subscription or that is added at some later time.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  observeTextEditors (callback) {\r\n    for (let textEditor of this.getTextEditors()) { callback(textEditor) }\r\n    return this.onDidAddTextEditor(({textEditor}) => callback(textEditor))\r\n  }\r", "name": "getTextEditors", "func_location": "WorkspaceCenter.observeTextEditors", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js", "line": 59, "func_start_line": 58}}, {"func_info": {"comment": [" Extended: Invoke the given callback when a text editor is added to the", " workspace center.", "", " * `callback` {Function} to be called when panes are added.", "   * `event` {Object} with the following keys:", "     * `textEditor` {TextEditor} that was added.", "     * `pane` {Pane} containing the added text editor.", "     * `index` {Number} indicating the index of the added text editor in its", "        pane.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "name": "WorkspaceCenter.onDidAddTextEditor", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js", "end_line": 247, "start_line": 241}, "call_info": {"func_end_line": 61, "comment": ["\r\n  Section: Event Subscription\r\n  ", " Essential: Invoke the given callback with all current and future text", " editors in the workspace center.", "", " * `callback` {Function} to be called with current and future text editors.", "   * `editor` An {TextEditor} that is present in {::getTextEditors} at the time", "     of subscription or that is added at some later time.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  observeTextEditors (callback) {\r\n    for (let textEditor of this.getTextEditors()) { callback(textEditor) }\r\n    return this.onDidAddTextEditor(({textEditor}) => callback(textEditor))\r\n  }\r", "name": "onDidAddTextEditor", "func_location": "WorkspaceCenter.observeTextEditors", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js", "line": 60, "func_start_line": 58}}, {"func_info": {"comment": [" Essential: Get all text editors in the workspace.", "", " Returns an {Array} of {TextEditor}s."], "name": "Workspace.getTextEditors", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1366, "start_line": 1364}, "call_info": {"func_end_line": 635, "comment": [" Essential: Invoke the given callback with all current and future text", " editors in the workspace.", "", " * `callback` {Function} to be called with current and future text editors.", "   * `editor` A {TextEditor} that is present in {::getTextEditors} at the time", "     of subscription or that is added at some later time.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  observeTextEditors (callback) {\r\n    for (let textEditor of this.getTextEditors()) { callback(textEditor) }\r\n    return this.onDidAddTextEditor(({textEditor}) => callback(textEditor))\r\n  }\r", "name": "getTextEditors", "func_location": "Workspace.observeTextEditors", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 633, "func_start_line": 632}}, {"func_info": {"comment": [" Extended: Invoke the given callback when a text editor is added to the", " workspace.", "", " * `callback` {Function} to be called panes are added.", "   * `event` {Object} with the following keys:", "     * `textEditor` {TextEditor} that was added.", "     * `pane` {Pane} containing the added text editor.", "     * `index` {Number} indicating the index of the added text editor in its", "        pane.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "name": "Workspace.onDidAddTextEditor", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 880, "start_line": 878}, "call_info": {"func_end_line": 635, "comment": [" Essential: Invoke the given callback with all current and future text", " editors in the workspace.", "", " * `callback` {Function} to be called with current and future text editors.", "   * `editor` A {TextEditor} that is present in {::getTextEditors} at the time", "     of subscription or that is added at some later time.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  observeTextEditors (callback) {\r\n    for (let textEditor of this.getTextEditors()) { callback(textEditor) }\r\n    return this.onDidAddTextEditor(({textEditor}) => callback(textEditor))\r\n  }\r", "name": "onDidAddTextEditor", "func_location": "Workspace.observeTextEditors", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 634, "func_start_line": 632}}, {"func_info": {"comment": [" Extended: Check if the dock is visible.", "", " Returns a {Boolean}."], "name": "Dock.isVisible", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 142, "start_line": 140}, "call_info": {"func_end_line": 457, "comment": [" Essential: Invoke the given callback with the current and all future visibilities of the dock.", "", " * `callback` {Function} to be called when the visibility changes.", "   * `visible` {Boolean} Is the dock now visible?", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  observeVisible (callback) {\r\n    callback(this.isVisible())\r\n    return this.onDidChangeVisible(callback)\r\n  }\r", "name": "isVisible", "func_location": "Dock.observeVisible", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 455, "func_start_line": 454}}, {"func_info": {"comment": ["\r\n  Section: Event Subscription\r\n  ", " Essential: Invoke the given callback when the visibility of the dock changes.", "", " * `callback` {Function} to be called when the visibility changes.", "   * `visible` {Boolean} Is the dock now visible?", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "name": "Dock.onDidChangeVisible", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 446, "start_line": 444}, "call_info": {"func_end_line": 457, "comment": [" Essential: Invoke the given callback with the current and all future visibilities of the dock.", "", " * `callback` {Function} to be called when the visibility changes.", "   * `visible` {Boolean} Is the dock now visible?", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  observeVisible (callback) {\r\n    callback(this.isVisible())\r\n    return this.onDidChangeVisible(callback)\r\n  }\r", "name": "onDidChangeVisible", "func_location": "Dock.observeVisible", "args": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 456, "func_start_line": 454}}, {"func_info": {"comment": [], "name": "Workspace.getPaneContainers", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1625, "start_line": 1618}, "call_info": {"func_end_line": 750, "comment": [" Extended: Invoke the given callback when a pane is added to the workspace.", "", " * `callback` {Function} to be called panes are added.", "   * `event` {Object} with the following keys:", "     * `pane` The added pane.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  onDidAddPane (callback) {\r\n    return new CompositeDisposable(\r\n      ...this.getPaneContainers().map(container => container.onDidAddPane(callback))\r\n    )\r\n  }\r", "name": "getPaneContainers", "func_location": "Workspace.onDidAddPane", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 748, "func_start_line": 746}}, {"func_info": {"comment": [], "name": "Workspace.getPaneContainers", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1625, "start_line": 1618}, "call_info": {"func_end_line": 831, "comment": [" Extended: Invoke the given callback when a pane item is added to the", " workspace.", "", " * `callback` {Function} to be called when pane items are added.", "   * `event` {Object} with the following keys:", "     * `item` The added pane item.", "     * `pane` {Pane} containing the added item.", "     * `index` {Number} indicating the index of the added item in its pane.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  onDidAddPaneItem (callback) {\r\n    return new CompositeDisposable(\r\n      ...this.getPaneContainers().map(container => container.onDidAddPaneItem(callback))\r\n    )\r\n  }\r", "name": "getPaneContainers", "func_location": "Workspace.onDidAddPaneItem", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 829, "func_start_line": 827}}, {"func_info": {"comment": [" Extended: Invoke the given callback when a pane item is added to the", " workspace center.", "", " * `callback` {Function} to be called when pane items are added.", "   * `event` {Object} with the following keys:", "     * `item` The added pane item.", "     * `pane` {Pane} containing the added item.", "     * `index` {Number} indicating the index of the added item in its pane.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "name": "WorkspaceCenter.onDidAddPaneItem", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js", "end_line": 199, "start_line": 197}, "call_info": {"func_end_line": 247, "name": "onDidAddPaneItem", "func_location": "WorkspaceCenter.onDidAddTextEditor", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace-center.js", "line": 242, "func_start_line": 241}}, {"func_info": {"comment": [], "name": "ApplicationDelegate.ipcMessageEmitter", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js", "end_line": 21, "start_line": 13}, "call_info": {"func_end_line": 283, "code": "  onDidBeginCheckingForUpdate (callback) {\r\n    return this.ipcMessageEmitter().on('checking-for-update', callback)\r\n  }\r", "name": "ipcMessageEmitter", "func_location": "ApplicationDelegate.onDidBeginCheckingForUpdate", "args": [{"type": "string"}, "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js", "line": 282, "func_start_line": 281}}, {"func_info": {"comment": [], "name": "ApplicationDelegate.onUpdateAvailable", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js", "end_line": 275, "start_line": 270}, "call_info": {"func_end_line": 279, "code": "  onDidBeginDownloadingUpdate (callback) {\r\n    return this.onUpdateAvailable(callback)\r\n  }\r", "name": "onUpdateAvailable", "func_location": "ApplicationDelegate.onDidBeginDownloadingUpdate", "args": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js", "line": 278, "func_start_line": 277}}, {"func_info": {"comment": [" Private: Begin watching for filesystem events.", "", " Has no effect if the watcher has already been started."], "name": "NativeWatcher.start", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js", "end_line": 55, "start_line": 45}, "call_info": {"func_end_line": 88, "comment": [" Private: Register a callback to be invoked with normalized filesystem events as they arrive. Starts the watcher", " automatically if it is not already running. The watcher will be stopped automatically when all subscribers", " dispose their subscriptions.", "", " Returns: A {Disposable} to revoke the subscription."], "code": "  onDidChange (callback) {\r\n    this.start()\r\n\r\n    const sub = this.emitter.on('did-change', callback)\r\n    return new Disposable(() => {\r\n      sub.dispose()\r\n      if (this.emitter.listenerCountForEventName('did-change') === 0) {\r\n        this.stop()\r\n      }\r\n    })\r\n  }\r", "name": "start", "func_location": "NativeWatcher.onDidChange", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js", "line": 79, "func_start_line": 78}}, {"func_info": {"comment": [], "name": "Config.onDidChangeScopedKeyPath", "params": ["scope", "keyPath", "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1279, "start_line": 1269}, "call_info": {"func_end_line": 524, "comment": [" Essential: Add a listener for changes to a given key path. If `keyPath` is", " not specified, your callback will be called on changes to any key.", "", " * `keyPath` (optional) {String} name of the key to observe. Must be", "   specified if `scopeDescriptor` is specified.", " * `options` (optional) {Object}", "   * `scope` (optional) {ScopeDescriptor} describing a path from", "     the root of the syntax tree to a token. Get one by calling", "     {editor.getLastCursor().getScopeDescriptor()}. See {::get} for examples.", "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)", "     for more information.", " * `callback` {Function} to call when the value of the key changes.", "   * `event` {Object}", "     * `newValue` the new value of the key", "     * `oldValue` the prior value of the key.", "", " Returns a {Disposable} with the following keys on which you can call", " `.dispose()` to unsubscribe."], "code": "  onDidChange (...args) {\r\n    let callback, keyPath, scopeDescriptor\r\n    if (args.length === 1) {\r\n      [callback] = args\r\n    } else if (args.length === 2) {\r\n      [keyPath, callback] = args\r\n    } else {\r\n      let options;\r\n      [keyPath, options, callback] = args\r\n      scopeDescriptor = options.scope\r\n    }\r\n\r\n    if (scopeDescriptor != null) {\r\n      return this.onDidChangeScopedKeyPath(scopeDescriptor, keyPath, callback)\r\n    } else {\r\n      return this.onDidChangeKeyPath(keyPath, callback)\r\n    }\r\n  }\r", "name": "onDidChangeScopedKeyPath", "func_location": "Config.onDidChange", "args": ["scopeDescriptor", "keyPath", "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 520, "func_start_line": 507}}, {"func_info": {"comment": [], "name": "Config.onDidChangeKeyPath", "params": ["keyPath", "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1056, "start_line": 1046}, "call_info": {"func_end_line": 524, "comment": [" Essential: Add a listener for changes to a given key path. If `keyPath` is", " not specified, your callback will be called on changes to any key.", "", " * `keyPath` (optional) {String} name of the key to observe. Must be", "   specified if `scopeDescriptor` is specified.", " * `options` (optional) {Object}", "   * `scope` (optional) {ScopeDescriptor} describing a path from", "     the root of the syntax tree to a token. Get one by calling", "     {editor.getLastCursor().getScopeDescriptor()}. See {::get} for examples.", "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)", "     for more information.", " * `callback` {Function} to call when the value of the key changes.", "   * `event` {Object}", "     * `newValue` the new value of the key", "     * `oldValue` the prior value of the key.", "", " Returns a {Disposable} with the following keys on which you can call", " `.dispose()` to unsubscribe."], "code": "  onDidChange (...args) {\r\n    let callback, keyPath, scopeDescriptor\r\n    if (args.length === 1) {\r\n      [callback] = args\r\n    } else if (args.length === 2) {\r\n      [keyPath, callback] = args\r\n    } else {\r\n      let options;\r\n      [keyPath, options, callback] = args\r\n      scopeDescriptor = options.scope\r\n    }\r\n\r\n    if (scopeDescriptor != null) {\r\n      return this.onDidChangeScopedKeyPath(scopeDescriptor, keyPath, callback)\r\n    } else {\r\n      return this.onDidChangeKeyPath(keyPath, callback)\r\n    }\r\n  }\r", "name": "onDidChangeKeyPath", "func_location": "Config.onDidChange", "args": ["keyPath", "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 522, "func_start_line": 507}}, {"func_info": {"comment": ["\r\n  Section: Managing Settings\r\n  ", " Essential: Retrieves the setting for the given key.", "", " ### Examples", "", " You might want to know what themes are enabled, so check `core.themes`", "", " ```coffee", " atom.config.get('core.themes')", " ```", "", " With scope descriptors you can get settings within a specific editor", " scope. For example, you might want to know `editor.tabLength` for ruby", " files.", "", " ```coffee", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " ```", "", " This setting in ruby files might be different than the global tabLength setting", "", " ```coffee", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " ```", "", " You can get the language scope descriptor via", " {TextEditor::getRootScopeDescriptor}. This will get the setting specifically", " for the editor's language.", "", " ```coffee", " atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2", " ```", "", " Additionally, you can get the setting at the specific cursor position.", "", " ```coffee", " scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()", " atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2", " ```", "", " * `keyPath` The {String} name of the key to retrieve.", " * `options` (optional) {Object}", "   * `sources` (optional) {Array} of {String} source names. If provided, only", "     values that were associated with these sources during {::set} will be used.", "   * `excludeSources` (optional) {Array} of {String} source names. If provided,", "     values that  were associated with these sources during {::set} will not", "     be used.", "   * `scope` (optional) {ScopeDescriptor} describing a path from", "     the root of the syntax tree to a token. Get one by calling", "     {editor.getLastCursor().getScopeDescriptor()}", "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)", "     for more information.", "", " Returns the value from Atom's default settings, the user's configuration", " file in the type specified by the configuration schema."], "name": "Config.get", "params": ["args"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 602, "start_line": 585}, "call_info": {"func_end_line": 1056, "code": "  onDidChangeKeyPath (keyPath, callback) {\r\n    let oldValue = this.get(keyPath)\r\n    return this.emitter.on('did-change', () => {\r\n      const newValue = this.get(keyPath)\r\n      if (!_.isEqual(oldValue, newValue)) {\r\n        const event = {oldValue, newValue}\r\n        oldValue = newValue\r\n        return callback(event)\r\n      }\r\n    })\r\n  }\r", "name": "get", "func_location": "Config.onDidChangeKeyPath", "args": ["keyPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1047, "func_start_line": 1046}}, {"func_info": {"comment": [" Essential: Retrieves the current {TextBuffer}."], "name": "TextEditor.getBuffer", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 963, "start_line": 963}, "call_info": {"func_end_line": 772, "comment": [" Extended: Calls your `callback` when the result of {::isModified} changes.", "", " * `callback` {Function}", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  onDidChangeModified (callback) {\r\n    return this.getBuffer().onDidChangeModified(callback)\r\n  }\r", "name": "getBuffer", "func_location": "TextEditor.onDidChangeModified", "args": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 771, "func_start_line": 770}}, {"func_info": {"comment": ["\r\n  Section: Managing Settings\r\n  ", " Essential: Retrieves the setting for the given key.", "", " ### Examples", "", " You might want to know what themes are enabled, so check `core.themes`", "", " ```coffee", " atom.config.get('core.themes')", " ```", "", " With scope descriptors you can get settings within a specific editor", " scope. For example, you might want to know `editor.tabLength` for ruby", " files.", "", " ```coffee", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " ```", "", " This setting in ruby files might be different than the global tabLength setting", "", " ```coffee", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " ```", "", " You can get the language scope descriptor via", " {TextEditor::getRootScopeDescriptor}. This will get the setting specifically", " for the editor's language.", "", " ```coffee", " atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2", " ```", "", " Additionally, you can get the setting at the specific cursor position.", "", " ```coffee", " scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()", " atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2", " ```", "", " * `keyPath` The {String} name of the key to retrieve.", " * `options` (optional) {Object}", "   * `sources` (optional) {Array} of {String} source names. If provided, only", "     values that were associated with these sources during {::set} will be used.", "   * `excludeSources` (optional) {Array} of {String} source names. If provided,", "     values that  were associated with these sources during {::set} will not", "     be used.", "   * `scope` (optional) {ScopeDescriptor} describing a path from", "     the root of the syntax tree to a token. Get one by calling", "     {editor.getLastCursor().getScopeDescriptor()}", "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)", "     for more information.", "", " Returns the value from Atom's default settings, the user's configuration", " file in the type specified by the configuration schema."], "name": "Config.get", "params": ["args"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 602, "start_line": 585}, "call_info": {"func_end_line": 1279, "code": "  onDidChangeScopedKeyPath (scope, keyPath, callback) {\r\n    let oldValue = this.get(keyPath, {scope})\r\n    return this.emitter.on('did-change', () => {\r\n      const newValue = this.get(keyPath, {scope})\r\n      if (!_.isEqual(oldValue, newValue)) {\r\n        const event = {oldValue, newValue}\r\n        oldValue = newValue\r\n        callback(event)\r\n      }\r\n    })\r\n  }\r", "name": "get", "func_location": "Config.onDidChangeScopedKeyPath", "args": ["keyPath", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1270, "func_start_line": 1269}}, {"func_info": {"comment": [], "name": "ApplicationDelegate.ipcMessageEmitter", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js", "end_line": 21, "start_line": 13}, "call_info": {"func_end_line": 206, "code": "  onDidChangeUserSettings (callback) {\r\n    return this.ipcMessageEmitter().on('did-change-user-settings', detail => {\r\n      if (this.pendingSettingsUpdateCount === 0) callback(detail)\r\n    })\r\n  }\r", "name": "ipcMessageEmitter", "func_location": "ApplicationDelegate.onDidChangeUserSettings", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js", "line": 203, "func_start_line": 202}}, {"func_info": {"comment": [], "name": "ApplicationDelegate.ipcMessageEmitter", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js", "end_line": 21, "start_line": 13}, "call_info": {"func_end_line": 287, "code": "  onDidCompleteDownloadingUpdate (callback) {\r\n    return this.ipcMessageEmitter().on('update-available', callback)\r\n  }\r", "name": "ipcMessageEmitter", "func_location": "ApplicationDelegate.onDidCompleteDownloadingUpdate", "args": [{"type": "string"}, "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js", "line": 286, "func_start_line": 285}}, {"func_info": {"comment": [" Essential: Retrieves the current {TextBuffer}."], "name": "TextEditor.getBuffer", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 963, "start_line": 963}, "call_info": {"func_end_line": 782, "comment": [" Extended: Calls your `callback` when the buffer's underlying file changes on", " disk at a moment when the result of {::isModified} is true.", "", " * `callback` {Function}", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  onDidConflict (callback) {\r\n    return this.getBuffer().onDidConflict(callback)\r\n  }\r", "name": "getBuffer", "func_location": "TextEditor.onDidConflict", "args": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 781, "func_start_line": 780}}, {"func_info": {"comment": [], "name": "Workspace.getPaneContainers", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1625, "start_line": 1618}, "call_info": {"func_end_line": 778, "comment": [" Extended: Invoke the given callback when a pane is destroyed in the", " workspace.", "", " * `callback` {Function} to be called panes are destroyed.", "   * `event` {Object} with the following keys:", "     * `pane` The destroyed pane.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  onDidDestroyPane (callback) {\r\n    return new CompositeDisposable(\r\n      ...this.getPaneContainers().map(container => container.onDidDestroyPane(callback))\r\n    )\r\n  }\r", "name": "getPaneContainers", "func_location": "Workspace.onDidDestroyPane", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 776, "func_start_line": 774}}, {"func_info": {"comment": [], "name": "Workspace.getPaneContainers", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1625, "start_line": 1618}, "call_info": {"func_end_line": 865, "comment": [" Extended: Invoke the given callback when a pane item is destroyed.", "", " * `callback` {Function} to be called when pane items are destroyed.", "   * `event` {Object} with the following keys:", "     * `item` The destroyed item.", "     * `pane` {Pane} containing the destroyed item.", "     * `index` {Number} indicating the index of the destroyed item in its", "       pane.", "", " Returns a {Disposable} on which `.dispose` can be called to unsubscribe."], "code": "  onDidDestroyPaneItem (callback) {\r\n    return new CompositeDisposable(\r\n      ...this.getPaneContainers().map(container => container.onDidDestroyPaneItem(callback))\r\n    )\r\n  }\r", "name": "getPaneContainers", "func_location": "Workspace.onDidDestroyPaneItem", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 863, "func_start_line": 861}}, {"func_info": {"comment": [], "name": "ApplicationDelegate.ipcMessageEmitter", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js", "end_line": 21, "start_line": 13}, "call_info": {"func_end_line": 210, "code": "  onDidFailToReadUserSettings (callback) {\r\n    return this.ipcMessageEmitter().on('did-fail-to-read-user-setting', callback)\r\n  }\r", "name": "ipcMessageEmitter", "func_location": "ApplicationDelegate.onDidFailToReadUserSettings", "args": [{"type": "string"}, "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js", "line": 209, "func_start_line": 208}}, {"func_info": {"comment": [], "name": "ApplicationDelegate.ipcMessageEmitter", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js", "end_line": 21, "start_line": 13}, "call_info": {"func_end_line": 268, "code": "  onDidOpenLocations (callback) {\r\n    return this.ipcMessageEmitter().on('open-locations', callback)\r\n  }\r", "name": "ipcMessageEmitter", "func_location": "ApplicationDelegate.onDidOpenLocations", "args": [{"type": "string"}, "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js", "line": 267, "func_start_line": 266}}, {"func_info": {"comment": [" Essential: Retrieves the current {TextBuffer}."], "name": "TextEditor.getBuffer", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 963, "start_line": 963}, "call_info": {"func_end_line": 816, "comment": [" Essential: Invoke the given callback after the buffer is saved to disk.", "", " * `callback` {Function} to be called after the buffer is saved.", "   * `event` {Object} with the following keys:", "     * `path` The path to which the buffer was saved.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  onDidSave (callback) {\r\n    return this.getBuffer().onDidSave(callback)\r\n  }\r", "name": "getBuffer", "func_location": "TextEditor.onDidSave", "args": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 815, "func_start_line": 814}}, {"func_info": {"comment": [" Essential: Retrieves the current {TextBuffer}."], "name": "TextEditor.getBuffer", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 963, "start_line": 963}, "call_info": {"func_end_line": 687, "comment": [" Essential: Invoke `callback` when the buffer's contents change. It is", " emit asynchronously 300ms after the last buffer change. This is a good place", " to handle changes to the buffer without compromising typing performance.", "", " * `callback` {Function}", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  onDidStopChanging (callback) {\r\n    return this.getBuffer().onDidStopChanging(callback)\r\n  }\r", "name": "getBuffer", "func_location": "TextEditor.onDidStopChanging", "args": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 686, "func_start_line": 685}}, {"func_info": {"comment": [], "name": "ApplicationDelegate.ipcMessageEmitter", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js", "end_line": 21, "start_line": 13}, "call_info": {"func_end_line": 275, "code": "  onUpdateAvailable (callback) {\r\n    // TODO: Yes, this is strange that `onUpdateAvailable` is listening for\r\n    // `did-begin-downloading-update`. We currently have no mechanism to know\r\n    // if there is an update, so begin of downloading is a good proxy.\r\n    return this.ipcMessageEmitter().on('did-begin-downloading-update', callback)\r\n  }\r", "name": "ipcMessageEmitter", "func_location": "ApplicationDelegate.onUpdateAvailable", "args": [{"type": "string"}, "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js", "line": 274, "func_start_line": 270}}, {"func_info": {"comment": [], "name": "ApplicationDelegate.ipcMessageEmitter", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js", "end_line": 21, "start_line": 13}, "call_info": {"func_end_line": 295, "code": "  onUpdateError (callback) {\r\n    return this.ipcMessageEmitter().on('update-error', callback)\r\n  }\r", "name": "ipcMessageEmitter", "func_location": "ApplicationDelegate.onUpdateError", "args": [{"type": "string"}, "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js", "line": 294, "func_start_line": 293}}, {"func_info": {"comment": [], "name": "ApplicationDelegate.ipcMessageEmitter", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js", "end_line": 21, "start_line": 13}, "call_info": {"func_end_line": 291, "code": "  onUpdateNotAvailable (callback) {\r\n    return this.ipcMessageEmitter().on('update-not-available', callback)\r\n  }\r", "name": "ipcMessageEmitter", "func_location": "ApplicationDelegate.onUpdateNotAvailable", "args": [{"type": "string"}, "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js", "line": 290, "func_start_line": 289}}, {"func_info": {"comment": [], "name": "Workspace.getPaneContainers", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1625, "start_line": 1618}, "call_info": {"func_end_line": 764, "comment": [" Extended: Invoke the given callback before a pane is destroyed in the", " workspace.", "", " * `callback` {Function} to be called before panes are destroyed.", "   * `event` {Object} with the following keys:", "     * `pane` The pane to be destroyed.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "code": "  onWillDestroyPane (callback) {\r\n    return new CompositeDisposable(\r\n      ...this.getPaneContainers().map(container => container.onWillDestroyPane(callback))\r\n    )\r\n  }\r", "name": "getPaneContainers", "func_location": "Workspace.onWillDestroyPane", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 762, "func_start_line": 760}}, {"func_info": {"comment": [], "name": "Workspace.getPaneContainers", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1625, "start_line": 1618}, "call_info": {"func_end_line": 849, "comment": [" Extended: Invoke the given callback when a pane item is about to be", " destroyed, before the user is prompted to save it.", "", " * `callback` {Function} to be called before pane items are destroyed. If this function returns", "   a {Promise}, then the item will not be destroyed until the promise resolves.", "   * `event` {Object} with the following keys:", "     * `item` The item to be destroyed.", "     * `pane` {Pane} containing the item to be destroyed.", "     * `index` {Number} indicating the index of the item to be destroyed in", "       its pane.", "", " Returns a {Disposable} on which `.dispose` can be called to unsubscribe."], "code": "  onWillDestroyPaneItem (callback) {\r\n    return new CompositeDisposable(\r\n      ...this.getPaneContainers().map(container => container.onWillDestroyPaneItem(callback))\r\n    )\r\n  }\r", "name": "getPaneContainers", "func_location": "Workspace.onWillDestroyPaneItem", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 847, "func_start_line": 845}}, {"func_info": {"comment": [], "name": "GitRepository.constructor", "params": ["path", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 108, "start_line": 74}, "call_info": {"func_end_line": 72, "name": "constructor", "func_location": "GitRepository.open", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 68, "func_start_line": 65}}, {"func_info": {"comment": [" Extended: Get the {Pane} containing the given item.", "", " * `item` the Item that the returned pane must contain.", "", " Returns a {Pane} or `undefined` if no pane exists for the given item."], "name": "Workspace.paneForItem", "params": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1503, "start_line": 1496}, "call_info": {"func_end_line": 1079, "comment": ["\r\n  Section: Opening\r\n  ", " Essential: Opens the given URI in Atom asynchronously.", " If the URI is already open, the existing item for that URI will be", " activated. If no URI is given, or no registered opener can open", " the URI, a new empty {TextEditor} will be created.", "", " * `uri` (optional) A {String} containing a URI.", " * `options` (optional) {Object}", "   * `initialLine` A {Number} indicating which row to move the cursor to", "     initially. Defaults to `0`.", "   * `initialColumn` A {Number} indicating which column to move the cursor to", "     initially. Defaults to `0`.", "   * `split` Either 'left', 'right', 'up' or 'down'.", "     If 'left', the item will be opened in leftmost pane of the current active pane's row.", "     If 'right', the item will be opened in the rightmost pane of the current active pane's row. If only one pane exists in the row, a new pane will be created.", "     If 'up', the item will be opened in topmost pane of the current active pane's column.", "     If 'down', the item will be opened in the bottommost pane of the current active pane's column. If only one pane exists in the column, a new pane will be created.", "   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on", "     containing pane. Defaults to `true`.", "   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}", "     on containing pane. Defaults to `true`.", "   * `pending` A {Boolean} indicating whether or not the item should be opened", "     in a pending state. Existing pending items in a pane are replaced with", "     new pending items when they are opened.", "   * `searchAllPanes` A {Boolean}. If `true`, the workspace will attempt to", "     activate an existing item for the given URI on any pane.", "     If `false`, only the active pane will be searched for", "     an existing item for the same URI. Defaults to `false`.", "   * `location` (optional) A {String} containing the name of the location", "     in which this item should be opened (one of \"left\", \"right\", \"bottom\",", "     or \"center\"). If omitted, Atom will fall back to the last location in", "     which a user has placed an item with the same URI or, if this is a new", "     URI, the default location specified by the item. NOTE: This option", "     should almost always be omitted to honor user preference.", "", " Returns a {Promise} that resolves to the {TextEditor} for the file URI."], "code": "  async open (itemOrURI, options = {}) {\r\n    let uri, item\r\n    if (typeof itemOrURI === 'string') {\r\n      uri = this.project.resolvePath(itemOrURI)\r\n    } else if (itemOrURI) {\r\n      item = itemOrURI\r\n      if (typeof item.getURI === 'function') uri = item.getURI()\r\n    }\r\n\r\n    let resolveItem = () => {}\r\n    if (uri) {\r\n      const incomingItem = this.incoming.get(uri)\r\n      if (!incomingItem) {\r\n        this.incoming.set(uri, new Promise(resolve => { resolveItem = resolve }))\r\n      } else {\r\n        await incomingItem\r\n      }\r\n    }\r\n\r\n    try {\r\n      if (!atom.config.get('core.allowPendingPaneItems')) {\r\n        options.pending = false\r\n      }\r\n\r\n      // Avoid adding URLs as recent documents to work-around this Spotlight crash:\r\n      // https://github.com/atom/atom/issues/10071\r\n      if (uri && (!url.parse(uri).protocol || process.platform === 'win32')) {\r\n        this.applicationDelegate.addRecentDocument(uri)\r\n      }\r\n\r\n      let pane, itemExistsInWorkspace\r\n\r\n      // Try to find an existing item in the workspace.\r\n      if (item || uri) {\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else if (options.searchAllPanes) {\r\n          pane = item ? this.paneForItem(item) : this.paneForURI(uri)\r\n        } else {\r\n          // If an item with the given URI is already in the workspace, assume\r\n          // that item's pane container is the preferred location for that URI.\r\n          let container\r\n          if (uri) container = this.paneContainerForURI(uri)\r\n          if (!container) container = this.getActivePaneContainer()\r\n\r\n          // The `split` option affects where we search for the item.\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n\r\n        if (pane) {\r\n          if (item) {\r\n            itemExistsInWorkspace = pane.getItems().includes(item)\r\n          } else {\r\n            item = pane.itemForURI(uri)\r\n            itemExistsInWorkspace = item != null\r\n          }\r\n        }\r\n      }\r\n\r\n      // If we already have an item at this stage, we won't need to do an async\r\n      // lookup of the URI, so we yield the event loop to ensure this method\r\n      // is consistently asynchronous.\r\n      if (item) await Promise.resolve()\r\n\r\n      if (!itemExistsInWorkspace) {\r\n        item = item || await this.createItemForURI(uri, options)\r\n        if (!item) return\r\n\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else {\r\n          let location = options.location\r\n          if (!location && !options.split && uri && this.enablePersistence) {\r\n            location = await this.itemLocationStore.load(uri)\r\n          }\r\n          if (!location && typeof item.getDefaultLocation === 'function') {\r\n            location = item.getDefaultLocation()\r\n          }\r\n\r\n          const allowedLocations = typeof item.getAllowedLocations === 'function' ? item.getAllowedLocations() : ALL_LOCATIONS\r\n          location = allowedLocations.includes(location) ? location : allowedLocations[0]\r\n\r\n          const container = this.paneContainers[location] || this.getCenter()\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findOrCreateRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findOrCreateBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!options.pending && (pane.getPendingItem() === item)) {\r\n        pane.clearPendingItem()\r\n      }\r\n\r\n      this.itemOpened(item)\r\n\r\n      if (options.activateItem === false) {\r\n        pane.addItem(item, {pending: options.pending})\r\n      } else {\r\n        pane.activateItem(item, {pending: options.pending})\r\n      }\r\n\r\n      if (options.activatePane !== false) {\r\n        pane.activate()\r\n      }\r\n\r\n      let initialColumn = 0\r\n      let initialLine = 0\r\n      if (!Number.isNaN(options.initialLine)) {\r\n        initialLine = options.initialLine\r\n      }\r\n      if (!Number.isNaN(options.initialColumn)) {\r\n        initialColumn = options.initialColumn\r\n      }\r\n      if (initialLine >= 0 || initialColumn >= 0) {\r\n        if (typeof item.setCursorBufferPosition === 'function') {\r\n          item.setCursorBufferPosition([initialLine, initialColumn])\r\n        }\r\n      }\r\n\r\n      const index = pane.getActiveItemIndex()\r\n      this.emitter.emit('did-open', {uri, pane, item, index})\r\n      if (uri) {\r\n        this.incoming.delete(uri)\r\n      }\r\n    } finally {\r\n      resolveItem()\r\n    }\r\n    return item\r\n  }\r", "name": "paneForItem", "func_location": "Workspace.open", "args": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 962, "func_start_line": 925}}, {"func_info": {"comment": [" Extended: Get the first {Pane} that contains an item with the given URI.", "", " * `uri` {String} uri", "", " Returns a {Pane} or `undefined` if no item exists with the given URI."], "name": "Workspace.paneForURI", "params": ["uri"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1489, "start_line": 1482}, "call_info": {"func_end_line": 1079, "comment": ["\r\n  Section: Opening\r\n  ", " Essential: Opens the given URI in Atom asynchronously.", " If the URI is already open, the existing item for that URI will be", " activated. If no URI is given, or no registered opener can open", " the URI, a new empty {TextEditor} will be created.", "", " * `uri` (optional) A {String} containing a URI.", " * `options` (optional) {Object}", "   * `initialLine` A {Number} indicating which row to move the cursor to", "     initially. Defaults to `0`.", "   * `initialColumn` A {Number} indicating which column to move the cursor to", "     initially. Defaults to `0`.", "   * `split` Either 'left', 'right', 'up' or 'down'.", "     If 'left', the item will be opened in leftmost pane of the current active pane's row.", "     If 'right', the item will be opened in the rightmost pane of the current active pane's row. If only one pane exists in the row, a new pane will be created.", "     If 'up', the item will be opened in topmost pane of the current active pane's column.", "     If 'down', the item will be opened in the bottommost pane of the current active pane's column. If only one pane exists in the column, a new pane will be created.", "   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on", "     containing pane. Defaults to `true`.", "   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}", "     on containing pane. Defaults to `true`.", "   * `pending` A {Boolean} indicating whether or not the item should be opened", "     in a pending state. Existing pending items in a pane are replaced with", "     new pending items when they are opened.", "   * `searchAllPanes` A {Boolean}. If `true`, the workspace will attempt to", "     activate an existing item for the given URI on any pane.", "     If `false`, only the active pane will be searched for", "     an existing item for the same URI. Defaults to `false`.", "   * `location` (optional) A {String} containing the name of the location", "     in which this item should be opened (one of \"left\", \"right\", \"bottom\",", "     or \"center\"). If omitted, Atom will fall back to the last location in", "     which a user has placed an item with the same URI or, if this is a new", "     URI, the default location specified by the item. NOTE: This option", "     should almost always be omitted to honor user preference.", "", " Returns a {Promise} that resolves to the {TextEditor} for the file URI."], "code": "  async open (itemOrURI, options = {}) {\r\n    let uri, item\r\n    if (typeof itemOrURI === 'string') {\r\n      uri = this.project.resolvePath(itemOrURI)\r\n    } else if (itemOrURI) {\r\n      item = itemOrURI\r\n      if (typeof item.getURI === 'function') uri = item.getURI()\r\n    }\r\n\r\n    let resolveItem = () => {}\r\n    if (uri) {\r\n      const incomingItem = this.incoming.get(uri)\r\n      if (!incomingItem) {\r\n        this.incoming.set(uri, new Promise(resolve => { resolveItem = resolve }))\r\n      } else {\r\n        await incomingItem\r\n      }\r\n    }\r\n\r\n    try {\r\n      if (!atom.config.get('core.allowPendingPaneItems')) {\r\n        options.pending = false\r\n      }\r\n\r\n      // Avoid adding URLs as recent documents to work-around this Spotlight crash:\r\n      // https://github.com/atom/atom/issues/10071\r\n      if (uri && (!url.parse(uri).protocol || process.platform === 'win32')) {\r\n        this.applicationDelegate.addRecentDocument(uri)\r\n      }\r\n\r\n      let pane, itemExistsInWorkspace\r\n\r\n      // Try to find an existing item in the workspace.\r\n      if (item || uri) {\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else if (options.searchAllPanes) {\r\n          pane = item ? this.paneForItem(item) : this.paneForURI(uri)\r\n        } else {\r\n          // If an item with the given URI is already in the workspace, assume\r\n          // that item's pane container is the preferred location for that URI.\r\n          let container\r\n          if (uri) container = this.paneContainerForURI(uri)\r\n          if (!container) container = this.getActivePaneContainer()\r\n\r\n          // The `split` option affects where we search for the item.\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n\r\n        if (pane) {\r\n          if (item) {\r\n            itemExistsInWorkspace = pane.getItems().includes(item)\r\n          } else {\r\n            item = pane.itemForURI(uri)\r\n            itemExistsInWorkspace = item != null\r\n          }\r\n        }\r\n      }\r\n\r\n      // If we already have an item at this stage, we won't need to do an async\r\n      // lookup of the URI, so we yield the event loop to ensure this method\r\n      // is consistently asynchronous.\r\n      if (item) await Promise.resolve()\r\n\r\n      if (!itemExistsInWorkspace) {\r\n        item = item || await this.createItemForURI(uri, options)\r\n        if (!item) return\r\n\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else {\r\n          let location = options.location\r\n          if (!location && !options.split && uri && this.enablePersistence) {\r\n            location = await this.itemLocationStore.load(uri)\r\n          }\r\n          if (!location && typeof item.getDefaultLocation === 'function') {\r\n            location = item.getDefaultLocation()\r\n          }\r\n\r\n          const allowedLocations = typeof item.getAllowedLocations === 'function' ? item.getAllowedLocations() : ALL_LOCATIONS\r\n          location = allowedLocations.includes(location) ? location : allowedLocations[0]\r\n\r\n          const container = this.paneContainers[location] || this.getCenter()\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findOrCreateRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findOrCreateBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!options.pending && (pane.getPendingItem() === item)) {\r\n        pane.clearPendingItem()\r\n      }\r\n\r\n      this.itemOpened(item)\r\n\r\n      if (options.activateItem === false) {\r\n        pane.addItem(item, {pending: options.pending})\r\n      } else {\r\n        pane.activateItem(item, {pending: options.pending})\r\n      }\r\n\r\n      if (options.activatePane !== false) {\r\n        pane.activate()\r\n      }\r\n\r\n      let initialColumn = 0\r\n      let initialLine = 0\r\n      if (!Number.isNaN(options.initialLine)) {\r\n        initialLine = options.initialLine\r\n      }\r\n      if (!Number.isNaN(options.initialColumn)) {\r\n        initialColumn = options.initialColumn\r\n      }\r\n      if (initialLine >= 0 || initialColumn >= 0) {\r\n        if (typeof item.setCursorBufferPosition === 'function') {\r\n          item.setCursorBufferPosition([initialLine, initialColumn])\r\n        }\r\n      }\r\n\r\n      const index = pane.getActiveItemIndex()\r\n      this.emitter.emit('did-open', {uri, pane, item, index})\r\n      if (uri) {\r\n        this.incoming.delete(uri)\r\n      }\r\n    } finally {\r\n      resolveItem()\r\n    }\r\n    return item\r\n  }\r", "name": "paneForURI", "func_location": "Workspace.open", "args": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 962, "func_start_line": 925}}, {"func_info": {"comment": [" Extended: Get the first pane container that contains an item with the given", " URI.", "", " * `uri` {String} uri", "", " Returns a {Dock}, the {WorkspaceCenter}, or `undefined` if no item exists", " with the given URI."], "name": "Workspace.paneContainerForURI", "params": ["uri"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1465, "start_line": 1463}, "call_info": {"func_end_line": 1079, "comment": ["\r\n  Section: Opening\r\n  ", " Essential: Opens the given URI in Atom asynchronously.", " If the URI is already open, the existing item for that URI will be", " activated. If no URI is given, or no registered opener can open", " the URI, a new empty {TextEditor} will be created.", "", " * `uri` (optional) A {String} containing a URI.", " * `options` (optional) {Object}", "   * `initialLine` A {Number} indicating which row to move the cursor to", "     initially. Defaults to `0`.", "   * `initialColumn` A {Number} indicating which column to move the cursor to", "     initially. Defaults to `0`.", "   * `split` Either 'left', 'right', 'up' or 'down'.", "     If 'left', the item will be opened in leftmost pane of the current active pane's row.", "     If 'right', the item will be opened in the rightmost pane of the current active pane's row. If only one pane exists in the row, a new pane will be created.", "     If 'up', the item will be opened in topmost pane of the current active pane's column.", "     If 'down', the item will be opened in the bottommost pane of the current active pane's column. If only one pane exists in the column, a new pane will be created.", "   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on", "     containing pane. Defaults to `true`.", "   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}", "     on containing pane. Defaults to `true`.", "   * `pending` A {Boolean} indicating whether or not the item should be opened", "     in a pending state. Existing pending items in a pane are replaced with", "     new pending items when they are opened.", "   * `searchAllPanes` A {Boolean}. If `true`, the workspace will attempt to", "     activate an existing item for the given URI on any pane.", "     If `false`, only the active pane will be searched for", "     an existing item for the same URI. Defaults to `false`.", "   * `location` (optional) A {String} containing the name of the location", "     in which this item should be opened (one of \"left\", \"right\", \"bottom\",", "     or \"center\"). If omitted, Atom will fall back to the last location in", "     which a user has placed an item with the same URI or, if this is a new", "     URI, the default location specified by the item. NOTE: This option", "     should almost always be omitted to honor user preference.", "", " Returns a {Promise} that resolves to the {TextEditor} for the file URI."], "code": "  async open (itemOrURI, options = {}) {\r\n    let uri, item\r\n    if (typeof itemOrURI === 'string') {\r\n      uri = this.project.resolvePath(itemOrURI)\r\n    } else if (itemOrURI) {\r\n      item = itemOrURI\r\n      if (typeof item.getURI === 'function') uri = item.getURI()\r\n    }\r\n\r\n    let resolveItem = () => {}\r\n    if (uri) {\r\n      const incomingItem = this.incoming.get(uri)\r\n      if (!incomingItem) {\r\n        this.incoming.set(uri, new Promise(resolve => { resolveItem = resolve }))\r\n      } else {\r\n        await incomingItem\r\n      }\r\n    }\r\n\r\n    try {\r\n      if (!atom.config.get('core.allowPendingPaneItems')) {\r\n        options.pending = false\r\n      }\r\n\r\n      // Avoid adding URLs as recent documents to work-around this Spotlight crash:\r\n      // https://github.com/atom/atom/issues/10071\r\n      if (uri && (!url.parse(uri).protocol || process.platform === 'win32')) {\r\n        this.applicationDelegate.addRecentDocument(uri)\r\n      }\r\n\r\n      let pane, itemExistsInWorkspace\r\n\r\n      // Try to find an existing item in the workspace.\r\n      if (item || uri) {\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else if (options.searchAllPanes) {\r\n          pane = item ? this.paneForItem(item) : this.paneForURI(uri)\r\n        } else {\r\n          // If an item with the given URI is already in the workspace, assume\r\n          // that item's pane container is the preferred location for that URI.\r\n          let container\r\n          if (uri) container = this.paneContainerForURI(uri)\r\n          if (!container) container = this.getActivePaneContainer()\r\n\r\n          // The `split` option affects where we search for the item.\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n\r\n        if (pane) {\r\n          if (item) {\r\n            itemExistsInWorkspace = pane.getItems().includes(item)\r\n          } else {\r\n            item = pane.itemForURI(uri)\r\n            itemExistsInWorkspace = item != null\r\n          }\r\n        }\r\n      }\r\n\r\n      // If we already have an item at this stage, we won't need to do an async\r\n      // lookup of the URI, so we yield the event loop to ensure this method\r\n      // is consistently asynchronous.\r\n      if (item) await Promise.resolve()\r\n\r\n      if (!itemExistsInWorkspace) {\r\n        item = item || await this.createItemForURI(uri, options)\r\n        if (!item) return\r\n\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else {\r\n          let location = options.location\r\n          if (!location && !options.split && uri && this.enablePersistence) {\r\n            location = await this.itemLocationStore.load(uri)\r\n          }\r\n          if (!location && typeof item.getDefaultLocation === 'function') {\r\n            location = item.getDefaultLocation()\r\n          }\r\n\r\n          const allowedLocations = typeof item.getAllowedLocations === 'function' ? item.getAllowedLocations() : ALL_LOCATIONS\r\n          location = allowedLocations.includes(location) ? location : allowedLocations[0]\r\n\r\n          const container = this.paneContainers[location] || this.getCenter()\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findOrCreateRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findOrCreateBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!options.pending && (pane.getPendingItem() === item)) {\r\n        pane.clearPendingItem()\r\n      }\r\n\r\n      this.itemOpened(item)\r\n\r\n      if (options.activateItem === false) {\r\n        pane.addItem(item, {pending: options.pending})\r\n      } else {\r\n        pane.activateItem(item, {pending: options.pending})\r\n      }\r\n\r\n      if (options.activatePane !== false) {\r\n        pane.activate()\r\n      }\r\n\r\n      let initialColumn = 0\r\n      let initialLine = 0\r\n      if (!Number.isNaN(options.initialLine)) {\r\n        initialLine = options.initialLine\r\n      }\r\n      if (!Number.isNaN(options.initialColumn)) {\r\n        initialColumn = options.initialColumn\r\n      }\r\n      if (initialLine >= 0 || initialColumn >= 0) {\r\n        if (typeof item.setCursorBufferPosition === 'function') {\r\n          item.setCursorBufferPosition([initialLine, initialColumn])\r\n        }\r\n      }\r\n\r\n      const index = pane.getActiveItemIndex()\r\n      this.emitter.emit('did-open', {uri, pane, item, index})\r\n      if (uri) {\r\n        this.incoming.delete(uri)\r\n      }\r\n    } finally {\r\n      resolveItem()\r\n    }\r\n    return item\r\n  }\r", "name": "paneContainerForURI", "func_location": "Workspace.open", "args": ["uri"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 967, "func_start_line": 925}}, {"func_info": {"comment": ["\r\n  Section: Panes\r\n  ", " Extended: Get the most recently focused pane container.", "", " Returns a {Dock} or the {WorkspaceCenter}."], "name": "Workspace.getActivePaneContainer", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1426, "start_line": 1424}, "call_info": {"func_end_line": 1079, "comment": ["\r\n  Section: Opening\r\n  ", " Essential: Opens the given URI in Atom asynchronously.", " If the URI is already open, the existing item for that URI will be", " activated. If no URI is given, or no registered opener can open", " the URI, a new empty {TextEditor} will be created.", "", " * `uri` (optional) A {String} containing a URI.", " * `options` (optional) {Object}", "   * `initialLine` A {Number} indicating which row to move the cursor to", "     initially. Defaults to `0`.", "   * `initialColumn` A {Number} indicating which column to move the cursor to", "     initially. Defaults to `0`.", "   * `split` Either 'left', 'right', 'up' or 'down'.", "     If 'left', the item will be opened in leftmost pane of the current active pane's row.", "     If 'right', the item will be opened in the rightmost pane of the current active pane's row. If only one pane exists in the row, a new pane will be created.", "     If 'up', the item will be opened in topmost pane of the current active pane's column.", "     If 'down', the item will be opened in the bottommost pane of the current active pane's column. If only one pane exists in the column, a new pane will be created.", "   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on", "     containing pane. Defaults to `true`.", "   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}", "     on containing pane. Defaults to `true`.", "   * `pending` A {Boolean} indicating whether or not the item should be opened", "     in a pending state. Existing pending items in a pane are replaced with", "     new pending items when they are opened.", "   * `searchAllPanes` A {Boolean}. If `true`, the workspace will attempt to", "     activate an existing item for the given URI on any pane.", "     If `false`, only the active pane will be searched for", "     an existing item for the same URI. Defaults to `false`.", "   * `location` (optional) A {String} containing the name of the location", "     in which this item should be opened (one of \"left\", \"right\", \"bottom\",", "     or \"center\"). If omitted, Atom will fall back to the last location in", "     which a user has placed an item with the same URI or, if this is a new", "     URI, the default location specified by the item. NOTE: This option", "     should almost always be omitted to honor user preference.", "", " Returns a {Promise} that resolves to the {TextEditor} for the file URI."], "code": "  async open (itemOrURI, options = {}) {\r\n    let uri, item\r\n    if (typeof itemOrURI === 'string') {\r\n      uri = this.project.resolvePath(itemOrURI)\r\n    } else if (itemOrURI) {\r\n      item = itemOrURI\r\n      if (typeof item.getURI === 'function') uri = item.getURI()\r\n    }\r\n\r\n    let resolveItem = () => {}\r\n    if (uri) {\r\n      const incomingItem = this.incoming.get(uri)\r\n      if (!incomingItem) {\r\n        this.incoming.set(uri, new Promise(resolve => { resolveItem = resolve }))\r\n      } else {\r\n        await incomingItem\r\n      }\r\n    }\r\n\r\n    try {\r\n      if (!atom.config.get('core.allowPendingPaneItems')) {\r\n        options.pending = false\r\n      }\r\n\r\n      // Avoid adding URLs as recent documents to work-around this Spotlight crash:\r\n      // https://github.com/atom/atom/issues/10071\r\n      if (uri && (!url.parse(uri).protocol || process.platform === 'win32')) {\r\n        this.applicationDelegate.addRecentDocument(uri)\r\n      }\r\n\r\n      let pane, itemExistsInWorkspace\r\n\r\n      // Try to find an existing item in the workspace.\r\n      if (item || uri) {\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else if (options.searchAllPanes) {\r\n          pane = item ? this.paneForItem(item) : this.paneForURI(uri)\r\n        } else {\r\n          // If an item with the given URI is already in the workspace, assume\r\n          // that item's pane container is the preferred location for that URI.\r\n          let container\r\n          if (uri) container = this.paneContainerForURI(uri)\r\n          if (!container) container = this.getActivePaneContainer()\r\n\r\n          // The `split` option affects where we search for the item.\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n\r\n        if (pane) {\r\n          if (item) {\r\n            itemExistsInWorkspace = pane.getItems().includes(item)\r\n          } else {\r\n            item = pane.itemForURI(uri)\r\n            itemExistsInWorkspace = item != null\r\n          }\r\n        }\r\n      }\r\n\r\n      // If we already have an item at this stage, we won't need to do an async\r\n      // lookup of the URI, so we yield the event loop to ensure this method\r\n      // is consistently asynchronous.\r\n      if (item) await Promise.resolve()\r\n\r\n      if (!itemExistsInWorkspace) {\r\n        item = item || await this.createItemForURI(uri, options)\r\n        if (!item) return\r\n\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else {\r\n          let location = options.location\r\n          if (!location && !options.split && uri && this.enablePersistence) {\r\n            location = await this.itemLocationStore.load(uri)\r\n          }\r\n          if (!location && typeof item.getDefaultLocation === 'function') {\r\n            location = item.getDefaultLocation()\r\n          }\r\n\r\n          const allowedLocations = typeof item.getAllowedLocations === 'function' ? item.getAllowedLocations() : ALL_LOCATIONS\r\n          location = allowedLocations.includes(location) ? location : allowedLocations[0]\r\n\r\n          const container = this.paneContainers[location] || this.getCenter()\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findOrCreateRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findOrCreateBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!options.pending && (pane.getPendingItem() === item)) {\r\n        pane.clearPendingItem()\r\n      }\r\n\r\n      this.itemOpened(item)\r\n\r\n      if (options.activateItem === false) {\r\n        pane.addItem(item, {pending: options.pending})\r\n      } else {\r\n        pane.activateItem(item, {pending: options.pending})\r\n      }\r\n\r\n      if (options.activatePane !== false) {\r\n        pane.activate()\r\n      }\r\n\r\n      let initialColumn = 0\r\n      let initialLine = 0\r\n      if (!Number.isNaN(options.initialLine)) {\r\n        initialLine = options.initialLine\r\n      }\r\n      if (!Number.isNaN(options.initialColumn)) {\r\n        initialColumn = options.initialColumn\r\n      }\r\n      if (initialLine >= 0 || initialColumn >= 0) {\r\n        if (typeof item.setCursorBufferPosition === 'function') {\r\n          item.setCursorBufferPosition([initialLine, initialColumn])\r\n        }\r\n      }\r\n\r\n      const index = pane.getActiveItemIndex()\r\n      this.emitter.emit('did-open', {uri, pane, item, index})\r\n      if (uri) {\r\n        this.incoming.delete(uri)\r\n      }\r\n    } finally {\r\n      resolveItem()\r\n    }\r\n    return item\r\n  }\r", "name": "getActivePaneContainer", "func_location": "Workspace.open", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 968, "func_start_line": 925}}, {"func_info": {"comment": [" Public: Creates a new item that corresponds to the provided URI.", "", " If no URI is given, or no registered opener can open the URI, a new empty", " {TextEditor} will be created.", "", " * `uri` A {String} containing a URI.", "", " Returns a {Promise} that resolves to the {TextEditor} (or other item) for the given URI."], "name": "Workspace.createItemForURI", "params": ["uri", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1229, "start_line": 1191}, "call_info": {"func_end_line": 1079, "comment": ["\r\n  Section: Opening\r\n  ", " Essential: Opens the given URI in Atom asynchronously.", " If the URI is already open, the existing item for that URI will be", " activated. If no URI is given, or no registered opener can open", " the URI, a new empty {TextEditor} will be created.", "", " * `uri` (optional) A {String} containing a URI.", " * `options` (optional) {Object}", "   * `initialLine` A {Number} indicating which row to move the cursor to", "     initially. Defaults to `0`.", "   * `initialColumn` A {Number} indicating which column to move the cursor to", "     initially. Defaults to `0`.", "   * `split` Either 'left', 'right', 'up' or 'down'.", "     If 'left', the item will be opened in leftmost pane of the current active pane's row.", "     If 'right', the item will be opened in the rightmost pane of the current active pane's row. If only one pane exists in the row, a new pane will be created.", "     If 'up', the item will be opened in topmost pane of the current active pane's column.", "     If 'down', the item will be opened in the bottommost pane of the current active pane's column. If only one pane exists in the column, a new pane will be created.", "   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on", "     containing pane. Defaults to `true`.", "   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}", "     on containing pane. Defaults to `true`.", "   * `pending` A {Boolean} indicating whether or not the item should be opened", "     in a pending state. Existing pending items in a pane are replaced with", "     new pending items when they are opened.", "   * `searchAllPanes` A {Boolean}. If `true`, the workspace will attempt to", "     activate an existing item for the given URI on any pane.", "     If `false`, only the active pane will be searched for", "     an existing item for the same URI. Defaults to `false`.", "   * `location` (optional) A {String} containing the name of the location", "     in which this item should be opened (one of \"left\", \"right\", \"bottom\",", "     or \"center\"). If omitted, Atom will fall back to the last location in", "     which a user has placed an item with the same URI or, if this is a new", "     URI, the default location specified by the item. NOTE: This option", "     should almost always be omitted to honor user preference.", "", " Returns a {Promise} that resolves to the {TextEditor} for the file URI."], "code": "  async open (itemOrURI, options = {}) {\r\n    let uri, item\r\n    if (typeof itemOrURI === 'string') {\r\n      uri = this.project.resolvePath(itemOrURI)\r\n    } else if (itemOrURI) {\r\n      item = itemOrURI\r\n      if (typeof item.getURI === 'function') uri = item.getURI()\r\n    }\r\n\r\n    let resolveItem = () => {}\r\n    if (uri) {\r\n      const incomingItem = this.incoming.get(uri)\r\n      if (!incomingItem) {\r\n        this.incoming.set(uri, new Promise(resolve => { resolveItem = resolve }))\r\n      } else {\r\n        await incomingItem\r\n      }\r\n    }\r\n\r\n    try {\r\n      if (!atom.config.get('core.allowPendingPaneItems')) {\r\n        options.pending = false\r\n      }\r\n\r\n      // Avoid adding URLs as recent documents to work-around this Spotlight crash:\r\n      // https://github.com/atom/atom/issues/10071\r\n      if (uri && (!url.parse(uri).protocol || process.platform === 'win32')) {\r\n        this.applicationDelegate.addRecentDocument(uri)\r\n      }\r\n\r\n      let pane, itemExistsInWorkspace\r\n\r\n      // Try to find an existing item in the workspace.\r\n      if (item || uri) {\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else if (options.searchAllPanes) {\r\n          pane = item ? this.paneForItem(item) : this.paneForURI(uri)\r\n        } else {\r\n          // If an item with the given URI is already in the workspace, assume\r\n          // that item's pane container is the preferred location for that URI.\r\n          let container\r\n          if (uri) container = this.paneContainerForURI(uri)\r\n          if (!container) container = this.getActivePaneContainer()\r\n\r\n          // The `split` option affects where we search for the item.\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n\r\n        if (pane) {\r\n          if (item) {\r\n            itemExistsInWorkspace = pane.getItems().includes(item)\r\n          } else {\r\n            item = pane.itemForURI(uri)\r\n            itemExistsInWorkspace = item != null\r\n          }\r\n        }\r\n      }\r\n\r\n      // If we already have an item at this stage, we won't need to do an async\r\n      // lookup of the URI, so we yield the event loop to ensure this method\r\n      // is consistently asynchronous.\r\n      if (item) await Promise.resolve()\r\n\r\n      if (!itemExistsInWorkspace) {\r\n        item = item || await this.createItemForURI(uri, options)\r\n        if (!item) return\r\n\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else {\r\n          let location = options.location\r\n          if (!location && !options.split && uri && this.enablePersistence) {\r\n            location = await this.itemLocationStore.load(uri)\r\n          }\r\n          if (!location && typeof item.getDefaultLocation === 'function') {\r\n            location = item.getDefaultLocation()\r\n          }\r\n\r\n          const allowedLocations = typeof item.getAllowedLocations === 'function' ? item.getAllowedLocations() : ALL_LOCATIONS\r\n          location = allowedLocations.includes(location) ? location : allowedLocations[0]\r\n\r\n          const container = this.paneContainers[location] || this.getCenter()\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findOrCreateRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findOrCreateBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!options.pending && (pane.getPendingItem() === item)) {\r\n        pane.clearPendingItem()\r\n      }\r\n\r\n      this.itemOpened(item)\r\n\r\n      if (options.activateItem === false) {\r\n        pane.addItem(item, {pending: options.pending})\r\n      } else {\r\n        pane.activateItem(item, {pending: options.pending})\r\n      }\r\n\r\n      if (options.activatePane !== false) {\r\n        pane.activate()\r\n      }\r\n\r\n      let initialColumn = 0\r\n      let initialLine = 0\r\n      if (!Number.isNaN(options.initialLine)) {\r\n        initialLine = options.initialLine\r\n      }\r\n      if (!Number.isNaN(options.initialColumn)) {\r\n        initialColumn = options.initialColumn\r\n      }\r\n      if (initialLine >= 0 || initialColumn >= 0) {\r\n        if (typeof item.setCursorBufferPosition === 'function') {\r\n          item.setCursorBufferPosition([initialLine, initialColumn])\r\n        }\r\n      }\r\n\r\n      const index = pane.getActiveItemIndex()\r\n      this.emitter.emit('did-open', {uri, pane, item, index})\r\n      if (uri) {\r\n        this.incoming.delete(uri)\r\n      }\r\n    } finally {\r\n      resolveItem()\r\n    }\r\n    return item\r\n  }\r", "name": "createItemForURI", "func_location": "Workspace.open", "args": ["uri", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1004, "func_start_line": 925}}, {"func_info": {"comment": ["\r\n  Section: Pane Locations\r\n  ", " Essential: Get the {WorkspaceCenter} at the center of the editor window."], "name": "Workspace.getCenter", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1601, "start_line": 1599}, "call_info": {"func_end_line": 1079, "comment": ["\r\n  Section: Opening\r\n  ", " Essential: Opens the given URI in Atom asynchronously.", " If the URI is already open, the existing item for that URI will be", " activated. If no URI is given, or no registered opener can open", " the URI, a new empty {TextEditor} will be created.", "", " * `uri` (optional) A {String} containing a URI.", " * `options` (optional) {Object}", "   * `initialLine` A {Number} indicating which row to move the cursor to", "     initially. Defaults to `0`.", "   * `initialColumn` A {Number} indicating which column to move the cursor to", "     initially. Defaults to `0`.", "   * `split` Either 'left', 'right', 'up' or 'down'.", "     If 'left', the item will be opened in leftmost pane of the current active pane's row.", "     If 'right', the item will be opened in the rightmost pane of the current active pane's row. If only one pane exists in the row, a new pane will be created.", "     If 'up', the item will be opened in topmost pane of the current active pane's column.", "     If 'down', the item will be opened in the bottommost pane of the current active pane's column. If only one pane exists in the column, a new pane will be created.", "   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on", "     containing pane. Defaults to `true`.", "   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}", "     on containing pane. Defaults to `true`.", "   * `pending` A {Boolean} indicating whether or not the item should be opened", "     in a pending state. Existing pending items in a pane are replaced with", "     new pending items when they are opened.", "   * `searchAllPanes` A {Boolean}. If `true`, the workspace will attempt to", "     activate an existing item for the given URI on any pane.", "     If `false`, only the active pane will be searched for", "     an existing item for the same URI. Defaults to `false`.", "   * `location` (optional) A {String} containing the name of the location", "     in which this item should be opened (one of \"left\", \"right\", \"bottom\",", "     or \"center\"). If omitted, Atom will fall back to the last location in", "     which a user has placed an item with the same URI or, if this is a new", "     URI, the default location specified by the item. NOTE: This option", "     should almost always be omitted to honor user preference.", "", " Returns a {Promise} that resolves to the {TextEditor} for the file URI."], "code": "  async open (itemOrURI, options = {}) {\r\n    let uri, item\r\n    if (typeof itemOrURI === 'string') {\r\n      uri = this.project.resolvePath(itemOrURI)\r\n    } else if (itemOrURI) {\r\n      item = itemOrURI\r\n      if (typeof item.getURI === 'function') uri = item.getURI()\r\n    }\r\n\r\n    let resolveItem = () => {}\r\n    if (uri) {\r\n      const incomingItem = this.incoming.get(uri)\r\n      if (!incomingItem) {\r\n        this.incoming.set(uri, new Promise(resolve => { resolveItem = resolve }))\r\n      } else {\r\n        await incomingItem\r\n      }\r\n    }\r\n\r\n    try {\r\n      if (!atom.config.get('core.allowPendingPaneItems')) {\r\n        options.pending = false\r\n      }\r\n\r\n      // Avoid adding URLs as recent documents to work-around this Spotlight crash:\r\n      // https://github.com/atom/atom/issues/10071\r\n      if (uri && (!url.parse(uri).protocol || process.platform === 'win32')) {\r\n        this.applicationDelegate.addRecentDocument(uri)\r\n      }\r\n\r\n      let pane, itemExistsInWorkspace\r\n\r\n      // Try to find an existing item in the workspace.\r\n      if (item || uri) {\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else if (options.searchAllPanes) {\r\n          pane = item ? this.paneForItem(item) : this.paneForURI(uri)\r\n        } else {\r\n          // If an item with the given URI is already in the workspace, assume\r\n          // that item's pane container is the preferred location for that URI.\r\n          let container\r\n          if (uri) container = this.paneContainerForURI(uri)\r\n          if (!container) container = this.getActivePaneContainer()\r\n\r\n          // The `split` option affects where we search for the item.\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n\r\n        if (pane) {\r\n          if (item) {\r\n            itemExistsInWorkspace = pane.getItems().includes(item)\r\n          } else {\r\n            item = pane.itemForURI(uri)\r\n            itemExistsInWorkspace = item != null\r\n          }\r\n        }\r\n      }\r\n\r\n      // If we already have an item at this stage, we won't need to do an async\r\n      // lookup of the URI, so we yield the event loop to ensure this method\r\n      // is consistently asynchronous.\r\n      if (item) await Promise.resolve()\r\n\r\n      if (!itemExistsInWorkspace) {\r\n        item = item || await this.createItemForURI(uri, options)\r\n        if (!item) return\r\n\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else {\r\n          let location = options.location\r\n          if (!location && !options.split && uri && this.enablePersistence) {\r\n            location = await this.itemLocationStore.load(uri)\r\n          }\r\n          if (!location && typeof item.getDefaultLocation === 'function') {\r\n            location = item.getDefaultLocation()\r\n          }\r\n\r\n          const allowedLocations = typeof item.getAllowedLocations === 'function' ? item.getAllowedLocations() : ALL_LOCATIONS\r\n          location = allowedLocations.includes(location) ? location : allowedLocations[0]\r\n\r\n          const container = this.paneContainers[location] || this.getCenter()\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findOrCreateRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findOrCreateBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!options.pending && (pane.getPendingItem() === item)) {\r\n        pane.clearPendingItem()\r\n      }\r\n\r\n      this.itemOpened(item)\r\n\r\n      if (options.activateItem === false) {\r\n        pane.addItem(item, {pending: options.pending})\r\n      } else {\r\n        pane.activateItem(item, {pending: options.pending})\r\n      }\r\n\r\n      if (options.activatePane !== false) {\r\n        pane.activate()\r\n      }\r\n\r\n      let initialColumn = 0\r\n      let initialLine = 0\r\n      if (!Number.isNaN(options.initialLine)) {\r\n        initialLine = options.initialLine\r\n      }\r\n      if (!Number.isNaN(options.initialColumn)) {\r\n        initialColumn = options.initialColumn\r\n      }\r\n      if (initialLine >= 0 || initialColumn >= 0) {\r\n        if (typeof item.setCursorBufferPosition === 'function') {\r\n          item.setCursorBufferPosition([initialLine, initialColumn])\r\n        }\r\n      }\r\n\r\n      const index = pane.getActiveItemIndex()\r\n      this.emitter.emit('did-open', {uri, pane, item, index})\r\n      if (uri) {\r\n        this.incoming.delete(uri)\r\n      }\r\n    } finally {\r\n      resolveItem()\r\n    }\r\n    return item\r\n  }\r", "name": "getCenter", "func_location": "Workspace.open", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1021, "func_start_line": 925}}, {"func_info": {"comment": [" Removes the item's uri from the list of potential items to reopen."], "name": "Workspace.itemOpened", "params": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1565, "start_line": 1554}, "call_info": {"func_end_line": 1079, "comment": ["\r\n  Section: Opening\r\n  ", " Essential: Opens the given URI in Atom asynchronously.", " If the URI is already open, the existing item for that URI will be", " activated. If no URI is given, or no registered opener can open", " the URI, a new empty {TextEditor} will be created.", "", " * `uri` (optional) A {String} containing a URI.", " * `options` (optional) {Object}", "   * `initialLine` A {Number} indicating which row to move the cursor to", "     initially. Defaults to `0`.", "   * `initialColumn` A {Number} indicating which column to move the cursor to", "     initially. Defaults to `0`.", "   * `split` Either 'left', 'right', 'up' or 'down'.", "     If 'left', the item will be opened in leftmost pane of the current active pane's row.", "     If 'right', the item will be opened in the rightmost pane of the current active pane's row. If only one pane exists in the row, a new pane will be created.", "     If 'up', the item will be opened in topmost pane of the current active pane's column.", "     If 'down', the item will be opened in the bottommost pane of the current active pane's column. If only one pane exists in the column, a new pane will be created.", "   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on", "     containing pane. Defaults to `true`.", "   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}", "     on containing pane. Defaults to `true`.", "   * `pending` A {Boolean} indicating whether or not the item should be opened", "     in a pending state. Existing pending items in a pane are replaced with", "     new pending items when they are opened.", "   * `searchAllPanes` A {Boolean}. If `true`, the workspace will attempt to", "     activate an existing item for the given URI on any pane.", "     If `false`, only the active pane will be searched for", "     an existing item for the same URI. Defaults to `false`.", "   * `location` (optional) A {String} containing the name of the location", "     in which this item should be opened (one of \"left\", \"right\", \"bottom\",", "     or \"center\"). If omitted, Atom will fall back to the last location in", "     which a user has placed an item with the same URI or, if this is a new", "     URI, the default location specified by the item. NOTE: This option", "     should almost always be omitted to honor user preference.", "", " Returns a {Promise} that resolves to the {TextEditor} for the file URI."], "code": "  async open (itemOrURI, options = {}) {\r\n    let uri, item\r\n    if (typeof itemOrURI === 'string') {\r\n      uri = this.project.resolvePath(itemOrURI)\r\n    } else if (itemOrURI) {\r\n      item = itemOrURI\r\n      if (typeof item.getURI === 'function') uri = item.getURI()\r\n    }\r\n\r\n    let resolveItem = () => {}\r\n    if (uri) {\r\n      const incomingItem = this.incoming.get(uri)\r\n      if (!incomingItem) {\r\n        this.incoming.set(uri, new Promise(resolve => { resolveItem = resolve }))\r\n      } else {\r\n        await incomingItem\r\n      }\r\n    }\r\n\r\n    try {\r\n      if (!atom.config.get('core.allowPendingPaneItems')) {\r\n        options.pending = false\r\n      }\r\n\r\n      // Avoid adding URLs as recent documents to work-around this Spotlight crash:\r\n      // https://github.com/atom/atom/issues/10071\r\n      if (uri && (!url.parse(uri).protocol || process.platform === 'win32')) {\r\n        this.applicationDelegate.addRecentDocument(uri)\r\n      }\r\n\r\n      let pane, itemExistsInWorkspace\r\n\r\n      // Try to find an existing item in the workspace.\r\n      if (item || uri) {\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else if (options.searchAllPanes) {\r\n          pane = item ? this.paneForItem(item) : this.paneForURI(uri)\r\n        } else {\r\n          // If an item with the given URI is already in the workspace, assume\r\n          // that item's pane container is the preferred location for that URI.\r\n          let container\r\n          if (uri) container = this.paneContainerForURI(uri)\r\n          if (!container) container = this.getActivePaneContainer()\r\n\r\n          // The `split` option affects where we search for the item.\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n\r\n        if (pane) {\r\n          if (item) {\r\n            itemExistsInWorkspace = pane.getItems().includes(item)\r\n          } else {\r\n            item = pane.itemForURI(uri)\r\n            itemExistsInWorkspace = item != null\r\n          }\r\n        }\r\n      }\r\n\r\n      // If we already have an item at this stage, we won't need to do an async\r\n      // lookup of the URI, so we yield the event loop to ensure this method\r\n      // is consistently asynchronous.\r\n      if (item) await Promise.resolve()\r\n\r\n      if (!itemExistsInWorkspace) {\r\n        item = item || await this.createItemForURI(uri, options)\r\n        if (!item) return\r\n\r\n        if (options.pane) {\r\n          pane = options.pane\r\n        } else {\r\n          let location = options.location\r\n          if (!location && !options.split && uri && this.enablePersistence) {\r\n            location = await this.itemLocationStore.load(uri)\r\n          }\r\n          if (!location && typeof item.getDefaultLocation === 'function') {\r\n            location = item.getDefaultLocation()\r\n          }\r\n\r\n          const allowedLocations = typeof item.getAllowedLocations === 'function' ? item.getAllowedLocations() : ALL_LOCATIONS\r\n          location = allowedLocations.includes(location) ? location : allowedLocations[0]\r\n\r\n          const container = this.paneContainers[location] || this.getCenter()\r\n          pane = container.getActivePane()\r\n          switch (options.split) {\r\n            case 'left':\r\n              pane = pane.findLeftmostSibling()\r\n              break\r\n            case 'right':\r\n              pane = pane.findOrCreateRightmostSibling()\r\n              break\r\n            case 'up':\r\n              pane = pane.findTopmostSibling()\r\n              break\r\n            case 'down':\r\n              pane = pane.findOrCreateBottommostSibling()\r\n              break\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!options.pending && (pane.getPendingItem() === item)) {\r\n        pane.clearPendingItem()\r\n      }\r\n\r\n      this.itemOpened(item)\r\n\r\n      if (options.activateItem === false) {\r\n        pane.addItem(item, {pending: options.pending})\r\n      } else {\r\n        pane.activateItem(item, {pending: options.pending})\r\n      }\r\n\r\n      if (options.activatePane !== false) {\r\n        pane.activate()\r\n      }\r\n\r\n      let initialColumn = 0\r\n      let initialLine = 0\r\n      if (!Number.isNaN(options.initialLine)) {\r\n        initialLine = options.initialLine\r\n      }\r\n      if (!Number.isNaN(options.initialColumn)) {\r\n        initialColumn = options.initialColumn\r\n      }\r\n      if (initialLine >= 0 || initialColumn >= 0) {\r\n        if (typeof item.setCursorBufferPosition === 'function') {\r\n          item.setCursorBufferPosition([initialLine, initialColumn])\r\n        }\r\n      }\r\n\r\n      const index = pane.getActiveItemIndex()\r\n      this.emitter.emit('did-open', {uri, pane, item, index})\r\n      if (uri) {\r\n        this.incoming.delete(uri)\r\n      }\r\n    } finally {\r\n      resolveItem()\r\n    }\r\n    return item\r\n  }\r", "name": "itemOpened", "func_location": "Workspace.open", "args": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1044, "func_start_line": 925}}, {"func_info": {"comment": [], "name": "AtomApplication.constructor", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 136, "start_line": 91}, "call_info": {"func_end_line": 85, "comment": [" Public: The entry point into the Atom application."], "code": "  static open (options) {\r\n    if (!options.socketPath) {\r\n      const {username} = os.userInfo()\r\n\r\n      // Lowercasing the ATOM_HOME to make sure that we don't get multiple sockets\r\n      // on case-insensitive filesystems due to arbitrary case differences in paths.\r\n      const atomHomeUnique = path.resolve(process.env.ATOM_HOME).toLowerCase()\r\n      const hash = crypto\r\n        .createHash('sha1')\r\n        .update(options.version)\r\n        .update('|')\r\n        .update(process.arch)\r\n        .update('|')\r\n        .update(username || '')\r\n        .update('|')\r\n        .update(atomHomeUnique)\r\n\r\n      // We only keep the first 12 characters of the hash as not to have excessively long\r\n      // socket file. Note that macOS/BSD limit the length of socket file paths (see #15081).\r\n      // The replace calls convert the digest into \"URL and Filename Safe\" encoding (see RFC 4648).\r\n      const atomInstanceDigest = hash\r\n        .digest('base64')\r\n        .substring(0, 12)\r\n        .replace(/\\+/g, '-')\r\n        .replace(/\\//g, '_')\r\n\r\n      if (process.platform === 'win32') {\r\n        options.socketPath = `\\\\\\\\.\\\\pipe\\\\atom-${atomInstanceDigest}-sock`\r\n      } else {\r\n        options.socketPath = path.join(os.tmpdir(), `atom-${atomInstanceDigest}.sock`)\r\n      }\r\n    }\r\n\r\n    // FIXME: Sometimes when socketPath doesn't exist, net.connect would strangely\r\n    // take a few seconds to trigger 'error' event, it could be a bug of node\r\n    // or electron, before it's fixed we check the existence of socketPath to\r\n    // speedup startup.\r\n    if ((process.platform !== 'win32' && !fs.existsSync(options.socketPath)) ||\r\n        options.test || options.benchmark || options.benchmarkTest) {\r\n      new AtomApplication(options).initialize(options)\r\n      return\r\n    }\r\n\r\n    const client = net.connect({path: options.socketPath}, () => {\r\n      client.write(JSON.stringify(options), () => {\r\n        client.end()\r\n        app.quit()\r\n      })\r\n    })\r\n\r\n    client.on('error', () => new AtomApplication(options).initialize(options))\r\n  }\r", "name": "constructor", "func_location": "AtomApplication.open", "args": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 73, "func_start_line": 34}}, {"func_info": {"comment": [" This stuff was previously done in the constructor, but we want to be able to construct this object", " for testing purposes without booting up the world. As you add tests, feel free to move instantiation", " of these various sub-objects into the constructor, but you'll need to remove the side-effects they", " perform during their construction, adding an initialize method that you call here."], "name": "AtomApplication.initialize", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 161, "start_line": 142}, "call_info": {"func_end_line": 85, "comment": [" Public: The entry point into the Atom application."], "code": "  static open (options) {\r\n    if (!options.socketPath) {\r\n      const {username} = os.userInfo()\r\n\r\n      // Lowercasing the ATOM_HOME to make sure that we don't get multiple sockets\r\n      // on case-insensitive filesystems due to arbitrary case differences in paths.\r\n      const atomHomeUnique = path.resolve(process.env.ATOM_HOME).toLowerCase()\r\n      const hash = crypto\r\n        .createHash('sha1')\r\n        .update(options.version)\r\n        .update('|')\r\n        .update(process.arch)\r\n        .update('|')\r\n        .update(username || '')\r\n        .update('|')\r\n        .update(atomHomeUnique)\r\n\r\n      // We only keep the first 12 characters of the hash as not to have excessively long\r\n      // socket file. Note that macOS/BSD limit the length of socket file paths (see #15081).\r\n      // The replace calls convert the digest into \"URL and Filename Safe\" encoding (see RFC 4648).\r\n      const atomInstanceDigest = hash\r\n        .digest('base64')\r\n        .substring(0, 12)\r\n        .replace(/\\+/g, '-')\r\n        .replace(/\\//g, '_')\r\n\r\n      if (process.platform === 'win32') {\r\n        options.socketPath = `\\\\\\\\.\\\\pipe\\\\atom-${atomInstanceDigest}-sock`\r\n      } else {\r\n        options.socketPath = path.join(os.tmpdir(), `atom-${atomInstanceDigest}.sock`)\r\n      }\r\n    }\r\n\r\n    // FIXME: Sometimes when socketPath doesn't exist, net.connect would strangely\r\n    // take a few seconds to trigger 'error' event, it could be a bug of node\r\n    // or electron, before it's fixed we check the existence of socketPath to\r\n    // speedup startup.\r\n    if ((process.platform !== 'win32' && !fs.existsSync(options.socketPath)) ||\r\n        options.test || options.benchmark || options.benchmarkTest) {\r\n      new AtomApplication(options).initialize(options)\r\n      return\r\n    }\r\n\r\n    const client = net.connect({path: options.socketPath}, () => {\r\n      client.write(JSON.stringify(options), () => {\r\n        client.end()\r\n        app.quit()\r\n      })\r\n    })\r\n\r\n    client.on('error', () => new AtomApplication(options).initialize(options))\r\n  }\r", "name": "initialize", "func_location": "AtomApplication.open", "args": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 73, "func_start_line": 34}}, {"func_info": {"comment": [" Converts a query string parameter for a line or column number", " to a zero-based line or column number for the Atom API."], "name": "getLineColNumber", "params": ["numStr"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/core-uri-handlers.js", "end_line": 6, "start_line": 3}, "call_info": {"func_end_line": 16, "code": "function openFile (atom, {query}) {\r\n  const {filename, line, column} = query\r\n\r\n  atom.workspace.open(filename, {\r\n    initialLine: getLineColNumber(line),\r\n    initialColumn: getLineColNumber(column),\r\n    searchAllPanes: true\r\n  })\r\n}\r", "name": "getLineColNumber", "func_location": "openFile", "args": ["line"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/core-uri-handlers.js", "line": 12, "func_start_line": 8}}, {"func_info": {"comment": [" Converts a query string parameter for a line or column number", " to a zero-based line or column number for the Atom API."], "name": "getLineColNumber", "params": ["numStr"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/core-uri-handlers.js", "end_line": 6, "start_line": 3}, "call_info": {"func_end_line": 16, "code": "function openFile (atom, {query}) {\r\n  const {filename, line, column} = query\r\n\r\n  atom.workspace.open(filename, {\r\n    initialLine: getLineColNumber(line),\r\n    initialColumn: getLineColNumber(column),\r\n    searchAllPanes: true\r\n  })\r\n}\r", "name": "getLineColNumber", "func_location": "openFile", "args": ["column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/core-uri-handlers.js", "line": 13, "func_start_line": 8}}, {"func_info": {"comment": [" Public: Get the load settings for the current window.", "", " Returns an {Object} containing all the load setting key/value pairs."], "name": "AtomEnvironment.getLoadSettings", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 527, "start_line": 525}, "call_info": {"func_end_line": 920, "code": "  openInitialEmptyEditorIfNecessary () {\r\n    if (!this.config.get('core.openEmptyEditorOnStart')) return\r\n    const {initialPaths} = this.getLoadSettings()\r\n    if (initialPaths && initialPaths.length === 0 && this.workspace.getPaneItems().length === 0) {\r\n      return this.workspace.open(null)\r\n    }\r\n  }\r", "name": "getLoadSettings", "func_location": "AtomEnvironment.openInitialEmptyEditorIfNecessary", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 916, "func_start_line": 914}}, {"func_info": {"comment": ["\r\n  Section: Opening\r\n  ", " Essential: Opens the given URI in Atom asynchronously.", " If the URI is already open, the existing item for that URI will be", " activated. If no URI is given, or no registered opener can open", " the URI, a new empty {TextEditor} will be created.", "", " * `uri` (optional) A {String} containing a URI.", " * `options` (optional) {Object}", "   * `initialLine` A {Number} indicating which row to move the cursor to", "     initially. Defaults to `0`.", "   * `initialColumn` A {Number} indicating which column to move the cursor to", "     initially. Defaults to `0`.", "   * `split` Either 'left', 'right', 'up' or 'down'.", "     If 'left', the item will be opened in leftmost pane of the current active pane's row.", "     If 'right', the item will be opened in the rightmost pane of the current active pane's row. If only one pane exists in the row, a new pane will be created.", "     If 'up', the item will be opened in topmost pane of the current active pane's column.", "     If 'down', the item will be opened in the bottommost pane of the current active pane's column. If only one pane exists in the column, a new pane will be created.", "   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on", "     containing pane. Defaults to `true`.", "   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}", "     on containing pane. Defaults to `true`.", "   * `pending` A {Boolean} indicating whether or not the item should be opened", "     in a pending state. Existing pending items in a pane are replaced with", "     new pending items when they are opened.", "   * `searchAllPanes` A {Boolean}. If `true`, the workspace will attempt to", "     activate an existing item for the given URI on any pane.", "     If `false`, only the active pane will be searched for", "     an existing item for the same URI. Defaults to `false`.", "   * `location` (optional) A {String} containing the name of the location", "     in which this item should be opened (one of \"left\", \"right\", \"bottom\",", "     or \"center\"). If omitted, Atom will fall back to the last location in", "     which a user has placed an item with the same URI or, if this is a new", "     URI, the default location specified by the item. NOTE: This option", "     should almost always be omitted to honor user preference.", "", " Returns a {Promise} that resolves to the {TextEditor} for the file URI."], "name": "Workspace.open", "params": ["itemOrURI", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1079, "start_line": 925}, "call_info": {"func_end_line": 1136, "comment": [" Open Atom's license in the active pane."], "code": "  openLicense () {\r\n    return this.open(path.join(process.resourcesPath, 'LICENSE.md'))\r\n  }\r", "name": "open", "func_location": "Workspace.openLicense", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1135, "func_start_line": 1134}}, {"func_info": {"comment": [], "name": "AtomWindow.sendMessage", "params": ["message", "detail"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "end_line": 271, "start_line": 269}, "call_info": {"func_end_line": 255, "code": "  async openLocations (locationsToOpen) {\r\n    await this.loadedPromise\r\n    this.sendMessage('open-locations', locationsToOpen)\r\n  }\r", "name": "sendMessage", "func_location": "AtomWindow.openLocations", "args": [{"type": "string"}, "locationsToOpen"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "line": 254, "func_start_line": 252}}, {"func_info": {"comment": [], "name": "AtomEnvironment.openLocations.pushFolderToOpen", "params": ["folder"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1368, "start_line": 1364}, "call_info": {"func_end_line": 1414, "code": "  async openLocations (locations) {\r\n    const needsProjectPaths = this.project && this.project.getPaths().length === 0\r\n    const foldersToAddToProject = []\r\n    const fileLocationsToOpen = []\r\n\r\n    function pushFolderToOpen (folder) {\r\n      if (!foldersToAddToProject.includes(folder)) {\r\n        foldersToAddToProject.push(folder)\r\n      }\r\n    }\r\n\r\n    for (const location of locations) {\r\n      const {pathToOpen} = location\r\n      if (pathToOpen && (needsProjectPaths || location.forceAddToWindow)) {\r\n        if (fs.existsSync(pathToOpen)) {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(pathToOpen).getPath())\r\n        } else if (fs.existsSync(path.dirname(pathToOpen))) {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(path.dirname(pathToOpen)).getPath())\r\n        } else {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(pathToOpen).getPath())\r\n        }\r\n      }\r\n\r\n      if (!fs.isDirectorySync(pathToOpen)) {\r\n        fileLocationsToOpen.push(location)\r\n      }\r\n\r\n      if (location.hasWaitSession) this.pathsWithWaitSessions.add(pathToOpen)\r\n    }\r\n\r\n    let restoredState = false\r\n    if (foldersToAddToProject.length > 0) {\r\n      const state = await this.loadState(this.getStateKey(foldersToAddToProject))\r\n\r\n      // only restore state if this is the first path added to the project\r\n      if (state && needsProjectPaths) {\r\n        const files = fileLocationsToOpen.map((location) => location.pathToOpen)\r\n        await this.attemptRestoreProjectStateForPaths(state, foldersToAddToProject, files)\r\n        restoredState = true\r\n      } else {\r\n        for (let folder of foldersToAddToProject) {\r\n          this.project.addPath(folder)\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!restoredState) {\r\n      const fileOpenPromises = []\r\n      for (const {pathToOpen, initialLine, initialColumn} of fileLocationsToOpen) {\r\n        fileOpenPromises.push(this.workspace && this.workspace.open(pathToOpen, {initialLine, initialColumn}))\r\n      }\r\n      await Promise.all(fileOpenPromises)\r\n    }\r\n\r\n    ipcRenderer.send('window-command', 'window:locations-opened')\r\n  }\r", "name": "pushFolderToOpen", "func_location": "AtomEnvironment.openLocations", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 1374, "func_start_line": 1359}}, {"func_info": {"comment": [], "name": "AtomEnvironment.openLocations.pushFolderToOpen", "params": ["folder"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1368, "start_line": 1364}, "call_info": {"func_end_line": 1414, "code": "  async openLocations (locations) {\r\n    const needsProjectPaths = this.project && this.project.getPaths().length === 0\r\n    const foldersToAddToProject = []\r\n    const fileLocationsToOpen = []\r\n\r\n    function pushFolderToOpen (folder) {\r\n      if (!foldersToAddToProject.includes(folder)) {\r\n        foldersToAddToProject.push(folder)\r\n      }\r\n    }\r\n\r\n    for (const location of locations) {\r\n      const {pathToOpen} = location\r\n      if (pathToOpen && (needsProjectPaths || location.forceAddToWindow)) {\r\n        if (fs.existsSync(pathToOpen)) {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(pathToOpen).getPath())\r\n        } else if (fs.existsSync(path.dirname(pathToOpen))) {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(path.dirname(pathToOpen)).getPath())\r\n        } else {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(pathToOpen).getPath())\r\n        }\r\n      }\r\n\r\n      if (!fs.isDirectorySync(pathToOpen)) {\r\n        fileLocationsToOpen.push(location)\r\n      }\r\n\r\n      if (location.hasWaitSession) this.pathsWithWaitSessions.add(pathToOpen)\r\n    }\r\n\r\n    let restoredState = false\r\n    if (foldersToAddToProject.length > 0) {\r\n      const state = await this.loadState(this.getStateKey(foldersToAddToProject))\r\n\r\n      // only restore state if this is the first path added to the project\r\n      if (state && needsProjectPaths) {\r\n        const files = fileLocationsToOpen.map((location) => location.pathToOpen)\r\n        await this.attemptRestoreProjectStateForPaths(state, foldersToAddToProject, files)\r\n        restoredState = true\r\n      } else {\r\n        for (let folder of foldersToAddToProject) {\r\n          this.project.addPath(folder)\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!restoredState) {\r\n      const fileOpenPromises = []\r\n      for (const {pathToOpen, initialLine, initialColumn} of fileLocationsToOpen) {\r\n        fileOpenPromises.push(this.workspace && this.workspace.open(pathToOpen, {initialLine, initialColumn}))\r\n      }\r\n      await Promise.all(fileOpenPromises)\r\n    }\r\n\r\n    ipcRenderer.send('window-command', 'window:locations-opened')\r\n  }\r", "name": "pushFolderToOpen", "func_location": "AtomEnvironment.openLocations", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 1376, "func_start_line": 1359}}, {"func_info": {"comment": [], "name": "AtomEnvironment.openLocations.pushFolderToOpen", "params": ["folder"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1368, "start_line": 1364}, "call_info": {"func_end_line": 1414, "code": "  async openLocations (locations) {\r\n    const needsProjectPaths = this.project && this.project.getPaths().length === 0\r\n    const foldersToAddToProject = []\r\n    const fileLocationsToOpen = []\r\n\r\n    function pushFolderToOpen (folder) {\r\n      if (!foldersToAddToProject.includes(folder)) {\r\n        foldersToAddToProject.push(folder)\r\n      }\r\n    }\r\n\r\n    for (const location of locations) {\r\n      const {pathToOpen} = location\r\n      if (pathToOpen && (needsProjectPaths || location.forceAddToWindow)) {\r\n        if (fs.existsSync(pathToOpen)) {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(pathToOpen).getPath())\r\n        } else if (fs.existsSync(path.dirname(pathToOpen))) {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(path.dirname(pathToOpen)).getPath())\r\n        } else {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(pathToOpen).getPath())\r\n        }\r\n      }\r\n\r\n      if (!fs.isDirectorySync(pathToOpen)) {\r\n        fileLocationsToOpen.push(location)\r\n      }\r\n\r\n      if (location.hasWaitSession) this.pathsWithWaitSessions.add(pathToOpen)\r\n    }\r\n\r\n    let restoredState = false\r\n    if (foldersToAddToProject.length > 0) {\r\n      const state = await this.loadState(this.getStateKey(foldersToAddToProject))\r\n\r\n      // only restore state if this is the first path added to the project\r\n      if (state && needsProjectPaths) {\r\n        const files = fileLocationsToOpen.map((location) => location.pathToOpen)\r\n        await this.attemptRestoreProjectStateForPaths(state, foldersToAddToProject, files)\r\n        restoredState = true\r\n      } else {\r\n        for (let folder of foldersToAddToProject) {\r\n          this.project.addPath(folder)\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!restoredState) {\r\n      const fileOpenPromises = []\r\n      for (const {pathToOpen, initialLine, initialColumn} of fileLocationsToOpen) {\r\n        fileOpenPromises.push(this.workspace && this.workspace.open(pathToOpen, {initialLine, initialColumn}))\r\n      }\r\n      await Promise.all(fileOpenPromises)\r\n    }\r\n\r\n    ipcRenderer.send('window-command', 'window:locations-opened')\r\n  }\r", "name": "pushFolderToOpen", "func_location": "AtomEnvironment.openLocations", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 1378, "func_start_line": 1359}}, {"func_info": {"comment": [], "name": "AtomEnvironment.loadState", "params": ["stateKey"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1221, "start_line": 1210}, "call_info": {"func_end_line": 1414, "code": "  async openLocations (locations) {\r\n    const needsProjectPaths = this.project && this.project.getPaths().length === 0\r\n    const foldersToAddToProject = []\r\n    const fileLocationsToOpen = []\r\n\r\n    function pushFolderToOpen (folder) {\r\n      if (!foldersToAddToProject.includes(folder)) {\r\n        foldersToAddToProject.push(folder)\r\n      }\r\n    }\r\n\r\n    for (const location of locations) {\r\n      const {pathToOpen} = location\r\n      if (pathToOpen && (needsProjectPaths || location.forceAddToWindow)) {\r\n        if (fs.existsSync(pathToOpen)) {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(pathToOpen).getPath())\r\n        } else if (fs.existsSync(path.dirname(pathToOpen))) {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(path.dirname(pathToOpen)).getPath())\r\n        } else {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(pathToOpen).getPath())\r\n        }\r\n      }\r\n\r\n      if (!fs.isDirectorySync(pathToOpen)) {\r\n        fileLocationsToOpen.push(location)\r\n      }\r\n\r\n      if (location.hasWaitSession) this.pathsWithWaitSessions.add(pathToOpen)\r\n    }\r\n\r\n    let restoredState = false\r\n    if (foldersToAddToProject.length > 0) {\r\n      const state = await this.loadState(this.getStateKey(foldersToAddToProject))\r\n\r\n      // only restore state if this is the first path added to the project\r\n      if (state && needsProjectPaths) {\r\n        const files = fileLocationsToOpen.map((location) => location.pathToOpen)\r\n        await this.attemptRestoreProjectStateForPaths(state, foldersToAddToProject, files)\r\n        restoredState = true\r\n      } else {\r\n        for (let folder of foldersToAddToProject) {\r\n          this.project.addPath(folder)\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!restoredState) {\r\n      const fileOpenPromises = []\r\n      for (const {pathToOpen, initialLine, initialColumn} of fileLocationsToOpen) {\r\n        fileOpenPromises.push(this.workspace && this.workspace.open(pathToOpen, {initialLine, initialColumn}))\r\n      }\r\n      await Promise.all(fileOpenPromises)\r\n    }\r\n\r\n    ipcRenderer.send('window-command', 'window:locations-opened')\r\n  }\r", "name": "loadState", "func_location": "AtomEnvironment.openLocations", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 1391, "func_start_line": 1359}}, {"func_info": {"comment": [], "name": "AtomEnvironment.getStateKey", "params": ["paths"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1286, "start_line": 1279}, "call_info": {"func_end_line": 1414, "code": "  async openLocations (locations) {\r\n    const needsProjectPaths = this.project && this.project.getPaths().length === 0\r\n    const foldersToAddToProject = []\r\n    const fileLocationsToOpen = []\r\n\r\n    function pushFolderToOpen (folder) {\r\n      if (!foldersToAddToProject.includes(folder)) {\r\n        foldersToAddToProject.push(folder)\r\n      }\r\n    }\r\n\r\n    for (const location of locations) {\r\n      const {pathToOpen} = location\r\n      if (pathToOpen && (needsProjectPaths || location.forceAddToWindow)) {\r\n        if (fs.existsSync(pathToOpen)) {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(pathToOpen).getPath())\r\n        } else if (fs.existsSync(path.dirname(pathToOpen))) {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(path.dirname(pathToOpen)).getPath())\r\n        } else {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(pathToOpen).getPath())\r\n        }\r\n      }\r\n\r\n      if (!fs.isDirectorySync(pathToOpen)) {\r\n        fileLocationsToOpen.push(location)\r\n      }\r\n\r\n      if (location.hasWaitSession) this.pathsWithWaitSessions.add(pathToOpen)\r\n    }\r\n\r\n    let restoredState = false\r\n    if (foldersToAddToProject.length > 0) {\r\n      const state = await this.loadState(this.getStateKey(foldersToAddToProject))\r\n\r\n      // only restore state if this is the first path added to the project\r\n      if (state && needsProjectPaths) {\r\n        const files = fileLocationsToOpen.map((location) => location.pathToOpen)\r\n        await this.attemptRestoreProjectStateForPaths(state, foldersToAddToProject, files)\r\n        restoredState = true\r\n      } else {\r\n        for (let folder of foldersToAddToProject) {\r\n          this.project.addPath(folder)\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!restoredState) {\r\n      const fileOpenPromises = []\r\n      for (const {pathToOpen, initialLine, initialColumn} of fileLocationsToOpen) {\r\n        fileOpenPromises.push(this.workspace && this.workspace.open(pathToOpen, {initialLine, initialColumn}))\r\n      }\r\n      await Promise.all(fileOpenPromises)\r\n    }\r\n\r\n    ipcRenderer.send('window-command', 'window:locations-opened')\r\n  }\r", "name": "getStateKey", "func_location": "AtomEnvironment.openLocations", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 1391, "func_start_line": 1359}}, {"func_info": {"comment": [], "name": "AtomEnvironment.attemptRestoreProjectStateForPaths", "params": ["state", "projectPaths", "filesToOpen"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1181, "start_line": 1129}, "call_info": {"func_end_line": 1414, "code": "  async openLocations (locations) {\r\n    const needsProjectPaths = this.project && this.project.getPaths().length === 0\r\n    const foldersToAddToProject = []\r\n    const fileLocationsToOpen = []\r\n\r\n    function pushFolderToOpen (folder) {\r\n      if (!foldersToAddToProject.includes(folder)) {\r\n        foldersToAddToProject.push(folder)\r\n      }\r\n    }\r\n\r\n    for (const location of locations) {\r\n      const {pathToOpen} = location\r\n      if (pathToOpen && (needsProjectPaths || location.forceAddToWindow)) {\r\n        if (fs.existsSync(pathToOpen)) {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(pathToOpen).getPath())\r\n        } else if (fs.existsSync(path.dirname(pathToOpen))) {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(path.dirname(pathToOpen)).getPath())\r\n        } else {\r\n          pushFolderToOpen(this.project.getDirectoryForProjectPath(pathToOpen).getPath())\r\n        }\r\n      }\r\n\r\n      if (!fs.isDirectorySync(pathToOpen)) {\r\n        fileLocationsToOpen.push(location)\r\n      }\r\n\r\n      if (location.hasWaitSession) this.pathsWithWaitSessions.add(pathToOpen)\r\n    }\r\n\r\n    let restoredState = false\r\n    if (foldersToAddToProject.length > 0) {\r\n      const state = await this.loadState(this.getStateKey(foldersToAddToProject))\r\n\r\n      // only restore state if this is the first path added to the project\r\n      if (state && needsProjectPaths) {\r\n        const files = fileLocationsToOpen.map((location) => location.pathToOpen)\r\n        await this.attemptRestoreProjectStateForPaths(state, foldersToAddToProject, files)\r\n        restoredState = true\r\n      } else {\r\n        for (let folder of foldersToAddToProject) {\r\n          this.project.addPath(folder)\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!restoredState) {\r\n      const fileOpenPromises = []\r\n      for (const {pathToOpen, initialLine, initialColumn} of fileLocationsToOpen) {\r\n        fileOpenPromises.push(this.workspace && this.workspace.open(pathToOpen, {initialLine, initialColumn}))\r\n      }\r\n      await Promise.all(fileOpenPromises)\r\n    }\r\n\r\n    ipcRenderer.send('window-command', 'window:locations-opened')\r\n  }\r", "name": "attemptRestoreProjectStateForPaths", "func_location": "AtomEnvironment.openLocations", "args": ["state", "foldersToAddToProject", "files"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 1396, "func_start_line": 1359}}, {"func_info": {"comment": [], "name": "AtomApplication.getLastFocusedWindow", "params": ["predicate"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 327, "start_line": 325}, "call_info": {"func_end_line": 1069, "code": "  openPackageUriHandler (url, parsedUrl, devMode, safeMode, env) {\r\n    let bestWindow\r\n\r\n    if (parsedUrl.host === 'core') {\r\n      const predicate = require('../core-uri-handlers').windowPredicate(parsedUrl)\r\n      bestWindow = this.getLastFocusedWindow(win => !win.isSpecWindow() && predicate(win))\r\n    }\r\n\r\n    if (!bestWindow) bestWindow = this.getLastFocusedWindow(win => !win.isSpecWindow())\r\n\r\n    if (bestWindow) {\r\n      bestWindow.sendURIMessage(url)\r\n      bestWindow.focus()\r\n    } else {\r\n      let windowInitializationScript\r\n      let {resourcePath} = this\r\n      if (devMode) {\r\n        try {\r\n          windowInitializationScript = require.resolve(\r\n            path.join(this.devResourcePath, 'src', 'initialize-application-window')\r\n          )\r\n          resourcePath = this.devResourcePath\r\n        } catch (error) {}\r\n      }\r\n\r\n      if (!windowInitializationScript) {\r\n        windowInitializationScript = require.resolve('../initialize-application-window')\r\n      }\r\n\r\n      const windowDimensions = this.getDimensionsForNewWindow()\r\n      const window = new AtomWindow(this, this.fileRecoveryService, {\r\n        resourcePath,\r\n        windowInitializationScript,\r\n        devMode,\r\n        safeMode,\r\n        windowDimensions,\r\n        env\r\n      })\r\n      this.addWindow(window)\r\n      window.on('window:loaded', () => window.sendURIMessage(url))\r\n      return window\r\n    }\r\n  }\r", "name": "getLastFocusedWindow", "func_location": "AtomApplication.openPackageUriHandler", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 1032, "func_start_line": 1027}}, {"func_info": {"comment": [], "name": "AtomApplication.getLastFocusedWindow", "params": ["predicate"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 327, "start_line": 325}, "call_info": {"func_end_line": 1069, "code": "  openPackageUriHandler (url, parsedUrl, devMode, safeMode, env) {\r\n    let bestWindow\r\n\r\n    if (parsedUrl.host === 'core') {\r\n      const predicate = require('../core-uri-handlers').windowPredicate(parsedUrl)\r\n      bestWindow = this.getLastFocusedWindow(win => !win.isSpecWindow() && predicate(win))\r\n    }\r\n\r\n    if (!bestWindow) bestWindow = this.getLastFocusedWindow(win => !win.isSpecWindow())\r\n\r\n    if (bestWindow) {\r\n      bestWindow.sendURIMessage(url)\r\n      bestWindow.focus()\r\n    } else {\r\n      let windowInitializationScript\r\n      let {resourcePath} = this\r\n      if (devMode) {\r\n        try {\r\n          windowInitializationScript = require.resolve(\r\n            path.join(this.devResourcePath, 'src', 'initialize-application-window')\r\n          )\r\n          resourcePath = this.devResourcePath\r\n        } catch (error) {}\r\n      }\r\n\r\n      if (!windowInitializationScript) {\r\n        windowInitializationScript = require.resolve('../initialize-application-window')\r\n      }\r\n\r\n      const windowDimensions = this.getDimensionsForNewWindow()\r\n      const window = new AtomWindow(this, this.fileRecoveryService, {\r\n        resourcePath,\r\n        windowInitializationScript,\r\n        devMode,\r\n        safeMode,\r\n        windowDimensions,\r\n        env\r\n      })\r\n      this.addWindow(window)\r\n      window.on('window:loaded', () => window.sendURIMessage(url))\r\n      return window\r\n    }\r\n  }\r", "name": "getLastFocusedWindow", "func_location": "AtomApplication.openPackageUriHandler", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 1035, "func_start_line": 1027}}, {"func_info": {"comment": [" Get the dimensions for opening a new window by cascading as appropriate to", " the platform."], "name": "AtomApplication.getDimensionsForNewWindow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 773, "start_line": 763}, "call_info": {"func_end_line": 1069, "code": "  openPackageUriHandler (url, parsedUrl, devMode, safeMode, env) {\r\n    let bestWindow\r\n\r\n    if (parsedUrl.host === 'core') {\r\n      const predicate = require('../core-uri-handlers').windowPredicate(parsedUrl)\r\n      bestWindow = this.getLastFocusedWindow(win => !win.isSpecWindow() && predicate(win))\r\n    }\r\n\r\n    if (!bestWindow) bestWindow = this.getLastFocusedWindow(win => !win.isSpecWindow())\r\n\r\n    if (bestWindow) {\r\n      bestWindow.sendURIMessage(url)\r\n      bestWindow.focus()\r\n    } else {\r\n      let windowInitializationScript\r\n      let {resourcePath} = this\r\n      if (devMode) {\r\n        try {\r\n          windowInitializationScript = require.resolve(\r\n            path.join(this.devResourcePath, 'src', 'initialize-application-window')\r\n          )\r\n          resourcePath = this.devResourcePath\r\n        } catch (error) {}\r\n      }\r\n\r\n      if (!windowInitializationScript) {\r\n        windowInitializationScript = require.resolve('../initialize-application-window')\r\n      }\r\n\r\n      const windowDimensions = this.getDimensionsForNewWindow()\r\n      const window = new AtomWindow(this, this.fileRecoveryService, {\r\n        resourcePath,\r\n        windowInitializationScript,\r\n        devMode,\r\n        safeMode,\r\n        windowDimensions,\r\n        env\r\n      })\r\n      this.addWindow(window)\r\n      window.on('window:loaded', () => window.sendURIMessage(url))\r\n      return window\r\n    }\r\n  }\r", "name": "getDimensionsForNewWindow", "func_location": "AtomApplication.openPackageUriHandler", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 1056, "func_start_line": 1027}}, {"func_info": {"comment": [" Public: Adds the {AtomWindow} to the global window list."], "name": "AtomApplication.addWindow", "params": ["window"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 319, "start_line": 299}, "call_info": {"func_end_line": 1069, "code": "  openPackageUriHandler (url, parsedUrl, devMode, safeMode, env) {\r\n    let bestWindow\r\n\r\n    if (parsedUrl.host === 'core') {\r\n      const predicate = require('../core-uri-handlers').windowPredicate(parsedUrl)\r\n      bestWindow = this.getLastFocusedWindow(win => !win.isSpecWindow() && predicate(win))\r\n    }\r\n\r\n    if (!bestWindow) bestWindow = this.getLastFocusedWindow(win => !win.isSpecWindow())\r\n\r\n    if (bestWindow) {\r\n      bestWindow.sendURIMessage(url)\r\n      bestWindow.focus()\r\n    } else {\r\n      let windowInitializationScript\r\n      let {resourcePath} = this\r\n      if (devMode) {\r\n        try {\r\n          windowInitializationScript = require.resolve(\r\n            path.join(this.devResourcePath, 'src', 'initialize-application-window')\r\n          )\r\n          resourcePath = this.devResourcePath\r\n        } catch (error) {}\r\n      }\r\n\r\n      if (!windowInitializationScript) {\r\n        windowInitializationScript = require.resolve('../initialize-application-window')\r\n      }\r\n\r\n      const windowDimensions = this.getDimensionsForNewWindow()\r\n      const window = new AtomWindow(this, this.fileRecoveryService, {\r\n        resourcePath,\r\n        windowInitializationScript,\r\n        devMode,\r\n        safeMode,\r\n        windowDimensions,\r\n        env\r\n      })\r\n      this.addWindow(window)\r\n      window.on('window:loaded', () => window.sendURIMessage(url))\r\n      return window\r\n    }\r\n  }\r", "name": "addWindow", "func_location": "AtomApplication.openPackageUriHandler", "args": ["window"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 1065, "func_start_line": 1027}}, {"func_info": {"comment": [], "name": "AtomApplication.getPackageManager", "params": ["devMode"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1106, "start_line": 1094}, "call_info": {"func_end_line": 1092, "code": "  openPackageUrlMain (packageName, packageUrlMain, urlToOpen, devMode, safeMode, env) {\r\n    const packagePath = this.getPackageManager(devMode).resolvePackagePath(packageName)\r\n    const windowInitializationScript = path.resolve(packagePath, packageUrlMain)\r\n    const windowDimensions = this.getDimensionsForNewWindow()\r\n    const window = new AtomWindow(this, this.fileRecoveryService, {\r\n      windowInitializationScript,\r\n      resourcePath: this.resourcePath,\r\n      devMode,\r\n      safeMode,\r\n      urlToOpen,\r\n      windowDimensions,\r\n      env\r\n    })\r\n    this.addWindow(window)\r\n    return window\r\n  }\r", "name": "getPackageManager", "func_location": "AtomApplication.openPackageUrlMain", "args": ["packageName"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 1078, "func_start_line": 1077}}, {"func_info": {"comment": [" Get the dimensions for opening a new window by cascading as appropriate to", " the platform."], "name": "AtomApplication.getDimensionsForNewWindow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 773, "start_line": 763}, "call_info": {"func_end_line": 1092, "code": "  openPackageUrlMain (packageName, packageUrlMain, urlToOpen, devMode, safeMode, env) {\r\n    const packagePath = this.getPackageManager(devMode).resolvePackagePath(packageName)\r\n    const windowInitializationScript = path.resolve(packagePath, packageUrlMain)\r\n    const windowDimensions = this.getDimensionsForNewWindow()\r\n    const window = new AtomWindow(this, this.fileRecoveryService, {\r\n      windowInitializationScript,\r\n      resourcePath: this.resourcePath,\r\n      devMode,\r\n      safeMode,\r\n      urlToOpen,\r\n      windowDimensions,\r\n      env\r\n    })\r\n    this.addWindow(window)\r\n    return window\r\n  }\r", "name": "getDimensionsForNewWindow", "func_location": "AtomApplication.openPackageUrlMain", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 1080, "func_start_line": 1077}}, {"func_info": {"comment": [" Public: Adds the {AtomWindow} to the global window list."], "name": "AtomApplication.addWindow", "params": ["window"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 319, "start_line": 299}, "call_info": {"func_end_line": 1092, "code": "  openPackageUrlMain (packageName, packageUrlMain, urlToOpen, devMode, safeMode, env) {\r\n    const packagePath = this.getPackageManager(devMode).resolvePackagePath(packageName)\r\n    const windowInitializationScript = path.resolve(packagePath, packageUrlMain)\r\n    const windowDimensions = this.getDimensionsForNewWindow()\r\n    const window = new AtomWindow(this, this.fileRecoveryService, {\r\n      windowInitializationScript,\r\n      resourcePath: this.resourcePath,\r\n      devMode,\r\n      safeMode,\r\n      urlToOpen,\r\n      windowDimensions,\r\n      env\r\n    })\r\n    this.addWindow(window)\r\n    return window\r\n  }\r", "name": "addWindow", "func_location": "AtomApplication.openPackageUrlMain", "args": ["window"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 1090, "func_start_line": 1077}}, {"func_info": {"comment": [], "name": "AtomWindow.openLocations", "params": ["locationsToOpen"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "end_line": 255, "start_line": 252}, "call_info": {"func_end_line": 250, "code": "  openPath (pathToOpen, initialLine, initialColumn) {\r\n    return this.openLocations([{pathToOpen, initialLine, initialColumn}])\r\n  }\r", "name": "openLocations", "func_location": "AtomWindow.openPath", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "line": 249, "func_start_line": 248}}, {"func_info": {"comment": [" Public: Opens multiple paths, in existing windows if possible.", "", " options -", "   :pathsToOpen - The array of file paths to open", "   :pidToKillWhenClosed - The integer of the pid to kill", "   :newWindow - Boolean of whether this should be opened in a new window.", "   :devMode - Boolean to control the opened window's dev mode.", "   :safeMode - Boolean to control the opened window's safe mode.", "   :windowDimensions - Object with height and width keys.", "   :window - {AtomWindow} to open file paths in.", "   :addToLastWindow - Boolean of whether this should be opened in last focused window."], "name": "AtomApplication.openPaths", "params": [["initialPaths", "pathsToOpen", "executedFrom", "pidToKillWhenClosed", "newWindow", "devMode", "safeMode", "windowDimensions", "profileStartup", "window", "clearWindowState", "addToLastWindow", "env"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 925, "start_line": 825}, "call_info": {"func_end_line": 812, "name": "openPaths", "func_location": "AtomApplication.openPath", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 799, "func_start_line": 786}}, {"func_info": {"comment": [], "name": "AtomApplication.parsePathToOpen", "params": ["pathToOpen", "executedFrom"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1293, "start_line": 1267}, "call_info": {"func_end_line": 925, "comment": [" Public: Opens multiple paths, in existing windows if possible.", "", " options -", "   :pathsToOpen - The array of file paths to open", "   :pidToKillWhenClosed - The integer of the pid to kill", "   :newWindow - Boolean of whether this should be opened in a new window.", "   :devMode - Boolean to control the opened window's dev mode.", "   :safeMode - Boolean to control the opened window's safe mode.", "   :windowDimensions - Object with height and width keys.", "   :window - {AtomWindow} to open file paths in.", "   :addToLastWindow - Boolean of whether this should be opened in last focused window."], "code": "  openPaths ({\r\n    initialPaths,\r\n    pathsToOpen,\r\n    executedFrom,\r\n    pidToKillWhenClosed,\r\n    newWindow,\r\n    devMode,\r\n    safeMode,\r\n    windowDimensions,\r\n    profileStartup,\r\n    window,\r\n    clearWindowState,\r\n    addToLastWindow,\r\n    env\r\n  } = {}) {\r\n    if (!pathsToOpen || pathsToOpen.length === 0) return\r\n    if (!env) env = process.env\r\n    devMode = Boolean(devMode)\r\n    safeMode = Boolean(safeMode)\r\n    clearWindowState = Boolean(clearWindowState)\r\n\r\n    const locationsToOpen = []\r\n    for (let i = 0; i < pathsToOpen.length; i++) {\r\n      const location = this.parsePathToOpen(pathsToOpen[i], executedFrom, addToLastWindow)\r\n      location.forceAddToWindow = addToLastWindow\r\n      location.hasWaitSession = pidToKillWhenClosed != null\r\n      locationsToOpen.push(location)\r\n      pathsToOpen[i] = location.pathToOpen\r\n    }\r\n\r\n    let existingWindow\r\n    if (!newWindow) {\r\n      existingWindow = this.windowForPaths(pathsToOpen, devMode)\r\n      if (!existingWindow) {\r\n        let lastWindow = window || this.getLastFocusedWindow()\r\n        if (lastWindow && lastWindow.devMode === devMode) {\r\n          if (addToLastWindow || (\r\n              locationsToOpen.every(({stat}) => stat && stat.isFile()) ||\r\n              (locationsToOpen.some(({stat}) => stat && stat.isDirectory()) && !lastWindow.hasProjectPath()))) {\r\n            existingWindow = lastWindow\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    let openedWindow\r\n    if (existingWindow) {\r\n      openedWindow = existingWindow\r\n      openedWindow.openLocations(locationsToOpen)\r\n      if (openedWindow.isMinimized()) {\r\n        openedWindow.restore()\r\n      } else {\r\n        openedWindow.focus()\r\n      }\r\n      openedWindow.replaceEnvironment(env)\r\n    } else {\r\n      let resourcePath, windowInitializationScript\r\n      if (devMode) {\r\n        try {\r\n          windowInitializationScript = require.resolve(\r\n            path.join(this.devResourcePath, 'src', 'initialize-application-window')\r\n          )\r\n          resourcePath = this.devResourcePath\r\n        } catch (error) {}\r\n      }\r\n\r\n      if (!windowInitializationScript) {\r\n        windowInitializationScript = require.resolve('../initialize-application-window')\r\n      }\r\n      if (!resourcePath) resourcePath = this.resourcePath\r\n      if (!windowDimensions) windowDimensions = this.getDimensionsForNewWindow()\r\n\r\n      openedWindow = new AtomWindow(this, this.fileRecoveryService, {\r\n        initialPaths,\r\n        locationsToOpen,\r\n        windowInitializationScript,\r\n        resourcePath,\r\n        devMode,\r\n        safeMode,\r\n        windowDimensions,\r\n        profileStartup,\r\n        clearWindowState,\r\n        env\r\n      })\r\n      this.addWindow(openedWindow)\r\n      openedWindow.focus()\r\n    }\r\n\r\n    if (pidToKillWhenClosed != null) {\r\n      if (!this.waitSessionsByWindow.has(openedWindow)) {\r\n        this.waitSessionsByWindow.set(openedWindow, [])\r\n      }\r\n      this.waitSessionsByWindow.get(openedWindow).push({\r\n        pid: pidToKillWhenClosed,\r\n        remainingPaths: new Set(pathsToOpen)\r\n      })\r\n    }\r\n\r\n    openedWindow.browserWindow.once('closed', () => this.killProcessesForWindow(openedWindow))\r\n    return openedWindow\r\n  }\r", "name": "parsePathToOpen", "func_location": "AtomApplication.openPaths", "args": ["pathsToOpen.i", "executedFrom", "addToLastWindow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 848, "func_start_line": 825}}, {"func_info": {"comment": [" Returns the {AtomWindow} for the given paths."], "name": "AtomApplication.windowForPaths", "params": ["pathsToOpen", "devMode"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 736, "start_line": 732}, "call_info": {"func_end_line": 925, "comment": [" Public: Opens multiple paths, in existing windows if possible.", "", " options -", "   :pathsToOpen - The array of file paths to open", "   :pidToKillWhenClosed - The integer of the pid to kill", "   :newWindow - Boolean of whether this should be opened in a new window.", "   :devMode - Boolean to control the opened window's dev mode.", "   :safeMode - Boolean to control the opened window's safe mode.", "   :windowDimensions - Object with height and width keys.", "   :window - {AtomWindow} to open file paths in.", "   :addToLastWindow - Boolean of whether this should be opened in last focused window."], "code": "  openPaths ({\r\n    initialPaths,\r\n    pathsToOpen,\r\n    executedFrom,\r\n    pidToKillWhenClosed,\r\n    newWindow,\r\n    devMode,\r\n    safeMode,\r\n    windowDimensions,\r\n    profileStartup,\r\n    window,\r\n    clearWindowState,\r\n    addToLastWindow,\r\n    env\r\n  } = {}) {\r\n    if (!pathsToOpen || pathsToOpen.length === 0) return\r\n    if (!env) env = process.env\r\n    devMode = Boolean(devMode)\r\n    safeMode = Boolean(safeMode)\r\n    clearWindowState = Boolean(clearWindowState)\r\n\r\n    const locationsToOpen = []\r\n    for (let i = 0; i < pathsToOpen.length; i++) {\r\n      const location = this.parsePathToOpen(pathsToOpen[i], executedFrom, addToLastWindow)\r\n      location.forceAddToWindow = addToLastWindow\r\n      location.hasWaitSession = pidToKillWhenClosed != null\r\n      locationsToOpen.push(location)\r\n      pathsToOpen[i] = location.pathToOpen\r\n    }\r\n\r\n    let existingWindow\r\n    if (!newWindow) {\r\n      existingWindow = this.windowForPaths(pathsToOpen, devMode)\r\n      if (!existingWindow) {\r\n        let lastWindow = window || this.getLastFocusedWindow()\r\n        if (lastWindow && lastWindow.devMode === devMode) {\r\n          if (addToLastWindow || (\r\n              locationsToOpen.every(({stat}) => stat && stat.isFile()) ||\r\n              (locationsToOpen.some(({stat}) => stat && stat.isDirectory()) && !lastWindow.hasProjectPath()))) {\r\n            existingWindow = lastWindow\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    let openedWindow\r\n    if (existingWindow) {\r\n      openedWindow = existingWindow\r\n      openedWindow.openLocations(locationsToOpen)\r\n      if (openedWindow.isMinimized()) {\r\n        openedWindow.restore()\r\n      } else {\r\n        openedWindow.focus()\r\n      }\r\n      openedWindow.replaceEnvironment(env)\r\n    } else {\r\n      let resourcePath, windowInitializationScript\r\n      if (devMode) {\r\n        try {\r\n          windowInitializationScript = require.resolve(\r\n            path.join(this.devResourcePath, 'src', 'initialize-application-window')\r\n          )\r\n          resourcePath = this.devResourcePath\r\n        } catch (error) {}\r\n      }\r\n\r\n      if (!windowInitializationScript) {\r\n        windowInitializationScript = require.resolve('../initialize-application-window')\r\n      }\r\n      if (!resourcePath) resourcePath = this.resourcePath\r\n      if (!windowDimensions) windowDimensions = this.getDimensionsForNewWindow()\r\n\r\n      openedWindow = new AtomWindow(this, this.fileRecoveryService, {\r\n        initialPaths,\r\n        locationsToOpen,\r\n        windowInitializationScript,\r\n        resourcePath,\r\n        devMode,\r\n        safeMode,\r\n        windowDimensions,\r\n        profileStartup,\r\n        clearWindowState,\r\n        env\r\n      })\r\n      this.addWindow(openedWindow)\r\n      openedWindow.focus()\r\n    }\r\n\r\n    if (pidToKillWhenClosed != null) {\r\n      if (!this.waitSessionsByWindow.has(openedWindow)) {\r\n        this.waitSessionsByWindow.set(openedWindow, [])\r\n      }\r\n      this.waitSessionsByWindow.get(openedWindow).push({\r\n        pid: pidToKillWhenClosed,\r\n        remainingPaths: new Set(pathsToOpen)\r\n      })\r\n    }\r\n\r\n    openedWindow.browserWindow.once('closed', () => this.killProcessesForWindow(openedWindow))\r\n    return openedWindow\r\n  }\r", "name": "windowForPaths", "func_location": "AtomApplication.openPaths", "args": ["pathsToOpen", "devMode"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 857, "func_start_line": 825}}, {"func_info": {"comment": [], "name": "AtomApplication.getLastFocusedWindow", "params": ["predicate"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 327, "start_line": 325}, "call_info": {"func_end_line": 925, "comment": [" Public: Opens multiple paths, in existing windows if possible.", "", " options -", "   :pathsToOpen - The array of file paths to open", "   :pidToKillWhenClosed - The integer of the pid to kill", "   :newWindow - Boolean of whether this should be opened in a new window.", "   :devMode - Boolean to control the opened window's dev mode.", "   :safeMode - Boolean to control the opened window's safe mode.", "   :windowDimensions - Object with height and width keys.", "   :window - {AtomWindow} to open file paths in.", "   :addToLastWindow - Boolean of whether this should be opened in last focused window."], "code": "  openPaths ({\r\n    initialPaths,\r\n    pathsToOpen,\r\n    executedFrom,\r\n    pidToKillWhenClosed,\r\n    newWindow,\r\n    devMode,\r\n    safeMode,\r\n    windowDimensions,\r\n    profileStartup,\r\n    window,\r\n    clearWindowState,\r\n    addToLastWindow,\r\n    env\r\n  } = {}) {\r\n    if (!pathsToOpen || pathsToOpen.length === 0) return\r\n    if (!env) env = process.env\r\n    devMode = Boolean(devMode)\r\n    safeMode = Boolean(safeMode)\r\n    clearWindowState = Boolean(clearWindowState)\r\n\r\n    const locationsToOpen = []\r\n    for (let i = 0; i < pathsToOpen.length; i++) {\r\n      const location = this.parsePathToOpen(pathsToOpen[i], executedFrom, addToLastWindow)\r\n      location.forceAddToWindow = addToLastWindow\r\n      location.hasWaitSession = pidToKillWhenClosed != null\r\n      locationsToOpen.push(location)\r\n      pathsToOpen[i] = location.pathToOpen\r\n    }\r\n\r\n    let existingWindow\r\n    if (!newWindow) {\r\n      existingWindow = this.windowForPaths(pathsToOpen, devMode)\r\n      if (!existingWindow) {\r\n        let lastWindow = window || this.getLastFocusedWindow()\r\n        if (lastWindow && lastWindow.devMode === devMode) {\r\n          if (addToLastWindow || (\r\n              locationsToOpen.every(({stat}) => stat && stat.isFile()) ||\r\n              (locationsToOpen.some(({stat}) => stat && stat.isDirectory()) && !lastWindow.hasProjectPath()))) {\r\n            existingWindow = lastWindow\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    let openedWindow\r\n    if (existingWindow) {\r\n      openedWindow = existingWindow\r\n      openedWindow.openLocations(locationsToOpen)\r\n      if (openedWindow.isMinimized()) {\r\n        openedWindow.restore()\r\n      } else {\r\n        openedWindow.focus()\r\n      }\r\n      openedWindow.replaceEnvironment(env)\r\n    } else {\r\n      let resourcePath, windowInitializationScript\r\n      if (devMode) {\r\n        try {\r\n          windowInitializationScript = require.resolve(\r\n            path.join(this.devResourcePath, 'src', 'initialize-application-window')\r\n          )\r\n          resourcePath = this.devResourcePath\r\n        } catch (error) {}\r\n      }\r\n\r\n      if (!windowInitializationScript) {\r\n        windowInitializationScript = require.resolve('../initialize-application-window')\r\n      }\r\n      if (!resourcePath) resourcePath = this.resourcePath\r\n      if (!windowDimensions) windowDimensions = this.getDimensionsForNewWindow()\r\n\r\n      openedWindow = new AtomWindow(this, this.fileRecoveryService, {\r\n        initialPaths,\r\n        locationsToOpen,\r\n        windowInitializationScript,\r\n        resourcePath,\r\n        devMode,\r\n        safeMode,\r\n        windowDimensions,\r\n        profileStartup,\r\n        clearWindowState,\r\n        env\r\n      })\r\n      this.addWindow(openedWindow)\r\n      openedWindow.focus()\r\n    }\r\n\r\n    if (pidToKillWhenClosed != null) {\r\n      if (!this.waitSessionsByWindow.has(openedWindow)) {\r\n        this.waitSessionsByWindow.set(openedWindow, [])\r\n      }\r\n      this.waitSessionsByWindow.get(openedWindow).push({\r\n        pid: pidToKillWhenClosed,\r\n        remainingPaths: new Set(pathsToOpen)\r\n      })\r\n    }\r\n\r\n    openedWindow.browserWindow.once('closed', () => this.killProcessesForWindow(openedWindow))\r\n    return openedWindow\r\n  }\r", "name": "getLastFocusedWindow", "func_location": "AtomApplication.openPaths", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 859, "func_start_line": 825}}, {"func_info": {"comment": [" Get the dimensions for opening a new window by cascading as appropriate to", " the platform."], "name": "AtomApplication.getDimensionsForNewWindow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 773, "start_line": 763}, "call_info": {"func_end_line": 925, "comment": [" Public: Opens multiple paths, in existing windows if possible.", "", " options -", "   :pathsToOpen - The array of file paths to open", "   :pidToKillWhenClosed - The integer of the pid to kill", "   :newWindow - Boolean of whether this should be opened in a new window.", "   :devMode - Boolean to control the opened window's dev mode.", "   :safeMode - Boolean to control the opened window's safe mode.", "   :windowDimensions - Object with height and width keys.", "   :window - {AtomWindow} to open file paths in.", "   :addToLastWindow - Boolean of whether this should be opened in last focused window."], "code": "  openPaths ({\r\n    initialPaths,\r\n    pathsToOpen,\r\n    executedFrom,\r\n    pidToKillWhenClosed,\r\n    newWindow,\r\n    devMode,\r\n    safeMode,\r\n    windowDimensions,\r\n    profileStartup,\r\n    window,\r\n    clearWindowState,\r\n    addToLastWindow,\r\n    env\r\n  } = {}) {\r\n    if (!pathsToOpen || pathsToOpen.length === 0) return\r\n    if (!env) env = process.env\r\n    devMode = Boolean(devMode)\r\n    safeMode = Boolean(safeMode)\r\n    clearWindowState = Boolean(clearWindowState)\r\n\r\n    const locationsToOpen = []\r\n    for (let i = 0; i < pathsToOpen.length; i++) {\r\n      const location = this.parsePathToOpen(pathsToOpen[i], executedFrom, addToLastWindow)\r\n      location.forceAddToWindow = addToLastWindow\r\n      location.hasWaitSession = pidToKillWhenClosed != null\r\n      locationsToOpen.push(location)\r\n      pathsToOpen[i] = location.pathToOpen\r\n    }\r\n\r\n    let existingWindow\r\n    if (!newWindow) {\r\n      existingWindow = this.windowForPaths(pathsToOpen, devMode)\r\n      if (!existingWindow) {\r\n        let lastWindow = window || this.getLastFocusedWindow()\r\n        if (lastWindow && lastWindow.devMode === devMode) {\r\n          if (addToLastWindow || (\r\n              locationsToOpen.every(({stat}) => stat && stat.isFile()) ||\r\n              (locationsToOpen.some(({stat}) => stat && stat.isDirectory()) && !lastWindow.hasProjectPath()))) {\r\n            existingWindow = lastWindow\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    let openedWindow\r\n    if (existingWindow) {\r\n      openedWindow = existingWindow\r\n      openedWindow.openLocations(locationsToOpen)\r\n      if (openedWindow.isMinimized()) {\r\n        openedWindow.restore()\r\n      } else {\r\n        openedWindow.focus()\r\n      }\r\n      openedWindow.replaceEnvironment(env)\r\n    } else {\r\n      let resourcePath, windowInitializationScript\r\n      if (devMode) {\r\n        try {\r\n          windowInitializationScript = require.resolve(\r\n            path.join(this.devResourcePath, 'src', 'initialize-application-window')\r\n          )\r\n          resourcePath = this.devResourcePath\r\n        } catch (error) {}\r\n      }\r\n\r\n      if (!windowInitializationScript) {\r\n        windowInitializationScript = require.resolve('../initialize-application-window')\r\n      }\r\n      if (!resourcePath) resourcePath = this.resourcePath\r\n      if (!windowDimensions) windowDimensions = this.getDimensionsForNewWindow()\r\n\r\n      openedWindow = new AtomWindow(this, this.fileRecoveryService, {\r\n        initialPaths,\r\n        locationsToOpen,\r\n        windowInitializationScript,\r\n        resourcePath,\r\n        devMode,\r\n        safeMode,\r\n        windowDimensions,\r\n        profileStartup,\r\n        clearWindowState,\r\n        env\r\n      })\r\n      this.addWindow(openedWindow)\r\n      openedWindow.focus()\r\n    }\r\n\r\n    if (pidToKillWhenClosed != null) {\r\n      if (!this.waitSessionsByWindow.has(openedWindow)) {\r\n        this.waitSessionsByWindow.set(openedWindow, [])\r\n      }\r\n      this.waitSessionsByWindow.get(openedWindow).push({\r\n        pid: pidToKillWhenClosed,\r\n        remainingPaths: new Set(pathsToOpen)\r\n      })\r\n    }\r\n\r\n    openedWindow.browserWindow.once('closed', () => this.killProcessesForWindow(openedWindow))\r\n    return openedWindow\r\n  }\r", "name": "getDimensionsForNewWindow", "func_location": "AtomApplication.openPaths", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 895, "func_start_line": 825}}, {"func_info": {"comment": [" Public: Adds the {AtomWindow} to the global window list."], "name": "AtomApplication.addWindow", "params": ["window"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 319, "start_line": 299}, "call_info": {"func_end_line": 925, "comment": [" Public: Opens multiple paths, in existing windows if possible.", "", " options -", "   :pathsToOpen - The array of file paths to open", "   :pidToKillWhenClosed - The integer of the pid to kill", "   :newWindow - Boolean of whether this should be opened in a new window.", "   :devMode - Boolean to control the opened window's dev mode.", "   :safeMode - Boolean to control the opened window's safe mode.", "   :windowDimensions - Object with height and width keys.", "   :window - {AtomWindow} to open file paths in.", "   :addToLastWindow - Boolean of whether this should be opened in last focused window."], "code": "  openPaths ({\r\n    initialPaths,\r\n    pathsToOpen,\r\n    executedFrom,\r\n    pidToKillWhenClosed,\r\n    newWindow,\r\n    devMode,\r\n    safeMode,\r\n    windowDimensions,\r\n    profileStartup,\r\n    window,\r\n    clearWindowState,\r\n    addToLastWindow,\r\n    env\r\n  } = {}) {\r\n    if (!pathsToOpen || pathsToOpen.length === 0) return\r\n    if (!env) env = process.env\r\n    devMode = Boolean(devMode)\r\n    safeMode = Boolean(safeMode)\r\n    clearWindowState = Boolean(clearWindowState)\r\n\r\n    const locationsToOpen = []\r\n    for (let i = 0; i < pathsToOpen.length; i++) {\r\n      const location = this.parsePathToOpen(pathsToOpen[i], executedFrom, addToLastWindow)\r\n      location.forceAddToWindow = addToLastWindow\r\n      location.hasWaitSession = pidToKillWhenClosed != null\r\n      locationsToOpen.push(location)\r\n      pathsToOpen[i] = location.pathToOpen\r\n    }\r\n\r\n    let existingWindow\r\n    if (!newWindow) {\r\n      existingWindow = this.windowForPaths(pathsToOpen, devMode)\r\n      if (!existingWindow) {\r\n        let lastWindow = window || this.getLastFocusedWindow()\r\n        if (lastWindow && lastWindow.devMode === devMode) {\r\n          if (addToLastWindow || (\r\n              locationsToOpen.every(({stat}) => stat && stat.isFile()) ||\r\n              (locationsToOpen.some(({stat}) => stat && stat.isDirectory()) && !lastWindow.hasProjectPath()))) {\r\n            existingWindow = lastWindow\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    let openedWindow\r\n    if (existingWindow) {\r\n      openedWindow = existingWindow\r\n      openedWindow.openLocations(locationsToOpen)\r\n      if (openedWindow.isMinimized()) {\r\n        openedWindow.restore()\r\n      } else {\r\n        openedWindow.focus()\r\n      }\r\n      openedWindow.replaceEnvironment(env)\r\n    } else {\r\n      let resourcePath, windowInitializationScript\r\n      if (devMode) {\r\n        try {\r\n          windowInitializationScript = require.resolve(\r\n            path.join(this.devResourcePath, 'src', 'initialize-application-window')\r\n          )\r\n          resourcePath = this.devResourcePath\r\n        } catch (error) {}\r\n      }\r\n\r\n      if (!windowInitializationScript) {\r\n        windowInitializationScript = require.resolve('../initialize-application-window')\r\n      }\r\n      if (!resourcePath) resourcePath = this.resourcePath\r\n      if (!windowDimensions) windowDimensions = this.getDimensionsForNewWindow()\r\n\r\n      openedWindow = new AtomWindow(this, this.fileRecoveryService, {\r\n        initialPaths,\r\n        locationsToOpen,\r\n        windowInitializationScript,\r\n        resourcePath,\r\n        devMode,\r\n        safeMode,\r\n        windowDimensions,\r\n        profileStartup,\r\n        clearWindowState,\r\n        env\r\n      })\r\n      this.addWindow(openedWindow)\r\n      openedWindow.focus()\r\n    }\r\n\r\n    if (pidToKillWhenClosed != null) {\r\n      if (!this.waitSessionsByWindow.has(openedWindow)) {\r\n        this.waitSessionsByWindow.set(openedWindow, [])\r\n      }\r\n      this.waitSessionsByWindow.get(openedWindow).push({\r\n        pid: pidToKillWhenClosed,\r\n        remainingPaths: new Set(pathsToOpen)\r\n      })\r\n    }\r\n\r\n    openedWindow.browserWindow.once('closed', () => this.killProcessesForWindow(openedWindow))\r\n    return openedWindow\r\n  }\r", "name": "addWindow", "func_location": "AtomApplication.openPaths", "args": ["openedWindow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 909, "func_start_line": 825}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.scopesFromTags", "params": ["startingScopes", "tags"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 490, "start_line": 472}, "call_info": {"func_end_line": 470, "code": "  openScopesForRow (bufferRow) {\r\n    const precedingLine = this.tokenizedLines[bufferRow - 1]\r\n    if (precedingLine) {\r\n      return this.scopesFromTags(precedingLine.openScopes, precedingLine.tags)\r\n    } else {\r\n      return []\r\n    }\r\n  }\r", "name": "scopesFromTags", "func_location": "TextMateLanguageMode.openScopesForRow", "args": ["precedingLine.openScopes", "precedingLine.tags"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 466, "func_start_line": 463}}, {"func_info": {"comment": [" Extended: Get the active {Pane}.", "", " Returns a {Pane}."], "name": "Workspace.getActivePane", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1444, "start_line": 1442}, "call_info": {"func_end_line": 1177, "comment": [" Synchronously open the given URI in the active pane. **Only use this method", " in specs. Calling this in production code will block the UI thread and", " everyone will be mad at you.**", "", " * `uri` A {String} containing a URI.", " * `options` An optional options {Object}", "   * `initialLine` A {Number} indicating which row to move the cursor to", "     initially. Defaults to `0`.", "   * `initialColumn` A {Number} indicating which column to move the cursor to", "     initially. Defaults to `0`.", "   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on", "     the containing pane. Defaults to `true`.", "   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}", "     on containing pane. Defaults to `true`."], "code": "  openSync (uri_ = '', options = {}) {\r\n    const {initialLine, initialColumn} = options\r\n    const activatePane = options.activatePane != null ? options.activatePane : true\r\n    const activateItem = options.activateItem != null ? options.activateItem : true\r\n\r\n    const uri = this.project.resolvePath(uri_)\r\n    let item = this.getActivePane().itemForURI(uri)\r\n    if (uri && (item == null)) {\r\n      for (const opener of this.getOpeners()) {\r\n        item = opener(uri, options)\r\n        if (item) break\r\n      }\r\n    }\r\n    if (item == null) {\r\n      item = this.project.openSync(uri, {initialLine, initialColumn})\r\n    }\r\n\r\n    if (activateItem) {\r\n      this.getActivePane().activateItem(item)\r\n    }\r\n    this.itemOpened(item)\r\n    if (activatePane) {\r\n      this.getActivePane().activate()\r\n    }\r\n    return item\r\n  }\r", "name": "getActivePane", "func_location": "Workspace.openSync", "args": ["uri"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1158, "func_start_line": 1152}}, {"func_info": {"comment": [], "name": "Workspace.getOpeners", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1341, "start_line": 1339}, "call_info": {"func_end_line": 1177, "comment": [" Synchronously open the given URI in the active pane. **Only use this method", " in specs. Calling this in production code will block the UI thread and", " everyone will be mad at you.**", "", " * `uri` A {String} containing a URI.", " * `options` An optional options {Object}", "   * `initialLine` A {Number} indicating which row to move the cursor to", "     initially. Defaults to `0`.", "   * `initialColumn` A {Number} indicating which column to move the cursor to", "     initially. Defaults to `0`.", "   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on", "     the containing pane. Defaults to `true`.", "   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}", "     on containing pane. Defaults to `true`."], "code": "  openSync (uri_ = '', options = {}) {\r\n    const {initialLine, initialColumn} = options\r\n    const activatePane = options.activatePane != null ? options.activatePane : true\r\n    const activateItem = options.activateItem != null ? options.activateItem : true\r\n\r\n    const uri = this.project.resolvePath(uri_)\r\n    let item = this.getActivePane().itemForURI(uri)\r\n    if (uri && (item == null)) {\r\n      for (const opener of this.getOpeners()) {\r\n        item = opener(uri, options)\r\n        if (item) break\r\n      }\r\n    }\r\n    if (item == null) {\r\n      item = this.project.openSync(uri, {initialLine, initialColumn})\r\n    }\r\n\r\n    if (activateItem) {\r\n      this.getActivePane().activateItem(item)\r\n    }\r\n    this.itemOpened(item)\r\n    if (activatePane) {\r\n      this.getActivePane().activate()\r\n    }\r\n    return item\r\n  }\r", "name": "getOpeners", "func_location": "Workspace.openSync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1160, "func_start_line": 1152}}, {"func_info": {"comment": [" Extended: Get the active {Pane}.", "", " Returns a {Pane}."], "name": "Workspace.getActivePane", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1444, "start_line": 1442}, "call_info": {"func_end_line": 1177, "comment": [" Synchronously open the given URI in the active pane. **Only use this method", " in specs. Calling this in production code will block the UI thread and", " everyone will be mad at you.**", "", " * `uri` A {String} containing a URI.", " * `options` An optional options {Object}", "   * `initialLine` A {Number} indicating which row to move the cursor to", "     initially. Defaults to `0`.", "   * `initialColumn` A {Number} indicating which column to move the cursor to", "     initially. Defaults to `0`.", "   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on", "     the containing pane. Defaults to `true`.", "   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}", "     on containing pane. Defaults to `true`."], "code": "  openSync (uri_ = '', options = {}) {\r\n    const {initialLine, initialColumn} = options\r\n    const activatePane = options.activatePane != null ? options.activatePane : true\r\n    const activateItem = options.activateItem != null ? options.activateItem : true\r\n\r\n    const uri = this.project.resolvePath(uri_)\r\n    let item = this.getActivePane().itemForURI(uri)\r\n    if (uri && (item == null)) {\r\n      for (const opener of this.getOpeners()) {\r\n        item = opener(uri, options)\r\n        if (item) break\r\n      }\r\n    }\r\n    if (item == null) {\r\n      item = this.project.openSync(uri, {initialLine, initialColumn})\r\n    }\r\n\r\n    if (activateItem) {\r\n      this.getActivePane().activateItem(item)\r\n    }\r\n    this.itemOpened(item)\r\n    if (activatePane) {\r\n      this.getActivePane().activate()\r\n    }\r\n    return item\r\n  }\r", "name": "getActivePane", "func_location": "Workspace.openSync", "args": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1170, "func_start_line": 1152}}, {"func_info": {"comment": [" Removes the item's uri from the list of potential items to reopen."], "name": "Workspace.itemOpened", "params": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1565, "start_line": 1554}, "call_info": {"func_end_line": 1177, "comment": [" Synchronously open the given URI in the active pane. **Only use this method", " in specs. Calling this in production code will block the UI thread and", " everyone will be mad at you.**", "", " * `uri` A {String} containing a URI.", " * `options` An optional options {Object}", "   * `initialLine` A {Number} indicating which row to move the cursor to", "     initially. Defaults to `0`.", "   * `initialColumn` A {Number} indicating which column to move the cursor to", "     initially. Defaults to `0`.", "   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on", "     the containing pane. Defaults to `true`.", "   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}", "     on containing pane. Defaults to `true`."], "code": "  openSync (uri_ = '', options = {}) {\r\n    const {initialLine, initialColumn} = options\r\n    const activatePane = options.activatePane != null ? options.activatePane : true\r\n    const activateItem = options.activateItem != null ? options.activateItem : true\r\n\r\n    const uri = this.project.resolvePath(uri_)\r\n    let item = this.getActivePane().itemForURI(uri)\r\n    if (uri && (item == null)) {\r\n      for (const opener of this.getOpeners()) {\r\n        item = opener(uri, options)\r\n        if (item) break\r\n      }\r\n    }\r\n    if (item == null) {\r\n      item = this.project.openSync(uri, {initialLine, initialColumn})\r\n    }\r\n\r\n    if (activateItem) {\r\n      this.getActivePane().activateItem(item)\r\n    }\r\n    this.itemOpened(item)\r\n    if (activatePane) {\r\n      this.getActivePane().activate()\r\n    }\r\n    return item\r\n  }\r", "name": "itemOpened", "func_location": "Workspace.openSync", "args": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1172, "func_start_line": 1152}}, {"func_info": {"comment": [" Extended: Get the active {Pane}.", "", " Returns a {Pane}."], "name": "Workspace.getActivePane", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1444, "start_line": 1442}, "call_info": {"func_end_line": 1177, "comment": [" Synchronously open the given URI in the active pane. **Only use this method", " in specs. Calling this in production code will block the UI thread and", " everyone will be mad at you.**", "", " * `uri` A {String} containing a URI.", " * `options` An optional options {Object}", "   * `initialLine` A {Number} indicating which row to move the cursor to", "     initially. Defaults to `0`.", "   * `initialColumn` A {Number} indicating which column to move the cursor to", "     initially. Defaults to `0`.", "   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on", "     the containing pane. Defaults to `true`.", "   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}", "     on containing pane. Defaults to `true`."], "code": "  openSync (uri_ = '', options = {}) {\r\n    const {initialLine, initialColumn} = options\r\n    const activatePane = options.activatePane != null ? options.activatePane : true\r\n    const activateItem = options.activateItem != null ? options.activateItem : true\r\n\r\n    const uri = this.project.resolvePath(uri_)\r\n    let item = this.getActivePane().itemForURI(uri)\r\n    if (uri && (item == null)) {\r\n      for (const opener of this.getOpeners()) {\r\n        item = opener(uri, options)\r\n        if (item) break\r\n      }\r\n    }\r\n    if (item == null) {\r\n      item = this.project.openSync(uri, {initialLine, initialColumn})\r\n    }\r\n\r\n    if (activateItem) {\r\n      this.getActivePane().activateItem(item)\r\n    }\r\n    this.itemOpened(item)\r\n    if (activatePane) {\r\n      this.getActivePane().activate()\r\n    }\r\n    return item\r\n  }\r", "name": "getActivePane", "func_location": "Workspace.openSync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1174, "func_start_line": 1152}}, {"func_info": {"comment": ["\r\n  Section: Opening\r\n  ", " Essential: Opens the given URI in Atom asynchronously.", " If the URI is already open, the existing item for that URI will be", " activated. If no URI is given, or no registered opener can open", " the URI, a new empty {TextEditor} will be created.", "", " * `uri` (optional) A {String} containing a URI.", " * `options` (optional) {Object}", "   * `initialLine` A {Number} indicating which row to move the cursor to", "     initially. Defaults to `0`.", "   * `initialColumn` A {Number} indicating which column to move the cursor to", "     initially. Defaults to `0`.", "   * `split` Either 'left', 'right', 'up' or 'down'.", "     If 'left', the item will be opened in leftmost pane of the current active pane's row.", "     If 'right', the item will be opened in the rightmost pane of the current active pane's row. If only one pane exists in the row, a new pane will be created.", "     If 'up', the item will be opened in topmost pane of the current active pane's column.", "     If 'down', the item will be opened in the bottommost pane of the current active pane's column. If only one pane exists in the column, a new pane will be created.", "   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on", "     containing pane. Defaults to `true`.", "   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}", "     on containing pane. Defaults to `true`.", "   * `pending` A {Boolean} indicating whether or not the item should be opened", "     in a pending state. Existing pending items in a pane are replaced with", "     new pending items when they are opened.", "   * `searchAllPanes` A {Boolean}. If `true`, the workspace will attempt to", "     activate an existing item for the given URI on any pane.", "     If `false`, only the active pane will be searched for", "     an existing item for the same URI. Defaults to `false`.", "   * `location` (optional) A {String} containing the name of the location", "     in which this item should be opened (one of \"left\", \"right\", \"bottom\",", "     or \"center\"). If omitted, Atom will fall back to the last location in", "     which a user has placed an item with the same URI or, if this is a new", "     URI, the default location specified by the item. NOTE: This option", "     should almost always be omitted to honor user preference.", "", " Returns a {Promise} that resolves to the {TextEditor} for the file URI."], "name": "Workspace.open", "params": ["itemOrURI", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1079, "start_line": 925}, "call_info": {"func_end_line": 1181, "code": "  openURIInPane (uri, pane) {\r\n    return this.open(uri, {pane})\r\n  }\r", "name": "open", "func_location": "Workspace.openURIInPane", "args": ["uri", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1180, "func_start_line": 1179}}, {"func_info": {"comment": [], "name": "AtomApplication.findPackageWithName", "params": ["packageName", "devMode"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1075, "start_line": 1071}, "call_info": {"func_end_line": 1025, "comment": [" Open an atom:// url.", "", " The host of the URL being opened is assumed to be the package name", " responsible for opening the URL.  A new window will be created with", " that package's `urlMain` as the bootstrap script.", "", " options -", "   :urlToOpen - The atom:// url to open.", "   :devMode - Boolean to control the opened window's dev mode.", "   :safeMode - Boolean to control the opened window's safe mode."], "code": "  openUrl ({urlToOpen, devMode, safeMode, env}) {\r\n    const parsedUrl = url.parse(urlToOpen, true)\r\n    if (parsedUrl.protocol !== 'atom:') return\r\n\r\n    const pack = this.findPackageWithName(parsedUrl.host, devMode)\r\n    if (pack && pack.urlMain) {\r\n      return this.openPackageUrlMain(\r\n        parsedUrl.host,\r\n        pack.urlMain,\r\n        urlToOpen,\r\n        devMode,\r\n        safeMode,\r\n        env\r\n      )\r\n    } else {\r\n      return this.openPackageUriHandler(urlToOpen, parsedUrl, devMode, safeMode, env)\r\n    }\r\n  }\r", "name": "findPackageWithName", "func_location": "AtomApplication.openUrl", "args": ["parsedUrl.host", "devMode"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 1012, "func_start_line": 1008}}, {"func_info": {"comment": [], "name": "AtomApplication.openPackageUrlMain", "params": ["packageName", "packageUrlMain", "urlToOpen", "devMode", "safeMode", "env"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1092, "start_line": 1077}, "call_info": {"func_end_line": 1025, "name": "openPackageUrlMain", "func_location": "AtomApplication.openUrl", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 1014, "func_start_line": 1008}}, {"func_info": {"comment": [], "name": "AtomApplication.openPackageUriHandler", "params": ["url", "parsedUrl", "devMode", "safeMode", "env"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1069, "start_line": 1027}, "call_info": {"func_end_line": 1025, "comment": [" Open an atom:// url.", "", " The host of the URL being opened is assumed to be the package name", " responsible for opening the URL.  A new window will be created with", " that package's `urlMain` as the bootstrap script.", "", " options -", "   :urlToOpen - The atom:// url to open.", "   :devMode - Boolean to control the opened window's dev mode.", "   :safeMode - Boolean to control the opened window's safe mode."], "code": "  openUrl ({urlToOpen, devMode, safeMode, env}) {\r\n    const parsedUrl = url.parse(urlToOpen, true)\r\n    if (parsedUrl.protocol !== 'atom:') return\r\n\r\n    const pack = this.findPackageWithName(parsedUrl.host, devMode)\r\n    if (pack && pack.urlMain) {\r\n      return this.openPackageUrlMain(\r\n        parsedUrl.host,\r\n        pack.urlMain,\r\n        urlToOpen,\r\n        devMode,\r\n        safeMode,\r\n        env\r\n      )\r\n    } else {\r\n      return this.openPackageUriHandler(urlToOpen, parsedUrl, devMode, safeMode, env)\r\n    }\r\n  }\r", "name": "openPackageUriHandler", "func_location": "AtomApplication.openUrl", "args": ["urlToOpen", "parsedUrl", "devMode", "safeMode", "env"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 1023, "func_start_line": 1008}}, {"func_info": {"comment": [" Opens up a new {AtomWindow} to run specs within.", "", " options -", "   :headless - A Boolean that, if true, will close the window upon", "                   completion.", "   :resourcePath - The path to include specs from.", "   :specPath - The directory to load specs from.", "   :safeMode - A Boolean that, if true, won't run specs from ~/.atom/packages", "               and ~/.atom/dev/packages, defaults to false."], "name": "AtomApplication.runTests", "params": [["headless", "resourcePath", "executedFrom", "pathsToOpen", "logFile", "safeMode", "timeout", "env"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1179, "start_line": 1117}, "call_info": {"func_end_line": 281, "name": "runTests", "func_location": "AtomApplication.openWithOptions", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 231, "func_start_line": 207}}, {"func_info": {"comment": [], "name": "AtomApplication.runBenchmarks", "params": [["headless", "test", "resourcePath", "executedFrom", "pathsToOpen", "env"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1225, "start_line": 1181}, "call_info": {"func_end_line": 281, "name": "runBenchmarks", "func_location": "AtomApplication.openWithOptions", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 242, "func_start_line": 207}}, {"func_info": {"comment": [" Public: Opens multiple paths, in existing windows if possible.", "", " options -", "   :pathsToOpen - The array of file paths to open", "   :pidToKillWhenClosed - The integer of the pid to kill", "   :newWindow - Boolean of whether this should be opened in a new window.", "   :devMode - Boolean to control the opened window's dev mode.", "   :safeMode - Boolean to control the opened window's safe mode.", "   :windowDimensions - Object with height and width keys.", "   :window - {AtomWindow} to open file paths in.", "   :addToLastWindow - Boolean of whether this should be opened in last focused window."], "name": "AtomApplication.openPaths", "params": [["initialPaths", "pathsToOpen", "executedFrom", "pidToKillWhenClosed", "newWindow", "devMode", "safeMode", "windowDimensions", "profileStartup", "window", "clearWindowState", "addToLastWindow", "env"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 925, "start_line": 825}, "call_info": {"func_end_line": 281, "name": "openPaths", "func_location": "AtomApplication.openWithOptions", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 252, "func_start_line": 207}}, {"func_info": {"comment": [" Public: Opens a single path, in an existing window if possible.", "", " options -", "   :pathToOpen - The file path to open", "   :pidToKillWhenClosed - The integer of the pid to kill", "   :newWindow - Boolean of whether this should be opened in a new window.", "   :devMode - Boolean to control the opened window's dev mode.", "   :safeMode - Boolean to control the opened window's safe mode.", "   :profileStartup - Boolean to control creating a profile of the startup time.", "   :window - {AtomWindow} to open file paths in.", "   :addToLastWindow - Boolean of whether this should be opened in last focused window."], "name": "AtomApplication.openPath", "params": [["initialPaths", "pathToOpen", "pidToKillWhenClosed", "newWindow", "devMode", "safeMode", "profileStartup", "window", "clearWindowState", "addToLastWindow", "env"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 812, "start_line": 786}, "call_info": {"func_end_line": 281, "name": "openPath", "func_location": "AtomApplication.openWithOptions", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 269, "func_start_line": 207}}, {"func_info": {"comment": [], "name": "Workspace.getPaneContainers", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1625, "start_line": 1618}, "call_info": {"func_end_line": 1475, "comment": [" Extended: Get the first pane container that contains the given item.", "", " * `item` the Item that the returned pane container must contain.", "", " Returns a {Dock}, the {WorkspaceCenter}, or `undefined` if no item exists", " with the given URI."], "code": "  paneContainerForItem (uri) {\r\n    return this.getPaneContainers().find(container => container.paneForItem(uri))\r\n  }\r", "name": "getPaneContainers", "func_location": "Workspace.paneContainerForItem", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1474, "func_start_line": 1473}}, {"func_info": {"comment": [], "name": "Workspace.getPaneContainers", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1625, "start_line": 1618}, "call_info": {"func_end_line": 1465, "comment": [" Extended: Get the first pane container that contains an item with the given", " URI.", "", " * `uri` {String} uri", "", " Returns a {Dock}, the {WorkspaceCenter}, or `undefined` if no item exists", " with the given URI."], "code": "  paneContainerForURI (uri) {\r\n    return this.getPaneContainers().find(container => container.paneForURI(uri))\r\n  }\r", "name": "getPaneContainers", "func_location": "Workspace.paneContainerForURI", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1464, "func_start_line": 1463}}, {"func_info": {"comment": [], "name": "PaneContainer.getPanes", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 152, "start_line": 146}, "call_info": {"func_end_line": 172, "code": "  paneForItem (item) {\r\n    return find(this.getPanes(), pane => pane.getItems().includes(item))\r\n  }\r", "name": "getPanes", "func_location": "PaneContainer.paneForItem", "args": [null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 171, "func_start_line": 170}}, {"func_info": {"comment": [], "name": "Workspace.getPaneContainers", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1625, "start_line": 1618}, "call_info": {"func_end_line": 1503, "comment": [" Extended: Get the {Pane} containing the given item.", "", " * `item` the Item that the returned pane must contain.", "", " Returns a {Pane} or `undefined` if no pane exists for the given item."], "code": "  paneForItem (item) {\r\n    for (let location of this.getPaneContainers()) {\r\n      const pane = location.paneForItem(item)\r\n      if (pane != null) {\r\n        return pane\r\n      }\r\n    }\r\n  }\r", "name": "getPaneContainers", "func_location": "Workspace.paneForItem", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1497, "func_start_line": 1496}}, {"func_info": {"comment": [], "name": "PaneContainer.getPanes", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 152, "start_line": 146}, "call_info": {"func_end_line": 168, "code": "  paneForURI (uri) {\r\n    return find(this.getPanes(), pane => pane.itemForURI(uri) != null)\r\n  }\r", "name": "getPanes", "func_location": "PaneContainer.paneForURI", "args": [null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 167, "func_start_line": 166}}, {"func_info": {"comment": [], "name": "Workspace.getPaneContainers", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1625, "start_line": 1618}, "call_info": {"func_end_line": 1489, "comment": [" Extended: Get the first {Pane} that contains an item with the given URI.", "", " * `uri` {String} uri", "", " Returns a {Pane} or `undefined` if no item exists with the given URI."], "code": "  paneForURI (uri) {\r\n    for (let location of this.getPaneContainers()) {\r\n      const pane = location.paneForURI(uri)\r\n      if (pane != null) {\r\n        return pane\r\n      }\r\n    }\r\n  }\r", "name": "getPaneContainers", "func_location": "Workspace.paneForURI", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1483, "func_start_line": 1482}}, {"func_info": {"comment": [], "name": "PanelContainerElement.hideAllPanelsExcept", "params": ["excludedPanel"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/panel-container-element.js", "end_line": 90, "start_line": 86}, "call_info": {"func_end_line": 77, "code": "  panelAdded ({panel, index}) {\r\n    const panelElement = panel.getElement()\r\n    panelElement.classList.add(this.model.getLocation())\r\n    if (this.model.isModal()) {\r\n      panelElement.classList.add('overlay', 'from-top')\r\n    } else {\r\n      panelElement.classList.add('tool-panel', `panel-${this.model.getLocation()}`)\r\n    }\r\n\r\n    if (index >= this.childNodes.length) {\r\n      this.appendChild(panelElement)\r\n    } else {\r\n      const referenceItem = this.childNodes[index]\r\n      this.insertBefore(panelElement, referenceItem)\r\n    }\r\n\r\n    if (this.model.isModal()) {\r\n      this.hideAllPanelsExcept(panel)\r\n      this.subscriptions.add(panel.onDidChangeVisible(visible => {\r\n        if (visible) { this.hideAllPanelsExcept(panel) }\r\n      }))\r\n\r\n      if (panel.autoFocus) {\r\n        const modalFocusTrap = focusTrap(panelElement, {\r\n          // focus-trap will attempt to give focus to the first tabbable element\r\n          // on activation. If there aren't any tabbable elements,\r\n          // give focus to the panel element itself\r\n          fallbackFocus: panelElement,\r\n          // closing is handled by core Atom commands and this already deactivates\r\n          // on visibility changes\r\n          escapeDeactivates: false\r\n        })\r\n\r\n        this.subscriptions.add(panel.onDidChangeVisible(visible => {\r\n          if (visible) {\r\n            modalFocusTrap.activate()\r\n          } else {\r\n            modalFocusTrap.deactivate()\r\n          }\r\n        }))\r\n      }\r\n    }\r\n  }\r", "name": "hideAllPanelsExcept", "func_location": "PanelContainerElement.panelAdded", "args": ["panel"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/panel-container-element.js", "line": 52, "func_start_line": 35}}, {"func_info": {"comment": [], "name": "Color.constructor", "params": ["red", "green", "blue", "alpha"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js", "end_line": 43, "start_line": 38}, "call_info": {"func_end_line": 36, "comment": [" Essential: Parse a {String} or {Object} into a {Color}.", "", " * `value` A {String} such as `'white'`, `#ff00ff`, or", "   `'rgba(255, 15, 60, .75)'` or an {Object} with `red`, `green`, `blue`,", "   and `alpha` properties.", "", " Returns a {Color} or `null` if it cannot be parsed."], "code": "  static parse (value) {\r\n    switch (typeof value) {\r\n      case 'string':\r\n        break\r\n      case 'object':\r\n        if (Array.isArray(value)) { return null }\r\n        break\r\n      default:\r\n        return null\r\n    }\r\n\r\n    if (!ParsedColor) {\r\n      ParsedColor = require('color')\r\n    }\r\n\r\n    try {\r\n      var parsedColor = new ParsedColor(value)\r\n    } catch (error) {\r\n      return null\r\n    }\r\n\r\n    return new Color(parsedColor.red(), parsedColor.green(), parsedColor.blue(), parsedColor.alpha())\r\n  }\r", "name": "constructor", "func_location": "Color.parse", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js", "line": 35, "func_start_line": 14}}, {"func_info": {"comment": [], "name": "StorageFolder.getPath", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/storage-folder.js", "end_line": 48, "start_line": 46}, "call_info": {"func_end_line": 44, "code": "  pathForKey (name) {\r\n    return path.join(this.getPath(), name)\r\n  }\r", "name": "getPath", "func_location": "StorageFolder.pathForKey", "args": [null, "name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/storage-folder.js", "line": 43, "func_start_line": 42}}, {"func_info": {"comment": [], "name": "TextEditorComponent.stopCursorBlinking", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1999, "start_line": 1991}, "call_info": {"func_end_line": 1984, "code": "  pauseCursorBlinking () {\r\n    this.stopCursorBlinking()\r\n    this.debouncedResumeCursorBlinking()\r\n  }\r", "name": "stopCursorBlinking", "func_location": "TextEditorComponent.pauseCursorBlinking", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1982, "func_start_line": 1981}}, {"func_info": {"comment": [], "name": "TextEditorComponent.renderedScreenLineForRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 961, "start_line": 956}, "call_info": {"func_end_line": 2377, "code": "  pixelLeftForRowAndColumn (row, column) {\r\n    if (column === 0) return 0\r\n    const screenLine = this.renderedScreenLineForRow(row)\r\n    if (screenLine) {\r\n      const horizontalPositionsByColumn = this.horizontalPixelPositionsByScreenLineId.get(screenLine.id)\r\n      if (horizontalPositionsByColumn) {\r\n        return horizontalPositionsByColumn.get(column)\r\n      }\r\n    }\r\n  }\r", "name": "renderedScreenLineForRow", "func_location": "TextEditorComponent.pixelLeftForRowAndColumn", "args": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2370, "func_start_line": 2368}}, {"func_info": {"comment": [], "name": "TextEditorElement.getModel", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 82, "start_line": 80}, "call_info": {"func_end_line": 232, "comment": [" Extended: Converts a buffer position to a pixel position.", "", " * `bufferPosition` A {Point}-like object that represents a buffer position.", "", " Be aware that calling this method with a column that does not translate", " to column 0 on screen could cause a synchronous DOM update in order to", " measure the requested horizontal pixel position if it isn't already", " cached.", "", " Returns an {Object} with two values: `top` and `left`, representing the", " pixel position."], "code": "  pixelPositionForBufferPosition (bufferPosition) {\r\n    const screenPosition = this.getModel().screenPositionForBufferPosition(bufferPosition)\r\n    return this.getComponent().pixelPositionForScreenPosition(screenPosition)\r\n  }\r", "name": "getModel", "func_location": "TextEditorElement.pixelPositionForBufferPosition", "args": ["bufferPosition"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 230, "func_start_line": 229}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 232, "comment": [" Extended: Converts a buffer position to a pixel position.", "", " * `bufferPosition` A {Point}-like object that represents a buffer position.", "", " Be aware that calling this method with a column that does not translate", " to column 0 on screen could cause a synchronous DOM update in order to", " measure the requested horizontal pixel position if it isn't already", " cached.", "", " Returns an {Object} with two values: `top` and `left`, representing the", " pixel position."], "code": "  pixelPositionForBufferPosition (bufferPosition) {\r\n    const screenPosition = this.getModel().screenPositionForBufferPosition(bufferPosition)\r\n    return this.getComponent().pixelPositionForScreenPosition(screenPosition)\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.pixelPositionForBufferPosition", "args": ["screenPosition"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 231, "func_start_line": 229}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelPositionAfterBlocksForRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2366, "start_line": 2364}, "call_info": {"func_end_line": 202, "code": "  pixelPositionForScreenPosition ({row, column}) {\r\n    const top = this.pixelPositionAfterBlocksForRow(row)\r\n    let left = column === 0 ? 0 : this.pixelLeftForRowAndColumn(row, column)\r\n    if (left == null) {\r\n      this.requestHorizontalMeasurement(row, column)\r\n      this.updateSync()\r\n      left = this.pixelLeftForRowAndColumn(row, column)\r\n    }\r\n    return {top, left}\r\n  }\r", "name": "pixelPositionAfterBlocksForRow", "func_location": "TextEditorComponent.pixelPositionForScreenPosition", "args": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 194, "func_start_line": 193}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelLeftForRowAndColumn", "params": ["row", "column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2377, "start_line": 2368}, "call_info": {"func_end_line": 202, "code": "  pixelPositionForScreenPosition ({row, column}) {\r\n    const top = this.pixelPositionAfterBlocksForRow(row)\r\n    let left = column === 0 ? 0 : this.pixelLeftForRowAndColumn(row, column)\r\n    if (left == null) {\r\n      this.requestHorizontalMeasurement(row, column)\r\n      this.updateSync()\r\n      left = this.pixelLeftForRowAndColumn(row, column)\r\n    }\r\n    return {top, left}\r\n  }\r", "name": "pixelLeftForRowAndColumn", "func_location": "TextEditorComponent.pixelPositionForScreenPosition", "args": ["row", "column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 195, "func_start_line": 193}}, {"func_info": {"comment": [], "name": "TextEditorComponent.requestHorizontalMeasurement", "params": ["row", "column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2257, "start_line": 2243}, "call_info": {"func_end_line": 202, "code": "  pixelPositionForScreenPosition ({row, column}) {\r\n    const top = this.pixelPositionAfterBlocksForRow(row)\r\n    let left = column === 0 ? 0 : this.pixelLeftForRowAndColumn(row, column)\r\n    if (left == null) {\r\n      this.requestHorizontalMeasurement(row, column)\r\n      this.updateSync()\r\n      left = this.pixelLeftForRowAndColumn(row, column)\r\n    }\r\n    return {top, left}\r\n  }\r", "name": "requestHorizontalMeasurement", "func_location": "TextEditorComponent.pixelPositionForScreenPosition", "args": ["row", "column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 197, "func_start_line": 193}}, {"func_info": {"comment": [], "name": "TextEditorComponent.updateSync", "params": ["useScheduler"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 289, "start_line": 221}, "call_info": {"func_end_line": 202, "code": "  pixelPositionForScreenPosition ({row, column}) {\r\n    const top = this.pixelPositionAfterBlocksForRow(row)\r\n    let left = column === 0 ? 0 : this.pixelLeftForRowAndColumn(row, column)\r\n    if (left == null) {\r\n      this.requestHorizontalMeasurement(row, column)\r\n      this.updateSync()\r\n      left = this.pixelLeftForRowAndColumn(row, column)\r\n    }\r\n    return {top, left}\r\n  }\r", "name": "updateSync", "func_location": "TextEditorComponent.pixelPositionForScreenPosition", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 198, "func_start_line": 193}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelLeftForRowAndColumn", "params": ["row", "column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2377, "start_line": 2368}, "call_info": {"func_end_line": 202, "code": "  pixelPositionForScreenPosition ({row, column}) {\r\n    const top = this.pixelPositionAfterBlocksForRow(row)\r\n    let left = column === 0 ? 0 : this.pixelLeftForRowAndColumn(row, column)\r\n    if (left == null) {\r\n      this.requestHorizontalMeasurement(row, column)\r\n      this.updateSync()\r\n      left = this.pixelLeftForRowAndColumn(row, column)\r\n    }\r\n    return {top, left}\r\n  }\r", "name": "pixelLeftForRowAndColumn", "func_location": "TextEditorComponent.pixelPositionForScreenPosition", "args": ["row", "column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 199, "func_start_line": 193}}, {"func_info": {"comment": [], "name": "TextEditorElement.getModel", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 82, "start_line": 80}, "call_info": {"func_end_line": 247, "comment": [" Extended: Converts a screen position to a pixel position.", "", " * `screenPosition` A {Point}-like object that represents a buffer position.", "", " Be aware that calling this method with a non-zero column value could", " cause a synchronous DOM update in order to measure the requested", " horizontal pixel position if it isn't already cached.", "", " Returns an {Object} with two values: `top` and `left`, representing the", " pixel position."], "code": "  pixelPositionForScreenPosition (screenPosition) {\r\n    screenPosition = this.getModel().clipScreenPosition(screenPosition)\r\n    return this.getComponent().pixelPositionForScreenPosition(screenPosition)\r\n  }\r", "name": "getModel", "func_location": "TextEditorElement.pixelPositionForScreenPosition", "args": ["screenPosition"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 245, "func_start_line": 244}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 247, "comment": [" Extended: Converts a screen position to a pixel position.", "", " * `screenPosition` A {Point}-like object that represents a buffer position.", "", " Be aware that calling this method with a non-zero column value could", " cause a synchronous DOM update in order to measure the requested", " horizontal pixel position if it isn't already cached.", "", " Returns an {Object} with two values: `top` and `left`, representing the", " pixel position."], "code": "  pixelPositionForScreenPosition (screenPosition) {\r\n    screenPosition = this.getModel().clipScreenPosition(screenPosition)\r\n    return this.getComponent().pixelPositionForScreenPosition(screenPosition)\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.pixelPositionForScreenPosition", "args": ["screenPosition"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 246, "func_start_line": 244}}, {"func_info": {"comment": [" Extended: Converts a screen position to a pixel position.", "", " * `screenPosition` A {Point}-like object that represents a buffer position.", "", " Be aware that calling this method with a non-zero column value could", " cause a synchronous DOM update in order to measure the requested", " horizontal pixel position if it isn't already cached.", "", " Returns an {Object} with two values: `top` and `left`, representing the", " pixel position."], "name": "TextEditorElement.pixelPositionForScreenPosition", "params": ["screenPosition"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 247, "start_line": 244}, "call_info": {"func_end_line": 274, "code": "  pixelRangeForScreenRange (range) {\r\n    range = Range.fromObject(range)\r\n    return {\r\n      start: this.pixelPositionForScreenPosition(range.start),\r\n      end: this.pixelPositionForScreenPosition(range.end)\r\n    }\r\n  }\r", "name": "pixelPositionForScreenPosition", "func_location": "TextEditorElement.pixelRangeForScreenRange", "args": ["range.start"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 271, "func_start_line": 268}}, {"func_info": {"comment": [" Extended: Converts a screen position to a pixel position.", "", " * `screenPosition` A {Point}-like object that represents a buffer position.", "", " Be aware that calling this method with a non-zero column value could", " cause a synchronous DOM update in order to measure the requested", " horizontal pixel position if it isn't already cached.", "", " Returns an {Object} with two values: `top` and `left`, representing the", " pixel position."], "name": "TextEditorElement.pixelPositionForScreenPosition", "params": ["screenPosition"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 247, "start_line": 244}, "call_info": {"func_end_line": 274, "code": "  pixelRangeForScreenRange (range) {\r\n    range = Range.fromObject(range)\r\n    return {\r\n      start: this.pixelPositionForScreenPosition(range.start),\r\n      end: this.pixelPositionForScreenPosition(range.end)\r\n    }\r\n  }\r", "name": "pixelPositionForScreenPosition", "func_location": "TextEditorElement.pixelRangeForScreenRange", "args": ["range.end"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 272, "func_start_line": 268}}, {"func_info": {"comment": [" Extended: Converts a screen position to a pixel position.", "", " * `screenPosition` A {Point}-like object that represents a buffer position.", "", " Be aware that calling this method with a non-zero column value could", " cause a synchronous DOM update in order to measure the requested", " horizontal pixel position if it isn't already cached.", "", " Returns an {Object} with two values: `top` and `left`, representing the", " pixel position."], "name": "TextEditorElement.pixelPositionForScreenPosition", "params": ["screenPosition"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 247, "start_line": 244}, "call_info": {"func_end_line": 266, "code": "  pixelRectForScreenRange (range) {\r\n    range = Range.fromObject(range)\r\n\r\n    const start = this.pixelPositionForScreenPosition(range.start)\r\n    const end = this.pixelPositionForScreenPosition(range.end)\r\n    const lineHeight = this.getComponent().getLineHeight()\r\n\r\n    return {\r\n      top: start.top,\r\n      left: start.left,\r\n      height: end.top + lineHeight - start.top,\r\n      width: end.left - start.left\r\n    }\r\n  }\r", "name": "pixelPositionForScreenPosition", "func_location": "TextEditorElement.pixelRectForScreenRange", "args": ["range.start"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 256, "func_start_line": 253}}, {"func_info": {"comment": [" Extended: Converts a screen position to a pixel position.", "", " * `screenPosition` A {Point}-like object that represents a buffer position.", "", " Be aware that calling this method with a non-zero column value could", " cause a synchronous DOM update in order to measure the requested", " horizontal pixel position if it isn't already cached.", "", " Returns an {Object} with two values: `top` and `left`, representing the", " pixel position."], "name": "TextEditorElement.pixelPositionForScreenPosition", "params": ["screenPosition"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 247, "start_line": 244}, "call_info": {"func_end_line": 266, "code": "  pixelRectForScreenRange (range) {\r\n    range = Range.fromObject(range)\r\n\r\n    const start = this.pixelPositionForScreenPosition(range.start)\r\n    const end = this.pixelPositionForScreenPosition(range.end)\r\n    const lineHeight = this.getComponent().getLineHeight()\r\n\r\n    return {\r\n      top: start.top,\r\n      left: start.left,\r\n      height: end.top + lineHeight - start.top,\r\n      width: end.left - start.left\r\n    }\r\n  }\r", "name": "pixelPositionForScreenPosition", "func_location": "TextEditorElement.pixelRectForScreenRange", "args": ["range.end"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 257, "func_start_line": 253}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 266, "code": "  pixelRectForScreenRange (range) {\r\n    range = Range.fromObject(range)\r\n\r\n    const start = this.pixelPositionForScreenPosition(range.start)\r\n    const end = this.pixelPositionForScreenPosition(range.end)\r\n    const lineHeight = this.getComponent().getLineHeight()\r\n\r\n    return {\r\n      top: start.top,\r\n      left: start.left,\r\n      height: end.top + lineHeight - start.top,\r\n      width: end.left - start.left\r\n    }\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.pixelRectForScreenRange", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 258, "func_start_line": 253}}, {"func_info": {"comment": [], "name": "AutoUpdateManager.getState", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/auto-update-manager.js", "end_line": 46, "start_line": 44}, "call_info": {"func_end_line": 54, "code": "  platformSupportsUpdates () {\r\n    return atom.getReleaseChannel() !== 'dev' && this.getState() !== 'unsupported'\r\n  }\r", "name": "getState", "func_location": "AutoUpdateManager.platformSupportsUpdates", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/auto-update-manager.js", "line": 53, "func_start_line": 52}}, {"func_info": {"comment": [], "name": "rectContainsPoint", "params": ["rect", "point"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 855, "start_line": 848}, "call_info": {"func_end_line": 405, "comment": [" Determine whether the cursor is within the dock hover area. This isn't as simple as just using", " mouseenter/leave because we want to be a little more forgiving. For example, if the cursor is", " over the footer, we want to show the bottom dock's toggle button. Also note that our criteria", " for detecting entry are different than detecting exit but, in order for us to avoid jitter, the", " area considered when detecting exit MUST fully encompass the area considered when detecting", " entry."], "code": "  pointWithinHoverArea (point, detectingExit) {\r\n    const dockBounds = this.refs.innerElement.getBoundingClientRect()\r\n\r\n    // Copy the bounds object since we can't mutate it.\r\n    const bounds = {\r\n      top: dockBounds.top,\r\n      right: dockBounds.right,\r\n      bottom: dockBounds.bottom,\r\n      left: dockBounds.left\r\n    }\r\n\r\n    // To provide a minimum target, expand the area toward the center a bit.\r\n    switch (this.location) {\r\n      case 'right':\r\n        bounds.left = Math.min(bounds.left, bounds.right - 2)\r\n        break\r\n      case 'bottom':\r\n        bounds.top = Math.min(bounds.top, bounds.bottom - 1)\r\n        break\r\n      case 'left':\r\n        bounds.right = Math.max(bounds.right, bounds.left + 2)\r\n        break\r\n    }\r\n\r\n    // Further expand the area to include all panels that are closer to the edge than the dock.\r\n    switch (this.location) {\r\n      case 'right':\r\n        bounds.right = Number.POSITIVE_INFINITY\r\n        break\r\n      case 'bottom':\r\n        bounds.bottom = Number.POSITIVE_INFINITY\r\n        break\r\n      case 'left':\r\n        bounds.left = Number.NEGATIVE_INFINITY\r\n        break\r\n    }\r\n\r\n    // If we're in this area, we know we're within the hover area without having to take further\r\n    // measurements.\r\n    if (rectContainsPoint(bounds, point)) return true\r\n\r\n    // If we're within the toggle button, we're definitely in the hover area. Unfortunately, we\r\n    // can't do this measurement conditionally (e.g. only if the toggle button is visible) because\r\n    // our knowledge of the toggle's button is incomplete due to CSS animations. (We may think the\r\n    // toggle button isn't visible when in actuality it is, but is animating to its hidden state.)\r\n    //\r\n    // Since `point` is always the current mouse position, one possible optimization would be to\r\n    // remove it as an argument and determine whether we're inside the toggle button using\r\n    // mouseenter/leave events on it. This class would still need to keep track of the mouse\r\n    // position (via a mousemove listener) for the other measurements, though.\r\n    const toggleButtonBounds = this.refs.toggleButton.getBounds()\r\n    if (rectContainsPoint(toggleButtonBounds, point)) return true\r\n\r\n    // The area used when detecting exit is actually larger than when detecting entrances. Expand\r\n    // our bounds and recheck them.\r\n    if (detectingExit) {\r\n      const hoverMargin = 20\r\n      switch (this.location) {\r\n        case 'right':\r\n          bounds.left = Math.min(bounds.left, toggleButtonBounds.left) - hoverMargin\r\n          break\r\n        case 'bottom':\r\n          bounds.top = Math.min(bounds.top, toggleButtonBounds.top) - hoverMargin\r\n          break\r\n        case 'left':\r\n          bounds.right = Math.max(bounds.right, toggleButtonBounds.right) + hoverMargin\r\n          break\r\n      }\r\n      if (rectContainsPoint(bounds, point)) return true\r\n    }\r\n\r\n    return false\r\n  }\r", "name": "rectContainsPoint", "func_location": "Dock.pointWithinHoverArea", "args": ["bounds", "point"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 372, "func_start_line": 333}}, {"func_info": {"comment": [], "name": "rectContainsPoint", "params": ["rect", "point"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 855, "start_line": 848}, "call_info": {"func_end_line": 405, "comment": [" Determine whether the cursor is within the dock hover area. This isn't as simple as just using", " mouseenter/leave because we want to be a little more forgiving. For example, if the cursor is", " over the footer, we want to show the bottom dock's toggle button. Also note that our criteria", " for detecting entry are different than detecting exit but, in order for us to avoid jitter, the", " area considered when detecting exit MUST fully encompass the area considered when detecting", " entry."], "code": "  pointWithinHoverArea (point, detectingExit) {\r\n    const dockBounds = this.refs.innerElement.getBoundingClientRect()\r\n\r\n    // Copy the bounds object since we can't mutate it.\r\n    const bounds = {\r\n      top: dockBounds.top,\r\n      right: dockBounds.right,\r\n      bottom: dockBounds.bottom,\r\n      left: dockBounds.left\r\n    }\r\n\r\n    // To provide a minimum target, expand the area toward the center a bit.\r\n    switch (this.location) {\r\n      case 'right':\r\n        bounds.left = Math.min(bounds.left, bounds.right - 2)\r\n        break\r\n      case 'bottom':\r\n        bounds.top = Math.min(bounds.top, bounds.bottom - 1)\r\n        break\r\n      case 'left':\r\n        bounds.right = Math.max(bounds.right, bounds.left + 2)\r\n        break\r\n    }\r\n\r\n    // Further expand the area to include all panels that are closer to the edge than the dock.\r\n    switch (this.location) {\r\n      case 'right':\r\n        bounds.right = Number.POSITIVE_INFINITY\r\n        break\r\n      case 'bottom':\r\n        bounds.bottom = Number.POSITIVE_INFINITY\r\n        break\r\n      case 'left':\r\n        bounds.left = Number.NEGATIVE_INFINITY\r\n        break\r\n    }\r\n\r\n    // If we're in this area, we know we're within the hover area without having to take further\r\n    // measurements.\r\n    if (rectContainsPoint(bounds, point)) return true\r\n\r\n    // If we're within the toggle button, we're definitely in the hover area. Unfortunately, we\r\n    // can't do this measurement conditionally (e.g. only if the toggle button is visible) because\r\n    // our knowledge of the toggle's button is incomplete due to CSS animations. (We may think the\r\n    // toggle button isn't visible when in actuality it is, but is animating to its hidden state.)\r\n    //\r\n    // Since `point` is always the current mouse position, one possible optimization would be to\r\n    // remove it as an argument and determine whether we're inside the toggle button using\r\n    // mouseenter/leave events on it. This class would still need to keep track of the mouse\r\n    // position (via a mousemove listener) for the other measurements, though.\r\n    const toggleButtonBounds = this.refs.toggleButton.getBounds()\r\n    if (rectContainsPoint(toggleButtonBounds, point)) return true\r\n\r\n    // The area used when detecting exit is actually larger than when detecting entrances. Expand\r\n    // our bounds and recheck them.\r\n    if (detectingExit) {\r\n      const hoverMargin = 20\r\n      switch (this.location) {\r\n        case 'right':\r\n          bounds.left = Math.min(bounds.left, toggleButtonBounds.left) - hoverMargin\r\n          break\r\n        case 'bottom':\r\n          bounds.top = Math.min(bounds.top, toggleButtonBounds.top) - hoverMargin\r\n          break\r\n        case 'left':\r\n          bounds.right = Math.max(bounds.right, toggleButtonBounds.right) + hoverMargin\r\n          break\r\n      }\r\n      if (rectContainsPoint(bounds, point)) return true\r\n    }\r\n\r\n    return false\r\n  }\r", "name": "rectContainsPoint", "func_location": "Dock.pointWithinHoverArea", "args": ["toggleButtonBounds", "point"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 384, "func_start_line": 333}}, {"func_info": {"comment": [], "name": "rectContainsPoint", "params": ["rect", "point"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 855, "start_line": 848}, "call_info": {"func_end_line": 405, "comment": [" Determine whether the cursor is within the dock hover area. This isn't as simple as just using", " mouseenter/leave because we want to be a little more forgiving. For example, if the cursor is", " over the footer, we want to show the bottom dock's toggle button. Also note that our criteria", " for detecting entry are different than detecting exit but, in order for us to avoid jitter, the", " area considered when detecting exit MUST fully encompass the area considered when detecting", " entry."], "code": "  pointWithinHoverArea (point, detectingExit) {\r\n    const dockBounds = this.refs.innerElement.getBoundingClientRect()\r\n\r\n    // Copy the bounds object since we can't mutate it.\r\n    const bounds = {\r\n      top: dockBounds.top,\r\n      right: dockBounds.right,\r\n      bottom: dockBounds.bottom,\r\n      left: dockBounds.left\r\n    }\r\n\r\n    // To provide a minimum target, expand the area toward the center a bit.\r\n    switch (this.location) {\r\n      case 'right':\r\n        bounds.left = Math.min(bounds.left, bounds.right - 2)\r\n        break\r\n      case 'bottom':\r\n        bounds.top = Math.min(bounds.top, bounds.bottom - 1)\r\n        break\r\n      case 'left':\r\n        bounds.right = Math.max(bounds.right, bounds.left + 2)\r\n        break\r\n    }\r\n\r\n    // Further expand the area to include all panels that are closer to the edge than the dock.\r\n    switch (this.location) {\r\n      case 'right':\r\n        bounds.right = Number.POSITIVE_INFINITY\r\n        break\r\n      case 'bottom':\r\n        bounds.bottom = Number.POSITIVE_INFINITY\r\n        break\r\n      case 'left':\r\n        bounds.left = Number.NEGATIVE_INFINITY\r\n        break\r\n    }\r\n\r\n    // If we're in this area, we know we're within the hover area without having to take further\r\n    // measurements.\r\n    if (rectContainsPoint(bounds, point)) return true\r\n\r\n    // If we're within the toggle button, we're definitely in the hover area. Unfortunately, we\r\n    // can't do this measurement conditionally (e.g. only if the toggle button is visible) because\r\n    // our knowledge of the toggle's button is incomplete due to CSS animations. (We may think the\r\n    // toggle button isn't visible when in actuality it is, but is animating to its hidden state.)\r\n    //\r\n    // Since `point` is always the current mouse position, one possible optimization would be to\r\n    // remove it as an argument and determine whether we're inside the toggle button using\r\n    // mouseenter/leave events on it. This class would still need to keep track of the mouse\r\n    // position (via a mousemove listener) for the other measurements, though.\r\n    const toggleButtonBounds = this.refs.toggleButton.getBounds()\r\n    if (rectContainsPoint(toggleButtonBounds, point)) return true\r\n\r\n    // The area used when detecting exit is actually larger than when detecting entrances. Expand\r\n    // our bounds and recheck them.\r\n    if (detectingExit) {\r\n      const hoverMargin = 20\r\n      switch (this.location) {\r\n        case 'right':\r\n          bounds.left = Math.min(bounds.left, toggleButtonBounds.left) - hoverMargin\r\n          break\r\n        case 'bottom':\r\n          bounds.top = Math.min(bounds.top, toggleButtonBounds.top) - hoverMargin\r\n          break\r\n        case 'left':\r\n          bounds.right = Math.max(bounds.right, toggleButtonBounds.right) + hoverMargin\r\n          break\r\n      }\r\n      if (rectContainsPoint(bounds, point)) return true\r\n    }\r\n\r\n    return false\r\n  }\r", "name": "rectContainsPoint", "func_location": "Dock.pointWithinHoverArea", "args": ["bounds", "point"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 401, "func_start_line": 333}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedStartRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2726, "start_line": 2720}, "call_info": {"func_end_line": 1309, "code": "  populateTextDecorationsToRender () {\r\n    // Sort all boundaries in ascending order of position\r\n    this.textDecorationBoundaries.sort((a, b) => a.position.compare(b.position))\r\n\r\n    // Combine adjacent boundaries with the same position\r\n    for (let i = 0; i < this.textDecorationBoundaries.length;) {\r\n      const boundary = this.textDecorationBoundaries[i]\r\n      const nextBoundary = this.textDecorationBoundaries[i + 1]\r\n      if (nextBoundary && nextBoundary.position.isEqual(boundary.position)) {\r\n        if (nextBoundary.starting) {\r\n          if (boundary.starting) {\r\n            boundary.starting.push(...nextBoundary.starting)\r\n          } else {\r\n            boundary.starting = nextBoundary.starting\r\n          }\r\n        }\r\n\r\n        if (nextBoundary.ending) {\r\n          if (boundary.ending) {\r\n            boundary.ending.push(...nextBoundary.ending)\r\n          } else {\r\n            boundary.ending = nextBoundary.ending\r\n          }\r\n        }\r\n\r\n        this.textDecorationBoundaries.splice(i + 1, 1)\r\n      } else {\r\n        i++\r\n      }\r\n    }\r\n\r\n    const renderedStartRow = this.getRenderedStartRow()\r\n    const renderedEndRow = this.getRenderedEndRow()\r\n    const containingMarkers = []\r\n\r\n    // Iterate over boundaries to build up text decorations.\r\n    for (let i = 0; i < this.textDecorationBoundaries.length; i++) {\r\n      const boundary = this.textDecorationBoundaries[i]\r\n\r\n      // If multiple markers start here, sort them by order of nesting (markers ending later come first)\r\n      if (boundary.starting && boundary.starting.length > 1) {\r\n        boundary.starting.sort((a, b) => a.compare(b))\r\n      }\r\n\r\n      // If multiple markers start here, sort them by order of nesting (markers starting earlier come first)\r\n      if (boundary.ending && boundary.ending.length > 1) {\r\n        boundary.ending.sort((a, b) => b.compare(a))\r\n      }\r\n\r\n      // Remove markers ending here from containing markers array\r\n      if (boundary.ending) {\r\n        for (let j = boundary.ending.length - 1; j >= 0; j--) {\r\n          containingMarkers.splice(containingMarkers.lastIndexOf(boundary.ending[j]), 1)\r\n        }\r\n      }\r\n      // Add markers starting here to containing markers array\r\n      if (boundary.starting) containingMarkers.push(...boundary.starting)\r\n\r\n      // Determine desired className and style based on containing markers\r\n      let className, style\r\n      for (let j = 0; j < containingMarkers.length; j++) {\r\n        const marker = containingMarkers[j]\r\n        const decorations = this.textDecorationsByMarker.get(marker)\r\n        for (let k = 0; k < decorations.length; k++) {\r\n          const decoration = decorations[k]\r\n          if (decoration.class) {\r\n            if (className) {\r\n              className += ' ' + decoration.class\r\n            } else {\r\n              className = decoration.class\r\n            }\r\n          }\r\n          if (decoration.style) {\r\n            if (style) {\r\n              Object.assign(style, decoration.style)\r\n            } else {\r\n              style = Object.assign({}, decoration.style)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Add decoration start with className/style for current position's column,\r\n      // and also for the start of every row up until the next decoration boundary\r\n      if (boundary.position.row >= renderedStartRow) {\r\n        this.addTextDecorationStart(boundary.position.row, boundary.position.column, className, style)\r\n      }\r\n      const nextBoundary = this.textDecorationBoundaries[i + 1]\r\n      if (nextBoundary) {\r\n        let row = Math.max(boundary.position.row + 1, renderedStartRow)\r\n        const endRow = Math.min(nextBoundary.position.row, renderedEndRow)\r\n        for (; row < endRow; row++) {\r\n          this.addTextDecorationStart(row, 0, className, style)\r\n        }\r\n\r\n        if (row === nextBoundary.position.row && nextBoundary.position.column !== 0) {\r\n          this.addTextDecorationStart(row, 0, className, style)\r\n        }\r\n      }\r\n    }\r\n  }\r", "name": "getRenderedStartRow", "func_location": "TextEditorComponent.populateTextDecorationsToRender", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1240, "func_start_line": 1209}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedEndRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2737, "start_line": 2728}, "call_info": {"func_end_line": 1309, "code": "  populateTextDecorationsToRender () {\r\n    // Sort all boundaries in ascending order of position\r\n    this.textDecorationBoundaries.sort((a, b) => a.position.compare(b.position))\r\n\r\n    // Combine adjacent boundaries with the same position\r\n    for (let i = 0; i < this.textDecorationBoundaries.length;) {\r\n      const boundary = this.textDecorationBoundaries[i]\r\n      const nextBoundary = this.textDecorationBoundaries[i + 1]\r\n      if (nextBoundary && nextBoundary.position.isEqual(boundary.position)) {\r\n        if (nextBoundary.starting) {\r\n          if (boundary.starting) {\r\n            boundary.starting.push(...nextBoundary.starting)\r\n          } else {\r\n            boundary.starting = nextBoundary.starting\r\n          }\r\n        }\r\n\r\n        if (nextBoundary.ending) {\r\n          if (boundary.ending) {\r\n            boundary.ending.push(...nextBoundary.ending)\r\n          } else {\r\n            boundary.ending = nextBoundary.ending\r\n          }\r\n        }\r\n\r\n        this.textDecorationBoundaries.splice(i + 1, 1)\r\n      } else {\r\n        i++\r\n      }\r\n    }\r\n\r\n    const renderedStartRow = this.getRenderedStartRow()\r\n    const renderedEndRow = this.getRenderedEndRow()\r\n    const containingMarkers = []\r\n\r\n    // Iterate over boundaries to build up text decorations.\r\n    for (let i = 0; i < this.textDecorationBoundaries.length; i++) {\r\n      const boundary = this.textDecorationBoundaries[i]\r\n\r\n      // If multiple markers start here, sort them by order of nesting (markers ending later come first)\r\n      if (boundary.starting && boundary.starting.length > 1) {\r\n        boundary.starting.sort((a, b) => a.compare(b))\r\n      }\r\n\r\n      // If multiple markers start here, sort them by order of nesting (markers starting earlier come first)\r\n      if (boundary.ending && boundary.ending.length > 1) {\r\n        boundary.ending.sort((a, b) => b.compare(a))\r\n      }\r\n\r\n      // Remove markers ending here from containing markers array\r\n      if (boundary.ending) {\r\n        for (let j = boundary.ending.length - 1; j >= 0; j--) {\r\n          containingMarkers.splice(containingMarkers.lastIndexOf(boundary.ending[j]), 1)\r\n        }\r\n      }\r\n      // Add markers starting here to containing markers array\r\n      if (boundary.starting) containingMarkers.push(...boundary.starting)\r\n\r\n      // Determine desired className and style based on containing markers\r\n      let className, style\r\n      for (let j = 0; j < containingMarkers.length; j++) {\r\n        const marker = containingMarkers[j]\r\n        const decorations = this.textDecorationsByMarker.get(marker)\r\n        for (let k = 0; k < decorations.length; k++) {\r\n          const decoration = decorations[k]\r\n          if (decoration.class) {\r\n            if (className) {\r\n              className += ' ' + decoration.class\r\n            } else {\r\n              className = decoration.class\r\n            }\r\n          }\r\n          if (decoration.style) {\r\n            if (style) {\r\n              Object.assign(style, decoration.style)\r\n            } else {\r\n              style = Object.assign({}, decoration.style)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Add decoration start with className/style for current position's column,\r\n      // and also for the start of every row up until the next decoration boundary\r\n      if (boundary.position.row >= renderedStartRow) {\r\n        this.addTextDecorationStart(boundary.position.row, boundary.position.column, className, style)\r\n      }\r\n      const nextBoundary = this.textDecorationBoundaries[i + 1]\r\n      if (nextBoundary) {\r\n        let row = Math.max(boundary.position.row + 1, renderedStartRow)\r\n        const endRow = Math.min(nextBoundary.position.row, renderedEndRow)\r\n        for (; row < endRow; row++) {\r\n          this.addTextDecorationStart(row, 0, className, style)\r\n        }\r\n\r\n        if (row === nextBoundary.position.row && nextBoundary.position.column !== 0) {\r\n          this.addTextDecorationStart(row, 0, className, style)\r\n        }\r\n      }\r\n    }\r\n  }\r", "name": "getRenderedEndRow", "func_location": "TextEditorComponent.populateTextDecorationsToRender", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1241, "func_start_line": 1209}}, {"func_info": {"comment": [], "name": "TextEditorComponent.addTextDecorationStart", "params": ["row", "column", "className", "style"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1319, "start_line": 1311}, "call_info": {"func_end_line": 1309, "code": "  populateTextDecorationsToRender () {\r\n    // Sort all boundaries in ascending order of position\r\n    this.textDecorationBoundaries.sort((a, b) => a.position.compare(b.position))\r\n\r\n    // Combine adjacent boundaries with the same position\r\n    for (let i = 0; i < this.textDecorationBoundaries.length;) {\r\n      const boundary = this.textDecorationBoundaries[i]\r\n      const nextBoundary = this.textDecorationBoundaries[i + 1]\r\n      if (nextBoundary && nextBoundary.position.isEqual(boundary.position)) {\r\n        if (nextBoundary.starting) {\r\n          if (boundary.starting) {\r\n            boundary.starting.push(...nextBoundary.starting)\r\n          } else {\r\n            boundary.starting = nextBoundary.starting\r\n          }\r\n        }\r\n\r\n        if (nextBoundary.ending) {\r\n          if (boundary.ending) {\r\n            boundary.ending.push(...nextBoundary.ending)\r\n          } else {\r\n            boundary.ending = nextBoundary.ending\r\n          }\r\n        }\r\n\r\n        this.textDecorationBoundaries.splice(i + 1, 1)\r\n      } else {\r\n        i++\r\n      }\r\n    }\r\n\r\n    const renderedStartRow = this.getRenderedStartRow()\r\n    const renderedEndRow = this.getRenderedEndRow()\r\n    const containingMarkers = []\r\n\r\n    // Iterate over boundaries to build up text decorations.\r\n    for (let i = 0; i < this.textDecorationBoundaries.length; i++) {\r\n      const boundary = this.textDecorationBoundaries[i]\r\n\r\n      // If multiple markers start here, sort them by order of nesting (markers ending later come first)\r\n      if (boundary.starting && boundary.starting.length > 1) {\r\n        boundary.starting.sort((a, b) => a.compare(b))\r\n      }\r\n\r\n      // If multiple markers start here, sort them by order of nesting (markers starting earlier come first)\r\n      if (boundary.ending && boundary.ending.length > 1) {\r\n        boundary.ending.sort((a, b) => b.compare(a))\r\n      }\r\n\r\n      // Remove markers ending here from containing markers array\r\n      if (boundary.ending) {\r\n        for (let j = boundary.ending.length - 1; j >= 0; j--) {\r\n          containingMarkers.splice(containingMarkers.lastIndexOf(boundary.ending[j]), 1)\r\n        }\r\n      }\r\n      // Add markers starting here to containing markers array\r\n      if (boundary.starting) containingMarkers.push(...boundary.starting)\r\n\r\n      // Determine desired className and style based on containing markers\r\n      let className, style\r\n      for (let j = 0; j < containingMarkers.length; j++) {\r\n        const marker = containingMarkers[j]\r\n        const decorations = this.textDecorationsByMarker.get(marker)\r\n        for (let k = 0; k < decorations.length; k++) {\r\n          const decoration = decorations[k]\r\n          if (decoration.class) {\r\n            if (className) {\r\n              className += ' ' + decoration.class\r\n            } else {\r\n              className = decoration.class\r\n            }\r\n          }\r\n          if (decoration.style) {\r\n            if (style) {\r\n              Object.assign(style, decoration.style)\r\n            } else {\r\n              style = Object.assign({}, decoration.style)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Add decoration start with className/style for current position's column,\r\n      // and also for the start of every row up until the next decoration boundary\r\n      if (boundary.position.row >= renderedStartRow) {\r\n        this.addTextDecorationStart(boundary.position.row, boundary.position.column, className, style)\r\n      }\r\n      const nextBoundary = this.textDecorationBoundaries[i + 1]\r\n      if (nextBoundary) {\r\n        let row = Math.max(boundary.position.row + 1, renderedStartRow)\r\n        const endRow = Math.min(nextBoundary.position.row, renderedEndRow)\r\n        for (; row < endRow; row++) {\r\n          this.addTextDecorationStart(row, 0, className, style)\r\n        }\r\n\r\n        if (row === nextBoundary.position.row && nextBoundary.position.column !== 0) {\r\n          this.addTextDecorationStart(row, 0, className, style)\r\n        }\r\n      }\r\n    }\r\n  }\r", "name": "addTextDecorationStart", "func_location": "TextEditorComponent.populateTextDecorationsToRender", "args": ["boundary.position.row", "boundary.position.column", "className", "style"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1294, "func_start_line": 1209}}, {"func_info": {"comment": [], "name": "TextEditorComponent.addTextDecorationStart", "params": ["row", "column", "className", "style"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1319, "start_line": 1311}, "call_info": {"func_end_line": 1309, "code": "  populateTextDecorationsToRender () {\r\n    // Sort all boundaries in ascending order of position\r\n    this.textDecorationBoundaries.sort((a, b) => a.position.compare(b.position))\r\n\r\n    // Combine adjacent boundaries with the same position\r\n    for (let i = 0; i < this.textDecorationBoundaries.length;) {\r\n      const boundary = this.textDecorationBoundaries[i]\r\n      const nextBoundary = this.textDecorationBoundaries[i + 1]\r\n      if (nextBoundary && nextBoundary.position.isEqual(boundary.position)) {\r\n        if (nextBoundary.starting) {\r\n          if (boundary.starting) {\r\n            boundary.starting.push(...nextBoundary.starting)\r\n          } else {\r\n            boundary.starting = nextBoundary.starting\r\n          }\r\n        }\r\n\r\n        if (nextBoundary.ending) {\r\n          if (boundary.ending) {\r\n            boundary.ending.push(...nextBoundary.ending)\r\n          } else {\r\n            boundary.ending = nextBoundary.ending\r\n          }\r\n        }\r\n\r\n        this.textDecorationBoundaries.splice(i + 1, 1)\r\n      } else {\r\n        i++\r\n      }\r\n    }\r\n\r\n    const renderedStartRow = this.getRenderedStartRow()\r\n    const renderedEndRow = this.getRenderedEndRow()\r\n    const containingMarkers = []\r\n\r\n    // Iterate over boundaries to build up text decorations.\r\n    for (let i = 0; i < this.textDecorationBoundaries.length; i++) {\r\n      const boundary = this.textDecorationBoundaries[i]\r\n\r\n      // If multiple markers start here, sort them by order of nesting (markers ending later come first)\r\n      if (boundary.starting && boundary.starting.length > 1) {\r\n        boundary.starting.sort((a, b) => a.compare(b))\r\n      }\r\n\r\n      // If multiple markers start here, sort them by order of nesting (markers starting earlier come first)\r\n      if (boundary.ending && boundary.ending.length > 1) {\r\n        boundary.ending.sort((a, b) => b.compare(a))\r\n      }\r\n\r\n      // Remove markers ending here from containing markers array\r\n      if (boundary.ending) {\r\n        for (let j = boundary.ending.length - 1; j >= 0; j--) {\r\n          containingMarkers.splice(containingMarkers.lastIndexOf(boundary.ending[j]), 1)\r\n        }\r\n      }\r\n      // Add markers starting here to containing markers array\r\n      if (boundary.starting) containingMarkers.push(...boundary.starting)\r\n\r\n      // Determine desired className and style based on containing markers\r\n      let className, style\r\n      for (let j = 0; j < containingMarkers.length; j++) {\r\n        const marker = containingMarkers[j]\r\n        const decorations = this.textDecorationsByMarker.get(marker)\r\n        for (let k = 0; k < decorations.length; k++) {\r\n          const decoration = decorations[k]\r\n          if (decoration.class) {\r\n            if (className) {\r\n              className += ' ' + decoration.class\r\n            } else {\r\n              className = decoration.class\r\n            }\r\n          }\r\n          if (decoration.style) {\r\n            if (style) {\r\n              Object.assign(style, decoration.style)\r\n            } else {\r\n              style = Object.assign({}, decoration.style)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Add decoration start with className/style for current position's column,\r\n      // and also for the start of every row up until the next decoration boundary\r\n      if (boundary.position.row >= renderedStartRow) {\r\n        this.addTextDecorationStart(boundary.position.row, boundary.position.column, className, style)\r\n      }\r\n      const nextBoundary = this.textDecorationBoundaries[i + 1]\r\n      if (nextBoundary) {\r\n        let row = Math.max(boundary.position.row + 1, renderedStartRow)\r\n        const endRow = Math.min(nextBoundary.position.row, renderedEndRow)\r\n        for (; row < endRow; row++) {\r\n          this.addTextDecorationStart(row, 0, className, style)\r\n        }\r\n\r\n        if (row === nextBoundary.position.row && nextBoundary.position.column !== 0) {\r\n          this.addTextDecorationStart(row, 0, className, style)\r\n        }\r\n      }\r\n    }\r\n  }\r", "name": "addTextDecorationStart", "func_location": "TextEditorComponent.populateTextDecorationsToRender", "args": ["row", {"type": "number"}, "className", "style"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1301, "func_start_line": 1209}}, {"func_info": {"comment": [], "name": "TextEditorComponent.addTextDecorationStart", "params": ["row", "column", "className", "style"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1319, "start_line": 1311}, "call_info": {"func_end_line": 1309, "code": "  populateTextDecorationsToRender () {\r\n    // Sort all boundaries in ascending order of position\r\n    this.textDecorationBoundaries.sort((a, b) => a.position.compare(b.position))\r\n\r\n    // Combine adjacent boundaries with the same position\r\n    for (let i = 0; i < this.textDecorationBoundaries.length;) {\r\n      const boundary = this.textDecorationBoundaries[i]\r\n      const nextBoundary = this.textDecorationBoundaries[i + 1]\r\n      if (nextBoundary && nextBoundary.position.isEqual(boundary.position)) {\r\n        if (nextBoundary.starting) {\r\n          if (boundary.starting) {\r\n            boundary.starting.push(...nextBoundary.starting)\r\n          } else {\r\n            boundary.starting = nextBoundary.starting\r\n          }\r\n        }\r\n\r\n        if (nextBoundary.ending) {\r\n          if (boundary.ending) {\r\n            boundary.ending.push(...nextBoundary.ending)\r\n          } else {\r\n            boundary.ending = nextBoundary.ending\r\n          }\r\n        }\r\n\r\n        this.textDecorationBoundaries.splice(i + 1, 1)\r\n      } else {\r\n        i++\r\n      }\r\n    }\r\n\r\n    const renderedStartRow = this.getRenderedStartRow()\r\n    const renderedEndRow = this.getRenderedEndRow()\r\n    const containingMarkers = []\r\n\r\n    // Iterate over boundaries to build up text decorations.\r\n    for (let i = 0; i < this.textDecorationBoundaries.length; i++) {\r\n      const boundary = this.textDecorationBoundaries[i]\r\n\r\n      // If multiple markers start here, sort them by order of nesting (markers ending later come first)\r\n      if (boundary.starting && boundary.starting.length > 1) {\r\n        boundary.starting.sort((a, b) => a.compare(b))\r\n      }\r\n\r\n      // If multiple markers start here, sort them by order of nesting (markers starting earlier come first)\r\n      if (boundary.ending && boundary.ending.length > 1) {\r\n        boundary.ending.sort((a, b) => b.compare(a))\r\n      }\r\n\r\n      // Remove markers ending here from containing markers array\r\n      if (boundary.ending) {\r\n        for (let j = boundary.ending.length - 1; j >= 0; j--) {\r\n          containingMarkers.splice(containingMarkers.lastIndexOf(boundary.ending[j]), 1)\r\n        }\r\n      }\r\n      // Add markers starting here to containing markers array\r\n      if (boundary.starting) containingMarkers.push(...boundary.starting)\r\n\r\n      // Determine desired className and style based on containing markers\r\n      let className, style\r\n      for (let j = 0; j < containingMarkers.length; j++) {\r\n        const marker = containingMarkers[j]\r\n        const decorations = this.textDecorationsByMarker.get(marker)\r\n        for (let k = 0; k < decorations.length; k++) {\r\n          const decoration = decorations[k]\r\n          if (decoration.class) {\r\n            if (className) {\r\n              className += ' ' + decoration.class\r\n            } else {\r\n              className = decoration.class\r\n            }\r\n          }\r\n          if (decoration.style) {\r\n            if (style) {\r\n              Object.assign(style, decoration.style)\r\n            } else {\r\n              style = Object.assign({}, decoration.style)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Add decoration start with className/style for current position's column,\r\n      // and also for the start of every row up until the next decoration boundary\r\n      if (boundary.position.row >= renderedStartRow) {\r\n        this.addTextDecorationStart(boundary.position.row, boundary.position.column, className, style)\r\n      }\r\n      const nextBoundary = this.textDecorationBoundaries[i + 1]\r\n      if (nextBoundary) {\r\n        let row = Math.max(boundary.position.row + 1, renderedStartRow)\r\n        const endRow = Math.min(nextBoundary.position.row, renderedEndRow)\r\n        for (; row < endRow; row++) {\r\n          this.addTextDecorationStart(row, 0, className, style)\r\n        }\r\n\r\n        if (row === nextBoundary.position.row && nextBoundary.position.column !== 0) {\r\n          this.addTextDecorationStart(row, 0, className, style)\r\n        }\r\n      }\r\n    }\r\n  }\r", "name": "addTextDecorationStart", "func_location": "TextEditorComponent.populateTextDecorationsToRender", "args": ["row", {"type": "number"}, "className", "style"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1305, "func_start_line": 1209}}, {"func_info": {"comment": [" We may render more tiles than needed if some contain block decorations,", " but keeping this calculation simple ensures the number of tiles remains", " fixed for a given editor height, which eliminates situations where a", " tile is repeatedly added and removed during scrolling in certain", " combinations of editor height and line height."], "name": "TextEditorComponent.getVisibleTileCount", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2785, "start_line": 2779}, "call_info": {"func_end_line": 2908, "comment": [" Ensure the spatial index is populated with rows that are currently visible"], "code": "  populateVisibleRowRange (renderedStartRow) {\r\n    const {model} = this.props\r\n    const previousScreenLineCount = model.getApproximateScreenLineCount()\r\n\r\n    const renderedEndRow = renderedStartRow + (this.getVisibleTileCount() * this.getRowsPerTile())\r\n    this.props.model.displayLayer.populateSpatialIndexIfNeeded(Infinity, renderedEndRow)\r\n\r\n    // If the approximate screen line count changes, previously-cached derived\r\n    // dimensions could now be out of date.\r\n    if (model.getApproximateScreenLineCount() !== previousScreenLineCount) {\r\n      this.derivedDimensionsCache = {}\r\n    }\r\n  }\r", "name": "getVisibleTileCount", "func_location": "TextEditorComponent.populateVisibleRowRange", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2900, "func_start_line": 2896}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRowsPerTile", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2714, "start_line": 2712}, "call_info": {"func_end_line": 2908, "comment": [" Ensure the spatial index is populated with rows that are currently visible"], "code": "  populateVisibleRowRange (renderedStartRow) {\r\n    const {model} = this.props\r\n    const previousScreenLineCount = model.getApproximateScreenLineCount()\r\n\r\n    const renderedEndRow = renderedStartRow + (this.getVisibleTileCount() * this.getRowsPerTile())\r\n    this.props.model.displayLayer.populateSpatialIndexIfNeeded(Infinity, renderedEndRow)\r\n\r\n    // If the approximate screen line count changes, previously-cached derived\r\n    // dimensions could now be out of date.\r\n    if (model.getApproximateScreenLineCount() !== previousScreenLineCount) {\r\n      this.derivedDimensionsCache = {}\r\n    }\r\n  }\r", "name": "getRowsPerTile", "func_location": "TextEditorComponent.populateVisibleRowRange", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2900, "func_start_line": 2896}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedStartRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2726, "start_line": 2720}, "call_info": {"func_end_line": 2937, "code": "  populateVisibleTiles () {\r\n    const startRow = this.getRenderedStartRow()\r\n    const endRow = this.getRenderedEndRow()\r\n    const freeTileIds = []\r\n    for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n      const tileStartRow = this.renderedTileStartRows[i]\r\n      if (tileStartRow < startRow || tileStartRow >= endRow) {\r\n        const tileId = this.idsByTileStartRow.get(tileStartRow)\r\n        freeTileIds.push(tileId)\r\n        this.idsByTileStartRow.delete(tileStartRow)\r\n      }\r\n    }\r\n\r\n    const rowsPerTile = this.getRowsPerTile()\r\n    this.renderedTileStartRows.length = this.getRenderedTileCount()\r\n    for (let tileStartRow = startRow, i = 0; tileStartRow < endRow; tileStartRow = tileStartRow + rowsPerTile, i++) {\r\n      this.renderedTileStartRows[i] = tileStartRow\r\n      if (!this.idsByTileStartRow.has(tileStartRow)) {\r\n        if (freeTileIds.length > 0) {\r\n          this.idsByTileStartRow.set(tileStartRow, freeTileIds.shift())\r\n        } else {\r\n          this.idsByTileStartRow.set(tileStartRow, this.nextTileId++)\r\n        }\r\n      }\r\n    }\r\n\r\n    this.renderedTileStartRows.sort((a, b) => this.idsByTileStartRow.get(a) - this.idsByTileStartRow.get(b))\r\n  }\r", "name": "getRenderedStartRow", "func_location": "TextEditorComponent.populateVisibleTiles", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2911, "func_start_line": 2910}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedEndRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2737, "start_line": 2728}, "call_info": {"func_end_line": 2937, "code": "  populateVisibleTiles () {\r\n    const startRow = this.getRenderedStartRow()\r\n    const endRow = this.getRenderedEndRow()\r\n    const freeTileIds = []\r\n    for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n      const tileStartRow = this.renderedTileStartRows[i]\r\n      if (tileStartRow < startRow || tileStartRow >= endRow) {\r\n        const tileId = this.idsByTileStartRow.get(tileStartRow)\r\n        freeTileIds.push(tileId)\r\n        this.idsByTileStartRow.delete(tileStartRow)\r\n      }\r\n    }\r\n\r\n    const rowsPerTile = this.getRowsPerTile()\r\n    this.renderedTileStartRows.length = this.getRenderedTileCount()\r\n    for (let tileStartRow = startRow, i = 0; tileStartRow < endRow; tileStartRow = tileStartRow + rowsPerTile, i++) {\r\n      this.renderedTileStartRows[i] = tileStartRow\r\n      if (!this.idsByTileStartRow.has(tileStartRow)) {\r\n        if (freeTileIds.length > 0) {\r\n          this.idsByTileStartRow.set(tileStartRow, freeTileIds.shift())\r\n        } else {\r\n          this.idsByTileStartRow.set(tileStartRow, this.nextTileId++)\r\n        }\r\n      }\r\n    }\r\n\r\n    this.renderedTileStartRows.sort((a, b) => this.idsByTileStartRow.get(a) - this.idsByTileStartRow.get(b))\r\n  }\r", "name": "getRenderedEndRow", "func_location": "TextEditorComponent.populateVisibleTiles", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2912, "func_start_line": 2910}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRowsPerTile", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2714, "start_line": 2712}, "call_info": {"func_end_line": 2937, "code": "  populateVisibleTiles () {\r\n    const startRow = this.getRenderedStartRow()\r\n    const endRow = this.getRenderedEndRow()\r\n    const freeTileIds = []\r\n    for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n      const tileStartRow = this.renderedTileStartRows[i]\r\n      if (tileStartRow < startRow || tileStartRow >= endRow) {\r\n        const tileId = this.idsByTileStartRow.get(tileStartRow)\r\n        freeTileIds.push(tileId)\r\n        this.idsByTileStartRow.delete(tileStartRow)\r\n      }\r\n    }\r\n\r\n    const rowsPerTile = this.getRowsPerTile()\r\n    this.renderedTileStartRows.length = this.getRenderedTileCount()\r\n    for (let tileStartRow = startRow, i = 0; tileStartRow < endRow; tileStartRow = tileStartRow + rowsPerTile, i++) {\r\n      this.renderedTileStartRows[i] = tileStartRow\r\n      if (!this.idsByTileStartRow.has(tileStartRow)) {\r\n        if (freeTileIds.length > 0) {\r\n          this.idsByTileStartRow.set(tileStartRow, freeTileIds.shift())\r\n        } else {\r\n          this.idsByTileStartRow.set(tileStartRow, this.nextTileId++)\r\n        }\r\n      }\r\n    }\r\n\r\n    this.renderedTileStartRows.sort((a, b) => this.idsByTileStartRow.get(a) - this.idsByTileStartRow.get(b))\r\n  }\r", "name": "getRowsPerTile", "func_location": "TextEditorComponent.populateVisibleTiles", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2923, "func_start_line": 2910}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedTileCount", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2753, "start_line": 2747}, "call_info": {"func_end_line": 2937, "code": "  populateVisibleTiles () {\r\n    const startRow = this.getRenderedStartRow()\r\n    const endRow = this.getRenderedEndRow()\r\n    const freeTileIds = []\r\n    for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n      const tileStartRow = this.renderedTileStartRows[i]\r\n      if (tileStartRow < startRow || tileStartRow >= endRow) {\r\n        const tileId = this.idsByTileStartRow.get(tileStartRow)\r\n        freeTileIds.push(tileId)\r\n        this.idsByTileStartRow.delete(tileStartRow)\r\n      }\r\n    }\r\n\r\n    const rowsPerTile = this.getRowsPerTile()\r\n    this.renderedTileStartRows.length = this.getRenderedTileCount()\r\n    for (let tileStartRow = startRow, i = 0; tileStartRow < endRow; tileStartRow = tileStartRow + rowsPerTile, i++) {\r\n      this.renderedTileStartRows[i] = tileStartRow\r\n      if (!this.idsByTileStartRow.has(tileStartRow)) {\r\n        if (freeTileIds.length > 0) {\r\n          this.idsByTileStartRow.set(tileStartRow, freeTileIds.shift())\r\n        } else {\r\n          this.idsByTileStartRow.set(tileStartRow, this.nextTileId++)\r\n        }\r\n      }\r\n    }\r\n\r\n    this.renderedTileStartRows.sort((a, b) => this.idsByTileStartRow.get(a) - this.idsByTileStartRow.get(b))\r\n  }\r", "name": "getRenderedTileCount", "func_location": "TextEditorComponent.populateVisibleTiles", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2924, "func_start_line": 2910}}, {"func_info": {"comment": [], "name": "Package.loadKeymaps", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 451, "start_line": 438}, "call_info": {"func_end_line": 108, "code": "  preload () {\r\n    this.loadKeymaps()\r\n    this.loadMenus()\r\n    this.registerDeserializerMethods()\r\n    this.activateCoreStartupServices()\r\n    this.registerURIHandler()\r\n    this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n    this.requireMainModule()\r\n    this.settingsPromise = this.loadSettings()\r\n\r\n    this.activationDisposables = new CompositeDisposable()\r\n    this.activateKeymaps()\r\n    this.activateMenus()\r\n    for (let settings of this.settings) {\r\n      settings.activate(this.config)\r\n    }\r\n    this.settingsActivated = true\r\n  }\r", "name": "loadKeymaps", "func_location": "Package.preload", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 92, "func_start_line": 91}}, {"func_info": {"comment": [], "name": "Package.loadMenus", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 466, "start_line": 453}, "call_info": {"func_end_line": 108, "code": "  preload () {\r\n    this.loadKeymaps()\r\n    this.loadMenus()\r\n    this.registerDeserializerMethods()\r\n    this.activateCoreStartupServices()\r\n    this.registerURIHandler()\r\n    this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n    this.requireMainModule()\r\n    this.settingsPromise = this.loadSettings()\r\n\r\n    this.activationDisposables = new CompositeDisposable()\r\n    this.activateKeymaps()\r\n    this.activateMenus()\r\n    for (let settings of this.settings) {\r\n      settings.activate(this.config)\r\n    }\r\n    this.settingsActivated = true\r\n  }\r", "name": "loadMenus", "func_location": "Package.preload", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 93, "func_start_line": 91}}, {"func_info": {"comment": [], "name": "Package.registerDeserializerMethods", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 507, "start_line": 492}, "call_info": {"func_end_line": 108, "code": "  preload () {\r\n    this.loadKeymaps()\r\n    this.loadMenus()\r\n    this.registerDeserializerMethods()\r\n    this.activateCoreStartupServices()\r\n    this.registerURIHandler()\r\n    this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n    this.requireMainModule()\r\n    this.settingsPromise = this.loadSettings()\r\n\r\n    this.activationDisposables = new CompositeDisposable()\r\n    this.activateKeymaps()\r\n    this.activateMenus()\r\n    for (let settings of this.settings) {\r\n      settings.activate(this.config)\r\n    }\r\n    this.settingsActivated = true\r\n  }\r", "name": "registerDeserializerMethods", "func_location": "Package.preload", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 94, "func_start_line": 91}}, {"func_info": {"comment": [], "name": "Package.activateCoreStartupServices", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 524, "start_line": 509}, "call_info": {"func_end_line": 108, "code": "  preload () {\r\n    this.loadKeymaps()\r\n    this.loadMenus()\r\n    this.registerDeserializerMethods()\r\n    this.activateCoreStartupServices()\r\n    this.registerURIHandler()\r\n    this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n    this.requireMainModule()\r\n    this.settingsPromise = this.loadSettings()\r\n\r\n    this.activationDisposables = new CompositeDisposable()\r\n    this.activateKeymaps()\r\n    this.activateMenus()\r\n    for (let settings of this.settings) {\r\n      settings.activate(this.config)\r\n    }\r\n    this.settingsActivated = true\r\n  }\r", "name": "activateCoreStartupServices", "func_location": "Package.preload", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 95, "func_start_line": 91}}, {"func_info": {"comment": [], "name": "Package.registerURIHandler", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 413, "start_line": 405}, "call_info": {"func_end_line": 108, "code": "  preload () {\r\n    this.loadKeymaps()\r\n    this.loadMenus()\r\n    this.registerDeserializerMethods()\r\n    this.activateCoreStartupServices()\r\n    this.registerURIHandler()\r\n    this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n    this.requireMainModule()\r\n    this.settingsPromise = this.loadSettings()\r\n\r\n    this.activationDisposables = new CompositeDisposable()\r\n    this.activateKeymaps()\r\n    this.activateMenus()\r\n    for (let settings of this.settings) {\r\n      settings.activate(this.config)\r\n    }\r\n    this.settingsActivated = true\r\n  }\r", "name": "registerURIHandler", "func_location": "Package.preload", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 96, "func_start_line": 91}}, {"func_info": {"comment": [], "name": "Package.registerConfigSchemaFromMetadata", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 246, "start_line": 238}, "call_info": {"func_end_line": 108, "code": "  preload () {\r\n    this.loadKeymaps()\r\n    this.loadMenus()\r\n    this.registerDeserializerMethods()\r\n    this.activateCoreStartupServices()\r\n    this.registerURIHandler()\r\n    this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n    this.requireMainModule()\r\n    this.settingsPromise = this.loadSettings()\r\n\r\n    this.activationDisposables = new CompositeDisposable()\r\n    this.activateKeymaps()\r\n    this.activateMenus()\r\n    for (let settings of this.settings) {\r\n      settings.activate(this.config)\r\n    }\r\n    this.settingsActivated = true\r\n  }\r", "name": "registerConfigSchemaFromMetadata", "func_location": "Package.preload", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 97, "func_start_line": 91}}, {"func_info": {"comment": [], "name": "Package.requireMainModule", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 784, "start_line": 755}, "call_info": {"func_end_line": 108, "code": "  preload () {\r\n    this.loadKeymaps()\r\n    this.loadMenus()\r\n    this.registerDeserializerMethods()\r\n    this.activateCoreStartupServices()\r\n    this.registerURIHandler()\r\n    this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n    this.requireMainModule()\r\n    this.settingsPromise = this.loadSettings()\r\n\r\n    this.activationDisposables = new CompositeDisposable()\r\n    this.activateKeymaps()\r\n    this.activateMenus()\r\n    for (let settings of this.settings) {\r\n      settings.activate(this.config)\r\n    }\r\n    this.settingsActivated = true\r\n  }\r", "name": "requireMainModule", "func_location": "Package.preload", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 98, "func_start_line": 91}}, {"func_info": {"comment": [], "name": "Package.loadSettings", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 671, "start_line": 634}, "call_info": {"func_end_line": 108, "code": "  preload () {\r\n    this.loadKeymaps()\r\n    this.loadMenus()\r\n    this.registerDeserializerMethods()\r\n    this.activateCoreStartupServices()\r\n    this.registerURIHandler()\r\n    this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n    this.requireMainModule()\r\n    this.settingsPromise = this.loadSettings()\r\n\r\n    this.activationDisposables = new CompositeDisposable()\r\n    this.activateKeymaps()\r\n    this.activateMenus()\r\n    for (let settings of this.settings) {\r\n      settings.activate(this.config)\r\n    }\r\n    this.settingsActivated = true\r\n  }\r", "name": "loadSettings", "func_location": "Package.preload", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 99, "func_start_line": 91}}, {"func_info": {"comment": [], "name": "Package.activateKeymaps", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 338, "start_line": 326}, "call_info": {"func_end_line": 108, "code": "  preload () {\r\n    this.loadKeymaps()\r\n    this.loadMenus()\r\n    this.registerDeserializerMethods()\r\n    this.activateCoreStartupServices()\r\n    this.registerURIHandler()\r\n    this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n    this.requireMainModule()\r\n    this.settingsPromise = this.loadSettings()\r\n\r\n    this.activationDisposables = new CompositeDisposable()\r\n    this.activateKeymaps()\r\n    this.activateMenus()\r\n    for (let settings of this.settings) {\r\n      settings.activate(this.config)\r\n    }\r\n    this.settingsActivated = true\r\n  }\r", "name": "activateKeymaps", "func_location": "Package.preload", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 102, "func_start_line": 91}}, {"func_info": {"comment": [], "name": "Package.activateMenus", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 378, "start_line": 356}, "call_info": {"func_end_line": 108, "code": "  preload () {\r\n    this.loadKeymaps()\r\n    this.loadMenus()\r\n    this.registerDeserializerMethods()\r\n    this.activateCoreStartupServices()\r\n    this.registerURIHandler()\r\n    this.configSchemaRegisteredOnLoad = this.registerConfigSchemaFromMetadata()\r\n    this.requireMainModule()\r\n    this.settingsPromise = this.loadSettings()\r\n\r\n    this.activationDisposables = new CompositeDisposable()\r\n    this.activateKeymaps()\r\n    this.activateMenus()\r\n    for (let settings of this.settings) {\r\n      settings.activate(this.config)\r\n    }\r\n    this.settingsActivated = true\r\n  }\r", "name": "activateMenus", "func_location": "Package.preload", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 103, "func_start_line": 91}}, {"func_info": {"comment": [], "name": "PackageManager.preloadPackage", "params": ["packageName", "pack"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 534, "start_line": 500}, "call_info": {"func_end_line": 498, "code": "  preloadPackages () {\r\n    const result = []\r\n    for (const packageName in this.packagesCache) {\r\n      result.push(this.preloadPackage(packageName, this.packagesCache[packageName]))\r\n    }\r\n    return result\r\n  }\r", "name": "preloadPackage", "func_location": "PackageManager.preloadPackages", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 495, "func_start_line": 492}}, {"func_info": {"comment": [], "name": "AtomWindow.isSpecWindow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "end_line": 384, "start_line": 382}, "call_info": {"func_end_line": 246, "code": "  async prepareToUnload () {\r\n    if (this.isSpecWindow()) return true\r\n\r\n    this.lastPrepareToUnloadPromise = new Promise(resolve => {\r\n      const callback = (event, result) => {\r\n        if (BrowserWindow.fromWebContents(event.sender) === this.browserWindow) {\r\n          ipcMain.removeListener('did-prepare-to-unload', callback)\r\n          if (!result) {\r\n            this.unloading = false\r\n            this.atomApplication.quitting = false\r\n          }\r\n          resolve(result)\r\n        }\r\n      }\r\n      ipcMain.on('did-prepare-to-unload', callback)\r\n      this.browserWindow.webContents.send('prepare-to-unload')\r\n    })\r\n\r\n    return this.lastPrepareToUnloadPromise\r\n  }\r", "name": "isSpecWindow", "func_location": "AtomWindow.prepareToUnload", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "line": 228, "func_start_line": 227}}, {"func_info": {"comment": [], "name": "AtomEnvironment.saveState", "params": ["options", "storageKey"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1208, "start_line": 1198}, "call_info": {"func_end_line": 899, "code": "  async prepareToUnloadEditorWindow () {\r\n    try {\r\n      await this.saveState({isUnloading: true})\r\n    } catch (error) {\r\n      console.error(error)\r\n    }\r\n\r\n    const closing = !this.workspace || await this.workspace.confirmClose({\r\n      windowCloseRequested: true,\r\n      projectHasPaths: this.project.getPaths().length > 0\r\n    })\r\n\r\n    if (closing) {\r\n      this.unloading = true\r\n      await this.packages.deactivatePackages()\r\n    }\r\n    return closing\r\n  }\r", "name": "saveState", "func_location": "AtomEnvironment.prepareToUnloadEditorWindow", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 884, "func_start_line": 882}}, {"func_info": {"comment": [" Public: Measure how long a function takes to run.", "", " description - A {String} description that will be logged to the console when", "               the function completes.", " fn - A {Function} to measure the duration of.", "", " Returns the value returned by the given function."], "name": "window.measure", "params": ["description", "fn"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/window.js", "end_line": 14, "start_line": 8}, "call_info": {"func_end_line": 30, "name": "measure", "func_location": "window.profile", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/window.js", "line": 24, "func_start_line": 23}}, {"func_info": {"comment": [], "name": "AtomApplication.promptForPath", "params": ["type", "callback", "path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1347, "start_line": 1319}, "call_info": {"func_end_line": 1317, "name": "promptForPath", "func_location": "AtomApplication.promptForPathToOpen", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 1310, "func_start_line": 1309}}, {"func_info": {"comment": ["\r\n  Section: Managing Settings\r\n  ", " Essential: Retrieves the setting for the given key.", "", " ### Examples", "", " You might want to know what themes are enabled, so check `core.themes`", "", " ```coffee", " atom.config.get('core.themes')", " ```", "", " With scope descriptors you can get settings within a specific editor", " scope. For example, you might want to know `editor.tabLength` for ruby", " files.", "", " ```coffee", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " ```", "", " This setting in ruby files might be different than the global tabLength setting", "", " ```coffee", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " ```", "", " You can get the language scope descriptor via", " {TextEditor::getRootScopeDescriptor}. This will get the setting specifically", " for the editor's language.", "", " ```coffee", " atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2", " ```", "", " Additionally, you can get the setting at the specific cursor position.", "", " ```coffee", " scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()", " atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2", " ```", "", " * `keyPath` The {String} name of the key to retrieve.", " * `options` (optional) {Object}", "   * `sources` (optional) {Array} of {String} source names. If provided, only", "     values that were associated with these sources during {::set} will be used.", "   * `excludeSources` (optional) {Array} of {String} source names. If provided,", "     values that  were associated with these sources during {::set} will not", "     be used.", "   * `scope` (optional) {ScopeDescriptor} describing a path from", "     the root of the syntax tree to a token. Get one by calling", "     {editor.getLastCursor().getScopeDescriptor()}", "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)", "     for more information.", "", " Returns the value from Atom's default settings, the user's configuration", " file in the type specified by the configuration schema."], "name": "Config.get", "params": ["args"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 602, "start_line": 585}, "call_info": {"func_end_line": 877, "code": "  pushAtKeyPath (keyPath, value) {\r\n    const left = this.get(keyPath)\r\n    const arrayValue = (left == null ? [] : left)\r\n    const result = arrayValue.push(value)\r\n    this.set(keyPath, arrayValue)\r\n    return result\r\n  }\r", "name": "get", "func_location": "Config.pushAtKeyPath", "args": ["keyPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 872, "func_start_line": 871}}, {"func_info": {"comment": [" Essential: Sets the value for a configuration setting.", "", " This value is stored in Atom's internal configuration file.", "", " ### Examples", "", " You might want to change the themes programmatically:", "", " ```coffee", " atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])", " ```", "", " You can also set scoped settings. For example, you might want change the", " `editor.tabLength` only for ruby files.", "", " ```coffee", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4", " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4", "", " # Set ruby to 2", " atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true", "", " # Notice it's only set to 2 in the case of ruby", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4", " ```", "", " * `keyPath` The {String} name of the key.", " * `value` The value of the setting. Passing `undefined` will revert the", "   setting to the default value.", " * `options` (optional) {Object}", "   * `scopeSelector` (optional) {String}. eg. '.source.ruby'", "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)", "     for more information.", "   * `source` (optional) {String} The name of a file with which the setting", "     is associated. Defaults to the user's config file.", "", " Returns a {Boolean}", " * `true` if the value was set.", " * `false` if the value was not able to be coerced to the type specified in the setting's schema."], "name": "Config.set", "params": ["args"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 722, "start_line": 687}, "call_info": {"func_end_line": 877, "code": "  pushAtKeyPath (keyPath, value) {\r\n    const left = this.get(keyPath)\r\n    const arrayValue = (left == null ? [] : left)\r\n    const result = arrayValue.push(value)\r\n    this.set(keyPath, arrayValue)\r\n    return result\r\n  }\r", "name": "set", "func_location": "Config.pushAtKeyPath", "args": ["keyPath", "arrayValue"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 875, "func_start_line": 871}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedStartRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2726, "start_line": 2720}, "call_info": {"func_end_line": 1009, "code": "  queryDecorationsToRender () {\r\n    this.decorationsToRender.lineNumbers.clear()\r\n    this.decorationsToRender.lines = []\r\n    this.decorationsToRender.overlays.length = 0\r\n    this.decorationsToRender.customGutter.clear()\r\n    this.decorationsToRender.blocks = new Map()\r\n    this.decorationsToRender.text = []\r\n    this.decorationsToMeasure.highlights.length = 0\r\n    this.decorationsToMeasure.cursors.clear()\r\n    this.textDecorationsByMarker.clear()\r\n    this.textDecorationBoundaries.length = 0\r\n\r\n    const decorationsByMarker =\r\n      this.props.model.decorationManager.decorationPropertiesByMarkerForScreenRowRange(\r\n        this.getRenderedStartRow(),\r\n        this.getRenderedEndRow()\r\n      )\r\n\r\n    decorationsByMarker.forEach((decorations, marker) => {\r\n      const screenRange = marker.getScreenRange()\r\n      const reversed = marker.isReversed()\r\n      for (let i = 0; i < decorations.length; i++) {\r\n        const decoration = decorations[i]\r\n        this.addDecorationToRender(decoration.type, decoration, marker, screenRange, reversed)\r\n      }\r\n    })\r\n\r\n    this.populateTextDecorationsToRender()\r\n  }\r", "name": "getRenderedStartRow", "func_location": "TextEditorComponent.queryDecorationsToRender", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 995, "func_start_line": 981}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedEndRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2737, "start_line": 2728}, "call_info": {"func_end_line": 1009, "code": "  queryDecorationsToRender () {\r\n    this.decorationsToRender.lineNumbers.clear()\r\n    this.decorationsToRender.lines = []\r\n    this.decorationsToRender.overlays.length = 0\r\n    this.decorationsToRender.customGutter.clear()\r\n    this.decorationsToRender.blocks = new Map()\r\n    this.decorationsToRender.text = []\r\n    this.decorationsToMeasure.highlights.length = 0\r\n    this.decorationsToMeasure.cursors.clear()\r\n    this.textDecorationsByMarker.clear()\r\n    this.textDecorationBoundaries.length = 0\r\n\r\n    const decorationsByMarker =\r\n      this.props.model.decorationManager.decorationPropertiesByMarkerForScreenRowRange(\r\n        this.getRenderedStartRow(),\r\n        this.getRenderedEndRow()\r\n      )\r\n\r\n    decorationsByMarker.forEach((decorations, marker) => {\r\n      const screenRange = marker.getScreenRange()\r\n      const reversed = marker.isReversed()\r\n      for (let i = 0; i < decorations.length; i++) {\r\n        const decoration = decorations[i]\r\n        this.addDecorationToRender(decoration.type, decoration, marker, screenRange, reversed)\r\n      }\r\n    })\r\n\r\n    this.populateTextDecorationsToRender()\r\n  }\r", "name": "getRenderedEndRow", "func_location": "TextEditorComponent.queryDecorationsToRender", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 996, "func_start_line": 981}}, {"func_info": {"comment": [], "name": "TextEditorComponent.populateTextDecorationsToRender", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1309, "start_line": 1209}, "call_info": {"func_end_line": 1009, "code": "  queryDecorationsToRender () {\r\n    this.decorationsToRender.lineNumbers.clear()\r\n    this.decorationsToRender.lines = []\r\n    this.decorationsToRender.overlays.length = 0\r\n    this.decorationsToRender.customGutter.clear()\r\n    this.decorationsToRender.blocks = new Map()\r\n    this.decorationsToRender.text = []\r\n    this.decorationsToMeasure.highlights.length = 0\r\n    this.decorationsToMeasure.cursors.clear()\r\n    this.textDecorationsByMarker.clear()\r\n    this.textDecorationBoundaries.length = 0\r\n\r\n    const decorationsByMarker =\r\n      this.props.model.decorationManager.decorationPropertiesByMarkerForScreenRowRange(\r\n        this.getRenderedStartRow(),\r\n        this.getRenderedEndRow()\r\n      )\r\n\r\n    decorationsByMarker.forEach((decorations, marker) => {\r\n      const screenRange = marker.getScreenRange()\r\n      const reversed = marker.isReversed()\r\n      for (let i = 0; i < decorations.length; i++) {\r\n        const decoration = decorations[i]\r\n        this.addDecorationToRender(decoration.type, decoration, marker, screenRange, reversed)\r\n      }\r\n    })\r\n\r\n    this.populateTextDecorationsToRender()\r\n  }\r", "name": "populateTextDecorationsToRender", "func_location": "TextEditorComponent.queryDecorationsToRender", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1008, "func_start_line": 981}}, {"func_info": {"comment": [], "name": "TextEditorComponent.queryMaxLineNumberDigits", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 954, "start_line": 945}, "call_info": {"func_end_line": 943, "code": "  queryLineNumbersToRender () {\r\n    const {model} = this.props\r\n    if (!model.anyLineNumberGutterVisible()) return\r\n    if (this.showLineNumbers !== model.doesShowLineNumbers()) {\r\n      this.remeasureGutterDimensions = true\r\n      this.showLineNumbers = model.doesShowLineNumbers()\r\n    }\r\n\r\n    this.queryMaxLineNumberDigits()\r\n\r\n    const startRow = this.getRenderedStartRow()\r\n    const endRow = this.getRenderedEndRow()\r\n    const renderedRowCount = this.getRenderedRowCount()\r\n\r\n    const bufferRows = model.bufferRowsForScreenRows(startRow, endRow)\r\n    const screenRows = new Array(renderedRowCount)\r\n    const keys = new Array(renderedRowCount)\r\n    const foldableFlags = new Array(renderedRowCount)\r\n    const softWrappedFlags = new Array(renderedRowCount)\r\n\r\n    let previousBufferRow = (startRow > 0) ? model.bufferRowForScreenRow(startRow - 1) : -1\r\n    let softWrapCount = 0\r\n    for (let row = startRow; row < endRow; row++) {\r\n      const i = row - startRow\r\n      const bufferRow = bufferRows[i]\r\n      if (bufferRow === previousBufferRow) {\r\n        softWrapCount++\r\n        softWrappedFlags[i] = true\r\n        keys[i] = bufferRow + '-' + softWrapCount\r\n      } else {\r\n        softWrapCount = 0\r\n        softWrappedFlags[i] = false\r\n        keys[i] = bufferRow\r\n      }\r\n\r\n      const nextBufferRow = bufferRows[i + 1]\r\n      if (bufferRow !== nextBufferRow) {\r\n        foldableFlags[i] = model.isFoldableAtBufferRow(bufferRow)\r\n      } else {\r\n        foldableFlags[i] = false\r\n      }\r\n\r\n      screenRows[i] = row\r\n      previousBufferRow = bufferRow\r\n    }\r\n\r\n    // Delete extra buffer row at the end because it's not currently on screen.\r\n    bufferRows.pop()\r\n\r\n    this.lineNumbersToRender.bufferRows = bufferRows\r\n    this.lineNumbersToRender.screenRows = screenRows\r\n    this.lineNumbersToRender.keys = keys\r\n    this.lineNumbersToRender.foldableFlags = foldableFlags\r\n    this.lineNumbersToRender.softWrappedFlags = softWrappedFlags\r\n  }\r", "name": "queryMaxLineNumberDigits", "func_location": "TextEditorComponent.queryLineNumbersToRender", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 897, "func_start_line": 889}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedStartRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2726, "start_line": 2720}, "call_info": {"func_end_line": 943, "code": "  queryLineNumbersToRender () {\r\n    const {model} = this.props\r\n    if (!model.anyLineNumberGutterVisible()) return\r\n    if (this.showLineNumbers !== model.doesShowLineNumbers()) {\r\n      this.remeasureGutterDimensions = true\r\n      this.showLineNumbers = model.doesShowLineNumbers()\r\n    }\r\n\r\n    this.queryMaxLineNumberDigits()\r\n\r\n    const startRow = this.getRenderedStartRow()\r\n    const endRow = this.getRenderedEndRow()\r\n    const renderedRowCount = this.getRenderedRowCount()\r\n\r\n    const bufferRows = model.bufferRowsForScreenRows(startRow, endRow)\r\n    const screenRows = new Array(renderedRowCount)\r\n    const keys = new Array(renderedRowCount)\r\n    const foldableFlags = new Array(renderedRowCount)\r\n    const softWrappedFlags = new Array(renderedRowCount)\r\n\r\n    let previousBufferRow = (startRow > 0) ? model.bufferRowForScreenRow(startRow - 1) : -1\r\n    let softWrapCount = 0\r\n    for (let row = startRow; row < endRow; row++) {\r\n      const i = row - startRow\r\n      const bufferRow = bufferRows[i]\r\n      if (bufferRow === previousBufferRow) {\r\n        softWrapCount++\r\n        softWrappedFlags[i] = true\r\n        keys[i] = bufferRow + '-' + softWrapCount\r\n      } else {\r\n        softWrapCount = 0\r\n        softWrappedFlags[i] = false\r\n        keys[i] = bufferRow\r\n      }\r\n\r\n      const nextBufferRow = bufferRows[i + 1]\r\n      if (bufferRow !== nextBufferRow) {\r\n        foldableFlags[i] = model.isFoldableAtBufferRow(bufferRow)\r\n      } else {\r\n        foldableFlags[i] = false\r\n      }\r\n\r\n      screenRows[i] = row\r\n      previousBufferRow = bufferRow\r\n    }\r\n\r\n    // Delete extra buffer row at the end because it's not currently on screen.\r\n    bufferRows.pop()\r\n\r\n    this.lineNumbersToRender.bufferRows = bufferRows\r\n    this.lineNumbersToRender.screenRows = screenRows\r\n    this.lineNumbersToRender.keys = keys\r\n    this.lineNumbersToRender.foldableFlags = foldableFlags\r\n    this.lineNumbersToRender.softWrappedFlags = softWrappedFlags\r\n  }\r", "name": "getRenderedStartRow", "func_location": "TextEditorComponent.queryLineNumbersToRender", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 899, "func_start_line": 889}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedEndRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2737, "start_line": 2728}, "call_info": {"func_end_line": 943, "code": "  queryLineNumbersToRender () {\r\n    const {model} = this.props\r\n    if (!model.anyLineNumberGutterVisible()) return\r\n    if (this.showLineNumbers !== model.doesShowLineNumbers()) {\r\n      this.remeasureGutterDimensions = true\r\n      this.showLineNumbers = model.doesShowLineNumbers()\r\n    }\r\n\r\n    this.queryMaxLineNumberDigits()\r\n\r\n    const startRow = this.getRenderedStartRow()\r\n    const endRow = this.getRenderedEndRow()\r\n    const renderedRowCount = this.getRenderedRowCount()\r\n\r\n    const bufferRows = model.bufferRowsForScreenRows(startRow, endRow)\r\n    const screenRows = new Array(renderedRowCount)\r\n    const keys = new Array(renderedRowCount)\r\n    const foldableFlags = new Array(renderedRowCount)\r\n    const softWrappedFlags = new Array(renderedRowCount)\r\n\r\n    let previousBufferRow = (startRow > 0) ? model.bufferRowForScreenRow(startRow - 1) : -1\r\n    let softWrapCount = 0\r\n    for (let row = startRow; row < endRow; row++) {\r\n      const i = row - startRow\r\n      const bufferRow = bufferRows[i]\r\n      if (bufferRow === previousBufferRow) {\r\n        softWrapCount++\r\n        softWrappedFlags[i] = true\r\n        keys[i] = bufferRow + '-' + softWrapCount\r\n      } else {\r\n        softWrapCount = 0\r\n        softWrappedFlags[i] = false\r\n        keys[i] = bufferRow\r\n      }\r\n\r\n      const nextBufferRow = bufferRows[i + 1]\r\n      if (bufferRow !== nextBufferRow) {\r\n        foldableFlags[i] = model.isFoldableAtBufferRow(bufferRow)\r\n      } else {\r\n        foldableFlags[i] = false\r\n      }\r\n\r\n      screenRows[i] = row\r\n      previousBufferRow = bufferRow\r\n    }\r\n\r\n    // Delete extra buffer row at the end because it's not currently on screen.\r\n    bufferRows.pop()\r\n\r\n    this.lineNumbersToRender.bufferRows = bufferRows\r\n    this.lineNumbersToRender.screenRows = screenRows\r\n    this.lineNumbersToRender.keys = keys\r\n    this.lineNumbersToRender.foldableFlags = foldableFlags\r\n    this.lineNumbersToRender.softWrappedFlags = softWrappedFlags\r\n  }\r", "name": "getRenderedEndRow", "func_location": "TextEditorComponent.queryLineNumbersToRender", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 900, "func_start_line": 889}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedRowCount", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2745, "start_line": 2739}, "call_info": {"func_end_line": 943, "code": "  queryLineNumbersToRender () {\r\n    const {model} = this.props\r\n    if (!model.anyLineNumberGutterVisible()) return\r\n    if (this.showLineNumbers !== model.doesShowLineNumbers()) {\r\n      this.remeasureGutterDimensions = true\r\n      this.showLineNumbers = model.doesShowLineNumbers()\r\n    }\r\n\r\n    this.queryMaxLineNumberDigits()\r\n\r\n    const startRow = this.getRenderedStartRow()\r\n    const endRow = this.getRenderedEndRow()\r\n    const renderedRowCount = this.getRenderedRowCount()\r\n\r\n    const bufferRows = model.bufferRowsForScreenRows(startRow, endRow)\r\n    const screenRows = new Array(renderedRowCount)\r\n    const keys = new Array(renderedRowCount)\r\n    const foldableFlags = new Array(renderedRowCount)\r\n    const softWrappedFlags = new Array(renderedRowCount)\r\n\r\n    let previousBufferRow = (startRow > 0) ? model.bufferRowForScreenRow(startRow - 1) : -1\r\n    let softWrapCount = 0\r\n    for (let row = startRow; row < endRow; row++) {\r\n      const i = row - startRow\r\n      const bufferRow = bufferRows[i]\r\n      if (bufferRow === previousBufferRow) {\r\n        softWrapCount++\r\n        softWrappedFlags[i] = true\r\n        keys[i] = bufferRow + '-' + softWrapCount\r\n      } else {\r\n        softWrapCount = 0\r\n        softWrappedFlags[i] = false\r\n        keys[i] = bufferRow\r\n      }\r\n\r\n      const nextBufferRow = bufferRows[i + 1]\r\n      if (bufferRow !== nextBufferRow) {\r\n        foldableFlags[i] = model.isFoldableAtBufferRow(bufferRow)\r\n      } else {\r\n        foldableFlags[i] = false\r\n      }\r\n\r\n      screenRows[i] = row\r\n      previousBufferRow = bufferRow\r\n    }\r\n\r\n    // Delete extra buffer row at the end because it's not currently on screen.\r\n    bufferRows.pop()\r\n\r\n    this.lineNumbersToRender.bufferRows = bufferRows\r\n    this.lineNumbersToRender.screenRows = screenRows\r\n    this.lineNumbersToRender.keys = keys\r\n    this.lineNumbersToRender.foldableFlags = foldableFlags\r\n    this.lineNumbersToRender.softWrappedFlags = softWrappedFlags\r\n  }\r", "name": "getRenderedRowCount", "func_location": "TextEditorComponent.queryLineNumbersToRender", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 901, "func_start_line": 889}}, {"func_info": {"comment": [], "name": "TextEditorComponent.requestLineToMeasure", "params": ["row", "screenLine"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2241, "start_line": 2239}, "call_info": {"func_end_line": 878, "code": "  queryLongestLine () {\r\n    const {model} = this.props\r\n\r\n    const longestLineRow = model.getApproximateLongestScreenRow()\r\n    const longestLine = model.screenLineForScreenRow(longestLineRow)\r\n    if (longestLine !== this.previousLongestLine || this.remeasureCharacterDimensions) {\r\n      this.requestLineToMeasure(longestLineRow, longestLine)\r\n      this.longestLineToMeasure = longestLine\r\n      this.previousLongestLine = longestLine\r\n    }\r\n  }\r", "name": "requestLineToMeasure", "func_location": "TextEditorComponent.queryLongestLine", "args": ["longestLineRow", "longestLine"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 874, "func_start_line": 868}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedStartRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2726, "start_line": 2720}, "call_info": {"func_end_line": 866, "code": "  queryScreenLinesToRender () {\r\n    const {model} = this.props\r\n\r\n    this.renderedScreenLines = model.displayLayer.getScreenLines(\r\n      this.getRenderedStartRow(),\r\n      this.getRenderedEndRow()\r\n    )\r\n  }\r", "name": "getRenderedStartRow", "func_location": "TextEditorComponent.queryScreenLinesToRender", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 863, "func_start_line": 859}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedEndRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2737, "start_line": 2728}, "call_info": {"func_end_line": 866, "code": "  queryScreenLinesToRender () {\r\n    const {model} = this.props\r\n\r\n    this.renderedScreenLines = model.displayLayer.getScreenLines(\r\n      this.getRenderedStartRow(),\r\n      this.getRenderedEndRow()\r\n    )\r\n  }\r", "name": "getRenderedEndRow", "func_location": "TextEditorComponent.queryScreenLinesToRender", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 864, "func_start_line": 859}}, {"func_info": {"comment": [], "name": "vecFromRange", "params": [["start", "end"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1188, "start_line": 1186}, "call_info": {"func_end_line": 1184, "comment": [" Return true iff `mouse` is smaller than `house`. Only correct if", " mouse and house overlap.", "", " * `mouse` {Range}", " * `house` {Range}"], "code": "function rangeIsSmaller (mouse, house) {\r\n  if (!house) return true\r\n  const mvec = vecFromRange(mouse)\r\n  const hvec = vecFromRange(house)\r\n  return Point.min(mvec, hvec) === mvec\r\n}\r", "name": "vecFromRange", "func_location": "rangeIsSmaller", "args": ["mouse"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 1181, "func_start_line": 1179}}, {"func_info": {"comment": [], "name": "vecFromRange", "params": [["start", "end"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1188, "start_line": 1186}, "call_info": {"func_end_line": 1184, "comment": [" Return true iff `mouse` is smaller than `house`. Only correct if", " mouse and house overlap.", "", " * `mouse` {Range}", " * `house` {Range}"], "code": "function rangeIsSmaller (mouse, house) {\r\n  if (!house) return true\r\n  const mvec = vecFromRange(mouse)\r\n  const hvec = vecFromRange(house)\r\n  return Point.min(mvec, hvec) === mvec\r\n}\r", "name": "vecFromRange", "func_location": "rangeIsSmaller", "args": ["house"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 1182, "func_start_line": 1179}}, {"func_info": {"comment": [], "name": "ViewRegistry.requestDocumentUpdate", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/view-registry.js", "end_line": 228, "start_line": 224}, "call_info": {"func_end_line": 201, "code": "  readDocument (fn) {\r\n    this.documentReaders.push(fn)\r\n    this.requestDocumentUpdate()\r\n    return new Disposable(() => {\r\n      this.documentReaders = this.documentReaders.filter(reader => reader !== fn)\r\n    })\r\n  }\r", "name": "requestDocumentUpdate", "func_location": "ViewRegistry.readDocument", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/view-registry.js", "line": 197, "func_start_line": 195}}, {"func_info": {"comment": [], "name": "GrammarRegistry.createGrammar", "params": ["grammarPath", "params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 547, "start_line": 538}, "call_info": {"func_end_line": 536, "comment": [" Extended: Read a grammar synchronously but don't add it to the registry.", "", " * `grammarPath` A {String} absolute file path to a grammar file.", "", " Returns a {Grammar}."], "code": "  readGrammarSync (grammarPath) {\r\n    return this.createGrammar(grammarPath, CSON.readFileSync(grammarPath) || {})\r\n  }\r", "name": "createGrammar", "func_location": "GrammarRegistry.readGrammarSync", "args": ["grammarPath", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 535, "func_start_line": 534}}, {"func_info": {"comment": [" Public: Read the text from the clipboard.", "", " Returns a {String}."], "name": "Clipboard.read", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/clipboard.js", "end_line": 53, "start_line": 51}, "call_info": {"func_end_line": 68, "comment": [" Public: Read the text from the clipboard and return both the text and the", " associated metadata.", "", " Returns an {Object} with the following keys:", " * `text` The {String} clipboard text.", " * `metadata` The metadata stored by an earlier call to {::write}."], "code": "  readWithMetadata () {\r\n    const text = this.read()\r\n    if (this.signatureForMetadata === this.md5(text)) {\r\n      return {text, metadata: this.metadata}\r\n    } else {\r\n      return {text}\r\n    }\r\n  }\r", "name": "read", "func_location": "Clipboard.readWithMetadata", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/clipboard.js", "line": 62, "func_start_line": 61}}, {"func_info": {"comment": [" Creates an `md5` hash of some text.", "", " * `text` A {String} to hash.", "", " Returns a hashed {String}."], "name": "Clipboard.md5", "params": ["text"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/clipboard.js", "end_line": 33, "start_line": 31}, "call_info": {"func_end_line": 68, "comment": [" Public: Read the text from the clipboard and return both the text and the", " associated metadata.", "", " Returns an {Object} with the following keys:", " * `text` The {String} clipboard text.", " * `metadata` The metadata stored by an earlier call to {::write}."], "code": "  readWithMetadata () {\r\n    const text = this.read()\r\n    if (this.signatureForMetadata === this.md5(text)) {\r\n      return {text, metadata: this.metadata}\r\n    } else {\r\n      return {text}\r\n    }\r\n  }\r", "name": "md5", "func_location": "Clipboard.readWithMetadata", "args": ["text"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/clipboard.js", "line": 63, "func_start_line": 61}}, {"func_info": {"comment": [], "name": "copyFile", "params": ["source", "destination", "mode"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js", "end_line": 165, "start_line": 149}, "call_info": {"func_end_line": 116, "code": "  async recover () {\r\n    await copyFile(this.recoveryPath, this.originalPath, this.fileMode)\r\n    await this.remove()\r\n  }\r", "name": "copyFile", "func_location": "RecoveryFile.recover", "args": [".recoveryPath", ".originalPath", ".fileMode"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js", "line": 114, "func_start_line": 113}}, {"func_info": {"comment": [], "name": "RecoveryFile.remove", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js", "end_line": 124, "start_line": 118}, "call_info": {"func_end_line": 116, "code": "  async recover () {\r\n    await copyFile(this.recoveryPath, this.originalPath, this.fileMode)\r\n    await this.remove()\r\n  }\r", "name": "remove", "func_location": "RecoveryFile.recover", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js", "line": 115, "func_start_line": 113}}, {"func_info": {"comment": [" Returns the corresponding {Repository}"], "name": "GitRepository.getRepo", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 530, "start_line": 524}, "call_info": {"func_end_line": 536, "comment": [" Reread the index to update any values that have changed since the", " last time the index was read."], "code": "  refreshIndex () {\r\n    return this.getRepo().refreshIndex()\r\n  }\r", "name": "getRepo", "func_location": "GitRepository.refreshIndex", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 535, "func_start_line": 534}}, {"func_info": {"comment": [], "name": "ThemeManager.getImportPaths", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 402, "start_line": 381}, "call_info": {"func_end_line": 379, "code": "  refreshLessCache () {\r\n    if (this.lessCache) this.lessCache.setImportPaths(this.getImportPaths())\r\n  }\r", "name": "getImportPaths", "func_location": "ThemeManager.refreshLessCache", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 378, "func_start_line": 377}}, {"func_info": {"comment": [" Returns the corresponding {Repository}"], "name": "GitRepository.getRepo", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 530, "start_line": 524}, "call_info": {"func_end_line": 594, "comment": [" Refreshes the current git status in an outside process and asynchronously", " updates the relevant properties."], "code": "  async refreshStatus () {\r\n    const statusRefreshCount = ++this.statusRefreshCount\r\n    const repo = this.getRepo()\r\n\r\n    const relativeProjectPaths = this.project && this.project.getPaths()\r\n      .map(projectPath => this.relativize(projectPath))\r\n      .filter(projectPath => (projectPath.length > 0) && !path.isAbsolute(projectPath))\r\n\r\n    const branch = await repo.getHeadAsync()\r\n    const upstream = await repo.getAheadBehindCountAsync()\r\n\r\n    const statuses = {}\r\n    const repoStatus = relativeProjectPaths.length > 0\r\n      ? await repo.getStatusAsync(relativeProjectPaths)\r\n      : await repo.getStatusAsync()\r\n    for (let filePath in repoStatus) {\r\n      statuses[filePath] = repoStatus[filePath]\r\n    }\r\n\r\n    const submodules = {}\r\n    for (let submodulePath in repo.submodules) {\r\n      const submoduleRepo = repo.submodules[submodulePath]\r\n      submodules[submodulePath] = {\r\n        branch: await submoduleRepo.getHeadAsync(),\r\n        upstream: await submoduleRepo.getAheadBehindCountAsync()\r\n      }\r\n\r\n      const workingDirectoryPath = submoduleRepo.getWorkingDirectory()\r\n      const submoduleStatus = await submoduleRepo.getStatusAsync()\r\n      for (let filePath in submoduleStatus) {\r\n        const absolutePath = path.join(workingDirectoryPath, filePath)\r\n        const relativizePath = repo.relativize(absolutePath)\r\n        statuses[relativizePath] = submoduleStatus[filePath]\r\n      }\r\n    }\r\n\r\n    if (this.statusRefreshCount !== statusRefreshCount || this.isDestroyed()) return\r\n\r\n    const statusesUnchanged =\r\n      _.isEqual(branch, this.branch) &&\r\n      _.isEqual(statuses, this.statuses) &&\r\n      _.isEqual(upstream, this.upstream) &&\r\n      _.isEqual(submodules, this.submodules)\r\n\r\n    this.branch = branch\r\n    this.statuses = statuses\r\n    this.upstream = upstream\r\n    this.submodules = submodules\r\n\r\n    for (let submodulePath in repo.submodules) {\r\n      repo.submodules[submodulePath].upstream = submodules[submodulePath].upstream\r\n    }\r\n\r\n    if (!statusesUnchanged) this.emitter.emit('did-change-statuses')\r\n  }\r", "name": "getRepo", "func_location": "GitRepository.refreshStatus", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 542, "func_start_line": 540}}, {"func_info": {"comment": [" Public: Returns a {Boolean} indicating if this repository has been destroyed."], "name": "GitRepository.isDestroyed", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 132, "start_line": 130}, "call_info": {"func_end_line": 594, "comment": [" Refreshes the current git status in an outside process and asynchronously", " updates the relevant properties."], "code": "  async refreshStatus () {\r\n    const statusRefreshCount = ++this.statusRefreshCount\r\n    const repo = this.getRepo()\r\n\r\n    const relativeProjectPaths = this.project && this.project.getPaths()\r\n      .map(projectPath => this.relativize(projectPath))\r\n      .filter(projectPath => (projectPath.length > 0) && !path.isAbsolute(projectPath))\r\n\r\n    const branch = await repo.getHeadAsync()\r\n    const upstream = await repo.getAheadBehindCountAsync()\r\n\r\n    const statuses = {}\r\n    const repoStatus = relativeProjectPaths.length > 0\r\n      ? await repo.getStatusAsync(relativeProjectPaths)\r\n      : await repo.getStatusAsync()\r\n    for (let filePath in repoStatus) {\r\n      statuses[filePath] = repoStatus[filePath]\r\n    }\r\n\r\n    const submodules = {}\r\n    for (let submodulePath in repo.submodules) {\r\n      const submoduleRepo = repo.submodules[submodulePath]\r\n      submodules[submodulePath] = {\r\n        branch: await submoduleRepo.getHeadAsync(),\r\n        upstream: await submoduleRepo.getAheadBehindCountAsync()\r\n      }\r\n\r\n      const workingDirectoryPath = submoduleRepo.getWorkingDirectory()\r\n      const submoduleStatus = await submoduleRepo.getStatusAsync()\r\n      for (let filePath in submoduleStatus) {\r\n        const absolutePath = path.join(workingDirectoryPath, filePath)\r\n        const relativizePath = repo.relativize(absolutePath)\r\n        statuses[relativizePath] = submoduleStatus[filePath]\r\n      }\r\n    }\r\n\r\n    if (this.statusRefreshCount !== statusRefreshCount || this.isDestroyed()) return\r\n\r\n    const statusesUnchanged =\r\n      _.isEqual(branch, this.branch) &&\r\n      _.isEqual(statuses, this.statuses) &&\r\n      _.isEqual(upstream, this.upstream) &&\r\n      _.isEqual(submodules, this.submodules)\r\n\r\n    this.branch = branch\r\n    this.statuses = statuses\r\n    this.upstream = upstream\r\n    this.submodules = submodules\r\n\r\n    for (let submodulePath in repo.submodules) {\r\n      repo.submodules[submodulePath].upstream = submodules[submodulePath].upstream\r\n    }\r\n\r\n    if (!statusesUnchanged) this.emitter.emit('did-change-statuses')\r\n  }\r", "name": "isDestroyed", "func_location": "GitRepository.refreshStatus", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 576, "func_start_line": 540}}, {"func_info": {"comment": [], "name": "registerBuiltins", "params": ["devMode"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js", "end_line": 250, "start_line": 229}, "call_info": {"func_end_line": 290, "code": "exports.register = function ({resourcePath, devMode} = {}) {\r\n  if (cache.registered) return\r\n\r\n  const originalResolveFilename = Module._resolveFilename\r\n  Module._resolveFilename = function (relativePath, parentModule) {\r\n    let resolvedPath = resolveModulePath(relativePath, parentModule)\r\n    if (!resolvedPath) {\r\n      resolvedPath = resolveFilePath(relativePath, parentModule)\r\n    }\r\n    return resolvedPath || originalResolveFilename(relativePath, parentModule)\r\n  }\r\n\r\n  cache.registered = true\r\n  cache.resourcePath = resourcePath\r\n  cache.resourcePathWithTrailingSlash = `${resourcePath}${path.sep}`\r\n  registerBuiltins(devMode)\r\n}\r", "name": "registerBuiltins", "func_location": "exports.register", "args": ["devMode"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js", "line": 289, "func_start_line": 274}}, {"func_info": {"comment": [], "name": "Package.getURIHandler", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 921, "start_line": 919}, "call_info": {"func_end_line": 413, "code": "  registerURIHandler () {\r\n    const handlerConfig = this.getURIHandler()\r\n    const methodName = handlerConfig && handlerConfig.method\r\n    if (methodName) {\r\n      this.uriHandlerSubscription = this.packageManager.registerURIHandlerForPackage(this.name, (...args) =>\r\n        this.handleURI(methodName, args)\r\n      )\r\n    }\r\n  }\r", "name": "getURIHandler", "func_location": "Package.registerURIHandler", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 406, "func_start_line": 405}}, {"func_info": {"comment": [], "name": "Package.requireMainModule", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 784, "start_line": 755}, "call_info": {"func_end_line": 537, "code": "  registerViewProviders () {\r\n    if (this.metadata.viewProviders && !this.registeredViewProviders) {\r\n      this.requireMainModule()\r\n      this.metadata.viewProviders.forEach(methodName => {\r\n        this.viewRegistry.addViewProvider(model => {\r\n          this.initializeIfNeeded()\r\n          return this.mainModule[methodName](model)\r\n        })\r\n      })\r\n      this.registeredViewProviders = true\r\n    }\r\n  }\r", "name": "requireMainModule", "func_location": "Package.registerViewProviders", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 528, "func_start_line": 526}}, {"func_info": {"comment": [" Returns the corresponding {Repository}"], "name": "GitRepository.getRepo", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "end_line": 530, "start_line": 524}, "call_info": {"func_end_line": 210, "comment": [" Public: Makes a path relative to the repository's working directory."], "code": "  relativize (path) {\r\n    return this.getRepo().relativize(path)\r\n  }\r", "name": "getRepo", "func_location": "GitRepository.relativize", "args": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/git-repository.js", "line": 209, "func_start_line": 208}}, {"func_info": {"comment": [" Public: Get the path to the project directory that contains the given path,", " and the relative path from that project directory to the given path.", "", " * `fullPath` {String} An absolute path.", "", " Returns an {Array} with two elements:", " * `projectPath` The {String} path to the project directory that contains the", "   given path, or `null` if none is found.", " * `relativePath` {String} The relative path from the project directory to", "   the given path."], "name": "Project.relativizePath", "params": ["fullPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 557, "start_line": 546}, "call_info": {"func_end_line": 534, "code": "  relativize (fullPath) {\r\n    return this.relativizePath(fullPath)[1]\r\n  }\r", "name": "relativizePath", "func_location": "Project.relativize", "args": ["fullPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 533, "func_start_line": 532}}, {"func_info": {"comment": [], "name": "NodePool.release", "params": ["node", "depth"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4483, "start_line": 4461}, "call_info": {"func_end_line": 4483, "code": "  release (node, depth = 0) {\r\n    var {nodeName} = node\r\n    if (nodeName === '#text') {\r\n      this.textNodes.push(node)\r\n    } else {\r\n      var elementsByDepth = this.elementsByType[nodeName]\r\n      if (!elementsByDepth) {\r\n        elementsByDepth = []\r\n        this.elementsByType[nodeName] = elementsByDepth\r\n      }\r\n\r\n      var elements = elementsByDepth[depth]\r\n      if (!elements) {\r\n        elements = []\r\n        elementsByDepth[depth] = elements\r\n      }\r\n\r\n      elements.push(node)\r\n      for (var i = 0; i < node.childNodes.length; i++) {\r\n        this.release(node.childNodes[i], depth + 1)\r\n      }\r\n    }\r\n  }\r", "name": "release", "func_location": "NodePool.release", "args": ["node.childNodes.i", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 4480, "func_start_line": 4461}}, {"func_info": {"comment": [], "name": "RecoveryFile.isReleased", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js", "end_line": 138, "start_line": 136}, "call_info": {"func_end_line": 134, "code": "  async release () {\r\n    this.refCount--\r\n    if (this.isReleased()) await this.remove()\r\n  }\r", "name": "isReleased", "func_location": "RecoveryFile.release", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js", "line": 133, "func_start_line": 131}}, {"func_info": {"comment": [], "name": "RecoveryFile.remove", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js", "end_line": 124, "start_line": 118}, "call_info": {"func_end_line": 134, "code": "  async release () {\r\n    this.refCount--\r\n    if (this.isReleased()) await this.remove()\r\n  }\r", "name": "remove", "func_location": "RecoveryFile.release", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js", "line": 133, "func_start_line": 131}}, {"func_info": {"comment": [], "name": "AtomWindow.prepareToUnload", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "end_line": 246, "start_line": 227}, "call_info": {"func_end_line": 392, "code": "  reload () {\r\n    this.loadedPromise = new Promise(resolve => { this.resolveLoadedPromise = resolve })\r\n    this.prepareToUnload().then(canUnload => {\r\n      if (canUnload) this.browserWindow.reload()\r\n    })\r\n    return this.loadedPromise\r\n  }\r", "name": "prepareToUnload", "func_location": "AtomWindow.reload", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "line": 388, "func_start_line": 386}}, {"func_info": {"comment": ["\r\n  Section: Accessing active packages\r\n  ", " Public: Get an {Array} of all the active {Package}s."], "name": "PackageManager.getActivePackages", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 293, "start_line": 291}, "call_info": {"func_end_line": 825, "code": "  reloadActivePackageStyleSheets () {\r\n    for (const pack of this.getActivePackages()) {\r\n      if (pack.getType() !== 'theme' && typeof pack.reloadStylesheets === 'function') {\r\n        pack.reloadStylesheets()\r\n      }\r\n    }\r\n  }\r", "name": "getActivePackages", "func_location": "PackageManager.reloadActivePackageStyleSheets", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 820, "func_start_line": 819}}, {"func_info": {"comment": ["\r\n  Section: Private\r\n  ", " Resolve and apply the stylesheet specified by the path.", "", " This supports both CSS and Less stylesheets.", "", " * `stylesheetPath` A {String} path to the stylesheet that can be an absolute", "   path or a relative path that will be resolved against the load path.", "", " Returns a {Disposable} on which `.dispose()` can be called to remove the", " required stylesheet."], "name": "ThemeManager.requireStylesheet", "params": ["stylesheetPath", "priority", "skipDeprecatedSelectorsTransformation"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 175, "start_line": 167}, "call_info": {"func_end_line": 226, "code": "  reloadBaseStylesheets () {\r\n    this.requireStylesheet('../static/atom', -2, true)\r\n  }\r", "name": "requireStylesheet", "func_location": "ThemeManager.reloadBaseStylesheets", "args": [{"type": "string"}, null, {"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 225, "func_start_line": 224}}, {"func_info": {"comment": [], "name": "Package.loadStylesheets", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 490, "start_line": 486}, "call_info": {"func_end_line": 753, "code": "  reloadStylesheets () {\r\n    try {\r\n      this.loadStylesheets()\r\n    } catch (error) {\r\n      this.handleError(`Failed to reload the ${this.name} package stylesheets`, error)\r\n    }\r\n\r\n    if (this.stylesheetDisposables) this.stylesheetDisposables.dispose()\r\n    this.stylesheetDisposables = new CompositeDisposable()\r\n    this.stylesheetsActivated = false\r\n    this.activateStylesheets()\r\n  }\r", "name": "loadStylesheets", "func_location": "Package.reloadStylesheets", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 744, "func_start_line": 742}}, {"func_info": {"comment": [], "name": "Package.handleError", "params": ["message", "error"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 1105, "start_line": 1085}, "call_info": {"func_end_line": 753, "code": "  reloadStylesheets () {\r\n    try {\r\n      this.loadStylesheets()\r\n    } catch (error) {\r\n      this.handleError(`Failed to reload the ${this.name} package stylesheets`, error)\r\n    }\r\n\r\n    if (this.stylesheetDisposables) this.stylesheetDisposables.dispose()\r\n    this.stylesheetDisposables = new CompositeDisposable()\r\n    this.stylesheetsActivated = false\r\n    this.activateStylesheets()\r\n  }\r", "name": "handleError", "func_location": "Package.reloadStylesheets", "args": [null, "error"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 746, "func_start_line": 742}}, {"func_info": {"comment": [], "name": "Package.activateStylesheets", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 295, "start_line": 265}, "call_info": {"func_end_line": 753, "code": "  reloadStylesheets () {\r\n    try {\r\n      this.loadStylesheets()\r\n    } catch (error) {\r\n      this.handleError(`Failed to reload the ${this.name} package stylesheets`, error)\r\n    }\r\n\r\n    if (this.stylesheetDisposables) this.stylesheetDisposables.dispose()\r\n    this.stylesheetDisposables = new CompositeDisposable()\r\n    this.stylesheetsActivated = false\r\n    this.activateStylesheets()\r\n  }\r", "name": "activateStylesheets", "func_location": "Package.reloadStylesheets", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 752, "func_start_line": 742}}, {"func_info": {"comment": [" Public: Returns an {Array} of all the active themes."], "name": "ThemeManager.getActiveThemes", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 94, "start_line": 92}, "call_info": {"func_end_line": 375, "code": "  removeActiveThemeClasses () {\r\n    const workspaceElement = this.viewRegistry.getView(this.workspace)\r\n    for (const pack of this.getActiveThemes()) {\r\n      workspaceElement.classList.remove(`theme-${pack.name}`)\r\n    }\r\n  }\r", "name": "getActiveThemes", "func_location": "ThemeManager.removeActiveThemeClasses", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 372, "func_start_line": 370}}, {"func_info": {"comment": ["\r\n  Section: Managing Settings\r\n  ", " Essential: Retrieves the setting for the given key.", "", " ### Examples", "", " You might want to know what themes are enabled, so check `core.themes`", "", " ```coffee", " atom.config.get('core.themes')", " ```", "", " With scope descriptors you can get settings within a specific editor", " scope. For example, you might want to know `editor.tabLength` for ruby", " files.", "", " ```coffee", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " ```", "", " This setting in ruby files might be different than the global tabLength setting", "", " ```coffee", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " ```", "", " You can get the language scope descriptor via", " {TextEditor::getRootScopeDescriptor}. This will get the setting specifically", " for the editor's language.", "", " ```coffee", " atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2", " ```", "", " Additionally, you can get the setting at the specific cursor position.", "", " ```coffee", " scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()", " atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2", " ```", "", " * `keyPath` The {String} name of the key to retrieve.", " * `options` (optional) {Object}", "   * `sources` (optional) {Array} of {String} source names. If provided, only", "     values that were associated with these sources during {::set} will be used.", "   * `excludeSources` (optional) {Array} of {String} source names. If provided,", "     values that  were associated with these sources during {::set} will not", "     be used.", "   * `scope` (optional) {ScopeDescriptor} describing a path from", "     the root of the syntax tree to a token. Get one by calling", "     {editor.getLastCursor().getScopeDescriptor()}", "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)", "     for more information.", "", " Returns the value from Atom's default settings, the user's configuration", " file in the type specified by the configuration schema."], "name": "Config.get", "params": ["args"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 602, "start_line": 585}, "call_info": {"func_end_line": 893, "code": "  removeAtKeyPath (keyPath, value) {\r\n    const left = this.get(keyPath)\r\n    const arrayValue = (left == null ? [] : left)\r\n    const result = _.remove(arrayValue, value)\r\n    this.set(keyPath, arrayValue)\r\n    return result\r\n  }\r", "name": "get", "func_location": "Config.removeAtKeyPath", "args": ["keyPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 888, "func_start_line": 887}}, {"func_info": {"comment": [" Essential: Sets the value for a configuration setting.", "", " This value is stored in Atom's internal configuration file.", "", " ### Examples", "", " You might want to change the themes programmatically:", "", " ```coffee", " atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])", " ```", "", " You can also set scoped settings. For example, you might want change the", " `editor.tabLength` only for ruby files.", "", " ```coffee", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4", " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4", "", " # Set ruby to 2", " atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true", "", " # Notice it's only set to 2 in the case of ruby", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4", " ```", "", " * `keyPath` The {String} name of the key.", " * `value` The value of the setting. Passing `undefined` will revert the", "   setting to the default value.", " * `options` (optional) {Object}", "   * `scopeSelector` (optional) {String}. eg. '.source.ruby'", "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)", "     for more information.", "   * `source` (optional) {String} The name of a file with which the setting", "     is associated. Defaults to the user's config file.", "", " Returns a {Boolean}", " * `true` if the value was set.", " * `false` if the value was not able to be coerced to the type specified in the setting's schema."], "name": "Config.set", "params": ["args"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 722, "start_line": 687}, "call_info": {"func_end_line": 893, "code": "  removeAtKeyPath (keyPath, value) {\r\n    const left = this.get(keyPath)\r\n    const arrayValue = (left == null ? [] : left)\r\n    const result = _.remove(arrayValue, value)\r\n    this.set(keyPath, arrayValue)\r\n    return result\r\n  }\r", "name": "set", "func_location": "Config.removeAtKeyPath", "args": ["keyPath", "arrayValue"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 891, "func_start_line": 887}}, {"func_info": {"comment": [], "name": "Project.removeBufferAtIndex", "params": ["index", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 747, "start_line": 744}, "call_info": {"func_end_line": 742, "comment": [" Removes a {TextBuffer} association from the project.", "", " Returns the removed {TextBuffer}."], "code": "  removeBuffer (buffer) {\r\n    const index = this.buffers.indexOf(buffer)\r\n    if (index !== -1) { return this.removeBufferAtIndex(index) }\r\n  }\r", "name": "removeBufferAtIndex", "func_location": "Project.removeBuffer", "args": ["index"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 741, "func_start_line": 739}}, {"func_info": {"comment": [], "name": "PaneAxis.unsubscribeFromChild", "params": ["child"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js", "end_line": 190, "start_line": 186}, "call_info": {"func_end_line": 149, "code": "  removeChild (child, replacing = false) {\r\n    const index = this.children.indexOf(child)\r\n    if (index === -1) { throw new Error('Removing non-existent child') }\r\n\r\n    this.unsubscribeFromChild(child)\r\n\r\n    this.children.splice(index, 1)\r\n    this.adjustFlexScale()\r\n    this.emitter.emit('did-remove-child', {child, index})\r\n    if (!replacing && this.children.length < 2) {\r\n      this.reparentLastChild()\r\n    }\r\n  }\r", "name": "unsubscribeFromChild", "func_location": "PaneAxis.removeChild", "args": ["child"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js", "line": 141, "func_start_line": 137}}, {"func_info": {"comment": [], "name": "PaneAxis.adjustFlexScale", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js", "end_line": 135, "start_line": 125}, "call_info": {"func_end_line": 149, "code": "  removeChild (child, replacing = false) {\r\n    const index = this.children.indexOf(child)\r\n    if (index === -1) { throw new Error('Removing non-existent child') }\r\n\r\n    this.unsubscribeFromChild(child)\r\n\r\n    this.children.splice(index, 1)\r\n    this.adjustFlexScale()\r\n    this.emitter.emit('did-remove-child', {child, index})\r\n    if (!replacing && this.children.length < 2) {\r\n      this.reparentLastChild()\r\n    }\r\n  }\r", "name": "adjustFlexScale", "func_location": "PaneAxis.removeChild", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js", "line": 144, "func_start_line": 137}}, {"func_info": {"comment": [], "name": "PaneAxis.reparentLastChild", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js", "end_line": 178, "start_line": 173}, "call_info": {"func_end_line": 149, "code": "  removeChild (child, replacing = false) {\r\n    const index = this.children.indexOf(child)\r\n    if (index === -1) { throw new Error('Removing non-existent child') }\r\n\r\n    this.unsubscribeFromChild(child)\r\n\r\n    this.children.splice(index, 1)\r\n    this.adjustFlexScale()\r\n    this.emitter.emit('did-remove-child', {child, index})\r\n    if (!replacing && this.children.length < 2) {\r\n      this.reparentLastChild()\r\n    }\r\n  }\r", "name": "reparentLastChild", "func_location": "PaneAxis.removeChild", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js", "line": 147, "func_start_line": 137}}, {"func_info": {"comment": [], "name": "GutterContainer.scheduleComponentUpdate", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/gutter-container.js", "end_line": 13, "start_line": 11}, "call_info": {"func_end_line": 96, "comment": ["\r\n  Section: Private Methods\r\n  ", " Processes the destruction of the gutter. Throws an error if this gutter is", " not within this gutterContainer."], "code": "  removeGutter (gutter) {\r\n    const index = this.gutters.indexOf(gutter)\r\n    if (index > -1) {\r\n      this.gutters.splice(index, 1)\r\n      this.scheduleComponentUpdate()\r\n      this.emitter.emit('did-remove-gutter', gutter.name)\r\n    } else {\r\n      throw new Error('The given gutter cannot be removed because it is not ' +\r\n          'within this GutterContainer.'\r\n      )\r\n    }\r\n  }\r", "name": "scheduleComponentUpdate", "func_location": "GutterContainer.removeGutter", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/gutter-container.js", "line": 89, "func_start_line": 85}}, {"func_info": {"comment": [], "name": "Pane.getPendingItem", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 656, "start_line": 654}, "call_info": {"func_end_line": 705, "code": "  removeItem (item, moved) {\r\n    const index = this.items.indexOf(item)\r\n    if (index === -1) return\r\n    if (this.getPendingItem() === item) this.pendingItem = null\r\n    this.removeItemFromStack(item)\r\n    this.emitter.emit('will-remove-item', {item, index, destroyed: !moved, moved})\r\n    this.unsubscribeFromItem(item)\r\n\r\n    if (item === this.activeItem) {\r\n      if (this.items.length === 1) {\r\n        this.setActiveItem(undefined)\r\n      } else if (index === 0) {\r\n        this.activateNextItem()\r\n      } else {\r\n        this.activatePreviousItem()\r\n      }\r\n    }\r\n    this.items.splice(index, 1)\r\n    this.emitter.emit('did-remove-item', {item, index, destroyed: !moved, moved})\r\n    if (!moved && this.container) this.container.didDestroyPaneItem({item, index, pane: this})\r\n    if (this.items.length === 0 && this.config.get('core.destroyEmptyPanes')) this.destroy()\r\n  }\r", "name": "getPendingItem", "func_location": "Pane.removeItem", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 687, "func_start_line": 684}}, {"func_info": {"comment": [" Remove the given item from the itemStack.", "", " * `item` The item to remove.", " * `index` {Number} indicating the index to which to remove the item from the itemStack."], "name": "Pane.removeItemFromStack", "params": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 714, "start_line": 711}, "call_info": {"func_end_line": 705, "code": "  removeItem (item, moved) {\r\n    const index = this.items.indexOf(item)\r\n    if (index === -1) return\r\n    if (this.getPendingItem() === item) this.pendingItem = null\r\n    this.removeItemFromStack(item)\r\n    this.emitter.emit('will-remove-item', {item, index, destroyed: !moved, moved})\r\n    this.unsubscribeFromItem(item)\r\n\r\n    if (item === this.activeItem) {\r\n      if (this.items.length === 1) {\r\n        this.setActiveItem(undefined)\r\n      } else if (index === 0) {\r\n        this.activateNextItem()\r\n      } else {\r\n        this.activatePreviousItem()\r\n      }\r\n    }\r\n    this.items.splice(index, 1)\r\n    this.emitter.emit('did-remove-item', {item, index, destroyed: !moved, moved})\r\n    if (!moved && this.container) this.container.didDestroyPaneItem({item, index, pane: this})\r\n    if (this.items.length === 0 && this.config.get('core.destroyEmptyPanes')) this.destroy()\r\n  }\r", "name": "removeItemFromStack", "func_location": "Pane.removeItem", "args": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 688, "func_start_line": 684}}, {"func_info": {"comment": [], "name": "Pane.unsubscribeFromItem", "params": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 416, "start_line": 410}, "call_info": {"func_end_line": 705, "code": "  removeItem (item, moved) {\r\n    const index = this.items.indexOf(item)\r\n    if (index === -1) return\r\n    if (this.getPendingItem() === item) this.pendingItem = null\r\n    this.removeItemFromStack(item)\r\n    this.emitter.emit('will-remove-item', {item, index, destroyed: !moved, moved})\r\n    this.unsubscribeFromItem(item)\r\n\r\n    if (item === this.activeItem) {\r\n      if (this.items.length === 1) {\r\n        this.setActiveItem(undefined)\r\n      } else if (index === 0) {\r\n        this.activateNextItem()\r\n      } else {\r\n        this.activatePreviousItem()\r\n      }\r\n    }\r\n    this.items.splice(index, 1)\r\n    this.emitter.emit('did-remove-item', {item, index, destroyed: !moved, moved})\r\n    if (!moved && this.container) this.container.didDestroyPaneItem({item, index, pane: this})\r\n    if (this.items.length === 0 && this.config.get('core.destroyEmptyPanes')) this.destroy()\r\n  }\r", "name": "unsubscribeFromItem", "func_location": "Pane.removeItem", "args": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 690, "func_start_line": 684}}, {"func_info": {"comment": [], "name": "Pane.setActiveItem", "params": ["activeItem", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 443, "start_line": 434}, "call_info": {"func_end_line": 705, "code": "  removeItem (item, moved) {\r\n    const index = this.items.indexOf(item)\r\n    if (index === -1) return\r\n    if (this.getPendingItem() === item) this.pendingItem = null\r\n    this.removeItemFromStack(item)\r\n    this.emitter.emit('will-remove-item', {item, index, destroyed: !moved, moved})\r\n    this.unsubscribeFromItem(item)\r\n\r\n    if (item === this.activeItem) {\r\n      if (this.items.length === 1) {\r\n        this.setActiveItem(undefined)\r\n      } else if (index === 0) {\r\n        this.activateNextItem()\r\n      } else {\r\n        this.activatePreviousItem()\r\n      }\r\n    }\r\n    this.items.splice(index, 1)\r\n    this.emitter.emit('did-remove-item', {item, index, destroyed: !moved, moved})\r\n    if (!moved && this.container) this.container.didDestroyPaneItem({item, index, pane: this})\r\n    if (this.items.length === 0 && this.config.get('core.destroyEmptyPanes')) this.destroy()\r\n  }\r", "name": "setActiveItem", "func_location": "Pane.removeItem", "args": ["undefined"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 694, "func_start_line": 684}}, {"func_info": {"comment": [" Public: Makes the next item active."], "name": "Pane.activateNextItem", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 520, "start_line": 513}, "call_info": {"func_end_line": 705, "code": "  removeItem (item, moved) {\r\n    const index = this.items.indexOf(item)\r\n    if (index === -1) return\r\n    if (this.getPendingItem() === item) this.pendingItem = null\r\n    this.removeItemFromStack(item)\r\n    this.emitter.emit('will-remove-item', {item, index, destroyed: !moved, moved})\r\n    this.unsubscribeFromItem(item)\r\n\r\n    if (item === this.activeItem) {\r\n      if (this.items.length === 1) {\r\n        this.setActiveItem(undefined)\r\n      } else if (index === 0) {\r\n        this.activateNextItem()\r\n      } else {\r\n        this.activatePreviousItem()\r\n      }\r\n    }\r\n    this.items.splice(index, 1)\r\n    this.emitter.emit('did-remove-item', {item, index, destroyed: !moved, moved})\r\n    if (!moved && this.container) this.container.didDestroyPaneItem({item, index, pane: this})\r\n    if (this.items.length === 0 && this.config.get('core.destroyEmptyPanes')) this.destroy()\r\n  }\r", "name": "activateNextItem", "func_location": "Pane.removeItem", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 696, "func_start_line": 684}}, {"func_info": {"comment": [" Public: Makes the previous item active."], "name": "Pane.activatePreviousItem", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 530, "start_line": 523}, "call_info": {"func_end_line": 705, "code": "  removeItem (item, moved) {\r\n    const index = this.items.indexOf(item)\r\n    if (index === -1) return\r\n    if (this.getPendingItem() === item) this.pendingItem = null\r\n    this.removeItemFromStack(item)\r\n    this.emitter.emit('will-remove-item', {item, index, destroyed: !moved, moved})\r\n    this.unsubscribeFromItem(item)\r\n\r\n    if (item === this.activeItem) {\r\n      if (this.items.length === 1) {\r\n        this.setActiveItem(undefined)\r\n      } else if (index === 0) {\r\n        this.activateNextItem()\r\n      } else {\r\n        this.activatePreviousItem()\r\n      }\r\n    }\r\n    this.items.splice(index, 1)\r\n    this.emitter.emit('did-remove-item', {item, index, destroyed: !moved, moved})\r\n    if (!moved && this.container) this.container.didDestroyPaneItem({item, index, pane: this})\r\n    if (this.items.length === 0 && this.config.get('core.destroyEmptyPanes')) this.destroy()\r\n  }\r", "name": "activatePreviousItem", "func_location": "Pane.removeItem", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 698, "func_start_line": 684}}, {"func_info": {"comment": [" Public: Close the pane and destroy all its items.", "", " If this is the last pane, all the items will be destroyed but the pane", " itself will not be destroyed."], "name": "Pane.destroy", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 1039, "start_line": 1022}, "call_info": {"func_end_line": 705, "code": "  removeItem (item, moved) {\r\n    const index = this.items.indexOf(item)\r\n    if (index === -1) return\r\n    if (this.getPendingItem() === item) this.pendingItem = null\r\n    this.removeItemFromStack(item)\r\n    this.emitter.emit('will-remove-item', {item, index, destroyed: !moved, moved})\r\n    this.unsubscribeFromItem(item)\r\n\r\n    if (item === this.activeItem) {\r\n      if (this.items.length === 1) {\r\n        this.setActiveItem(undefined)\r\n      } else if (index === 0) {\r\n        this.activateNextItem()\r\n      } else {\r\n        this.activatePreviousItem()\r\n      }\r\n    }\r\n    this.items.splice(index, 1)\r\n    this.emitter.emit('did-remove-item', {item, index, destroyed: !moved, moved})\r\n    if (!moved && this.container) this.container.didDestroyPaneItem({item, index, pane: this})\r\n    if (this.items.length === 0 && this.config.get('core.destroyEmptyPanes')) this.destroy()\r\n  }\r", "name": "destroy", "func_location": "Pane.removeItem", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 704, "func_start_line": 684}}, {"func_info": {"comment": ["\r\n  Section: Managing Paths\r\n  ", " Public: Get an {Array} of {String}s containing the paths of the project's", " directories."], "name": "Project.getPaths", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 329, "start_line": 327}, "call_info": {"func_end_line": 507, "comment": [" Public: remove a path from the project's list of root paths.", "", " * `projectPath` {String} The path to remove."], "code": "  removePath (projectPath) {\r\n    // The projectPath may be a URI, in which case it should not be normalized.\r\n    if (!this.getPaths().includes(projectPath)) {\r\n      projectPath = this.defaultDirectoryProvider.normalizePath(projectPath)\r\n    }\r\n\r\n    let indexToRemove = null\r\n    for (let i = 0; i < this.rootDirectories.length; i++) {\r\n      const directory = this.rootDirectories[i]\r\n      if (directory.getPath() === projectPath) {\r\n        indexToRemove = i\r\n        break\r\n      }\r\n    }\r\n\r\n    if (indexToRemove != null) {\r\n      this.rootDirectories.splice(indexToRemove, 1)\r\n      const [removedRepository] = this.repositories.splice(indexToRemove, 1)\r\n      if (!this.repositories.includes(removedRepository)) {\r\n        if (removedRepository) removedRepository.destroy()\r\n      }\r\n      if (this.watcherPromisesByPath[projectPath] != null) {\r\n        this.watcherPromisesByPath[projectPath].then(w => w.dispose())\r\n      }\r\n      delete this.watcherPromisesByPath[projectPath]\r\n      this.emitter.emit('did-change-paths', this.getPaths())\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r", "name": "getPaths", "func_location": "Project.removePath", "args": ["projectPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 479, "func_start_line": 477}}, {"func_info": {"comment": ["\r\n  Section: Managing Paths\r\n  ", " Public: Get an {Array} of {String}s containing the paths of the project's", " directories."], "name": "Project.getPaths", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 329, "start_line": 327}, "call_info": {"func_end_line": 507, "comment": [" Public: remove a path from the project's list of root paths.", "", " * `projectPath` {String} The path to remove."], "code": "  removePath (projectPath) {\r\n    // The projectPath may be a URI, in which case it should not be normalized.\r\n    if (!this.getPaths().includes(projectPath)) {\r\n      projectPath = this.defaultDirectoryProvider.normalizePath(projectPath)\r\n    }\r\n\r\n    let indexToRemove = null\r\n    for (let i = 0; i < this.rootDirectories.length; i++) {\r\n      const directory = this.rootDirectories[i]\r\n      if (directory.getPath() === projectPath) {\r\n        indexToRemove = i\r\n        break\r\n      }\r\n    }\r\n\r\n    if (indexToRemove != null) {\r\n      this.rootDirectories.splice(indexToRemove, 1)\r\n      const [removedRepository] = this.repositories.splice(indexToRemove, 1)\r\n      if (!this.repositories.includes(removedRepository)) {\r\n        if (removedRepository) removedRepository.destroy()\r\n      }\r\n      if (this.watcherPromisesByPath[projectPath] != null) {\r\n        this.watcherPromisesByPath[projectPath].then(w => w.dispose())\r\n      }\r\n      delete this.watcherPromisesByPath[projectPath]\r\n      this.emitter.emit('did-change-paths', this.getPaths())\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r", "name": "getPaths", "func_location": "Project.removePath", "args": [{"type": "string"}, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 502, "func_start_line": 477}}, {"func_info": {"comment": [], "name": "HistoryManager.getProject", "params": ["paths"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "end_line": 91, "start_line": 83}, "call_info": {"func_end_line": 81, "code": "  async removeProject (paths) {\r\n    if (paths.length === 0) return\r\n\r\n    let project = this.getProject(paths)\r\n    if (!project) return\r\n\r\n    let index = this.projects.indexOf(project)\r\n    this.projects.splice(index, 1)\r\n\r\n    await this.saveState()\r\n    this.didChangeProjects()\r\n  }\r", "name": "getProject", "func_location": "HistoryManager.removeProject", "args": ["paths"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "line": 73, "func_start_line": 70}}, {"func_info": {"comment": [], "name": "HistoryManager.saveState", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "end_line": 106, "start_line": 103}, "call_info": {"func_end_line": 81, "code": "  async removeProject (paths) {\r\n    if (paths.length === 0) return\r\n\r\n    let project = this.getProject(paths)\r\n    if (!project) return\r\n\r\n    let index = this.projects.indexOf(project)\r\n    this.projects.splice(index, 1)\r\n\r\n    await this.saveState()\r\n    this.didChangeProjects()\r\n  }\r", "name": "saveState", "func_location": "HistoryManager.removeProject", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "line": 79, "func_start_line": 70}}, {"func_info": {"comment": [], "name": "HistoryManager.didChangeProjects", "params": ["args"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "end_line": 53, "start_line": 51}, "call_info": {"func_end_line": 81, "code": "  async removeProject (paths) {\r\n    if (paths.length === 0) return\r\n\r\n    let project = this.getProject(paths)\r\n    if (!project) return\r\n\r\n    let index = this.projects.indexOf(project)\r\n    this.projects.splice(index, 1)\r\n\r\n    await this.saveState()\r\n    this.didChangeProjects()\r\n  }\r", "name": "didChangeProjects", "func_location": "HistoryManager.removeProject", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/history-manager.js", "line": 80, "func_start_line": 70}}, {"func_info": {"comment": [], "name": "AtomApplication.getAllWindows", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 323, "start_line": 321}, "call_info": {"func_end_line": 296, "comment": [" Public: Removes the {AtomWindow} from the global window list."], "code": "  removeWindow (window) {\r\n    this.windowStack.removeWindow(window)\r\n    if (this.getAllWindows().length === 0) {\r\n      if (this.applicationMenu != null) {\r\n        this.applicationMenu.enableWindowSpecificItems(false)\r\n      }\r\n      if (['win32', 'linux'].includes(process.platform)) {\r\n        app.quit()\r\n        return\r\n      }\r\n    }\r\n    if (!window.isSpec) this.saveCurrentWindowOptions(true)\r\n  }\r", "name": "getAllWindows", "func_location": "AtomApplication.removeWindow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 286, "func_start_line": 284}}, {"func_info": {"comment": [], "name": "AtomApplication.saveCurrentWindowOptions", "params": ["allowEmpty"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 981, "start_line": 968}, "call_info": {"func_end_line": 296, "comment": [" Public: Removes the {AtomWindow} from the global window list."], "code": "  removeWindow (window) {\r\n    this.windowStack.removeWindow(window)\r\n    if (this.getAllWindows().length === 0) {\r\n      if (this.applicationMenu != null) {\r\n        this.applicationMenu.enableWindowSpecificItems(false)\r\n      }\r\n      if (['win32', 'linux'].includes(process.platform)) {\r\n        app.quit()\r\n        return\r\n      }\r\n    }\r\n    if (!window.isSpec) this.saveCurrentWindowOptions(true)\r\n  }\r", "name": "saveCurrentWindowOptions", "func_location": "AtomApplication.removeWindow", "args": [{"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 295, "func_start_line": 284}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getContentHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2686, "start_line": 2684}, "call_info": {"func_end_line": 521, "code": "  render () {\r\n    const {model} = this.props\r\n    const style = {}\r\n\r\n    if (!model.getAutoHeight() && !model.getAutoWidth()) {\r\n      style.contain = 'size'\r\n    }\r\n\r\n    let clientContainerHeight = '100%'\r\n    let clientContainerWidth = '100%'\r\n    if (this.hasInitialMeasurements) {\r\n      if (model.getAutoHeight()) {\r\n        clientContainerHeight =\r\n          this.getContentHeight() +\r\n          this.getHorizontalScrollbarHeight() +\r\n          'px'\r\n      }\r\n      if (model.getAutoWidth()) {\r\n        style.width = 'min-content'\r\n        clientContainerWidth =\r\n          this.getGutterContainerWidth() +\r\n          this.getContentWidth() +\r\n          this.getVerticalScrollbarWidth() +\r\n          'px'\r\n      } else {\r\n        style.width = this.element.style.width\r\n      }\r\n    }\r\n\r\n    let attributes = {}\r\n    if (model.isMini()) {\r\n      attributes.mini = ''\r\n    }\r\n\r\n    if (model.isReadOnly()) {\r\n      attributes.readonly = ''\r\n    }\r\n\r\n    const dataset = {encoding: model.getEncoding()}\r\n    const grammar = model.getGrammar()\r\n    if (grammar && grammar.scopeName) {\r\n      dataset.grammar = grammar.scopeName.replace(/\\./g, ' ')\r\n    }\r\n\r\n    return $('atom-text-editor',\r\n      {\r\n        // See this.updateClassList() for construction of the class name\r\n        style,\r\n        attributes,\r\n        dataset,\r\n        tabIndex: -1,\r\n        on: {mousewheel: this.didMouseWheel}\r\n      },\r\n      $.div(\r\n        {\r\n          ref: 'clientContainer',\r\n          style: {\r\n            position: 'relative',\r\n            contain: 'strict',\r\n            overflow: 'hidden',\r\n            backgroundColor: 'inherit',\r\n            height: clientContainerHeight,\r\n            width: clientContainerWidth\r\n          }\r\n        },\r\n        this.renderGutterContainer(),\r\n        this.renderScrollContainer()\r\n      ),\r\n      this.renderOverlayDecorations()\r\n    )\r\n  }\r", "name": "getContentHeight", "func_location": "TextEditorComponent.render", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 464, "func_start_line": 451}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getHorizontalScrollbarHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2710, "start_line": 2708}, "call_info": {"func_end_line": 521, "code": "  render () {\r\n    const {model} = this.props\r\n    const style = {}\r\n\r\n    if (!model.getAutoHeight() && !model.getAutoWidth()) {\r\n      style.contain = 'size'\r\n    }\r\n\r\n    let clientContainerHeight = '100%'\r\n    let clientContainerWidth = '100%'\r\n    if (this.hasInitialMeasurements) {\r\n      if (model.getAutoHeight()) {\r\n        clientContainerHeight =\r\n          this.getContentHeight() +\r\n          this.getHorizontalScrollbarHeight() +\r\n          'px'\r\n      }\r\n      if (model.getAutoWidth()) {\r\n        style.width = 'min-content'\r\n        clientContainerWidth =\r\n          this.getGutterContainerWidth() +\r\n          this.getContentWidth() +\r\n          this.getVerticalScrollbarWidth() +\r\n          'px'\r\n      } else {\r\n        style.width = this.element.style.width\r\n      }\r\n    }\r\n\r\n    let attributes = {}\r\n    if (model.isMini()) {\r\n      attributes.mini = ''\r\n    }\r\n\r\n    if (model.isReadOnly()) {\r\n      attributes.readonly = ''\r\n    }\r\n\r\n    const dataset = {encoding: model.getEncoding()}\r\n    const grammar = model.getGrammar()\r\n    if (grammar && grammar.scopeName) {\r\n      dataset.grammar = grammar.scopeName.replace(/\\./g, ' ')\r\n    }\r\n\r\n    return $('atom-text-editor',\r\n      {\r\n        // See this.updateClassList() for construction of the class name\r\n        style,\r\n        attributes,\r\n        dataset,\r\n        tabIndex: -1,\r\n        on: {mousewheel: this.didMouseWheel}\r\n      },\r\n      $.div(\r\n        {\r\n          ref: 'clientContainer',\r\n          style: {\r\n            position: 'relative',\r\n            contain: 'strict',\r\n            overflow: 'hidden',\r\n            backgroundColor: 'inherit',\r\n            height: clientContainerHeight,\r\n            width: clientContainerWidth\r\n          }\r\n        },\r\n        this.renderGutterContainer(),\r\n        this.renderScrollContainer()\r\n      ),\r\n      this.renderOverlayDecorations()\r\n    )\r\n  }\r", "name": "getHorizontalScrollbarHeight", "func_location": "TextEditorComponent.render", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 465, "func_start_line": 451}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getGutterContainerWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2698, "start_line": 2696}, "call_info": {"func_end_line": 521, "code": "  render () {\r\n    const {model} = this.props\r\n    const style = {}\r\n\r\n    if (!model.getAutoHeight() && !model.getAutoWidth()) {\r\n      style.contain = 'size'\r\n    }\r\n\r\n    let clientContainerHeight = '100%'\r\n    let clientContainerWidth = '100%'\r\n    if (this.hasInitialMeasurements) {\r\n      if (model.getAutoHeight()) {\r\n        clientContainerHeight =\r\n          this.getContentHeight() +\r\n          this.getHorizontalScrollbarHeight() +\r\n          'px'\r\n      }\r\n      if (model.getAutoWidth()) {\r\n        style.width = 'min-content'\r\n        clientContainerWidth =\r\n          this.getGutterContainerWidth() +\r\n          this.getContentWidth() +\r\n          this.getVerticalScrollbarWidth() +\r\n          'px'\r\n      } else {\r\n        style.width = this.element.style.width\r\n      }\r\n    }\r\n\r\n    let attributes = {}\r\n    if (model.isMini()) {\r\n      attributes.mini = ''\r\n    }\r\n\r\n    if (model.isReadOnly()) {\r\n      attributes.readonly = ''\r\n    }\r\n\r\n    const dataset = {encoding: model.getEncoding()}\r\n    const grammar = model.getGrammar()\r\n    if (grammar && grammar.scopeName) {\r\n      dataset.grammar = grammar.scopeName.replace(/\\./g, ' ')\r\n    }\r\n\r\n    return $('atom-text-editor',\r\n      {\r\n        // See this.updateClassList() for construction of the class name\r\n        style,\r\n        attributes,\r\n        dataset,\r\n        tabIndex: -1,\r\n        on: {mousewheel: this.didMouseWheel}\r\n      },\r\n      $.div(\r\n        {\r\n          ref: 'clientContainer',\r\n          style: {\r\n            position: 'relative',\r\n            contain: 'strict',\r\n            overflow: 'hidden',\r\n            backgroundColor: 'inherit',\r\n            height: clientContainerHeight,\r\n            width: clientContainerWidth\r\n          }\r\n        },\r\n        this.renderGutterContainer(),\r\n        this.renderScrollContainer()\r\n      ),\r\n      this.renderOverlayDecorations()\r\n    )\r\n  }\r", "name": "getGutterContainerWidth", "func_location": "TextEditorComponent.render", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 471, "func_start_line": 451}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getContentWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2690, "start_line": 2688}, "call_info": {"func_end_line": 521, "code": "  render () {\r\n    const {model} = this.props\r\n    const style = {}\r\n\r\n    if (!model.getAutoHeight() && !model.getAutoWidth()) {\r\n      style.contain = 'size'\r\n    }\r\n\r\n    let clientContainerHeight = '100%'\r\n    let clientContainerWidth = '100%'\r\n    if (this.hasInitialMeasurements) {\r\n      if (model.getAutoHeight()) {\r\n        clientContainerHeight =\r\n          this.getContentHeight() +\r\n          this.getHorizontalScrollbarHeight() +\r\n          'px'\r\n      }\r\n      if (model.getAutoWidth()) {\r\n        style.width = 'min-content'\r\n        clientContainerWidth =\r\n          this.getGutterContainerWidth() +\r\n          this.getContentWidth() +\r\n          this.getVerticalScrollbarWidth() +\r\n          'px'\r\n      } else {\r\n        style.width = this.element.style.width\r\n      }\r\n    }\r\n\r\n    let attributes = {}\r\n    if (model.isMini()) {\r\n      attributes.mini = ''\r\n    }\r\n\r\n    if (model.isReadOnly()) {\r\n      attributes.readonly = ''\r\n    }\r\n\r\n    const dataset = {encoding: model.getEncoding()}\r\n    const grammar = model.getGrammar()\r\n    if (grammar && grammar.scopeName) {\r\n      dataset.grammar = grammar.scopeName.replace(/\\./g, ' ')\r\n    }\r\n\r\n    return $('atom-text-editor',\r\n      {\r\n        // See this.updateClassList() for construction of the class name\r\n        style,\r\n        attributes,\r\n        dataset,\r\n        tabIndex: -1,\r\n        on: {mousewheel: this.didMouseWheel}\r\n      },\r\n      $.div(\r\n        {\r\n          ref: 'clientContainer',\r\n          style: {\r\n            position: 'relative',\r\n            contain: 'strict',\r\n            overflow: 'hidden',\r\n            backgroundColor: 'inherit',\r\n            height: clientContainerHeight,\r\n            width: clientContainerWidth\r\n          }\r\n        },\r\n        this.renderGutterContainer(),\r\n        this.renderScrollContainer()\r\n      ),\r\n      this.renderOverlayDecorations()\r\n    )\r\n  }\r", "name": "getContentWidth", "func_location": "TextEditorComponent.render", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 472, "func_start_line": 451}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getVerticalScrollbarWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2706, "start_line": 2704}, "call_info": {"func_end_line": 521, "code": "  render () {\r\n    const {model} = this.props\r\n    const style = {}\r\n\r\n    if (!model.getAutoHeight() && !model.getAutoWidth()) {\r\n      style.contain = 'size'\r\n    }\r\n\r\n    let clientContainerHeight = '100%'\r\n    let clientContainerWidth = '100%'\r\n    if (this.hasInitialMeasurements) {\r\n      if (model.getAutoHeight()) {\r\n        clientContainerHeight =\r\n          this.getContentHeight() +\r\n          this.getHorizontalScrollbarHeight() +\r\n          'px'\r\n      }\r\n      if (model.getAutoWidth()) {\r\n        style.width = 'min-content'\r\n        clientContainerWidth =\r\n          this.getGutterContainerWidth() +\r\n          this.getContentWidth() +\r\n          this.getVerticalScrollbarWidth() +\r\n          'px'\r\n      } else {\r\n        style.width = this.element.style.width\r\n      }\r\n    }\r\n\r\n    let attributes = {}\r\n    if (model.isMini()) {\r\n      attributes.mini = ''\r\n    }\r\n\r\n    if (model.isReadOnly()) {\r\n      attributes.readonly = ''\r\n    }\r\n\r\n    const dataset = {encoding: model.getEncoding()}\r\n    const grammar = model.getGrammar()\r\n    if (grammar && grammar.scopeName) {\r\n      dataset.grammar = grammar.scopeName.replace(/\\./g, ' ')\r\n    }\r\n\r\n    return $('atom-text-editor',\r\n      {\r\n        // See this.updateClassList() for construction of the class name\r\n        style,\r\n        attributes,\r\n        dataset,\r\n        tabIndex: -1,\r\n        on: {mousewheel: this.didMouseWheel}\r\n      },\r\n      $.div(\r\n        {\r\n          ref: 'clientContainer',\r\n          style: {\r\n            position: 'relative',\r\n            contain: 'strict',\r\n            overflow: 'hidden',\r\n            backgroundColor: 'inherit',\r\n            height: clientContainerHeight,\r\n            width: clientContainerWidth\r\n          }\r\n        },\r\n        this.renderGutterContainer(),\r\n        this.renderScrollContainer()\r\n      ),\r\n      this.renderOverlayDecorations()\r\n    )\r\n  }\r", "name": "getVerticalScrollbarWidth", "func_location": "TextEditorComponent.render", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 473, "func_start_line": 451}}, {"func_info": {"comment": [], "name": "TextEditorComponent.renderGutterContainer", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 548, "start_line": 523}, "call_info": {"func_end_line": 521, "code": "  render () {\r\n    const {model} = this.props\r\n    const style = {}\r\n\r\n    if (!model.getAutoHeight() && !model.getAutoWidth()) {\r\n      style.contain = 'size'\r\n    }\r\n\r\n    let clientContainerHeight = '100%'\r\n    let clientContainerWidth = '100%'\r\n    if (this.hasInitialMeasurements) {\r\n      if (model.getAutoHeight()) {\r\n        clientContainerHeight =\r\n          this.getContentHeight() +\r\n          this.getHorizontalScrollbarHeight() +\r\n          'px'\r\n      }\r\n      if (model.getAutoWidth()) {\r\n        style.width = 'min-content'\r\n        clientContainerWidth =\r\n          this.getGutterContainerWidth() +\r\n          this.getContentWidth() +\r\n          this.getVerticalScrollbarWidth() +\r\n          'px'\r\n      } else {\r\n        style.width = this.element.style.width\r\n      }\r\n    }\r\n\r\n    let attributes = {}\r\n    if (model.isMini()) {\r\n      attributes.mini = ''\r\n    }\r\n\r\n    if (model.isReadOnly()) {\r\n      attributes.readonly = ''\r\n    }\r\n\r\n    const dataset = {encoding: model.getEncoding()}\r\n    const grammar = model.getGrammar()\r\n    if (grammar && grammar.scopeName) {\r\n      dataset.grammar = grammar.scopeName.replace(/\\./g, ' ')\r\n    }\r\n\r\n    return $('atom-text-editor',\r\n      {\r\n        // See this.updateClassList() for construction of the class name\r\n        style,\r\n        attributes,\r\n        dataset,\r\n        tabIndex: -1,\r\n        on: {mousewheel: this.didMouseWheel}\r\n      },\r\n      $.div(\r\n        {\r\n          ref: 'clientContainer',\r\n          style: {\r\n            position: 'relative',\r\n            contain: 'strict',\r\n            overflow: 'hidden',\r\n            backgroundColor: 'inherit',\r\n            height: clientContainerHeight,\r\n            width: clientContainerWidth\r\n          }\r\n        },\r\n        this.renderGutterContainer(),\r\n        this.renderScrollContainer()\r\n      ),\r\n      this.renderOverlayDecorations()\r\n    )\r\n  }\r", "name": "renderGutterContainer", "func_location": "TextEditorComponent.render", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 516, "func_start_line": 451}}, {"func_info": {"comment": [], "name": "TextEditorComponent.renderScrollContainer", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 575, "start_line": 550}, "call_info": {"func_end_line": 521, "code": "  render () {\r\n    const {model} = this.props\r\n    const style = {}\r\n\r\n    if (!model.getAutoHeight() && !model.getAutoWidth()) {\r\n      style.contain = 'size'\r\n    }\r\n\r\n    let clientContainerHeight = '100%'\r\n    let clientContainerWidth = '100%'\r\n    if (this.hasInitialMeasurements) {\r\n      if (model.getAutoHeight()) {\r\n        clientContainerHeight =\r\n          this.getContentHeight() +\r\n          this.getHorizontalScrollbarHeight() +\r\n          'px'\r\n      }\r\n      if (model.getAutoWidth()) {\r\n        style.width = 'min-content'\r\n        clientContainerWidth =\r\n          this.getGutterContainerWidth() +\r\n          this.getContentWidth() +\r\n          this.getVerticalScrollbarWidth() +\r\n          'px'\r\n      } else {\r\n        style.width = this.element.style.width\r\n      }\r\n    }\r\n\r\n    let attributes = {}\r\n    if (model.isMini()) {\r\n      attributes.mini = ''\r\n    }\r\n\r\n    if (model.isReadOnly()) {\r\n      attributes.readonly = ''\r\n    }\r\n\r\n    const dataset = {encoding: model.getEncoding()}\r\n    const grammar = model.getGrammar()\r\n    if (grammar && grammar.scopeName) {\r\n      dataset.grammar = grammar.scopeName.replace(/\\./g, ' ')\r\n    }\r\n\r\n    return $('atom-text-editor',\r\n      {\r\n        // See this.updateClassList() for construction of the class name\r\n        style,\r\n        attributes,\r\n        dataset,\r\n        tabIndex: -1,\r\n        on: {mousewheel: this.didMouseWheel}\r\n      },\r\n      $.div(\r\n        {\r\n          ref: 'clientContainer',\r\n          style: {\r\n            position: 'relative',\r\n            contain: 'strict',\r\n            overflow: 'hidden',\r\n            backgroundColor: 'inherit',\r\n            height: clientContainerHeight,\r\n            width: clientContainerWidth\r\n          }\r\n        },\r\n        this.renderGutterContainer(),\r\n        this.renderScrollContainer()\r\n      ),\r\n      this.renderOverlayDecorations()\r\n    )\r\n  }\r", "name": "renderScrollContainer", "func_location": "TextEditorComponent.render", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 517, "func_start_line": 451}}, {"func_info": {"comment": [], "name": "TextEditorComponent.renderOverlayDecorations", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 825, "start_line": 811}, "call_info": {"func_end_line": 521, "code": "  render () {\r\n    const {model} = this.props\r\n    const style = {}\r\n\r\n    if (!model.getAutoHeight() && !model.getAutoWidth()) {\r\n      style.contain = 'size'\r\n    }\r\n\r\n    let clientContainerHeight = '100%'\r\n    let clientContainerWidth = '100%'\r\n    if (this.hasInitialMeasurements) {\r\n      if (model.getAutoHeight()) {\r\n        clientContainerHeight =\r\n          this.getContentHeight() +\r\n          this.getHorizontalScrollbarHeight() +\r\n          'px'\r\n      }\r\n      if (model.getAutoWidth()) {\r\n        style.width = 'min-content'\r\n        clientContainerWidth =\r\n          this.getGutterContainerWidth() +\r\n          this.getContentWidth() +\r\n          this.getVerticalScrollbarWidth() +\r\n          'px'\r\n      } else {\r\n        style.width = this.element.style.width\r\n      }\r\n    }\r\n\r\n    let attributes = {}\r\n    if (model.isMini()) {\r\n      attributes.mini = ''\r\n    }\r\n\r\n    if (model.isReadOnly()) {\r\n      attributes.readonly = ''\r\n    }\r\n\r\n    const dataset = {encoding: model.getEncoding()}\r\n    const grammar = model.getGrammar()\r\n    if (grammar && grammar.scopeName) {\r\n      dataset.grammar = grammar.scopeName.replace(/\\./g, ' ')\r\n    }\r\n\r\n    return $('atom-text-editor',\r\n      {\r\n        // See this.updateClassList() for construction of the class name\r\n        style,\r\n        attributes,\r\n        dataset,\r\n        tabIndex: -1,\r\n        on: {mousewheel: this.didMouseWheel}\r\n      },\r\n      $.div(\r\n        {\r\n          ref: 'clientContainer',\r\n          style: {\r\n            position: 'relative',\r\n            contain: 'strict',\r\n            overflow: 'hidden',\r\n            backgroundColor: 'inherit',\r\n            height: clientContainerHeight,\r\n            width: clientContainerWidth\r\n          }\r\n        },\r\n        this.renderGutterContainer(),\r\n        this.renderScrollContainer()\r\n      ),\r\n      this.renderOverlayDecorations()\r\n    )\r\n  }\r", "name": "renderOverlayDecorations", "func_location": "TextEditorComponent.render", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 519, "func_start_line": 451}}, {"func_info": {"comment": [], "name": "ceilToPhysicalPixelBoundary", "params": ["virtualPixelPosition"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4494, "start_line": 4491}, "call_info": {"func_end_line": 3307, "code": "  render () {\r\n    const {\r\n      rootComponent, showLineNumbers, height, width, startRow, endRow, rowsPerTile,\r\n      maxDigits, keys, bufferRows, screenRows, softWrappedFlags, foldableFlags, decorations,\r\n      className\r\n    } = this.props\r\n\r\n    let children = null\r\n\r\n    if (bufferRows) {\r\n      children = new Array(rootComponent.renderedTileStartRows.length)\r\n      for (let i = 0; i < rootComponent.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = rootComponent.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileChildren = new Array(tileEndRow - tileStartRow)\r\n        for (let row = tileStartRow; row < tileEndRow; row++) {\r\n          const indexInTile = row - tileStartRow\r\n          const j = row - startRow\r\n          const key = keys[j]\r\n          const softWrapped = softWrappedFlags[j]\r\n          const foldable = foldableFlags[j]\r\n          const bufferRow = bufferRows[j]\r\n          const screenRow = screenRows[j]\r\n\r\n          let className = 'line-number'\r\n          if (foldable) className = className + ' foldable'\r\n\r\n          const decorationsForRow = decorations[row - startRow]\r\n          if (decorationsForRow) className = className + ' ' + decorationsForRow\r\n\r\n          let number = null\r\n          if (showLineNumbers) {\r\n            if (this.props.labelFn == null) {\r\n              number = softWrapped ? '\u2022' : bufferRow + 1\r\n              number = NBSP_CHARACTER.repeat(maxDigits - number.length) + number\r\n            } else {\r\n              number = this.props.labelFn({bufferRow, screenRow, foldable, softWrapped, maxDigits})\r\n            }\r\n          }\r\n\r\n          // We need to adjust the line number position to account for block\r\n          // decorations preceding the current row and following the preceding\r\n          // row. Note that we ignore the latter when the line number starts at\r\n          // the beginning of the tile, because the tile will already be\r\n          // positioned to take into account block decorations added after the\r\n          // last row of the previous tile.\r\n          let marginTop = rootComponent.heightForBlockDecorationsBeforeRow(row)\r\n          if (indexInTile > 0) marginTop += rootComponent.heightForBlockDecorationsAfterRow(row - 1)\r\n\r\n          tileChildren[row - tileStartRow] = $(LineNumberComponent, {\r\n            key,\r\n            className,\r\n            width,\r\n            bufferRow,\r\n            screenRow,\r\n            number,\r\n            marginTop,\r\n            nodePool: this.nodePool\r\n          })\r\n        }\r\n\r\n        const tileTop = rootComponent.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n        const tileBottom = rootComponent.pixelPositionBeforeBlocksForRow(tileEndRow)\r\n        const tileHeight = tileBottom - tileTop\r\n        const tileWidth = width != null && width > 0 ? width + 'px' : ''\r\n\r\n        children[i] = $.div({\r\n          key: rootComponent.idsByTileStartRow.get(tileStartRow),\r\n          style: {\r\n            contain: 'layout style',\r\n            position: 'absolute',\r\n            top: 0,\r\n            height: tileHeight + 'px',\r\n            width: tileWidth,\r\n            transform: `translateY(${tileTop}px)`\r\n          }\r\n        }, ...tileChildren)\r\n      }\r\n    }\r\n\r\n    let rootClassName = 'gutter line-numbers'\r\n    if (className) {\r\n      rootClassName += ' ' + className\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        className: rootClassName,\r\n        attributes: {'gutter-name': this.props.name},\r\n        style: {position: 'relative', height: ceilToPhysicalPixelBoundary(height) + 'px'},\r\n        on: {\r\n          mousedown: this.didMouseDown,\r\n          mousemove: this.didMouseMove\r\n        }\r\n      },\r\n      $.div({key: 'placeholder', className: 'line-number dummy', style: {visibility: 'hidden'}},\r\n        showLineNumbers ? '0'.repeat(maxDigits) : null,\r\n        $.div({className: 'icon-right'})\r\n      ),\r\n      children\r\n    )\r\n  }\r", "name": "ceilToPhysicalPixelBoundary", "func_location": "LineNumberGutterComponent.render", "args": ["height"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3295, "func_start_line": 3206}}, {"func_info": {"comment": [], "name": "roundToPhysicalPixelBoundary", "params": ["virtualPixelPosition"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4489, "start_line": 4486}, "call_info": {"func_end_line": 3129, "code": "  render () {\r\n    const {hasInitialMeasurements, scrollTop, scrollHeight, guttersToRender, decorationsToRender} = this.props\r\n\r\n    const innerStyle = {\r\n      willChange: 'transform',\r\n      display: 'flex'\r\n    }\r\n\r\n    if (hasInitialMeasurements) {\r\n      innerStyle.transform = `translateY(${-roundToPhysicalPixelBoundary(scrollTop)}px)`\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'gutterContainer',\r\n        key: 'gutterContainer',\r\n        className: 'gutter-container',\r\n        style: {\r\n          position: 'relative',\r\n          zIndex: 1,\r\n          backgroundColor: 'inherit'\r\n        }\r\n      },\r\n      $.div({style: innerStyle},\r\n        guttersToRender.map((gutter) => {\r\n          if (gutter.type === 'line-number') {\r\n            return this.renderLineNumberGutter(gutter)\r\n          } else {\r\n            return $(CustomGutterComponent, {\r\n              key: gutter,\r\n              element: gutter.getElement(),\r\n              name: gutter.name,\r\n              visible: gutter.isVisible(),\r\n              height: scrollHeight,\r\n              decorations: decorationsToRender.customGutter.get(gutter.name)\r\n            })\r\n          }\r\n        })\r\n      )\r\n    )\r\n  }\r", "name": "roundToPhysicalPixelBoundary", "func_location": "GutterContainerComponent.render", "args": ["scrollTop"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3098, "func_start_line": 3089}}, {"func_info": {"comment": [], "name": "CustomGutterComponent.renderDecorations", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 3500, "start_line": 3489}, "call_info": {"func_end_line": 3487, "code": "  render () {\r\n    let className = 'gutter'\r\n    if (this.props.className) {\r\n      className += ' ' + this.props.className\r\n    }\r\n    return $.div(\r\n      {\r\n        className,\r\n        attributes: {'gutter-name': this.props.name},\r\n        style: {\r\n          display: this.props.visible ? '' : 'none'\r\n        }\r\n      },\r\n      $.div(\r\n        {\r\n          className: 'custom-decorations',\r\n          style: {height: this.props.height + 'px'}\r\n        },\r\n        this.renderDecorations()\r\n      )\r\n    )\r\n  }\r", "name": "renderDecorations", "func_location": "CustomGutterComponent.render", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3484, "func_start_line": 3466}}, {"func_info": {"comment": [], "name": "CursorsAndInputComponent.getCursorsClassName", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 3602, "start_line": 3600}, "call_info": {"func_end_line": 3598, "code": "  render () {\r\n    const {lineHeight, decorationsToRender, scrollHeight, scrollWidth} = this.props\r\n\r\n    const className = this.getCursorsClassName()\r\n    const cursorHeight = lineHeight + 'px'\r\n\r\n    const children = [this.renderHiddenInput()]\r\n    for (let i = 0; i < decorationsToRender.cursors.length; i++) {\r\n      const {pixelLeft, pixelTop, pixelWidth, className: extraCursorClassName, style: extraCursorStyle} = decorationsToRender.cursors[i]\r\n      let cursorClassName = 'cursor'\r\n      if (extraCursorClassName) cursorClassName += ' ' + extraCursorClassName\r\n\r\n      const cursorStyle = {\r\n        height: cursorHeight,\r\n        width: Math.min(pixelWidth, scrollWidth - pixelLeft) + 'px',\r\n        transform: `translate(${pixelLeft}px, ${pixelTop}px)`\r\n      }\r\n      if (extraCursorStyle) Object.assign(cursorStyle, extraCursorStyle)\r\n\r\n      children.push($.div({\r\n        className: cursorClassName,\r\n        style: cursorStyle\r\n      }))\r\n    }\r\n\r\n    return $.div({\r\n      key: 'cursors',\r\n      ref: 'cursors',\r\n      className,\r\n      style: {\r\n        position: 'absolute',\r\n        contain: 'strict',\r\n        zIndex: 1,\r\n        width: scrollWidth + 'px',\r\n        height: scrollHeight + 'px',\r\n        pointerEvents: 'none',\r\n        userSelect: 'none'\r\n      }\r\n    }, children)\r\n  }\r", "name": "getCursorsClassName", "func_location": "CursorsAndInputComponent.render", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3562, "func_start_line": 3559}}, {"func_info": {"comment": [], "name": "CursorsAndInputComponent.renderHiddenInput", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 3648, "start_line": 3604}, "call_info": {"func_end_line": 3598, "code": "  render () {\r\n    const {lineHeight, decorationsToRender, scrollHeight, scrollWidth} = this.props\r\n\r\n    const className = this.getCursorsClassName()\r\n    const cursorHeight = lineHeight + 'px'\r\n\r\n    const children = [this.renderHiddenInput()]\r\n    for (let i = 0; i < decorationsToRender.cursors.length; i++) {\r\n      const {pixelLeft, pixelTop, pixelWidth, className: extraCursorClassName, style: extraCursorStyle} = decorationsToRender.cursors[i]\r\n      let cursorClassName = 'cursor'\r\n      if (extraCursorClassName) cursorClassName += ' ' + extraCursorClassName\r\n\r\n      const cursorStyle = {\r\n        height: cursorHeight,\r\n        width: Math.min(pixelWidth, scrollWidth - pixelLeft) + 'px',\r\n        transform: `translate(${pixelLeft}px, ${pixelTop}px)`\r\n      }\r\n      if (extraCursorStyle) Object.assign(cursorStyle, extraCursorStyle)\r\n\r\n      children.push($.div({\r\n        className: cursorClassName,\r\n        style: cursorStyle\r\n      }))\r\n    }\r\n\r\n    return $.div({\r\n      key: 'cursors',\r\n      ref: 'cursors',\r\n      className,\r\n      style: {\r\n        position: 'absolute',\r\n        contain: 'strict',\r\n        zIndex: 1,\r\n        width: scrollWidth + 'px',\r\n        height: scrollHeight + 'px',\r\n        pointerEvents: 'none',\r\n        userSelect: 'none'\r\n      }\r\n    }, children)\r\n  }\r", "name": "renderHiddenInput", "func_location": "CursorsAndInputComponent.render", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3565, "func_start_line": 3559}}, {"func_info": {"comment": [], "name": "getIconName", "params": ["location", "visible"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 846, "start_line": 839}, "call_info": {"func_end_line": 789, "name": "getIconName", "func_location": "DockToggleButton.render", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 782, "func_start_line": 765}}, {"func_info": {"comment": [], "name": "getPreferredSize", "params": ["item", "location"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 837, "start_line": 825}, "call_info": {"func_end_line": 244, "code": "  render () {\r\n    const innerElementClassList = ['atom-dock-inner', this.location]\r\n    if (this.state.visible) innerElementClassList.push(VISIBLE_CLASS)\r\n\r\n    const maskElementClassList = ['atom-dock-mask']\r\n    if (this.state.shouldAnimate) maskElementClassList.push(SHOULD_ANIMATE_CLASS)\r\n\r\n    const cursorOverlayElementClassList = ['atom-dock-cursor-overlay', this.location]\r\n    if (this.state.resizing) cursorOverlayElementClassList.push(CURSOR_OVERLAY_VISIBLE_CLASS)\r\n\r\n    const shouldBeVisible = this.state.visible || this.state.showDropTarget\r\n    const size = Math.max(MINIMUM_SIZE,\r\n      this.state.size ||\r\n      (this.state.draggingItem && getPreferredSize(this.state.draggingItem, this.location)) ||\r\n      DEFAULT_INITIAL_SIZE\r\n    )\r\n\r\n    // We need to change the size of the mask...\r\n    const maskStyle = {[this.widthOrHeight]: `${shouldBeVisible ? size : 0}px`}\r\n    // ...but the content needs to maintain a constant size.\r\n    const wrapperStyle = {[this.widthOrHeight]: `${size}px`}\r\n\r\n    return $(\r\n      'atom-dock',\r\n      {className: this.location},\r\n      $.div(\r\n        {ref: 'innerElement', className: innerElementClassList.join(' ')},\r\n        $.div(\r\n          {\r\n            className: maskElementClassList.join(' '),\r\n            style: maskStyle\r\n          },\r\n          $.div(\r\n            {\r\n              ref: 'wrapperElement',\r\n              className: `atom-dock-content-wrapper ${this.location}`,\r\n              style: wrapperStyle\r\n            },\r\n            $(DockResizeHandle, {\r\n              location: this.location,\r\n              onResizeStart: this.handleResizeHandleDragStart,\r\n              onResizeToFit: this.handleResizeToFit,\r\n              dockIsVisible: this.state.visible\r\n            }),\r\n            $(ElementComponent, {element: this.paneContainer.getElement()}),\r\n            $.div({className: cursorOverlayElementClassList.join(' ')})\r\n          )\r\n        ),\r\n        $(DockToggleButton, {\r\n          ref: 'toggleButton',\r\n          onDragEnter: this.state.draggingItem ? this.handleToggleButtonDragEnter : null,\r\n          location: this.location,\r\n          toggle: this.toggle,\r\n          dockIsVisible: shouldBeVisible,\r\n          visible:\r\n            // Don't show the toggle button if the dock is closed and empty...\r\n            (this.state.hovered &&\r\n              (this.state.visible || this.getPaneItems().length > 0)) ||\r\n            // ...or if the item can't be dropped in that dock.\r\n            (!shouldBeVisible &&\r\n              this.state.draggingItem &&\r\n              isItemAllowed(this.state.draggingItem, this.location))\r\n        })\r\n      )\r\n    )\r\n  }\r", "name": "getPreferredSize", "func_location": "Dock.render", "args": [".state.draggingItem", ".location"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 192, "func_start_line": 179}}, {"func_info": {"comment": ["\r\n  Section: Pane Items\r\n  ", " Essential: Get all pane items in the dock.", "", " Returns an {Array} of items."], "name": "Dock.getPaneItems", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 644, "start_line": 642}, "call_info": {"func_end_line": 244, "code": "  render () {\r\n    const innerElementClassList = ['atom-dock-inner', this.location]\r\n    if (this.state.visible) innerElementClassList.push(VISIBLE_CLASS)\r\n\r\n    const maskElementClassList = ['atom-dock-mask']\r\n    if (this.state.shouldAnimate) maskElementClassList.push(SHOULD_ANIMATE_CLASS)\r\n\r\n    const cursorOverlayElementClassList = ['atom-dock-cursor-overlay', this.location]\r\n    if (this.state.resizing) cursorOverlayElementClassList.push(CURSOR_OVERLAY_VISIBLE_CLASS)\r\n\r\n    const shouldBeVisible = this.state.visible || this.state.showDropTarget\r\n    const size = Math.max(MINIMUM_SIZE,\r\n      this.state.size ||\r\n      (this.state.draggingItem && getPreferredSize(this.state.draggingItem, this.location)) ||\r\n      DEFAULT_INITIAL_SIZE\r\n    )\r\n\r\n    // We need to change the size of the mask...\r\n    const maskStyle = {[this.widthOrHeight]: `${shouldBeVisible ? size : 0}px`}\r\n    // ...but the content needs to maintain a constant size.\r\n    const wrapperStyle = {[this.widthOrHeight]: `${size}px`}\r\n\r\n    return $(\r\n      'atom-dock',\r\n      {className: this.location},\r\n      $.div(\r\n        {ref: 'innerElement', className: innerElementClassList.join(' ')},\r\n        $.div(\r\n          {\r\n            className: maskElementClassList.join(' '),\r\n            style: maskStyle\r\n          },\r\n          $.div(\r\n            {\r\n              ref: 'wrapperElement',\r\n              className: `atom-dock-content-wrapper ${this.location}`,\r\n              style: wrapperStyle\r\n            },\r\n            $(DockResizeHandle, {\r\n              location: this.location,\r\n              onResizeStart: this.handleResizeHandleDragStart,\r\n              onResizeToFit: this.handleResizeToFit,\r\n              dockIsVisible: this.state.visible\r\n            }),\r\n            $(ElementComponent, {element: this.paneContainer.getElement()}),\r\n            $.div({className: cursorOverlayElementClassList.join(' ')})\r\n          )\r\n        ),\r\n        $(DockToggleButton, {\r\n          ref: 'toggleButton',\r\n          onDragEnter: this.state.draggingItem ? this.handleToggleButtonDragEnter : null,\r\n          location: this.location,\r\n          toggle: this.toggle,\r\n          dockIsVisible: shouldBeVisible,\r\n          visible:\r\n            // Don't show the toggle button if the dock is closed and empty...\r\n            (this.state.hovered &&\r\n              (this.state.visible || this.getPaneItems().length > 0)) ||\r\n            // ...or if the item can't be dropped in that dock.\r\n            (!shouldBeVisible &&\r\n              this.state.draggingItem &&\r\n              isItemAllowed(this.state.draggingItem, this.location))\r\n        })\r\n      )\r\n    )\r\n  }\r", "name": "getPaneItems", "func_location": "Dock.render", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 236, "func_start_line": 179}}, {"func_info": {"comment": [" Is the item allowed in the given location?"], "name": "isItemAllowed", "params": ["item", "location"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 861, "start_line": 858}, "call_info": {"func_end_line": 244, "code": "  render () {\r\n    const innerElementClassList = ['atom-dock-inner', this.location]\r\n    if (this.state.visible) innerElementClassList.push(VISIBLE_CLASS)\r\n\r\n    const maskElementClassList = ['atom-dock-mask']\r\n    if (this.state.shouldAnimate) maskElementClassList.push(SHOULD_ANIMATE_CLASS)\r\n\r\n    const cursorOverlayElementClassList = ['atom-dock-cursor-overlay', this.location]\r\n    if (this.state.resizing) cursorOverlayElementClassList.push(CURSOR_OVERLAY_VISIBLE_CLASS)\r\n\r\n    const shouldBeVisible = this.state.visible || this.state.showDropTarget\r\n    const size = Math.max(MINIMUM_SIZE,\r\n      this.state.size ||\r\n      (this.state.draggingItem && getPreferredSize(this.state.draggingItem, this.location)) ||\r\n      DEFAULT_INITIAL_SIZE\r\n    )\r\n\r\n    // We need to change the size of the mask...\r\n    const maskStyle = {[this.widthOrHeight]: `${shouldBeVisible ? size : 0}px`}\r\n    // ...but the content needs to maintain a constant size.\r\n    const wrapperStyle = {[this.widthOrHeight]: `${size}px`}\r\n\r\n    return $(\r\n      'atom-dock',\r\n      {className: this.location},\r\n      $.div(\r\n        {ref: 'innerElement', className: innerElementClassList.join(' ')},\r\n        $.div(\r\n          {\r\n            className: maskElementClassList.join(' '),\r\n            style: maskStyle\r\n          },\r\n          $.div(\r\n            {\r\n              ref: 'wrapperElement',\r\n              className: `atom-dock-content-wrapper ${this.location}`,\r\n              style: wrapperStyle\r\n            },\r\n            $(DockResizeHandle, {\r\n              location: this.location,\r\n              onResizeStart: this.handleResizeHandleDragStart,\r\n              onResizeToFit: this.handleResizeToFit,\r\n              dockIsVisible: this.state.visible\r\n            }),\r\n            $(ElementComponent, {element: this.paneContainer.getElement()}),\r\n            $.div({className: cursorOverlayElementClassList.join(' ')})\r\n          )\r\n        ),\r\n        $(DockToggleButton, {\r\n          ref: 'toggleButton',\r\n          onDragEnter: this.state.draggingItem ? this.handleToggleButtonDragEnter : null,\r\n          location: this.location,\r\n          toggle: this.toggle,\r\n          dockIsVisible: shouldBeVisible,\r\n          visible:\r\n            // Don't show the toggle button if the dock is closed and empty...\r\n            (this.state.hovered &&\r\n              (this.state.visible || this.getPaneItems().length > 0)) ||\r\n            // ...or if the item can't be dropped in that dock.\r\n            (!shouldBeVisible &&\r\n              this.state.draggingItem &&\r\n              isItemAllowed(this.state.draggingItem, this.location))\r\n        })\r\n      )\r\n    )\r\n  }\r", "name": "isItemAllowed", "func_location": "Dock.render", "args": [".state.draggingItem", ".location"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 240, "func_start_line": 179}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2682, "start_line": 2672}, "call_info": {"func_end_line": 744, "code": "  renderBlockDecorationMeasurementArea () {\r\n    return $.div({\r\n      ref: 'blockDecorationMeasurementArea',\r\n      key: 'blockDecorationMeasurementArea',\r\n      style: {\r\n        contain: 'strict',\r\n        position: 'absolute',\r\n        visibility: 'hidden',\r\n        width: this.getScrollWidth() + 'px'\r\n      }\r\n    })\r\n  }\r", "name": "getScrollWidth", "func_location": "TextEditorComponent.renderBlockDecorationMeasurementArea", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 741, "func_start_line": 733}}, {"func_info": {"comment": [], "name": "ceilToPhysicalPixelBoundary", "params": ["virtualPixelPosition"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4494, "start_line": 4491}, "call_info": {"func_end_line": 600, "code": "  renderContent () {\r\n    let style = {\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      backgroundColor: 'inherit'\r\n    }\r\n    if (this.hasInitialMeasurements) {\r\n      style.width = ceilToPhysicalPixelBoundary(this.getScrollWidth()) + 'px'\r\n      style.height = ceilToPhysicalPixelBoundary(this.getScrollHeight()) + 'px'\r\n      style.willChange = 'transform'\r\n      style.transform = `translate(${-roundToPhysicalPixelBoundary(this.getScrollLeft())}px, ${-roundToPhysicalPixelBoundary(this.getScrollTop())}px)`\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'content',\r\n        on: {mousedown: this.didMouseDownOnContent},\r\n        style\r\n      },\r\n      this.renderLineTiles(),\r\n      this.renderBlockDecorationMeasurementArea(),\r\n      this.renderCharacterMeasurementLine()\r\n    )\r\n  }\r", "name": "ceilToPhysicalPixelBoundary", "func_location": "TextEditorComponent.renderContent", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 584, "func_start_line": 577}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2682, "start_line": 2672}, "call_info": {"func_end_line": 600, "code": "  renderContent () {\r\n    let style = {\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      backgroundColor: 'inherit'\r\n    }\r\n    if (this.hasInitialMeasurements) {\r\n      style.width = ceilToPhysicalPixelBoundary(this.getScrollWidth()) + 'px'\r\n      style.height = ceilToPhysicalPixelBoundary(this.getScrollHeight()) + 'px'\r\n      style.willChange = 'transform'\r\n      style.transform = `translate(${-roundToPhysicalPixelBoundary(this.getScrollLeft())}px, ${-roundToPhysicalPixelBoundary(this.getScrollTop())}px)`\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'content',\r\n        on: {mousedown: this.didMouseDownOnContent},\r\n        style\r\n      },\r\n      this.renderLineTiles(),\r\n      this.renderBlockDecorationMeasurementArea(),\r\n      this.renderCharacterMeasurementLine()\r\n    )\r\n  }\r", "name": "getScrollWidth", "func_location": "TextEditorComponent.renderContent", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 584, "func_start_line": 577}}, {"func_info": {"comment": [], "name": "ceilToPhysicalPixelBoundary", "params": ["virtualPixelPosition"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4494, "start_line": 4491}, "call_info": {"func_end_line": 600, "code": "  renderContent () {\r\n    let style = {\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      backgroundColor: 'inherit'\r\n    }\r\n    if (this.hasInitialMeasurements) {\r\n      style.width = ceilToPhysicalPixelBoundary(this.getScrollWidth()) + 'px'\r\n      style.height = ceilToPhysicalPixelBoundary(this.getScrollHeight()) + 'px'\r\n      style.willChange = 'transform'\r\n      style.transform = `translate(${-roundToPhysicalPixelBoundary(this.getScrollLeft())}px, ${-roundToPhysicalPixelBoundary(this.getScrollTop())}px)`\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'content',\r\n        on: {mousedown: this.didMouseDownOnContent},\r\n        style\r\n      },\r\n      this.renderLineTiles(),\r\n      this.renderBlockDecorationMeasurementArea(),\r\n      this.renderCharacterMeasurementLine()\r\n    )\r\n  }\r", "name": "ceilToPhysicalPixelBoundary", "func_location": "TextEditorComponent.renderContent", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 585, "func_start_line": 577}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2670, "start_line": 2659}, "call_info": {"func_end_line": 600, "code": "  renderContent () {\r\n    let style = {\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      backgroundColor: 'inherit'\r\n    }\r\n    if (this.hasInitialMeasurements) {\r\n      style.width = ceilToPhysicalPixelBoundary(this.getScrollWidth()) + 'px'\r\n      style.height = ceilToPhysicalPixelBoundary(this.getScrollHeight()) + 'px'\r\n      style.willChange = 'transform'\r\n      style.transform = `translate(${-roundToPhysicalPixelBoundary(this.getScrollLeft())}px, ${-roundToPhysicalPixelBoundary(this.getScrollTop())}px)`\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'content',\r\n        on: {mousedown: this.didMouseDownOnContent},\r\n        style\r\n      },\r\n      this.renderLineTiles(),\r\n      this.renderBlockDecorationMeasurementArea(),\r\n      this.renderCharacterMeasurementLine()\r\n    )\r\n  }\r", "name": "getScrollHeight", "func_location": "TextEditorComponent.renderContent", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 585, "func_start_line": 577}}, {"func_info": {"comment": [], "name": "roundToPhysicalPixelBoundary", "params": ["virtualPixelPosition"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4489, "start_line": 4486}, "call_info": {"func_end_line": 600, "code": "  renderContent () {\r\n    let style = {\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      backgroundColor: 'inherit'\r\n    }\r\n    if (this.hasInitialMeasurements) {\r\n      style.width = ceilToPhysicalPixelBoundary(this.getScrollWidth()) + 'px'\r\n      style.height = ceilToPhysicalPixelBoundary(this.getScrollHeight()) + 'px'\r\n      style.willChange = 'transform'\r\n      style.transform = `translate(${-roundToPhysicalPixelBoundary(this.getScrollLeft())}px, ${-roundToPhysicalPixelBoundary(this.getScrollTop())}px)`\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'content',\r\n        on: {mousedown: this.didMouseDownOnContent},\r\n        style\r\n      },\r\n      this.renderLineTiles(),\r\n      this.renderBlockDecorationMeasurementArea(),\r\n      this.renderCharacterMeasurementLine()\r\n    )\r\n  }\r", "name": "roundToPhysicalPixelBoundary", "func_location": "TextEditorComponent.renderContent", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 587, "func_start_line": 577}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollLeft", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2825, "start_line": 2823}, "call_info": {"func_end_line": 600, "code": "  renderContent () {\r\n    let style = {\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      backgroundColor: 'inherit'\r\n    }\r\n    if (this.hasInitialMeasurements) {\r\n      style.width = ceilToPhysicalPixelBoundary(this.getScrollWidth()) + 'px'\r\n      style.height = ceilToPhysicalPixelBoundary(this.getScrollHeight()) + 'px'\r\n      style.willChange = 'transform'\r\n      style.transform = `translate(${-roundToPhysicalPixelBoundary(this.getScrollLeft())}px, ${-roundToPhysicalPixelBoundary(this.getScrollTop())}px)`\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'content',\r\n        on: {mousedown: this.didMouseDownOnContent},\r\n        style\r\n      },\r\n      this.renderLineTiles(),\r\n      this.renderBlockDecorationMeasurementArea(),\r\n      this.renderCharacterMeasurementLine()\r\n    )\r\n  }\r", "name": "getScrollLeft", "func_location": "TextEditorComponent.renderContent", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 587, "func_start_line": 577}}, {"func_info": {"comment": [], "name": "roundToPhysicalPixelBoundary", "params": ["virtualPixelPosition"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4489, "start_line": 4486}, "call_info": {"func_end_line": 600, "code": "  renderContent () {\r\n    let style = {\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      backgroundColor: 'inherit'\r\n    }\r\n    if (this.hasInitialMeasurements) {\r\n      style.width = ceilToPhysicalPixelBoundary(this.getScrollWidth()) + 'px'\r\n      style.height = ceilToPhysicalPixelBoundary(this.getScrollHeight()) + 'px'\r\n      style.willChange = 'transform'\r\n      style.transform = `translate(${-roundToPhysicalPixelBoundary(this.getScrollLeft())}px, ${-roundToPhysicalPixelBoundary(this.getScrollTop())}px)`\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'content',\r\n        on: {mousedown: this.didMouseDownOnContent},\r\n        style\r\n      },\r\n      this.renderLineTiles(),\r\n      this.renderBlockDecorationMeasurementArea(),\r\n      this.renderCharacterMeasurementLine()\r\n    )\r\n  }\r", "name": "roundToPhysicalPixelBoundary", "func_location": "TextEditorComponent.renderContent", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 587, "func_start_line": 577}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollTop", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2794, "start_line": 2791}, "call_info": {"func_end_line": 600, "code": "  renderContent () {\r\n    let style = {\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      backgroundColor: 'inherit'\r\n    }\r\n    if (this.hasInitialMeasurements) {\r\n      style.width = ceilToPhysicalPixelBoundary(this.getScrollWidth()) + 'px'\r\n      style.height = ceilToPhysicalPixelBoundary(this.getScrollHeight()) + 'px'\r\n      style.willChange = 'transform'\r\n      style.transform = `translate(${-roundToPhysicalPixelBoundary(this.getScrollLeft())}px, ${-roundToPhysicalPixelBoundary(this.getScrollTop())}px)`\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'content',\r\n        on: {mousedown: this.didMouseDownOnContent},\r\n        style\r\n      },\r\n      this.renderLineTiles(),\r\n      this.renderBlockDecorationMeasurementArea(),\r\n      this.renderCharacterMeasurementLine()\r\n    )\r\n  }\r", "name": "getScrollTop", "func_location": "TextEditorComponent.renderContent", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 587, "func_start_line": 577}}, {"func_info": {"comment": [], "name": "TextEditorComponent.renderLineTiles", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 680, "start_line": 612}, "call_info": {"func_end_line": 600, "code": "  renderContent () {\r\n    let style = {\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      backgroundColor: 'inherit'\r\n    }\r\n    if (this.hasInitialMeasurements) {\r\n      style.width = ceilToPhysicalPixelBoundary(this.getScrollWidth()) + 'px'\r\n      style.height = ceilToPhysicalPixelBoundary(this.getScrollHeight()) + 'px'\r\n      style.willChange = 'transform'\r\n      style.transform = `translate(${-roundToPhysicalPixelBoundary(this.getScrollLeft())}px, ${-roundToPhysicalPixelBoundary(this.getScrollTop())}px)`\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'content',\r\n        on: {mousedown: this.didMouseDownOnContent},\r\n        style\r\n      },\r\n      this.renderLineTiles(),\r\n      this.renderBlockDecorationMeasurementArea(),\r\n      this.renderCharacterMeasurementLine()\r\n    )\r\n  }\r", "name": "renderLineTiles", "func_location": "TextEditorComponent.renderContent", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 596, "func_start_line": 577}}, {"func_info": {"comment": [], "name": "TextEditorComponent.renderBlockDecorationMeasurementArea", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 744, "start_line": 733}, "call_info": {"func_end_line": 600, "code": "  renderContent () {\r\n    let style = {\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      backgroundColor: 'inherit'\r\n    }\r\n    if (this.hasInitialMeasurements) {\r\n      style.width = ceilToPhysicalPixelBoundary(this.getScrollWidth()) + 'px'\r\n      style.height = ceilToPhysicalPixelBoundary(this.getScrollHeight()) + 'px'\r\n      style.willChange = 'transform'\r\n      style.transform = `translate(${-roundToPhysicalPixelBoundary(this.getScrollLeft())}px, ${-roundToPhysicalPixelBoundary(this.getScrollTop())}px)`\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'content',\r\n        on: {mousedown: this.didMouseDownOnContent},\r\n        style\r\n      },\r\n      this.renderLineTiles(),\r\n      this.renderBlockDecorationMeasurementArea(),\r\n      this.renderCharacterMeasurementLine()\r\n    )\r\n  }\r", "name": "renderBlockDecorationMeasurementArea", "func_location": "TextEditorComponent.renderContent", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 597, "func_start_line": 577}}, {"func_info": {"comment": [], "name": "TextEditorComponent.renderCharacterMeasurementLine", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 731, "start_line": 718}, "call_info": {"func_end_line": 600, "code": "  renderContent () {\r\n    let style = {\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      backgroundColor: 'inherit'\r\n    }\r\n    if (this.hasInitialMeasurements) {\r\n      style.width = ceilToPhysicalPixelBoundary(this.getScrollWidth()) + 'px'\r\n      style.height = ceilToPhysicalPixelBoundary(this.getScrollHeight()) + 'px'\r\n      style.willChange = 'transform'\r\n      style.transform = `translate(${-roundToPhysicalPixelBoundary(this.getScrollLeft())}px, ${-roundToPhysicalPixelBoundary(this.getScrollTop())}px)`\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'content',\r\n        on: {mousedown: this.didMouseDownOnContent},\r\n        style\r\n      },\r\n      this.renderLineTiles(),\r\n      this.renderBlockDecorationMeasurementArea(),\r\n      this.renderCharacterMeasurementLine()\r\n    )\r\n  }\r", "name": "renderCharacterMeasurementLine", "func_location": "TextEditorComponent.renderContent", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 598, "func_start_line": 577}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getLineHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2602, "start_line": 2600}, "call_info": {"func_end_line": 705, "code": "  renderCursorsAndInput () {\r\n    return $(CursorsAndInputComponent, {\r\n      ref: 'cursorsAndInput',\r\n      key: 'cursorsAndInput',\r\n      didBlurHiddenInput: this.didBlurHiddenInput,\r\n      didFocusHiddenInput: this.didFocusHiddenInput,\r\n      didTextInput: this.didTextInput,\r\n      didPaste: this.didPaste,\r\n      didKeydown: this.didKeydown,\r\n      didKeyup: this.didKeyup,\r\n      didKeypress: this.didKeypress,\r\n      didCompositionStart: this.didCompositionStart,\r\n      didCompositionUpdate: this.didCompositionUpdate,\r\n      didCompositionEnd: this.didCompositionEnd,\r\n      measuredContent: this.measuredContent,\r\n      lineHeight: this.getLineHeight(),\r\n      scrollHeight: this.getScrollHeight(),\r\n      scrollWidth: this.getScrollWidth(),\r\n      decorationsToRender: this.decorationsToRender,\r\n      cursorsBlinkedOff: this.cursorsBlinkedOff,\r\n      hiddenInputPosition: this.hiddenInputPosition,\r\n      tabIndex: this.tabIndex\r\n    })\r\n  }\r", "name": "getLineHeight", "func_location": "TextEditorComponent.renderCursorsAndInput", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 697, "func_start_line": 682}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2670, "start_line": 2659}, "call_info": {"func_end_line": 705, "code": "  renderCursorsAndInput () {\r\n    return $(CursorsAndInputComponent, {\r\n      ref: 'cursorsAndInput',\r\n      key: 'cursorsAndInput',\r\n      didBlurHiddenInput: this.didBlurHiddenInput,\r\n      didFocusHiddenInput: this.didFocusHiddenInput,\r\n      didTextInput: this.didTextInput,\r\n      didPaste: this.didPaste,\r\n      didKeydown: this.didKeydown,\r\n      didKeyup: this.didKeyup,\r\n      didKeypress: this.didKeypress,\r\n      didCompositionStart: this.didCompositionStart,\r\n      didCompositionUpdate: this.didCompositionUpdate,\r\n      didCompositionEnd: this.didCompositionEnd,\r\n      measuredContent: this.measuredContent,\r\n      lineHeight: this.getLineHeight(),\r\n      scrollHeight: this.getScrollHeight(),\r\n      scrollWidth: this.getScrollWidth(),\r\n      decorationsToRender: this.decorationsToRender,\r\n      cursorsBlinkedOff: this.cursorsBlinkedOff,\r\n      hiddenInputPosition: this.hiddenInputPosition,\r\n      tabIndex: this.tabIndex\r\n    })\r\n  }\r", "name": "getScrollHeight", "func_location": "TextEditorComponent.renderCursorsAndInput", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 698, "func_start_line": 682}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2682, "start_line": 2672}, "call_info": {"func_end_line": 705, "code": "  renderCursorsAndInput () {\r\n    return $(CursorsAndInputComponent, {\r\n      ref: 'cursorsAndInput',\r\n      key: 'cursorsAndInput',\r\n      didBlurHiddenInput: this.didBlurHiddenInput,\r\n      didFocusHiddenInput: this.didFocusHiddenInput,\r\n      didTextInput: this.didTextInput,\r\n      didPaste: this.didPaste,\r\n      didKeydown: this.didKeydown,\r\n      didKeyup: this.didKeyup,\r\n      didKeypress: this.didKeypress,\r\n      didCompositionStart: this.didCompositionStart,\r\n      didCompositionUpdate: this.didCompositionUpdate,\r\n      didCompositionEnd: this.didCompositionEnd,\r\n      measuredContent: this.measuredContent,\r\n      lineHeight: this.getLineHeight(),\r\n      scrollHeight: this.getScrollHeight(),\r\n      scrollWidth: this.getScrollWidth(),\r\n      decorationsToRender: this.decorationsToRender,\r\n      cursorsBlinkedOff: this.cursorsBlinkedOff,\r\n      hiddenInputPosition: this.hiddenInputPosition,\r\n      tabIndex: this.tabIndex\r\n    })\r\n  }\r", "name": "getScrollWidth", "func_location": "TextEditorComponent.renderCursorsAndInput", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 699, "func_start_line": 682}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2670, "start_line": 2659}, "call_info": {"func_end_line": 809, "code": "  renderDummyScrollbars () {\r\n    if (this.shouldRenderDummyScrollbars && !this.props.model.isMini()) {\r\n      let scrollHeight, scrollTop, horizontalScrollbarHeight\r\n      let scrollWidth, scrollLeft, verticalScrollbarWidth, forceScrollbarVisible\r\n      let canScrollHorizontally, canScrollVertically\r\n\r\n      if (this.hasInitialMeasurements) {\r\n        scrollHeight = this.getScrollHeight()\r\n        scrollWidth = this.getScrollWidth()\r\n        scrollTop = this.getScrollTop()\r\n        scrollLeft = this.getScrollLeft()\r\n        canScrollHorizontally = this.canScrollHorizontally()\r\n        canScrollVertically = this.canScrollVertically()\r\n        horizontalScrollbarHeight = this.getHorizontalScrollbarHeight()\r\n        verticalScrollbarWidth = this.getVerticalScrollbarWidth()\r\n        forceScrollbarVisible = this.remeasureScrollbars\r\n      } else {\r\n        forceScrollbarVisible = true\r\n      }\r\n\r\n      return [\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'verticalScrollbar',\r\n          orientation: 'vertical',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollVertically,\r\n          scrollHeight,\r\n          scrollTop,\r\n          horizontalScrollbarHeight,\r\n          forceScrollbarVisible\r\n        }),\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'horizontalScrollbar',\r\n          orientation: 'horizontal',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollHorizontally,\r\n          scrollWidth,\r\n          scrollLeft,\r\n          verticalScrollbarWidth,\r\n          forceScrollbarVisible\r\n        }),\r\n\r\n        // Force a \"corner\" to render where the two scrollbars meet at the lower right\r\n        $.div(\r\n          {\r\n            ref: 'scrollbarCorner',\r\n            className: 'scrollbar-corner',\r\n            style: {\r\n              position: 'absolute',\r\n              height: '20px',\r\n              width: '20px',\r\n              bottom: 0,\r\n              right: 0,\r\n              overflow: 'scroll'\r\n            }\r\n          }\r\n        )\r\n      ]\r\n    } else {\r\n      return null\r\n    }\r\n  }\r", "name": "getScrollHeight", "func_location": "TextEditorComponent.renderDummyScrollbars", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 753, "func_start_line": 746}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2682, "start_line": 2672}, "call_info": {"func_end_line": 809, "code": "  renderDummyScrollbars () {\r\n    if (this.shouldRenderDummyScrollbars && !this.props.model.isMini()) {\r\n      let scrollHeight, scrollTop, horizontalScrollbarHeight\r\n      let scrollWidth, scrollLeft, verticalScrollbarWidth, forceScrollbarVisible\r\n      let canScrollHorizontally, canScrollVertically\r\n\r\n      if (this.hasInitialMeasurements) {\r\n        scrollHeight = this.getScrollHeight()\r\n        scrollWidth = this.getScrollWidth()\r\n        scrollTop = this.getScrollTop()\r\n        scrollLeft = this.getScrollLeft()\r\n        canScrollHorizontally = this.canScrollHorizontally()\r\n        canScrollVertically = this.canScrollVertically()\r\n        horizontalScrollbarHeight = this.getHorizontalScrollbarHeight()\r\n        verticalScrollbarWidth = this.getVerticalScrollbarWidth()\r\n        forceScrollbarVisible = this.remeasureScrollbars\r\n      } else {\r\n        forceScrollbarVisible = true\r\n      }\r\n\r\n      return [\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'verticalScrollbar',\r\n          orientation: 'vertical',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollVertically,\r\n          scrollHeight,\r\n          scrollTop,\r\n          horizontalScrollbarHeight,\r\n          forceScrollbarVisible\r\n        }),\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'horizontalScrollbar',\r\n          orientation: 'horizontal',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollHorizontally,\r\n          scrollWidth,\r\n          scrollLeft,\r\n          verticalScrollbarWidth,\r\n          forceScrollbarVisible\r\n        }),\r\n\r\n        // Force a \"corner\" to render where the two scrollbars meet at the lower right\r\n        $.div(\r\n          {\r\n            ref: 'scrollbarCorner',\r\n            className: 'scrollbar-corner',\r\n            style: {\r\n              position: 'absolute',\r\n              height: '20px',\r\n              width: '20px',\r\n              bottom: 0,\r\n              right: 0,\r\n              overflow: 'scroll'\r\n            }\r\n          }\r\n        )\r\n      ]\r\n    } else {\r\n      return null\r\n    }\r\n  }\r", "name": "getScrollWidth", "func_location": "TextEditorComponent.renderDummyScrollbars", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 754, "func_start_line": 746}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollTop", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2794, "start_line": 2791}, "call_info": {"func_end_line": 809, "code": "  renderDummyScrollbars () {\r\n    if (this.shouldRenderDummyScrollbars && !this.props.model.isMini()) {\r\n      let scrollHeight, scrollTop, horizontalScrollbarHeight\r\n      let scrollWidth, scrollLeft, verticalScrollbarWidth, forceScrollbarVisible\r\n      let canScrollHorizontally, canScrollVertically\r\n\r\n      if (this.hasInitialMeasurements) {\r\n        scrollHeight = this.getScrollHeight()\r\n        scrollWidth = this.getScrollWidth()\r\n        scrollTop = this.getScrollTop()\r\n        scrollLeft = this.getScrollLeft()\r\n        canScrollHorizontally = this.canScrollHorizontally()\r\n        canScrollVertically = this.canScrollVertically()\r\n        horizontalScrollbarHeight = this.getHorizontalScrollbarHeight()\r\n        verticalScrollbarWidth = this.getVerticalScrollbarWidth()\r\n        forceScrollbarVisible = this.remeasureScrollbars\r\n      } else {\r\n        forceScrollbarVisible = true\r\n      }\r\n\r\n      return [\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'verticalScrollbar',\r\n          orientation: 'vertical',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollVertically,\r\n          scrollHeight,\r\n          scrollTop,\r\n          horizontalScrollbarHeight,\r\n          forceScrollbarVisible\r\n        }),\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'horizontalScrollbar',\r\n          orientation: 'horizontal',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollHorizontally,\r\n          scrollWidth,\r\n          scrollLeft,\r\n          verticalScrollbarWidth,\r\n          forceScrollbarVisible\r\n        }),\r\n\r\n        // Force a \"corner\" to render where the two scrollbars meet at the lower right\r\n        $.div(\r\n          {\r\n            ref: 'scrollbarCorner',\r\n            className: 'scrollbar-corner',\r\n            style: {\r\n              position: 'absolute',\r\n              height: '20px',\r\n              width: '20px',\r\n              bottom: 0,\r\n              right: 0,\r\n              overflow: 'scroll'\r\n            }\r\n          }\r\n        )\r\n      ]\r\n    } else {\r\n      return null\r\n    }\r\n  }\r", "name": "getScrollTop", "func_location": "TextEditorComponent.renderDummyScrollbars", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 755, "func_start_line": 746}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollLeft", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2825, "start_line": 2823}, "call_info": {"func_end_line": 809, "code": "  renderDummyScrollbars () {\r\n    if (this.shouldRenderDummyScrollbars && !this.props.model.isMini()) {\r\n      let scrollHeight, scrollTop, horizontalScrollbarHeight\r\n      let scrollWidth, scrollLeft, verticalScrollbarWidth, forceScrollbarVisible\r\n      let canScrollHorizontally, canScrollVertically\r\n\r\n      if (this.hasInitialMeasurements) {\r\n        scrollHeight = this.getScrollHeight()\r\n        scrollWidth = this.getScrollWidth()\r\n        scrollTop = this.getScrollTop()\r\n        scrollLeft = this.getScrollLeft()\r\n        canScrollHorizontally = this.canScrollHorizontally()\r\n        canScrollVertically = this.canScrollVertically()\r\n        horizontalScrollbarHeight = this.getHorizontalScrollbarHeight()\r\n        verticalScrollbarWidth = this.getVerticalScrollbarWidth()\r\n        forceScrollbarVisible = this.remeasureScrollbars\r\n      } else {\r\n        forceScrollbarVisible = true\r\n      }\r\n\r\n      return [\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'verticalScrollbar',\r\n          orientation: 'vertical',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollVertically,\r\n          scrollHeight,\r\n          scrollTop,\r\n          horizontalScrollbarHeight,\r\n          forceScrollbarVisible\r\n        }),\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'horizontalScrollbar',\r\n          orientation: 'horizontal',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollHorizontally,\r\n          scrollWidth,\r\n          scrollLeft,\r\n          verticalScrollbarWidth,\r\n          forceScrollbarVisible\r\n        }),\r\n\r\n        // Force a \"corner\" to render where the two scrollbars meet at the lower right\r\n        $.div(\r\n          {\r\n            ref: 'scrollbarCorner',\r\n            className: 'scrollbar-corner',\r\n            style: {\r\n              position: 'absolute',\r\n              height: '20px',\r\n              width: '20px',\r\n              bottom: 0,\r\n              right: 0,\r\n              overflow: 'scroll'\r\n            }\r\n          }\r\n        )\r\n      ]\r\n    } else {\r\n      return null\r\n    }\r\n  }\r", "name": "getScrollLeft", "func_location": "TextEditorComponent.renderDummyScrollbars", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 756, "func_start_line": 746}}, {"func_info": {"comment": [], "name": "TextEditorComponent.canScrollHorizontally", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2657, "start_line": 2651}, "call_info": {"func_end_line": 809, "code": "  renderDummyScrollbars () {\r\n    if (this.shouldRenderDummyScrollbars && !this.props.model.isMini()) {\r\n      let scrollHeight, scrollTop, horizontalScrollbarHeight\r\n      let scrollWidth, scrollLeft, verticalScrollbarWidth, forceScrollbarVisible\r\n      let canScrollHorizontally, canScrollVertically\r\n\r\n      if (this.hasInitialMeasurements) {\r\n        scrollHeight = this.getScrollHeight()\r\n        scrollWidth = this.getScrollWidth()\r\n        scrollTop = this.getScrollTop()\r\n        scrollLeft = this.getScrollLeft()\r\n        canScrollHorizontally = this.canScrollHorizontally()\r\n        canScrollVertically = this.canScrollVertically()\r\n        horizontalScrollbarHeight = this.getHorizontalScrollbarHeight()\r\n        verticalScrollbarWidth = this.getVerticalScrollbarWidth()\r\n        forceScrollbarVisible = this.remeasureScrollbars\r\n      } else {\r\n        forceScrollbarVisible = true\r\n      }\r\n\r\n      return [\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'verticalScrollbar',\r\n          orientation: 'vertical',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollVertically,\r\n          scrollHeight,\r\n          scrollTop,\r\n          horizontalScrollbarHeight,\r\n          forceScrollbarVisible\r\n        }),\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'horizontalScrollbar',\r\n          orientation: 'horizontal',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollHorizontally,\r\n          scrollWidth,\r\n          scrollLeft,\r\n          verticalScrollbarWidth,\r\n          forceScrollbarVisible\r\n        }),\r\n\r\n        // Force a \"corner\" to render where the two scrollbars meet at the lower right\r\n        $.div(\r\n          {\r\n            ref: 'scrollbarCorner',\r\n            className: 'scrollbar-corner',\r\n            style: {\r\n              position: 'absolute',\r\n              height: '20px',\r\n              width: '20px',\r\n              bottom: 0,\r\n              right: 0,\r\n              overflow: 'scroll'\r\n            }\r\n          }\r\n        )\r\n      ]\r\n    } else {\r\n      return null\r\n    }\r\n  }\r", "name": "canScrollHorizontally", "func_location": "TextEditorComponent.renderDummyScrollbars", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 757, "func_start_line": 746}}, {"func_info": {"comment": [], "name": "TextEditorComponent.canScrollVertically", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2649, "start_line": 2644}, "call_info": {"func_end_line": 809, "code": "  renderDummyScrollbars () {\r\n    if (this.shouldRenderDummyScrollbars && !this.props.model.isMini()) {\r\n      let scrollHeight, scrollTop, horizontalScrollbarHeight\r\n      let scrollWidth, scrollLeft, verticalScrollbarWidth, forceScrollbarVisible\r\n      let canScrollHorizontally, canScrollVertically\r\n\r\n      if (this.hasInitialMeasurements) {\r\n        scrollHeight = this.getScrollHeight()\r\n        scrollWidth = this.getScrollWidth()\r\n        scrollTop = this.getScrollTop()\r\n        scrollLeft = this.getScrollLeft()\r\n        canScrollHorizontally = this.canScrollHorizontally()\r\n        canScrollVertically = this.canScrollVertically()\r\n        horizontalScrollbarHeight = this.getHorizontalScrollbarHeight()\r\n        verticalScrollbarWidth = this.getVerticalScrollbarWidth()\r\n        forceScrollbarVisible = this.remeasureScrollbars\r\n      } else {\r\n        forceScrollbarVisible = true\r\n      }\r\n\r\n      return [\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'verticalScrollbar',\r\n          orientation: 'vertical',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollVertically,\r\n          scrollHeight,\r\n          scrollTop,\r\n          horizontalScrollbarHeight,\r\n          forceScrollbarVisible\r\n        }),\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'horizontalScrollbar',\r\n          orientation: 'horizontal',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollHorizontally,\r\n          scrollWidth,\r\n          scrollLeft,\r\n          verticalScrollbarWidth,\r\n          forceScrollbarVisible\r\n        }),\r\n\r\n        // Force a \"corner\" to render where the two scrollbars meet at the lower right\r\n        $.div(\r\n          {\r\n            ref: 'scrollbarCorner',\r\n            className: 'scrollbar-corner',\r\n            style: {\r\n              position: 'absolute',\r\n              height: '20px',\r\n              width: '20px',\r\n              bottom: 0,\r\n              right: 0,\r\n              overflow: 'scroll'\r\n            }\r\n          }\r\n        )\r\n      ]\r\n    } else {\r\n      return null\r\n    }\r\n  }\r", "name": "canScrollVertically", "func_location": "TextEditorComponent.renderDummyScrollbars", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 758, "func_start_line": 746}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getHorizontalScrollbarHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2710, "start_line": 2708}, "call_info": {"func_end_line": 809, "code": "  renderDummyScrollbars () {\r\n    if (this.shouldRenderDummyScrollbars && !this.props.model.isMini()) {\r\n      let scrollHeight, scrollTop, horizontalScrollbarHeight\r\n      let scrollWidth, scrollLeft, verticalScrollbarWidth, forceScrollbarVisible\r\n      let canScrollHorizontally, canScrollVertically\r\n\r\n      if (this.hasInitialMeasurements) {\r\n        scrollHeight = this.getScrollHeight()\r\n        scrollWidth = this.getScrollWidth()\r\n        scrollTop = this.getScrollTop()\r\n        scrollLeft = this.getScrollLeft()\r\n        canScrollHorizontally = this.canScrollHorizontally()\r\n        canScrollVertically = this.canScrollVertically()\r\n        horizontalScrollbarHeight = this.getHorizontalScrollbarHeight()\r\n        verticalScrollbarWidth = this.getVerticalScrollbarWidth()\r\n        forceScrollbarVisible = this.remeasureScrollbars\r\n      } else {\r\n        forceScrollbarVisible = true\r\n      }\r\n\r\n      return [\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'verticalScrollbar',\r\n          orientation: 'vertical',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollVertically,\r\n          scrollHeight,\r\n          scrollTop,\r\n          horizontalScrollbarHeight,\r\n          forceScrollbarVisible\r\n        }),\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'horizontalScrollbar',\r\n          orientation: 'horizontal',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollHorizontally,\r\n          scrollWidth,\r\n          scrollLeft,\r\n          verticalScrollbarWidth,\r\n          forceScrollbarVisible\r\n        }),\r\n\r\n        // Force a \"corner\" to render where the two scrollbars meet at the lower right\r\n        $.div(\r\n          {\r\n            ref: 'scrollbarCorner',\r\n            className: 'scrollbar-corner',\r\n            style: {\r\n              position: 'absolute',\r\n              height: '20px',\r\n              width: '20px',\r\n              bottom: 0,\r\n              right: 0,\r\n              overflow: 'scroll'\r\n            }\r\n          }\r\n        )\r\n      ]\r\n    } else {\r\n      return null\r\n    }\r\n  }\r", "name": "getHorizontalScrollbarHeight", "func_location": "TextEditorComponent.renderDummyScrollbars", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 759, "func_start_line": 746}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getVerticalScrollbarWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2706, "start_line": 2704}, "call_info": {"func_end_line": 809, "code": "  renderDummyScrollbars () {\r\n    if (this.shouldRenderDummyScrollbars && !this.props.model.isMini()) {\r\n      let scrollHeight, scrollTop, horizontalScrollbarHeight\r\n      let scrollWidth, scrollLeft, verticalScrollbarWidth, forceScrollbarVisible\r\n      let canScrollHorizontally, canScrollVertically\r\n\r\n      if (this.hasInitialMeasurements) {\r\n        scrollHeight = this.getScrollHeight()\r\n        scrollWidth = this.getScrollWidth()\r\n        scrollTop = this.getScrollTop()\r\n        scrollLeft = this.getScrollLeft()\r\n        canScrollHorizontally = this.canScrollHorizontally()\r\n        canScrollVertically = this.canScrollVertically()\r\n        horizontalScrollbarHeight = this.getHorizontalScrollbarHeight()\r\n        verticalScrollbarWidth = this.getVerticalScrollbarWidth()\r\n        forceScrollbarVisible = this.remeasureScrollbars\r\n      } else {\r\n        forceScrollbarVisible = true\r\n      }\r\n\r\n      return [\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'verticalScrollbar',\r\n          orientation: 'vertical',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollVertically,\r\n          scrollHeight,\r\n          scrollTop,\r\n          horizontalScrollbarHeight,\r\n          forceScrollbarVisible\r\n        }),\r\n        $(DummyScrollbarComponent, {\r\n          ref: 'horizontalScrollbar',\r\n          orientation: 'horizontal',\r\n          didScroll: this.didScrollDummyScrollbar,\r\n          didMouseDown: this.didMouseDownOnContent,\r\n          canScroll: canScrollHorizontally,\r\n          scrollWidth,\r\n          scrollLeft,\r\n          verticalScrollbarWidth,\r\n          forceScrollbarVisible\r\n        }),\r\n\r\n        // Force a \"corner\" to render where the two scrollbars meet at the lower right\r\n        $.div(\r\n          {\r\n            ref: 'scrollbarCorner',\r\n            className: 'scrollbar-corner',\r\n            style: {\r\n              position: 'absolute',\r\n              height: '20px',\r\n              width: '20px',\r\n              bottom: 0,\r\n              right: 0,\r\n              overflow: 'scroll'\r\n            }\r\n          }\r\n        )\r\n      ]\r\n    } else {\r\n      return null\r\n    }\r\n  }\r", "name": "getVerticalScrollbarWidth", "func_location": "TextEditorComponent.renderDummyScrollbars", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 760, "func_start_line": 746}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedStartRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2726, "start_line": 2720}, "call_info": {"func_end_line": 961, "code": "  renderedScreenLineForRow (row) {\r\n    return (\r\n      this.renderedScreenLines[row - this.getRenderedStartRow()] ||\r\n      this.extraRenderedScreenLines.get(row)\r\n    )\r\n  }\r", "name": "getRenderedStartRow", "func_location": "TextEditorComponent.renderedScreenLineForRow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 958, "func_start_line": 956}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollTop", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2794, "start_line": 2791}, "call_info": {"func_end_line": 548, "code": "  renderGutterContainer () {\r\n    if (this.props.model.isMini()) {\r\n      return null\r\n    } else {\r\n      return $(GutterContainerComponent, {\r\n        ref: 'gutterContainer',\r\n        key: 'gutterContainer',\r\n        rootComponent: this,\r\n        hasInitialMeasurements: this.hasInitialMeasurements,\r\n        measuredContent: this.measuredContent,\r\n        scrollTop: this.getScrollTop(),\r\n        scrollHeight: this.getScrollHeight(),\r\n        lineNumberGutterWidth: this.getLineNumberGutterWidth(),\r\n        lineHeight: this.getLineHeight(),\r\n        renderedStartRow: this.getRenderedStartRow(),\r\n        renderedEndRow: this.getRenderedEndRow(),\r\n        rowsPerTile: this.getRowsPerTile(),\r\n        guttersToRender: this.guttersToRender,\r\n        decorationsToRender: this.decorationsToRender,\r\n        isLineNumberGutterVisible: this.props.model.isLineNumberGutterVisible(),\r\n        showLineNumbers: this.showLineNumbers,\r\n        lineNumbersToRender: this.lineNumbersToRender,\r\n        didMeasureVisibleBlockDecoration: this.didMeasureVisibleBlockDecoration\r\n      })\r\n    }\r\n  }\r", "name": "getScrollTop", "func_location": "TextEditorComponent.renderGutterContainer", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 533, "func_start_line": 523}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2670, "start_line": 2659}, "call_info": {"func_end_line": 548, "code": "  renderGutterContainer () {\r\n    if (this.props.model.isMini()) {\r\n      return null\r\n    } else {\r\n      return $(GutterContainerComponent, {\r\n        ref: 'gutterContainer',\r\n        key: 'gutterContainer',\r\n        rootComponent: this,\r\n        hasInitialMeasurements: this.hasInitialMeasurements,\r\n        measuredContent: this.measuredContent,\r\n        scrollTop: this.getScrollTop(),\r\n        scrollHeight: this.getScrollHeight(),\r\n        lineNumberGutterWidth: this.getLineNumberGutterWidth(),\r\n        lineHeight: this.getLineHeight(),\r\n        renderedStartRow: this.getRenderedStartRow(),\r\n        renderedEndRow: this.getRenderedEndRow(),\r\n        rowsPerTile: this.getRowsPerTile(),\r\n        guttersToRender: this.guttersToRender,\r\n        decorationsToRender: this.decorationsToRender,\r\n        isLineNumberGutterVisible: this.props.model.isLineNumberGutterVisible(),\r\n        showLineNumbers: this.showLineNumbers,\r\n        lineNumbersToRender: this.lineNumbersToRender,\r\n        didMeasureVisibleBlockDecoration: this.didMeasureVisibleBlockDecoration\r\n      })\r\n    }\r\n  }\r", "name": "getScrollHeight", "func_location": "TextEditorComponent.renderGutterContainer", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 534, "func_start_line": 523}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getLineNumberGutterWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2702, "start_line": 2700}, "call_info": {"func_end_line": 548, "code": "  renderGutterContainer () {\r\n    if (this.props.model.isMini()) {\r\n      return null\r\n    } else {\r\n      return $(GutterContainerComponent, {\r\n        ref: 'gutterContainer',\r\n        key: 'gutterContainer',\r\n        rootComponent: this,\r\n        hasInitialMeasurements: this.hasInitialMeasurements,\r\n        measuredContent: this.measuredContent,\r\n        scrollTop: this.getScrollTop(),\r\n        scrollHeight: this.getScrollHeight(),\r\n        lineNumberGutterWidth: this.getLineNumberGutterWidth(),\r\n        lineHeight: this.getLineHeight(),\r\n        renderedStartRow: this.getRenderedStartRow(),\r\n        renderedEndRow: this.getRenderedEndRow(),\r\n        rowsPerTile: this.getRowsPerTile(),\r\n        guttersToRender: this.guttersToRender,\r\n        decorationsToRender: this.decorationsToRender,\r\n        isLineNumberGutterVisible: this.props.model.isLineNumberGutterVisible(),\r\n        showLineNumbers: this.showLineNumbers,\r\n        lineNumbersToRender: this.lineNumbersToRender,\r\n        didMeasureVisibleBlockDecoration: this.didMeasureVisibleBlockDecoration\r\n      })\r\n    }\r\n  }\r", "name": "getLineNumberGutterWidth", "func_location": "TextEditorComponent.renderGutterContainer", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 535, "func_start_line": 523}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getLineHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2602, "start_line": 2600}, "call_info": {"func_end_line": 548, "code": "  renderGutterContainer () {\r\n    if (this.props.model.isMini()) {\r\n      return null\r\n    } else {\r\n      return $(GutterContainerComponent, {\r\n        ref: 'gutterContainer',\r\n        key: 'gutterContainer',\r\n        rootComponent: this,\r\n        hasInitialMeasurements: this.hasInitialMeasurements,\r\n        measuredContent: this.measuredContent,\r\n        scrollTop: this.getScrollTop(),\r\n        scrollHeight: this.getScrollHeight(),\r\n        lineNumberGutterWidth: this.getLineNumberGutterWidth(),\r\n        lineHeight: this.getLineHeight(),\r\n        renderedStartRow: this.getRenderedStartRow(),\r\n        renderedEndRow: this.getRenderedEndRow(),\r\n        rowsPerTile: this.getRowsPerTile(),\r\n        guttersToRender: this.guttersToRender,\r\n        decorationsToRender: this.decorationsToRender,\r\n        isLineNumberGutterVisible: this.props.model.isLineNumberGutterVisible(),\r\n        showLineNumbers: this.showLineNumbers,\r\n        lineNumbersToRender: this.lineNumbersToRender,\r\n        didMeasureVisibleBlockDecoration: this.didMeasureVisibleBlockDecoration\r\n      })\r\n    }\r\n  }\r", "name": "getLineHeight", "func_location": "TextEditorComponent.renderGutterContainer", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 536, "func_start_line": 523}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedStartRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2726, "start_line": 2720}, "call_info": {"func_end_line": 548, "code": "  renderGutterContainer () {\r\n    if (this.props.model.isMini()) {\r\n      return null\r\n    } else {\r\n      return $(GutterContainerComponent, {\r\n        ref: 'gutterContainer',\r\n        key: 'gutterContainer',\r\n        rootComponent: this,\r\n        hasInitialMeasurements: this.hasInitialMeasurements,\r\n        measuredContent: this.measuredContent,\r\n        scrollTop: this.getScrollTop(),\r\n        scrollHeight: this.getScrollHeight(),\r\n        lineNumberGutterWidth: this.getLineNumberGutterWidth(),\r\n        lineHeight: this.getLineHeight(),\r\n        renderedStartRow: this.getRenderedStartRow(),\r\n        renderedEndRow: this.getRenderedEndRow(),\r\n        rowsPerTile: this.getRowsPerTile(),\r\n        guttersToRender: this.guttersToRender,\r\n        decorationsToRender: this.decorationsToRender,\r\n        isLineNumberGutterVisible: this.props.model.isLineNumberGutterVisible(),\r\n        showLineNumbers: this.showLineNumbers,\r\n        lineNumbersToRender: this.lineNumbersToRender,\r\n        didMeasureVisibleBlockDecoration: this.didMeasureVisibleBlockDecoration\r\n      })\r\n    }\r\n  }\r", "name": "getRenderedStartRow", "func_location": "TextEditorComponent.renderGutterContainer", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 537, "func_start_line": 523}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedEndRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2737, "start_line": 2728}, "call_info": {"func_end_line": 548, "code": "  renderGutterContainer () {\r\n    if (this.props.model.isMini()) {\r\n      return null\r\n    } else {\r\n      return $(GutterContainerComponent, {\r\n        ref: 'gutterContainer',\r\n        key: 'gutterContainer',\r\n        rootComponent: this,\r\n        hasInitialMeasurements: this.hasInitialMeasurements,\r\n        measuredContent: this.measuredContent,\r\n        scrollTop: this.getScrollTop(),\r\n        scrollHeight: this.getScrollHeight(),\r\n        lineNumberGutterWidth: this.getLineNumberGutterWidth(),\r\n        lineHeight: this.getLineHeight(),\r\n        renderedStartRow: this.getRenderedStartRow(),\r\n        renderedEndRow: this.getRenderedEndRow(),\r\n        rowsPerTile: this.getRowsPerTile(),\r\n        guttersToRender: this.guttersToRender,\r\n        decorationsToRender: this.decorationsToRender,\r\n        isLineNumberGutterVisible: this.props.model.isLineNumberGutterVisible(),\r\n        showLineNumbers: this.showLineNumbers,\r\n        lineNumbersToRender: this.lineNumbersToRender,\r\n        didMeasureVisibleBlockDecoration: this.didMeasureVisibleBlockDecoration\r\n      })\r\n    }\r\n  }\r", "name": "getRenderedEndRow", "func_location": "TextEditorComponent.renderGutterContainer", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 538, "func_start_line": 523}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRowsPerTile", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2714, "start_line": 2712}, "call_info": {"func_end_line": 548, "code": "  renderGutterContainer () {\r\n    if (this.props.model.isMini()) {\r\n      return null\r\n    } else {\r\n      return $(GutterContainerComponent, {\r\n        ref: 'gutterContainer',\r\n        key: 'gutterContainer',\r\n        rootComponent: this,\r\n        hasInitialMeasurements: this.hasInitialMeasurements,\r\n        measuredContent: this.measuredContent,\r\n        scrollTop: this.getScrollTop(),\r\n        scrollHeight: this.getScrollHeight(),\r\n        lineNumberGutterWidth: this.getLineNumberGutterWidth(),\r\n        lineHeight: this.getLineHeight(),\r\n        renderedStartRow: this.getRenderedStartRow(),\r\n        renderedEndRow: this.getRenderedEndRow(),\r\n        rowsPerTile: this.getRowsPerTile(),\r\n        guttersToRender: this.guttersToRender,\r\n        decorationsToRender: this.decorationsToRender,\r\n        isLineNumberGutterVisible: this.props.model.isLineNumberGutterVisible(),\r\n        showLineNumbers: this.showLineNumbers,\r\n        lineNumbersToRender: this.lineNumbersToRender,\r\n        didMeasureVisibleBlockDecoration: this.didMeasureVisibleBlockDecoration\r\n      })\r\n    }\r\n  }\r", "name": "getRowsPerTile", "func_location": "TextEditorComponent.renderGutterContainer", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 539, "func_start_line": 523}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2682, "start_line": 2672}, "call_info": {"func_end_line": 610, "code": "  renderHighlightDecorations () {\r\n    return $(HighlightsComponent, {\r\n      hasInitialMeasurements: this.hasInitialMeasurements,\r\n      highlightDecorations: this.decorationsToRender.highlights.slice(),\r\n      width: this.getScrollWidth(),\r\n      height: this.getScrollHeight(),\r\n      lineHeight: this.getLineHeight()\r\n    })\r\n  }\r", "name": "getScrollWidth", "func_location": "TextEditorComponent.renderHighlightDecorations", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 606, "func_start_line": 602}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2670, "start_line": 2659}, "call_info": {"func_end_line": 610, "code": "  renderHighlightDecorations () {\r\n    return $(HighlightsComponent, {\r\n      hasInitialMeasurements: this.hasInitialMeasurements,\r\n      highlightDecorations: this.decorationsToRender.highlights.slice(),\r\n      width: this.getScrollWidth(),\r\n      height: this.getScrollHeight(),\r\n      lineHeight: this.getLineHeight()\r\n    })\r\n  }\r", "name": "getScrollHeight", "func_location": "TextEditorComponent.renderHighlightDecorations", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 607, "func_start_line": 602}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getLineHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2602, "start_line": 2600}, "call_info": {"func_end_line": 610, "code": "  renderHighlightDecorations () {\r\n    return $(HighlightsComponent, {\r\n      hasInitialMeasurements: this.hasInitialMeasurements,\r\n      highlightDecorations: this.decorationsToRender.highlights.slice(),\r\n      width: this.getScrollWidth(),\r\n      height: this.getScrollHeight(),\r\n      lineHeight: this.getLineHeight()\r\n    })\r\n  }\r", "name": "getLineHeight", "func_location": "TextEditorComponent.renderHighlightDecorations", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 608, "func_start_line": 602}}, {"func_info": {"comment": [], "name": "TextEditorComponent.renderHighlightDecorations", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 610, "start_line": 602}, "call_info": {"func_end_line": 680, "code": "  renderLineTiles () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden'\r\n    }\r\n\r\n    const children = []\r\n    children.push(this.renderHighlightDecorations())\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      const {lineComponentsByScreenLineId} = this\r\n\r\n      const startRow = this.getRenderedStartRow()\r\n      const endRow = this.getRenderedEndRow()\r\n      const rowsPerTile = this.getRowsPerTile()\r\n      const tileWidth = this.getScrollWidth()\r\n\r\n      for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = this.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileHeight = this.pixelPositionBeforeBlocksForRow(tileEndRow) - this.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n\r\n        children.push($(LinesTileComponent, {\r\n          key: this.idsByTileStartRow.get(tileStartRow),\r\n          measuredContent: this.measuredContent,\r\n          height: tileHeight,\r\n          width: tileWidth,\r\n          top: this.pixelPositionBeforeBlocksForRow(tileStartRow),\r\n          lineHeight: this.getLineHeight(),\r\n          renderedStartRow: startRow,\r\n          tileStartRow,\r\n          tileEndRow,\r\n          screenLines: this.renderedScreenLines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          lineDecorations: this.decorationsToRender.lines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          textDecorations: this.decorationsToRender.text.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),\r\n          displayLayer: this.props.model.displayLayer,\r\n          nodePool: this.lineNodesPool,\r\n          lineComponentsByScreenLineId\r\n        }))\r\n      }\r\n\r\n      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {\r\n        if (screenRow < startRow || screenRow >= endRow) {\r\n          children.push($(LineComponent, {\r\n            key: 'extra-' + screenLine.id,\r\n            offScreen: true,\r\n            screenLine,\r\n            screenRow,\r\n            displayLayer: this.props.model.displayLayer,\r\n            nodePool: this.lineNodesPool,\r\n            lineComponentsByScreenLineId\r\n          }))\r\n        }\r\n      })\r\n\r\n      style.width = this.getScrollWidth() + 'px'\r\n      style.height = this.getScrollHeight() + 'px'\r\n    }\r\n\r\n    children.push(this.renderPlaceholderText())\r\n    children.push(this.renderCursorsAndInput())\r\n\r\n    return $.div(\r\n      {key: 'lineTiles', ref: 'lineTiles', className: 'lines', style},\r\n      children\r\n    )\r\n  }\r", "name": "renderHighlightDecorations", "func_location": "TextEditorComponent.renderLineTiles", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 620, "func_start_line": 612}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedStartRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2726, "start_line": 2720}, "call_info": {"func_end_line": 680, "code": "  renderLineTiles () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden'\r\n    }\r\n\r\n    const children = []\r\n    children.push(this.renderHighlightDecorations())\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      const {lineComponentsByScreenLineId} = this\r\n\r\n      const startRow = this.getRenderedStartRow()\r\n      const endRow = this.getRenderedEndRow()\r\n      const rowsPerTile = this.getRowsPerTile()\r\n      const tileWidth = this.getScrollWidth()\r\n\r\n      for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = this.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileHeight = this.pixelPositionBeforeBlocksForRow(tileEndRow) - this.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n\r\n        children.push($(LinesTileComponent, {\r\n          key: this.idsByTileStartRow.get(tileStartRow),\r\n          measuredContent: this.measuredContent,\r\n          height: tileHeight,\r\n          width: tileWidth,\r\n          top: this.pixelPositionBeforeBlocksForRow(tileStartRow),\r\n          lineHeight: this.getLineHeight(),\r\n          renderedStartRow: startRow,\r\n          tileStartRow,\r\n          tileEndRow,\r\n          screenLines: this.renderedScreenLines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          lineDecorations: this.decorationsToRender.lines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          textDecorations: this.decorationsToRender.text.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),\r\n          displayLayer: this.props.model.displayLayer,\r\n          nodePool: this.lineNodesPool,\r\n          lineComponentsByScreenLineId\r\n        }))\r\n      }\r\n\r\n      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {\r\n        if (screenRow < startRow || screenRow >= endRow) {\r\n          children.push($(LineComponent, {\r\n            key: 'extra-' + screenLine.id,\r\n            offScreen: true,\r\n            screenLine,\r\n            screenRow,\r\n            displayLayer: this.props.model.displayLayer,\r\n            nodePool: this.lineNodesPool,\r\n            lineComponentsByScreenLineId\r\n          }))\r\n        }\r\n      })\r\n\r\n      style.width = this.getScrollWidth() + 'px'\r\n      style.height = this.getScrollHeight() + 'px'\r\n    }\r\n\r\n    children.push(this.renderPlaceholderText())\r\n    children.push(this.renderCursorsAndInput())\r\n\r\n    return $.div(\r\n      {key: 'lineTiles', ref: 'lineTiles', className: 'lines', style},\r\n      children\r\n    )\r\n  }\r", "name": "getRenderedStartRow", "func_location": "TextEditorComponent.renderLineTiles", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 625, "func_start_line": 612}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedEndRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2737, "start_line": 2728}, "call_info": {"func_end_line": 680, "code": "  renderLineTiles () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden'\r\n    }\r\n\r\n    const children = []\r\n    children.push(this.renderHighlightDecorations())\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      const {lineComponentsByScreenLineId} = this\r\n\r\n      const startRow = this.getRenderedStartRow()\r\n      const endRow = this.getRenderedEndRow()\r\n      const rowsPerTile = this.getRowsPerTile()\r\n      const tileWidth = this.getScrollWidth()\r\n\r\n      for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = this.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileHeight = this.pixelPositionBeforeBlocksForRow(tileEndRow) - this.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n\r\n        children.push($(LinesTileComponent, {\r\n          key: this.idsByTileStartRow.get(tileStartRow),\r\n          measuredContent: this.measuredContent,\r\n          height: tileHeight,\r\n          width: tileWidth,\r\n          top: this.pixelPositionBeforeBlocksForRow(tileStartRow),\r\n          lineHeight: this.getLineHeight(),\r\n          renderedStartRow: startRow,\r\n          tileStartRow,\r\n          tileEndRow,\r\n          screenLines: this.renderedScreenLines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          lineDecorations: this.decorationsToRender.lines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          textDecorations: this.decorationsToRender.text.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),\r\n          displayLayer: this.props.model.displayLayer,\r\n          nodePool: this.lineNodesPool,\r\n          lineComponentsByScreenLineId\r\n        }))\r\n      }\r\n\r\n      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {\r\n        if (screenRow < startRow || screenRow >= endRow) {\r\n          children.push($(LineComponent, {\r\n            key: 'extra-' + screenLine.id,\r\n            offScreen: true,\r\n            screenLine,\r\n            screenRow,\r\n            displayLayer: this.props.model.displayLayer,\r\n            nodePool: this.lineNodesPool,\r\n            lineComponentsByScreenLineId\r\n          }))\r\n        }\r\n      })\r\n\r\n      style.width = this.getScrollWidth() + 'px'\r\n      style.height = this.getScrollHeight() + 'px'\r\n    }\r\n\r\n    children.push(this.renderPlaceholderText())\r\n    children.push(this.renderCursorsAndInput())\r\n\r\n    return $.div(\r\n      {key: 'lineTiles', ref: 'lineTiles', className: 'lines', style},\r\n      children\r\n    )\r\n  }\r", "name": "getRenderedEndRow", "func_location": "TextEditorComponent.renderLineTiles", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 626, "func_start_line": 612}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRowsPerTile", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2714, "start_line": 2712}, "call_info": {"func_end_line": 680, "code": "  renderLineTiles () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden'\r\n    }\r\n\r\n    const children = []\r\n    children.push(this.renderHighlightDecorations())\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      const {lineComponentsByScreenLineId} = this\r\n\r\n      const startRow = this.getRenderedStartRow()\r\n      const endRow = this.getRenderedEndRow()\r\n      const rowsPerTile = this.getRowsPerTile()\r\n      const tileWidth = this.getScrollWidth()\r\n\r\n      for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = this.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileHeight = this.pixelPositionBeforeBlocksForRow(tileEndRow) - this.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n\r\n        children.push($(LinesTileComponent, {\r\n          key: this.idsByTileStartRow.get(tileStartRow),\r\n          measuredContent: this.measuredContent,\r\n          height: tileHeight,\r\n          width: tileWidth,\r\n          top: this.pixelPositionBeforeBlocksForRow(tileStartRow),\r\n          lineHeight: this.getLineHeight(),\r\n          renderedStartRow: startRow,\r\n          tileStartRow,\r\n          tileEndRow,\r\n          screenLines: this.renderedScreenLines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          lineDecorations: this.decorationsToRender.lines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          textDecorations: this.decorationsToRender.text.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),\r\n          displayLayer: this.props.model.displayLayer,\r\n          nodePool: this.lineNodesPool,\r\n          lineComponentsByScreenLineId\r\n        }))\r\n      }\r\n\r\n      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {\r\n        if (screenRow < startRow || screenRow >= endRow) {\r\n          children.push($(LineComponent, {\r\n            key: 'extra-' + screenLine.id,\r\n            offScreen: true,\r\n            screenLine,\r\n            screenRow,\r\n            displayLayer: this.props.model.displayLayer,\r\n            nodePool: this.lineNodesPool,\r\n            lineComponentsByScreenLineId\r\n          }))\r\n        }\r\n      })\r\n\r\n      style.width = this.getScrollWidth() + 'px'\r\n      style.height = this.getScrollHeight() + 'px'\r\n    }\r\n\r\n    children.push(this.renderPlaceholderText())\r\n    children.push(this.renderCursorsAndInput())\r\n\r\n    return $.div(\r\n      {key: 'lineTiles', ref: 'lineTiles', className: 'lines', style},\r\n      children\r\n    )\r\n  }\r", "name": "getRowsPerTile", "func_location": "TextEditorComponent.renderLineTiles", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 627, "func_start_line": 612}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2682, "start_line": 2672}, "call_info": {"func_end_line": 680, "code": "  renderLineTiles () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden'\r\n    }\r\n\r\n    const children = []\r\n    children.push(this.renderHighlightDecorations())\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      const {lineComponentsByScreenLineId} = this\r\n\r\n      const startRow = this.getRenderedStartRow()\r\n      const endRow = this.getRenderedEndRow()\r\n      const rowsPerTile = this.getRowsPerTile()\r\n      const tileWidth = this.getScrollWidth()\r\n\r\n      for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = this.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileHeight = this.pixelPositionBeforeBlocksForRow(tileEndRow) - this.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n\r\n        children.push($(LinesTileComponent, {\r\n          key: this.idsByTileStartRow.get(tileStartRow),\r\n          measuredContent: this.measuredContent,\r\n          height: tileHeight,\r\n          width: tileWidth,\r\n          top: this.pixelPositionBeforeBlocksForRow(tileStartRow),\r\n          lineHeight: this.getLineHeight(),\r\n          renderedStartRow: startRow,\r\n          tileStartRow,\r\n          tileEndRow,\r\n          screenLines: this.renderedScreenLines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          lineDecorations: this.decorationsToRender.lines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          textDecorations: this.decorationsToRender.text.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),\r\n          displayLayer: this.props.model.displayLayer,\r\n          nodePool: this.lineNodesPool,\r\n          lineComponentsByScreenLineId\r\n        }))\r\n      }\r\n\r\n      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {\r\n        if (screenRow < startRow || screenRow >= endRow) {\r\n          children.push($(LineComponent, {\r\n            key: 'extra-' + screenLine.id,\r\n            offScreen: true,\r\n            screenLine,\r\n            screenRow,\r\n            displayLayer: this.props.model.displayLayer,\r\n            nodePool: this.lineNodesPool,\r\n            lineComponentsByScreenLineId\r\n          }))\r\n        }\r\n      })\r\n\r\n      style.width = this.getScrollWidth() + 'px'\r\n      style.height = this.getScrollHeight() + 'px'\r\n    }\r\n\r\n    children.push(this.renderPlaceholderText())\r\n    children.push(this.renderCursorsAndInput())\r\n\r\n    return $.div(\r\n      {key: 'lineTiles', ref: 'lineTiles', className: 'lines', style},\r\n      children\r\n    )\r\n  }\r", "name": "getScrollWidth", "func_location": "TextEditorComponent.renderLineTiles", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 628, "func_start_line": 612}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelPositionBeforeBlocksForRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2362, "start_line": 2360}, "call_info": {"func_end_line": 680, "code": "  renderLineTiles () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden'\r\n    }\r\n\r\n    const children = []\r\n    children.push(this.renderHighlightDecorations())\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      const {lineComponentsByScreenLineId} = this\r\n\r\n      const startRow = this.getRenderedStartRow()\r\n      const endRow = this.getRenderedEndRow()\r\n      const rowsPerTile = this.getRowsPerTile()\r\n      const tileWidth = this.getScrollWidth()\r\n\r\n      for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = this.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileHeight = this.pixelPositionBeforeBlocksForRow(tileEndRow) - this.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n\r\n        children.push($(LinesTileComponent, {\r\n          key: this.idsByTileStartRow.get(tileStartRow),\r\n          measuredContent: this.measuredContent,\r\n          height: tileHeight,\r\n          width: tileWidth,\r\n          top: this.pixelPositionBeforeBlocksForRow(tileStartRow),\r\n          lineHeight: this.getLineHeight(),\r\n          renderedStartRow: startRow,\r\n          tileStartRow,\r\n          tileEndRow,\r\n          screenLines: this.renderedScreenLines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          lineDecorations: this.decorationsToRender.lines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          textDecorations: this.decorationsToRender.text.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),\r\n          displayLayer: this.props.model.displayLayer,\r\n          nodePool: this.lineNodesPool,\r\n          lineComponentsByScreenLineId\r\n        }))\r\n      }\r\n\r\n      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {\r\n        if (screenRow < startRow || screenRow >= endRow) {\r\n          children.push($(LineComponent, {\r\n            key: 'extra-' + screenLine.id,\r\n            offScreen: true,\r\n            screenLine,\r\n            screenRow,\r\n            displayLayer: this.props.model.displayLayer,\r\n            nodePool: this.lineNodesPool,\r\n            lineComponentsByScreenLineId\r\n          }))\r\n        }\r\n      })\r\n\r\n      style.width = this.getScrollWidth() + 'px'\r\n      style.height = this.getScrollHeight() + 'px'\r\n    }\r\n\r\n    children.push(this.renderPlaceholderText())\r\n    children.push(this.renderCursorsAndInput())\r\n\r\n    return $.div(\r\n      {key: 'lineTiles', ref: 'lineTiles', className: 'lines', style},\r\n      children\r\n    )\r\n  }\r", "name": "pixelPositionBeforeBlocksForRow", "func_location": "TextEditorComponent.renderLineTiles", "args": ["tileEndRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 633, "func_start_line": 612}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelPositionBeforeBlocksForRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2362, "start_line": 2360}, "call_info": {"func_end_line": 680, "code": "  renderLineTiles () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden'\r\n    }\r\n\r\n    const children = []\r\n    children.push(this.renderHighlightDecorations())\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      const {lineComponentsByScreenLineId} = this\r\n\r\n      const startRow = this.getRenderedStartRow()\r\n      const endRow = this.getRenderedEndRow()\r\n      const rowsPerTile = this.getRowsPerTile()\r\n      const tileWidth = this.getScrollWidth()\r\n\r\n      for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = this.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileHeight = this.pixelPositionBeforeBlocksForRow(tileEndRow) - this.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n\r\n        children.push($(LinesTileComponent, {\r\n          key: this.idsByTileStartRow.get(tileStartRow),\r\n          measuredContent: this.measuredContent,\r\n          height: tileHeight,\r\n          width: tileWidth,\r\n          top: this.pixelPositionBeforeBlocksForRow(tileStartRow),\r\n          lineHeight: this.getLineHeight(),\r\n          renderedStartRow: startRow,\r\n          tileStartRow,\r\n          tileEndRow,\r\n          screenLines: this.renderedScreenLines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          lineDecorations: this.decorationsToRender.lines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          textDecorations: this.decorationsToRender.text.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),\r\n          displayLayer: this.props.model.displayLayer,\r\n          nodePool: this.lineNodesPool,\r\n          lineComponentsByScreenLineId\r\n        }))\r\n      }\r\n\r\n      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {\r\n        if (screenRow < startRow || screenRow >= endRow) {\r\n          children.push($(LineComponent, {\r\n            key: 'extra-' + screenLine.id,\r\n            offScreen: true,\r\n            screenLine,\r\n            screenRow,\r\n            displayLayer: this.props.model.displayLayer,\r\n            nodePool: this.lineNodesPool,\r\n            lineComponentsByScreenLineId\r\n          }))\r\n        }\r\n      })\r\n\r\n      style.width = this.getScrollWidth() + 'px'\r\n      style.height = this.getScrollHeight() + 'px'\r\n    }\r\n\r\n    children.push(this.renderPlaceholderText())\r\n    children.push(this.renderCursorsAndInput())\r\n\r\n    return $.div(\r\n      {key: 'lineTiles', ref: 'lineTiles', className: 'lines', style},\r\n      children\r\n    )\r\n  }\r", "name": "pixelPositionBeforeBlocksForRow", "func_location": "TextEditorComponent.renderLineTiles", "args": ["tileEndRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 633, "func_start_line": 612}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelPositionBeforeBlocksForRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2362, "start_line": 2360}, "call_info": {"func_end_line": 680, "code": "  renderLineTiles () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden'\r\n    }\r\n\r\n    const children = []\r\n    children.push(this.renderHighlightDecorations())\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      const {lineComponentsByScreenLineId} = this\r\n\r\n      const startRow = this.getRenderedStartRow()\r\n      const endRow = this.getRenderedEndRow()\r\n      const rowsPerTile = this.getRowsPerTile()\r\n      const tileWidth = this.getScrollWidth()\r\n\r\n      for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = this.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileHeight = this.pixelPositionBeforeBlocksForRow(tileEndRow) - this.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n\r\n        children.push($(LinesTileComponent, {\r\n          key: this.idsByTileStartRow.get(tileStartRow),\r\n          measuredContent: this.measuredContent,\r\n          height: tileHeight,\r\n          width: tileWidth,\r\n          top: this.pixelPositionBeforeBlocksForRow(tileStartRow),\r\n          lineHeight: this.getLineHeight(),\r\n          renderedStartRow: startRow,\r\n          tileStartRow,\r\n          tileEndRow,\r\n          screenLines: this.renderedScreenLines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          lineDecorations: this.decorationsToRender.lines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          textDecorations: this.decorationsToRender.text.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),\r\n          displayLayer: this.props.model.displayLayer,\r\n          nodePool: this.lineNodesPool,\r\n          lineComponentsByScreenLineId\r\n        }))\r\n      }\r\n\r\n      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {\r\n        if (screenRow < startRow || screenRow >= endRow) {\r\n          children.push($(LineComponent, {\r\n            key: 'extra-' + screenLine.id,\r\n            offScreen: true,\r\n            screenLine,\r\n            screenRow,\r\n            displayLayer: this.props.model.displayLayer,\r\n            nodePool: this.lineNodesPool,\r\n            lineComponentsByScreenLineId\r\n          }))\r\n        }\r\n      })\r\n\r\n      style.width = this.getScrollWidth() + 'px'\r\n      style.height = this.getScrollHeight() + 'px'\r\n    }\r\n\r\n    children.push(this.renderPlaceholderText())\r\n    children.push(this.renderCursorsAndInput())\r\n\r\n    return $.div(\r\n      {key: 'lineTiles', ref: 'lineTiles', className: 'lines', style},\r\n      children\r\n    )\r\n  }\r", "name": "pixelPositionBeforeBlocksForRow", "func_location": "TextEditorComponent.renderLineTiles", "args": ["tileStartRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 640, "func_start_line": 612}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getLineHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2602, "start_line": 2600}, "call_info": {"func_end_line": 680, "code": "  renderLineTiles () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden'\r\n    }\r\n\r\n    const children = []\r\n    children.push(this.renderHighlightDecorations())\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      const {lineComponentsByScreenLineId} = this\r\n\r\n      const startRow = this.getRenderedStartRow()\r\n      const endRow = this.getRenderedEndRow()\r\n      const rowsPerTile = this.getRowsPerTile()\r\n      const tileWidth = this.getScrollWidth()\r\n\r\n      for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = this.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileHeight = this.pixelPositionBeforeBlocksForRow(tileEndRow) - this.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n\r\n        children.push($(LinesTileComponent, {\r\n          key: this.idsByTileStartRow.get(tileStartRow),\r\n          measuredContent: this.measuredContent,\r\n          height: tileHeight,\r\n          width: tileWidth,\r\n          top: this.pixelPositionBeforeBlocksForRow(tileStartRow),\r\n          lineHeight: this.getLineHeight(),\r\n          renderedStartRow: startRow,\r\n          tileStartRow,\r\n          tileEndRow,\r\n          screenLines: this.renderedScreenLines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          lineDecorations: this.decorationsToRender.lines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          textDecorations: this.decorationsToRender.text.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),\r\n          displayLayer: this.props.model.displayLayer,\r\n          nodePool: this.lineNodesPool,\r\n          lineComponentsByScreenLineId\r\n        }))\r\n      }\r\n\r\n      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {\r\n        if (screenRow < startRow || screenRow >= endRow) {\r\n          children.push($(LineComponent, {\r\n            key: 'extra-' + screenLine.id,\r\n            offScreen: true,\r\n            screenLine,\r\n            screenRow,\r\n            displayLayer: this.props.model.displayLayer,\r\n            nodePool: this.lineNodesPool,\r\n            lineComponentsByScreenLineId\r\n          }))\r\n        }\r\n      })\r\n\r\n      style.width = this.getScrollWidth() + 'px'\r\n      style.height = this.getScrollHeight() + 'px'\r\n    }\r\n\r\n    children.push(this.renderPlaceholderText())\r\n    children.push(this.renderCursorsAndInput())\r\n\r\n    return $.div(\r\n      {key: 'lineTiles', ref: 'lineTiles', className: 'lines', style},\r\n      children\r\n    )\r\n  }\r", "name": "getLineHeight", "func_location": "TextEditorComponent.renderLineTiles", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 641, "func_start_line": 612}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2682, "start_line": 2672}, "call_info": {"func_end_line": 680, "code": "  renderLineTiles () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden'\r\n    }\r\n\r\n    const children = []\r\n    children.push(this.renderHighlightDecorations())\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      const {lineComponentsByScreenLineId} = this\r\n\r\n      const startRow = this.getRenderedStartRow()\r\n      const endRow = this.getRenderedEndRow()\r\n      const rowsPerTile = this.getRowsPerTile()\r\n      const tileWidth = this.getScrollWidth()\r\n\r\n      for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = this.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileHeight = this.pixelPositionBeforeBlocksForRow(tileEndRow) - this.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n\r\n        children.push($(LinesTileComponent, {\r\n          key: this.idsByTileStartRow.get(tileStartRow),\r\n          measuredContent: this.measuredContent,\r\n          height: tileHeight,\r\n          width: tileWidth,\r\n          top: this.pixelPositionBeforeBlocksForRow(tileStartRow),\r\n          lineHeight: this.getLineHeight(),\r\n          renderedStartRow: startRow,\r\n          tileStartRow,\r\n          tileEndRow,\r\n          screenLines: this.renderedScreenLines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          lineDecorations: this.decorationsToRender.lines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          textDecorations: this.decorationsToRender.text.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),\r\n          displayLayer: this.props.model.displayLayer,\r\n          nodePool: this.lineNodesPool,\r\n          lineComponentsByScreenLineId\r\n        }))\r\n      }\r\n\r\n      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {\r\n        if (screenRow < startRow || screenRow >= endRow) {\r\n          children.push($(LineComponent, {\r\n            key: 'extra-' + screenLine.id,\r\n            offScreen: true,\r\n            screenLine,\r\n            screenRow,\r\n            displayLayer: this.props.model.displayLayer,\r\n            nodePool: this.lineNodesPool,\r\n            lineComponentsByScreenLineId\r\n          }))\r\n        }\r\n      })\r\n\r\n      style.width = this.getScrollWidth() + 'px'\r\n      style.height = this.getScrollHeight() + 'px'\r\n    }\r\n\r\n    children.push(this.renderPlaceholderText())\r\n    children.push(this.renderCursorsAndInput())\r\n\r\n    return $.div(\r\n      {key: 'lineTiles', ref: 'lineTiles', className: 'lines', style},\r\n      children\r\n    )\r\n  }\r", "name": "getScrollWidth", "func_location": "TextEditorComponent.renderLineTiles", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 669, "func_start_line": 612}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2670, "start_line": 2659}, "call_info": {"func_end_line": 680, "code": "  renderLineTiles () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden'\r\n    }\r\n\r\n    const children = []\r\n    children.push(this.renderHighlightDecorations())\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      const {lineComponentsByScreenLineId} = this\r\n\r\n      const startRow = this.getRenderedStartRow()\r\n      const endRow = this.getRenderedEndRow()\r\n      const rowsPerTile = this.getRowsPerTile()\r\n      const tileWidth = this.getScrollWidth()\r\n\r\n      for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = this.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileHeight = this.pixelPositionBeforeBlocksForRow(tileEndRow) - this.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n\r\n        children.push($(LinesTileComponent, {\r\n          key: this.idsByTileStartRow.get(tileStartRow),\r\n          measuredContent: this.measuredContent,\r\n          height: tileHeight,\r\n          width: tileWidth,\r\n          top: this.pixelPositionBeforeBlocksForRow(tileStartRow),\r\n          lineHeight: this.getLineHeight(),\r\n          renderedStartRow: startRow,\r\n          tileStartRow,\r\n          tileEndRow,\r\n          screenLines: this.renderedScreenLines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          lineDecorations: this.decorationsToRender.lines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          textDecorations: this.decorationsToRender.text.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),\r\n          displayLayer: this.props.model.displayLayer,\r\n          nodePool: this.lineNodesPool,\r\n          lineComponentsByScreenLineId\r\n        }))\r\n      }\r\n\r\n      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {\r\n        if (screenRow < startRow || screenRow >= endRow) {\r\n          children.push($(LineComponent, {\r\n            key: 'extra-' + screenLine.id,\r\n            offScreen: true,\r\n            screenLine,\r\n            screenRow,\r\n            displayLayer: this.props.model.displayLayer,\r\n            nodePool: this.lineNodesPool,\r\n            lineComponentsByScreenLineId\r\n          }))\r\n        }\r\n      })\r\n\r\n      style.width = this.getScrollWidth() + 'px'\r\n      style.height = this.getScrollHeight() + 'px'\r\n    }\r\n\r\n    children.push(this.renderPlaceholderText())\r\n    children.push(this.renderCursorsAndInput())\r\n\r\n    return $.div(\r\n      {key: 'lineTiles', ref: 'lineTiles', className: 'lines', style},\r\n      children\r\n    )\r\n  }\r", "name": "getScrollHeight", "func_location": "TextEditorComponent.renderLineTiles", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 670, "func_start_line": 612}}, {"func_info": {"comment": [], "name": "TextEditorComponent.renderPlaceholderText", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 716, "start_line": 707}, "call_info": {"func_end_line": 680, "code": "  renderLineTiles () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden'\r\n    }\r\n\r\n    const children = []\r\n    children.push(this.renderHighlightDecorations())\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      const {lineComponentsByScreenLineId} = this\r\n\r\n      const startRow = this.getRenderedStartRow()\r\n      const endRow = this.getRenderedEndRow()\r\n      const rowsPerTile = this.getRowsPerTile()\r\n      const tileWidth = this.getScrollWidth()\r\n\r\n      for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = this.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileHeight = this.pixelPositionBeforeBlocksForRow(tileEndRow) - this.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n\r\n        children.push($(LinesTileComponent, {\r\n          key: this.idsByTileStartRow.get(tileStartRow),\r\n          measuredContent: this.measuredContent,\r\n          height: tileHeight,\r\n          width: tileWidth,\r\n          top: this.pixelPositionBeforeBlocksForRow(tileStartRow),\r\n          lineHeight: this.getLineHeight(),\r\n          renderedStartRow: startRow,\r\n          tileStartRow,\r\n          tileEndRow,\r\n          screenLines: this.renderedScreenLines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          lineDecorations: this.decorationsToRender.lines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          textDecorations: this.decorationsToRender.text.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),\r\n          displayLayer: this.props.model.displayLayer,\r\n          nodePool: this.lineNodesPool,\r\n          lineComponentsByScreenLineId\r\n        }))\r\n      }\r\n\r\n      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {\r\n        if (screenRow < startRow || screenRow >= endRow) {\r\n          children.push($(LineComponent, {\r\n            key: 'extra-' + screenLine.id,\r\n            offScreen: true,\r\n            screenLine,\r\n            screenRow,\r\n            displayLayer: this.props.model.displayLayer,\r\n            nodePool: this.lineNodesPool,\r\n            lineComponentsByScreenLineId\r\n          }))\r\n        }\r\n      })\r\n\r\n      style.width = this.getScrollWidth() + 'px'\r\n      style.height = this.getScrollHeight() + 'px'\r\n    }\r\n\r\n    children.push(this.renderPlaceholderText())\r\n    children.push(this.renderCursorsAndInput())\r\n\r\n    return $.div(\r\n      {key: 'lineTiles', ref: 'lineTiles', className: 'lines', style},\r\n      children\r\n    )\r\n  }\r", "name": "renderPlaceholderText", "func_location": "TextEditorComponent.renderLineTiles", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 673, "func_start_line": 612}}, {"func_info": {"comment": [], "name": "TextEditorComponent.renderCursorsAndInput", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 705, "start_line": 682}, "call_info": {"func_end_line": 680, "code": "  renderLineTiles () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden'\r\n    }\r\n\r\n    const children = []\r\n    children.push(this.renderHighlightDecorations())\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      const {lineComponentsByScreenLineId} = this\r\n\r\n      const startRow = this.getRenderedStartRow()\r\n      const endRow = this.getRenderedEndRow()\r\n      const rowsPerTile = this.getRowsPerTile()\r\n      const tileWidth = this.getScrollWidth()\r\n\r\n      for (let i = 0; i < this.renderedTileStartRows.length; i++) {\r\n        const tileStartRow = this.renderedTileStartRows[i]\r\n        const tileEndRow = Math.min(endRow, tileStartRow + rowsPerTile)\r\n        const tileHeight = this.pixelPositionBeforeBlocksForRow(tileEndRow) - this.pixelPositionBeforeBlocksForRow(tileStartRow)\r\n\r\n        children.push($(LinesTileComponent, {\r\n          key: this.idsByTileStartRow.get(tileStartRow),\r\n          measuredContent: this.measuredContent,\r\n          height: tileHeight,\r\n          width: tileWidth,\r\n          top: this.pixelPositionBeforeBlocksForRow(tileStartRow),\r\n          lineHeight: this.getLineHeight(),\r\n          renderedStartRow: startRow,\r\n          tileStartRow,\r\n          tileEndRow,\r\n          screenLines: this.renderedScreenLines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          lineDecorations: this.decorationsToRender.lines.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          textDecorations: this.decorationsToRender.text.slice(tileStartRow - startRow, tileEndRow - startRow),\r\n          blockDecorations: this.decorationsToRender.blocks.get(tileStartRow),\r\n          displayLayer: this.props.model.displayLayer,\r\n          nodePool: this.lineNodesPool,\r\n          lineComponentsByScreenLineId\r\n        }))\r\n      }\r\n\r\n      this.extraRenderedScreenLines.forEach((screenLine, screenRow) => {\r\n        if (screenRow < startRow || screenRow >= endRow) {\r\n          children.push($(LineComponent, {\r\n            key: 'extra-' + screenLine.id,\r\n            offScreen: true,\r\n            screenLine,\r\n            screenRow,\r\n            displayLayer: this.props.model.displayLayer,\r\n            nodePool: this.lineNodesPool,\r\n            lineComponentsByScreenLineId\r\n          }))\r\n        }\r\n      })\r\n\r\n      style.width = this.getScrollWidth() + 'px'\r\n      style.height = this.getScrollHeight() + 'px'\r\n    }\r\n\r\n    children.push(this.renderPlaceholderText())\r\n    children.push(this.renderCursorsAndInput())\r\n\r\n    return $.div(\r\n      {key: 'lineTiles', ref: 'lineTiles', className: 'lines', style},\r\n      children\r\n    )\r\n  }\r", "name": "renderCursorsAndInput", "func_location": "TextEditorComponent.renderLineTiles", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 674, "func_start_line": 612}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getGutterContainerWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2698, "start_line": 2696}, "call_info": {"func_end_line": 575, "code": "  renderScrollContainer () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      top: 0,\r\n      bottom: 0,\r\n      backgroundColor: 'inherit'\r\n    }\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      style.left = this.getGutterContainerWidth() + 'px'\r\n      style.width = this.getScrollContainerWidth() + 'px'\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'scrollContainer',\r\n        key: 'scrollContainer',\r\n        className: 'scroll-view',\r\n        style\r\n      },\r\n      this.renderContent(),\r\n      this.renderDummyScrollbars()\r\n    )\r\n  }\r", "name": "getGutterContainerWidth", "func_location": "TextEditorComponent.renderScrollContainer", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 561, "func_start_line": 550}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollContainerWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2626, "start_line": 2620}, "call_info": {"func_end_line": 575, "code": "  renderScrollContainer () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      top: 0,\r\n      bottom: 0,\r\n      backgroundColor: 'inherit'\r\n    }\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      style.left = this.getGutterContainerWidth() + 'px'\r\n      style.width = this.getScrollContainerWidth() + 'px'\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'scrollContainer',\r\n        key: 'scrollContainer',\r\n        className: 'scroll-view',\r\n        style\r\n      },\r\n      this.renderContent(),\r\n      this.renderDummyScrollbars()\r\n    )\r\n  }\r", "name": "getScrollContainerWidth", "func_location": "TextEditorComponent.renderScrollContainer", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 562, "func_start_line": 550}}, {"func_info": {"comment": [], "name": "TextEditorComponent.renderContent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 600, "start_line": 577}, "call_info": {"func_end_line": 575, "code": "  renderScrollContainer () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      top: 0,\r\n      bottom: 0,\r\n      backgroundColor: 'inherit'\r\n    }\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      style.left = this.getGutterContainerWidth() + 'px'\r\n      style.width = this.getScrollContainerWidth() + 'px'\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'scrollContainer',\r\n        key: 'scrollContainer',\r\n        className: 'scroll-view',\r\n        style\r\n      },\r\n      this.renderContent(),\r\n      this.renderDummyScrollbars()\r\n    )\r\n  }\r", "name": "renderContent", "func_location": "TextEditorComponent.renderScrollContainer", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 572, "func_start_line": 550}}, {"func_info": {"comment": [], "name": "TextEditorComponent.renderDummyScrollbars", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 809, "start_line": 746}, "call_info": {"func_end_line": 575, "code": "  renderScrollContainer () {\r\n    const style = {\r\n      position: 'absolute',\r\n      contain: 'strict',\r\n      overflow: 'hidden',\r\n      top: 0,\r\n      bottom: 0,\r\n      backgroundColor: 'inherit'\r\n    }\r\n\r\n    if (this.hasInitialMeasurements) {\r\n      style.left = this.getGutterContainerWidth() + 'px'\r\n      style.width = this.getScrollContainerWidth() + 'px'\r\n    }\r\n\r\n    return $.div(\r\n      {\r\n        ref: 'scrollContainer',\r\n        key: 'scrollContainer',\r\n        className: 'scroll-view',\r\n        style\r\n      },\r\n      this.renderContent(),\r\n      this.renderDummyScrollbars()\r\n    )\r\n  }\r", "name": "renderDummyScrollbars", "func_location": "TextEditorComponent.renderScrollContainer", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 573, "func_start_line": 550}}, {"func_info": {"comment": ["\r\n  Section: Opening\r\n  ", " Essential: Opens the given URI in Atom asynchronously.", " If the URI is already open, the existing item for that URI will be", " activated. If no URI is given, or no registered opener can open", " the URI, a new empty {TextEditor} will be created.", "", " * `uri` (optional) A {String} containing a URI.", " * `options` (optional) {Object}", "   * `initialLine` A {Number} indicating which row to move the cursor to", "     initially. Defaults to `0`.", "   * `initialColumn` A {Number} indicating which column to move the cursor to", "     initially. Defaults to `0`.", "   * `split` Either 'left', 'right', 'up' or 'down'.", "     If 'left', the item will be opened in leftmost pane of the current active pane's row.", "     If 'right', the item will be opened in the rightmost pane of the current active pane's row. If only one pane exists in the row, a new pane will be created.", "     If 'up', the item will be opened in topmost pane of the current active pane's column.", "     If 'down', the item will be opened in the bottommost pane of the current active pane's column. If only one pane exists in the column, a new pane will be created.", "   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on", "     containing pane. Defaults to `true`.", "   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}", "     on containing pane. Defaults to `true`.", "   * `pending` A {Boolean} indicating whether or not the item should be opened", "     in a pending state. Existing pending items in a pane are replaced with", "     new pending items when they are opened.", "   * `searchAllPanes` A {Boolean}. If `true`, the workspace will attempt to", "     activate an existing item for the given URI on any pane.", "     If `false`, only the active pane will be searched for", "     an existing item for the same URI. Defaults to `false`.", "   * `location` (optional) A {String} containing the name of the location", "     in which this item should be opened (one of \"left\", \"right\", \"bottom\",", "     or \"center\"). If omitted, Atom will fall back to the last location in", "     which a user has placed an item with the same URI or, if this is a new", "     URI, the default location specified by the item. NOTE: This option", "     should almost always be omitted to honor user preference.", "", " Returns a {Promise} that resolves to the {TextEditor} for the file URI."], "name": "Workspace.open", "params": ["itemOrURI", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1079, "start_line": 925}, "call_info": {"func_end_line": 1303, "comment": [" Public: Asynchronously reopens the last-closed item's URI if it hasn't already been", " reopened.", "", " Returns a {Promise} that is resolved when the item is opened"], "code": "  reopenItem () {\r\n    const uri = this.destroyedItemURIs.pop()\r\n    if (uri) {\r\n      return this.open(uri)\r\n    } else {\r\n      return Promise.resolve()\r\n    }\r\n  }\r", "name": "open", "func_location": "Workspace.reopenItem", "args": ["uri"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1299, "func_start_line": 1296}}, {"func_info": {"comment": [], "name": "ReopenProjectMenuManager.createReopenProjectListView", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js", "end_line": 43, "start_line": 33}, "call_info": {"func_end_line": 31, "code": "  reopenProjectCommand (e) {\r\n    if (e.detail != null && e.detail.index != null) {\r\n      this.open(this.projects[e.detail.index].paths)\r\n    } else {\r\n      this.createReopenProjectListView()\r\n    }\r\n  }\r", "name": "createReopenProjectListView", "func_location": "ReopenProjectMenuManager.reopenProjectCommand", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js", "line": 29, "func_start_line": 25}}, {"func_info": {"comment": [" Public: Set the paths of the project's directories.", "", " * `projectPaths` {Array} of {String} paths.", " * `options` An optional {Object} that may contain the following keys:", "   * `mustExist` If `true`, throw an Error if any `projectPaths` do not exist. Any remaining `projectPaths` that", "     do exist will still be added to the project. Default: `false`.", "   * `exact` If `true`, only add a `projectPath` if it names an existing directory. If `false` and any `projectPath`", "     is a file or does not exist, its parent directory will be added instead. Default: `false`."], "name": "Project.setPaths", "params": ["projectPaths", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 371, "start_line": 339}, "call_info": {"func_end_line": 99, "comment": [" Layers the contents of a project's file's config", " on top of the current global config."], "code": "  replace (projectSpecification) {\r\n    if (projectSpecification == null) {\r\n      atom.config.clearProjectSettings()\r\n      this.setPaths([])\r\n    } else {\r\n      if (projectSpecification.originPath == null) {\r\n        return\r\n      }\r\n\r\n      // If no path is specified, set to directory of originPath.\r\n      if (!Array.isArray(projectSpecification.paths)) {\r\n        projectSpecification.paths = [path.dirname(projectSpecification.originPath)]\r\n      }\r\n      atom.config.resetProjectSettings(projectSpecification.config, projectSpecification.originPath)\r\n      this.setPaths(projectSpecification.paths)\r\n    }\r\n    this.emitter.emit('did-replace', projectSpecification)\r\n  }\r", "name": "setPaths", "func_location": "Project.replace", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 85, "func_start_line": 82}}, {"func_info": {"comment": [" Public: Set the paths of the project's directories.", "", " * `projectPaths` {Array} of {String} paths.", " * `options` An optional {Object} that may contain the following keys:", "   * `mustExist` If `true`, throw an Error if any `projectPaths` do not exist. Any remaining `projectPaths` that", "     do exist will still be added to the project. Default: `false`.", "   * `exact` If `true`, only add a `projectPath` if it names an existing directory. If `false` and any `projectPath`", "     is a file or does not exist, its parent directory will be added instead. Default: `false`."], "name": "Project.setPaths", "params": ["projectPaths", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 371, "start_line": 339}, "call_info": {"func_end_line": 99, "comment": [" Layers the contents of a project's file's config", " on top of the current global config."], "code": "  replace (projectSpecification) {\r\n    if (projectSpecification == null) {\r\n      atom.config.clearProjectSettings()\r\n      this.setPaths([])\r\n    } else {\r\n      if (projectSpecification.originPath == null) {\r\n        return\r\n      }\r\n\r\n      // If no path is specified, set to directory of originPath.\r\n      if (!Array.isArray(projectSpecification.paths)) {\r\n        projectSpecification.paths = [path.dirname(projectSpecification.originPath)]\r\n      }\r\n      atom.config.resetProjectSettings(projectSpecification.config, projectSpecification.originPath)\r\n      this.setPaths(projectSpecification.paths)\r\n    }\r\n    this.emitter.emit('did-replace', projectSpecification)\r\n  }\r", "name": "setPaths", "func_location": "Project.replace", "args": ["projectSpecification.paths"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 96, "func_start_line": 82}}, {"func_info": {"comment": [], "name": "PaneContainer.setRoot", "params": ["root"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 139, "start_line": 131}, "call_info": {"func_end_line": 144, "code": "  replaceChild (oldChild, newChild) {\r\n    if (oldChild !== this.root) { throw new Error('Replacing non-existent child') }\r\n    this.setRoot(newChild)\r\n  }\r", "name": "setRoot", "func_location": "PaneContainer.replaceChild", "args": ["newChild"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 143, "func_start_line": 141}}, {"func_info": {"comment": [], "name": "PaneAxis.unsubscribeFromChild", "params": ["child"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js", "end_line": 190, "start_line": 186}, "call_info": {"func_end_line": 161, "code": "  replaceChild (oldChild, newChild) {\r\n    this.unsubscribeFromChild(oldChild)\r\n    this.subscribeToChild(newChild)\r\n\r\n    newChild.setParent(this)\r\n    newChild.setContainer(this.container)\r\n\r\n    const index = this.children.indexOf(oldChild)\r\n    this.children.splice(index, 1, newChild)\r\n    this.emitter.emit('did-replace-child', {oldChild, newChild, index})\r\n  }\r", "name": "unsubscribeFromChild", "func_location": "PaneAxis.replaceChild", "args": ["oldChild"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js", "line": 152, "func_start_line": 151}}, {"func_info": {"comment": [], "name": "PaneAxis.subscribeToChild", "params": ["child"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js", "end_line": 184, "start_line": 180}, "call_info": {"func_end_line": 161, "code": "  replaceChild (oldChild, newChild) {\r\n    this.unsubscribeFromChild(oldChild)\r\n    this.subscribeToChild(newChild)\r\n\r\n    newChild.setParent(this)\r\n    newChild.setContainer(this.container)\r\n\r\n    const index = this.children.indexOf(oldChild)\r\n    this.children.splice(index, 1, newChild)\r\n    this.emitter.emit('did-replace-child', {oldChild, newChild, index})\r\n  }\r", "name": "subscribeToChild", "func_location": "PaneAxis.replaceChild", "args": ["newChild"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-axis.js", "line": 153, "func_start_line": 151}}, {"func_info": {"comment": [], "name": "TextEditorComponent.requestLineToMeasure", "params": ["row", "screenLine"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2241, "start_line": 2239}, "call_info": {"func_end_line": 2257, "code": "  requestHorizontalMeasurement (row, column) {\r\n    if (column === 0) return\r\n\r\n    const screenLine = this.props.model.screenLineForScreenRow(row)\r\n    if (screenLine) {\r\n      this.requestLineToMeasure(row, screenLine)\r\n\r\n      let columns = this.horizontalPositionsToMeasure.get(row)\r\n      if (columns == null) {\r\n        columns = []\r\n        this.horizontalPositionsToMeasure.set(row, columns)\r\n      }\r\n      columns.push(column)\r\n    }\r\n  }\r", "name": "requestLineToMeasure", "func_location": "TextEditorComponent.requestHorizontalMeasurement", "args": ["row", "screenLine"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2248, "func_start_line": 2243}}, {"func_info": {"comment": ["\r\n  Section: Native Module Compatibility\r\n  ", " Extended: Are all native modules depended on by this package correctly", " compiled against the current version of Atom?", "", " Incompatible packages cannot be activated.", "", " Returns a {Boolean}, true if compatible, false if incompatible."], "name": "Package.isCompatible", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 989, "start_line": 975}, "call_info": {"func_end_line": 784, "code": "  requireMainModule () {\r\n    if (this.bundledPackage && this.packageManager.packagesCache[this.name]) {\r\n      if (this.packageManager.packagesCache[this.name].main) {\r\n        this.mainModule = require(this.packageManager.packagesCache[this.name].main)\r\n        return this.mainModule\r\n      }\r\n    } else if (this.mainModuleRequired) {\r\n      return this.mainModule\r\n    } else if (!this.isCompatible()) {\r\n      const nativeModuleNames = this.incompatibleModules.map(m => m.name).join(', ')\r\n      console.warn(dedent `\r\n        Failed to require the main module of '${this.name}' because it requires one or more incompatible native modules (${nativeModuleNames}).\r\n        Run \\`apm rebuild\\` in the package directory and restart Atom to resolve.\\\r\n      `)\r\n    } else {\r\n      const mainModulePath = this.getMainModulePath()\r\n      if (fs.isFileSync(mainModulePath)) {\r\n        this.mainModuleRequired = true\r\n\r\n        const previousViewProviderCount = this.viewRegistry.getViewProviderCount()\r\n        const previousDeserializerCount = this.deserializerManager.getDeserializerCount()\r\n        this.mainModule = require(mainModulePath)\r\n        if ((this.viewRegistry.getViewProviderCount() === previousViewProviderCount) &&\r\n            (this.deserializerManager.getDeserializerCount() === previousDeserializerCount)) {\r\n          localStorage.setItem(this.getCanDeferMainModuleRequireStorageKey(), 'true')\r\n        }\r\n        return this.mainModule\r\n      }\r\n    }\r\n  }\r", "name": "isCompatible", "func_location": "Package.requireMainModule", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 763, "func_start_line": 755}}, {"func_info": {"comment": [], "name": "Package.getMainModulePath", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 803, "start_line": 786}, "call_info": {"func_end_line": 784, "code": "  requireMainModule () {\r\n    if (this.bundledPackage && this.packageManager.packagesCache[this.name]) {\r\n      if (this.packageManager.packagesCache[this.name].main) {\r\n        this.mainModule = require(this.packageManager.packagesCache[this.name].main)\r\n        return this.mainModule\r\n      }\r\n    } else if (this.mainModuleRequired) {\r\n      return this.mainModule\r\n    } else if (!this.isCompatible()) {\r\n      const nativeModuleNames = this.incompatibleModules.map(m => m.name).join(', ')\r\n      console.warn(dedent `\r\n        Failed to require the main module of '${this.name}' because it requires one or more incompatible native modules (${nativeModuleNames}).\r\n        Run \\`apm rebuild\\` in the package directory and restart Atom to resolve.\\\r\n      `)\r\n    } else {\r\n      const mainModulePath = this.getMainModulePath()\r\n      if (fs.isFileSync(mainModulePath)) {\r\n        this.mainModuleRequired = true\r\n\r\n        const previousViewProviderCount = this.viewRegistry.getViewProviderCount()\r\n        const previousDeserializerCount = this.deserializerManager.getDeserializerCount()\r\n        this.mainModule = require(mainModulePath)\r\n        if ((this.viewRegistry.getViewProviderCount() === previousViewProviderCount) &&\r\n            (this.deserializerManager.getDeserializerCount() === previousDeserializerCount)) {\r\n          localStorage.setItem(this.getCanDeferMainModuleRequireStorageKey(), 'true')\r\n        }\r\n        return this.mainModule\r\n      }\r\n    }\r\n  }\r", "name": "getMainModulePath", "func_location": "Package.requireMainModule", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 770, "func_start_line": 755}}, {"func_info": {"comment": [], "name": "Package.getCanDeferMainModuleRequireStorageKey", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 1043, "start_line": 1041}, "call_info": {"func_end_line": 784, "code": "  requireMainModule () {\r\n    if (this.bundledPackage && this.packageManager.packagesCache[this.name]) {\r\n      if (this.packageManager.packagesCache[this.name].main) {\r\n        this.mainModule = require(this.packageManager.packagesCache[this.name].main)\r\n        return this.mainModule\r\n      }\r\n    } else if (this.mainModuleRequired) {\r\n      return this.mainModule\r\n    } else if (!this.isCompatible()) {\r\n      const nativeModuleNames = this.incompatibleModules.map(m => m.name).join(', ')\r\n      console.warn(dedent `\r\n        Failed to require the main module of '${this.name}' because it requires one or more incompatible native modules (${nativeModuleNames}).\r\n        Run \\`apm rebuild\\` in the package directory and restart Atom to resolve.\\\r\n      `)\r\n    } else {\r\n      const mainModulePath = this.getMainModulePath()\r\n      if (fs.isFileSync(mainModulePath)) {\r\n        this.mainModuleRequired = true\r\n\r\n        const previousViewProviderCount = this.viewRegistry.getViewProviderCount()\r\n        const previousDeserializerCount = this.deserializerManager.getDeserializerCount()\r\n        this.mainModule = require(mainModulePath)\r\n        if ((this.viewRegistry.getViewProviderCount() === previousViewProviderCount) &&\r\n            (this.deserializerManager.getDeserializerCount() === previousDeserializerCount)) {\r\n          localStorage.setItem(this.getCanDeferMainModuleRequireStorageKey(), 'true')\r\n        }\r\n        return this.mainModule\r\n      }\r\n    }\r\n  }\r", "name": "getCanDeferMainModuleRequireStorageKey", "func_location": "Package.requireMainModule", "args": [null, {"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 779, "func_start_line": 755}}, {"func_info": {"comment": [], "name": "ThemeManager.resolveStylesheet", "params": ["stylesheetPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 239, "start_line": 233}, "call_info": {"func_end_line": 175, "comment": ["\r\n  Section: Private\r\n  ", " Resolve and apply the stylesheet specified by the path.", "", " This supports both CSS and Less stylesheets.", "", " * `stylesheetPath` A {String} path to the stylesheet that can be an absolute", "   path or a relative path that will be resolved against the load path.", "", " Returns a {Disposable} on which `.dispose()` can be called to remove the", " required stylesheet."], "code": "  requireStylesheet (stylesheetPath, priority, skipDeprecatedSelectorsTransformation) {\r\n    let fullPath = this.resolveStylesheet(stylesheetPath)\r\n    if (fullPath) {\r\n      const content = this.loadStylesheet(fullPath)\r\n      return this.applyStylesheet(fullPath, content, priority, skipDeprecatedSelectorsTransformation)\r\n    } else {\r\n      throw new Error(`Could not find a file at path '${stylesheetPath}'`)\r\n    }\r\n  }\r", "name": "resolveStylesheet", "func_location": "ThemeManager.requireStylesheet", "args": ["stylesheetPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 168, "func_start_line": 167}}, {"func_info": {"comment": [], "name": "ThemeManager.loadStylesheet", "params": ["stylesheetPath", "importFallbackVariables"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 247, "start_line": 241}, "call_info": {"func_end_line": 175, "comment": ["\r\n  Section: Private\r\n  ", " Resolve and apply the stylesheet specified by the path.", "", " This supports both CSS and Less stylesheets.", "", " * `stylesheetPath` A {String} path to the stylesheet that can be an absolute", "   path or a relative path that will be resolved against the load path.", "", " Returns a {Disposable} on which `.dispose()` can be called to remove the", " required stylesheet."], "code": "  requireStylesheet (stylesheetPath, priority, skipDeprecatedSelectorsTransformation) {\r\n    let fullPath = this.resolveStylesheet(stylesheetPath)\r\n    if (fullPath) {\r\n      const content = this.loadStylesheet(fullPath)\r\n      return this.applyStylesheet(fullPath, content, priority, skipDeprecatedSelectorsTransformation)\r\n    } else {\r\n      throw new Error(`Could not find a file at path '${stylesheetPath}'`)\r\n    }\r\n  }\r", "name": "loadStylesheet", "func_location": "ThemeManager.requireStylesheet", "args": ["fullPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 170, "func_start_line": 167}}, {"func_info": {"comment": [], "name": "ThemeManager.applyStylesheet", "params": ["path", "text", "priority", "skipDeprecatedSelectorsTransformation"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "end_line": 317, "start_line": 306}, "call_info": {"func_end_line": 175, "comment": ["\r\n  Section: Private\r\n  ", " Resolve and apply the stylesheet specified by the path.", "", " This supports both CSS and Less stylesheets.", "", " * `stylesheetPath` A {String} path to the stylesheet that can be an absolute", "   path or a relative path that will be resolved against the load path.", "", " Returns a {Disposable} on which `.dispose()` can be called to remove the", " required stylesheet."], "code": "  requireStylesheet (stylesheetPath, priority, skipDeprecatedSelectorsTransformation) {\r\n    let fullPath = this.resolveStylesheet(stylesheetPath)\r\n    if (fullPath) {\r\n      const content = this.loadStylesheet(fullPath)\r\n      return this.applyStylesheet(fullPath, content, priority, skipDeprecatedSelectorsTransformation)\r\n    } else {\r\n      throw new Error(`Could not find a file at path '${stylesheetPath}'`)\r\n    }\r\n  }\r", "name": "applyStylesheet", "func_location": "ThemeManager.requireStylesheet", "args": ["fullPath", "content", "priority", "skipDeprecatedSelectorsTransformation"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/theme-manager.js", "line": 171, "func_start_line": 167}}, {"func_info": {"comment": [], "name": "AtomEnvironment.getUserInitScriptPath", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1296, "start_line": 1293}, "call_info": {"func_end_line": 1310, "code": "  requireUserInitScript () {\r\n    const userInitScriptPath = this.getUserInitScriptPath()\r\n    if (userInitScriptPath) {\r\n      try {\r\n        if (fs.isFileSync(userInitScriptPath)) require(userInitScriptPath)\r\n      } catch (error) {\r\n        this.notifications.addError(`Failed to load \\`${userInitScriptPath}\\``, {\r\n          detail: error.message,\r\n          dismissable: true\r\n        })\r\n      }\r\n    }\r\n  }\r", "name": "getUserInitScriptPath", "func_location": "AtomEnvironment.requireUserInitScript", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 1299, "func_start_line": 1298}}, {"func_info": {"comment": [], "name": "Workspace.createCenter", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 262, "start_line": 250}, "call_info": {"func_end_line": 318, "code": "  reset (packageManager) {\r\n    this.packageManager = packageManager\r\n    this.emitter.dispose()\r\n    this.emitter = new Emitter()\r\n\r\n    this.paneContainers.center.destroy()\r\n    this.paneContainers.left.destroy()\r\n    this.paneContainers.right.destroy()\r\n    this.paneContainers.bottom.destroy()\r\n\r\n    _.values(this.panelContainers).forEach(panelContainer => { panelContainer.destroy() })\r\n\r\n    this.paneContainers = {\r\n      center: this.createCenter(),\r\n      left: this.createDock('left'),\r\n      right: this.createDock('right'),\r\n      bottom: this.createDock('bottom')\r\n    }\r\n    this.activePaneContainer = this.paneContainers.center\r\n    this.hasActiveTextEditor = false\r\n\r\n    this.panelContainers = {\r\n      top: new PanelContainer({viewRegistry: this.viewRegistry, location: 'top'}),\r\n      left: new PanelContainer({viewRegistry: this.viewRegistry, location: 'left', dock: this.paneContainers.left}),\r\n      right: new PanelContainer({viewRegistry: this.viewRegistry, location: 'right', dock: this.paneContainers.right}),\r\n      bottom: new PanelContainer({viewRegistry: this.viewRegistry, location: 'bottom', dock: this.paneContainers.bottom}),\r\n      header: new PanelContainer({viewRegistry: this.viewRegistry, location: 'header'}),\r\n      footer: new PanelContainer({viewRegistry: this.viewRegistry, location: 'footer'}),\r\n      modal: new PanelContainer({viewRegistry: this.viewRegistry, location: 'modal'})\r\n    }\r\n\r\n    this.originalFontSize = null\r\n    this.openers = []\r\n    this.destroyedItemURIs = []\r\n    if (this.element) {\r\n      this.element.destroy()\r\n      this.element = null\r\n    }\r\n    this.consumeServices(this.packageManager)\r\n  }\r", "name": "createCenter", "func_location": "Workspace.reset", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 292, "func_start_line": 279}}, {"func_info": {"comment": [], "name": "Workspace.createDock", "params": ["location"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 277, "start_line": 264}, "call_info": {"func_end_line": 318, "code": "  reset (packageManager) {\r\n    this.packageManager = packageManager\r\n    this.emitter.dispose()\r\n    this.emitter = new Emitter()\r\n\r\n    this.paneContainers.center.destroy()\r\n    this.paneContainers.left.destroy()\r\n    this.paneContainers.right.destroy()\r\n    this.paneContainers.bottom.destroy()\r\n\r\n    _.values(this.panelContainers).forEach(panelContainer => { panelContainer.destroy() })\r\n\r\n    this.paneContainers = {\r\n      center: this.createCenter(),\r\n      left: this.createDock('left'),\r\n      right: this.createDock('right'),\r\n      bottom: this.createDock('bottom')\r\n    }\r\n    this.activePaneContainer = this.paneContainers.center\r\n    this.hasActiveTextEditor = false\r\n\r\n    this.panelContainers = {\r\n      top: new PanelContainer({viewRegistry: this.viewRegistry, location: 'top'}),\r\n      left: new PanelContainer({viewRegistry: this.viewRegistry, location: 'left', dock: this.paneContainers.left}),\r\n      right: new PanelContainer({viewRegistry: this.viewRegistry, location: 'right', dock: this.paneContainers.right}),\r\n      bottom: new PanelContainer({viewRegistry: this.viewRegistry, location: 'bottom', dock: this.paneContainers.bottom}),\r\n      header: new PanelContainer({viewRegistry: this.viewRegistry, location: 'header'}),\r\n      footer: new PanelContainer({viewRegistry: this.viewRegistry, location: 'footer'}),\r\n      modal: new PanelContainer({viewRegistry: this.viewRegistry, location: 'modal'})\r\n    }\r\n\r\n    this.originalFontSize = null\r\n    this.openers = []\r\n    this.destroyedItemURIs = []\r\n    if (this.element) {\r\n      this.element.destroy()\r\n      this.element = null\r\n    }\r\n    this.consumeServices(this.packageManager)\r\n  }\r", "name": "createDock", "func_location": "Workspace.reset", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 293, "func_start_line": 279}}, {"func_info": {"comment": [], "name": "Workspace.createDock", "params": ["location"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 277, "start_line": 264}, "call_info": {"func_end_line": 318, "code": "  reset (packageManager) {\r\n    this.packageManager = packageManager\r\n    this.emitter.dispose()\r\n    this.emitter = new Emitter()\r\n\r\n    this.paneContainers.center.destroy()\r\n    this.paneContainers.left.destroy()\r\n    this.paneContainers.right.destroy()\r\n    this.paneContainers.bottom.destroy()\r\n\r\n    _.values(this.panelContainers).forEach(panelContainer => { panelContainer.destroy() })\r\n\r\n    this.paneContainers = {\r\n      center: this.createCenter(),\r\n      left: this.createDock('left'),\r\n      right: this.createDock('right'),\r\n      bottom: this.createDock('bottom')\r\n    }\r\n    this.activePaneContainer = this.paneContainers.center\r\n    this.hasActiveTextEditor = false\r\n\r\n    this.panelContainers = {\r\n      top: new PanelContainer({viewRegistry: this.viewRegistry, location: 'top'}),\r\n      left: new PanelContainer({viewRegistry: this.viewRegistry, location: 'left', dock: this.paneContainers.left}),\r\n      right: new PanelContainer({viewRegistry: this.viewRegistry, location: 'right', dock: this.paneContainers.right}),\r\n      bottom: new PanelContainer({viewRegistry: this.viewRegistry, location: 'bottom', dock: this.paneContainers.bottom}),\r\n      header: new PanelContainer({viewRegistry: this.viewRegistry, location: 'header'}),\r\n      footer: new PanelContainer({viewRegistry: this.viewRegistry, location: 'footer'}),\r\n      modal: new PanelContainer({viewRegistry: this.viewRegistry, location: 'modal'})\r\n    }\r\n\r\n    this.originalFontSize = null\r\n    this.openers = []\r\n    this.destroyedItemURIs = []\r\n    if (this.element) {\r\n      this.element.destroy()\r\n      this.element = null\r\n    }\r\n    this.consumeServices(this.packageManager)\r\n  }\r", "name": "createDock", "func_location": "Workspace.reset", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 294, "func_start_line": 279}}, {"func_info": {"comment": [], "name": "Workspace.createDock", "params": ["location"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 277, "start_line": 264}, "call_info": {"func_end_line": 318, "code": "  reset (packageManager) {\r\n    this.packageManager = packageManager\r\n    this.emitter.dispose()\r\n    this.emitter = new Emitter()\r\n\r\n    this.paneContainers.center.destroy()\r\n    this.paneContainers.left.destroy()\r\n    this.paneContainers.right.destroy()\r\n    this.paneContainers.bottom.destroy()\r\n\r\n    _.values(this.panelContainers).forEach(panelContainer => { panelContainer.destroy() })\r\n\r\n    this.paneContainers = {\r\n      center: this.createCenter(),\r\n      left: this.createDock('left'),\r\n      right: this.createDock('right'),\r\n      bottom: this.createDock('bottom')\r\n    }\r\n    this.activePaneContainer = this.paneContainers.center\r\n    this.hasActiveTextEditor = false\r\n\r\n    this.panelContainers = {\r\n      top: new PanelContainer({viewRegistry: this.viewRegistry, location: 'top'}),\r\n      left: new PanelContainer({viewRegistry: this.viewRegistry, location: 'left', dock: this.paneContainers.left}),\r\n      right: new PanelContainer({viewRegistry: this.viewRegistry, location: 'right', dock: this.paneContainers.right}),\r\n      bottom: new PanelContainer({viewRegistry: this.viewRegistry, location: 'bottom', dock: this.paneContainers.bottom}),\r\n      header: new PanelContainer({viewRegistry: this.viewRegistry, location: 'header'}),\r\n      footer: new PanelContainer({viewRegistry: this.viewRegistry, location: 'footer'}),\r\n      modal: new PanelContainer({viewRegistry: this.viewRegistry, location: 'modal'})\r\n    }\r\n\r\n    this.originalFontSize = null\r\n    this.openers = []\r\n    this.destroyedItemURIs = []\r\n    if (this.element) {\r\n      this.element.destroy()\r\n      this.element = null\r\n    }\r\n    this.consumeServices(this.packageManager)\r\n  }\r", "name": "createDock", "func_location": "Workspace.reset", "args": [{"type": "string"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 295, "func_start_line": 279}}, {"func_info": {"comment": [], "name": "Workspace.consumeServices", "params": [["serviceHub"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 335, "start_line": 328}, "call_info": {"func_end_line": 318, "code": "  reset (packageManager) {\r\n    this.packageManager = packageManager\r\n    this.emitter.dispose()\r\n    this.emitter = new Emitter()\r\n\r\n    this.paneContainers.center.destroy()\r\n    this.paneContainers.left.destroy()\r\n    this.paneContainers.right.destroy()\r\n    this.paneContainers.bottom.destroy()\r\n\r\n    _.values(this.panelContainers).forEach(panelContainer => { panelContainer.destroy() })\r\n\r\n    this.paneContainers = {\r\n      center: this.createCenter(),\r\n      left: this.createDock('left'),\r\n      right: this.createDock('right'),\r\n      bottom: this.createDock('bottom')\r\n    }\r\n    this.activePaneContainer = this.paneContainers.center\r\n    this.hasActiveTextEditor = false\r\n\r\n    this.panelContainers = {\r\n      top: new PanelContainer({viewRegistry: this.viewRegistry, location: 'top'}),\r\n      left: new PanelContainer({viewRegistry: this.viewRegistry, location: 'left', dock: this.paneContainers.left}),\r\n      right: new PanelContainer({viewRegistry: this.viewRegistry, location: 'right', dock: this.paneContainers.right}),\r\n      bottom: new PanelContainer({viewRegistry: this.viewRegistry, location: 'bottom', dock: this.paneContainers.bottom}),\r\n      header: new PanelContainer({viewRegistry: this.viewRegistry, location: 'header'}),\r\n      footer: new PanelContainer({viewRegistry: this.viewRegistry, location: 'footer'}),\r\n      modal: new PanelContainer({viewRegistry: this.viewRegistry, location: 'modal'})\r\n    }\r\n\r\n    this.originalFontSize = null\r\n    this.openers = []\r\n    this.destroyedItemURIs = []\r\n    if (this.element) {\r\n      this.element.destroy()\r\n      this.element = null\r\n    }\r\n    this.consumeServices(this.packageManager)\r\n  }\r", "name": "consumeServices", "func_location": "Workspace.reset", "args": [".packageManager"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 317, "func_start_line": 279}}, {"func_info": {"comment": [" Public: Set the paths of the project's directories.", "", " * `projectPaths` {Array} of {String} paths.", " * `options` An optional {Object} that may contain the following keys:", "   * `mustExist` If `true`, throw an Error if any `projectPaths` do not exist. Any remaining `projectPaths` that", "     do exist will still be added to the project. Default: `false`.", "   * `exact` If `true`, only add a `projectPath` if it names an existing directory. If `false` and any `projectPath`", "     is a file or does not exist, its parent directory will be added instead. Default: `false`."], "name": "Project.setPaths", "params": ["projectPaths", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 371, "start_line": 339}, "call_info": {"func_end_line": 72, "code": "  reset (packageManager) {\r\n    this.emitter.dispose()\r\n    this.emitter = new Emitter()\r\n\r\n    this.subscriptions.dispose()\r\n    this.subscriptions = new CompositeDisposable()\r\n\r\n    for (let buffer of this.buffers) {\r\n      if (buffer != null) buffer.destroy()\r\n    }\r\n    this.buffers = []\r\n    this.setPaths([])\r\n    this.loadPromisesByPath = {}\r\n    this.retiredBufferIDs = new Set()\r\n    this.retiredBufferPaths = new Set()\r\n    this.consumeServices(packageManager)\r\n  }\r", "name": "setPaths", "func_location": "Project.reset", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 67, "func_start_line": 56}}, {"func_info": {"comment": ["\r\n  Section: Private\r\n  "], "name": "Project.consumeServices", "params": [["serviceHub"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 615, "start_line": 594}, "call_info": {"func_end_line": 72, "code": "  reset (packageManager) {\r\n    this.emitter.dispose()\r\n    this.emitter = new Emitter()\r\n\r\n    this.subscriptions.dispose()\r\n    this.subscriptions = new CompositeDisposable()\r\n\r\n    for (let buffer of this.buffers) {\r\n      if (buffer != null) buffer.destroy()\r\n    }\r\n    this.buffers = []\r\n    this.setPaths([])\r\n    this.loadPromisesByPath = {}\r\n    this.retiredBufferIDs = new Set()\r\n    this.retiredBufferPaths = new Set()\r\n    this.consumeServices(packageManager)\r\n  }\r", "name": "consumeServices", "func_location": "Project.reset", "args": ["packageManager"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 71, "func_start_line": 56}}, {"func_info": {"comment": [], "name": "AtomEnvironment.registerDefaultDeserializers", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 303, "start_line": 294}, "call_info": {"func_end_line": 367, "code": "  async reset () {\r\n    this.deserializers.clear()\r\n    this.registerDefaultDeserializers()\r\n\r\n    this.config.clear()\r\n    this.config.setSchema(null, {type: 'object', properties: _.clone(ConfigSchema)})\r\n\r\n    this.keymaps.clear()\r\n    this.keymaps.loadBundledKeymaps()\r\n\r\n    this.commands.clear()\r\n    this.registerDefaultCommands()\r\n\r\n    this.styles.restoreSnapshot(this.initialStyleElements)\r\n\r\n    this.menu.clear()\r\n\r\n    this.clipboard.reset()\r\n\r\n    this.notifications.clear()\r\n\r\n    this.contextMenu.clear()\r\n\r\n    await this.packages.reset()\r\n    this.workspace.reset(this.packages)\r\n    this.registerDefaultOpeners()\r\n    this.project.reset(this.packages)\r\n    this.workspace.subscribeToEvents()\r\n    this.grammars.clear()\r\n    this.textEditors.clear()\r\n    this.views.clear()\r\n    this.pathsWithWaitSessions.clear()\r\n  }\r", "name": "registerDefaultDeserializers", "func_location": "AtomEnvironment.reset", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 337, "func_start_line": 335}}, {"func_info": {"comment": [], "name": "AtomEnvironment.registerDefaultCommands", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 307, "start_line": 305}, "call_info": {"func_end_line": 367, "code": "  async reset () {\r\n    this.deserializers.clear()\r\n    this.registerDefaultDeserializers()\r\n\r\n    this.config.clear()\r\n    this.config.setSchema(null, {type: 'object', properties: _.clone(ConfigSchema)})\r\n\r\n    this.keymaps.clear()\r\n    this.keymaps.loadBundledKeymaps()\r\n\r\n    this.commands.clear()\r\n    this.registerDefaultCommands()\r\n\r\n    this.styles.restoreSnapshot(this.initialStyleElements)\r\n\r\n    this.menu.clear()\r\n\r\n    this.clipboard.reset()\r\n\r\n    this.notifications.clear()\r\n\r\n    this.contextMenu.clear()\r\n\r\n    await this.packages.reset()\r\n    this.workspace.reset(this.packages)\r\n    this.registerDefaultOpeners()\r\n    this.project.reset(this.packages)\r\n    this.workspace.subscribeToEvents()\r\n    this.grammars.clear()\r\n    this.textEditors.clear()\r\n    this.views.clear()\r\n    this.pathsWithWaitSessions.clear()\r\n  }\r", "name": "registerDefaultCommands", "func_location": "AtomEnvironment.reset", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 346, "func_start_line": 335}}, {"func_info": {"comment": [], "name": "AtomEnvironment.registerDefaultOpeners", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 322, "start_line": 309}, "call_info": {"func_end_line": 367, "code": "  async reset () {\r\n    this.deserializers.clear()\r\n    this.registerDefaultDeserializers()\r\n\r\n    this.config.clear()\r\n    this.config.setSchema(null, {type: 'object', properties: _.clone(ConfigSchema)})\r\n\r\n    this.keymaps.clear()\r\n    this.keymaps.loadBundledKeymaps()\r\n\r\n    this.commands.clear()\r\n    this.registerDefaultCommands()\r\n\r\n    this.styles.restoreSnapshot(this.initialStyleElements)\r\n\r\n    this.menu.clear()\r\n\r\n    this.clipboard.reset()\r\n\r\n    this.notifications.clear()\r\n\r\n    this.contextMenu.clear()\r\n\r\n    await this.packages.reset()\r\n    this.workspace.reset(this.packages)\r\n    this.registerDefaultOpeners()\r\n    this.project.reset(this.packages)\r\n    this.workspace.subscribeToEvents()\r\n    this.grammars.clear()\r\n    this.textEditors.clear()\r\n    this.views.clear()\r\n    this.pathsWithWaitSessions.clear()\r\n  }\r", "name": "registerDefaultOpeners", "func_location": "AtomEnvironment.reset", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 360, "func_start_line": 335}}, {"func_info": {"comment": [" Deactivate all packages"], "name": "PackageManager.deactivatePackages", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 776, "start_line": 770}, "call_info": {"func_end_line": 93, "code": "  async reset () {\r\n    this.serviceHub.clear()\r\n    await this.deactivatePackages()\r\n    this.loadedPackages = {}\r\n    this.preloadedPackages = {}\r\n    this.packageStates = {}\r\n    this.packagesCache = packageJSON._atomPackages != null ? packageJSON._atomPackages : {}\r\n    this.packageDependencies = packageJSON.packageDependencies != null ? packageJSON.packageDependencies : {}\r\n    this.triggeredActivationHooks.clear()\r\n  }\r", "name": "deactivatePackages", "func_location": "PackageManager.reset", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 86, "func_start_line": 84}}, {"func_info": {"comment": [], "name": "Config._resetSettings", "params": ["newSettings", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 967, "start_line": 940}, "call_info": {"func_end_line": 988, "code": "  resetProjectSettings (newSettings, projectFile) {\r\n    // Sets the scope and source of all project settings to `path`.\r\n    newSettings = Object.assign({}, newSettings)\r\n    const oldProjectFile = this.projectFile\r\n    this.projectFile = projectFile\r\n    if (this.projectFile != null) {\r\n      this._resetSettings(newSettings, {source: this.projectFile})\r\n    } else {\r\n      this.scopedSettingsStore.removePropertiesForSource(oldProjectFile)\r\n      this.projectSettings = {}\r\n    }\r\n  }\r", "name": "_resetSettings", "func_location": "Config.resetProjectSettings", "args": ["newSettings", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 983, "func_start_line": 977}}, {"func_info": {"comment": ["\r\n  Section: Private Scoped Settings\r\n  "], "name": "Config.priorityForSource", "params": ["source"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1209, "start_line": 1200}, "call_info": {"func_end_line": 1229, "code": "  resetScopedSettings (newScopedSettings, options = {}) {\r\n    const source = options.source == null ? this.mainSource : options.source\r\n    const priority = this.priorityForSource(source)\r\n    this.scopedSettingsStore.removePropertiesForSource(source)\r\n\r\n    for (let scopeSelector in newScopedSettings) {\r\n      let settings = newScopedSettings[scopeSelector]\r\n      settings = this.makeValueConformToSchema(null, settings, {suppressException: true})\r\n      const validatedSettings = {}\r\n      validatedSettings[scopeSelector] = withoutEmptyObjects(settings)\r\n      if (validatedSettings[scopeSelector] != null) { this.scopedSettingsStore.addProperties(source, validatedSettings, {priority}) }\r\n    }\r\n\r\n    return this.emitChangeEvent()\r\n  }\r", "name": "priorityForSource", "func_location": "Config.resetScopedSettings", "args": ["source"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1217, "func_start_line": 1215}}, {"func_info": {"comment": [], "name": "Config.makeValueConformToSchema", "params": ["keyPath", "value", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1178, "start_line": 1164}, "call_info": {"func_end_line": 1229, "code": "  resetScopedSettings (newScopedSettings, options = {}) {\r\n    const source = options.source == null ? this.mainSource : options.source\r\n    const priority = this.priorityForSource(source)\r\n    this.scopedSettingsStore.removePropertiesForSource(source)\r\n\r\n    for (let scopeSelector in newScopedSettings) {\r\n      let settings = newScopedSettings[scopeSelector]\r\n      settings = this.makeValueConformToSchema(null, settings, {suppressException: true})\r\n      const validatedSettings = {}\r\n      validatedSettings[scopeSelector] = withoutEmptyObjects(settings)\r\n      if (validatedSettings[scopeSelector] != null) { this.scopedSettingsStore.addProperties(source, validatedSettings, {priority}) }\r\n    }\r\n\r\n    return this.emitChangeEvent()\r\n  }\r", "name": "makeValueConformToSchema", "func_location": "Config.resetScopedSettings", "args": [{"type": "object"}, "settings", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1222, "func_start_line": 1215}}, {"func_info": {"comment": [], "name": "Config.emitChangeEvent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1213, "start_line": 1211}, "call_info": {"func_end_line": 1229, "code": "  resetScopedSettings (newScopedSettings, options = {}) {\r\n    const source = options.source == null ? this.mainSource : options.source\r\n    const priority = this.priorityForSource(source)\r\n    this.scopedSettingsStore.removePropertiesForSource(source)\r\n\r\n    for (let scopeSelector in newScopedSettings) {\r\n      let settings = newScopedSettings[scopeSelector]\r\n      settings = this.makeValueConformToSchema(null, settings, {suppressException: true})\r\n      const validatedSettings = {}\r\n      validatedSettings[scopeSelector] = withoutEmptyObjects(settings)\r\n      if (validatedSettings[scopeSelector] != null) { this.scopedSettingsStore.addProperties(source, validatedSettings, {priority}) }\r\n    }\r\n\r\n    return this.emitChangeEvent()\r\n  }\r", "name": "emitChangeEvent", "func_location": "Config.resetScopedSettings", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1228, "func_start_line": 1215}}, {"func_info": {"comment": [" Extended: Suppress calls to handler functions registered with {::onDidChange}", " and {::observe} for the duration of `callback`. After `callback` executes,", " handlers will be called once if the value for their key-path has changed.", "", " * `callback` {Function} to execute while suppressing calls to handlers."], "name": "Config.transact", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 823, "start_line": 816}, "call_info": {"func_end_line": 1194, "name": "transact", "func_location": "Config.resetSettingsForSchemaChange", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1184, "func_start_line": 1182}}, {"func_info": {"comment": [], "name": "Config._resetSettings", "params": ["newSettings", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 967, "start_line": 940}, "call_info": {"func_end_line": 938, "comment": ["\r\n  Section: Private methods managing global settings\r\n  "], "code": "  resetUserSettings (newSettings, options = {}) {\r\n    this._resetSettings(newSettings, options)\r\n  }\r", "name": "_resetSettings", "func_location": "Config.resetUserSettings", "args": ["newSettings", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 937, "func_start_line": 936}}, {"func_info": {"comment": [], "name": "satisfies", "params": ["version", "rawRange"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js", "end_line": 173, "start_line": 166}, "call_info": {"func_end_line": 227, "code": "function resolveModulePath (relativePath, parentModule) {\r\n  if (!relativePath) return\r\n  if (!(parentModule && parentModule.filename)) return\r\n\r\n  if (!nativeModules) nativeModules = process.binding('natives')\r\n  if (nativeModules.hasOwnProperty(relativePath)) return\r\n  if (relativePath[0] === '.') return\r\n  if (isAbsolute(relativePath)) return\r\n\r\n  const folderPath = path.dirname(parentModule.filename)\r\n\r\n  const range = cache.folders[folderPath] && cache.folders[folderPath][relativePath]\r\n  if (!range) {\r\n    const builtinPath = cache.builtins[relativePath]\r\n    if (builtinPath) {\r\n      return builtinPath\r\n    } else {\r\n      return\r\n    }\r\n  }\r\n\r\n  const candidates = cache.dependencies[relativePath]\r\n  if (candidates == null) return\r\n\r\n  for (let version in candidates) {\r\n    const resolvedPath = candidates[version]\r\n    if (Module._cache[resolvedPath] || isCorePath(resolvedPath)) {\r\n      if (satisfies(version, range)) return resolvedPath\r\n    }\r\n  }\r\n}\r", "name": "satisfies", "func_location": "resolveModulePath", "args": ["version", "range"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js", "line": 224, "func_start_line": 197}}, {"func_info": {"comment": [], "name": "PackageManager.hasAtomEngine", "params": ["packagePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 435, "start_line": 432}, "call_info": {"func_end_line": 213, "comment": ["\r\n  Section: General package data\r\n  ", " Public: Resolve the given package name to a path on disk.", "", " * `name` - The {String} package name.", "", " Return a {String} folder path or undefined if it could not be resolved."], "code": "  resolvePackagePath (name) {\r\n    if (fs.isDirectorySync(name)) {\r\n      return name\r\n    }\r\n\r\n    let packagePath = fs.resolve(...this.packageDirPaths, name)\r\n    if (fs.isDirectorySync(packagePath)) {\r\n      return packagePath\r\n    }\r\n\r\n    packagePath = path.join(this.resourcePath, 'node_modules', name)\r\n    if (this.hasAtomEngine(packagePath)) {\r\n      return packagePath\r\n    }\r\n\r\n    return null\r\n  }\r", "name": "hasAtomEngine", "func_location": "PackageManager.resolvePackagePath", "args": ["packagePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 208, "func_start_line": 197}}, {"func_info": {"comment": ["\r\n  Section: Managing Paths\r\n  ", " Public: Get an {Array} of {String}s containing the paths of the project's", " directories."], "name": "Project.getPaths", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 329, "start_line": 327}, "call_info": {"func_end_line": 530, "code": "  resolvePath (uri) {\r\n    if (!uri) { return }\r\n\r\n    if (uri.match(/[A-Za-z0-9+-.]+:\\/\\//)) { // leave path alone if it has a scheme\r\n      return uri\r\n    } else {\r\n      let projectPath\r\n      if (fs.isAbsolute(uri)) {\r\n        return this.defaultDirectoryProvider.normalizePath(fs.resolveHome(uri))\r\n      // TODO: what should we do here when there are multiple directories?\r\n      } else if ((projectPath = this.getPaths()[0])) {\r\n        return this.defaultDirectoryProvider.normalizePath(fs.resolveHome(path.join(projectPath, uri)))\r\n      } else {\r\n        return undefined\r\n      }\r\n    }\r\n  }\r", "name": "getPaths", "func_location": "Project.resolvePath", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 524, "func_start_line": 514}}, {"func_info": {"comment": [], "name": "AtomApplication.resolveLegacyTestRunnerPath", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1265, "start_line": 1259}, "call_info": {"func_end_line": 1257, "code": "  resolveTestRunnerPath (testPath) {\r\n    let packageRoot\r\n    if (FindParentDir == null) {\r\n      FindParentDir = require('find-parent-dir')\r\n    }\r\n\r\n    if ((packageRoot = FindParentDir.sync(testPath, 'package.json'))) {\r\n      const packageMetadata = require(path.join(packageRoot, 'package.json'))\r\n      if (packageMetadata.atomTestRunner) {\r\n        let testRunnerPath\r\n        if (Resolve == null) {\r\n          Resolve = require('resolve')\r\n        }\r\n        if (\r\n          (testRunnerPath = Resolve.sync(packageMetadata.atomTestRunner, {\r\n            basedir: packageRoot,\r\n            extensions: Object.keys(require.extensions)\r\n          }))\r\n        ) {\r\n          return testRunnerPath\r\n        } else {\r\n          process.stderr.write(\r\n            `Error: Could not resolve test runner path '${packageMetadata.atomTestRunner}'`\r\n          )\r\n          process.exit(1)\r\n        }\r\n      }\r\n    }\r\n\r\n    return this.resolveLegacyTestRunnerPath()\r\n  }\r", "name": "resolveLegacyTestRunnerPath", "func_location": "AtomApplication.resolveTestRunnerPath", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 1256, "func_start_line": 1227}}, {"func_info": {"comment": ["\r\n  Section: Reading Style Elements\r\n  ", " Extended: Get all loaded style elements."], "name": "StyleManager.getStyleElements", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js", "end_line": 115, "start_line": 113}, "call_info": {"func_end_line": 234, "code": "  restoreSnapshot (styleElementsToRestore) {\r\n    for (let styleElement of this.getStyleElements()) {\r\n      if (!styleElementsToRestore.includes(styleElement)) {\r\n        this.removeStyleElement(styleElement)\r\n      }\r\n    }\r\n\r\n    const existingStyleElements = this.getStyleElements()\r\n    for (let styleElement of styleElementsToRestore) {\r\n      if (!existingStyleElements.includes(styleElement)) {\r\n        this.addStyleElement(styleElement)\r\n      }\r\n    }\r\n  }\r", "name": "getStyleElements", "func_location": "StyleManager.restoreSnapshot", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js", "line": 222, "func_start_line": 221}}, {"func_info": {"comment": [], "name": "StyleManager.removeStyleElement", "params": ["styleElement"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js", "end_line": 187, "start_line": 178}, "call_info": {"func_end_line": 234, "code": "  restoreSnapshot (styleElementsToRestore) {\r\n    for (let styleElement of this.getStyleElements()) {\r\n      if (!styleElementsToRestore.includes(styleElement)) {\r\n        this.removeStyleElement(styleElement)\r\n      }\r\n    }\r\n\r\n    const existingStyleElements = this.getStyleElements()\r\n    for (let styleElement of styleElementsToRestore) {\r\n      if (!existingStyleElements.includes(styleElement)) {\r\n        this.addStyleElement(styleElement)\r\n      }\r\n    }\r\n  }\r", "name": "removeStyleElement", "func_location": "StyleManager.restoreSnapshot", "args": ["styleElement"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js", "line": 224, "func_start_line": 221}}, {"func_info": {"comment": ["\r\n  Section: Reading Style Elements\r\n  ", " Extended: Get all loaded style elements."], "name": "StyleManager.getStyleElements", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js", "end_line": 115, "start_line": 113}, "call_info": {"func_end_line": 234, "code": "  restoreSnapshot (styleElementsToRestore) {\r\n    for (let styleElement of this.getStyleElements()) {\r\n      if (!styleElementsToRestore.includes(styleElement)) {\r\n        this.removeStyleElement(styleElement)\r\n      }\r\n    }\r\n\r\n    const existingStyleElements = this.getStyleElements()\r\n    for (let styleElement of styleElementsToRestore) {\r\n      if (!existingStyleElements.includes(styleElement)) {\r\n        this.addStyleElement(styleElement)\r\n      }\r\n    }\r\n  }\r", "name": "getStyleElements", "func_location": "StyleManager.restoreSnapshot", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js", "line": 228, "func_start_line": 221}}, {"func_info": {"comment": [], "name": "StyleManager.addStyleElement", "params": ["styleElement"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js", "end_line": 176, "start_line": 159}, "call_info": {"func_end_line": 234, "code": "  restoreSnapshot (styleElementsToRestore) {\r\n    for (let styleElement of this.getStyleElements()) {\r\n      if (!styleElementsToRestore.includes(styleElement)) {\r\n        this.removeStyleElement(styleElement)\r\n      }\r\n    }\r\n\r\n    const existingStyleElements = this.getStyleElements()\r\n    for (let styleElement of styleElementsToRestore) {\r\n      if (!existingStyleElements.includes(styleElement)) {\r\n        this.addStyleElement(styleElement)\r\n      }\r\n    }\r\n  }\r", "name": "addStyleElement", "func_location": "StyleManager.restoreSnapshot", "args": ["styleElement"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js", "line": 231, "func_start_line": 221}}, {"func_info": {"comment": [" Extended: Returns a {Boolean} that is `true` if the current window is in full screen mode."], "name": "AtomEnvironment.isFullScreen", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 643, "start_line": 641}, "call_info": {"func_end_line": 1189, "code": "  restoreStateIntoThisEnvironment (state) {\r\n    state.fullScreen = this.isFullScreen()\r\n    for (let pane of this.workspace.getPanes()) {\r\n      pane.destroy()\r\n    }\r\n    return this.deserialize(state)\r\n  }\r", "name": "isFullScreen", "func_location": "AtomEnvironment.restoreStateIntoThisEnvironment", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 1184, "func_start_line": 1183}}, {"func_info": {"comment": [], "name": "AtomEnvironment.deserialize", "params": ["state"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1277, "start_line": 1223}, "call_info": {"func_end_line": 1189, "code": "  restoreStateIntoThisEnvironment (state) {\r\n    state.fullScreen = this.isFullScreen()\r\n    for (let pane of this.workspace.getPanes()) {\r\n      pane.destroy()\r\n    }\r\n    return this.deserialize(state)\r\n  }\r", "name": "deserialize", "func_location": "AtomEnvironment.restoreStateIntoThisEnvironment", "args": ["state"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 1188, "func_start_line": 1183}}, {"func_info": {"comment": [" Returns true if the dimensions are useable, false if they should be ignored.", " Work around for https://github.com/atom/atom-shell/issues/473"], "name": "AtomEnvironment.isValidDimensions", "params": [["x", "y", "width", "height"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 718, "start_line": 716}, "call_info": {"func_end_line": 753, "code": "  async restoreWindowDimensions () {\r\n    if (!this.windowDimensions || !this.isValidDimensions(this.windowDimensions)) {\r\n      this.windowDimensions = this.getDefaultWindowDimensions()\r\n    }\r\n    await this.setWindowDimensions(this.windowDimensions)\r\n    return this.windowDimensions\r\n  }\r", "name": "isValidDimensions", "func_location": "AtomEnvironment.restoreWindowDimensions", "args": [".windowDimensions"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 748, "func_start_line": 747}}, {"func_info": {"comment": [], "name": "AtomEnvironment.getDefaultWindowDimensions", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 745, "start_line": 727}, "call_info": {"func_end_line": 753, "code": "  async restoreWindowDimensions () {\r\n    if (!this.windowDimensions || !this.isValidDimensions(this.windowDimensions)) {\r\n      this.windowDimensions = this.getDefaultWindowDimensions()\r\n    }\r\n    await this.setWindowDimensions(this.windowDimensions)\r\n    return this.windowDimensions\r\n  }\r", "name": "getDefaultWindowDimensions", "func_location": "AtomEnvironment.restoreWindowDimensions", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 749, "func_start_line": 747}}, {"func_info": {"comment": [" Set the dimensions of the window.", "", " The window will be centered if either the x or y coordinate is not set", " in the dimensions parameter. If x or y are omitted the window will be", " centered. If height or width are omitted only the position will be changed.", "", " * `dimensions` An {Object} with the following keys:", "   * `x` The new x coordinate.", "   * `y` The new y coordinate.", "   * `width` The new width.", "   * `height` The new height."], "name": "AtomEnvironment.setWindowDimensions", "params": [["x", "y", "width", "height"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 712, "start_line": 701}, "call_info": {"func_end_line": 753, "code": "  async restoreWindowDimensions () {\r\n    if (!this.windowDimensions || !this.isValidDimensions(this.windowDimensions)) {\r\n      this.windowDimensions = this.getDefaultWindowDimensions()\r\n    }\r\n    await this.setWindowDimensions(this.windowDimensions)\r\n    return this.windowDimensions\r\n  }\r", "name": "setWindowDimensions", "func_location": "AtomEnvironment.restoreWindowDimensions", "args": [".windowDimensions"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 751, "func_start_line": 747}}, {"func_info": {"comment": [], "name": "TextEditorComponent.startCursorBlinking", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2010, "start_line": 2001}, "call_info": {"func_end_line": 1989, "code": "  resumeCursorBlinking () {\r\n    this.cursorsBlinkedOff = true\r\n    this.startCursorBlinking()\r\n  }\r", "name": "startCursorBlinking", "func_location": "TextEditorComponent.resumeCursorBlinking", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1988, "func_start_line": 1986}}, {"func_info": {"comment": [], "name": "RecoveryFile.isReleased", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js", "end_line": 138, "start_line": 136}, "call_info": {"func_end_line": 129, "code": "  async retain () {\r\n    if (this.isReleased()) await this.store()\r\n    this.refCount++\r\n  }\r", "name": "isReleased", "func_location": "RecoveryFile.retain", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js", "line": 127, "func_start_line": 126}}, {"func_info": {"comment": [], "name": "RecoveryFile.store", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js", "end_line": 111, "start_line": 109}, "call_info": {"func_end_line": 129, "code": "  async retain () {\r\n    if (this.isReleased()) await this.store()\r\n    this.refCount++\r\n  }\r", "name": "store", "func_location": "RecoveryFile.retain", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js", "line": 127, "func_start_line": 126}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.markTokenizationComplete", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 326, "start_line": 321}, "call_info": {"func_end_line": 263, "code": "  retokenizeLines () {\r\n    if (!this.alive) return\r\n    this.fullyTokenized = false\r\n    this.tokenizedLines = new Array(this.buffer.getLineCount())\r\n    this.invalidRows = []\r\n    if (this.largeFileMode || this.grammar.name === 'Null Grammar') {\r\n      this.markTokenizationComplete()\r\n    } else {\r\n      this.invalidateRow(0)\r\n    }\r\n  }\r", "name": "markTokenizationComplete", "func_location": "TextMateLanguageMode.retokenizeLines", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 259, "func_start_line": 253}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.invalidateRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 340, "start_line": 336}, "call_info": {"func_end_line": 263, "code": "  retokenizeLines () {\r\n    if (!this.alive) return\r\n    this.fullyTokenized = false\r\n    this.tokenizedLines = new Array(this.buffer.getLineCount())\r\n    this.invalidRows = []\r\n    if (this.largeFileMode || this.grammar.name === 'Null Grammar') {\r\n      this.markTokenizationComplete()\r\n    } else {\r\n      this.invalidateRow(0)\r\n    }\r\n  }\r", "name": "invalidateRow", "func_location": "TextMateLanguageMode.retokenizeLines", "args": [{"type": "number"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 261, "func_start_line": 253}}, {"func_info": {"comment": [], "name": "readCachedJavaScript", "params": ["relativeCachePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/compile-cache.js", "end_line": 109, "start_line": 101}, "call_info": {"func_end_line": 190, "comment": [" Most of this logic is the same as the default implementation in the", " source-map-support module, but we've overridden it to read the javascript", " code from our cache directory."], "code": "    retrieveSourceMap: function (filePath) {\r\n      if (filePath === '<embedded>') {\r\n        return {map: snapshotSourceMapConsumer}\r\n      }\r\n\r\n      if (!cacheDirectory || !fs.isFileSync(filePath)) {\r\n        return null\r\n      }\r\n\r\n      try {\r\n        var sourceCode = fs.readFileSync(filePath, 'utf8')\r\n      } catch (error) {\r\n        console.warn('Error reading source file', error.stack)\r\n        return null\r\n      }\r\n\r\n      var compiler = COMPILERS[path.extname(filePath)]\r\n      if (!compiler) compiler = COMPILERS['.js']\r\n\r\n      try {\r\n        var fileData = readCachedJavaScript(compiler.getCachePath(sourceCode, filePath))\r\n      } catch (error) {\r\n        console.warn('Error reading compiled file', error.stack)\r\n        return null\r\n      }\r\n\r\n      if (fileData == null) {\r\n        return null\r\n      }\r\n\r\n      var match, lastMatch\r\n      INLINE_SOURCE_MAP_REGEXP.lastIndex = 0\r\n      while ((match = INLINE_SOURCE_MAP_REGEXP.exec(fileData))) {\r\n        lastMatch = match\r\n      }\r\n      if (lastMatch == null) {\r\n        return null\r\n      }\r\n\r\n      var sourceMappingURL = lastMatch[1]\r\n      var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1)\r\n\r\n      try {\r\n        var sourceMap = JSON.parse(new Buffer(rawData, 'base64'))\r\n      } catch (error) {\r\n        console.warn('Error parsing source map', error.stack)\r\n        return null\r\n      }\r\n\r\n      return {\r\n        map: sourceMap,\r\n        url: null\r\n      }\r\n    }\r", "name": "readCachedJavaScript", "func_location": "retrieveSourceMap", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/compile-cache.js", "line": 157, "func_start_line": 137}}, {"func_info": {"comment": [], "name": "PaneContainerElement.hasFocus", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container-element.js", "end_line": 35, "start_line": 33}, "call_info": {"func_end_line": 31, "code": "  rootChanged (root) {\r\n    const focusedElement = this.hasFocus() ? document.activeElement : null\r\n    if (this.firstChild != null) {\r\n      this.firstChild.remove()\r\n    }\r\n    if (root != null) {\r\n      const view = this.views.getView(root)\r\n      this.appendChild(view)\r\n      if (focusedElement != null) {\r\n        focusedElement.focus()\r\n      }\r\n    }\r\n  }\r", "name": "hasFocus", "func_location": "PaneContainerElement.rootChanged", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container-element.js", "line": 20, "func_start_line": 19}}, {"func_info": {"comment": [" Public: Adds the {AtomWindow} to the global window list."], "name": "AtomApplication.addWindow", "params": ["window"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 319, "start_line": 299}, "call_info": {"func_end_line": 1225, "code": "  runBenchmarks ({headless, test, resourcePath, executedFrom, pathsToOpen, env}) {\r\n    let windowInitializationScript\r\n    if (resourcePath !== this.resourcePath && !fs.existsSync(resourcePath)) {\r\n      ;({resourcePath} = this)\r\n    }\r\n\r\n    try {\r\n      windowInitializationScript = require.resolve(\r\n        path.resolve(this.devResourcePath, 'src', 'initialize-benchmark-window')\r\n      )\r\n    } catch (error) {\r\n      windowInitializationScript = require.resolve(\r\n        path.resolve(__dirname, '..', '..', 'src', 'initialize-benchmark-window')\r\n      )\r\n    }\r\n\r\n    const benchmarkPaths = []\r\n    if (pathsToOpen != null) {\r\n      for (let pathToOpen of pathsToOpen) {\r\n        benchmarkPaths.push(path.resolve(executedFrom, fs.normalize(pathToOpen)))\r\n      }\r\n    }\r\n\r\n    if (benchmarkPaths.length === 0) {\r\n      process.stderr.write('Error: Specify at least one benchmark path.\\n\\n')\r\n      process.exit(1)\r\n    }\r\n\r\n    const devMode = true\r\n    const isSpec = true\r\n    const safeMode = false\r\n    const window = new AtomWindow(this, this.fileRecoveryService, {\r\n      windowInitializationScript,\r\n      resourcePath,\r\n      headless,\r\n      test,\r\n      isSpec,\r\n      devMode,\r\n      benchmarkPaths,\r\n      safeMode,\r\n      env\r\n    })\r\n    this.addWindow(window)\r\n    return window\r\n  }\r", "name": "addWindow", "func_location": "AtomApplication.runBenchmarks", "args": ["window"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 1223, "func_start_line": 1181}}, {"func_info": {"comment": [], "name": "AtomApplication.resolveLegacyTestRunnerPath", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1265, "start_line": 1259}, "call_info": {"func_end_line": 1179, "comment": [" Opens up a new {AtomWindow} to run specs within.", "", " options -", "   :headless - A Boolean that, if true, will close the window upon", "                   completion.", "   :resourcePath - The path to include specs from.", "   :specPath - The directory to load specs from.", "   :safeMode - A Boolean that, if true, won't run specs from ~/.atom/packages", "               and ~/.atom/dev/packages, defaults to false."], "code": "  runTests ({headless, resourcePath, executedFrom, pathsToOpen, logFile, safeMode, timeout, env}) {\r\n    let windowInitializationScript\r\n    if (resourcePath !== this.resourcePath && !fs.existsSync(resourcePath)) {\r\n      ;({resourcePath} = this)\r\n    }\r\n\r\n    const timeoutInSeconds = Number.parseFloat(timeout)\r\n    if (!Number.isNaN(timeoutInSeconds)) {\r\n      const timeoutHandler = function () {\r\n        console.log(\r\n          `The test suite has timed out because it has been running for more than ${timeoutInSeconds} seconds.`\r\n        )\r\n        return process.exit(124) // Use the same exit code as the UNIX timeout util.\r\n      }\r\n      setTimeout(timeoutHandler, timeoutInSeconds * 1000)\r\n    }\r\n\r\n    try {\r\n      windowInitializationScript = require.resolve(\r\n        path.resolve(this.devResourcePath, 'src', 'initialize-test-window')\r\n      )\r\n    } catch (error) {\r\n      windowInitializationScript = require.resolve(\r\n        path.resolve(__dirname, '..', '..', 'src', 'initialize-test-window')\r\n      )\r\n    }\r\n\r\n    const testPaths = []\r\n    if (pathsToOpen != null) {\r\n      for (let pathToOpen of pathsToOpen) {\r\n        testPaths.push(path.resolve(executedFrom, fs.normalize(pathToOpen)))\r\n      }\r\n    }\r\n\r\n    if (testPaths.length === 0) {\r\n      process.stderr.write('Error: Specify at least one test path\\n\\n')\r\n      process.exit(1)\r\n    }\r\n\r\n    const legacyTestRunnerPath = this.resolveLegacyTestRunnerPath()\r\n    const testRunnerPath = this.resolveTestRunnerPath(testPaths[0])\r\n    const devMode = true\r\n    const isSpec = true\r\n    if (safeMode == null) {\r\n      safeMode = false\r\n    }\r\n    const window = new AtomWindow(this, this.fileRecoveryService, {\r\n      windowInitializationScript,\r\n      resourcePath,\r\n      headless,\r\n      isSpec,\r\n      devMode,\r\n      testRunnerPath,\r\n      legacyTestRunnerPath,\r\n      testPaths,\r\n      logFile,\r\n      safeMode,\r\n      env\r\n    })\r\n    this.addWindow(window)\r\n    if (env) window.replaceEnvironment(env)\r\n    return window\r\n  }\r", "name": "resolveLegacyTestRunnerPath", "func_location": "AtomApplication.runTests", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 1156, "func_start_line": 1117}}, {"func_info": {"comment": [], "name": "AtomApplication.resolveTestRunnerPath", "params": ["testPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1257, "start_line": 1227}, "call_info": {"func_end_line": 1179, "comment": [" Opens up a new {AtomWindow} to run specs within.", "", " options -", "   :headless - A Boolean that, if true, will close the window upon", "                   completion.", "   :resourcePath - The path to include specs from.", "   :specPath - The directory to load specs from.", "   :safeMode - A Boolean that, if true, won't run specs from ~/.atom/packages", "               and ~/.atom/dev/packages, defaults to false."], "code": "  runTests ({headless, resourcePath, executedFrom, pathsToOpen, logFile, safeMode, timeout, env}) {\r\n    let windowInitializationScript\r\n    if (resourcePath !== this.resourcePath && !fs.existsSync(resourcePath)) {\r\n      ;({resourcePath} = this)\r\n    }\r\n\r\n    const timeoutInSeconds = Number.parseFloat(timeout)\r\n    if (!Number.isNaN(timeoutInSeconds)) {\r\n      const timeoutHandler = function () {\r\n        console.log(\r\n          `The test suite has timed out because it has been running for more than ${timeoutInSeconds} seconds.`\r\n        )\r\n        return process.exit(124) // Use the same exit code as the UNIX timeout util.\r\n      }\r\n      setTimeout(timeoutHandler, timeoutInSeconds * 1000)\r\n    }\r\n\r\n    try {\r\n      windowInitializationScript = require.resolve(\r\n        path.resolve(this.devResourcePath, 'src', 'initialize-test-window')\r\n      )\r\n    } catch (error) {\r\n      windowInitializationScript = require.resolve(\r\n        path.resolve(__dirname, '..', '..', 'src', 'initialize-test-window')\r\n      )\r\n    }\r\n\r\n    const testPaths = []\r\n    if (pathsToOpen != null) {\r\n      for (let pathToOpen of pathsToOpen) {\r\n        testPaths.push(path.resolve(executedFrom, fs.normalize(pathToOpen)))\r\n      }\r\n    }\r\n\r\n    if (testPaths.length === 0) {\r\n      process.stderr.write('Error: Specify at least one test path\\n\\n')\r\n      process.exit(1)\r\n    }\r\n\r\n    const legacyTestRunnerPath = this.resolveLegacyTestRunnerPath()\r\n    const testRunnerPath = this.resolveTestRunnerPath(testPaths[0])\r\n    const devMode = true\r\n    const isSpec = true\r\n    if (safeMode == null) {\r\n      safeMode = false\r\n    }\r\n    const window = new AtomWindow(this, this.fileRecoveryService, {\r\n      windowInitializationScript,\r\n      resourcePath,\r\n      headless,\r\n      isSpec,\r\n      devMode,\r\n      testRunnerPath,\r\n      legacyTestRunnerPath,\r\n      testPaths,\r\n      logFile,\r\n      safeMode,\r\n      env\r\n    })\r\n    this.addWindow(window)\r\n    if (env) window.replaceEnvironment(env)\r\n    return window\r\n  }\r", "name": "resolveTestRunnerPath", "func_location": "AtomApplication.runTests", "args": ["testPaths."], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 1157, "func_start_line": 1117}}, {"func_info": {"comment": [" Public: Adds the {AtomWindow} to the global window list."], "name": "AtomApplication.addWindow", "params": ["window"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 319, "start_line": 299}, "call_info": {"func_end_line": 1179, "comment": [" Opens up a new {AtomWindow} to run specs within.", "", " options -", "   :headless - A Boolean that, if true, will close the window upon", "                   completion.", "   :resourcePath - The path to include specs from.", "   :specPath - The directory to load specs from.", "   :safeMode - A Boolean that, if true, won't run specs from ~/.atom/packages", "               and ~/.atom/dev/packages, defaults to false."], "code": "  runTests ({headless, resourcePath, executedFrom, pathsToOpen, logFile, safeMode, timeout, env}) {\r\n    let windowInitializationScript\r\n    if (resourcePath !== this.resourcePath && !fs.existsSync(resourcePath)) {\r\n      ;({resourcePath} = this)\r\n    }\r\n\r\n    const timeoutInSeconds = Number.parseFloat(timeout)\r\n    if (!Number.isNaN(timeoutInSeconds)) {\r\n      const timeoutHandler = function () {\r\n        console.log(\r\n          `The test suite has timed out because it has been running for more than ${timeoutInSeconds} seconds.`\r\n        )\r\n        return process.exit(124) // Use the same exit code as the UNIX timeout util.\r\n      }\r\n      setTimeout(timeoutHandler, timeoutInSeconds * 1000)\r\n    }\r\n\r\n    try {\r\n      windowInitializationScript = require.resolve(\r\n        path.resolve(this.devResourcePath, 'src', 'initialize-test-window')\r\n      )\r\n    } catch (error) {\r\n      windowInitializationScript = require.resolve(\r\n        path.resolve(__dirname, '..', '..', 'src', 'initialize-test-window')\r\n      )\r\n    }\r\n\r\n    const testPaths = []\r\n    if (pathsToOpen != null) {\r\n      for (let pathToOpen of pathsToOpen) {\r\n        testPaths.push(path.resolve(executedFrom, fs.normalize(pathToOpen)))\r\n      }\r\n    }\r\n\r\n    if (testPaths.length === 0) {\r\n      process.stderr.write('Error: Specify at least one test path\\n\\n')\r\n      process.exit(1)\r\n    }\r\n\r\n    const legacyTestRunnerPath = this.resolveLegacyTestRunnerPath()\r\n    const testRunnerPath = this.resolveTestRunnerPath(testPaths[0])\r\n    const devMode = true\r\n    const isSpec = true\r\n    if (safeMode == null) {\r\n      safeMode = false\r\n    }\r\n    const window = new AtomWindow(this, this.fileRecoveryService, {\r\n      windowInitializationScript,\r\n      resourcePath,\r\n      headless,\r\n      isSpec,\r\n      devMode,\r\n      testRunnerPath,\r\n      legacyTestRunnerPath,\r\n      testPaths,\r\n      logFile,\r\n      safeMode,\r\n      env\r\n    })\r\n    this.addWindow(window)\r\n    if (env) window.replaceEnvironment(env)\r\n    return window\r\n  }\r", "name": "addWindow", "func_location": "AtomApplication.runTests", "args": ["window"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 1176, "func_start_line": 1117}}, {"func_info": {"comment": [], "name": "Range.constructor", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js", "end_line": 11, "start_line": 7}, "call_info": {"func_end_line": 173, "name": "constructor", "func_location": "satisfies", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/module-cache.js", "line": 169, "func_start_line": 166}}, {"func_info": {"comment": [" Public: Save the given item.", "", " * `item` The item to save.", " * `nextAction` (optional) {Function} which will be called with no argument", "   after the item is successfully saved, or with the error if it failed.", "   The return value will be that of `nextAction` or `undefined` if it was not", "   provided", "", " Returns a {Promise} that resolves when the save is complete"], "name": "Pane.saveItem", "params": ["item", "nextAction"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 905, "start_line": 875}, "call_info": {"func_end_line": 853, "comment": [" Public: Save the active item."], "code": "  saveActiveItem (nextAction) {\r\n    return this.saveItem(this.getActiveItem(), nextAction)\r\n  }\r", "name": "saveItem", "func_location": "Pane.saveActiveItem", "args": [null, "nextAction"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 852, "func_start_line": 851}}, {"func_info": {"comment": [" Public: Get the active pane item in this pane.", "", " Returns a pane item."], "name": "Pane.getActiveItem", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 432, "start_line": 432}, "call_info": {"func_end_line": 853, "comment": [" Public: Save the active item."], "code": "  saveActiveItem (nextAction) {\r\n    return this.saveItem(this.getActiveItem(), nextAction)\r\n  }\r", "name": "getActiveItem", "func_location": "Pane.saveActiveItem", "args": [null, "nextAction"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 852, "func_start_line": 851}}, {"func_info": {"comment": [" Public: Prompt the user for a location and save the active item with the", " path they select.", "", " * `item` The item to save.", " * `nextAction` (optional) {Function} which will be called with no argument", "   after the item is successfully saved, or with the error if it failed.", "   The return value will be that of `nextAction` or `undefined` if it was not", "   provided"], "name": "Pane.saveItemAs", "params": ["item", "nextAction"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 954, "start_line": 915}, "call_info": {"func_end_line": 864, "comment": [" Public: Prompt the user for a location and save the active item with the", " path they select.", "", " * `nextAction` (optional) {Function} which will be called after the item is", "   successfully saved.", "", " Returns a {Promise} that resolves when the save is complete"], "code": "  saveActiveItemAs (nextAction) {\r\n    return this.saveItemAs(this.getActiveItem(), nextAction)\r\n  }\r", "name": "saveItemAs", "func_location": "Pane.saveActiveItemAs", "args": [null, "nextAction"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 863, "func_start_line": 862}}, {"func_info": {"comment": [" Public: Get the active pane item in this pane.", "", " Returns a pane item."], "name": "Pane.getActiveItem", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 432, "start_line": 432}, "call_info": {"func_end_line": 864, "comment": [" Public: Prompt the user for a location and save the active item with the", " path they select.", "", " * `nextAction` (optional) {Function} which will be called after the item is", "   successfully saved.", "", " Returns a {Promise} that resolves when the save is complete"], "code": "  saveActiveItemAs (nextAction) {\r\n    return this.saveItemAs(this.getActiveItem(), nextAction)\r\n  }\r", "name": "getActiveItem", "func_location": "Pane.saveActiveItemAs", "args": [null, "nextAction"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 863, "func_start_line": 862}}, {"func_info": {"comment": ["\r\n  Section: Pane Locations\r\n  ", " Essential: Get the {WorkspaceCenter} at the center of the editor window."], "name": "Workspace.getCenter", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1601, "start_line": 1599}, "call_info": {"func_end_line": 1398, "comment": [" Save the active pane item.", "", " If the active pane item currently has a URI according to the item's", " `.getURI` method, calls `.save` on the item. Otherwise", " {::saveActivePaneItemAs} # will be called instead. This method does nothing", " if the active item does not implement a `.save` method."], "code": "  saveActivePaneItem () {\r\n    return this.getCenter().getActivePane().saveActiveItem()\r\n  }\r", "name": "getCenter", "func_location": "Workspace.saveActivePaneItem", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1397, "func_start_line": 1396}}, {"func_info": {"comment": ["\r\n  Section: Pane Locations\r\n  ", " Essential: Get the {WorkspaceCenter} at the center of the editor window."], "name": "Workspace.getCenter", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1601, "start_line": 1599}, "call_info": {"func_end_line": 1407, "comment": [" Prompt the user for a path and save the active pane item to it.", "", " Opens a native dialog where the user selects a path on disk, then calls", " `.saveAs` on the item with the selected path. This method does nothing if", " the active item does not implement a `.saveAs` method."], "code": "  saveActivePaneItemAs () {\r\n    this.getCenter().getActivePane().saveActiveItemAs()\r\n  }\r", "name": "getCenter", "func_location": "Workspace.saveActivePaneItemAs", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1406, "func_start_line": 1405}}, {"func_info": {"comment": [], "name": "PaneContainer.getPanes", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 152, "start_line": 146}, "call_info": {"func_end_line": 176, "code": "  saveAll () {\r\n    for (let pane of this.getPanes()) { pane.saveItems() }\r\n  }\r", "name": "getPanes", "func_location": "PaneContainer.saveAll", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 175, "func_start_line": 174}}, {"func_info": {"comment": [], "name": "Workspace.getPaneContainers", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1625, "start_line": 1618}, "call_info": {"func_end_line": 1382, "comment": [" Save all pane items."], "code": "  saveAll () {\r\n    this.getPaneContainers().forEach(container => {\r\n      container.saveAll()\r\n    })\r\n  }\r", "name": "getPaneContainers", "func_location": "Workspace.saveAll", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1379, "func_start_line": 1378}}, {"func_info": {"comment": [], "name": "AtomApplication.getAllWindows", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 323, "start_line": 321}, "call_info": {"func_end_line": 981, "code": "  async saveCurrentWindowOptions (allowEmpty = false) {\r\n    if (this.quitting) return\r\n\r\n    const states = []\r\n    for (let window of this.getAllWindows()) {\r\n      if (!window.isSpec) states.push({initialPaths: window.representedDirectoryPaths})\r\n    }\r\n    states.reverse()\r\n\r\n    if (states.length > 0 || allowEmpty) {\r\n      await this.storageFolder.store('application.json', states)\r\n      this.emit('application:did-save-state')\r\n    }\r\n  }\r", "name": "getAllWindows", "func_location": "AtomApplication.saveCurrentWindowOptions", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 972, "func_start_line": 968}}, {"func_info": {"comment": [], "name": "promisify", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 1268, "start_line": 1262}, "call_info": {"func_end_line": 905, "comment": [" Public: Save the given item.", "", " * `item` The item to save.", " * `nextAction` (optional) {Function} which will be called with no argument", "   after the item is successfully saved, or with the error if it failed.", "   The return value will be that of `nextAction` or `undefined` if it was not", "   provided", "", " Returns a {Promise} that resolves when the save is complete"], "code": "  saveItem (item, nextAction) {\r\n    if (!item) return Promise.resolve()\r\n\r\n    let itemURI\r\n    if (typeof item.getURI === 'function') {\r\n      itemURI = item.getURI()\r\n    } else if (typeof item.getUri === 'function') {\r\n      itemURI = item.getUri()\r\n    }\r\n\r\n    if (itemURI != null) {\r\n      if (typeof item.save === 'function') {\r\n        return promisify(() => item.save())\r\n          .then(() => {\r\n            if (nextAction) nextAction()\r\n          })\r\n          .catch(error => {\r\n            if (nextAction) {\r\n              nextAction(error)\r\n            } else {\r\n              this.handleSaveError(error, item)\r\n            }\r\n          })\r\n      } else if (nextAction) {\r\n        nextAction()\r\n        return Promise.resolve()\r\n      }\r\n    } else {\r\n      return this.saveItemAs(item, nextAction)\r\n    }\r\n  }\r", "name": "promisify", "func_location": "Pane.saveItem", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 887, "func_start_line": 875}}, {"func_info": {"comment": [" Public: Prompt the user for a location and save the active item with the", " path they select.", "", " * `item` The item to save.", " * `nextAction` (optional) {Function} which will be called with no argument", "   after the item is successfully saved, or with the error if it failed.", "   The return value will be that of `nextAction` or `undefined` if it was not", "   provided"], "name": "Pane.saveItemAs", "params": ["item", "nextAction"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 954, "start_line": 915}, "call_info": {"func_end_line": 905, "comment": [" Public: Save the given item.", "", " * `item` The item to save.", " * `nextAction` (optional) {Function} which will be called with no argument", "   after the item is successfully saved, or with the error if it failed.", "   The return value will be that of `nextAction` or `undefined` if it was not", "   provided", "", " Returns a {Promise} that resolves when the save is complete"], "code": "  saveItem (item, nextAction) {\r\n    if (!item) return Promise.resolve()\r\n\r\n    let itemURI\r\n    if (typeof item.getURI === 'function') {\r\n      itemURI = item.getURI()\r\n    } else if (typeof item.getUri === 'function') {\r\n      itemURI = item.getUri()\r\n    }\r\n\r\n    if (itemURI != null) {\r\n      if (typeof item.save === 'function') {\r\n        return promisify(() => item.save())\r\n          .then(() => {\r\n            if (nextAction) nextAction()\r\n          })\r\n          .catch(error => {\r\n            if (nextAction) {\r\n              nextAction(error)\r\n            } else {\r\n              this.handleSaveError(error, item)\r\n            }\r\n          })\r\n      } else if (nextAction) {\r\n        nextAction()\r\n        return Promise.resolve()\r\n      }\r\n    } else {\r\n      return this.saveItemAs(item, nextAction)\r\n    }\r\n  }\r", "name": "saveItemAs", "func_location": "Pane.saveItem", "args": ["item", "nextAction"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 903, "func_start_line": 875}}, {"func_info": {"comment": ["\r\n  Section: Items\r\n  ", " Public: Get the items in this pane.", "", " Returns an {Array} of items."], "name": "Pane.getItems", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 427, "start_line": 425}, "call_info": {"func_end_line": 963, "comment": [" Public: Save all items."], "code": "  saveItems () {\r\n    for (let item of this.getItems()) {\r\n      if (typeof item.isModified === 'function' && item.isModified()) {\r\n        this.saveItem(item)\r\n      }\r\n    }\r\n  }\r", "name": "getItems", "func_location": "Pane.saveItems", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 958, "func_start_line": 957}}, {"func_info": {"comment": [" Public: Save the given item.", "", " * `item` The item to save.", " * `nextAction` (optional) {Function} which will be called with no argument", "   after the item is successfully saved, or with the error if it failed.", "   The return value will be that of `nextAction` or `undefined` if it was not", "   provided", "", " Returns a {Promise} that resolves when the save is complete"], "name": "Pane.saveItem", "params": ["item", "nextAction"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 905, "start_line": 875}, "call_info": {"func_end_line": 963, "comment": [" Public: Save all items."], "code": "  saveItems () {\r\n    for (let item of this.getItems()) {\r\n      if (typeof item.isModified === 'function' && item.isModified()) {\r\n        this.saveItem(item)\r\n      }\r\n    }\r\n  }\r", "name": "saveItem", "func_location": "Pane.saveItems", "args": ["item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 960, "func_start_line": 957}}, {"func_info": {"comment": [], "name": "AtomEnvironment.serialize", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 880, "start_line": 870}, "call_info": {"func_end_line": 1208, "code": "  async saveState (options, storageKey) {\r\n    if (this.enablePersistence && this.project) {\r\n      const state = this.serialize(options)\r\n      if (!storageKey) storageKey = this.getStateKey(this.project && this.project.getPaths())\r\n      if (storageKey) {\r\n        await this.stateStore.save(storageKey, state)\r\n      } else {\r\n        await this.applicationDelegate.setTemporaryWindowState(state)\r\n      }\r\n    }\r\n  }\r", "name": "serialize", "func_location": "AtomEnvironment.saveState", "args": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 1200, "func_start_line": 1198}}, {"func_info": {"comment": [], "name": "AtomEnvironment.getStateKey", "params": ["paths"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1286, "start_line": 1279}, "call_info": {"func_end_line": 1208, "code": "  async saveState (options, storageKey) {\r\n    if (this.enablePersistence && this.project) {\r\n      const state = this.serialize(options)\r\n      if (!storageKey) storageKey = this.getStateKey(this.project && this.project.getPaths())\r\n      if (storageKey) {\r\n        await this.stateStore.save(storageKey, state)\r\n      } else {\r\n        await this.applicationDelegate.setTemporaryWindowState(state)\r\n      }\r\n    }\r\n  }\r", "name": "getStateKey", "func_location": "AtomEnvironment.saveState", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 1201, "func_start_line": 1198}}, {"func_info": {"comment": [], "name": "TextEditorComponent.updateSync", "params": ["useScheduler"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 289, "start_line": 221}, "call_info": {"func_end_line": 219, "code": "  scheduleUpdate (nextUpdateOnlyBlinksCursors = false) {\r\n    if (!this.visible) return\r\n    if (this.suppressUpdates) return\r\n\r\n    this.nextUpdateOnlyBlinksCursors =\r\n      this.nextUpdateOnlyBlinksCursors !== false && nextUpdateOnlyBlinksCursors === true\r\n\r\n    if (this.updatedSynchronously) {\r\n      this.updateSync()\r\n    } else if (!this.updateScheduled) {\r\n      this.updateScheduled = true\r\n      etch.getScheduler().updateDocument(() => {\r\n        if (this.updateScheduled) this.updateSync(true)\r\n      })\r\n    }\r\n  }\r", "name": "updateSync", "func_location": "TextEditorComponent.scheduleUpdate", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 212, "func_start_line": 204}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.tokenizedLineForRow", "params": ["bufferRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 449, "start_line": 425}, "call_info": {"func_end_line": 526, "code": "  scopeDescriptorForPosition (position) {\r\n    let scopes\r\n    const {row, column} = this.buffer.clipPosition(Point.fromObject(position))\r\n\r\n    const iterator = this.tokenizedLineForRow(row).getTokenIterator()\r\n    while (iterator.next()) {\r\n      if (iterator.getBufferEnd() > column) {\r\n        scopes = iterator.getScopes()\r\n        break\r\n      }\r\n    }\r\n\r\n    // rebuild scope of last token if we iterated off the end\r\n    if (!scopes) {\r\n      scopes = iterator.getScopes()\r\n      scopes.push(...iterator.getScopeEnds().reverse())\r\n    }\r\n\r\n    return new ScopeDescriptor({scopes})\r\n  }\r", "name": "tokenizedLineForRow", "func_location": "TextMateLanguageMode.scopeDescriptorForPosition", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 511, "func_start_line": 507}}, {"func_info": {"comment": ["\r\n  Section - Highlighting\r\n  "], "name": "TreeSitterLanguageMode.buildHighlightIterator", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 144, "start_line": 141}, "call_info": {"func_end_line": 510, "code": "  scopeDescriptorForPosition (point) {\r\n    point = this.buffer.clipPosition(Point.fromObject(point))\r\n\r\n    // If the position is the end of a line, get scope of left character instead of newline\r\n    // This is to match TextMate behaviour, see https://github.com/atom/atom/issues/18463\r\n    if (point.column > 0 && point.column === this.buffer.lineLengthForRow(point.row)) {\r\n      point = point.copy()\r\n      point.column--\r\n    }\r\n\r\n    const iterator = this.buildHighlightIterator()\r\n    const scopes = []\r\n    for (const scope of iterator.seek(point, point.row + 1)) {\r\n      scopes.push(this.grammar.scopeNameForScopeId(scope))\r\n    }\r\n    if (point.isEqual(iterator.getPosition())) {\r\n      for (const scope of iterator.getOpenScopeIds()) {\r\n        scopes.push(this.grammar.scopeNameForScopeId(scope))\r\n      }\r\n    }\r\n    if (scopes.length === 0 || scopes[0] !== this.grammar.scopeName) {\r\n      scopes.unshift(this.grammar.scopeName)\r\n    }\r\n    return new ScopeDescriptor({scopes})\r\n  }\r", "name": "buildHighlightIterator", "func_location": "TreeSitterLanguageMode.scopeDescriptorForPosition", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 496, "func_start_line": 486}}, {"func_info": {"comment": [], "name": "TextEditorComponent.screenPositionForPixelPosition", "params": [["top", "left"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2456, "start_line": 2379}, "call_info": {"func_end_line": 1963, "code": "  screenPositionForMouseEvent (event) {\r\n    return this.screenPositionForPixelPosition(this.pixelPositionForMouseEvent(event))\r\n  }\r", "name": "screenPositionForPixelPosition", "func_location": "TextEditorComponent.screenPositionForMouseEvent", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1962, "func_start_line": 1961}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelPositionForMouseEvent", "params": [["clientX", "clientY"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1974, "start_line": 1965}, "call_info": {"func_end_line": 1963, "code": "  screenPositionForMouseEvent (event) {\r\n    return this.screenPositionForPixelPosition(this.pixelPositionForMouseEvent(event))\r\n  }\r", "name": "pixelPositionForMouseEvent", "func_location": "TextEditorComponent.screenPositionForMouseEvent", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1962, "func_start_line": 1961}}, {"func_info": {"comment": [], "name": "TextEditorComponent.rowForPixelPosition", "params": ["pixelPosition"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2348, "start_line": 2346}, "call_info": {"func_end_line": 2456, "code": "  screenPositionForPixelPosition ({top, left}) {\r\n    const {model} = this.props\r\n\r\n    const row = Math.min(\r\n      this.rowForPixelPosition(top),\r\n      model.getApproximateScreenLineCount() - 1\r\n    )\r\n\r\n    let screenLine = this.renderedScreenLineForRow(row)\r\n    if (!screenLine) {\r\n      this.requestLineToMeasure(row, model.screenLineForScreenRow(row))\r\n      this.updateSyncBeforeMeasuringContent()\r\n      this.measureContentDuringUpdateSync()\r\n      screenLine = this.renderedScreenLineForRow(row)\r\n    }\r\n\r\n    const linesClientLeft = this.refs.lineTiles.getBoundingClientRect().left\r\n    const targetClientLeft = linesClientLeft + Math.max(0, left)\r\n    const {textNodes} = this.lineComponentsByScreenLineId.get(screenLine.id)\r\n\r\n    let containingTextNodeIndex\r\n    {\r\n      let low = 0\r\n      let high = textNodes.length - 1\r\n      while (low <= high) {\r\n        const mid = low + ((high - low) >> 1)\r\n        const textNode = textNodes[mid]\r\n        const textNodeRect = clientRectForRange(textNode, 0, textNode.length)\r\n\r\n        if (targetClientLeft < textNodeRect.left) {\r\n          high = mid - 1\r\n          containingTextNodeIndex = Math.max(0, mid - 1)\r\n        } else if (targetClientLeft > textNodeRect.right) {\r\n          low = mid + 1\r\n          containingTextNodeIndex = Math.min(textNodes.length - 1, mid + 1)\r\n        } else {\r\n          containingTextNodeIndex = mid\r\n          break\r\n        }\r\n      }\r\n    }\r\n    const containingTextNode = textNodes[containingTextNodeIndex]\r\n    let characterIndex = 0\r\n    {\r\n      let low = 0\r\n      let high = containingTextNode.length - 1\r\n      while (low <= high) {\r\n        const charIndex = low + ((high - low) >> 1)\r\n        const nextCharIndex = isPairedCharacter(containingTextNode.textContent, charIndex)\r\n          ? charIndex + 2\r\n          : charIndex + 1\r\n\r\n        const rangeRect = clientRectForRange(containingTextNode, charIndex, nextCharIndex)\r\n        if (targetClientLeft < rangeRect.left) {\r\n          high = charIndex - 1\r\n          characterIndex = Math.max(0, charIndex - 1)\r\n        } else if (targetClientLeft > rangeRect.right) {\r\n          low = nextCharIndex\r\n          characterIndex = Math.min(containingTextNode.textContent.length, nextCharIndex)\r\n        } else {\r\n          if (targetClientLeft <= ((rangeRect.left + rangeRect.right) / 2)) {\r\n            characterIndex = charIndex\r\n          } else {\r\n            characterIndex = nextCharIndex\r\n          }\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    let textNodeStartColumn = 0\r\n    for (let i = 0; i < containingTextNodeIndex; i++) {\r\n      textNodeStartColumn = textNodeStartColumn + textNodes[i].length\r\n    }\r\n    const column = textNodeStartColumn + characterIndex\r\n\r\n    return Point(row, column)\r\n  }\r", "name": "rowForPixelPosition", "func_location": "TextEditorComponent.screenPositionForPixelPosition", "args": ["top"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2383, "func_start_line": 2379}}, {"func_info": {"comment": [], "name": "TextEditorComponent.renderedScreenLineForRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 961, "start_line": 956}, "call_info": {"func_end_line": 2456, "code": "  screenPositionForPixelPosition ({top, left}) {\r\n    const {model} = this.props\r\n\r\n    const row = Math.min(\r\n      this.rowForPixelPosition(top),\r\n      model.getApproximateScreenLineCount() - 1\r\n    )\r\n\r\n    let screenLine = this.renderedScreenLineForRow(row)\r\n    if (!screenLine) {\r\n      this.requestLineToMeasure(row, model.screenLineForScreenRow(row))\r\n      this.updateSyncBeforeMeasuringContent()\r\n      this.measureContentDuringUpdateSync()\r\n      screenLine = this.renderedScreenLineForRow(row)\r\n    }\r\n\r\n    const linesClientLeft = this.refs.lineTiles.getBoundingClientRect().left\r\n    const targetClientLeft = linesClientLeft + Math.max(0, left)\r\n    const {textNodes} = this.lineComponentsByScreenLineId.get(screenLine.id)\r\n\r\n    let containingTextNodeIndex\r\n    {\r\n      let low = 0\r\n      let high = textNodes.length - 1\r\n      while (low <= high) {\r\n        const mid = low + ((high - low) >> 1)\r\n        const textNode = textNodes[mid]\r\n        const textNodeRect = clientRectForRange(textNode, 0, textNode.length)\r\n\r\n        if (targetClientLeft < textNodeRect.left) {\r\n          high = mid - 1\r\n          containingTextNodeIndex = Math.max(0, mid - 1)\r\n        } else if (targetClientLeft > textNodeRect.right) {\r\n          low = mid + 1\r\n          containingTextNodeIndex = Math.min(textNodes.length - 1, mid + 1)\r\n        } else {\r\n          containingTextNodeIndex = mid\r\n          break\r\n        }\r\n      }\r\n    }\r\n    const containingTextNode = textNodes[containingTextNodeIndex]\r\n    let characterIndex = 0\r\n    {\r\n      let low = 0\r\n      let high = containingTextNode.length - 1\r\n      while (low <= high) {\r\n        const charIndex = low + ((high - low) >> 1)\r\n        const nextCharIndex = isPairedCharacter(containingTextNode.textContent, charIndex)\r\n          ? charIndex + 2\r\n          : charIndex + 1\r\n\r\n        const rangeRect = clientRectForRange(containingTextNode, charIndex, nextCharIndex)\r\n        if (targetClientLeft < rangeRect.left) {\r\n          high = charIndex - 1\r\n          characterIndex = Math.max(0, charIndex - 1)\r\n        } else if (targetClientLeft > rangeRect.right) {\r\n          low = nextCharIndex\r\n          characterIndex = Math.min(containingTextNode.textContent.length, nextCharIndex)\r\n        } else {\r\n          if (targetClientLeft <= ((rangeRect.left + rangeRect.right) / 2)) {\r\n            characterIndex = charIndex\r\n          } else {\r\n            characterIndex = nextCharIndex\r\n          }\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    let textNodeStartColumn = 0\r\n    for (let i = 0; i < containingTextNodeIndex; i++) {\r\n      textNodeStartColumn = textNodeStartColumn + textNodes[i].length\r\n    }\r\n    const column = textNodeStartColumn + characterIndex\r\n\r\n    return Point(row, column)\r\n  }\r", "name": "renderedScreenLineForRow", "func_location": "TextEditorComponent.screenPositionForPixelPosition", "args": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2387, "func_start_line": 2379}}, {"func_info": {"comment": [], "name": "TextEditorComponent.requestLineToMeasure", "params": ["row", "screenLine"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2241, "start_line": 2239}, "call_info": {"func_end_line": 2456, "code": "  screenPositionForPixelPosition ({top, left}) {\r\n    const {model} = this.props\r\n\r\n    const row = Math.min(\r\n      this.rowForPixelPosition(top),\r\n      model.getApproximateScreenLineCount() - 1\r\n    )\r\n\r\n    let screenLine = this.renderedScreenLineForRow(row)\r\n    if (!screenLine) {\r\n      this.requestLineToMeasure(row, model.screenLineForScreenRow(row))\r\n      this.updateSyncBeforeMeasuringContent()\r\n      this.measureContentDuringUpdateSync()\r\n      screenLine = this.renderedScreenLineForRow(row)\r\n    }\r\n\r\n    const linesClientLeft = this.refs.lineTiles.getBoundingClientRect().left\r\n    const targetClientLeft = linesClientLeft + Math.max(0, left)\r\n    const {textNodes} = this.lineComponentsByScreenLineId.get(screenLine.id)\r\n\r\n    let containingTextNodeIndex\r\n    {\r\n      let low = 0\r\n      let high = textNodes.length - 1\r\n      while (low <= high) {\r\n        const mid = low + ((high - low) >> 1)\r\n        const textNode = textNodes[mid]\r\n        const textNodeRect = clientRectForRange(textNode, 0, textNode.length)\r\n\r\n        if (targetClientLeft < textNodeRect.left) {\r\n          high = mid - 1\r\n          containingTextNodeIndex = Math.max(0, mid - 1)\r\n        } else if (targetClientLeft > textNodeRect.right) {\r\n          low = mid + 1\r\n          containingTextNodeIndex = Math.min(textNodes.length - 1, mid + 1)\r\n        } else {\r\n          containingTextNodeIndex = mid\r\n          break\r\n        }\r\n      }\r\n    }\r\n    const containingTextNode = textNodes[containingTextNodeIndex]\r\n    let characterIndex = 0\r\n    {\r\n      let low = 0\r\n      let high = containingTextNode.length - 1\r\n      while (low <= high) {\r\n        const charIndex = low + ((high - low) >> 1)\r\n        const nextCharIndex = isPairedCharacter(containingTextNode.textContent, charIndex)\r\n          ? charIndex + 2\r\n          : charIndex + 1\r\n\r\n        const rangeRect = clientRectForRange(containingTextNode, charIndex, nextCharIndex)\r\n        if (targetClientLeft < rangeRect.left) {\r\n          high = charIndex - 1\r\n          characterIndex = Math.max(0, charIndex - 1)\r\n        } else if (targetClientLeft > rangeRect.right) {\r\n          low = nextCharIndex\r\n          characterIndex = Math.min(containingTextNode.textContent.length, nextCharIndex)\r\n        } else {\r\n          if (targetClientLeft <= ((rangeRect.left + rangeRect.right) / 2)) {\r\n            characterIndex = charIndex\r\n          } else {\r\n            characterIndex = nextCharIndex\r\n          }\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    let textNodeStartColumn = 0\r\n    for (let i = 0; i < containingTextNodeIndex; i++) {\r\n      textNodeStartColumn = textNodeStartColumn + textNodes[i].length\r\n    }\r\n    const column = textNodeStartColumn + characterIndex\r\n\r\n    return Point(row, column)\r\n  }\r", "name": "requestLineToMeasure", "func_location": "TextEditorComponent.screenPositionForPixelPosition", "args": ["row", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2389, "func_start_line": 2379}}, {"func_info": {"comment": [], "name": "TextEditorComponent.updateSyncBeforeMeasuringContent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 387, "start_line": 364}, "call_info": {"func_end_line": 2456, "code": "  screenPositionForPixelPosition ({top, left}) {\r\n    const {model} = this.props\r\n\r\n    const row = Math.min(\r\n      this.rowForPixelPosition(top),\r\n      model.getApproximateScreenLineCount() - 1\r\n    )\r\n\r\n    let screenLine = this.renderedScreenLineForRow(row)\r\n    if (!screenLine) {\r\n      this.requestLineToMeasure(row, model.screenLineForScreenRow(row))\r\n      this.updateSyncBeforeMeasuringContent()\r\n      this.measureContentDuringUpdateSync()\r\n      screenLine = this.renderedScreenLineForRow(row)\r\n    }\r\n\r\n    const linesClientLeft = this.refs.lineTiles.getBoundingClientRect().left\r\n    const targetClientLeft = linesClientLeft + Math.max(0, left)\r\n    const {textNodes} = this.lineComponentsByScreenLineId.get(screenLine.id)\r\n\r\n    let containingTextNodeIndex\r\n    {\r\n      let low = 0\r\n      let high = textNodes.length - 1\r\n      while (low <= high) {\r\n        const mid = low + ((high - low) >> 1)\r\n        const textNode = textNodes[mid]\r\n        const textNodeRect = clientRectForRange(textNode, 0, textNode.length)\r\n\r\n        if (targetClientLeft < textNodeRect.left) {\r\n          high = mid - 1\r\n          containingTextNodeIndex = Math.max(0, mid - 1)\r\n        } else if (targetClientLeft > textNodeRect.right) {\r\n          low = mid + 1\r\n          containingTextNodeIndex = Math.min(textNodes.length - 1, mid + 1)\r\n        } else {\r\n          containingTextNodeIndex = mid\r\n          break\r\n        }\r\n      }\r\n    }\r\n    const containingTextNode = textNodes[containingTextNodeIndex]\r\n    let characterIndex = 0\r\n    {\r\n      let low = 0\r\n      let high = containingTextNode.length - 1\r\n      while (low <= high) {\r\n        const charIndex = low + ((high - low) >> 1)\r\n        const nextCharIndex = isPairedCharacter(containingTextNode.textContent, charIndex)\r\n          ? charIndex + 2\r\n          : charIndex + 1\r\n\r\n        const rangeRect = clientRectForRange(containingTextNode, charIndex, nextCharIndex)\r\n        if (targetClientLeft < rangeRect.left) {\r\n          high = charIndex - 1\r\n          characterIndex = Math.max(0, charIndex - 1)\r\n        } else if (targetClientLeft > rangeRect.right) {\r\n          low = nextCharIndex\r\n          characterIndex = Math.min(containingTextNode.textContent.length, nextCharIndex)\r\n        } else {\r\n          if (targetClientLeft <= ((rangeRect.left + rangeRect.right) / 2)) {\r\n            characterIndex = charIndex\r\n          } else {\r\n            characterIndex = nextCharIndex\r\n          }\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    let textNodeStartColumn = 0\r\n    for (let i = 0; i < containingTextNodeIndex; i++) {\r\n      textNodeStartColumn = textNodeStartColumn + textNodes[i].length\r\n    }\r\n    const column = textNodeStartColumn + characterIndex\r\n\r\n    return Point(row, column)\r\n  }\r", "name": "updateSyncBeforeMeasuringContent", "func_location": "TextEditorComponent.screenPositionForPixelPosition", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2390, "func_start_line": 2379}}, {"func_info": {"comment": [], "name": "TextEditorComponent.measureContentDuringUpdateSync", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 424, "start_line": 389}, "call_info": {"func_end_line": 2456, "code": "  screenPositionForPixelPosition ({top, left}) {\r\n    const {model} = this.props\r\n\r\n    const row = Math.min(\r\n      this.rowForPixelPosition(top),\r\n      model.getApproximateScreenLineCount() - 1\r\n    )\r\n\r\n    let screenLine = this.renderedScreenLineForRow(row)\r\n    if (!screenLine) {\r\n      this.requestLineToMeasure(row, model.screenLineForScreenRow(row))\r\n      this.updateSyncBeforeMeasuringContent()\r\n      this.measureContentDuringUpdateSync()\r\n      screenLine = this.renderedScreenLineForRow(row)\r\n    }\r\n\r\n    const linesClientLeft = this.refs.lineTiles.getBoundingClientRect().left\r\n    const targetClientLeft = linesClientLeft + Math.max(0, left)\r\n    const {textNodes} = this.lineComponentsByScreenLineId.get(screenLine.id)\r\n\r\n    let containingTextNodeIndex\r\n    {\r\n      let low = 0\r\n      let high = textNodes.length - 1\r\n      while (low <= high) {\r\n        const mid = low + ((high - low) >> 1)\r\n        const textNode = textNodes[mid]\r\n        const textNodeRect = clientRectForRange(textNode, 0, textNode.length)\r\n\r\n        if (targetClientLeft < textNodeRect.left) {\r\n          high = mid - 1\r\n          containingTextNodeIndex = Math.max(0, mid - 1)\r\n        } else if (targetClientLeft > textNodeRect.right) {\r\n          low = mid + 1\r\n          containingTextNodeIndex = Math.min(textNodes.length - 1, mid + 1)\r\n        } else {\r\n          containingTextNodeIndex = mid\r\n          break\r\n        }\r\n      }\r\n    }\r\n    const containingTextNode = textNodes[containingTextNodeIndex]\r\n    let characterIndex = 0\r\n    {\r\n      let low = 0\r\n      let high = containingTextNode.length - 1\r\n      while (low <= high) {\r\n        const charIndex = low + ((high - low) >> 1)\r\n        const nextCharIndex = isPairedCharacter(containingTextNode.textContent, charIndex)\r\n          ? charIndex + 2\r\n          : charIndex + 1\r\n\r\n        const rangeRect = clientRectForRange(containingTextNode, charIndex, nextCharIndex)\r\n        if (targetClientLeft < rangeRect.left) {\r\n          high = charIndex - 1\r\n          characterIndex = Math.max(0, charIndex - 1)\r\n        } else if (targetClientLeft > rangeRect.right) {\r\n          low = nextCharIndex\r\n          characterIndex = Math.min(containingTextNode.textContent.length, nextCharIndex)\r\n        } else {\r\n          if (targetClientLeft <= ((rangeRect.left + rangeRect.right) / 2)) {\r\n            characterIndex = charIndex\r\n          } else {\r\n            characterIndex = nextCharIndex\r\n          }\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    let textNodeStartColumn = 0\r\n    for (let i = 0; i < containingTextNodeIndex; i++) {\r\n      textNodeStartColumn = textNodeStartColumn + textNodes[i].length\r\n    }\r\n    const column = textNodeStartColumn + characterIndex\r\n\r\n    return Point(row, column)\r\n  }\r", "name": "measureContentDuringUpdateSync", "func_location": "TextEditorComponent.screenPositionForPixelPosition", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2391, "func_start_line": 2379}}, {"func_info": {"comment": [], "name": "TextEditorComponent.renderedScreenLineForRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 961, "start_line": 956}, "call_info": {"func_end_line": 2456, "code": "  screenPositionForPixelPosition ({top, left}) {\r\n    const {model} = this.props\r\n\r\n    const row = Math.min(\r\n      this.rowForPixelPosition(top),\r\n      model.getApproximateScreenLineCount() - 1\r\n    )\r\n\r\n    let screenLine = this.renderedScreenLineForRow(row)\r\n    if (!screenLine) {\r\n      this.requestLineToMeasure(row, model.screenLineForScreenRow(row))\r\n      this.updateSyncBeforeMeasuringContent()\r\n      this.measureContentDuringUpdateSync()\r\n      screenLine = this.renderedScreenLineForRow(row)\r\n    }\r\n\r\n    const linesClientLeft = this.refs.lineTiles.getBoundingClientRect().left\r\n    const targetClientLeft = linesClientLeft + Math.max(0, left)\r\n    const {textNodes} = this.lineComponentsByScreenLineId.get(screenLine.id)\r\n\r\n    let containingTextNodeIndex\r\n    {\r\n      let low = 0\r\n      let high = textNodes.length - 1\r\n      while (low <= high) {\r\n        const mid = low + ((high - low) >> 1)\r\n        const textNode = textNodes[mid]\r\n        const textNodeRect = clientRectForRange(textNode, 0, textNode.length)\r\n\r\n        if (targetClientLeft < textNodeRect.left) {\r\n          high = mid - 1\r\n          containingTextNodeIndex = Math.max(0, mid - 1)\r\n        } else if (targetClientLeft > textNodeRect.right) {\r\n          low = mid + 1\r\n          containingTextNodeIndex = Math.min(textNodes.length - 1, mid + 1)\r\n        } else {\r\n          containingTextNodeIndex = mid\r\n          break\r\n        }\r\n      }\r\n    }\r\n    const containingTextNode = textNodes[containingTextNodeIndex]\r\n    let characterIndex = 0\r\n    {\r\n      let low = 0\r\n      let high = containingTextNode.length - 1\r\n      while (low <= high) {\r\n        const charIndex = low + ((high - low) >> 1)\r\n        const nextCharIndex = isPairedCharacter(containingTextNode.textContent, charIndex)\r\n          ? charIndex + 2\r\n          : charIndex + 1\r\n\r\n        const rangeRect = clientRectForRange(containingTextNode, charIndex, nextCharIndex)\r\n        if (targetClientLeft < rangeRect.left) {\r\n          high = charIndex - 1\r\n          characterIndex = Math.max(0, charIndex - 1)\r\n        } else if (targetClientLeft > rangeRect.right) {\r\n          low = nextCharIndex\r\n          characterIndex = Math.min(containingTextNode.textContent.length, nextCharIndex)\r\n        } else {\r\n          if (targetClientLeft <= ((rangeRect.left + rangeRect.right) / 2)) {\r\n            characterIndex = charIndex\r\n          } else {\r\n            characterIndex = nextCharIndex\r\n          }\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    let textNodeStartColumn = 0\r\n    for (let i = 0; i < containingTextNodeIndex; i++) {\r\n      textNodeStartColumn = textNodeStartColumn + textNodes[i].length\r\n    }\r\n    const column = textNodeStartColumn + characterIndex\r\n\r\n    return Point(row, column)\r\n  }\r", "name": "renderedScreenLineForRow", "func_location": "TextEditorComponent.screenPositionForPixelPosition", "args": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2392, "func_start_line": 2379}}, {"func_info": {"comment": [], "name": "clientRectForRange", "params": ["textNode", "startIndex", "endIndex"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4340, "start_line": 4335}, "call_info": {"func_end_line": 2456, "code": "  screenPositionForPixelPosition ({top, left}) {\r\n    const {model} = this.props\r\n\r\n    const row = Math.min(\r\n      this.rowForPixelPosition(top),\r\n      model.getApproximateScreenLineCount() - 1\r\n    )\r\n\r\n    let screenLine = this.renderedScreenLineForRow(row)\r\n    if (!screenLine) {\r\n      this.requestLineToMeasure(row, model.screenLineForScreenRow(row))\r\n      this.updateSyncBeforeMeasuringContent()\r\n      this.measureContentDuringUpdateSync()\r\n      screenLine = this.renderedScreenLineForRow(row)\r\n    }\r\n\r\n    const linesClientLeft = this.refs.lineTiles.getBoundingClientRect().left\r\n    const targetClientLeft = linesClientLeft + Math.max(0, left)\r\n    const {textNodes} = this.lineComponentsByScreenLineId.get(screenLine.id)\r\n\r\n    let containingTextNodeIndex\r\n    {\r\n      let low = 0\r\n      let high = textNodes.length - 1\r\n      while (low <= high) {\r\n        const mid = low + ((high - low) >> 1)\r\n        const textNode = textNodes[mid]\r\n        const textNodeRect = clientRectForRange(textNode, 0, textNode.length)\r\n\r\n        if (targetClientLeft < textNodeRect.left) {\r\n          high = mid - 1\r\n          containingTextNodeIndex = Math.max(0, mid - 1)\r\n        } else if (targetClientLeft > textNodeRect.right) {\r\n          low = mid + 1\r\n          containingTextNodeIndex = Math.min(textNodes.length - 1, mid + 1)\r\n        } else {\r\n          containingTextNodeIndex = mid\r\n          break\r\n        }\r\n      }\r\n    }\r\n    const containingTextNode = textNodes[containingTextNodeIndex]\r\n    let characterIndex = 0\r\n    {\r\n      let low = 0\r\n      let high = containingTextNode.length - 1\r\n      while (low <= high) {\r\n        const charIndex = low + ((high - low) >> 1)\r\n        const nextCharIndex = isPairedCharacter(containingTextNode.textContent, charIndex)\r\n          ? charIndex + 2\r\n          : charIndex + 1\r\n\r\n        const rangeRect = clientRectForRange(containingTextNode, charIndex, nextCharIndex)\r\n        if (targetClientLeft < rangeRect.left) {\r\n          high = charIndex - 1\r\n          characterIndex = Math.max(0, charIndex - 1)\r\n        } else if (targetClientLeft > rangeRect.right) {\r\n          low = nextCharIndex\r\n          characterIndex = Math.min(containingTextNode.textContent.length, nextCharIndex)\r\n        } else {\r\n          if (targetClientLeft <= ((rangeRect.left + rangeRect.right) / 2)) {\r\n            characterIndex = charIndex\r\n          } else {\r\n            characterIndex = nextCharIndex\r\n          }\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    let textNodeStartColumn = 0\r\n    for (let i = 0; i < containingTextNodeIndex; i++) {\r\n      textNodeStartColumn = textNodeStartColumn + textNodes[i].length\r\n    }\r\n    const column = textNodeStartColumn + characterIndex\r\n\r\n    return Point(row, column)\r\n  }\r", "name": "clientRectForRange", "func_location": "TextEditorComponent.screenPositionForPixelPosition", "args": ["textNode", {"type": "number"}, "textNode.length"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2406, "func_start_line": 2379}}, {"func_info": {"comment": [], "name": "clientRectForRange", "params": ["textNode", "startIndex", "endIndex"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4340, "start_line": 4335}, "call_info": {"func_end_line": 2456, "code": "  screenPositionForPixelPosition ({top, left}) {\r\n    const {model} = this.props\r\n\r\n    const row = Math.min(\r\n      this.rowForPixelPosition(top),\r\n      model.getApproximateScreenLineCount() - 1\r\n    )\r\n\r\n    let screenLine = this.renderedScreenLineForRow(row)\r\n    if (!screenLine) {\r\n      this.requestLineToMeasure(row, model.screenLineForScreenRow(row))\r\n      this.updateSyncBeforeMeasuringContent()\r\n      this.measureContentDuringUpdateSync()\r\n      screenLine = this.renderedScreenLineForRow(row)\r\n    }\r\n\r\n    const linesClientLeft = this.refs.lineTiles.getBoundingClientRect().left\r\n    const targetClientLeft = linesClientLeft + Math.max(0, left)\r\n    const {textNodes} = this.lineComponentsByScreenLineId.get(screenLine.id)\r\n\r\n    let containingTextNodeIndex\r\n    {\r\n      let low = 0\r\n      let high = textNodes.length - 1\r\n      while (low <= high) {\r\n        const mid = low + ((high - low) >> 1)\r\n        const textNode = textNodes[mid]\r\n        const textNodeRect = clientRectForRange(textNode, 0, textNode.length)\r\n\r\n        if (targetClientLeft < textNodeRect.left) {\r\n          high = mid - 1\r\n          containingTextNodeIndex = Math.max(0, mid - 1)\r\n        } else if (targetClientLeft > textNodeRect.right) {\r\n          low = mid + 1\r\n          containingTextNodeIndex = Math.min(textNodes.length - 1, mid + 1)\r\n        } else {\r\n          containingTextNodeIndex = mid\r\n          break\r\n        }\r\n      }\r\n    }\r\n    const containingTextNode = textNodes[containingTextNodeIndex]\r\n    let characterIndex = 0\r\n    {\r\n      let low = 0\r\n      let high = containingTextNode.length - 1\r\n      while (low <= high) {\r\n        const charIndex = low + ((high - low) >> 1)\r\n        const nextCharIndex = isPairedCharacter(containingTextNode.textContent, charIndex)\r\n          ? charIndex + 2\r\n          : charIndex + 1\r\n\r\n        const rangeRect = clientRectForRange(containingTextNode, charIndex, nextCharIndex)\r\n        if (targetClientLeft < rangeRect.left) {\r\n          high = charIndex - 1\r\n          characterIndex = Math.max(0, charIndex - 1)\r\n        } else if (targetClientLeft > rangeRect.right) {\r\n          low = nextCharIndex\r\n          characterIndex = Math.min(containingTextNode.textContent.length, nextCharIndex)\r\n        } else {\r\n          if (targetClientLeft <= ((rangeRect.left + rangeRect.right) / 2)) {\r\n            characterIndex = charIndex\r\n          } else {\r\n            characterIndex = nextCharIndex\r\n          }\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    let textNodeStartColumn = 0\r\n    for (let i = 0; i < containingTextNodeIndex; i++) {\r\n      textNodeStartColumn = textNodeStartColumn + textNodes[i].length\r\n    }\r\n    const column = textNodeStartColumn + characterIndex\r\n\r\n    return Point(row, column)\r\n  }\r", "name": "clientRectForRange", "func_location": "TextEditorComponent.screenPositionForPixelPosition", "args": ["containingTextNode", "charIndex", "nextCharIndex"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2431, "func_start_line": 2379}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 251, "code": "  screenPositionForPixelPosition (pixelPosition) {\r\n    return this.getComponent().screenPositionForPixelPosition(pixelPosition)\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.screenPositionForPixelPosition", "args": ["pixelPosition"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 250, "func_start_line": 249}}, {"func_info": {"comment": [], "name": "TextEditorElement.setScrollTop", "params": ["scrollTop"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 176, "start_line": 172}, "call_info": {"func_end_line": 212, "comment": [" Essential: Scrolls the editor to the bottom."], "code": "  scrollToBottom () {\r\n    this.setScrollTop(Infinity)\r\n  }\r", "name": "setScrollTop", "func_location": "TextEditorElement.scrollToBottom", "args": ["Infinity"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 211, "func_start_line": 210}}, {"func_info": {"comment": [], "name": "TextEditorElement.setScrollTop", "params": ["scrollTop"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 176, "start_line": 172}, "call_info": {"func_end_line": 207, "comment": [" Essential: Scrolls the editor to the top."], "code": "  scrollToTop () {\r\n    this.setScrollTop(0)\r\n  }\r", "name": "setScrollTop", "func_location": "TextEditorElement.scrollToTop", "args": [{"type": "number"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 206, "func_start_line": 205}}, {"func_info": {"comment": [], "name": "LayerHighlightIterator._currentScopeId", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1062, "start_line": 1052}, "call_info": {"func_end_line": 940, "code": "  seek (targetIndex, containingTags, containingTagStartIndices) {\r\n    while (this.treeCursor.gotoParent()) {}\r\n\r\n    this.done = false\r\n    this.atEnd = true\r\n    this.closeTags.length = 0\r\n    this.openTags.length = 0\r\n    this.containingNodeTypes.length = 0\r\n    this.containingNodeChildIndices.length = 0\r\n    this.containingNodeEndIndices.length = 0\r\n\r\n    const containingTagEndIndices = []\r\n\r\n    if (targetIndex >= this.treeCursor.endIndex) {\r\n      this.done = true\r\n      return\r\n    }\r\n\r\n    let childIndex = -1\r\n    for (;;) {\r\n      this.containingNodeTypes.push(this.treeCursor.nodeType)\r\n      this.containingNodeChildIndices.push(childIndex)\r\n      this.containingNodeEndIndices.push(this.treeCursor.endIndex)\r\n\r\n      const scopeId = this._currentScopeId()\r\n      if (scopeId) {\r\n        if (this.treeCursor.startIndex < targetIndex) {\r\n          insertContainingTag(\r\n            scopeId, this.treeCursor.startIndex,\r\n            containingTags, containingTagStartIndices\r\n          )\r\n          containingTagEndIndices.push(this.treeCursor.endIndex)\r\n        } else {\r\n          this.atEnd = false\r\n          this.openTags.push(scopeId)\r\n          this._moveDown()\r\n          break\r\n        }\r\n      }\r\n\r\n      childIndex = this.treeCursor.gotoFirstChildForIndex(targetIndex)\r\n      if (childIndex === null) break\r\n      if (this.treeCursor.startIndex >= targetIndex) this.atEnd = false\r\n    }\r\n\r\n    if (this.atEnd) {\r\n      const currentIndex = this.treeCursor.endIndex\r\n      for (let i = 0, {length} = containingTags; i < length; i++) {\r\n        if (containingTagEndIndices[i] === currentIndex) {\r\n          this.closeTags.push(containingTags[i])\r\n        }\r\n      }\r\n    }\r\n\r\n    return containingTags\r\n  }\r", "name": "_currentScopeId", "func_location": "LayerHighlightIterator.seek", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 909, "func_start_line": 885}}, {"func_info": {"comment": [], "name": "insertContainingTag", "params": ["tag", "index", "tags", "indices"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1172, "start_line": 1163}, "call_info": {"func_end_line": 940, "name": "insertContainingTag", "func_location": "LayerHighlightIterator.seek", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 912, "func_start_line": 885}}, {"func_info": {"comment": [], "name": "LayerHighlightIterator._moveDown", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 1040, "start_line": 1016}, "call_info": {"func_end_line": 940, "code": "  seek (targetIndex, containingTags, containingTagStartIndices) {\r\n    while (this.treeCursor.gotoParent()) {}\r\n\r\n    this.done = false\r\n    this.atEnd = true\r\n    this.closeTags.length = 0\r\n    this.openTags.length = 0\r\n    this.containingNodeTypes.length = 0\r\n    this.containingNodeChildIndices.length = 0\r\n    this.containingNodeEndIndices.length = 0\r\n\r\n    const containingTagEndIndices = []\r\n\r\n    if (targetIndex >= this.treeCursor.endIndex) {\r\n      this.done = true\r\n      return\r\n    }\r\n\r\n    let childIndex = -1\r\n    for (;;) {\r\n      this.containingNodeTypes.push(this.treeCursor.nodeType)\r\n      this.containingNodeChildIndices.push(childIndex)\r\n      this.containingNodeEndIndices.push(this.treeCursor.endIndex)\r\n\r\n      const scopeId = this._currentScopeId()\r\n      if (scopeId) {\r\n        if (this.treeCursor.startIndex < targetIndex) {\r\n          insertContainingTag(\r\n            scopeId, this.treeCursor.startIndex,\r\n            containingTags, containingTagStartIndices\r\n          )\r\n          containingTagEndIndices.push(this.treeCursor.endIndex)\r\n        } else {\r\n          this.atEnd = false\r\n          this.openTags.push(scopeId)\r\n          this._moveDown()\r\n          break\r\n        }\r\n      }\r\n\r\n      childIndex = this.treeCursor.gotoFirstChildForIndex(targetIndex)\r\n      if (childIndex === null) break\r\n      if (this.treeCursor.startIndex >= targetIndex) this.atEnd = false\r\n    }\r\n\r\n    if (this.atEnd) {\r\n      const currentIndex = this.treeCursor.endIndex\r\n      for (let i = 0, {length} = containingTags; i < length; i++) {\r\n        if (containingTagEndIndices[i] === currentIndex) {\r\n          this.closeTags.push(containingTags[i])\r\n        }\r\n      }\r\n    }\r\n\r\n    return containingTags\r\n  }\r", "name": "_moveDown", "func_location": "LayerHighlightIterator.seek", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 920, "func_start_line": 885}}, {"func_info": {"comment": [" Public: Modifies the buffer {Range} for the selection.", "", " * `bufferRange` The new {Range} to select.", " * `options` (optional) {Object} with the keys:", "   * `preserveFolds` if `true`, the fold settings are preserved after the", "     selection moves.", "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new", "     range. Defaults to `true` if this is the most recently added selection,", "     `false` otherwise."], "name": "Selection.setBufferRange", "params": ["bufferRange", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 104, "start_line": 92}, "call_info": {"func_end_line": 284, "comment": [" Public: Selects all the text in the buffer."], "code": "  selectAll () {\r\n    this.setBufferRange(this.editor.buffer.getRange(), {autoscroll: false})\r\n  }\r", "name": "setBufferRange", "func_location": "Selection.selectAll", "args": [null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 283, "func_start_line": 282}}, {"func_info": {"comment": [], "name": "GrammarRegistry.selectGrammarWithScore", "params": ["filePath", "fileContents"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 202, "start_line": 191}, "call_info": {"func_end_line": 189, "comment": [" Extended: Select a grammar for the given file path and file contents.", "", " This picks the best match by checking the file path and contents against", " each grammar.", "", " * `filePath` A {String} file path.", " * `fileContents` A {String} of text for the file path.", "", " Returns a {Grammar}, never null."], "code": "  selectGrammar (filePath, fileContents) {\r\n    return this.selectGrammarWithScore(filePath, fileContents).grammar\r\n  }\r", "name": "selectGrammarWithScore", "func_location": "GrammarRegistry.selectGrammar", "args": ["filePath", "fileContents"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 188, "func_start_line": 187}}, {"func_info": {"comment": [], "name": "GrammarRegistry.forEachGrammar", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 311, "start_line": 305}, "call_info": {"func_end_line": 202, "name": "forEachGrammar", "func_location": "GrammarRegistry.selectGrammarWithScore", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 194, "func_start_line": 191}}, {"func_info": {"comment": [], "name": "TextEditorElement.intersectsVisibleRowRange", "params": ["startRow", "endRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 331, "start_line": 326}, "call_info": {"func_end_line": 336, "code": "  selectionIntersectsVisibleRowRange (selection) {\r\n    const {start, end} = selection.getScreenRange()\r\n    return this.intersectsVisibleRowRange(start.row, end.row + 1)\r\n  }\r", "name": "intersectsVisibleRowRange", "func_location": "TextEditorElement.selectionIntersectsVisibleRowRange", "args": ["start.row", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 335, "func_start_line": 333}}, {"func_info": {"comment": [" Public: Modifies the buffer {Range} for the selection.", "", " * `bufferRange` The new {Range} to select.", " * `options` (optional) {Object} with the keys:", "   * `preserveFolds` if `true`, the fold settings are preserved after the", "     selection moves.", "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new", "     range. Defaults to `true` if this is the most recently added selection,", "     `false` otherwise."], "name": "Selection.setBufferRange", "params": ["bufferRange", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 104, "start_line": 92}, "call_info": {"func_end_line": 397, "comment": [" Public: Selects an entire line in the buffer.", "", " * `row` The line {Number} to select (default: the row of the cursor)."], "code": "  selectLine (row, options) {\r\n    if (row != null) {\r\n      this.setBufferRange(this.editor.bufferRangeForBufferRow(row, {includeNewline: true}), options)\r\n    } else {\r\n      const startRange = this.editor.bufferRangeForBufferRow(this.marker.getStartBufferPosition().row)\r\n      const endRange = this.editor.bufferRangeForBufferRow(this.marker.getEndBufferPosition().row, {includeNewline: true})\r\n      this.setBufferRange(startRange.union(endRange), options)\r\n    }\r\n\r\n    this.linewise = true\r\n    this.wordwise = false\r\n    this.initialScreenRange = this.getScreenRange()\r\n  }\r", "name": "setBufferRange", "func_location": "Selection.selectLine", "args": [null, "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 387, "func_start_line": 385}}, {"func_info": {"comment": [" Public: Modifies the buffer {Range} for the selection.", "", " * `bufferRange` The new {Range} to select.", " * `options` (optional) {Object} with the keys:", "   * `preserveFolds` if `true`, the fold settings are preserved after the", "     selection moves.", "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new", "     range. Defaults to `true` if this is the most recently added selection,", "     `false` otherwise."], "name": "Selection.setBufferRange", "params": ["bufferRange", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 104, "start_line": 92}, "call_info": {"func_end_line": 397, "comment": [" Public: Selects an entire line in the buffer.", "", " * `row` The line {Number} to select (default: the row of the cursor)."], "code": "  selectLine (row, options) {\r\n    if (row != null) {\r\n      this.setBufferRange(this.editor.bufferRangeForBufferRow(row, {includeNewline: true}), options)\r\n    } else {\r\n      const startRange = this.editor.bufferRangeForBufferRow(this.marker.getStartBufferPosition().row)\r\n      const endRange = this.editor.bufferRangeForBufferRow(this.marker.getEndBufferPosition().row, {includeNewline: true})\r\n      this.setBufferRange(startRange.union(endRange), options)\r\n    }\r\n\r\n    this.linewise = true\r\n    this.wordwise = false\r\n    this.initialScreenRange = this.getScreenRange()\r\n  }\r", "name": "setBufferRange", "func_location": "Selection.selectLine", "args": [null, "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 391, "func_start_line": 385}}, {"func_info": {"comment": ["\r\n  Section: Managing the selection range\r\n  ", " Public: Returns the screen {Range} for the selection."], "name": "Selection.getScreenRange", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 68, "start_line": 66}, "call_info": {"func_end_line": 397, "comment": [" Public: Selects an entire line in the buffer.", "", " * `row` The line {Number} to select (default: the row of the cursor)."], "code": "  selectLine (row, options) {\r\n    if (row != null) {\r\n      this.setBufferRange(this.editor.bufferRangeForBufferRow(row, {includeNewline: true}), options)\r\n    } else {\r\n      const startRange = this.editor.bufferRangeForBufferRow(this.marker.getStartBufferPosition().row)\r\n      const endRange = this.editor.bufferRangeForBufferRow(this.marker.getEndBufferPosition().row, {includeNewline: true})\r\n      this.setBufferRange(startRange.union(endRange), options)\r\n    }\r\n\r\n    this.linewise = true\r\n    this.wordwise = false\r\n    this.initialScreenRange = this.getScreenRange()\r\n  }\r", "name": "getScreenRange", "func_location": "Selection.selectLine", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 396, "func_start_line": 385}}, {"func_info": {"comment": [" Essential: Return a matcher function for a selector.", "", " * selector, a {String} selector", " Returns {(scope: String) -> Boolean}, a matcher function returning", " true iff the scope matches the selector."], "name": "matcherForSelector", "params": ["selector"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selectors.js", "end_line": 29, "start_line": 23}, "call_info": {"func_end_line": 38, "comment": [" Essential: Return true iff the selector matches any provided scope.", "", " * {String} selector", " * {Array<String>} scopes", " Returns {Boolean} true if any scope matches the selector."], "code": "function selectorMatchesAnyScope (selector, scopes) {\r\n  return !selector || scopes.some(matcherForSelector(selector))\r\n}\r", "name": "matcherForSelector", "func_location": "selectorMatchesAnyScope", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selectors.js", "line": 37, "func_start_line": 36}}, {"func_info": {"comment": [" Public: Modifies the buffer {Range} for the selection.", "", " * `bufferRange` The new {Range} to select.", " * `options` (optional) {Object} with the keys:", "   * `preserveFolds` if `true`, the fold settings are preserved after the", "     selection moves.", "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new", "     range. Defaults to `true` if this is the most recently added selection,", "     `false` otherwise."], "name": "Selection.setBufferRange", "params": ["bufferRange", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 104, "start_line": 92}, "call_info": {"func_end_line": 372, "comment": [" Public: Modifies the selection to encompass the current word.", "", " Returns a {Range}."], "code": "  selectWord (options = {}) {\r\n    if (this.cursor.isSurroundedByWhitespace()) options.wordRegex = /[\\t ]*/\r\n    if (this.cursor.isBetweenWordAndNonWord()) {\r\n      options.includeNonWordCharacters = false\r\n    }\r\n\r\n    this.setBufferRange(this.cursor.getCurrentWordBufferRange(options), options)\r\n    this.wordwise = true\r\n    this.initialScreenRange = this.getScreenRange()\r\n  }\r", "name": "setBufferRange", "func_location": "Selection.selectWord", "args": [null, "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 369, "func_start_line": 363}}, {"func_info": {"comment": ["\r\n  Section: Managing the selection range\r\n  ", " Public: Returns the screen {Range} for the selection."], "name": "Selection.getScreenRange", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 68, "start_line": 66}, "call_info": {"func_end_line": 372, "comment": [" Public: Modifies the selection to encompass the current word.", "", " Returns a {Range}."], "code": "  selectWord (options = {}) {\r\n    if (this.cursor.isSurroundedByWhitespace()) options.wordRegex = /[\\t ]*/\r\n    if (this.cursor.isBetweenWordAndNonWord()) {\r\n      options.includeNonWordCharacters = false\r\n    }\r\n\r\n    this.setBufferRange(this.cursor.getCurrentWordBufferRange(options), options)\r\n    this.wordwise = true\r\n    this.initialScreenRange = this.getScreenRange()\r\n  }\r", "name": "getScreenRange", "func_location": "Selection.selectWord", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 371, "func_start_line": 363}}, {"func_info": {"comment": [], "name": "AtomWindow.isSpecWindow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "end_line": 384, "start_line": 382}, "call_info": {"func_end_line": 287, "code": "  sendCommand (command, ...args) {\r\n    if (this.isSpecWindow()) {\r\n      if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n        switch (command) {\r\n          case 'window:reload': return this.reload()\r\n          case 'window:toggle-dev-tools': return this.toggleDevTools()\r\n          case 'window:close': return this.close()\r\n        }\r\n      }\r\n    } else if (this.isWebViewFocused()) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    } else if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    }\r\n  }\r", "name": "isSpecWindow", "func_location": "AtomWindow.sendCommand", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "line": 274, "func_start_line": 273}}, {"func_info": {"comment": [], "name": "AtomWindow.reload", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "end_line": 392, "start_line": 386}, "call_info": {"func_end_line": 287, "code": "  sendCommand (command, ...args) {\r\n    if (this.isSpecWindow()) {\r\n      if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n        switch (command) {\r\n          case 'window:reload': return this.reload()\r\n          case 'window:toggle-dev-tools': return this.toggleDevTools()\r\n          case 'window:close': return this.close()\r\n        }\r\n      }\r\n    } else if (this.isWebViewFocused()) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    } else if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    }\r\n  }\r", "name": "reload", "func_location": "AtomWindow.sendCommand", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "line": 277, "func_start_line": 273}}, {"func_info": {"comment": [], "name": "AtomWindow.toggleDevTools", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "end_line": 411, "start_line": 409}, "call_info": {"func_end_line": 287, "code": "  sendCommand (command, ...args) {\r\n    if (this.isSpecWindow()) {\r\n      if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n        switch (command) {\r\n          case 'window:reload': return this.reload()\r\n          case 'window:toggle-dev-tools': return this.toggleDevTools()\r\n          case 'window:close': return this.close()\r\n        }\r\n      }\r\n    } else if (this.isWebViewFocused()) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    } else if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    }\r\n  }\r", "name": "toggleDevTools", "func_location": "AtomWindow.sendCommand", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "line": 278, "func_start_line": 273}}, {"func_info": {"comment": [], "name": "AtomWindow.close", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "end_line": 332, "start_line": 330}, "call_info": {"func_end_line": 287, "code": "  sendCommand (command, ...args) {\r\n    if (this.isSpecWindow()) {\r\n      if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n        switch (command) {\r\n          case 'window:reload': return this.reload()\r\n          case 'window:toggle-dev-tools': return this.toggleDevTools()\r\n          case 'window:close': return this.close()\r\n        }\r\n      }\r\n    } else if (this.isWebViewFocused()) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    } else if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    }\r\n  }\r", "name": "close", "func_location": "AtomWindow.sendCommand", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "line": 279, "func_start_line": 273}}, {"func_info": {"comment": [], "name": "AtomWindow.isWebViewFocused", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "end_line": 380, "start_line": 378}, "call_info": {"func_end_line": 287, "code": "  sendCommand (command, ...args) {\r\n    if (this.isSpecWindow()) {\r\n      if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n        switch (command) {\r\n          case 'window:reload': return this.reload()\r\n          case 'window:toggle-dev-tools': return this.toggleDevTools()\r\n          case 'window:close': return this.close()\r\n        }\r\n      }\r\n    } else if (this.isWebViewFocused()) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    } else if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    }\r\n  }\r", "name": "isWebViewFocused", "func_location": "AtomWindow.sendCommand", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "line": 282, "func_start_line": 273}}, {"func_info": {"comment": [], "name": "AtomWindow.sendCommandToBrowserWindow", "params": ["command", "args"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "end_line": 298, "start_line": 293}, "call_info": {"func_end_line": 287, "code": "  sendCommand (command, ...args) {\r\n    if (this.isSpecWindow()) {\r\n      if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n        switch (command) {\r\n          case 'window:reload': return this.reload()\r\n          case 'window:toggle-dev-tools': return this.toggleDevTools()\r\n          case 'window:close': return this.close()\r\n        }\r\n      }\r\n    } else if (this.isWebViewFocused()) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    } else if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    }\r\n  }\r", "name": "sendCommandToBrowserWindow", "func_location": "AtomWindow.sendCommand", "args": ["command", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "line": 283, "func_start_line": 273}}, {"func_info": {"comment": [], "name": "AtomWindow.sendCommandToBrowserWindow", "params": ["command", "args"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "end_line": 298, "start_line": 293}, "call_info": {"func_end_line": 287, "code": "  sendCommand (command, ...args) {\r\n    if (this.isSpecWindow()) {\r\n      if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n        switch (command) {\r\n          case 'window:reload': return this.reload()\r\n          case 'window:toggle-dev-tools': return this.toggleDevTools()\r\n          case 'window:close': return this.close()\r\n        }\r\n      }\r\n    } else if (this.isWebViewFocused()) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    } else if (!this.atomApplication.sendCommandToFirstResponder(command)) {\r\n      this.sendCommandToBrowserWindow(command, ...args)\r\n    }\r\n  }\r", "name": "sendCommandToBrowserWindow", "func_location": "AtomWindow.sendCommand", "args": ["command", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-window.js", "line": 285, "func_start_line": 273}}, {"func_info": {"comment": [" Public: Returns the currently focused {AtomWindow} or undefined if none."], "name": "AtomApplication.focusedWindow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 750, "start_line": 748}, "call_info": {"func_end_line": 666, "comment": [" Public: Executes the given command.", "", " If it isn't handled globally, delegate to the currently focused window.", "", " command - The string representing the command.", " args - The optional arguments to pass along."], "code": "  sendCommand (command, ...args) {\r\n    if (!this.emit(command, ...args)) {\r\n      const focusedWindow = this.focusedWindow()\r\n      if (focusedWindow) {\r\n        return focusedWindow.sendCommand(command, ...args)\r\n      } else {\r\n        return this.sendCommandToFirstResponder(command)\r\n      }\r\n    }\r\n  }\r", "name": "focusedWindow", "func_location": "AtomApplication.sendCommand", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 659, "func_start_line": 657}}, {"func_info": {"comment": [" Translates the command into macOS action and sends it to application's first", " responder."], "name": "AtomApplication.sendCommandToFirstResponder", "params": ["command"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 711, "start_line": 685}, "call_info": {"func_end_line": 666, "comment": [" Public: Executes the given command.", "", " If it isn't handled globally, delegate to the currently focused window.", "", " command - The string representing the command.", " args - The optional arguments to pass along."], "code": "  sendCommand (command, ...args) {\r\n    if (!this.emit(command, ...args)) {\r\n      const focusedWindow = this.focusedWindow()\r\n      if (focusedWindow) {\r\n        return focusedWindow.sendCommand(command, ...args)\r\n      } else {\r\n        return this.sendCommandToFirstResponder(command)\r\n      }\r\n    }\r\n  }\r", "name": "sendCommandToFirstResponder", "func_location": "AtomApplication.sendCommand", "args": ["command"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 663, "func_start_line": 657}}, {"func_info": {"comment": [" Translates the command into macOS action and sends it to application's first", " responder."], "name": "AtomApplication.sendCommandToFirstResponder", "params": ["command"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 711, "start_line": 685}, "call_info": {"func_end_line": 681, "comment": [" Public: Executes the given command on the given window.", "", " command - The string representing the command.", " atomWindow - The {AtomWindow} to send the command to.", " args - The optional arguments to pass along."], "code": "  sendCommandToWindow (command, atomWindow, ...args) {\r\n    if (!this.emit(command, ...args)) {\r\n      if (atomWindow) {\r\n        return atomWindow.sendCommand(command, ...args)\r\n      } else {\r\n        return this.sendCommandToFirstResponder(command)\r\n      }\r\n    }\r\n  }\r", "name": "sendCommandToFirstResponder", "func_location": "AtomApplication.sendCommandToWindow", "args": ["command"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 678, "func_start_line": 673}}, {"func_info": {"comment": [], "name": "Workspace.getPackageNamesWithActiveGrammars", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 408, "start_line": 383}, "call_info": {"func_end_line": 353, "comment": [" Called by the Serializable mixin during serialization."], "code": "  serialize () {\r\n    return {\r\n      deserializer: 'Workspace',\r\n      packagesWithActiveGrammars: this.getPackageNamesWithActiveGrammars(),\r\n      destroyedItemURIs: this.destroyedItemURIs.slice(),\r\n      // Ensure deserializing 1.17 state with pre 1.17 Atom does not error\r\n      // TODO: Remove after 1.17 has been on stable for a while\r\n      paneContainer: {version: 2},\r\n      paneContainers: {\r\n        center: this.paneContainers.center.serialize(),\r\n        left: this.paneContainers.left.serialize(),\r\n        right: this.paneContainers.right.serialize(),\r\n        bottom: this.paneContainers.bottom.serialize()\r\n      }\r\n    }\r\n  }\r", "name": "getPackageNamesWithActiveGrammars", "func_location": "Workspace.serialize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 341, "func_start_line": 338}}, {"func_info": {"comment": ["\r\n  Section: Managing Paths\r\n  ", " Public: Get an {Array} of {String}s containing the paths of the project's", " directories."], "name": "Project.getPaths", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 329, "start_line": 327}, "call_info": {"func_end_line": 156, "code": "  serialize (options = {}) {\r\n    return {\r\n      deserializer: 'Project',\r\n      paths: this.getPaths(),\r\n      buffers: _.compact(this.buffers.map(function (buffer) {\r\n        if (buffer.isRetained()) {\r\n          const isUnloading = options.isUnloading === true\r\n          return buffer.serialize({markerLayers: isUnloading, history: isUnloading})\r\n        }\r\n      }))\r\n    }\r\n  }\r", "name": "getPaths", "func_location": "Project.serialize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 148, "func_start_line": 145}}, {"func_info": {"comment": [" Extended: Returns a {Boolean} that is `true` if the current window is in full screen mode."], "name": "AtomEnvironment.isFullScreen", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 643, "start_line": 641}, "call_info": {"func_end_line": 880, "code": "  serialize (options) {\r\n    return {\r\n      version: this.constructor.version,\r\n      project: this.project.serialize(options),\r\n      workspace: this.workspace.serialize(),\r\n      packageStates: this.packages.serialize(),\r\n      grammars: this.grammars.serialize(),\r\n      fullScreen: this.isFullScreen(),\r\n      windowDimensions: this.windowDimensions\r\n    }\r\n  }\r", "name": "isFullScreen", "func_location": "AtomEnvironment.serialize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 877, "func_start_line": 870}}, {"func_info": {"comment": ["\r\n  Section: Accessing active packages\r\n  ", " Public: Get an {Array} of all the active {Package}s."], "name": "PackageManager.getActivePackages", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 293, "start_line": 291}, "call_info": {"func_end_line": 761, "code": "  serialize () {\r\n    for (const pack of this.getActivePackages()) {\r\n      this.serializePackage(pack)\r\n    }\r\n    return this.packageStates\r\n  }\r", "name": "getActivePackages", "func_location": "PackageManager.serialize", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 757, "func_start_line": 756}}, {"func_info": {"comment": [], "name": "PackageManager.serializePackage", "params": ["pack"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 767, "start_line": 763}, "call_info": {"func_end_line": 761, "code": "  serialize () {\r\n    for (const pack of this.getActivePackages()) {\r\n      this.serializePackage(pack)\r\n    }\r\n    return this.packageStates\r\n  }\r", "name": "serializePackage", "func_location": "PackageManager.serialize", "args": ["pack"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 758, "func_start_line": 756}}, {"func_info": {"comment": [], "name": "PackageManager.setPackageState", "params": ["name", "state"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 426, "start_line": 424}, "call_info": {"func_end_line": 767, "code": "  serializePackage (pack) {\r\n    if (typeof pack.serialize === 'function') {\r\n      this.setPackageState(pack.name, pack.serialize())\r\n    }\r\n  }\r", "name": "setPackageState", "func_location": "PackageManager.serializePackage", "args": ["pack.name", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 765, "func_start_line": 763}}, {"func_info": {"comment": [], "name": "Config.makeValueConformToSchema", "params": ["keyPath", "value", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1178, "start_line": 1164}, "call_info": {"func_end_line": 722, "comment": [" Essential: Sets the value for a configuration setting.", "", " This value is stored in Atom's internal configuration file.", "", " ### Examples", "", " You might want to change the themes programmatically:", "", " ```coffee", " atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])", " ```", "", " You can also set scoped settings. For example, you might want change the", " `editor.tabLength` only for ruby files.", "", " ```coffee", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4", " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4", "", " # Set ruby to 2", " atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true", "", " # Notice it's only set to 2 in the case of ruby", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4", " ```", "", " * `keyPath` The {String} name of the key.", " * `value` The value of the setting. Passing `undefined` will revert the", "   setting to the default value.", " * `options` (optional) {Object}", "   * `scopeSelector` (optional) {String}. eg. '.source.ruby'", "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)", "     for more information.", "   * `source` (optional) {String} The name of a file with which the setting", "     is associated. Defaults to the user's config file.", "", " Returns a {Boolean}", " * `true` if the value was set.", " * `false` if the value was not able to be coerced to the type specified in the setting's schema."], "code": "  set (...args) {\r\n    let [keyPath, value, options = {}] = args\r\n\r\n    if (!this.settingsLoaded) {\r\n      this.pendingOperations.push(() => this.set(keyPath, value, options))\r\n    }\r\n\r\n    const scopeSelector = options.scopeSelector\r\n    let source = options.source\r\n    const shouldSave = options.save != null ? options.save : true\r\n\r\n    if (source && !scopeSelector && source !== this.projectFile) {\r\n      throw new Error(\"::set with a 'source' and no 'sourceSelector' is not yet implemented!\")\r\n    }\r\n\r\n    if (!source) source = this.mainSource\r\n\r\n    if (value !== undefined) {\r\n      try {\r\n        value = this.makeValueConformToSchema(keyPath, value)\r\n      } catch (e) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    if (scopeSelector != null) {\r\n      this.setRawScopedValue(keyPath, value, source, scopeSelector)\r\n    } else {\r\n      this.setRawValue(keyPath, value, {source})\r\n    }\r\n\r\n    if (source === this.mainSource && shouldSave && this.settingsLoaded) {\r\n      this.requestSave()\r\n    }\r\n    return true\r\n  }\r", "name": "makeValueConformToSchema", "func_location": "Config.set", "args": ["keyPath", "value"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 706, "func_start_line": 687}}, {"func_info": {"comment": [], "name": "Config.setRawScopedValue", "params": ["keyPath", "value", "source", "selector", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1242, "start_line": 1231}, "call_info": {"func_end_line": 722, "comment": [" Essential: Sets the value for a configuration setting.", "", " This value is stored in Atom's internal configuration file.", "", " ### Examples", "", " You might want to change the themes programmatically:", "", " ```coffee", " atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])", " ```", "", " You can also set scoped settings. For example, you might want change the", " `editor.tabLength` only for ruby files.", "", " ```coffee", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4", " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4", "", " # Set ruby to 2", " atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true", "", " # Notice it's only set to 2 in the case of ruby", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4", " ```", "", " * `keyPath` The {String} name of the key.", " * `value` The value of the setting. Passing `undefined` will revert the", "   setting to the default value.", " * `options` (optional) {Object}", "   * `scopeSelector` (optional) {String}. eg. '.source.ruby'", "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)", "     for more information.", "   * `source` (optional) {String} The name of a file with which the setting", "     is associated. Defaults to the user's config file.", "", " Returns a {Boolean}", " * `true` if the value was set.", " * `false` if the value was not able to be coerced to the type specified in the setting's schema."], "code": "  set (...args) {\r\n    let [keyPath, value, options = {}] = args\r\n\r\n    if (!this.settingsLoaded) {\r\n      this.pendingOperations.push(() => this.set(keyPath, value, options))\r\n    }\r\n\r\n    const scopeSelector = options.scopeSelector\r\n    let source = options.source\r\n    const shouldSave = options.save != null ? options.save : true\r\n\r\n    if (source && !scopeSelector && source !== this.projectFile) {\r\n      throw new Error(\"::set with a 'source' and no 'sourceSelector' is not yet implemented!\")\r\n    }\r\n\r\n    if (!source) source = this.mainSource\r\n\r\n    if (value !== undefined) {\r\n      try {\r\n        value = this.makeValueConformToSchema(keyPath, value)\r\n      } catch (e) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    if (scopeSelector != null) {\r\n      this.setRawScopedValue(keyPath, value, source, scopeSelector)\r\n    } else {\r\n      this.setRawValue(keyPath, value, {source})\r\n    }\r\n\r\n    if (source === this.mainSource && shouldSave && this.settingsLoaded) {\r\n      this.requestSave()\r\n    }\r\n    return true\r\n  }\r", "name": "setRawScopedValue", "func_location": "Config.set", "args": ["keyPath", "value", "source", "scopeSelector"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 713, "func_start_line": 687}}, {"func_info": {"comment": [], "name": "Config.setRawValue", "params": ["keyPath", "value", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1039, "start_line": 1020}, "call_info": {"func_end_line": 722, "comment": [" Essential: Sets the value for a configuration setting.", "", " This value is stored in Atom's internal configuration file.", "", " ### Examples", "", " You might want to change the themes programmatically:", "", " ```coffee", " atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])", " ```", "", " You can also set scoped settings. For example, you might want change the", " `editor.tabLength` only for ruby files.", "", " ```coffee", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4", " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4", "", " # Set ruby to 2", " atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true", "", " # Notice it's only set to 2 in the case of ruby", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4", " ```", "", " * `keyPath` The {String} name of the key.", " * `value` The value of the setting. Passing `undefined` will revert the", "   setting to the default value.", " * `options` (optional) {Object}", "   * `scopeSelector` (optional) {String}. eg. '.source.ruby'", "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)", "     for more information.", "   * `source` (optional) {String} The name of a file with which the setting", "     is associated. Defaults to the user's config file.", "", " Returns a {Boolean}", " * `true` if the value was set.", " * `false` if the value was not able to be coerced to the type specified in the setting's schema."], "code": "  set (...args) {\r\n    let [keyPath, value, options = {}] = args\r\n\r\n    if (!this.settingsLoaded) {\r\n      this.pendingOperations.push(() => this.set(keyPath, value, options))\r\n    }\r\n\r\n    const scopeSelector = options.scopeSelector\r\n    let source = options.source\r\n    const shouldSave = options.save != null ? options.save : true\r\n\r\n    if (source && !scopeSelector && source !== this.projectFile) {\r\n      throw new Error(\"::set with a 'source' and no 'sourceSelector' is not yet implemented!\")\r\n    }\r\n\r\n    if (!source) source = this.mainSource\r\n\r\n    if (value !== undefined) {\r\n      try {\r\n        value = this.makeValueConformToSchema(keyPath, value)\r\n      } catch (e) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    if (scopeSelector != null) {\r\n      this.setRawScopedValue(keyPath, value, source, scopeSelector)\r\n    } else {\r\n      this.setRawValue(keyPath, value, {source})\r\n    }\r\n\r\n    if (source === this.mainSource && shouldSave && this.settingsLoaded) {\r\n      this.requestSave()\r\n    }\r\n    return true\r\n  }\r", "name": "setRawValue", "func_location": "Config.set", "args": ["keyPath", "value", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 715, "func_start_line": 687}}, {"func_info": {"comment": [], "name": "parseAlpha", "params": ["alphaString"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js", "end_line": 124, "start_line": 121}, "call_info": {"func_end_line": 59, "code": "  set alpha (alpha) {\r\n    this._alpha = parseAlpha(alpha)\r\n  }\r", "name": "parseAlpha", "func_location": "Color.set", "args": ["alpha"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js", "line": 58, "func_start_line": 57}}, {"func_info": {"comment": [], "name": "parseColor", "params": ["colorString"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js", "end_line": 119, "start_line": 116}, "call_info": {"func_end_line": 55, "code": "  set blue (blue) {\r\n    this._blue = parseColor(blue)\r\n  }\r", "name": "parseColor", "func_location": "Color.set", "args": ["blue"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js", "line": 54, "func_start_line": 53}}, {"func_info": {"comment": [], "name": "parseColor", "params": ["colorString"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js", "end_line": 119, "start_line": 116}, "call_info": {"func_end_line": 51, "code": "  set green (green) {\r\n    this._green = parseColor(green)\r\n  }\r", "name": "parseColor", "func_location": "Color.set", "args": ["green"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js", "line": 50, "func_start_line": 49}}, {"func_info": {"comment": [], "name": "parseColor", "params": ["colorString"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js", "end_line": 119, "start_line": 116}, "call_info": {"func_end_line": 47, "code": "  set red (red) {\r\n    this._red = parseColor(red)\r\n  }\r", "name": "parseColor", "func_location": "Color.set", "args": ["red"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js", "line": 46, "func_start_line": 45}}, {"func_info": {"comment": [" Add item (or move item) to the end of the itemStack"], "name": "Pane.addItemToStack", "params": ["newItem"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 464, "start_line": 459}, "call_info": {"func_end_line": 443, "code": "  setActiveItem (activeItem, options) {\r\n    const modifyStack = options && options.modifyStack\r\n    if (activeItem !== this.activeItem) {\r\n      if (modifyStack !== false) this.addItemToStack(activeItem)\r\n      this.activeItem = activeItem\r\n      this.emitter.emit('did-change-active-item', this.activeItem)\r\n      if (this.container) this.container.didChangeActiveItemOnPane(this, this.activeItem)\r\n    }\r\n    return this.activeItem\r\n  }\r", "name": "addItemToStack", "func_location": "Pane.setActiveItem", "args": ["activeItem"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 437, "func_start_line": 434}}, {"func_info": {"comment": [" Sets the proper visible state the update menu items"], "name": "ApplicationMenu.showUpdateMenuItem", "params": ["state"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "end_line": 140, "start_line": 109}, "call_info": {"func_end_line": 40, "code": "  setActiveTemplate (template) {\r\n    if (!_.isEqual(template, this.activeTemplate)) {\r\n      this.activeTemplate = template\r\n      this.menu = Menu.buildFromTemplate(_.deepClone(template))\r\n      Menu.setApplicationMenu(this.menu)\r\n    }\r\n\r\n    return this.showUpdateMenuItem(this.autoUpdateManager.getState())\r\n  }\r", "name": "showUpdateMenuItem", "func_location": "ApplicationMenu.setActiveTemplate", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "line": 39, "func_start_line": 32}}, {"func_info": {"comment": [], "name": "ProtocolHandlerInstaller.isSupported", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js", "end_line": 12, "start_line": 10}, "call_info": {"func_end_line": 22, "code": "  setAsDefaultProtocolClient () {\r\n    // This Electron API is only available on Windows and macOS. There might be some\r\n    // hacks to make it work on Linux; see https://github.com/electron/electron/issues/6440\r\n    return this.isSupported() && remote.app.setAsDefaultProtocolClient('atom', process.execPath, ['--uri-handler', '--'])\r\n  }\r", "name": "isSupported", "func_location": "ProtocolHandlerInstaller.setAsDefaultProtocolClient", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/protocol-handler-installer.js", "line": 21, "func_start_line": 18}}, {"func_info": {"comment": [], "name": "Cursor.changePosition", "params": ["options", "fn"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 728, "start_line": 720}, "call_info": {"func_end_line": 88, "name": "changePosition", "func_location": "Cursor.setBufferPosition", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 85, "func_start_line": 84}}, {"func_info": {"comment": [" Public: Determines if the ending position of a marker is greater than the", " starting position.", "", " This can happen when, for example, you highlight text \"up\" in a {TextBuffer}."], "name": "Selection.isReversed", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 149, "start_line": 147}, "call_info": {"func_end_line": 104, "comment": [" Public: Modifies the buffer {Range} for the selection.", "", " * `bufferRange` The new {Range} to select.", " * `options` (optional) {Object} with the keys:", "   * `preserveFolds` if `true`, the fold settings are preserved after the", "     selection moves.", "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new", "     range. Defaults to `true` if this is the most recently added selection,", "     `false` otherwise."], "code": "  setBufferRange (bufferRange, options = {}) {\r\n    bufferRange = Range.fromObject(bufferRange)\r\n    if (options.reversed == null) options.reversed = this.isReversed()\r\n    if (!options.preserveFolds) this.editor.destroyFoldsContainingBufferPositions([bufferRange.start, bufferRange.end], true)\r\n    this.modifySelection(() => {\r\n      const needsFlash = options.flash\r\n      options.flash = null\r\n      this.marker.setBufferRange(bufferRange, options)\r\n      const autoscroll = options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n      if (autoscroll) this.autoscroll()\r\n      if (needsFlash) this.decoration.flash('flash', this.editor.selectionFlashDuration)\r\n    })\r\n  }\r", "name": "isReversed", "func_location": "Selection.setBufferRange", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 94, "func_start_line": 92}}, {"func_info": {"comment": [" Extended: Suppress calls to handler functions registered with {::onDidChange}", " and {::observe} for the duration of `callback`. After `callback` executes,", " handlers will be called once if the value for their key-path has changed.", "", " * `callback` {Function} to execute while suppressing calls to handlers."], "name": "Config.transact", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 823, "start_line": 816}, "call_info": {"func_end_line": 1090, "name": "transact", "func_location": "Config.setDefaults", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1073, "func_start_line": 1070}}, {"func_info": {"comment": [], "name": "Config.makeValueConformToSchema", "params": ["keyPath", "value", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1178, "start_line": 1164}, "call_info": {"func_end_line": 1090, "code": "  setDefaults (keyPath, defaults) {\r\n    if ((defaults != null) && isPlainObject(defaults)) {\r\n      const keys = splitKeyPath(keyPath)\r\n      this.transact(() => {\r\n        const result = []\r\n        for (let key in defaults) {\r\n          const childValue = defaults[key]\r\n          if (!defaults.hasOwnProperty(key)) { continue }\r\n          result.push(this.setDefaults(keys.concat([key]).join('.'), childValue))\r\n        }\r\n        return result\r\n      })\r\n    } else {\r\n      try {\r\n        defaults = this.makeValueConformToSchema(keyPath, defaults)\r\n        this.setRawDefault(keyPath, defaults)\r\n      } catch (e) {\r\n        console.warn(`'${keyPath}' could not set the default. Attempted default: ${JSON.stringify(defaults)}; Schema: ${JSON.stringify(this.getSchema(keyPath))}`)\r\n      }\r\n    }\r\n  }\r", "name": "makeValueConformToSchema", "func_location": "Config.setDefaults", "args": ["keyPath", "defaults"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1084, "func_start_line": 1070}}, {"func_info": {"comment": [], "name": "Config.setRawDefault", "params": ["keyPath", "value"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1068, "start_line": 1065}, "call_info": {"func_end_line": 1090, "code": "  setDefaults (keyPath, defaults) {\r\n    if ((defaults != null) && isPlainObject(defaults)) {\r\n      const keys = splitKeyPath(keyPath)\r\n      this.transact(() => {\r\n        const result = []\r\n        for (let key in defaults) {\r\n          const childValue = defaults[key]\r\n          if (!defaults.hasOwnProperty(key)) { continue }\r\n          result.push(this.setDefaults(keys.concat([key]).join('.'), childValue))\r\n        }\r\n        return result\r\n      })\r\n    } else {\r\n      try {\r\n        defaults = this.makeValueConformToSchema(keyPath, defaults)\r\n        this.setRawDefault(keyPath, defaults)\r\n      } catch (e) {\r\n        console.warn(`'${keyPath}' could not set the default. Attempted default: ${JSON.stringify(defaults)}; Schema: ${JSON.stringify(this.getSchema(keyPath))}`)\r\n      }\r\n    }\r\n  }\r", "name": "setRawDefault", "func_location": "Config.setDefaults", "args": ["keyPath", "defaults"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1085, "func_start_line": 1070}}, {"func_info": {"comment": [" Extended: Retrieve the schema for a specific key path. The schema will tell", " you what type the keyPath expects, and other metadata about the config", " option.", "", " * `keyPath` The {String} name of the key.", "", " Returns an {Object} eg. `{type: 'integer', default: 23, minimum: 1}`.", " Returns `null` when the keyPath has no schema specified, but is accessible", " from the root schema."], "name": "Config.getSchema", "params": ["keyPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 805, "start_line": 783}, "call_info": {"func_end_line": 1090, "code": "  setDefaults (keyPath, defaults) {\r\n    if ((defaults != null) && isPlainObject(defaults)) {\r\n      const keys = splitKeyPath(keyPath)\r\n      this.transact(() => {\r\n        const result = []\r\n        for (let key in defaults) {\r\n          const childValue = defaults[key]\r\n          if (!defaults.hasOwnProperty(key)) { continue }\r\n          result.push(this.setDefaults(keys.concat([key]).join('.'), childValue))\r\n        }\r\n        return result\r\n      })\r\n    } else {\r\n      try {\r\n        defaults = this.makeValueConformToSchema(keyPath, defaults)\r\n        this.setRawDefault(keyPath, defaults)\r\n      } catch (e) {\r\n        console.warn(`'${keyPath}' could not set the default. Attempted default: ${JSON.stringify(defaults)}; Schema: ${JSON.stringify(this.getSchema(keyPath))}`)\r\n      }\r\n    }\r\n  }\r", "name": "getSchema", "func_location": "Config.setDefaults", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1087, "func_start_line": 1070}}, {"func_info": {"comment": [], "name": "Dock.setState", "params": ["newState"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 177, "start_line": 144}, "call_info": {"func_end_line": 111, "code": "  setDraggingItem (draggingItem) {\r\n    if (draggingItem === this.state.draggingItem) return\r\n    this.setState({draggingItem})\r\n  }\r", "name": "setState", "func_location": "Dock.setDraggingItem", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 110, "func_start_line": 108}}, {"func_info": {"comment": [], "name": "TextEditor.update", "params": ["params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 539, "start_line": 320}, "call_info": {"func_end_line": 1068, "comment": [" Set the number of characters that can be displayed horizontally in the", " editor.", "", " * `editorWidthInChars` A {Number} representing the width of the", " {TextEditorElement} in characters."], "code": "  setEditorWidthInChars (editorWidthInChars) { this.update({editorWidthInChars}) }\r", "name": "update", "func_location": "TextEditor.setEditorWidthInChars", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 1068, "func_start_line": 1068}}, {"func_info": {"comment": [], "name": "TextEditorElement.getModel", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 82, "start_line": 80}, "call_info": {"func_end_line": 340, "code": "  setFirstVisibleScreenColumn (column) {\r\n    return this.getModel().setFirstVisibleScreenColumn(column)\r\n  }\r", "name": "getModel", "func_location": "TextEditorElement.setFirstVisibleScreenColumn", "args": ["column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 339, "func_start_line": 338}}, {"func_info": {"comment": [], "name": "TextEditorElement.getModel", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 82, "start_line": 80}, "call_info": {"func_end_line": 312, "code": "  setFirstVisibleScreenRow (row) {\r\n    this.getModel().setFirstVisibleScreenRow(row)\r\n  }\r", "name": "getModel", "func_location": "TextEditorElement.setFirstVisibleScreenRow", "args": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 311, "func_start_line": 310}}, {"func_info": {"comment": [], "name": "GrammarRegistry.grammarForScopeName", "params": ["scopeName"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "end_line": 454, "start_line": 452}, "call_info": {"func_end_line": 352, "comment": [" Deprecated: Set the grammar override for the given file path.", "", " * `filePath` A non-empty {String} file path.", " * `languageId` A {String} such as `\"source.js\"`.", "", " Returns undefined."], "code": "  setGrammarOverrideForPath (filePath, languageId) {\r\n    Grim.deprecate('Use atom.grammars.assignLanguageMode(buffer, languageId) instead')\r\n    const buffer = atom.project.findBufferForPath(filePath)\r\n    if (buffer) {\r\n      const grammar = this.grammarForScopeName(languageId)\r\n      if (grammar) this.languageOverridesByBufferId.set(buffer.id, grammar.name)\r\n    }\r\n  }\r", "name": "grammarForScopeName", "func_location": "GrammarRegistry.setGrammarOverrideForPath", "args": ["languageId"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/grammar-registry.js", "line": 349, "func_start_line": 345}}, {"func_info": {"comment": [], "name": "Dock.setState", "params": ["newState"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 177, "start_line": 144}, "call_info": {"func_end_line": 106, "code": "  setHovered (hovered) {\r\n    if (hovered === this.state.hovered) return\r\n    this.setState({hovered})\r\n  }\r", "name": "setState", "func_location": "Dock.setHovered", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 105, "func_start_line": 103}}, {"func_info": {"comment": [], "name": "TextEditor.update", "params": ["params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 539, "start_line": 320}, "call_info": {"func_end_line": 1020, "code": "  setLineNumberGutterVisible (lineNumberGutterVisible) { this.update({lineNumberGutterVisible}) }\r", "name": "update", "func_location": "TextEditor.setLineNumberGutterVisible", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 1020, "func_start_line": 1020}}, {"func_info": {"comment": [], "name": "TextEditor.update", "params": ["params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 539, "start_line": 320}, "call_info": {"func_end_line": 1000, "code": "  setMini (mini) {\r\n    this.update({mini})\r\n  }\r", "name": "update", "func_location": "TextEditor.setMini", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 999, "func_start_line": 998}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 87, "code": "  setModel (model) {\r\n    this.getComponent().update({model})\r\n    this.updateModelFromAttributes()\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.setModel", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 85, "func_start_line": 84}}, {"func_info": {"comment": [], "name": "TextEditorElement.updateModelFromAttributes", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 96, "start_line": 89}, "call_info": {"func_end_line": 87, "code": "  setModel (model) {\r\n    this.getComponent().update({model})\r\n    this.updateModelFromAttributes()\r\n  }\r", "name": "updateModelFromAttributes", "func_location": "TextEditorElement.setModel", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 86, "func_start_line": 84}}, {"func_info": {"comment": [" Public: Add a path to the project's list of root paths", "", " * `projectPath` {String} The path to the directory to add.", " * `options` An optional {Object} that may contain the following keys:", "   * `mustExist` If `true`, throw an Error if the `projectPath` does not exist. If `false`, a `projectPath` that does", "     not exist is ignored. Default: `false`.", "   * `exact` If `true`, only add `projectPath` if it names an existing directory. If `false`, if `projectPath` is a", "     a file or does not exist, its parent directory will be added instead."], "name": "Project.addPath", "params": ["projectPath", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "end_line": 442, "start_line": 381}, "call_info": {"func_end_line": 371, "comment": [" Public: Set the paths of the project's directories.", "", " * `projectPaths` {Array} of {String} paths.", " * `options` An optional {Object} that may contain the following keys:", "   * `mustExist` If `true`, throw an Error if any `projectPaths` do not exist. Any remaining `projectPaths` that", "     do exist will still be added to the project. Default: `false`.", "   * `exact` If `true`, only add a `projectPath` if it names an existing directory. If `false` and any `projectPath`", "     is a file or does not exist, its parent directory will be added instead. Default: `false`."], "code": "  setPaths (projectPaths, options = {}) {\r\n    for (let repository of this.repositories) {\r\n      if (repository != null) repository.destroy()\r\n    }\r\n    this.rootDirectories = []\r\n    this.repositories = []\r\n\r\n    for (let path in this.watcherPromisesByPath) {\r\n      this.watcherPromisesByPath[path].then(watcher => { watcher.dispose() })\r\n    }\r\n    this.watcherPromisesByPath = {}\r\n\r\n    const missingProjectPaths = []\r\n    for (let projectPath of projectPaths) {\r\n      try {\r\n        this.addPath(projectPath, {emitEvent: false, mustExist: true, exact: options.exact === true})\r\n      } catch (e) {\r\n        if (e.missingProjectPaths != null) {\r\n          missingProjectPaths.push(...e.missingProjectPaths)\r\n        } else {\r\n          throw e\r\n        }\r\n      }\r\n    }\r\n\r\n    this.emitter.emit('did-change-paths', projectPaths)\r\n\r\n    if ((options.mustExist === true) && (missingProjectPaths.length > 0)) {\r\n      const err = new Error('One or more project directories do not exist')\r\n      err.missingProjectPaths = missingProjectPaths\r\n      throw err\r\n    }\r\n  }\r", "name": "addPath", "func_location": "Project.setPaths", "args": ["projectPath", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/project.js", "line": 354, "func_start_line": 339}}, {"func_info": {"comment": [" Applies changes to a decorationsParam {Object} to make it possible to", " differentiate decorations on custom gutters versus the line-number gutter."], "name": "translateDecorationParamsOldToNew", "params": ["decorationParams"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration.js", "end_line": 13, "start_line": 8}, "call_info": {"func_end_line": 173, "comment": [" Essential: Update the marker with new Properties. Allows you to change the decoration's class.", "", " ## Examples", "", " ```coffee", " decoration.setProperties({type: 'line-number', class: 'my-new-class'})", " ```", "", " * `newProperties` {Object} eg. `{type: 'line-number', class: 'my-new-class'}`"], "code": "  setProperties (newProperties) {\r\n    if (this.destroyed) { return }\r\n    const oldProperties = this.properties\r\n    this.properties = translateDecorationParamsOldToNew(newProperties)\r\n    if (newProperties.type != null) {\r\n      this.decorationManager.decorationDidChangeType(this)\r\n    }\r\n    this.decorationManager.emitDidUpdateDecorations()\r\n    return this.emitter.emit('did-change-properties', {oldProperties, newProperties})\r\n  }\r", "name": "translateDecorationParamsOldToNew", "func_location": "Decoration.setProperties", "args": ["newProperties"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/decoration.js", "line": 167, "func_start_line": 164}}, {"func_info": {"comment": [], "name": "Config.emitChangeEvent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1213, "start_line": 1211}, "call_info": {"func_end_line": 1068, "code": "  setRawDefault (keyPath, value) {\r\n    setValueAtKeyPath(this.defaultSettings, keyPath, value)\r\n    return this.emitChangeEvent()\r\n  }\r", "name": "emitChangeEvent", "func_location": "Config.setRawDefault", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1067, "func_start_line": 1065}}, {"func_info": {"comment": ["\r\n  Section: Private Scoped Settings\r\n  "], "name": "Config.priorityForSource", "params": ["source"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1209, "start_line": 1200}, "call_info": {"func_end_line": 1242, "code": "  setRawScopedValue (keyPath, value, source, selector, options) {\r\n    if (keyPath != null) {\r\n      const newValue = {}\r\n      setValueAtKeyPath(newValue, keyPath, value)\r\n      value = newValue\r\n    }\r\n\r\n    const settingsBySelector = {}\r\n    settingsBySelector[selector] = value\r\n    this.scopedSettingsStore.addProperties(source, settingsBySelector, {priority: this.priorityForSource(source)})\r\n    return this.emitChangeEvent()\r\n  }\r", "name": "priorityForSource", "func_location": "Config.setRawScopedValue", "args": ["source", "settingsBySelector", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1240, "func_start_line": 1231}}, {"func_info": {"comment": [], "name": "Config.emitChangeEvent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1213, "start_line": 1211}, "call_info": {"func_end_line": 1242, "code": "  setRawScopedValue (keyPath, value, source, selector, options) {\r\n    if (keyPath != null) {\r\n      const newValue = {}\r\n      setValueAtKeyPath(newValue, keyPath, value)\r\n      value = newValue\r\n    }\r\n\r\n    const settingsBySelector = {}\r\n    settingsBySelector[selector] = value\r\n    this.scopedSettingsStore.addProperties(source, settingsBySelector, {priority: this.priorityForSource(source)})\r\n    return this.emitChangeEvent()\r\n  }\r", "name": "emitChangeEvent", "func_location": "Config.setRawScopedValue", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1241, "func_start_line": 1231}}, {"func_info": {"comment": [], "name": "Config.emitChangeEvent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1213, "start_line": 1211}, "call_info": {"func_end_line": 1039, "code": "  setRawValue (keyPath, value, options = {}) {\r\n    const source = options.source ? options.source : undefined\r\n    const settingsToChange = source === this.projectFile ? 'projectSettings' : 'settings'\r\n    const defaultValue = getValueAtKeyPath(this.defaultSettings, keyPath)\r\n\r\n    if (_.isEqual(defaultValue, value)) {\r\n      if (keyPath != null) {\r\n        deleteValueAtKeyPath(this[settingsToChange], keyPath)\r\n      } else {\r\n        this[settingsToChange] = null\r\n      }\r\n    } else {\r\n      if (keyPath != null) {\r\n        setValueAtKeyPath(this[settingsToChange], keyPath, value)\r\n      } else {\r\n        this[settingsToChange] = value\r\n      }\r\n    }\r\n    return this.emitChangeEvent()\r\n  }\r", "name": "emitChangeEvent", "func_location": "Config.setRawValue", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1038, "func_start_line": 1020}}, {"func_info": {"comment": [], "name": "TextEditor.update", "params": ["params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 539, "start_line": 320}, "call_info": {"func_end_line": 1006, "code": "  setReadOnly (readOnly) {\r\n    this.update({readOnly})\r\n  }\r", "name": "update", "func_location": "TextEditor.setReadOnly", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 1005, "func_start_line": 1004}}, {"func_info": {"comment": [], "name": "PaneContainer.getActivePane", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 160, "start_line": 158}, "call_info": {"func_end_line": 139, "code": "  setRoot (root) {\r\n    this.root = root\r\n    this.root.setParent(this)\r\n    this.root.setContainer(this)\r\n    this.emitter.emit('did-change-root', this.root)\r\n    if ((this.getActivePane() == null) && this.root instanceof Pane) {\r\n      this.didActivatePane(this.root)\r\n    }\r\n  }\r", "name": "getActivePane", "func_location": "PaneContainer.setRoot", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 136, "func_start_line": 131}}, {"func_info": {"comment": [], "name": "PaneContainer.didActivatePane", "params": ["activePane"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "end_line": 263, "start_line": 251}, "call_info": {"func_end_line": 139, "code": "  setRoot (root) {\r\n    this.root = root\r\n    this.root.setParent(this)\r\n    this.root.setContainer(this)\r\n    this.emitter.emit('did-change-root', this.root)\r\n    if ((this.getActivePane() == null) && this.root instanceof Pane) {\r\n      this.didActivatePane(this.root)\r\n    }\r\n  }\r", "name": "didActivatePane", "func_location": "PaneContainer.setRoot", "args": [".root"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane-container.js", "line": 137, "func_start_line": 131}}, {"func_info": {"comment": [" Extended: Suppress calls to handler functions registered with {::onDidChange}", " and {::observe} for the duration of `callback`. After `callback` executes,", " handlers will be called once if the value for their key-path has changed.", "", " * `callback` {Function} to execute while suppressing calls to handlers."], "name": "Config.transact", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 823, "start_line": 816}, "call_info": {"func_end_line": 921, "name": "transact", "func_location": "Config.setSchema", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 916, "func_start_line": 895}}, {"func_info": {"comment": [" `schema` will look something like this", "", " ```coffee", " type: 'string'", " default: 'ok'", " scopes:", "   '.source.js':", "     default: 'omg'", " ```"], "name": "Config.setScopedDefaultsFromSchema", "params": ["keyPath", "schema"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1151, "start_line": 1131}, "call_info": {"func_end_line": 1151, "comment": [" `schema` will look something like this", "", " ```coffee", " type: 'string'", " default: 'ok'", " scopes:", "   '.source.js':", "     default: 'omg'", " ```"], "code": "  setScopedDefaultsFromSchema (keyPath, schema) {\r\n    if ((schema.scopes != null) && isPlainObject(schema.scopes)) {\r\n      const scopedDefaults = {}\r\n      for (let scope in schema.scopes) {\r\n        const scopeSchema = schema.scopes[scope]\r\n        if (!scopeSchema.hasOwnProperty('default')) { continue }\r\n        scopedDefaults[scope] = {}\r\n        setValueAtKeyPath(scopedDefaults[scope], keyPath, scopeSchema.default)\r\n      }\r\n      this.scopedSettingsStore.addProperties('schema-default', scopedDefaults)\r\n    }\r\n\r\n    if ((schema.type === 'object') && (schema.properties != null) && isPlainObject(schema.properties)) {\r\n      const keys = splitKeyPath(keyPath)\r\n      for (let key in schema.properties) {\r\n        const childValue = schema.properties[key]\r\n        if (!schema.properties.hasOwnProperty(key)) { continue }\r\n        this.setScopedDefaultsFromSchema(keys.concat([key]).join('.'), childValue)\r\n      }\r\n    }\r\n  }\r", "name": "setScopedDefaultsFromSchema", "func_location": "Config.setScopedDefaultsFromSchema", "args": [null, "childValue"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 1148, "func_start_line": 1131}}, {"func_info": {"comment": [], "name": "Cursor.changePosition", "params": ["options", "fn"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 728, "start_line": 720}, "call_info": {"func_end_line": 70, "name": "changePosition", "func_location": "Cursor.setScreenPosition", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 67, "func_start_line": 66}}, {"func_info": {"comment": [" Public: Modifies the buffer {Range} for the selection.", "", " * `bufferRange` The new {Range} to select.", " * `options` (optional) {Object} with the keys:", "   * `preserveFolds` if `true`, the fold settings are preserved after the", "     selection moves.", "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new", "     range. Defaults to `true` if this is the most recently added selection,", "     `false` otherwise."], "name": "Selection.setBufferRange", "params": ["bufferRange", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "end_line": 104, "start_line": 92}, "call_info": {"func_end_line": 76, "comment": [" Public: Modifies the screen range for the selection.", "", " * `screenRange` The new {Range} to use.", " * `options` (optional) {Object} options matching those found in {::setBufferRange}."], "code": "  setScreenRange (screenRange, options) {\r\n    return this.setBufferRange(this.editor.bufferRangeForScreenRange(screenRange), options)\r\n  }\r", "name": "setBufferRange", "func_location": "Selection.setScreenRange", "args": [null, "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/selection.js", "line": 75, "func_start_line": 74}}, {"func_info": {"comment": [], "name": "TextEditorComponent.setScrollTop", "params": ["scrollTop"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2809, "start_line": 2796}, "call_info": {"func_end_line": 2821, "code": "  setScrollBottom (scrollBottom) {\r\n    return this.setScrollTop(scrollBottom - this.getScrollContainerClientHeight())\r\n  }\r", "name": "setScrollTop", "func_location": "TextEditorComponent.setScrollBottom", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2820, "func_start_line": 2819}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollContainerClientHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2642, "start_line": 2640}, "call_info": {"func_end_line": 2821, "code": "  setScrollBottom (scrollBottom) {\r\n    return this.setScrollTop(scrollBottom - this.getScrollContainerClientHeight())\r\n  }\r", "name": "getScrollContainerClientHeight", "func_location": "TextEditorComponent.setScrollBottom", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2820, "func_start_line": 2819}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 184, "code": "  setScrollBottom (scrollBottom) {\r\n    return this.getComponent().setScrollBottom(scrollBottom)\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.setScrollBottom", "args": ["scrollBottom"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 183, "func_start_line": 182}}, {"func_info": {"comment": [], "name": "roundToPhysicalPixelBoundary", "params": ["virtualPixelPosition"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4489, "start_line": 4486}, "call_info": {"func_end_line": 2839, "code": "  setScrollLeft (scrollLeft) {\r\n    if (Number.isNaN(scrollLeft) || scrollLeft == null) return false\r\n\r\n    scrollLeft = roundToPhysicalPixelBoundary(Math.max(0, Math.min(this.getMaxScrollLeft(), scrollLeft)))\r\n    if (scrollLeft !== this.scrollLeft) {\r\n      this.scrollLeftPending = true\r\n      this.scrollLeft = scrollLeft\r\n      this.element.emitter.emit('did-change-scroll-left', scrollLeft)\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r", "name": "roundToPhysicalPixelBoundary", "func_location": "TextEditorComponent.setScrollLeft", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2830, "func_start_line": 2827}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getMaxScrollLeft", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2843, "start_line": 2841}, "call_info": {"func_end_line": 2839, "code": "  setScrollLeft (scrollLeft) {\r\n    if (Number.isNaN(scrollLeft) || scrollLeft == null) return false\r\n\r\n    scrollLeft = roundToPhysicalPixelBoundary(Math.max(0, Math.min(this.getMaxScrollLeft(), scrollLeft)))\r\n    if (scrollLeft !== this.scrollLeft) {\r\n      this.scrollLeftPending = true\r\n      this.scrollLeft = scrollLeft\r\n      this.element.emitter.emit('did-change-scroll-left', scrollLeft)\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r", "name": "getMaxScrollLeft", "func_location": "TextEditorComponent.setScrollLeft", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2830, "func_start_line": 2827}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 194, "code": "  setScrollLeft (scrollLeft) {\r\n    const component = this.getComponent()\r\n    component.setScrollLeft(scrollLeft)\r\n    component.scheduleUpdate()\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.setScrollLeft", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 191, "func_start_line": 190}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getLongestLineWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2610, "start_line": 2608}, "call_info": {"func_end_line": 2885, "code": "  setScrollLeftColumn (scrollLeftColumn, scheduleUpdate = true) {\r\n    if (this.hasInitialMeasurements && this.getLongestLineWidth() != null) {\r\n      const didScroll = this.setScrollLeft(scrollLeftColumn * this.getBaseCharacterWidth())\r\n      if (didScroll && scheduleUpdate) {\r\n        this.scheduleUpdate()\r\n      }\r\n      return didScroll\r\n    } else {\r\n      this.pendingScrollLeftColumn = scrollLeftColumn\r\n      return false\r\n    }\r\n  }\r", "name": "getLongestLineWidth", "func_location": "TextEditorComponent.setScrollLeftColumn", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2875, "func_start_line": 2874}}, {"func_info": {"comment": [], "name": "TextEditorComponent.setScrollLeft", "params": ["scrollLeft"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2839, "start_line": 2827}, "call_info": {"func_end_line": 2885, "code": "  setScrollLeftColumn (scrollLeftColumn, scheduleUpdate = true) {\r\n    if (this.hasInitialMeasurements && this.getLongestLineWidth() != null) {\r\n      const didScroll = this.setScrollLeft(scrollLeftColumn * this.getBaseCharacterWidth())\r\n      if (didScroll && scheduleUpdate) {\r\n        this.scheduleUpdate()\r\n      }\r\n      return didScroll\r\n    } else {\r\n      this.pendingScrollLeftColumn = scrollLeftColumn\r\n      return false\r\n    }\r\n  }\r", "name": "setScrollLeft", "func_location": "TextEditorComponent.setScrollLeftColumn", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2876, "func_start_line": 2874}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getBaseCharacterWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2606, "start_line": 2604}, "call_info": {"func_end_line": 2885, "code": "  setScrollLeftColumn (scrollLeftColumn, scheduleUpdate = true) {\r\n    if (this.hasInitialMeasurements && this.getLongestLineWidth() != null) {\r\n      const didScroll = this.setScrollLeft(scrollLeftColumn * this.getBaseCharacterWidth())\r\n      if (didScroll && scheduleUpdate) {\r\n        this.scheduleUpdate()\r\n      }\r\n      return didScroll\r\n    } else {\r\n      this.pendingScrollLeftColumn = scrollLeftColumn\r\n      return false\r\n    }\r\n  }\r", "name": "getBaseCharacterWidth", "func_location": "TextEditorComponent.setScrollLeftColumn", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2876, "func_start_line": 2874}}, {"func_info": {"comment": [], "name": "TextEditorComponent.scheduleUpdate", "params": ["nextUpdateOnlyBlinksCursors"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 219, "start_line": 204}, "call_info": {"func_end_line": 2885, "code": "  setScrollLeftColumn (scrollLeftColumn, scheduleUpdate = true) {\r\n    if (this.hasInitialMeasurements && this.getLongestLineWidth() != null) {\r\n      const didScroll = this.setScrollLeft(scrollLeftColumn * this.getBaseCharacterWidth())\r\n      if (didScroll && scheduleUpdate) {\r\n        this.scheduleUpdate()\r\n      }\r\n      return didScroll\r\n    } else {\r\n      this.pendingScrollLeftColumn = scrollLeftColumn\r\n      return false\r\n    }\r\n  }\r", "name": "scheduleUpdate", "func_location": "TextEditorComponent.setScrollLeftColumn", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2878, "func_start_line": 2874}}, {"func_info": {"comment": [], "name": "TextEditorComponent.setScrollLeft", "params": ["scrollLeft"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2839, "start_line": 2827}, "call_info": {"func_end_line": 2851, "code": "  setScrollRight (scrollRight) {\r\n    return this.setScrollLeft(scrollRight - this.getScrollContainerClientWidth())\r\n  }\r", "name": "setScrollLeft", "func_location": "TextEditorComponent.setScrollRight", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2850, "func_start_line": 2849}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollContainerClientWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2638, "start_line": 2636}, "call_info": {"func_end_line": 2851, "code": "  setScrollRight (scrollRight) {\r\n    return this.setScrollLeft(scrollRight - this.getScrollContainerClientWidth())\r\n  }\r", "name": "getScrollContainerClientWidth", "func_location": "TextEditorComponent.setScrollRight", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2850, "func_start_line": 2849}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 202, "code": "  setScrollRight (scrollRight) {\r\n    return this.getComponent().setScrollRight(scrollRight)\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.setScrollRight", "args": ["scrollRight"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 201, "func_start_line": 200}}, {"func_info": {"comment": [], "name": "roundToPhysicalPixelBoundary", "params": ["virtualPixelPosition"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4489, "start_line": 4486}, "call_info": {"func_end_line": 2809, "code": "  setScrollTop (scrollTop) {\r\n    if (Number.isNaN(scrollTop) || scrollTop == null) return false\r\n\r\n    scrollTop = roundToPhysicalPixelBoundary(Math.max(0, Math.min(this.getMaxScrollTop(), scrollTop)))\r\n    if (scrollTop !== this.scrollTop) {\r\n      this.derivedDimensionsCache = {}\r\n      this.scrollTopPending = true\r\n      this.scrollTop = scrollTop\r\n      this.element.emitter.emit('did-change-scroll-top', scrollTop)\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r", "name": "roundToPhysicalPixelBoundary", "func_location": "TextEditorComponent.setScrollTop", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2799, "func_start_line": 2796}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getMaxScrollTop", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2813, "start_line": 2811}, "call_info": {"func_end_line": 2809, "code": "  setScrollTop (scrollTop) {\r\n    if (Number.isNaN(scrollTop) || scrollTop == null) return false\r\n\r\n    scrollTop = roundToPhysicalPixelBoundary(Math.max(0, Math.min(this.getMaxScrollTop(), scrollTop)))\r\n    if (scrollTop !== this.scrollTop) {\r\n      this.derivedDimensionsCache = {}\r\n      this.scrollTopPending = true\r\n      this.scrollTop = scrollTop\r\n      this.element.emitter.emit('did-change-scroll-top', scrollTop)\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r", "name": "getMaxScrollTop", "func_location": "TextEditorComponent.setScrollTop", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2799, "func_start_line": 2796}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 176, "code": "  setScrollTop (scrollTop) {\r\n    const component = this.getComponent()\r\n    component.setScrollTop(scrollTop)\r\n    component.scheduleUpdate()\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.setScrollTop", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 173, "func_start_line": 172}}, {"func_info": {"comment": [], "name": "TextEditorComponent.setScrollTop", "params": ["scrollTop"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2809, "start_line": 2796}, "call_info": {"func_end_line": 2864, "code": "  setScrollTopRow (scrollTopRow, scheduleUpdate = true) {\r\n    if (this.hasInitialMeasurements) {\r\n      const didScroll = this.setScrollTop(this.pixelPositionBeforeBlocksForRow(scrollTopRow))\r\n      if (didScroll && scheduleUpdate) {\r\n        this.scheduleUpdate()\r\n      }\r\n      return didScroll\r\n    } else {\r\n      this.pendingScrollTopRow = scrollTopRow\r\n      return false\r\n    }\r\n  }\r", "name": "setScrollTop", "func_location": "TextEditorComponent.setScrollTopRow", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2855, "func_start_line": 2853}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelPositionBeforeBlocksForRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2362, "start_line": 2360}, "call_info": {"func_end_line": 2864, "code": "  setScrollTopRow (scrollTopRow, scheduleUpdate = true) {\r\n    if (this.hasInitialMeasurements) {\r\n      const didScroll = this.setScrollTop(this.pixelPositionBeforeBlocksForRow(scrollTopRow))\r\n      if (didScroll && scheduleUpdate) {\r\n        this.scheduleUpdate()\r\n      }\r\n      return didScroll\r\n    } else {\r\n      this.pendingScrollTopRow = scrollTopRow\r\n      return false\r\n    }\r\n  }\r", "name": "pixelPositionBeforeBlocksForRow", "func_location": "TextEditorComponent.setScrollTopRow", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2855, "func_start_line": 2853}}, {"func_info": {"comment": [], "name": "TextEditorComponent.scheduleUpdate", "params": ["nextUpdateOnlyBlinksCursors"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 219, "start_line": 204}, "call_info": {"func_end_line": 2864, "code": "  setScrollTopRow (scrollTopRow, scheduleUpdate = true) {\r\n    if (this.hasInitialMeasurements) {\r\n      const didScroll = this.setScrollTop(this.pixelPositionBeforeBlocksForRow(scrollTopRow))\r\n      if (didScroll && scheduleUpdate) {\r\n        this.scheduleUpdate()\r\n      }\r\n      return didScroll\r\n    } else {\r\n      this.pendingScrollTopRow = scrollTopRow\r\n      return false\r\n    }\r\n  }\r", "name": "scheduleUpdate", "func_location": "TextEditorComponent.setScrollTopRow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2857, "func_start_line": 2853}}, {"func_info": {"comment": [], "name": "mergeTable", "params": ["table", "defaultTable", "mergeIndices"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js", "end_line": 174, "start_line": 154}, "call_info": {"func_end_line": 152, "code": "function setTableDefaults (table, allowWildcardSelector) {\r\n  const defaultTypeTable = allowWildcardSelector ? table['*'] : null\r\n\r\n  for (let type in table) {\r\n    let typeTable = table[type]\r\n    if (typeTable === defaultTypeTable) continue\r\n\r\n    if (defaultTypeTable) {\r\n      mergeTable(typeTable, defaultTypeTable)\r\n    }\r\n\r\n    if (typeTable.parents) {\r\n      setTableDefaults(typeTable.parents, true)\r\n    }\r\n\r\n    for (let key in typeTable.indices) {\r\n      const indexTable = typeTable.indices[key]\r\n      mergeTable(indexTable, typeTable, false)\r\n      if (indexTable.parents) {\r\n        setTableDefaults(indexTable.parents, true)\r\n      }\r\n    }\r\n  }\r\n}\r", "name": "mergeTable", "func_location": "setTableDefaults", "args": ["typeTable", "defaultTypeTable"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js", "line": 137, "func_start_line": 129}}, {"func_info": {"comment": [], "name": "setTableDefaults", "params": ["table", "allowWildcardSelector"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js", "end_line": 152, "start_line": 129}, "call_info": {"func_end_line": 152, "code": "function setTableDefaults (table, allowWildcardSelector) {\r\n  const defaultTypeTable = allowWildcardSelector ? table['*'] : null\r\n\r\n  for (let type in table) {\r\n    let typeTable = table[type]\r\n    if (typeTable === defaultTypeTable) continue\r\n\r\n    if (defaultTypeTable) {\r\n      mergeTable(typeTable, defaultTypeTable)\r\n    }\r\n\r\n    if (typeTable.parents) {\r\n      setTableDefaults(typeTable.parents, true)\r\n    }\r\n\r\n    for (let key in typeTable.indices) {\r\n      const indexTable = typeTable.indices[key]\r\n      mergeTable(indexTable, typeTable, false)\r\n      if (indexTable.parents) {\r\n        setTableDefaults(indexTable.parents, true)\r\n      }\r\n    }\r\n  }\r\n}\r", "name": "setTableDefaults", "func_location": "setTableDefaults", "args": ["typeTable.parents", {"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js", "line": 141, "func_start_line": 129}}, {"func_info": {"comment": [], "name": "mergeTable", "params": ["table", "defaultTable", "mergeIndices"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js", "end_line": 174, "start_line": 154}, "call_info": {"func_end_line": 152, "code": "function setTableDefaults (table, allowWildcardSelector) {\r\n  const defaultTypeTable = allowWildcardSelector ? table['*'] : null\r\n\r\n  for (let type in table) {\r\n    let typeTable = table[type]\r\n    if (typeTable === defaultTypeTable) continue\r\n\r\n    if (defaultTypeTable) {\r\n      mergeTable(typeTable, defaultTypeTable)\r\n    }\r\n\r\n    if (typeTable.parents) {\r\n      setTableDefaults(typeTable.parents, true)\r\n    }\r\n\r\n    for (let key in typeTable.indices) {\r\n      const indexTable = typeTable.indices[key]\r\n      mergeTable(indexTable, typeTable, false)\r\n      if (indexTable.parents) {\r\n        setTableDefaults(indexTable.parents, true)\r\n      }\r\n    }\r\n  }\r\n}\r", "name": "mergeTable", "func_location": "setTableDefaults", "args": ["indexTable", "typeTable", {"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js", "line": 146, "func_start_line": 129}}, {"func_info": {"comment": [], "name": "setTableDefaults", "params": ["table", "allowWildcardSelector"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js", "end_line": 152, "start_line": 129}, "call_info": {"func_end_line": 152, "code": "function setTableDefaults (table, allowWildcardSelector) {\r\n  const defaultTypeTable = allowWildcardSelector ? table['*'] : null\r\n\r\n  for (let type in table) {\r\n    let typeTable = table[type]\r\n    if (typeTable === defaultTypeTable) continue\r\n\r\n    if (defaultTypeTable) {\r\n      mergeTable(typeTable, defaultTypeTable)\r\n    }\r\n\r\n    if (typeTable.parents) {\r\n      setTableDefaults(typeTable.parents, true)\r\n    }\r\n\r\n    for (let key in typeTable.indices) {\r\n      const indexTable = typeTable.indices[key]\r\n      mergeTable(indexTable, typeTable, false)\r\n      if (indexTable.parents) {\r\n        setTableDefaults(indexTable.parents, true)\r\n      }\r\n    }\r\n  }\r\n}\r", "name": "setTableDefaults", "func_location": "setTableDefaults", "args": ["indexTable.parents", {"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/syntax-scope-map.js", "line": 148, "func_start_line": 129}}, {"func_info": {"comment": [" Essential: Retrieves the current {TextBuffer}."], "name": "TextEditor.getBuffer", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 963, "start_line": 963}, "call_info": {"func_end_line": 1359, "comment": [" Essential: Set the text in the given {Range} in buffer coordinates.", "", " * `range` A {Range} or range-compatible {Array}.", " * `text` A {String}", " * `options` (optional) {Object}", "   * `normalizeLineEndings` (optional) {Boolean} (default: true)", "   * `undo` (optional) *Deprecated* {String} 'skip' will skip the undo system. This property is deprecated. Call groupLastChanges() on the {TextBuffer} afterward instead.", "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)", "", " Returns the {Range} of the newly-inserted text."], "code": "  setTextInBufferRange (range, text, options = {}) {\r\n    if (!this.ensureWritable('setTextInBufferRange', options)) return\r\n    return this.getBuffer().setTextInRange(range, text, options)\r\n  }\r", "name": "getBuffer", "func_location": "TextEditor.setTextInBufferRange", "args": ["range", "text", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 1358, "func_start_line": 1356}}, {"func_info": {"comment": [], "name": "TextEditorElement.getComponent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 288, "start_line": 276}, "call_info": {"func_end_line": 112, "code": "  setWidth (width) {\r\n    this.style.width = this.getComponent().getGutterContainerWidth() + width + 'px'\r\n  }\r", "name": "getComponent", "func_location": "TextEditorElement.setWidth", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 111, "func_start_line": 110}}, {"func_info": {"comment": [" Essential: Set the size of current window.", "", " * `width` The {Number} of pixels.", " * `height` The {Number} of pixels."], "name": "AtomEnvironment.setSize", "params": ["width", "height"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 578, "start_line": 576}, "call_info": {"func_end_line": 712, "comment": [" Set the dimensions of the window.", "", " The window will be centered if either the x or y coordinate is not set", " in the dimensions parameter. If x or y are omitted the window will be", " centered. If height or width are omitted only the position will be changed.", "", " * `dimensions` An {Object} with the following keys:", "   * `x` The new x coordinate.", "   * `y` The new y coordinate.", "   * `width` The new width.", "   * `height` The new height."], "code": "  setWindowDimensions ({x, y, width, height}) {\r\n    const steps = []\r\n    if (width != null && height != null) {\r\n      steps.push(this.setSize(width, height))\r\n    }\r\n    if (x != null && y != null) {\r\n      steps.push(this.setPosition(x, y))\r\n    } else {\r\n      steps.push(this.center())\r\n    }\r\n    return Promise.all(steps)\r\n  }\r", "name": "setSize", "func_location": "AtomEnvironment.setWindowDimensions", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 704, "func_start_line": 701}}, {"func_info": {"comment": [" Essential: Set the position of current window.", "", " * `x` The {Number} of pixels.", " * `y` The {Number} of pixels."], "name": "AtomEnvironment.setPosition", "params": ["x", "y"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 593, "start_line": 591}, "call_info": {"func_end_line": 712, "comment": [" Set the dimensions of the window.", "", " The window will be centered if either the x or y coordinate is not set", " in the dimensions parameter. If x or y are omitted the window will be", " centered. If height or width are omitted only the position will be changed.", "", " * `dimensions` An {Object} with the following keys:", "   * `x` The new x coordinate.", "   * `y` The new y coordinate.", "   * `width` The new width.", "   * `height` The new height."], "code": "  setWindowDimensions ({x, y, width, height}) {\r\n    const steps = []\r\n    if (width != null && height != null) {\r\n      steps.push(this.setSize(width, height))\r\n    }\r\n    if (x != null && y != null) {\r\n      steps.push(this.setPosition(x, y))\r\n    } else {\r\n      steps.push(this.center())\r\n    }\r\n    return Promise.all(steps)\r\n  }\r", "name": "setPosition", "func_location": "AtomEnvironment.setWindowDimensions", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 707, "func_start_line": 701}}, {"func_info": {"comment": [" Extended: Move current window to the center of the screen."], "name": "AtomEnvironment.center", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 603, "start_line": 601}, "call_info": {"func_end_line": 712, "comment": [" Set the dimensions of the window.", "", " The window will be centered if either the x or y coordinate is not set", " in the dimensions parameter. If x or y are omitted the window will be", " centered. If height or width are omitted only the position will be changed.", "", " * `dimensions` An {Object} with the following keys:", "   * `x` The new x coordinate.", "   * `y` The new y coordinate.", "   * `width` The new width.", "   * `height` The new height."], "code": "  setWindowDimensions ({x, y, width, height}) {\r\n    const steps = []\r\n    if (width != null && height != null) {\r\n      steps.push(this.setSize(width, height))\r\n    }\r\n    if (x != null && y != null) {\r\n      steps.push(this.setPosition(x, y))\r\n    } else {\r\n      steps.push(this.center())\r\n    }\r\n    return Promise.all(steps)\r\n  }\r", "name": "center", "func_location": "AtomEnvironment.setWindowDimensions", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 709, "func_start_line": 701}}, {"func_info": {"comment": [" Essential: Returns {Boolean} `true` if this editor has been modified."], "name": "TextEditor.isModified", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 1161, "start_line": 1161}, "call_info": {"func_end_line": 1190, "comment": [" Determine whether the user should be prompted to save before closing", " this editor."], "code": "  shouldPromptToSave ({windowCloseRequested, projectHasPaths} = {}) {\r\n    if (windowCloseRequested && projectHasPaths && atom.stateStore.isConnected()) {\r\n      return this.buffer.isInConflict()\r\n    } else {\r\n      return this.isModified() && !this.buffer.hasMultipleEditors()\r\n    }\r\n  }\r", "name": "isModified", "func_location": "TextEditor.shouldPromptToSave", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 1188, "func_start_line": 1184}}, {"func_info": {"comment": [], "name": "Package.activationShouldBeDeferred", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 807, "start_line": 805}, "call_info": {"func_end_line": 158, "code": "  shouldRequireMainModuleOnLoad () {\r\n    return !(\r\n      this.metadata.deserializers ||\r\n      this.metadata.viewProviders ||\r\n      this.metadata.configSchema ||\r\n      this.activationShouldBeDeferred() ||\r\n      localStorage.getItem(this.getCanDeferMainModuleRequireStorageKey()) === 'true'\r\n    )\r\n  }\r", "name": "activationShouldBeDeferred", "func_location": "Package.shouldRequireMainModuleOnLoad", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 155, "func_start_line": 150}}, {"func_info": {"comment": [], "name": "Package.getCanDeferMainModuleRequireStorageKey", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 1043, "start_line": 1041}, "call_info": {"func_end_line": 158, "code": "  shouldRequireMainModuleOnLoad () {\r\n    return !(\r\n      this.metadata.deserializers ||\r\n      this.metadata.viewProviders ||\r\n      this.metadata.configSchema ||\r\n      this.activationShouldBeDeferred() ||\r\n      localStorage.getItem(this.getCanDeferMainModuleRequireStorageKey()) === 'true'\r\n    )\r\n  }\r", "name": "getCanDeferMainModuleRequireStorageKey", "func_location": "Package.shouldRequireMainModuleOnLoad", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 156, "func_start_line": 150}}, {"func_info": {"comment": [], "name": "arraysEqual", "params": ["a", "b"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4362, "start_line": 4356}, "call_info": {"func_end_line": 3925, "code": "  shouldUpdate (newProps) {\r\n    const oldProps = this.props\r\n    if (oldProps.top !== newProps.top) return true\r\n    if (oldProps.height !== newProps.height) return true\r\n    if (oldProps.width !== newProps.width) return true\r\n    if (oldProps.lineHeight !== newProps.lineHeight) return true\r\n    if (oldProps.tileStartRow !== newProps.tileStartRow) return true\r\n    if (oldProps.tileEndRow !== newProps.tileEndRow) return true\r\n    if (!arraysEqual(oldProps.screenLines, newProps.screenLines)) return true\r\n    if (!arraysEqual(oldProps.lineDecorations, newProps.lineDecorations)) return true\r\n\r\n    if (oldProps.blockDecorations && newProps.blockDecorations) {\r\n      if (oldProps.blockDecorations.size !== newProps.blockDecorations.size) return true\r\n\r\n      let blockDecorationsChanged = false\r\n\r\n      oldProps.blockDecorations.forEach((oldDecorations, screenLineId) => {\r\n        if (!blockDecorationsChanged) {\r\n          const newDecorations = newProps.blockDecorations.get(screenLineId)\r\n          blockDecorationsChanged = (newDecorations == null || !arraysEqual(oldDecorations, newDecorations))\r\n        }\r\n      })\r\n      if (blockDecorationsChanged) return true\r\n\r\n      newProps.blockDecorations.forEach((newDecorations, screenLineId) => {\r\n        if (!blockDecorationsChanged) {\r\n          const oldDecorations = oldProps.blockDecorations.get(screenLineId)\r\n          blockDecorationsChanged = (oldDecorations == null)\r\n        }\r\n      })\r\n      if (blockDecorationsChanged) return true\r\n    } else if (oldProps.blockDecorations) {\r\n      return true\r\n    } else if (newProps.blockDecorations) {\r\n      return true\r\n    }\r\n\r\n    if (oldProps.textDecorations.length !== newProps.textDecorations.length) return true\r\n    for (let i = 0; i < oldProps.textDecorations.length; i++) {\r\n      if (!textDecorationsEqual(oldProps.textDecorations[i], newProps.textDecorations[i])) return true\r\n    }\r\n\r\n    return false\r\n  }\r", "name": "arraysEqual", "func_location": "LinesTileComponent.shouldUpdate", "args": ["oldProps.screenLines", "newProps.screenLines"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3890, "func_start_line": 3882}}, {"func_info": {"comment": [], "name": "arraysEqual", "params": ["a", "b"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4362, "start_line": 4356}, "call_info": {"func_end_line": 3925, "code": "  shouldUpdate (newProps) {\r\n    const oldProps = this.props\r\n    if (oldProps.top !== newProps.top) return true\r\n    if (oldProps.height !== newProps.height) return true\r\n    if (oldProps.width !== newProps.width) return true\r\n    if (oldProps.lineHeight !== newProps.lineHeight) return true\r\n    if (oldProps.tileStartRow !== newProps.tileStartRow) return true\r\n    if (oldProps.tileEndRow !== newProps.tileEndRow) return true\r\n    if (!arraysEqual(oldProps.screenLines, newProps.screenLines)) return true\r\n    if (!arraysEqual(oldProps.lineDecorations, newProps.lineDecorations)) return true\r\n\r\n    if (oldProps.blockDecorations && newProps.blockDecorations) {\r\n      if (oldProps.blockDecorations.size !== newProps.blockDecorations.size) return true\r\n\r\n      let blockDecorationsChanged = false\r\n\r\n      oldProps.blockDecorations.forEach((oldDecorations, screenLineId) => {\r\n        if (!blockDecorationsChanged) {\r\n          const newDecorations = newProps.blockDecorations.get(screenLineId)\r\n          blockDecorationsChanged = (newDecorations == null || !arraysEqual(oldDecorations, newDecorations))\r\n        }\r\n      })\r\n      if (blockDecorationsChanged) return true\r\n\r\n      newProps.blockDecorations.forEach((newDecorations, screenLineId) => {\r\n        if (!blockDecorationsChanged) {\r\n          const oldDecorations = oldProps.blockDecorations.get(screenLineId)\r\n          blockDecorationsChanged = (oldDecorations == null)\r\n        }\r\n      })\r\n      if (blockDecorationsChanged) return true\r\n    } else if (oldProps.blockDecorations) {\r\n      return true\r\n    } else if (newProps.blockDecorations) {\r\n      return true\r\n    }\r\n\r\n    if (oldProps.textDecorations.length !== newProps.textDecorations.length) return true\r\n    for (let i = 0; i < oldProps.textDecorations.length; i++) {\r\n      if (!textDecorationsEqual(oldProps.textDecorations[i], newProps.textDecorations[i])) return true\r\n    }\r\n\r\n    return false\r\n  }\r", "name": "arraysEqual", "func_location": "LinesTileComponent.shouldUpdate", "args": ["oldProps.lineDecorations", "newProps.lineDecorations"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3891, "func_start_line": 3882}}, {"func_info": {"comment": [], "name": "textDecorationsEqual", "params": ["oldDecorations", "newDecorations"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4354, "start_line": 4342}, "call_info": {"func_end_line": 3925, "code": "  shouldUpdate (newProps) {\r\n    const oldProps = this.props\r\n    if (oldProps.top !== newProps.top) return true\r\n    if (oldProps.height !== newProps.height) return true\r\n    if (oldProps.width !== newProps.width) return true\r\n    if (oldProps.lineHeight !== newProps.lineHeight) return true\r\n    if (oldProps.tileStartRow !== newProps.tileStartRow) return true\r\n    if (oldProps.tileEndRow !== newProps.tileEndRow) return true\r\n    if (!arraysEqual(oldProps.screenLines, newProps.screenLines)) return true\r\n    if (!arraysEqual(oldProps.lineDecorations, newProps.lineDecorations)) return true\r\n\r\n    if (oldProps.blockDecorations && newProps.blockDecorations) {\r\n      if (oldProps.blockDecorations.size !== newProps.blockDecorations.size) return true\r\n\r\n      let blockDecorationsChanged = false\r\n\r\n      oldProps.blockDecorations.forEach((oldDecorations, screenLineId) => {\r\n        if (!blockDecorationsChanged) {\r\n          const newDecorations = newProps.blockDecorations.get(screenLineId)\r\n          blockDecorationsChanged = (newDecorations == null || !arraysEqual(oldDecorations, newDecorations))\r\n        }\r\n      })\r\n      if (blockDecorationsChanged) return true\r\n\r\n      newProps.blockDecorations.forEach((newDecorations, screenLineId) => {\r\n        if (!blockDecorationsChanged) {\r\n          const oldDecorations = oldProps.blockDecorations.get(screenLineId)\r\n          blockDecorationsChanged = (oldDecorations == null)\r\n        }\r\n      })\r\n      if (blockDecorationsChanged) return true\r\n    } else if (oldProps.blockDecorations) {\r\n      return true\r\n    } else if (newProps.blockDecorations) {\r\n      return true\r\n    }\r\n\r\n    if (oldProps.textDecorations.length !== newProps.textDecorations.length) return true\r\n    for (let i = 0; i < oldProps.textDecorations.length; i++) {\r\n      if (!textDecorationsEqual(oldProps.textDecorations[i], newProps.textDecorations[i])) return true\r\n    }\r\n\r\n    return false\r\n  }\r", "name": "textDecorationsEqual", "func_location": "LinesTileComponent.shouldUpdate", "args": ["oldProps.textDecorations.i", "newProps.textDecorations.i"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3921, "func_start_line": 3882}}, {"func_info": {"comment": [], "name": "arraysEqual", "params": ["a", "b"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4362, "start_line": 4356}, "call_info": {"func_end_line": 3365, "code": "  shouldUpdate (newProps) {\r\n    const oldProps = this.props\r\n\r\n    if (oldProps.showLineNumbers !== newProps.showLineNumbers) return true\r\n    if (oldProps.height !== newProps.height) return true\r\n    if (oldProps.width !== newProps.width) return true\r\n    if (oldProps.lineHeight !== newProps.lineHeight) return true\r\n    if (oldProps.startRow !== newProps.startRow) return true\r\n    if (oldProps.endRow !== newProps.endRow) return true\r\n    if (oldProps.rowsPerTile !== newProps.rowsPerTile) return true\r\n    if (oldProps.maxDigits !== newProps.maxDigits) return true\r\n    if (oldProps.labelFn !== newProps.labelFn) return true\r\n    if (oldProps.className !== newProps.className) return true\r\n    if (newProps.didMeasureVisibleBlockDecoration) return true\r\n    if (!arraysEqual(oldProps.keys, newProps.keys)) return true\r\n    if (!arraysEqual(oldProps.bufferRows, newProps.bufferRows)) return true\r\n    if (!arraysEqual(oldProps.foldableFlags, newProps.foldableFlags)) return true\r\n    if (!arraysEqual(oldProps.decorations, newProps.decorations)) return true\r\n\r\n    let oldTileStartRow = oldProps.startRow\r\n    let newTileStartRow = newProps.startRow\r\n    while (oldTileStartRow < oldProps.endRow || newTileStartRow < newProps.endRow) {\r\n      let oldTileBlockDecorations = oldProps.blockDecorations.get(oldTileStartRow)\r\n      let newTileBlockDecorations = newProps.blockDecorations.get(newTileStartRow)\r\n\r\n      if (oldTileBlockDecorations && newTileBlockDecorations) {\r\n        if (oldTileBlockDecorations.size !== newTileBlockDecorations.size) return true\r\n\r\n        let blockDecorationsChanged = false\r\n\r\n        oldTileBlockDecorations.forEach((oldDecorations, screenLineId) => {\r\n          if (!blockDecorationsChanged) {\r\n            const newDecorations = newTileBlockDecorations.get(screenLineId)\r\n            blockDecorationsChanged = (newDecorations == null || !arraysEqual(oldDecorations, newDecorations))\r\n          }\r\n        })\r\n        if (blockDecorationsChanged) return true\r\n\r\n        newTileBlockDecorations.forEach((newDecorations, screenLineId) => {\r\n          if (!blockDecorationsChanged) {\r\n            const oldDecorations = oldTileBlockDecorations.get(screenLineId)\r\n            blockDecorationsChanged = (oldDecorations == null)\r\n          }\r\n        })\r\n        if (blockDecorationsChanged) return true\r\n      } else if (oldTileBlockDecorations) {\r\n        return true\r\n      } else if (newTileBlockDecorations) {\r\n        return true\r\n      }\r\n\r\n      oldTileStartRow += oldProps.rowsPerTile\r\n      newTileStartRow += newProps.rowsPerTile\r\n    }\r\n\r\n    return false\r\n  }\r", "name": "arraysEqual", "func_location": "LineNumberGutterComponent.shouldUpdate", "args": ["oldProps.keys", "newProps.keys"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3323, "func_start_line": 3309}}, {"func_info": {"comment": [], "name": "arraysEqual", "params": ["a", "b"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4362, "start_line": 4356}, "call_info": {"func_end_line": 3365, "code": "  shouldUpdate (newProps) {\r\n    const oldProps = this.props\r\n\r\n    if (oldProps.showLineNumbers !== newProps.showLineNumbers) return true\r\n    if (oldProps.height !== newProps.height) return true\r\n    if (oldProps.width !== newProps.width) return true\r\n    if (oldProps.lineHeight !== newProps.lineHeight) return true\r\n    if (oldProps.startRow !== newProps.startRow) return true\r\n    if (oldProps.endRow !== newProps.endRow) return true\r\n    if (oldProps.rowsPerTile !== newProps.rowsPerTile) return true\r\n    if (oldProps.maxDigits !== newProps.maxDigits) return true\r\n    if (oldProps.labelFn !== newProps.labelFn) return true\r\n    if (oldProps.className !== newProps.className) return true\r\n    if (newProps.didMeasureVisibleBlockDecoration) return true\r\n    if (!arraysEqual(oldProps.keys, newProps.keys)) return true\r\n    if (!arraysEqual(oldProps.bufferRows, newProps.bufferRows)) return true\r\n    if (!arraysEqual(oldProps.foldableFlags, newProps.foldableFlags)) return true\r\n    if (!arraysEqual(oldProps.decorations, newProps.decorations)) return true\r\n\r\n    let oldTileStartRow = oldProps.startRow\r\n    let newTileStartRow = newProps.startRow\r\n    while (oldTileStartRow < oldProps.endRow || newTileStartRow < newProps.endRow) {\r\n      let oldTileBlockDecorations = oldProps.blockDecorations.get(oldTileStartRow)\r\n      let newTileBlockDecorations = newProps.blockDecorations.get(newTileStartRow)\r\n\r\n      if (oldTileBlockDecorations && newTileBlockDecorations) {\r\n        if (oldTileBlockDecorations.size !== newTileBlockDecorations.size) return true\r\n\r\n        let blockDecorationsChanged = false\r\n\r\n        oldTileBlockDecorations.forEach((oldDecorations, screenLineId) => {\r\n          if (!blockDecorationsChanged) {\r\n            const newDecorations = newTileBlockDecorations.get(screenLineId)\r\n            blockDecorationsChanged = (newDecorations == null || !arraysEqual(oldDecorations, newDecorations))\r\n          }\r\n        })\r\n        if (blockDecorationsChanged) return true\r\n\r\n        newTileBlockDecorations.forEach((newDecorations, screenLineId) => {\r\n          if (!blockDecorationsChanged) {\r\n            const oldDecorations = oldTileBlockDecorations.get(screenLineId)\r\n            blockDecorationsChanged = (oldDecorations == null)\r\n          }\r\n        })\r\n        if (blockDecorationsChanged) return true\r\n      } else if (oldTileBlockDecorations) {\r\n        return true\r\n      } else if (newTileBlockDecorations) {\r\n        return true\r\n      }\r\n\r\n      oldTileStartRow += oldProps.rowsPerTile\r\n      newTileStartRow += newProps.rowsPerTile\r\n    }\r\n\r\n    return false\r\n  }\r", "name": "arraysEqual", "func_location": "LineNumberGutterComponent.shouldUpdate", "args": ["oldProps.bufferRows", "newProps.bufferRows"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3324, "func_start_line": 3309}}, {"func_info": {"comment": [], "name": "arraysEqual", "params": ["a", "b"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4362, "start_line": 4356}, "call_info": {"func_end_line": 3365, "code": "  shouldUpdate (newProps) {\r\n    const oldProps = this.props\r\n\r\n    if (oldProps.showLineNumbers !== newProps.showLineNumbers) return true\r\n    if (oldProps.height !== newProps.height) return true\r\n    if (oldProps.width !== newProps.width) return true\r\n    if (oldProps.lineHeight !== newProps.lineHeight) return true\r\n    if (oldProps.startRow !== newProps.startRow) return true\r\n    if (oldProps.endRow !== newProps.endRow) return true\r\n    if (oldProps.rowsPerTile !== newProps.rowsPerTile) return true\r\n    if (oldProps.maxDigits !== newProps.maxDigits) return true\r\n    if (oldProps.labelFn !== newProps.labelFn) return true\r\n    if (oldProps.className !== newProps.className) return true\r\n    if (newProps.didMeasureVisibleBlockDecoration) return true\r\n    if (!arraysEqual(oldProps.keys, newProps.keys)) return true\r\n    if (!arraysEqual(oldProps.bufferRows, newProps.bufferRows)) return true\r\n    if (!arraysEqual(oldProps.foldableFlags, newProps.foldableFlags)) return true\r\n    if (!arraysEqual(oldProps.decorations, newProps.decorations)) return true\r\n\r\n    let oldTileStartRow = oldProps.startRow\r\n    let newTileStartRow = newProps.startRow\r\n    while (oldTileStartRow < oldProps.endRow || newTileStartRow < newProps.endRow) {\r\n      let oldTileBlockDecorations = oldProps.blockDecorations.get(oldTileStartRow)\r\n      let newTileBlockDecorations = newProps.blockDecorations.get(newTileStartRow)\r\n\r\n      if (oldTileBlockDecorations && newTileBlockDecorations) {\r\n        if (oldTileBlockDecorations.size !== newTileBlockDecorations.size) return true\r\n\r\n        let blockDecorationsChanged = false\r\n\r\n        oldTileBlockDecorations.forEach((oldDecorations, screenLineId) => {\r\n          if (!blockDecorationsChanged) {\r\n            const newDecorations = newTileBlockDecorations.get(screenLineId)\r\n            blockDecorationsChanged = (newDecorations == null || !arraysEqual(oldDecorations, newDecorations))\r\n          }\r\n        })\r\n        if (blockDecorationsChanged) return true\r\n\r\n        newTileBlockDecorations.forEach((newDecorations, screenLineId) => {\r\n          if (!blockDecorationsChanged) {\r\n            const oldDecorations = oldTileBlockDecorations.get(screenLineId)\r\n            blockDecorationsChanged = (oldDecorations == null)\r\n          }\r\n        })\r\n        if (blockDecorationsChanged) return true\r\n      } else if (oldTileBlockDecorations) {\r\n        return true\r\n      } else if (newTileBlockDecorations) {\r\n        return true\r\n      }\r\n\r\n      oldTileStartRow += oldProps.rowsPerTile\r\n      newTileStartRow += newProps.rowsPerTile\r\n    }\r\n\r\n    return false\r\n  }\r", "name": "arraysEqual", "func_location": "LineNumberGutterComponent.shouldUpdate", "args": ["oldProps.foldableFlags", "newProps.foldableFlags"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3325, "func_start_line": 3309}}, {"func_info": {"comment": [], "name": "arraysEqual", "params": ["a", "b"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4362, "start_line": 4356}, "call_info": {"func_end_line": 3365, "code": "  shouldUpdate (newProps) {\r\n    const oldProps = this.props\r\n\r\n    if (oldProps.showLineNumbers !== newProps.showLineNumbers) return true\r\n    if (oldProps.height !== newProps.height) return true\r\n    if (oldProps.width !== newProps.width) return true\r\n    if (oldProps.lineHeight !== newProps.lineHeight) return true\r\n    if (oldProps.startRow !== newProps.startRow) return true\r\n    if (oldProps.endRow !== newProps.endRow) return true\r\n    if (oldProps.rowsPerTile !== newProps.rowsPerTile) return true\r\n    if (oldProps.maxDigits !== newProps.maxDigits) return true\r\n    if (oldProps.labelFn !== newProps.labelFn) return true\r\n    if (oldProps.className !== newProps.className) return true\r\n    if (newProps.didMeasureVisibleBlockDecoration) return true\r\n    if (!arraysEqual(oldProps.keys, newProps.keys)) return true\r\n    if (!arraysEqual(oldProps.bufferRows, newProps.bufferRows)) return true\r\n    if (!arraysEqual(oldProps.foldableFlags, newProps.foldableFlags)) return true\r\n    if (!arraysEqual(oldProps.decorations, newProps.decorations)) return true\r\n\r\n    let oldTileStartRow = oldProps.startRow\r\n    let newTileStartRow = newProps.startRow\r\n    while (oldTileStartRow < oldProps.endRow || newTileStartRow < newProps.endRow) {\r\n      let oldTileBlockDecorations = oldProps.blockDecorations.get(oldTileStartRow)\r\n      let newTileBlockDecorations = newProps.blockDecorations.get(newTileStartRow)\r\n\r\n      if (oldTileBlockDecorations && newTileBlockDecorations) {\r\n        if (oldTileBlockDecorations.size !== newTileBlockDecorations.size) return true\r\n\r\n        let blockDecorationsChanged = false\r\n\r\n        oldTileBlockDecorations.forEach((oldDecorations, screenLineId) => {\r\n          if (!blockDecorationsChanged) {\r\n            const newDecorations = newTileBlockDecorations.get(screenLineId)\r\n            blockDecorationsChanged = (newDecorations == null || !arraysEqual(oldDecorations, newDecorations))\r\n          }\r\n        })\r\n        if (blockDecorationsChanged) return true\r\n\r\n        newTileBlockDecorations.forEach((newDecorations, screenLineId) => {\r\n          if (!blockDecorationsChanged) {\r\n            const oldDecorations = oldTileBlockDecorations.get(screenLineId)\r\n            blockDecorationsChanged = (oldDecorations == null)\r\n          }\r\n        })\r\n        if (blockDecorationsChanged) return true\r\n      } else if (oldTileBlockDecorations) {\r\n        return true\r\n      } else if (newTileBlockDecorations) {\r\n        return true\r\n      }\r\n\r\n      oldTileStartRow += oldProps.rowsPerTile\r\n      newTileStartRow += newProps.rowsPerTile\r\n    }\r\n\r\n    return false\r\n  }\r", "name": "arraysEqual", "func_location": "LineNumberGutterComponent.shouldUpdate", "args": ["oldProps.decorations", "newProps.decorations"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3326, "func_start_line": 3309}}, {"func_info": {"comment": [], "name": "Dock.setState", "params": ["newState"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 177, "start_line": 144}, "call_info": {"func_end_line": 121, "comment": [" Extended: Show the dock without focusing it."], "code": "  show () {\r\n    this.setState({visible: true})\r\n  }\r", "name": "setState", "func_location": "Dock.show", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 120, "func_start_line": 119}}, {"func_info": {"comment": [], "name": "ApplicationDelegate.getCurrentWindow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js", "end_line": 40, "start_line": 38}, "call_info": {"func_end_line": 260, "code": "  showSaveDialog (options, callback) {\r\n    if (typeof callback === 'function') {\r\n      // Async\r\n      this.getCurrentWindow().showSaveDialog(options, callback)\r\n    } else {\r\n      // Sync\r\n      if (typeof options === 'string') {\r\n        options = {defaultPath: options}\r\n      }\r\n      return this.getCurrentWindow().showSaveDialog(options)\r\n    }\r\n  }\r", "name": "getCurrentWindow", "func_location": "ApplicationDelegate.showSaveDialog", "args": ["options", "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js", "line": 252, "func_start_line": 249}}, {"func_info": {"comment": [], "name": "ApplicationDelegate.getCurrentWindow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js", "end_line": 40, "start_line": 38}, "call_info": {"func_end_line": 260, "code": "  showSaveDialog (options, callback) {\r\n    if (typeof callback === 'function') {\r\n      // Async\r\n      this.getCurrentWindow().showSaveDialog(options, callback)\r\n    } else {\r\n      // Sync\r\n      if (typeof options === 'string') {\r\n        options = {defaultPath: options}\r\n      }\r\n      return this.getCurrentWindow().showSaveDialog(options)\r\n    }\r\n  }\r", "name": "getCurrentWindow", "func_location": "ApplicationDelegate.showSaveDialog", "args": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/application-delegate.js", "line": 258, "func_start_line": 249}}, {"func_info": {"comment": [" Flattens the given menu and submenu items into an single Array.", "", " menu - A complete menu configuration object for atom-shell's menu API.", "", " Returns an Array of native menu items."], "name": "ApplicationMenu.flattenMenuItems", "params": ["menu"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "end_line": 76, "start_line": 67}, "call_info": {"func_end_line": 140, "comment": [" Sets the proper visible state the update menu items"], "code": "  showUpdateMenuItem (state) {\r\n    const items = this.flattenMenuItems(this.menu)\r\n    const checkForUpdateItem = items.find(({label}) => label === 'Check for Update')\r\n    const checkingForUpdateItem = items.find(({label}) => label === 'Checking for Update')\r\n    const downloadingUpdateItem = items.find(({label}) => label === 'Downloading Update')\r\n    const installUpdateItem = items.find(({label}) => label === 'Restart and Install Update')\r\n\r\n    if (!checkForUpdateItem || !checkingForUpdateItem ||\r\n        !downloadingUpdateItem || !installUpdateItem) return\r\n\r\n    checkForUpdateItem.visible = false\r\n    checkingForUpdateItem.visible = false\r\n    downloadingUpdateItem.visible = false\r\n    installUpdateItem.visible = false\r\n\r\n    switch (state) {\r\n      case 'idle':\r\n      case 'error':\r\n      case 'no-update-available':\r\n        checkForUpdateItem.visible = true\r\n        break\r\n      case 'checking':\r\n        checkingForUpdateItem.visible = true\r\n        break\r\n      case 'downloading':\r\n        downloadingUpdateItem.visible = true\r\n        break\r\n      case 'update-available':\r\n        installUpdateItem.visible = true\r\n        break\r\n    }\r\n  }\r", "name": "flattenMenuItems", "func_location": "ApplicationMenu.showUpdateMenuItem", "args": [".menu"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "line": 110, "func_start_line": 109}}, {"func_info": {"comment": [" Public: Returns the current buffer position as an Array."], "name": "Cursor.getBufferPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 93, "start_line": 91}, "call_info": {"func_end_line": 439, "comment": [" Public: Moves the cursor to the beginning of the buffer line, skipping all", " whitespace."], "code": "  skipLeadingWhitespace () {\r\n    const position = this.getBufferPosition()\r\n    const scanRange = this.getCurrentLineBufferRange()\r\n    let endOfLeadingWhitespace = null\r\n    this.editor.scanInBufferRange(/^[ \\t]*/, scanRange, ({range}) => {\r\n      endOfLeadingWhitespace = range.end\r\n    })\r\n\r\n    if (endOfLeadingWhitespace.isGreaterThan(position)) this.setBufferPosition(endOfLeadingWhitespace)\r\n  }\r", "name": "getBufferPosition", "func_location": "Cursor.skipLeadingWhitespace", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 431, "func_start_line": 430}}, {"func_info": {"comment": [" Public: Returns the buffer Range for the current line.", "", " * `options` (optional) {Object}", "   * `includeNewline` A {Boolean} which controls whether the Range should", "     include the newline."], "name": "Cursor.getCurrentLineBufferRange", "params": ["options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 625, "start_line": 623}, "call_info": {"func_end_line": 439, "comment": [" Public: Moves the cursor to the beginning of the buffer line, skipping all", " whitespace."], "code": "  skipLeadingWhitespace () {\r\n    const position = this.getBufferPosition()\r\n    const scanRange = this.getCurrentLineBufferRange()\r\n    let endOfLeadingWhitespace = null\r\n    this.editor.scanInBufferRange(/^[ \\t]*/, scanRange, ({range}) => {\r\n      endOfLeadingWhitespace = range.end\r\n    })\r\n\r\n    if (endOfLeadingWhitespace.isGreaterThan(position)) this.setBufferPosition(endOfLeadingWhitespace)\r\n  }\r", "name": "getCurrentLineBufferRange", "func_location": "Cursor.skipLeadingWhitespace", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 432, "func_start_line": 430}}, {"func_info": {"comment": [" Public: Moves a cursor to a given buffer position.", "", " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.", " * `options` (optional) {Object} with the following keys:", "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new", "     position. Defaults to `true` if this is the most recently added cursor,", "     `false` otherwise."], "name": "Cursor.setBufferPosition", "params": ["bufferPosition", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 88, "start_line": 84}, "call_info": {"func_end_line": 439, "comment": [" Public: Moves the cursor to the beginning of the buffer line, skipping all", " whitespace."], "code": "  skipLeadingWhitespace () {\r\n    const position = this.getBufferPosition()\r\n    const scanRange = this.getCurrentLineBufferRange()\r\n    let endOfLeadingWhitespace = null\r\n    this.editor.scanInBufferRange(/^[ \\t]*/, scanRange, ({range}) => {\r\n      endOfLeadingWhitespace = range.end\r\n    })\r\n\r\n    if (endOfLeadingWhitespace.isGreaterThan(position)) this.setBufferPosition(endOfLeadingWhitespace)\r\n  }\r", "name": "setBufferPosition", "func_location": "Cursor.skipLeadingWhitespace", "args": ["position"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 438, "func_start_line": 430}}, {"func_info": {"comment": [], "name": "findEdgesInGroup", "params": ["groups", "i", "edges"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js", "end_line": 154, "start_line": 132}, "call_info": {"func_end_line": 166, "code": "function sortGroups (groups) {\r\n  const originalOrder = groups.map((item, i) => i)\r\n  const edges = new Map()\r\n\r\n  for (let i = 0; i < groups.length; i++) {\r\n    findEdgesInGroup(groups, i, edges)\r\n  }\r\n\r\n  const sortedGroupIndexes = sortTopologically(originalOrder, edges)\r\n  return sortedGroupIndexes.map(i => groups[i])\r\n}\r", "name": "findEdgesInGroup", "func_location": "sortGroups", "args": ["groups", "i", "edges"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js", "line": 161, "func_start_line": 156}}, {"func_info": {"comment": [" Sort nodes topologically using a depth-first approach. Encountered cycles", " are broken."], "name": "sortTopologically", "params": ["originalOrder", "edgesById"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js", "end_line": 69, "start_line": 49}, "call_info": {"func_end_line": 166, "code": "function sortGroups (groups) {\r\n  const originalOrder = groups.map((item, i) => i)\r\n  const edges = new Map()\r\n\r\n  for (let i = 0; i < groups.length; i++) {\r\n    findEdgesInGroup(groups, i, edges)\r\n  }\r\n\r\n  const sortedGroupIndexes = sortTopologically(originalOrder, edges)\r\n  return sortedGroupIndexes.map(i => groups[i])\r\n}\r", "name": "sortTopologically", "func_location": "sortGroups", "args": ["originalOrder", "edges"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js", "line": 164, "func_start_line": 156}}, {"func_info": {"comment": [" Sort nodes topologically using a depth-first approach. Encountered cycles", " are broken."], "name": "sortTopologically", "params": ["originalOrder", "edgesById"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js", "end_line": 69, "start_line": 49}, "call_info": {"func_end_line": 130, "code": "function sortItemsInGroup (group) {\r\n  const originalOrder = group.map((node, i) => i)\r\n  const edges = new Map()\r\n  const commandToIndex = new Map(group.map((item, i) => [item.command, i]))\r\n\r\n  group.forEach((item, i) => {\r\n    if (item.before) {\r\n      item.before.forEach(toCommand => {\r\n        const to = commandToIndex.get(toCommand)\r\n        if (to != null) {\r\n          pushOntoMultiMap(edges, to, i)\r\n        }\r\n      })\r\n    }\r\n    if (item.after) {\r\n      item.after.forEach(toCommand => {\r\n        const to = commandToIndex.get(toCommand)\r\n        if (to != null) {\r\n          pushOntoMultiMap(edges, i, to)\r\n        }\r\n      })\r\n    }\r\n  })\r\n\r\n  const sortedNodes = sortTopologically(originalOrder, edges)\r\n\r\n  return sortedNodes.map(i => group[i])\r\n}\r", "name": "sortTopologically", "func_location": "sortItemsInGroup", "args": ["originalOrder", "edges"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js", "line": 127, "func_start_line": 103}}, {"func_info": {"comment": [" UTILS"], "name": "splitArray", "params": ["arr", "predicate"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js", "end_line": 17, "start_line": 3}, "call_info": {"func_end_line": 184, "code": "function sortMenuItems (menuItems) {\r\n  // Split the items into their implicit groups based upon separators.\r\n  const groups = splitArray(menuItems, isSeparator)\r\n  // Merge groups that contain before/after references to eachother.\r\n  const mergedGroups = mergeGroups(groups)\r\n  // Sort each individual group internally.\r\n  const mergedGroupsWithSortedItems = mergedGroups.map(sortItemsInGroup)\r\n  // Sort the groups based upon their beforeGroupContaining/afterGroupContaining\r\n  // references.\r\n  const sortedGroups = sortGroups(mergedGroupsWithSortedItems)\r\n  // Join the groups back\r\n  return joinArrays(sortedGroups, { type: 'separator' })\r\n}\r", "name": "splitArray", "func_location": "sortMenuItems", "args": ["menuItems", "isSeparator"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js", "line": 174, "func_start_line": 172}}, {"func_info": {"comment": [" Merge groups based on before/after positions", " Mutates both the array of groups, and the individual group arrays."], "name": "mergeGroups", "params": ["groups"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js", "end_line": 101, "start_line": 95}, "call_info": {"func_end_line": 184, "code": "function sortMenuItems (menuItems) {\r\n  // Split the items into their implicit groups based upon separators.\r\n  const groups = splitArray(menuItems, isSeparator)\r\n  // Merge groups that contain before/after references to eachother.\r\n  const mergedGroups = mergeGroups(groups)\r\n  // Sort each individual group internally.\r\n  const mergedGroupsWithSortedItems = mergedGroups.map(sortItemsInGroup)\r\n  // Sort the groups based upon their beforeGroupContaining/afterGroupContaining\r\n  // references.\r\n  const sortedGroups = sortGroups(mergedGroupsWithSortedItems)\r\n  // Join the groups back\r\n  return joinArrays(sortedGroups, { type: 'separator' })\r\n}\r", "name": "mergeGroups", "func_location": "sortMenuItems", "args": ["groups"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js", "line": 176, "func_start_line": 172}}, {"func_info": {"comment": [], "name": "sortGroups", "params": ["groups"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js", "end_line": 166, "start_line": 156}, "call_info": {"func_end_line": 184, "code": "function sortMenuItems (menuItems) {\r\n  // Split the items into their implicit groups based upon separators.\r\n  const groups = splitArray(menuItems, isSeparator)\r\n  // Merge groups that contain before/after references to eachother.\r\n  const mergedGroups = mergeGroups(groups)\r\n  // Sort each individual group internally.\r\n  const mergedGroupsWithSortedItems = mergedGroups.map(sortItemsInGroup)\r\n  // Sort the groups based upon their beforeGroupContaining/afterGroupContaining\r\n  // references.\r\n  const sortedGroups = sortGroups(mergedGroupsWithSortedItems)\r\n  // Join the groups back\r\n  return joinArrays(sortedGroups, { type: 'separator' })\r\n}\r", "name": "sortGroups", "func_location": "sortMenuItems", "args": ["mergedGroupsWithSortedItems"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js", "line": 181, "func_start_line": 172}}, {"func_info": {"comment": [], "name": "joinArrays", "params": ["arrays", "joiner"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js", "end_line": 28, "start_line": 19}, "call_info": {"func_end_line": 184, "code": "function sortMenuItems (menuItems) {\r\n  // Split the items into their implicit groups based upon separators.\r\n  const groups = splitArray(menuItems, isSeparator)\r\n  // Merge groups that contain before/after references to eachother.\r\n  const mergedGroups = mergeGroups(groups)\r\n  // Sort each individual group internally.\r\n  const mergedGroupsWithSortedItems = mergedGroups.map(sortItemsInGroup)\r\n  // Sort the groups based upon their beforeGroupContaining/afterGroupContaining\r\n  // references.\r\n  const sortedGroups = sortGroups(mergedGroupsWithSortedItems)\r\n  // Join the groups back\r\n  return joinArrays(sortedGroups, { type: 'separator' })\r\n}\r", "name": "joinArrays", "func_location": "sortMenuItems", "args": ["sortedGroups", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-sort-helpers.js", "line": 183, "func_start_line": 172}}, {"func_info": {"comment": [], "name": "BufferedProcess.spawn", "params": ["command", "args", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "end_line": 250, "start_line": 244}, "call_info": {"func_end_line": 103, "comment": [" Windows has a bunch of special rules that node still doesn't take care of for you"], "code": "  spawnWithEscapedWindowsArgs (command, args, options) {\r\n    let cmdArgs = []\r\n    // Quote all arguments and escapes inner quotes\r\n    if (args) {\r\n      cmdArgs = args.filter((arg) => arg != null)\r\n        .map((arg) => {\r\n          if (this.isExplorerCommand(command) && /^\\/[a-zA-Z]+,.*$/.test(arg)) {\r\n            // Don't wrap /root,C:\\folder style arguments to explorer calls in\r\n            // quotes since they will not be interpreted correctly if they are\r\n            return arg\r\n          } else {\r\n            // Escape double quotes by putting a backslash in front of them\r\n            return `\\\"${arg.toString().replace(/\"/g, '\\\\\"')}\\\"`\r\n          }\r\n        })\r\n    }\r\n\r\n    // The command itself is quoted if it contains spaces, &, ^, | or # chars\r\n    cmdArgs.unshift(/\\s|&|\\^|\\(|\\)|\\||#/.test(command) ? `\\\"${command}\\\"` : command)\r\n\r\n    const cmdOptions = _.clone(options)\r\n    cmdOptions.windowsVerbatimArguments = true\r\n\r\n    this.spawn(this.getCmdPath(), ['/s', '/d', '/c', `\\\"${cmdArgs.join(' ')}\\\"`], cmdOptions)\r\n  }\r", "name": "spawn", "func_location": "BufferedProcess.spawnWithEscapedWindowsArgs", "args": [null, null, "cmdOptions"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "line": 102, "func_start_line": 79}}, {"func_info": {"comment": [], "name": "BufferedProcess.getCmdPath", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "end_line": 230, "start_line": 222}, "call_info": {"func_end_line": 103, "comment": [" Windows has a bunch of special rules that node still doesn't take care of for you"], "code": "  spawnWithEscapedWindowsArgs (command, args, options) {\r\n    let cmdArgs = []\r\n    // Quote all arguments and escapes inner quotes\r\n    if (args) {\r\n      cmdArgs = args.filter((arg) => arg != null)\r\n        .map((arg) => {\r\n          if (this.isExplorerCommand(command) && /^\\/[a-zA-Z]+,.*$/.test(arg)) {\r\n            // Don't wrap /root,C:\\folder style arguments to explorer calls in\r\n            // quotes since they will not be interpreted correctly if they are\r\n            return arg\r\n          } else {\r\n            // Escape double quotes by putting a backslash in front of them\r\n            return `\\\"${arg.toString().replace(/\"/g, '\\\\\"')}\\\"`\r\n          }\r\n        })\r\n    }\r\n\r\n    // The command itself is quoted if it contains spaces, &, ^, | or # chars\r\n    cmdArgs.unshift(/\\s|&|\\^|\\(|\\)|\\||#/.test(command) ? `\\\"${command}\\\"` : command)\r\n\r\n    const cmdOptions = _.clone(options)\r\n    cmdOptions.windowsVerbatimArguments = true\r\n\r\n    this.spawn(this.getCmdPath(), ['/s', '/d', '/c', `\\\"${cmdArgs.join(' ')}\\\"`], cmdOptions)\r\n  }\r", "name": "getCmdPath", "func_location": "BufferedProcess.spawnWithEscapedWindowsArgs", "args": [null, null, "cmdOptions"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "line": 102, "func_start_line": 79}}, {"func_info": {"comment": [], "name": "Pane.copyActiveItem", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 998, "start_line": 994}, "call_info": {"func_end_line": 1130, "code": "  split (orientation, side, params) {\r\n    if (params && params.copyActiveItem) {\r\n      if (!params.items) params.items = []\r\n      params.items.push(this.copyActiveItem())\r\n    }\r\n\r\n    if (this.parent.orientation !== orientation) {\r\n      this.parent.replaceChild(this, new PaneAxis({\r\n        container: this.container,\r\n        orientation,\r\n        children: [this],\r\n        flexScale: this.flexScale},\r\n        this.viewRegistry\r\n      ))\r\n      this.setFlexScale(1)\r\n    }\r\n\r\n    const newPane = new Pane(Object.assign({\r\n      applicationDelegate: this.applicationDelegate,\r\n      notificationManager: this.notificationManager,\r\n      deserializerManager: this.deserializerManager,\r\n      config: this.config,\r\n      viewRegistry: this.viewRegistry\r\n    }, params))\r\n\r\n    switch (side) {\r\n      case 'before': this.parent.insertChildBefore(this, newPane); break\r\n      case 'after': this.parent.insertChildAfter(this, newPane); break\r\n    }\r\n\r\n    if (params && params.moveActiveItem && this.activeItem) this.moveItemToPane(this.activeItem, newPane)\r\n\r\n    newPane.activate()\r\n    return newPane\r\n  }\r", "name": "copyActiveItem", "func_location": "Pane.split", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 1099, "func_start_line": 1096}}, {"func_info": {"comment": [], "name": "Pane.setFlexScale", "params": ["flexScale"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 154, "start_line": 150}, "call_info": {"func_end_line": 1130, "code": "  split (orientation, side, params) {\r\n    if (params && params.copyActiveItem) {\r\n      if (!params.items) params.items = []\r\n      params.items.push(this.copyActiveItem())\r\n    }\r\n\r\n    if (this.parent.orientation !== orientation) {\r\n      this.parent.replaceChild(this, new PaneAxis({\r\n        container: this.container,\r\n        orientation,\r\n        children: [this],\r\n        flexScale: this.flexScale},\r\n        this.viewRegistry\r\n      ))\r\n      this.setFlexScale(1)\r\n    }\r\n\r\n    const newPane = new Pane(Object.assign({\r\n      applicationDelegate: this.applicationDelegate,\r\n      notificationManager: this.notificationManager,\r\n      deserializerManager: this.deserializerManager,\r\n      config: this.config,\r\n      viewRegistry: this.viewRegistry\r\n    }, params))\r\n\r\n    switch (side) {\r\n      case 'before': this.parent.insertChildBefore(this, newPane); break\r\n      case 'after': this.parent.insertChildAfter(this, newPane); break\r\n    }\r\n\r\n    if (params && params.moveActiveItem && this.activeItem) this.moveItemToPane(this.activeItem, newPane)\r\n\r\n    newPane.activate()\r\n    return newPane\r\n  }\r", "name": "setFlexScale", "func_location": "Pane.split", "args": [{"type": "number"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 1110, "func_start_line": 1096}}, {"func_info": {"comment": [" Public: Move the given item to the given index on another pane.", "", " * `item` The item to move.", " * `pane` {Pane} to which to move the item.", " * `index` {Number} indicating the index to which to move the item in the", "   given pane."], "name": "Pane.moveItemToPane", "params": ["item", "pane", "index"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 736, "start_line": 733}, "call_info": {"func_end_line": 1130, "code": "  split (orientation, side, params) {\r\n    if (params && params.copyActiveItem) {\r\n      if (!params.items) params.items = []\r\n      params.items.push(this.copyActiveItem())\r\n    }\r\n\r\n    if (this.parent.orientation !== orientation) {\r\n      this.parent.replaceChild(this, new PaneAxis({\r\n        container: this.container,\r\n        orientation,\r\n        children: [this],\r\n        flexScale: this.flexScale},\r\n        this.viewRegistry\r\n      ))\r\n      this.setFlexScale(1)\r\n    }\r\n\r\n    const newPane = new Pane(Object.assign({\r\n      applicationDelegate: this.applicationDelegate,\r\n      notificationManager: this.notificationManager,\r\n      deserializerManager: this.deserializerManager,\r\n      config: this.config,\r\n      viewRegistry: this.viewRegistry\r\n    }, params))\r\n\r\n    switch (side) {\r\n      case 'before': this.parent.insertChildBefore(this, newPane); break\r\n      case 'after': this.parent.insertChildAfter(this, newPane); break\r\n    }\r\n\r\n    if (params && params.moveActiveItem && this.activeItem) this.moveItemToPane(this.activeItem, newPane)\r\n\r\n    newPane.activate()\r\n    return newPane\r\n  }\r", "name": "moveItemToPane", "func_location": "Pane.split", "args": [".activeItem", "newPane"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 1126, "func_start_line": 1096}}, {"func_info": {"comment": [], "name": "Pane.split", "params": ["orientation", "side", "params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 1130, "start_line": 1096}, "call_info": {"func_end_line": 1094, "comment": [" Public: Creates a new pane below the receiver.", "", " * `params` (optional) {Object} with the following keys:", "   * `items` (optional) {Array} of items to add to the new pane.", "   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane", "", " Returns the new {Pane}."], "code": "  splitDown (params) {\r\n    return this.split('vertical', 'after', params)\r\n  }\r", "name": "split", "func_location": "Pane.splitDown", "args": [{"type": "string"}, {"type": "string"}, "params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 1093, "func_start_line": 1092}}, {"func_info": {"comment": [], "name": "Pane.split", "params": ["orientation", "side", "params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 1130, "start_line": 1096}, "call_info": {"func_end_line": 1061, "comment": ["\r\n  Section: Splitting\r\n  ", " Public: Create a new pane to the left of this pane.", "", " * `params` (optional) {Object} with the following keys:", "   * `items` (optional) {Array} of items to add to the new pane.", "   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane", "", " Returns the new {Pane}."], "code": "  splitLeft (params) {\r\n    return this.split('horizontal', 'before', params)\r\n  }\r", "name": "split", "func_location": "Pane.splitLeft", "args": [{"type": "string"}, {"type": "string"}, "params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 1060, "func_start_line": 1059}}, {"func_info": {"comment": [], "name": "Pane.split", "params": ["orientation", "side", "params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 1130, "start_line": 1096}, "call_info": {"func_end_line": 1072, "comment": [" Public: Create a new pane to the right of this pane.", "", " * `params` (optional) {Object} with the following keys:", "   * `items` (optional) {Array} of items to add to the new pane.", "   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane", "", " Returns the new {Pane}."], "code": "  splitRight (params) {\r\n    return this.split('horizontal', 'after', params)\r\n  }\r", "name": "split", "func_location": "Pane.splitRight", "args": [{"type": "string"}, {"type": "string"}, "params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 1071, "func_start_line": 1070}}, {"func_info": {"comment": [], "name": "Pane.split", "params": ["orientation", "side", "params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "end_line": 1130, "start_line": 1096}, "call_info": {"func_end_line": 1083, "comment": [" Public: Creates a new pane above the receiver.", "", " * `params` (optional) {Object} with the following keys:", "   * `items` (optional) {Array} of items to add to the new pane.", "   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane", "", " Returns the new {Pane}."], "code": "  splitUp (params) {\r\n    return this.split('vertical', 'before', params)\r\n  }\r", "name": "split", "func_location": "Pane.splitUp", "args": [{"type": "string"}, {"type": "string"}, "params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/pane.js", "line": 1082, "func_start_line": 1081}}, {"func_info": {"comment": [], "name": "NativeWatcher.doStart", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js", "end_line": 59, "start_line": 57}, "call_info": {"func_end_line": 55, "comment": [" Private: Begin watching for filesystem events.", "", " Has no effect if the watcher has already been started."], "code": "  async start () {\r\n    if (this.state !== WATCHER_STATE.STOPPED) {\r\n      return\r\n    }\r\n    this.state = WATCHER_STATE.STARTING\r\n\r\n    await this.doStart()\r\n\r\n    this.state = WATCHER_STATE.RUNNING\r\n    this.emitter.emit('did-start')\r\n  }\r", "name": "doStart", "func_location": "NativeWatcher.start", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js", "line": 51, "func_start_line": 45}}, {"func_info": {"comment": [" Windows has a bunch of special rules that node still doesn't take care of for you"], "name": "BufferedProcess.spawnWithEscapedWindowsArgs", "params": ["command", "args", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "end_line": 103, "start_line": 79}, "call_info": {"func_end_line": 76, "code": "  start () {\r\n    if (this.started === true) return\r\n\r\n    this.started = true\r\n    // Related to joyent/node#2318\r\n    if (process.platform === 'win32' && this.options.shell === undefined) {\r\n      this.spawnWithEscapedWindowsArgs(this.command, this.args, this.options)\r\n    } else {\r\n      this.spawn(this.command, this.args, this.options)\r\n    }\r\n    this.handleEvents(this.stdout, this.stderr, this.exit)\r\n  }\r", "name": "spawnWithEscapedWindowsArgs", "func_location": "BufferedProcess.start", "args": [".command", ".args", ".options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "line": 71, "func_start_line": 65}}, {"func_info": {"comment": [], "name": "BufferedProcess.spawn", "params": ["command", "args", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "end_line": 250, "start_line": 244}, "call_info": {"func_end_line": 76, "code": "  start () {\r\n    if (this.started === true) return\r\n\r\n    this.started = true\r\n    // Related to joyent/node#2318\r\n    if (process.platform === 'win32' && this.options.shell === undefined) {\r\n      this.spawnWithEscapedWindowsArgs(this.command, this.args, this.options)\r\n    } else {\r\n      this.spawn(this.command, this.args, this.options)\r\n    }\r\n    this.handleEvents(this.stdout, this.stderr, this.exit)\r\n  }\r", "name": "spawn", "func_location": "BufferedProcess.start", "args": [".command", ".args", ".options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "line": 73, "func_start_line": 65}}, {"func_info": {"comment": [], "name": "BufferedProcess.handleEvents", "params": ["stdout", "stderr", "exit"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "end_line": 295, "start_line": 252}, "call_info": {"func_end_line": 76, "code": "  start () {\r\n    if (this.started === true) return\r\n\r\n    this.started = true\r\n    // Related to joyent/node#2318\r\n    if (process.platform === 'win32' && this.options.shell === undefined) {\r\n      this.spawnWithEscapedWindowsArgs(this.command, this.args, this.options)\r\n    } else {\r\n      this.spawn(this.command, this.args, this.options)\r\n    }\r\n    this.handleEvents(this.stdout, this.stderr, this.exit)\r\n  }\r", "name": "handleEvents", "func_location": "BufferedProcess.start", "args": [".stdout", ".stderr", ".exit"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/buffered-process.js", "line": 75, "func_start_line": 65}}, {"func_info": {"comment": [], "name": "normalizeDriveLetterName", "params": ["filePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/start.js", "end_line": 130, "start_line": 124}, "call_info": {"func_end_line": 94, "code": "module.exports = function start (resourcePath, devResourcePath, startTime) {\r\n  global.shellStartTime = startTime\r\n\r\n  process.on('uncaughtException', function (error = {}) {\r\n    if (error.message != null) {\r\n      console.log(error.message)\r\n    }\r\n\r\n    if (error.stack != null) {\r\n      console.log(error.stack)\r\n    }\r\n  })\r\n\r\n  process.on('unhandledRejection', function (error = {}) {\r\n    if (error.message != null) {\r\n      console.log(error.message)\r\n    }\r\n\r\n    if (error.stack != null) {\r\n      console.log(error.stack)\r\n    }\r\n  })\r\n\r\n  const previousConsoleLog = console.log\r\n  console.log = nslog\r\n\r\n  app.commandLine.appendSwitch('enable-experimental-web-platform-features')\r\n\r\n  const args = parseCommandLine(process.argv.slice(1))\r\n  args.resourcePath = normalizeDriveLetterName(resourcePath)\r\n  args.devResourcePath = normalizeDriveLetterName(devResourcePath)\r\n\r\n  atomPaths.setAtomHome(app.getPath('home'))\r\n  atomPaths.setUserData(app)\r\n\r\n  const config = getConfig()\r\n  const colorProfile = config.get('core.colorProfile')\r\n  if (colorProfile && colorProfile !== 'default') {\r\n    app.commandLine.appendSwitch('force-color-profile', colorProfile)\r\n  }\r\n\r\n  if (handleStartupEventWithSquirrel()) {\r\n    return\r\n  } else if (args.test && args.mainProcess) {\r\n    app.setPath('userData', temp.mkdirSync('atom-user-data-dir-for-main-process-tests'))\r\n    console.log = previousConsoleLog\r\n    app.on('ready', function () {\r\n      const testRunner = require(path.join(args.resourcePath, 'spec/main-process/mocha-test-runner'))\r\n      testRunner(args.pathsToOpen)\r\n    })\r\n    return\r\n  }\r\n\r\n  // NB: This prevents Win10 from showing dupe items in the taskbar\r\n  app.setAppUserModelId('com.squirrel.atom.' + process.arch)\r\n\r\n  function addPathToOpen (event, pathToOpen) {\r\n    event.preventDefault()\r\n    args.pathsToOpen.push(pathToOpen)\r\n  }\r\n\r\n  function addUrlToOpen (event, urlToOpen) {\r\n    event.preventDefault()\r\n    args.urlsToOpen.push(urlToOpen)\r\n  }\r\n\r\n  app.on('open-file', addPathToOpen)\r\n  app.on('open-url', addUrlToOpen)\r\n  app.on('will-finish-launching', startCrashReporter)\r\n\r\n  if (args.userDataDir != null) {\r\n    app.setPath('userData', args.userDataDir)\r\n  } else if (args.test || args.benchmark || args.benchmarkTest) {\r\n    app.setPath('userData', temp.mkdirSync('atom-test-data'))\r\n  }\r\n\r\n  app.on('ready', function () {\r\n    app.removeListener('open-file', addPathToOpen)\r\n    app.removeListener('open-url', addUrlToOpen)\r\n    const AtomApplication = require(path.join(args.resourcePath, 'src', 'main-process', 'atom-application'))\r\n    AtomApplication.open(args)\r\n  })\r\n}\r", "name": "normalizeDriveLetterName", "func_location": "start", "args": ["resourcePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/start.js", "line": 41, "func_start_line": 12}}, {"func_info": {"comment": [], "name": "normalizeDriveLetterName", "params": ["filePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/start.js", "end_line": 130, "start_line": 124}, "call_info": {"func_end_line": 94, "code": "module.exports = function start (resourcePath, devResourcePath, startTime) {\r\n  global.shellStartTime = startTime\r\n\r\n  process.on('uncaughtException', function (error = {}) {\r\n    if (error.message != null) {\r\n      console.log(error.message)\r\n    }\r\n\r\n    if (error.stack != null) {\r\n      console.log(error.stack)\r\n    }\r\n  })\r\n\r\n  process.on('unhandledRejection', function (error = {}) {\r\n    if (error.message != null) {\r\n      console.log(error.message)\r\n    }\r\n\r\n    if (error.stack != null) {\r\n      console.log(error.stack)\r\n    }\r\n  })\r\n\r\n  const previousConsoleLog = console.log\r\n  console.log = nslog\r\n\r\n  app.commandLine.appendSwitch('enable-experimental-web-platform-features')\r\n\r\n  const args = parseCommandLine(process.argv.slice(1))\r\n  args.resourcePath = normalizeDriveLetterName(resourcePath)\r\n  args.devResourcePath = normalizeDriveLetterName(devResourcePath)\r\n\r\n  atomPaths.setAtomHome(app.getPath('home'))\r\n  atomPaths.setUserData(app)\r\n\r\n  const config = getConfig()\r\n  const colorProfile = config.get('core.colorProfile')\r\n  if (colorProfile && colorProfile !== 'default') {\r\n    app.commandLine.appendSwitch('force-color-profile', colorProfile)\r\n  }\r\n\r\n  if (handleStartupEventWithSquirrel()) {\r\n    return\r\n  } else if (args.test && args.mainProcess) {\r\n    app.setPath('userData', temp.mkdirSync('atom-user-data-dir-for-main-process-tests'))\r\n    console.log = previousConsoleLog\r\n    app.on('ready', function () {\r\n      const testRunner = require(path.join(args.resourcePath, 'spec/main-process/mocha-test-runner'))\r\n      testRunner(args.pathsToOpen)\r\n    })\r\n    return\r\n  }\r\n\r\n  // NB: This prevents Win10 from showing dupe items in the taskbar\r\n  app.setAppUserModelId('com.squirrel.atom.' + process.arch)\r\n\r\n  function addPathToOpen (event, pathToOpen) {\r\n    event.preventDefault()\r\n    args.pathsToOpen.push(pathToOpen)\r\n  }\r\n\r\n  function addUrlToOpen (event, urlToOpen) {\r\n    event.preventDefault()\r\n    args.urlsToOpen.push(urlToOpen)\r\n  }\r\n\r\n  app.on('open-file', addPathToOpen)\r\n  app.on('open-url', addUrlToOpen)\r\n  app.on('will-finish-launching', startCrashReporter)\r\n\r\n  if (args.userDataDir != null) {\r\n    app.setPath('userData', args.userDataDir)\r\n  } else if (args.test || args.benchmark || args.benchmarkTest) {\r\n    app.setPath('userData', temp.mkdirSync('atom-test-data'))\r\n  }\r\n\r\n  app.on('ready', function () {\r\n    app.removeListener('open-file', addPathToOpen)\r\n    app.removeListener('open-url', addUrlToOpen)\r\n    const AtomApplication = require(path.join(args.resourcePath, 'src', 'main-process', 'atom-application'))\r\n    AtomApplication.open(args)\r\n  })\r\n}\r", "name": "normalizeDriveLetterName", "func_location": "start", "args": ["devResourcePath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/start.js", "line": 42, "func_start_line": 12}}, {"func_info": {"comment": [], "name": "getConfig", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/start.js", "end_line": 122, "start_line": 106}, "call_info": {"func_end_line": 94, "code": "module.exports = function start (resourcePath, devResourcePath, startTime) {\r\n  global.shellStartTime = startTime\r\n\r\n  process.on('uncaughtException', function (error = {}) {\r\n    if (error.message != null) {\r\n      console.log(error.message)\r\n    }\r\n\r\n    if (error.stack != null) {\r\n      console.log(error.stack)\r\n    }\r\n  })\r\n\r\n  process.on('unhandledRejection', function (error = {}) {\r\n    if (error.message != null) {\r\n      console.log(error.message)\r\n    }\r\n\r\n    if (error.stack != null) {\r\n      console.log(error.stack)\r\n    }\r\n  })\r\n\r\n  const previousConsoleLog = console.log\r\n  console.log = nslog\r\n\r\n  app.commandLine.appendSwitch('enable-experimental-web-platform-features')\r\n\r\n  const args = parseCommandLine(process.argv.slice(1))\r\n  args.resourcePath = normalizeDriveLetterName(resourcePath)\r\n  args.devResourcePath = normalizeDriveLetterName(devResourcePath)\r\n\r\n  atomPaths.setAtomHome(app.getPath('home'))\r\n  atomPaths.setUserData(app)\r\n\r\n  const config = getConfig()\r\n  const colorProfile = config.get('core.colorProfile')\r\n  if (colorProfile && colorProfile !== 'default') {\r\n    app.commandLine.appendSwitch('force-color-profile', colorProfile)\r\n  }\r\n\r\n  if (handleStartupEventWithSquirrel()) {\r\n    return\r\n  } else if (args.test && args.mainProcess) {\r\n    app.setPath('userData', temp.mkdirSync('atom-user-data-dir-for-main-process-tests'))\r\n    console.log = previousConsoleLog\r\n    app.on('ready', function () {\r\n      const testRunner = require(path.join(args.resourcePath, 'spec/main-process/mocha-test-runner'))\r\n      testRunner(args.pathsToOpen)\r\n    })\r\n    return\r\n  }\r\n\r\n  // NB: This prevents Win10 from showing dupe items in the taskbar\r\n  app.setAppUserModelId('com.squirrel.atom.' + process.arch)\r\n\r\n  function addPathToOpen (event, pathToOpen) {\r\n    event.preventDefault()\r\n    args.pathsToOpen.push(pathToOpen)\r\n  }\r\n\r\n  function addUrlToOpen (event, urlToOpen) {\r\n    event.preventDefault()\r\n    args.urlsToOpen.push(urlToOpen)\r\n  }\r\n\r\n  app.on('open-file', addPathToOpen)\r\n  app.on('open-url', addUrlToOpen)\r\n  app.on('will-finish-launching', startCrashReporter)\r\n\r\n  if (args.userDataDir != null) {\r\n    app.setPath('userData', args.userDataDir)\r\n  } else if (args.test || args.benchmark || args.benchmarkTest) {\r\n    app.setPath('userData', temp.mkdirSync('atom-test-data'))\r\n  }\r\n\r\n  app.on('ready', function () {\r\n    app.removeListener('open-file', addPathToOpen)\r\n    app.removeListener('open-url', addUrlToOpen)\r\n    const AtomApplication = require(path.join(args.resourcePath, 'src', 'main-process', 'atom-application'))\r\n    AtomApplication.open(args)\r\n  })\r\n}\r", "name": "getConfig", "func_location": "start", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/start.js", "line": 47, "func_start_line": 12}}, {"func_info": {"comment": [], "name": "handleStartupEventWithSquirrel", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/start.js", "end_line": 104, "start_line": 96}, "call_info": {"func_end_line": 94, "code": "module.exports = function start (resourcePath, devResourcePath, startTime) {\r\n  global.shellStartTime = startTime\r\n\r\n  process.on('uncaughtException', function (error = {}) {\r\n    if (error.message != null) {\r\n      console.log(error.message)\r\n    }\r\n\r\n    if (error.stack != null) {\r\n      console.log(error.stack)\r\n    }\r\n  })\r\n\r\n  process.on('unhandledRejection', function (error = {}) {\r\n    if (error.message != null) {\r\n      console.log(error.message)\r\n    }\r\n\r\n    if (error.stack != null) {\r\n      console.log(error.stack)\r\n    }\r\n  })\r\n\r\n  const previousConsoleLog = console.log\r\n  console.log = nslog\r\n\r\n  app.commandLine.appendSwitch('enable-experimental-web-platform-features')\r\n\r\n  const args = parseCommandLine(process.argv.slice(1))\r\n  args.resourcePath = normalizeDriveLetterName(resourcePath)\r\n  args.devResourcePath = normalizeDriveLetterName(devResourcePath)\r\n\r\n  atomPaths.setAtomHome(app.getPath('home'))\r\n  atomPaths.setUserData(app)\r\n\r\n  const config = getConfig()\r\n  const colorProfile = config.get('core.colorProfile')\r\n  if (colorProfile && colorProfile !== 'default') {\r\n    app.commandLine.appendSwitch('force-color-profile', colorProfile)\r\n  }\r\n\r\n  if (handleStartupEventWithSquirrel()) {\r\n    return\r\n  } else if (args.test && args.mainProcess) {\r\n    app.setPath('userData', temp.mkdirSync('atom-user-data-dir-for-main-process-tests'))\r\n    console.log = previousConsoleLog\r\n    app.on('ready', function () {\r\n      const testRunner = require(path.join(args.resourcePath, 'spec/main-process/mocha-test-runner'))\r\n      testRunner(args.pathsToOpen)\r\n    })\r\n    return\r\n  }\r\n\r\n  // NB: This prevents Win10 from showing dupe items in the taskbar\r\n  app.setAppUserModelId('com.squirrel.atom.' + process.arch)\r\n\r\n  function addPathToOpen (event, pathToOpen) {\r\n    event.preventDefault()\r\n    args.pathsToOpen.push(pathToOpen)\r\n  }\r\n\r\n  function addUrlToOpen (event, urlToOpen) {\r\n    event.preventDefault()\r\n    args.urlsToOpen.push(urlToOpen)\r\n  }\r\n\r\n  app.on('open-file', addPathToOpen)\r\n  app.on('open-url', addUrlToOpen)\r\n  app.on('will-finish-launching', startCrashReporter)\r\n\r\n  if (args.userDataDir != null) {\r\n    app.setPath('userData', args.userDataDir)\r\n  } else if (args.test || args.benchmark || args.benchmarkTest) {\r\n    app.setPath('userData', temp.mkdirSync('atom-test-data'))\r\n  }\r\n\r\n  app.on('ready', function () {\r\n    app.removeListener('open-file', addPathToOpen)\r\n    app.removeListener('open-url', addUrlToOpen)\r\n    const AtomApplication = require(path.join(args.resourcePath, 'src', 'main-process', 'atom-application'))\r\n    AtomApplication.open(args)\r\n  })\r\n}\r", "name": "handleStartupEventWithSquirrel", "func_location": "start", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/start.js", "line": 53, "func_start_line": 12}}, {"func_info": {"comment": [], "name": "TextEditorComponent.scheduleUpdate", "params": ["nextUpdateOnlyBlinksCursors"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 219, "start_line": 204}, "call_info": {"func_end_line": 2010, "code": "  startCursorBlinking () {\r\n    if (!this.cursorsBlinking) {\r\n      this.cursorBlinkIntervalHandle = window.setInterval(() => {\r\n        this.cursorsBlinkedOff = !this.cursorsBlinkedOff\r\n        this.scheduleUpdate(true)\r\n      }, (this.props.cursorBlinkPeriod || CURSOR_BLINK_PERIOD) / 2)\r\n      this.cursorsBlinking = true\r\n      this.scheduleUpdate(true)\r\n    }\r\n  }\r", "name": "scheduleUpdate", "func_location": "TextEditorComponent.startCursorBlinking", "args": [{"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2008, "func_start_line": 2001}}, {"func_info": {"comment": [" Public: Get the load settings for the current window.", "", " Returns an {Object} containing all the load setting key/value pairs."], "name": "AtomEnvironment.getLoadSettings", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 527, "start_line": 525}, "call_info": {"func_end_line": 868, "comment": [" Call this method when establishing a real application window."], "code": "  async startEditorWindow () {\r\n    if (this.getLoadSettings().clearWindowState) {\r\n      await this.stateStore.clear()\r\n    }\r\n\r\n    this.unloading = false\r\n\r\n    const updateProcessEnvPromise = this.updateProcessEnvAndTriggerHooks()\r\n\r\n    const loadStatePromise = this.loadState().then(async state => {\r\n      this.windowDimensions = state && state.windowDimensions\r\n      await this.displayWindow()\r\n      this.commandInstaller.installAtomCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n      this.commandInstaller.installApmCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidChangeUserSettings(settings =>\r\n        this.config.resetUserSettings(settings)\r\n      ))\r\n      this.disposables.add(this.applicationDelegate.onDidFailToReadUserSettings(message =>\r\n        this.notifications.addError(message)\r\n      ))\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidOpenLocations(this.openLocations.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onApplicationMenuCommand(this.dispatchApplicationMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onContextMenuCommand(this.dispatchContextMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onURIMessage(this.dispatchURIMessage.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onDidRequestUnload(this.prepareToUnloadEditorWindow.bind(this)))\r\n\r\n      this.listenForUpdates()\r\n\r\n      this.registerDefaultTargetForKeymaps()\r\n\r\n      this.packages.loadPackages()\r\n\r\n      const startTime = Date.now()\r\n      await this.deserialize(state)\r\n      this.deserializeTimings.atom = Date.now() - startTime\r\n\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom-inset') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-inset-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'hidden') {\r\n        this.document.body.classList.add('hidden-title-bar')\r\n      }\r\n\r\n      this.document.body.appendChild(this.workspace.getElement())\r\n      if (this.backgroundStylesheet) this.backgroundStylesheet.remove()\r\n\r\n      let previousProjectPaths = this.project.getPaths()\r\n      this.disposables.add(this.project.onDidChangePaths(newPaths => {\r\n        for (let path of previousProjectPaths) {\r\n          if (this.pathsWithWaitSessions.has(path) && !newPaths.includes(path)) {\r\n            this.applicationDelegate.didClosePathWithWaitSession(path)\r\n          }\r\n        }\r\n        previousProjectPaths = newPaths\r\n        this.applicationDelegate.setRepresentedDirectoryPaths(newPaths)\r\n      }))\r\n      this.disposables.add(this.workspace.onDidDestroyPaneItem(({item}) => {\r\n        const path = item.getPath && item.getPath()\r\n        if (this.pathsWithWaitSessions.has(path)) {\r\n          this.applicationDelegate.didClosePathWithWaitSession(path)\r\n        }\r\n      }))\r\n\r\n      this.packages.activate()\r\n      this.keymaps.loadUserKeymap()\r\n      if (!this.getLoadSettings().safeMode) this.requireUserInitScript()\r\n\r\n      this.menu.update()\r\n\r\n      await this.openInitialEmptyEditorIfNecessary()\r\n    })\r\n\r\n    const loadHistoryPromise = this.history.loadState().then(() => {\r\n      this.reopenProjectMenuManager = new ReopenProjectMenuManager({\r\n        menu: this.menu,\r\n        commands: this.commands,\r\n        history: this.history,\r\n        config: this.config,\r\n        open: paths => this.open({pathsToOpen: paths})\r\n      })\r\n      this.reopenProjectMenuManager.update()\r\n    })\r\n\r\n    return Promise.all([loadStatePromise, loadHistoryPromise, updateProcessEnvPromise])\r\n  }\r", "name": "getLoadSettings", "func_location": "AtomEnvironment.startEditorWindow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 774, "func_start_line": 773}}, {"func_info": {"comment": [], "name": "AtomEnvironment.updateProcessEnvAndTriggerHooks", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 975, "start_line": 970}, "call_info": {"func_end_line": 868, "comment": [" Call this method when establishing a real application window."], "code": "  async startEditorWindow () {\r\n    if (this.getLoadSettings().clearWindowState) {\r\n      await this.stateStore.clear()\r\n    }\r\n\r\n    this.unloading = false\r\n\r\n    const updateProcessEnvPromise = this.updateProcessEnvAndTriggerHooks()\r\n\r\n    const loadStatePromise = this.loadState().then(async state => {\r\n      this.windowDimensions = state && state.windowDimensions\r\n      await this.displayWindow()\r\n      this.commandInstaller.installAtomCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n      this.commandInstaller.installApmCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidChangeUserSettings(settings =>\r\n        this.config.resetUserSettings(settings)\r\n      ))\r\n      this.disposables.add(this.applicationDelegate.onDidFailToReadUserSettings(message =>\r\n        this.notifications.addError(message)\r\n      ))\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidOpenLocations(this.openLocations.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onApplicationMenuCommand(this.dispatchApplicationMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onContextMenuCommand(this.dispatchContextMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onURIMessage(this.dispatchURIMessage.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onDidRequestUnload(this.prepareToUnloadEditorWindow.bind(this)))\r\n\r\n      this.listenForUpdates()\r\n\r\n      this.registerDefaultTargetForKeymaps()\r\n\r\n      this.packages.loadPackages()\r\n\r\n      const startTime = Date.now()\r\n      await this.deserialize(state)\r\n      this.deserializeTimings.atom = Date.now() - startTime\r\n\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom-inset') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-inset-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'hidden') {\r\n        this.document.body.classList.add('hidden-title-bar')\r\n      }\r\n\r\n      this.document.body.appendChild(this.workspace.getElement())\r\n      if (this.backgroundStylesheet) this.backgroundStylesheet.remove()\r\n\r\n      let previousProjectPaths = this.project.getPaths()\r\n      this.disposables.add(this.project.onDidChangePaths(newPaths => {\r\n        for (let path of previousProjectPaths) {\r\n          if (this.pathsWithWaitSessions.has(path) && !newPaths.includes(path)) {\r\n            this.applicationDelegate.didClosePathWithWaitSession(path)\r\n          }\r\n        }\r\n        previousProjectPaths = newPaths\r\n        this.applicationDelegate.setRepresentedDirectoryPaths(newPaths)\r\n      }))\r\n      this.disposables.add(this.workspace.onDidDestroyPaneItem(({item}) => {\r\n        const path = item.getPath && item.getPath()\r\n        if (this.pathsWithWaitSessions.has(path)) {\r\n          this.applicationDelegate.didClosePathWithWaitSession(path)\r\n        }\r\n      }))\r\n\r\n      this.packages.activate()\r\n      this.keymaps.loadUserKeymap()\r\n      if (!this.getLoadSettings().safeMode) this.requireUserInitScript()\r\n\r\n      this.menu.update()\r\n\r\n      await this.openInitialEmptyEditorIfNecessary()\r\n    })\r\n\r\n    const loadHistoryPromise = this.history.loadState().then(() => {\r\n      this.reopenProjectMenuManager = new ReopenProjectMenuManager({\r\n        menu: this.menu,\r\n        commands: this.commands,\r\n        history: this.history,\r\n        config: this.config,\r\n        open: paths => this.open({pathsToOpen: paths})\r\n      })\r\n      this.reopenProjectMenuManager.update()\r\n    })\r\n\r\n    return Promise.all([loadStatePromise, loadHistoryPromise, updateProcessEnvPromise])\r\n  }\r", "name": "updateProcessEnvAndTriggerHooks", "func_location": "AtomEnvironment.startEditorWindow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 780, "func_start_line": 773}}, {"func_info": {"comment": [], "name": "AtomEnvironment.loadState", "params": ["stateKey"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 1221, "start_line": 1210}, "call_info": {"func_end_line": 868, "comment": [" Call this method when establishing a real application window."], "code": "  async startEditorWindow () {\r\n    if (this.getLoadSettings().clearWindowState) {\r\n      await this.stateStore.clear()\r\n    }\r\n\r\n    this.unloading = false\r\n\r\n    const updateProcessEnvPromise = this.updateProcessEnvAndTriggerHooks()\r\n\r\n    const loadStatePromise = this.loadState().then(async state => {\r\n      this.windowDimensions = state && state.windowDimensions\r\n      await this.displayWindow()\r\n      this.commandInstaller.installAtomCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n      this.commandInstaller.installApmCommand(false, (error) => {\r\n        if (error) console.warn(error.message)\r\n      })\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidChangeUserSettings(settings =>\r\n        this.config.resetUserSettings(settings)\r\n      ))\r\n      this.disposables.add(this.applicationDelegate.onDidFailToReadUserSettings(message =>\r\n        this.notifications.addError(message)\r\n      ))\r\n\r\n      this.disposables.add(this.applicationDelegate.onDidOpenLocations(this.openLocations.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onApplicationMenuCommand(this.dispatchApplicationMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onContextMenuCommand(this.dispatchContextMenuCommand.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onURIMessage(this.dispatchURIMessage.bind(this)))\r\n      this.disposables.add(this.applicationDelegate.onDidRequestUnload(this.prepareToUnloadEditorWindow.bind(this)))\r\n\r\n      this.listenForUpdates()\r\n\r\n      this.registerDefaultTargetForKeymaps()\r\n\r\n      this.packages.loadPackages()\r\n\r\n      const startTime = Date.now()\r\n      await this.deserialize(state)\r\n      this.deserializeTimings.atom = Date.now() - startTime\r\n\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'custom-inset') {\r\n        this.workspace.addHeaderPanel({item: new TitleBar({workspace: this.workspace, themes: this.themes, applicationDelegate: this.applicationDelegate})})\r\n        this.document.body.classList.add('custom-inset-title-bar')\r\n      }\r\n      if (process.platform === 'darwin' && this.config.get('core.titleBar') === 'hidden') {\r\n        this.document.body.classList.add('hidden-title-bar')\r\n      }\r\n\r\n      this.document.body.appendChild(this.workspace.getElement())\r\n      if (this.backgroundStylesheet) this.backgroundStylesheet.remove()\r\n\r\n      let previousProjectPaths = this.project.getPaths()\r\n      this.disposables.add(this.project.onDidChangePaths(newPaths => {\r\n        for (let path of previousProjectPaths) {\r\n          if (this.pathsWithWaitSessions.has(path) && !newPaths.includes(path)) {\r\n            this.applicationDelegate.didClosePathWithWaitSession(path)\r\n          }\r\n        }\r\n        previousProjectPaths = newPaths\r\n        this.applicationDelegate.setRepresentedDirectoryPaths(newPaths)\r\n      }))\r\n      this.disposables.add(this.workspace.onDidDestroyPaneItem(({item}) => {\r\n        const path = item.getPath && item.getPath()\r\n        if (this.pathsWithWaitSessions.has(path)) {\r\n          this.applicationDelegate.didClosePathWithWaitSession(path)\r\n        }\r\n      }))\r\n\r\n      this.packages.activate()\r\n      this.keymaps.loadUserKeymap()\r\n      if (!this.getLoadSettings().safeMode) this.requireUserInitScript()\r\n\r\n      this.menu.update()\r\n\r\n      await this.openInitialEmptyEditorIfNecessary()\r\n    })\r\n\r\n    const loadHistoryPromise = this.history.loadState().then(() => {\r\n      this.reopenProjectMenuManager = new ReopenProjectMenuManager({\r\n        menu: this.menu,\r\n        commands: this.commands,\r\n        history: this.history,\r\n        config: this.config,\r\n        open: paths => this.open({pathsToOpen: paths})\r\n      })\r\n      this.reopenProjectMenuManager.update()\r\n    })\r\n\r\n    return Promise.all([loadStatePromise, loadHistoryPromise, updateProcessEnvPromise])\r\n  }\r", "name": "loadState", "func_location": "AtomEnvironment.startEditorWindow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 782, "func_start_line": 773}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.tokenizeInBackground", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 280, "start_line": 272}, "call_info": {"func_end_line": 270, "code": "  startTokenizing () {\r\n    this.tokenizationStarted = true\r\n    if (this.grammar.name !== 'Null Grammar' && !this.largeFileMode) {\r\n      this.tokenizeInBackground()\r\n    }\r\n  }\r", "name": "tokenizeInBackground", "func_location": "TextMateLanguageMode.startTokenizing", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 268, "func_start_line": 265}}, {"func_info": {"comment": [], "name": "NativeWatcher.doStop", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js", "end_line": 146, "start_line": 144}, "call_info": {"func_end_line": 142, "comment": [" Private: Stop the native watcher and release any operating system resources associated with it.", "", " Has no effect if the watcher is not running."], "code": "  async stop () {\r\n    if (this.state !== WATCHER_STATE.RUNNING) {\r\n      return\r\n    }\r\n    this.state = WATCHER_STATE.STOPPING\r\n    this.emitter.emit('will-stop')\r\n\r\n    await this.doStop()\r\n\r\n    this.state = WATCHER_STATE.STOPPED\r\n\r\n    this.emitter.emit('did-stop')\r\n  }\r", "name": "doStop", "func_location": "NativeWatcher.stop", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/path-watcher.js", "line": 137, "func_start_line": 130}}, {"func_info": {"comment": [], "name": "TextEditorComponent.scheduleUpdate", "params": ["nextUpdateOnlyBlinksCursors"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 219, "start_line": 204}, "call_info": {"func_end_line": 1999, "code": "  stopCursorBlinking () {\r\n    if (this.cursorsBlinking) {\r\n      this.cursorsBlinkedOff = false\r\n      this.cursorsBlinking = false\r\n      window.clearInterval(this.cursorBlinkIntervalHandle)\r\n      this.cursorBlinkIntervalHandle = null\r\n      this.scheduleUpdate()\r\n    }\r\n  }\r", "name": "scheduleUpdate", "func_location": "TextEditorComponent.stopCursorBlinking", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1997, "func_start_line": 1991}}, {"func_info": {"comment": [], "name": "copyFile", "params": ["source", "destination", "mode"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js", "end_line": 165, "start_line": 149}, "call_info": {"func_end_line": 111, "code": "  async store () {\r\n    await copyFile(this.originalPath, this.recoveryPath, this.fileMode)\r\n  }\r", "name": "copyFile", "func_location": "RecoveryFile.store", "args": [".originalPath", ".recoveryPath", ".fileMode"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js", "line": 110, "func_start_line": 109}}, {"func_info": {"comment": [" Public: Returns a {Boolean} that is `true` if the current window is running specs."], "name": "AtomEnvironment.inSpecMode", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 471, "start_line": 468}, "call_info": {"func_end_line": 770, "code": "  storeWindowBackground () {\r\n    if (this.inSpecMode()) return\r\n\r\n    const backgroundColor = this.window.getComputedStyle(this.workspace.getElement())['background-color']\r\n    this.window.localStorage.setItem('atom:window-background-color', backgroundColor)\r\n  }\r", "name": "inSpecMode", "func_location": "AtomEnvironment.storeWindowBackground", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 766, "func_start_line": 765}}, {"func_info": {"comment": [" Get the dimensions of this window.", "", " Returns an {Object} with the following keys:", "   * `x`      The window's x-position {Number}.", "   * `y`      The window's y-position {Number}.", "   * `width`  The window's width {Number}.", "   * `height` The window's height {Number}."], "name": "AtomEnvironment.getWindowDimensions", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 688, "start_line": 682}, "call_info": {"func_end_line": 725, "code": "  storeWindowDimensions () {\r\n    this.windowDimensions = this.getWindowDimensions()\r\n    if (this.isValidDimensions(this.windowDimensions)) {\r\n      localStorage.setItem('defaultWindowDimensions', JSON.stringify(this.windowDimensions))\r\n    }\r\n  }\r", "name": "getWindowDimensions", "func_location": "AtomEnvironment.storeWindowDimensions", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 721, "func_start_line": 720}}, {"func_info": {"comment": [" Returns true if the dimensions are useable, false if they should be ignored.", " Work around for https://github.com/atom/atom-shell/issues/473"], "name": "AtomEnvironment.isValidDimensions", "params": [["x", "y", "width", "height"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 718, "start_line": 716}, "call_info": {"func_end_line": 725, "code": "  storeWindowDimensions () {\r\n    this.windowDimensions = this.getWindowDimensions()\r\n    if (this.isValidDimensions(this.windowDimensions)) {\r\n      localStorage.setItem('defaultWindowDimensions', JSON.stringify(this.windowDimensions))\r\n    }\r\n  }\r", "name": "isValidDimensions", "func_location": "AtomEnvironment.storeWindowDimensions", "args": [".windowDimensions"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 722, "func_start_line": 720}}, {"func_info": {"comment": [], "name": "Package.getActivationCommands", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 888, "start_line": 870}, "call_info": {"func_end_line": 868, "code": "  subscribeToActivationCommands () {\r\n    this.activationCommandSubscriptions = new CompositeDisposable()\r\n    const object = this.getActivationCommands()\r\n    for (let selector in object) {\r\n      const commands = object[selector]\r\n      for (let command of commands) {\r\n        ((selector, command) => {\r\n          // Add dummy command so it appears in menu.\r\n          // The real command will be registered on package activation\r\n          try {\r\n            this.activationCommandSubscriptions.add(this.commandRegistry.add(selector, command, function () {}))\r\n          } catch (error) {\r\n            if (error.code === 'EBADSELECTOR') {\r\n              const metadataPath = path.join(this.path, 'package.json')\r\n              error.message += ` in ${metadataPath}`\r\n              error.stack += `\\n  at ${metadataPath}:1:1`\r\n            }\r\n            throw error\r\n          }\r\n\r\n          this.activationCommandSubscriptions.add(this.commandRegistry.onWillDispatch(event => {\r\n            if (event.type !== command) return\r\n            let currentTarget = event.target\r\n            while (currentTarget) {\r\n              if (currentTarget.webkitMatchesSelector(selector)) {\r\n                this.activationCommandSubscriptions.dispose()\r\n                this.activateNow()\r\n                break\r\n              }\r\n              currentTarget = currentTarget.parentElement\r\n            }\r\n          }))\r\n        })(selector, command)\r\n      }\r\n    }\r\n  }\r", "name": "getActivationCommands", "func_location": "Package.subscribeToActivationCommands", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 835, "func_start_line": 833}}, {"func_info": {"comment": [], "name": "Package.getActivationHooks", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 917, "start_line": 901}, "call_info": {"func_end_line": 899, "code": "  subscribeToActivationHooks () {\r\n    this.activationHookSubscriptions = new CompositeDisposable()\r\n    for (let hook of this.getActivationHooks()) {\r\n      if (typeof hook === 'string' && hook.trim().length > 0) {\r\n        this.activationHookSubscriptions.add(\r\n          this.packageManager.onDidTriggerActivationHook(hook, () => this.activateNow())\r\n        )\r\n      }\r\n    }\r\n  }\r", "name": "getActivationHooks", "func_location": "Package.subscribeToActivationHooks", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 892, "func_start_line": 890}}, {"func_info": {"comment": [" Extended: Invoke the given callback when a pane item is added to the", " workspace.", "", " * `callback` {Function} to be called when pane items are added.", "   * `event` {Object} with the following keys:", "     * `item` The added pane item.", "     * `pane` {Pane} containing the added item.", "     * `index` {Number} indicating the index of the added item in its pane.", "", " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."], "name": "Workspace.onDidAddPaneItem", "params": ["callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 831, "start_line": 827}, "call_info": {"func_end_line": 518, "name": "onDidAddPaneItem", "func_location": "Workspace.subscribeToAddedItems", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 496, "func_start_line": 495}}, {"func_info": {"comment": [], "name": "Package.subscribeToActivationCommands", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 868, "start_line": 833}, "call_info": {"func_end_line": 831, "code": "  subscribeToDeferredActivation () {\r\n    this.subscribeToActivationCommands()\r\n    this.subscribeToActivationHooks()\r\n  }\r", "name": "subscribeToActivationCommands", "func_location": "Package.subscribeToDeferredActivation", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 829, "func_start_line": 828}}, {"func_info": {"comment": [], "name": "Package.subscribeToActivationHooks", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 899, "start_line": 890}, "call_info": {"func_end_line": 831, "code": "  subscribeToDeferredActivation () {\r\n    this.subscribeToActivationCommands()\r\n    this.subscribeToActivationHooks()\r\n  }\r", "name": "subscribeToActivationHooks", "func_location": "Package.subscribeToDeferredActivation", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 830, "func_start_line": 828}}, {"func_info": {"comment": [" Essential: Get the {Dock} to the left of the editor window."], "name": "Workspace.getLeftDock", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1606, "start_line": 1604}, "call_info": {"func_end_line": 532, "code": "  subscribeToDockToggling () {\r\n    const docks = [this.getLeftDock(), this.getRightDock(), this.getBottomDock()]\r\n    docks.forEach(dock => {\r\n      dock.onDidChangeVisible(visible => {\r\n        if (visible) return\r\n        const {activeElement} = document\r\n        const dockElement = dock.getElement()\r\n        if (dockElement === activeElement || dockElement.contains(activeElement)) {\r\n          this.getCenter().activate()\r\n        }\r\n      })\r\n    })\r\n  }\r", "name": "getLeftDock", "func_location": "Workspace.subscribeToDockToggling", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 521, "func_start_line": 520}}, {"func_info": {"comment": [" Essential: Get the {Dock} to the right of the editor window."], "name": "Workspace.getRightDock", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1611, "start_line": 1609}, "call_info": {"func_end_line": 532, "code": "  subscribeToDockToggling () {\r\n    const docks = [this.getLeftDock(), this.getRightDock(), this.getBottomDock()]\r\n    docks.forEach(dock => {\r\n      dock.onDidChangeVisible(visible => {\r\n        if (visible) return\r\n        const {activeElement} = document\r\n        const dockElement = dock.getElement()\r\n        if (dockElement === activeElement || dockElement.contains(activeElement)) {\r\n          this.getCenter().activate()\r\n        }\r\n      })\r\n    })\r\n  }\r", "name": "getRightDock", "func_location": "Workspace.subscribeToDockToggling", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 521, "func_start_line": 520}}, {"func_info": {"comment": [" Essential: Get the {Dock} below the editor window."], "name": "Workspace.getBottomDock", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1616, "start_line": 1614}, "call_info": {"func_end_line": 532, "code": "  subscribeToDockToggling () {\r\n    const docks = [this.getLeftDock(), this.getRightDock(), this.getBottomDock()]\r\n    docks.forEach(dock => {\r\n      dock.onDidChangeVisible(visible => {\r\n        if (visible) return\r\n        const {activeElement} = document\r\n        const dockElement = dock.getElement()\r\n        if (dockElement === activeElement || dockElement.contains(activeElement)) {\r\n          this.getCenter().activate()\r\n        }\r\n      })\r\n    })\r\n  }\r", "name": "getBottomDock", "func_location": "Workspace.subscribeToDockToggling", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 521, "func_start_line": 520}}, {"func_info": {"comment": [], "name": "Workspace.subscribeToFontSize", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1551, "start_line": 1545}, "call_info": {"func_end_line": 326, "code": "  subscribeToEvents () {\r\n    this.project.onDidChangePaths(this.updateWindowTitle)\r\n    this.subscribeToFontSize()\r\n    this.subscribeToAddedItems()\r\n    this.subscribeToMovedItems()\r\n    this.subscribeToDockToggling()\r\n  }\r", "name": "subscribeToFontSize", "func_location": "Workspace.subscribeToEvents", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 322, "func_start_line": 320}}, {"func_info": {"comment": [], "name": "Workspace.subscribeToAddedItems", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 518, "start_line": 495}, "call_info": {"func_end_line": 326, "code": "  subscribeToEvents () {\r\n    this.project.onDidChangePaths(this.updateWindowTitle)\r\n    this.subscribeToFontSize()\r\n    this.subscribeToAddedItems()\r\n    this.subscribeToMovedItems()\r\n    this.subscribeToDockToggling()\r\n  }\r", "name": "subscribeToAddedItems", "func_location": "Workspace.subscribeToEvents", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 323, "func_start_line": 320}}, {"func_info": {"comment": [], "name": "Workspace.subscribeToMovedItems", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 557, "start_line": 534}, "call_info": {"func_end_line": 326, "code": "  subscribeToEvents () {\r\n    this.project.onDidChangePaths(this.updateWindowTitle)\r\n    this.subscribeToFontSize()\r\n    this.subscribeToAddedItems()\r\n    this.subscribeToMovedItems()\r\n    this.subscribeToDockToggling()\r\n  }\r", "name": "subscribeToMovedItems", "func_location": "Workspace.subscribeToEvents", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 324, "func_start_line": 320}}, {"func_info": {"comment": [], "name": "Workspace.subscribeToDockToggling", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 532, "start_line": 520}, "call_info": {"func_end_line": 326, "code": "  subscribeToEvents () {\r\n    this.project.onDidChangePaths(this.updateWindowTitle)\r\n    this.subscribeToFontSize()\r\n    this.subscribeToAddedItems()\r\n    this.subscribeToMovedItems()\r\n    this.subscribeToDockToggling()\r\n  }\r", "name": "subscribeToDockToggling", "func_location": "Workspace.subscribeToEvents", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 325, "func_start_line": 320}}, {"func_info": {"comment": [], "name": "Workspace.getPaneContainers", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1625, "start_line": 1618}, "call_info": {"func_end_line": 557, "code": "  subscribeToMovedItems () {\r\n    for (const paneContainer of this.getPaneContainers()) {\r\n      paneContainer.observePanes(pane => {\r\n        pane.onDidAddItem(({item}) => {\r\n          if (typeof item.getURI === 'function' && this.enablePersistence) {\r\n            const uri = item.getURI()\r\n            if (uri) {\r\n              const location = paneContainer.getLocation()\r\n              let defaultLocation\r\n              if (typeof item.getDefaultLocation === 'function') {\r\n                defaultLocation = item.getDefaultLocation()\r\n              }\r\n              defaultLocation = defaultLocation || 'center'\r\n              if (location === defaultLocation) {\r\n                this.itemLocationStore.delete(item.getURI())\r\n              } else {\r\n                this.itemLocationStore.save(item.getURI(), location)\r\n              }\r\n            }\r\n          }\r\n        })\r\n      })\r\n    }\r\n  }\r", "name": "getPaneContainers", "func_location": "Workspace.subscribeToMovedItems", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 535, "func_start_line": 534}}, {"func_info": {"comment": [" Flattens the given menu template into an single Array.", "", " template - An object describing the menu item.", "", " Returns an Array of native menu items."], "name": "ApplicationMenu.flattenMenuTemplate", "params": ["template"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "end_line": 90, "start_line": 83}, "call_info": {"func_end_line": 106, "comment": [" Replaces VERSION with the current version."], "code": "  substituteVersion (template) {\r\n    let item = this.flattenMenuTemplate(template).find(({label}) => label === 'VERSION')\r\n    if (item) item.label = `Version ${this.version}`\r\n  }\r", "name": "flattenMenuTemplate", "func_location": "ApplicationMenu.substituteVersion", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "line": 104, "func_start_line": 103}}, {"func_info": {"comment": ["\r\n  Section: Private\r\n  "], "name": "Cursor.getNonWordCharacters", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 718, "start_line": 716}, "call_info": {"func_end_line": 710, "comment": [" Public: Get the RegExp used by the cursor to determine what a \"subword\" is.", "", " * `options` (optional) {Object} with the following keys:", "   * `backwards` A {Boolean} indicating whether to look forwards or backwards", "     for the next subword. (default: false)", "", " Returns a {RegExp}."], "code": "  subwordRegExp (options = {}) {\r\n    const nonWordCharacters = this.getNonWordCharacters()\r\n    const lowercaseLetters = 'a-z\\\\u00DF-\\\\u00F6\\\\u00F8-\\\\u00FF'\r\n    const uppercaseLetters = 'A-Z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00DE'\r\n    const snakeCamelSegment = `[${uppercaseLetters}]?[${lowercaseLetters}]+`\r\n    const segments = [\r\n      '^[\\t ]+',\r\n      '[\\t ]+$',\r\n      `[${uppercaseLetters}]+(?![${lowercaseLetters}])`,\r\n      '\\\\d+'\r\n    ]\r\n    if (options.backwards) {\r\n      segments.push(`${snakeCamelSegment}_*`)\r\n      segments.push(`[${_.escapeRegExp(nonWordCharacters)}]+\\\\s*`)\r\n    } else {\r\n      segments.push(`_*${snakeCamelSegment}`)\r\n      segments.push(`\\\\s*[${_.escapeRegExp(nonWordCharacters)}]+`)\r\n    }\r\n    segments.push('_+')\r\n    return new RegExp(segments.join('|'), 'g')\r\n  }\r", "name": "getNonWordCharacters", "func_location": "Cursor.subwordRegExp", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 691, "func_start_line": 690}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.tokenizedLineForRow", "params": ["bufferRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 449, "start_line": 425}, "call_info": {"func_end_line": 90, "comment": ["\r\n  Section - auto-indent\r\n  ", " Get the suggested indentation level for an existing line in the buffer.", "", " * bufferRow - A {Number} indicating the buffer row", "", " Returns a {Number}."], "code": "  suggestedIndentForBufferRow (bufferRow, tabLength, options) {\r\n    const line = this.buffer.lineForRow(bufferRow)\r\n    const tokenizedLine = this.tokenizedLineForRow(bufferRow)\r\n    const iterator = tokenizedLine.getTokenIterator()\r\n    iterator.next()\r\n    const scopeDescriptor = new ScopeDescriptor({scopes: iterator.getScopes()})\r\n    return this._suggestedIndentForLineWithScopeAtBufferRow(\r\n      bufferRow,\r\n      line,\r\n      scopeDescriptor,\r\n      tabLength,\r\n      options\r\n    )\r\n  }\r", "name": "tokenizedLineForRow", "func_location": "TextMateLanguageMode.suggestedIndentForBufferRow", "args": ["bufferRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 79, "func_start_line": 77}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode._suggestedIndentForLineWithScopeAtBufferRow", "params": ["bufferRow", "line", "scopeDescriptor", "tabLength", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 179, "start_line": 151}, "call_info": {"func_end_line": 90, "name": "_suggestedIndentForLineWithScopeAtBufferRow", "func_location": "TextMateLanguageMode.suggestedIndentForBufferRow", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 83, "func_start_line": 77}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.indentLevelForLine", "params": ["line", "tabLength"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 505, "start_line": 492}, "call_info": {"func_end_line": 149, "comment": [" Get the suggested indentation level for a line in the buffer on which the user is currently", " typing. This may return a different result from {::suggestedIndentForBufferRow} in order", " to avoid unexpected changes in indentation. It may also return undefined if no change should", " be made.", "", " * bufferRow - The row {Number}", "", " Returns a {Number}."], "code": "  suggestedIndentForEditedBufferRow (bufferRow, tabLength) {\r\n    const line = this.buffer.lineForRow(bufferRow)\r\n    const currentIndentLevel = this.indentLevelForLine(line, tabLength)\r\n    if (currentIndentLevel === 0) return\r\n\r\n    const scopeDescriptor = this.scopeDescriptorForPosition(new Point(bufferRow, 0))\r\n    const decreaseIndentRegex = this.decreaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (!decreaseIndentRegex) return\r\n\r\n    if (!decreaseIndentRegex.testSync(line)) return\r\n\r\n    const precedingRow = this.buffer.previousNonBlankRow(bufferRow)\r\n    if (precedingRow == null) return\r\n\r\n    const precedingLine = this.buffer.lineForRow(precedingRow)\r\n    let desiredIndentLevel = this.indentLevelForLine(precedingLine, tabLength)\r\n\r\n    const increaseIndentRegex = this.increaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (increaseIndentRegex) {\r\n      if (!increaseIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    const decreaseNextIndentRegex = this.decreaseNextIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (decreaseNextIndentRegex) {\r\n      if (decreaseNextIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    if (desiredIndentLevel < 0) return 0\r\n    if (desiredIndentLevel >= currentIndentLevel) return\r\n    return desiredIndentLevel\r\n  }\r", "name": "indentLevelForLine", "func_location": "TextMateLanguageMode.suggestedIndentForEditedBufferRow", "args": ["line", "tabLength"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 121, "func_start_line": 119}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.scopeDescriptorForPosition", "params": ["position"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 526, "start_line": 507}, "call_info": {"func_end_line": 149, "comment": [" Get the suggested indentation level for a line in the buffer on which the user is currently", " typing. This may return a different result from {::suggestedIndentForBufferRow} in order", " to avoid unexpected changes in indentation. It may also return undefined if no change should", " be made.", "", " * bufferRow - The row {Number}", "", " Returns a {Number}."], "code": "  suggestedIndentForEditedBufferRow (bufferRow, tabLength) {\r\n    const line = this.buffer.lineForRow(bufferRow)\r\n    const currentIndentLevel = this.indentLevelForLine(line, tabLength)\r\n    if (currentIndentLevel === 0) return\r\n\r\n    const scopeDescriptor = this.scopeDescriptorForPosition(new Point(bufferRow, 0))\r\n    const decreaseIndentRegex = this.decreaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (!decreaseIndentRegex) return\r\n\r\n    if (!decreaseIndentRegex.testSync(line)) return\r\n\r\n    const precedingRow = this.buffer.previousNonBlankRow(bufferRow)\r\n    if (precedingRow == null) return\r\n\r\n    const precedingLine = this.buffer.lineForRow(precedingRow)\r\n    let desiredIndentLevel = this.indentLevelForLine(precedingLine, tabLength)\r\n\r\n    const increaseIndentRegex = this.increaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (increaseIndentRegex) {\r\n      if (!increaseIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    const decreaseNextIndentRegex = this.decreaseNextIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (decreaseNextIndentRegex) {\r\n      if (decreaseNextIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    if (desiredIndentLevel < 0) return 0\r\n    if (desiredIndentLevel >= currentIndentLevel) return\r\n    return desiredIndentLevel\r\n  }\r", "name": "scopeDescriptorForPosition", "func_location": "TextMateLanguageMode.suggestedIndentForEditedBufferRow", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 124, "func_start_line": 119}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.decreaseIndentRegexForScopeDescriptor", "params": ["scope"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 703, "start_line": 701}, "call_info": {"func_end_line": 149, "comment": [" Get the suggested indentation level for a line in the buffer on which the user is currently", " typing. This may return a different result from {::suggestedIndentForBufferRow} in order", " to avoid unexpected changes in indentation. It may also return undefined if no change should", " be made.", "", " * bufferRow - The row {Number}", "", " Returns a {Number}."], "code": "  suggestedIndentForEditedBufferRow (bufferRow, tabLength) {\r\n    const line = this.buffer.lineForRow(bufferRow)\r\n    const currentIndentLevel = this.indentLevelForLine(line, tabLength)\r\n    if (currentIndentLevel === 0) return\r\n\r\n    const scopeDescriptor = this.scopeDescriptorForPosition(new Point(bufferRow, 0))\r\n    const decreaseIndentRegex = this.decreaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (!decreaseIndentRegex) return\r\n\r\n    if (!decreaseIndentRegex.testSync(line)) return\r\n\r\n    const precedingRow = this.buffer.previousNonBlankRow(bufferRow)\r\n    if (precedingRow == null) return\r\n\r\n    const precedingLine = this.buffer.lineForRow(precedingRow)\r\n    let desiredIndentLevel = this.indentLevelForLine(precedingLine, tabLength)\r\n\r\n    const increaseIndentRegex = this.increaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (increaseIndentRegex) {\r\n      if (!increaseIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    const decreaseNextIndentRegex = this.decreaseNextIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (decreaseNextIndentRegex) {\r\n      if (decreaseNextIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    if (desiredIndentLevel < 0) return 0\r\n    if (desiredIndentLevel >= currentIndentLevel) return\r\n    return desiredIndentLevel\r\n  }\r", "name": "decreaseIndentRegexForScopeDescriptor", "func_location": "TextMateLanguageMode.suggestedIndentForEditedBufferRow", "args": ["scopeDescriptor"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 125, "func_start_line": 119}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.indentLevelForLine", "params": ["line", "tabLength"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 505, "start_line": 492}, "call_info": {"func_end_line": 149, "comment": [" Get the suggested indentation level for a line in the buffer on which the user is currently", " typing. This may return a different result from {::suggestedIndentForBufferRow} in order", " to avoid unexpected changes in indentation. It may also return undefined if no change should", " be made.", "", " * bufferRow - The row {Number}", "", " Returns a {Number}."], "code": "  suggestedIndentForEditedBufferRow (bufferRow, tabLength) {\r\n    const line = this.buffer.lineForRow(bufferRow)\r\n    const currentIndentLevel = this.indentLevelForLine(line, tabLength)\r\n    if (currentIndentLevel === 0) return\r\n\r\n    const scopeDescriptor = this.scopeDescriptorForPosition(new Point(bufferRow, 0))\r\n    const decreaseIndentRegex = this.decreaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (!decreaseIndentRegex) return\r\n\r\n    if (!decreaseIndentRegex.testSync(line)) return\r\n\r\n    const precedingRow = this.buffer.previousNonBlankRow(bufferRow)\r\n    if (precedingRow == null) return\r\n\r\n    const precedingLine = this.buffer.lineForRow(precedingRow)\r\n    let desiredIndentLevel = this.indentLevelForLine(precedingLine, tabLength)\r\n\r\n    const increaseIndentRegex = this.increaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (increaseIndentRegex) {\r\n      if (!increaseIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    const decreaseNextIndentRegex = this.decreaseNextIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (decreaseNextIndentRegex) {\r\n      if (decreaseNextIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    if (desiredIndentLevel < 0) return 0\r\n    if (desiredIndentLevel >= currentIndentLevel) return\r\n    return desiredIndentLevel\r\n  }\r", "name": "indentLevelForLine", "func_location": "TextMateLanguageMode.suggestedIndentForEditedBufferRow", "args": ["precedingLine", "tabLength"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 134, "func_start_line": 119}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.increaseIndentRegexForScopeDescriptor", "params": ["scope"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 699, "start_line": 697}, "call_info": {"func_end_line": 149, "comment": [" Get the suggested indentation level for a line in the buffer on which the user is currently", " typing. This may return a different result from {::suggestedIndentForBufferRow} in order", " to avoid unexpected changes in indentation. It may also return undefined if no change should", " be made.", "", " * bufferRow - The row {Number}", "", " Returns a {Number}."], "code": "  suggestedIndentForEditedBufferRow (bufferRow, tabLength) {\r\n    const line = this.buffer.lineForRow(bufferRow)\r\n    const currentIndentLevel = this.indentLevelForLine(line, tabLength)\r\n    if (currentIndentLevel === 0) return\r\n\r\n    const scopeDescriptor = this.scopeDescriptorForPosition(new Point(bufferRow, 0))\r\n    const decreaseIndentRegex = this.decreaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (!decreaseIndentRegex) return\r\n\r\n    if (!decreaseIndentRegex.testSync(line)) return\r\n\r\n    const precedingRow = this.buffer.previousNonBlankRow(bufferRow)\r\n    if (precedingRow == null) return\r\n\r\n    const precedingLine = this.buffer.lineForRow(precedingRow)\r\n    let desiredIndentLevel = this.indentLevelForLine(precedingLine, tabLength)\r\n\r\n    const increaseIndentRegex = this.increaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (increaseIndentRegex) {\r\n      if (!increaseIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    const decreaseNextIndentRegex = this.decreaseNextIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (decreaseNextIndentRegex) {\r\n      if (decreaseNextIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    if (desiredIndentLevel < 0) return 0\r\n    if (desiredIndentLevel >= currentIndentLevel) return\r\n    return desiredIndentLevel\r\n  }\r", "name": "increaseIndentRegexForScopeDescriptor", "func_location": "TextMateLanguageMode.suggestedIndentForEditedBufferRow", "args": ["scopeDescriptor"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 136, "func_start_line": 119}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.decreaseNextIndentRegexForScopeDescriptor", "params": ["scope"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 707, "start_line": 705}, "call_info": {"func_end_line": 149, "comment": [" Get the suggested indentation level for a line in the buffer on which the user is currently", " typing. This may return a different result from {::suggestedIndentForBufferRow} in order", " to avoid unexpected changes in indentation. It may also return undefined if no change should", " be made.", "", " * bufferRow - The row {Number}", "", " Returns a {Number}."], "code": "  suggestedIndentForEditedBufferRow (bufferRow, tabLength) {\r\n    const line = this.buffer.lineForRow(bufferRow)\r\n    const currentIndentLevel = this.indentLevelForLine(line, tabLength)\r\n    if (currentIndentLevel === 0) return\r\n\r\n    const scopeDescriptor = this.scopeDescriptorForPosition(new Point(bufferRow, 0))\r\n    const decreaseIndentRegex = this.decreaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (!decreaseIndentRegex) return\r\n\r\n    if (!decreaseIndentRegex.testSync(line)) return\r\n\r\n    const precedingRow = this.buffer.previousNonBlankRow(bufferRow)\r\n    if (precedingRow == null) return\r\n\r\n    const precedingLine = this.buffer.lineForRow(precedingRow)\r\n    let desiredIndentLevel = this.indentLevelForLine(precedingLine, tabLength)\r\n\r\n    const increaseIndentRegex = this.increaseIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (increaseIndentRegex) {\r\n      if (!increaseIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    const decreaseNextIndentRegex = this.decreaseNextIndentRegexForScopeDescriptor(scopeDescriptor)\r\n    if (decreaseNextIndentRegex) {\r\n      if (decreaseNextIndentRegex.testSync(precedingLine)) desiredIndentLevel -= 1\r\n    }\r\n\r\n    if (desiredIndentLevel < 0) return 0\r\n    if (desiredIndentLevel >= currentIndentLevel) return\r\n    return desiredIndentLevel\r\n  }\r", "name": "decreaseNextIndentRegexForScopeDescriptor", "func_location": "TextMateLanguageMode.suggestedIndentForEditedBufferRow", "args": ["scopeDescriptor"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 141, "func_start_line": 119}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.buildTokenizedLineForRowWithText", "params": ["row", "text", "currentRuleStack", "openScopes"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 423, "start_line": 411}, "call_info": {"func_end_line": 109, "comment": [" Get the suggested indentation level for a given line of text, if it were inserted at the given", " row in the buffer.", "", " * bufferRow - A {Number} indicating the buffer row", "", " Returns a {Number}."], "code": "  suggestedIndentForLineAtBufferRow (bufferRow, line, tabLength) {\r\n    const tokenizedLine = this.buildTokenizedLineForRowWithText(bufferRow, line)\r\n    const iterator = tokenizedLine.getTokenIterator()\r\n    iterator.next()\r\n    const scopeDescriptor = new ScopeDescriptor({scopes: iterator.getScopes()})\r\n    return this._suggestedIndentForLineWithScopeAtBufferRow(\r\n      bufferRow,\r\n      line,\r\n      scopeDescriptor,\r\n      tabLength\r\n    )\r\n  }\r", "name": "buildTokenizedLineForRowWithText", "func_location": "TextMateLanguageMode.suggestedIndentForLineAtBufferRow", "args": ["bufferRow", "line"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 99, "func_start_line": 98}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode._suggestedIndentForLineWithScopeAtBufferRow", "params": ["bufferRow", "line", "scopeDescriptor", "tabLength", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 179, "start_line": 151}, "call_info": {"func_end_line": 109, "name": "_suggestedIndentForLineWithScopeAtBufferRow", "func_location": "TextMateLanguageMode.suggestedIndentForLineAtBufferRow", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 103, "func_start_line": 98}}, {"func_info": {"comment": [], "name": "TreeSitterLanguageMode._forEachTreeWithRange", "params": ["range", "callback"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 316, "start_line": 303}, "call_info": {"func_end_line": 484, "name": "_forEachTreeWithRange", "func_location": "TreeSitterLanguageMode.syntaxTreeScopeDescriptorForPosition", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 465, "func_start_line": 454}}, {"func_info": {"comment": [], "name": "objectsEqual", "params": ["a", "b"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4376, "start_line": 4364}, "call_info": {"func_end_line": 4354, "code": "function textDecorationsEqual (oldDecorations, newDecorations) {\r\n  if (!oldDecorations && newDecorations) return false\r\n  if (oldDecorations && !newDecorations) return false\r\n  if (oldDecorations && newDecorations) {\r\n    if (oldDecorations.length !== newDecorations.length) return false\r\n    for (let j = 0; j < oldDecorations.length; j++) {\r\n      if (oldDecorations[j].column !== newDecorations[j].column) return false\r\n      if (oldDecorations[j].className !== newDecorations[j].className) return false\r\n      if (!objectsEqual(oldDecorations[j].style, newDecorations[j].style)) return false\r\n    }\r\n  }\r\n  return true\r\n}\r", "name": "objectsEqual", "func_location": "textDecorationsEqual", "args": ["oldDecorations.j.style", "newDecorations.j.style"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 4350, "func_start_line": 4342}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRowsPerTile", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2714, "start_line": 2712}, "call_info": {"func_end_line": 2718, "code": "  tileStartRowForRow (row) {\r\n    return row - (row % this.getRowsPerTile())\r\n  }\r", "name": "getRowsPerTile", "func_location": "TextEditorComponent.tileStartRowForRow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2717, "func_start_line": 2716}}, {"func_info": {"comment": [], "name": "ReopenProjectListView.cancel", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js", "end_line": 50, "start_line": 40}, "call_info": {"func_end_line": 70, "code": "  async toggle () {\r\n    if (this.panel != null) {\r\n      this.cancel()\r\n    } else {\r\n      this.currentProjectName = atom.project != null ? this.makeName(atom.project.getPaths()) : null\r\n      const projects = atom.history.getProjects().map(p => ({ name: this.makeName(p.paths), value: p.paths }))\r\n      await this.selectListView.update({items: projects})\r\n      this.attach()\r\n    }\r\n  }\r", "name": "cancel", "func_location": "ReopenProjectListView.toggle", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js", "line": 63, "func_start_line": 61}}, {"func_info": {"comment": [], "name": "ReopenProjectListView.makeName", "params": ["paths"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js", "end_line": 74, "start_line": 72}, "call_info": {"func_end_line": 70, "code": "  async toggle () {\r\n    if (this.panel != null) {\r\n      this.cancel()\r\n    } else {\r\n      this.currentProjectName = atom.project != null ? this.makeName(atom.project.getPaths()) : null\r\n      const projects = atom.history.getProjects().map(p => ({ name: this.makeName(p.paths), value: p.paths }))\r\n      await this.selectListView.update({items: projects})\r\n      this.attach()\r\n    }\r\n  }\r", "name": "makeName", "func_location": "ReopenProjectListView.toggle", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js", "line": 65, "func_start_line": 61}}, {"func_info": {"comment": [], "name": "ReopenProjectListView.attach", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js", "end_line": 59, "start_line": 52}, "call_info": {"func_end_line": 70, "code": "  async toggle () {\r\n    if (this.panel != null) {\r\n      this.cancel()\r\n    } else {\r\n      this.currentProjectName = atom.project != null ? this.makeName(atom.project.getPaths()) : null\r\n      const projects = atom.history.getProjects().map(p => ({ name: this.makeName(p.paths), value: p.paths }))\r\n      await this.selectListView.update({items: projects})\r\n      this.attach()\r\n    }\r\n  }\r", "name": "attach", "func_location": "ReopenProjectListView.toggle", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-list-view.js", "line": 68, "func_start_line": 61}}, {"func_info": {"comment": [" Essential: Search the workspace for items matching the given URI and hide them.", "", " * `itemOrURI` The item to hide or a {String} containing the URI", "   of the item to hide.", "", " Returns a {Boolean} indicating whether any items were found (and hidden)."], "name": "Workspace.hide", "params": ["itemOrURI"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1116, "start_line": 1087}, "call_info": {"func_end_line": 1131, "comment": [" Essential: Search the workspace for items matching the given URI. If any are found, hide them.", " Otherwise, open the URL.", "", " * `itemOrURI` (optional) The item to toggle or a {String} containing the URI", "   of the item to toggle.", "", " Returns a Promise that resolves when the item is shown or hidden."], "code": "  toggle (itemOrURI) {\r\n    if (this.hide(itemOrURI)) {\r\n      return Promise.resolve()\r\n    } else {\r\n      return this.open(itemOrURI, {searchAllPanes: true})\r\n    }\r\n  }\r", "name": "hide", "func_location": "Workspace.toggle", "args": ["itemOrURI"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1126, "func_start_line": 1125}}, {"func_info": {"comment": ["\r\n  Section: Opening\r\n  ", " Essential: Opens the given URI in Atom asynchronously.", " If the URI is already open, the existing item for that URI will be", " activated. If no URI is given, or no registered opener can open", " the URI, a new empty {TextEditor} will be created.", "", " * `uri` (optional) A {String} containing a URI.", " * `options` (optional) {Object}", "   * `initialLine` A {Number} indicating which row to move the cursor to", "     initially. Defaults to `0`.", "   * `initialColumn` A {Number} indicating which column to move the cursor to", "     initially. Defaults to `0`.", "   * `split` Either 'left', 'right', 'up' or 'down'.", "     If 'left', the item will be opened in leftmost pane of the current active pane's row.", "     If 'right', the item will be opened in the rightmost pane of the current active pane's row. If only one pane exists in the row, a new pane will be created.", "     If 'up', the item will be opened in topmost pane of the current active pane's column.", "     If 'down', the item will be opened in the bottommost pane of the current active pane's column. If only one pane exists in the column, a new pane will be created.", "   * `activatePane` A {Boolean} indicating whether to call {Pane::activate} on", "     containing pane. Defaults to `true`.", "   * `activateItem` A {Boolean} indicating whether to call {Pane::activateItem}", "     on containing pane. Defaults to `true`.", "   * `pending` A {Boolean} indicating whether or not the item should be opened", "     in a pending state. Existing pending items in a pane are replaced with", "     new pending items when they are opened.", "   * `searchAllPanes` A {Boolean}. If `true`, the workspace will attempt to", "     activate an existing item for the given URI on any pane.", "     If `false`, only the active pane will be searched for", "     an existing item for the same URI. Defaults to `false`.", "   * `location` (optional) A {String} containing the name of the location", "     in which this item should be opened (one of \"left\", \"right\", \"bottom\",", "     or \"center\"). If omitted, Atom will fall back to the last location in", "     which a user has placed an item with the same URI or, if this is a new", "     URI, the default location specified by the item. NOTE: This option", "     should almost always be omitted to honor user preference.", "", " Returns a {Promise} that resolves to the {TextEditor} for the file URI."], "name": "Workspace.open", "params": ["itemOrURI", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1079, "start_line": 925}, "call_info": {"func_end_line": 1131, "comment": [" Essential: Search the workspace for items matching the given URI. If any are found, hide them.", " Otherwise, open the URL.", "", " * `itemOrURI` (optional) The item to toggle or a {String} containing the URI", "   of the item to toggle.", "", " Returns a Promise that resolves when the item is shown or hidden."], "code": "  toggle (itemOrURI) {\r\n    if (this.hide(itemOrURI)) {\r\n      return Promise.resolve()\r\n    } else {\r\n      return this.open(itemOrURI, {searchAllPanes: true})\r\n    }\r\n  }\r", "name": "open", "func_location": "Workspace.toggle", "args": ["itemOrURI", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 1129, "func_start_line": 1125}}, {"func_info": {"comment": [], "name": "Dock.setState", "params": ["newState"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "end_line": 177, "start_line": 144}, "call_info": {"func_end_line": 135, "comment": [" Extended: Toggle the dock's visibility without changing the {Workspace}'s", " active pane container."], "code": "  toggle () {\r\n    const state = {visible: !this.state.visible}\r\n    if (!state.visible) state.hovered = false\r\n    this.setState(state)\r\n  }\r", "name": "setState", "func_location": "Dock.toggle", "args": ["state"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/dock.js", "line": 134, "func_start_line": 131}}, {"func_info": {"comment": [" Extended: Set the full screen state of the current window."], "name": "AtomEnvironment.setFullScreen", "params": ["fullScreen"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 648, "start_line": 646}, "call_info": {"func_end_line": 653, "comment": [" Extended: Toggle the full screen state of the current window."], "code": "  toggleFullScreen () {\r\n    return this.setFullScreen(!this.isFullScreen())\r\n  }\r", "name": "setFullScreen", "func_location": "AtomEnvironment.toggleFullScreen", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 652, "func_start_line": 651}}, {"func_info": {"comment": [" Extended: Returns a {Boolean} that is `true` if the current window is in full screen mode."], "name": "AtomEnvironment.isFullScreen", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 643, "start_line": 641}, "call_info": {"func_end_line": 653, "comment": [" Extended: Toggle the full screen state of the current window."], "code": "  toggleFullScreen () {\r\n    return this.setFullScreen(!this.isFullScreen())\r\n  }\r", "name": "isFullScreen", "func_location": "AtomEnvironment.toggleFullScreen", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 652, "func_start_line": 651}}, {"func_info": {"comment": [], "name": "numberToHexString", "params": ["number"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js", "end_line": 129, "start_line": 126}, "call_info": {"func_end_line": 80, "comment": [" Essential: Returns a {String} in the form `'#abcdef'`."], "code": "  toHexString () {\r\n    return `#${numberToHexString(this.red)}${numberToHexString(this.green)}${numberToHexString(this.blue)}`\r\n  }\r", "name": "numberToHexString", "func_location": "Color.toHexString", "args": [".red"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js", "line": 79, "func_start_line": 78}}, {"func_info": {"comment": [], "name": "numberToHexString", "params": ["number"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js", "end_line": 129, "start_line": 126}, "call_info": {"func_end_line": 80, "comment": [" Essential: Returns a {String} in the form `'#abcdef'`."], "code": "  toHexString () {\r\n    return `#${numberToHexString(this.red)}${numberToHexString(this.green)}${numberToHexString(this.blue)}`\r\n  }\r", "name": "numberToHexString", "func_location": "Color.toHexString", "args": [".red"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js", "line": 79, "func_start_line": 78}}, {"func_info": {"comment": [], "name": "numberToHexString", "params": ["number"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js", "end_line": 129, "start_line": 126}, "call_info": {"func_end_line": 80, "comment": [" Essential: Returns a {String} in the form `'#abcdef'`."], "code": "  toHexString () {\r\n    return `#${numberToHexString(this.red)}${numberToHexString(this.green)}${numberToHexString(this.blue)}`\r\n  }\r", "name": "numberToHexString", "func_location": "Color.toHexString", "args": [".red"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js", "line": 79, "func_start_line": 78}}, {"func_info": {"comment": [" Essential: Returns a {String} in the form `'#abcdef'`."], "name": "Color.toHexString", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js", "end_line": 80, "start_line": 78}, "call_info": {"func_end_line": 89, "code": "  toJSON () {\r\n    return this.alpha === 1 ? this.toHexString() : this.toRGBAString()\r\n  }\r", "name": "toHexString", "func_location": "Color.toJSON", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js", "line": 88, "func_start_line": 87}}, {"func_info": {"comment": [" Essential: Returns a {String} in the form `'rgba(25, 50, 75, .9)'`."], "name": "Color.toRGBAString", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js", "end_line": 85, "start_line": 83}, "call_info": {"func_end_line": 89, "code": "  toJSON () {\r\n    return this.alpha === 1 ? this.toHexString() : this.toRGBAString()\r\n  }\r", "name": "toRGBAString", "func_location": "Color.toJSON", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js", "line": 88, "func_start_line": 87}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.tokenizedLineForRow", "params": ["bufferRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 449, "start_line": 425}, "call_info": {"func_end_line": 531, "code": "  tokenForPosition (position) {\r\n    const {row, column} = Point.fromObject(position)\r\n    return this.tokenizedLineForRow(row).tokenAtBufferColumn(column)\r\n  }\r", "name": "tokenizedLineForRow", "func_location": "TextMateLanguageMode.tokenForPosition", "args": ["column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 530, "func_start_line": 528}}, {"func_info": {"comment": [], "name": "TreeSitterLanguageMode.getSyntaxNodeAtPosition", "params": ["position", "where"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 418, "start_line": 416}, "call_info": {"func_end_line": 516, "code": "  tokenForPosition (point) {\r\n    const node = this.getSyntaxNodeAtPosition(point)\r\n    const scopes = this.scopeDescriptorForPosition(point).getScopesArray()\r\n    return new Token({value: node.text, scopes})\r\n  }\r", "name": "getSyntaxNodeAtPosition", "func_location": "TreeSitterLanguageMode.tokenForPosition", "args": ["point"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 513, "func_start_line": 512}}, {"func_info": {"comment": [], "name": "TreeSitterLanguageMode.scopeDescriptorForPosition", "params": ["point"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 510, "start_line": 486}, "call_info": {"func_end_line": 516, "code": "  tokenForPosition (point) {\r\n    const node = this.getSyntaxNodeAtPosition(point)\r\n    const scopes = this.scopeDescriptorForPosition(point).getScopesArray()\r\n    return new Token({value: node.text, scopes})\r\n  }\r", "name": "scopeDescriptorForPosition", "func_location": "TreeSitterLanguageMode.tokenForPosition", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 514, "func_start_line": 512}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.tokenizedLineForRow", "params": ["bufferRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 449, "start_line": 425}, "call_info": {"func_end_line": 457, "code": "  tokenizedLinesForRows (startRow, endRow) {\r\n    const result = []\r\n    for (let row = startRow, end = endRow; row <= end; row++) {\r\n      result.push(this.tokenizedLineForRow(row))\r\n    }\r\n    return result\r\n  }\r", "name": "tokenizedLineForRow", "func_location": "TextMateLanguageMode.tokenizedLinesForRows", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 454, "func_start_line": 451}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.firstInvalidRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 330, "start_line": 328}, "call_info": {"func_end_line": 319, "code": "  tokenizeNextChunk () {\r\n    let rowsRemaining = this.chunkSize\r\n\r\n    while (this.firstInvalidRow() != null && rowsRemaining > 0) {\r\n      var endRow, filledRegion\r\n      const startRow = this.invalidRows.shift()\r\n      const lastRow = this.buffer.getLastRow()\r\n      if (startRow > lastRow) continue\r\n\r\n      let row = startRow\r\n      while (true) {\r\n        const previousStack = this.stackForRow(row)\r\n        this.tokenizedLines[row] = this.buildTokenizedLineForRow(row, this.stackForRow(row - 1), this.openScopesForRow(row))\r\n        if (--rowsRemaining === 0) {\r\n          filledRegion = false\r\n          endRow = row\r\n          break\r\n        }\r\n        if (row === lastRow || _.isEqual(this.stackForRow(row), previousStack)) {\r\n          filledRegion = true\r\n          endRow = row\r\n          break\r\n        }\r\n        row++\r\n      }\r\n\r\n      this.validateRow(endRow)\r\n      if (!filledRegion) this.invalidateRow(endRow + 1)\r\n\r\n      this.emitter.emit('did-change-highlighting', Range(Point(startRow, 0), Point(endRow + 1, 0)))\r\n    }\r\n\r\n    if (this.firstInvalidRow() != null) {\r\n      this.tokenizeInBackground()\r\n    } else {\r\n      this.markTokenizationComplete()\r\n    }\r\n  }\r", "name": "firstInvalidRow", "func_location": "TextMateLanguageMode.tokenizeNextChunk", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 285, "func_start_line": 282}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.stackForRow", "params": ["bufferRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 461, "start_line": 459}, "call_info": {"func_end_line": 319, "code": "  tokenizeNextChunk () {\r\n    let rowsRemaining = this.chunkSize\r\n\r\n    while (this.firstInvalidRow() != null && rowsRemaining > 0) {\r\n      var endRow, filledRegion\r\n      const startRow = this.invalidRows.shift()\r\n      const lastRow = this.buffer.getLastRow()\r\n      if (startRow > lastRow) continue\r\n\r\n      let row = startRow\r\n      while (true) {\r\n        const previousStack = this.stackForRow(row)\r\n        this.tokenizedLines[row] = this.buildTokenizedLineForRow(row, this.stackForRow(row - 1), this.openScopesForRow(row))\r\n        if (--rowsRemaining === 0) {\r\n          filledRegion = false\r\n          endRow = row\r\n          break\r\n        }\r\n        if (row === lastRow || _.isEqual(this.stackForRow(row), previousStack)) {\r\n          filledRegion = true\r\n          endRow = row\r\n          break\r\n        }\r\n        row++\r\n      }\r\n\r\n      this.validateRow(endRow)\r\n      if (!filledRegion) this.invalidateRow(endRow + 1)\r\n\r\n      this.emitter.emit('did-change-highlighting', Range(Point(startRow, 0), Point(endRow + 1, 0)))\r\n    }\r\n\r\n    if (this.firstInvalidRow() != null) {\r\n      this.tokenizeInBackground()\r\n    } else {\r\n      this.markTokenizationComplete()\r\n    }\r\n  }\r", "name": "stackForRow", "func_location": "TextMateLanguageMode.tokenizeNextChunk", "args": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 293, "func_start_line": 282}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.buildTokenizedLineForRow", "params": ["row", "ruleStack", "openScopes"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 409, "start_line": 407}, "call_info": {"func_end_line": 319, "code": "  tokenizeNextChunk () {\r\n    let rowsRemaining = this.chunkSize\r\n\r\n    while (this.firstInvalidRow() != null && rowsRemaining > 0) {\r\n      var endRow, filledRegion\r\n      const startRow = this.invalidRows.shift()\r\n      const lastRow = this.buffer.getLastRow()\r\n      if (startRow > lastRow) continue\r\n\r\n      let row = startRow\r\n      while (true) {\r\n        const previousStack = this.stackForRow(row)\r\n        this.tokenizedLines[row] = this.buildTokenizedLineForRow(row, this.stackForRow(row - 1), this.openScopesForRow(row))\r\n        if (--rowsRemaining === 0) {\r\n          filledRegion = false\r\n          endRow = row\r\n          break\r\n        }\r\n        if (row === lastRow || _.isEqual(this.stackForRow(row), previousStack)) {\r\n          filledRegion = true\r\n          endRow = row\r\n          break\r\n        }\r\n        row++\r\n      }\r\n\r\n      this.validateRow(endRow)\r\n      if (!filledRegion) this.invalidateRow(endRow + 1)\r\n\r\n      this.emitter.emit('did-change-highlighting', Range(Point(startRow, 0), Point(endRow + 1, 0)))\r\n    }\r\n\r\n    if (this.firstInvalidRow() != null) {\r\n      this.tokenizeInBackground()\r\n    } else {\r\n      this.markTokenizationComplete()\r\n    }\r\n  }\r", "name": "buildTokenizedLineForRow", "func_location": "TextMateLanguageMode.tokenizeNextChunk", "args": ["row", null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 294, "func_start_line": 282}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.stackForRow", "params": ["bufferRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 461, "start_line": 459}, "call_info": {"func_end_line": 319, "code": "  tokenizeNextChunk () {\r\n    let rowsRemaining = this.chunkSize\r\n\r\n    while (this.firstInvalidRow() != null && rowsRemaining > 0) {\r\n      var endRow, filledRegion\r\n      const startRow = this.invalidRows.shift()\r\n      const lastRow = this.buffer.getLastRow()\r\n      if (startRow > lastRow) continue\r\n\r\n      let row = startRow\r\n      while (true) {\r\n        const previousStack = this.stackForRow(row)\r\n        this.tokenizedLines[row] = this.buildTokenizedLineForRow(row, this.stackForRow(row - 1), this.openScopesForRow(row))\r\n        if (--rowsRemaining === 0) {\r\n          filledRegion = false\r\n          endRow = row\r\n          break\r\n        }\r\n        if (row === lastRow || _.isEqual(this.stackForRow(row), previousStack)) {\r\n          filledRegion = true\r\n          endRow = row\r\n          break\r\n        }\r\n        row++\r\n      }\r\n\r\n      this.validateRow(endRow)\r\n      if (!filledRegion) this.invalidateRow(endRow + 1)\r\n\r\n      this.emitter.emit('did-change-highlighting', Range(Point(startRow, 0), Point(endRow + 1, 0)))\r\n    }\r\n\r\n    if (this.firstInvalidRow() != null) {\r\n      this.tokenizeInBackground()\r\n    } else {\r\n      this.markTokenizationComplete()\r\n    }\r\n  }\r", "name": "stackForRow", "func_location": "TextMateLanguageMode.tokenizeNextChunk", "args": ["row", null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 294, "func_start_line": 282}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.openScopesForRow", "params": ["bufferRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 470, "start_line": 463}, "call_info": {"func_end_line": 319, "code": "  tokenizeNextChunk () {\r\n    let rowsRemaining = this.chunkSize\r\n\r\n    while (this.firstInvalidRow() != null && rowsRemaining > 0) {\r\n      var endRow, filledRegion\r\n      const startRow = this.invalidRows.shift()\r\n      const lastRow = this.buffer.getLastRow()\r\n      if (startRow > lastRow) continue\r\n\r\n      let row = startRow\r\n      while (true) {\r\n        const previousStack = this.stackForRow(row)\r\n        this.tokenizedLines[row] = this.buildTokenizedLineForRow(row, this.stackForRow(row - 1), this.openScopesForRow(row))\r\n        if (--rowsRemaining === 0) {\r\n          filledRegion = false\r\n          endRow = row\r\n          break\r\n        }\r\n        if (row === lastRow || _.isEqual(this.stackForRow(row), previousStack)) {\r\n          filledRegion = true\r\n          endRow = row\r\n          break\r\n        }\r\n        row++\r\n      }\r\n\r\n      this.validateRow(endRow)\r\n      if (!filledRegion) this.invalidateRow(endRow + 1)\r\n\r\n      this.emitter.emit('did-change-highlighting', Range(Point(startRow, 0), Point(endRow + 1, 0)))\r\n    }\r\n\r\n    if (this.firstInvalidRow() != null) {\r\n      this.tokenizeInBackground()\r\n    } else {\r\n      this.markTokenizationComplete()\r\n    }\r\n  }\r", "name": "openScopesForRow", "func_location": "TextMateLanguageMode.tokenizeNextChunk", "args": ["row", null, null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 294, "func_start_line": 282}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.stackForRow", "params": ["bufferRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 461, "start_line": 459}, "call_info": {"func_end_line": 319, "code": "  tokenizeNextChunk () {\r\n    let rowsRemaining = this.chunkSize\r\n\r\n    while (this.firstInvalidRow() != null && rowsRemaining > 0) {\r\n      var endRow, filledRegion\r\n      const startRow = this.invalidRows.shift()\r\n      const lastRow = this.buffer.getLastRow()\r\n      if (startRow > lastRow) continue\r\n\r\n      let row = startRow\r\n      while (true) {\r\n        const previousStack = this.stackForRow(row)\r\n        this.tokenizedLines[row] = this.buildTokenizedLineForRow(row, this.stackForRow(row - 1), this.openScopesForRow(row))\r\n        if (--rowsRemaining === 0) {\r\n          filledRegion = false\r\n          endRow = row\r\n          break\r\n        }\r\n        if (row === lastRow || _.isEqual(this.stackForRow(row), previousStack)) {\r\n          filledRegion = true\r\n          endRow = row\r\n          break\r\n        }\r\n        row++\r\n      }\r\n\r\n      this.validateRow(endRow)\r\n      if (!filledRegion) this.invalidateRow(endRow + 1)\r\n\r\n      this.emitter.emit('did-change-highlighting', Range(Point(startRow, 0), Point(endRow + 1, 0)))\r\n    }\r\n\r\n    if (this.firstInvalidRow() != null) {\r\n      this.tokenizeInBackground()\r\n    } else {\r\n      this.markTokenizationComplete()\r\n    }\r\n  }\r", "name": "stackForRow", "func_location": "TextMateLanguageMode.tokenizeNextChunk", "args": [null, "previousStack"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 300, "func_start_line": 282}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.validateRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 334, "start_line": 332}, "call_info": {"func_end_line": 319, "code": "  tokenizeNextChunk () {\r\n    let rowsRemaining = this.chunkSize\r\n\r\n    while (this.firstInvalidRow() != null && rowsRemaining > 0) {\r\n      var endRow, filledRegion\r\n      const startRow = this.invalidRows.shift()\r\n      const lastRow = this.buffer.getLastRow()\r\n      if (startRow > lastRow) continue\r\n\r\n      let row = startRow\r\n      while (true) {\r\n        const previousStack = this.stackForRow(row)\r\n        this.tokenizedLines[row] = this.buildTokenizedLineForRow(row, this.stackForRow(row - 1), this.openScopesForRow(row))\r\n        if (--rowsRemaining === 0) {\r\n          filledRegion = false\r\n          endRow = row\r\n          break\r\n        }\r\n        if (row === lastRow || _.isEqual(this.stackForRow(row), previousStack)) {\r\n          filledRegion = true\r\n          endRow = row\r\n          break\r\n        }\r\n        row++\r\n      }\r\n\r\n      this.validateRow(endRow)\r\n      if (!filledRegion) this.invalidateRow(endRow + 1)\r\n\r\n      this.emitter.emit('did-change-highlighting', Range(Point(startRow, 0), Point(endRow + 1, 0)))\r\n    }\r\n\r\n    if (this.firstInvalidRow() != null) {\r\n      this.tokenizeInBackground()\r\n    } else {\r\n      this.markTokenizationComplete()\r\n    }\r\n  }\r", "name": "validateRow", "func_location": "TextMateLanguageMode.tokenizeNextChunk", "args": ["endRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 308, "func_start_line": 282}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.invalidateRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 340, "start_line": 336}, "call_info": {"func_end_line": 319, "code": "  tokenizeNextChunk () {\r\n    let rowsRemaining = this.chunkSize\r\n\r\n    while (this.firstInvalidRow() != null && rowsRemaining > 0) {\r\n      var endRow, filledRegion\r\n      const startRow = this.invalidRows.shift()\r\n      const lastRow = this.buffer.getLastRow()\r\n      if (startRow > lastRow) continue\r\n\r\n      let row = startRow\r\n      while (true) {\r\n        const previousStack = this.stackForRow(row)\r\n        this.tokenizedLines[row] = this.buildTokenizedLineForRow(row, this.stackForRow(row - 1), this.openScopesForRow(row))\r\n        if (--rowsRemaining === 0) {\r\n          filledRegion = false\r\n          endRow = row\r\n          break\r\n        }\r\n        if (row === lastRow || _.isEqual(this.stackForRow(row), previousStack)) {\r\n          filledRegion = true\r\n          endRow = row\r\n          break\r\n        }\r\n        row++\r\n      }\r\n\r\n      this.validateRow(endRow)\r\n      if (!filledRegion) this.invalidateRow(endRow + 1)\r\n\r\n      this.emitter.emit('did-change-highlighting', Range(Point(startRow, 0), Point(endRow + 1, 0)))\r\n    }\r\n\r\n    if (this.firstInvalidRow() != null) {\r\n      this.tokenizeInBackground()\r\n    } else {\r\n      this.markTokenizationComplete()\r\n    }\r\n  }\r", "name": "invalidateRow", "func_location": "TextMateLanguageMode.tokenizeNextChunk", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 309, "func_start_line": 282}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.firstInvalidRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 330, "start_line": 328}, "call_info": {"func_end_line": 319, "code": "  tokenizeNextChunk () {\r\n    let rowsRemaining = this.chunkSize\r\n\r\n    while (this.firstInvalidRow() != null && rowsRemaining > 0) {\r\n      var endRow, filledRegion\r\n      const startRow = this.invalidRows.shift()\r\n      const lastRow = this.buffer.getLastRow()\r\n      if (startRow > lastRow) continue\r\n\r\n      let row = startRow\r\n      while (true) {\r\n        const previousStack = this.stackForRow(row)\r\n        this.tokenizedLines[row] = this.buildTokenizedLineForRow(row, this.stackForRow(row - 1), this.openScopesForRow(row))\r\n        if (--rowsRemaining === 0) {\r\n          filledRegion = false\r\n          endRow = row\r\n          break\r\n        }\r\n        if (row === lastRow || _.isEqual(this.stackForRow(row), previousStack)) {\r\n          filledRegion = true\r\n          endRow = row\r\n          break\r\n        }\r\n        row++\r\n      }\r\n\r\n      this.validateRow(endRow)\r\n      if (!filledRegion) this.invalidateRow(endRow + 1)\r\n\r\n      this.emitter.emit('did-change-highlighting', Range(Point(startRow, 0), Point(endRow + 1, 0)))\r\n    }\r\n\r\n    if (this.firstInvalidRow() != null) {\r\n      this.tokenizeInBackground()\r\n    } else {\r\n      this.markTokenizationComplete()\r\n    }\r\n  }\r", "name": "firstInvalidRow", "func_location": "TextMateLanguageMode.tokenizeNextChunk", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 314, "func_start_line": 282}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.tokenizeInBackground", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 280, "start_line": 272}, "call_info": {"func_end_line": 319, "code": "  tokenizeNextChunk () {\r\n    let rowsRemaining = this.chunkSize\r\n\r\n    while (this.firstInvalidRow() != null && rowsRemaining > 0) {\r\n      var endRow, filledRegion\r\n      const startRow = this.invalidRows.shift()\r\n      const lastRow = this.buffer.getLastRow()\r\n      if (startRow > lastRow) continue\r\n\r\n      let row = startRow\r\n      while (true) {\r\n        const previousStack = this.stackForRow(row)\r\n        this.tokenizedLines[row] = this.buildTokenizedLineForRow(row, this.stackForRow(row - 1), this.openScopesForRow(row))\r\n        if (--rowsRemaining === 0) {\r\n          filledRegion = false\r\n          endRow = row\r\n          break\r\n        }\r\n        if (row === lastRow || _.isEqual(this.stackForRow(row), previousStack)) {\r\n          filledRegion = true\r\n          endRow = row\r\n          break\r\n        }\r\n        row++\r\n      }\r\n\r\n      this.validateRow(endRow)\r\n      if (!filledRegion) this.invalidateRow(endRow + 1)\r\n\r\n      this.emitter.emit('did-change-highlighting', Range(Point(startRow, 0), Point(endRow + 1, 0)))\r\n    }\r\n\r\n    if (this.firstInvalidRow() != null) {\r\n      this.tokenizeInBackground()\r\n    } else {\r\n      this.markTokenizationComplete()\r\n    }\r\n  }\r", "name": "tokenizeInBackground", "func_location": "TextMateLanguageMode.tokenizeNextChunk", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 315, "func_start_line": 282}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.markTokenizationComplete", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 326, "start_line": 321}, "call_info": {"func_end_line": 319, "code": "  tokenizeNextChunk () {\r\n    let rowsRemaining = this.chunkSize\r\n\r\n    while (this.firstInvalidRow() != null && rowsRemaining > 0) {\r\n      var endRow, filledRegion\r\n      const startRow = this.invalidRows.shift()\r\n      const lastRow = this.buffer.getLastRow()\r\n      if (startRow > lastRow) continue\r\n\r\n      let row = startRow\r\n      while (true) {\r\n        const previousStack = this.stackForRow(row)\r\n        this.tokenizedLines[row] = this.buildTokenizedLineForRow(row, this.stackForRow(row - 1), this.openScopesForRow(row))\r\n        if (--rowsRemaining === 0) {\r\n          filledRegion = false\r\n          endRow = row\r\n          break\r\n        }\r\n        if (row === lastRow || _.isEqual(this.stackForRow(row), previousStack)) {\r\n          filledRegion = true\r\n          endRow = row\r\n          break\r\n        }\r\n        row++\r\n      }\r\n\r\n      this.validateRow(endRow)\r\n      if (!filledRegion) this.invalidateRow(endRow + 1)\r\n\r\n      this.emitter.emit('did-change-highlighting', Range(Point(startRow, 0), Point(endRow + 1, 0)))\r\n    }\r\n\r\n    if (this.firstInvalidRow() != null) {\r\n      this.tokenizeInBackground()\r\n    } else {\r\n      this.markTokenizationComplete()\r\n    }\r\n  }\r", "name": "markTokenizationComplete", "func_location": "TextMateLanguageMode.tokenizeNextChunk", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 317, "func_start_line": 282}}, {"func_info": {"comment": [], "name": "TextEditor.screenLineForScreenRow", "params": ["screenRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 1274, "start_line": 1272}, "call_info": {"func_end_line": 1270, "code": "  tokensForScreenRow (screenRow) {\r\n    const tokens = []\r\n    let lineTextIndex = 0\r\n    const currentTokenScopes = []\r\n    const {lineText, tags} = this.screenLineForScreenRow(screenRow)\r\n    for (const tag of tags) {\r\n      if (this.displayLayer.isOpenTag(tag)) {\r\n        currentTokenScopes.push(this.displayLayer.classNameForTag(tag))\r\n      } else if (this.displayLayer.isCloseTag(tag)) {\r\n        currentTokenScopes.pop()\r\n      } else {\r\n        tokens.push({\r\n          text: lineText.substr(lineTextIndex, tag),\r\n          scopes: currentTokenScopes.slice()\r\n        })\r\n        lineTextIndex += tag\r\n      }\r\n    }\r\n    return tokens\r\n  }\r", "name": "screenLineForScreenRow", "func_location": "TextEditor.tokensForScreenRow", "args": ["screenRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 1255, "func_start_line": 1251}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.tokenizedLineForRow", "params": ["bufferRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 449, "start_line": 425}, "call_info": {"func_end_line": 537, "code": "  tokenStartPositionForPosition (position) {\r\n    let {row, column} = Point.fromObject(position)\r\n    column = this.tokenizedLineForRow(row).tokenStartColumnForBufferColumn(column)\r\n    return new Point(row, column)\r\n  }\r", "name": "tokenizedLineForRow", "func_location": "TextMateLanguageMode.tokenStartPositionForPosition", "args": ["column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 535, "func_start_line": 533}}, {"func_info": {"comment": [], "name": "ScopeDescriptor.getScopeChain", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/scope-descriptor.js", "end_line": 62, "start_line": 47}, "call_info": {"func_end_line": 66, "code": "  toString () {\r\n    return this.getScopeChain()\r\n  }\r", "name": "getScopeChain", "func_location": "ScopeDescriptor.toString", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/scope-descriptor.js", "line": 65, "func_start_line": 64}}, {"func_info": {"comment": [" Essential: Returns a {String} in the form `'rgba(25, 50, 75, .9)'`."], "name": "Color.toRGBAString", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js", "end_line": 85, "start_line": 83}, "call_info": {"func_end_line": 93, "code": "  toString () {\r\n    return this.toRGBAString()\r\n  }\r", "name": "toRGBAString", "func_location": "Color.toString", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/color.js", "line": 92, "func_start_line": 91}}, {"func_info": {"comment": [], "name": "WindowStack.addWindow", "params": ["window"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 1402, "start_line": 1399}, "call_info": {"func_end_line": 1406, "code": "  touch (window) {\r\n    return this.addWindow(window)\r\n  }\r", "name": "addWindow", "func_location": "WindowStack.touch", "args": ["window"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 1405, "func_start_line": 1404}}, {"func_info": {"comment": [], "name": "Config.beginTransaction", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 864, "start_line": 862}, "call_info": {"func_end_line": 823, "comment": [" Extended: Suppress calls to handler functions registered with {::onDidChange}", " and {::observe} for the duration of `callback`. After `callback` executes,", " handlers will be called once if the value for their key-path has changed.", "", " * `callback` {Function} to execute while suppressing calls to handlers."], "code": "  transact (callback) {\r\n    this.beginTransaction()\r\n    try {\r\n      return callback()\r\n    } finally {\r\n      this.endTransaction()\r\n    }\r\n  }\r", "name": "beginTransaction", "func_location": "Config.transact", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 817, "func_start_line": 816}}, {"func_info": {"comment": [], "name": "Config.endTransaction", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 869, "start_line": 866}, "call_info": {"func_end_line": 823, "comment": [" Extended: Suppress calls to handler functions registered with {::onDidChange}", " and {::observe} for the duration of `callback`. After `callback` executes,", " handlers will be called once if the value for their key-path has changed.", "", " * `callback` {Function} to execute while suppressing calls to handlers."], "code": "  transact (callback) {\r\n    this.beginTransaction()\r\n    try {\r\n      return callback()\r\n    } finally {\r\n      this.endTransaction()\r\n    }\r\n  }\r", "name": "endTransaction", "func_location": "Config.transact", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 821, "func_start_line": 816}}, {"func_info": {"comment": [], "name": "Config.beginTransaction", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 864, "start_line": 862}, "call_info": {"func_end_line": 860, "comment": ["\r\n  Section: Internal methods used by core\r\n  ", " Private: Suppress calls to handler functions registered with {::onDidChange}", " and {::observe} for the duration of the {Promise} returned by `callback`.", " After the {Promise} is either resolved or rejected, handlers will be called", " once if the value for their key-path has changed.", "", " * `callback` {Function} that returns a {Promise}, which will be executed", "   while suppressing calls to handlers.", "", " Returns a {Promise} that is either resolved or rejected according to the", " `{Promise}` returned by `callback`. If `callback` throws an error, a", " rejected {Promise} will be returned instead."], "code": "  transactAsync (callback) {\r\n    let endTransaction\r\n    this.beginTransaction()\r\n    try {\r\n      endTransaction = fn => (...args) => {\r\n        this.endTransaction()\r\n        return fn(...args)\r\n      }\r\n      const result = callback()\r\n      return new Promise((resolve, reject) => {\r\n        return result.then(endTransaction(resolve)).catch(endTransaction(reject))\r\n      })\r\n    } catch (error) {\r\n      this.endTransaction()\r\n      return Promise.reject(error)\r\n    }\r\n  }\r", "name": "beginTransaction", "func_location": "Config.transactAsync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 846, "func_start_line": 844}}, {"func_info": {"comment": [], "name": "Config.endTransaction", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 869, "start_line": 866}, "call_info": {"func_end_line": 860, "comment": ["\r\n  Section: Internal methods used by core\r\n  ", " Private: Suppress calls to handler functions registered with {::onDidChange}", " and {::observe} for the duration of the {Promise} returned by `callback`.", " After the {Promise} is either resolved or rejected, handlers will be called", " once if the value for their key-path has changed.", "", " * `callback` {Function} that returns a {Promise}, which will be executed", "   while suppressing calls to handlers.", "", " Returns a {Promise} that is either resolved or rejected according to the", " `{Promise}` returned by `callback`. If `callback` throws an error, a", " rejected {Promise} will be returned instead."], "code": "  transactAsync (callback) {\r\n    let endTransaction\r\n    this.beginTransaction()\r\n    try {\r\n      endTransaction = fn => (...args) => {\r\n        this.endTransaction()\r\n        return fn(...args)\r\n      }\r\n      const result = callback()\r\n      return new Promise((resolve, reject) => {\r\n        return result.then(endTransaction(resolve)).catch(endTransaction(reject))\r\n      })\r\n    } catch (error) {\r\n      this.endTransaction()\r\n      return Promise.reject(error)\r\n    }\r\n  }\r", "name": "endTransaction", "func_location": "Config.transactAsync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 857, "func_start_line": 844}}, {"func_info": {"comment": [], "name": "PackageTranspilationRegistry.getTranspiler", "params": ["spec"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js", "end_line": 175, "start_line": 168}, "call_info": {"func_end_line": 150, "code": "  transpileWithPackageTranspiler (sourceCode, filePath, spec) {\r\n    const transpiler = this.getTranspiler(spec)\r\n\r\n    if (transpiler) {\r\n      const meta = this.getMetadata(spec)\r\n      const result = transpiler.transpile(sourceCode, filePath, spec.options || {}, meta)\r\n      if (result === undefined || (result && result.code === undefined)) {\r\n        return sourceCode\r\n      } else if (result.code) {\r\n        return result.code.toString()\r\n      } else {\r\n        throw new Error('Could not find a property `.code` on the transpilation results of ' + filePath)\r\n      }\r\n    } else {\r\n      const err = new Error(\"Could not resolve transpiler '\" + spec.transpiler + \"' from '\" + spec._config.path + \"'\")\r\n      throw err\r\n    }\r\n  }\r", "name": "getTranspiler", "func_location": "PackageTranspilationRegistry.transpileWithPackageTranspiler", "args": ["spec"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js", "line": 134, "func_start_line": 133}}, {"func_info": {"comment": [], "name": "PackageTranspilationRegistry.getMetadata", "params": ["spec"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js", "end_line": 158, "start_line": 152}, "call_info": {"func_end_line": 150, "code": "  transpileWithPackageTranspiler (sourceCode, filePath, spec) {\r\n    const transpiler = this.getTranspiler(spec)\r\n\r\n    if (transpiler) {\r\n      const meta = this.getMetadata(spec)\r\n      const result = transpiler.transpile(sourceCode, filePath, spec.options || {}, meta)\r\n      if (result === undefined || (result && result.code === undefined)) {\r\n        return sourceCode\r\n      } else if (result.code) {\r\n        return result.code.toString()\r\n      } else {\r\n        throw new Error('Could not find a property `.code` on the transpilation results of ' + filePath)\r\n      }\r\n    } else {\r\n      const err = new Error(\"Could not resolve transpiler '\" + spec.transpiler + \"' from '\" + spec._config.path + \"'\")\r\n      throw err\r\n    }\r\n  }\r", "name": "getMetadata", "func_location": "PackageTranspilationRegistry.transpileWithPackageTranspiler", "args": ["spec"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-transpilation-registry.js", "line": 137, "func_start_line": 133}}, {"func_info": {"comment": [], "name": "NativeCompileCache.restorePreviousModuleCompile", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/native-compile-cache.js", "end_line": 93, "start_line": 91}, "call_info": {"func_end_line": 31, "code": "  uninstall () {\r\n    this.restorePreviousModuleCompile()\r\n  }\r", "name": "restorePreviousModuleCompile", "func_location": "NativeCompileCache.uninstall", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/native-compile-cache.js", "line": 30, "func_start_line": 29}}, {"func_info": {"comment": [], "name": "Package.unregisterTranspilerConfig", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "end_line": 436, "start_line": 432}, "call_info": {"func_end_line": 148, "code": "  unload () {\r\n    this.unregisterTranspilerConfig()\r\n  }\r", "name": "unregisterTranspilerConfig", "func_location": "Package.unload", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package.js", "line": 147, "func_start_line": 146}}, {"func_info": {"comment": [], "name": "AtomEnvironment.storeWindowBackground", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 770, "start_line": 765}, "call_info": {"func_end_line": 906, "code": "  unloadEditorWindow () {\r\n    if (!this.project) return\r\n\r\n    this.storeWindowBackground()\r\n    this.saveBlobStoreSync()\r\n  }\r", "name": "storeWindowBackground", "func_location": "AtomEnvironment.unloadEditorWindow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 904, "func_start_line": 901}}, {"func_info": {"comment": [], "name": "AtomEnvironment.saveBlobStoreSync", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 912, "start_line": 908}, "call_info": {"func_end_line": 906, "code": "  unloadEditorWindow () {\r\n    if (!this.project) return\r\n\r\n    this.storeWindowBackground()\r\n    this.saveBlobStoreSync()\r\n  }\r", "name": "saveBlobStoreSync", "func_location": "AtomEnvironment.unloadEditorWindow", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 905, "func_start_line": 901}}, {"func_info": {"comment": [" Public: Is the {Package} with the given name active?", "", " * `name` - The {String} package name.", "", " Returns a {Boolean}."], "name": "PackageManager.isPackageActive", "params": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 311, "start_line": 309}, "call_info": {"func_end_line": 653, "code": "  unloadPackage (name) {\r\n    if (this.isPackageActive(name)) {\r\n      throw new Error(`Tried to unload active package '${name}'`)\r\n    }\r\n\r\n    const pack = this.getLoadedPackage(name)\r\n    if (pack) {\r\n      delete this.loadedPackages[pack.name]\r\n      this.emitter.emit('did-unload-package', pack)\r\n    } else {\r\n      throw new Error(`No loaded package for name '${name}'`)\r\n    }\r\n  }\r", "name": "isPackageActive", "func_location": "PackageManager.unloadPackage", "args": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 642, "func_start_line": 641}}, {"func_info": {"comment": [" Public: Get the loaded {Package} with the given name.", "", " * `name` - The {String} package name.", "", " Returns a {Package} or undefined."], "name": "PackageManager.getLoadedPackage", "params": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "end_line": 341, "start_line": 339}, "call_info": {"func_end_line": 653, "code": "  unloadPackage (name) {\r\n    if (this.isPackageActive(name)) {\r\n      throw new Error(`Tried to unload active package '${name}'`)\r\n    }\r\n\r\n    const pack = this.getLoadedPackage(name)\r\n    if (pack) {\r\n      delete this.loadedPackages[pack.name]\r\n      this.emitter.emit('did-unload-package', pack)\r\n    } else {\r\n      throw new Error(`No loaded package for name '${name}'`)\r\n    }\r\n  }\r", "name": "getLoadedPackage", "func_location": "PackageManager.unloadPackage", "args": ["name"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/package-manager.js", "line": 646, "func_start_line": 641}}, {"func_info": {"comment": [], "name": "findMatchingItemIndex", "params": ["menu", ["type", "label", "submenu"]], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js", "end_line": 66, "start_line": 52}, "call_info": {"func_end_line": 50, "code": "function unmerge (menu, item) {\r\n  const matchingItemIndex = findMatchingItemIndex(menu, item)\r\n  if (matchingItemIndex === -1) {\r\n    return\r\n  }\r\n\r\n  const matchingItem = menu[matchingItemIndex]\r\n  if (item.submenu != null) {\r\n    for (let submenuItem of item.submenu) {\r\n      unmerge(matchingItem.submenu, submenuItem)\r\n    }\r\n  }\r\n\r\n  if (matchingItem.submenu == null || matchingItem.submenu.length === 0) {\r\n    menu.splice(matchingItemIndex, 1)\r\n  }\r\n}\r", "name": "findMatchingItemIndex", "func_location": "unmerge", "args": ["menu", "item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js", "line": 35, "func_start_line": 34}}, {"func_info": {"comment": [], "name": "unmerge", "params": ["menu", "item"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js", "end_line": 50, "start_line": 34}, "call_info": {"func_end_line": 50, "code": "function unmerge (menu, item) {\r\n  const matchingItemIndex = findMatchingItemIndex(menu, item)\r\n  if (matchingItemIndex === -1) {\r\n    return\r\n  }\r\n\r\n  const matchingItem = menu[matchingItemIndex]\r\n  if (item.submenu != null) {\r\n    for (let submenuItem of item.submenu) {\r\n      unmerge(matchingItem.submenu, submenuItem)\r\n    }\r\n  }\r\n\r\n  if (matchingItem.submenu == null || matchingItem.submenu.length === 0) {\r\n    menu.splice(matchingItemIndex, 1)\r\n  }\r\n}\r", "name": "unmerge", "func_location": "unmerge", "args": ["matchingItem.submenu", "submenuItem"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/menu-helpers.js", "line": 43, "func_start_line": 34}}, {"func_info": {"comment": [" Essential: Sets the value for a configuration setting.", "", " This value is stored in Atom's internal configuration file.", "", " ### Examples", "", " You might want to change the themes programmatically:", "", " ```coffee", " atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])", " ```", "", " You can also set scoped settings. For example, you might want change the", " `editor.tabLength` only for ruby files.", "", " ```coffee", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4", " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4", "", " # Set ruby to 2", " atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true", "", " # Notice it's only set to 2 in the case of ruby", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4", " ```", "", " * `keyPath` The {String} name of the key.", " * `value` The value of the setting. Passing `undefined` will revert the", "   setting to the default value.", " * `options` (optional) {Object}", "   * `scopeSelector` (optional) {String}. eg. '.source.ruby'", "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)", "     for more information.", "   * `source` (optional) {String} The name of a file with which the setting", "     is associated. Defaults to the user's config file.", "", " Returns a {Boolean}", " * `true` if the value was set.", " * `false` if the value was not able to be coerced to the type specified in the setting's schema."], "name": "Config.set", "params": ["args"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 722, "start_line": 687}, "call_info": {"func_end_line": 766, "comment": [" Essential: Restore the setting at `keyPath` to its default value.", "", " * `keyPath` The {String} name of the key.", " * `options` (optional) {Object}", "   * `scopeSelector` (optional) {String}. See {::set}", "   * `source` (optional) {String}. See {::set}"], "code": "  unset (keyPath, options) {\r\n    if (!this.settingsLoaded) {\r\n      this.pendingOperations.push(() => this.unset(keyPath, options))\r\n    }\r\n\r\n    let {scopeSelector, source} = options != null ? options : {}\r\n    if (source == null) { source = this.mainSource }\r\n\r\n    if (scopeSelector != null) {\r\n      if (keyPath != null) {\r\n        let settings = this.scopedSettingsStore.propertiesForSourceAndSelector(source, scopeSelector)\r\n        if (getValueAtKeyPath(settings, keyPath) != null) {\r\n          this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n          setValueAtKeyPath(settings, keyPath, undefined)\r\n          settings = withoutEmptyObjects(settings)\r\n          if (settings != null) {\r\n            this.set(null, settings, {scopeSelector, source, priority: this.priorityForSource(source)})\r\n          }\r\n\r\n          const configIsReady = (source === this.mainSource) && this.settingsLoaded\r\n          if (configIsReady) {\r\n            return this.requestSave()\r\n          }\r\n        }\r\n      } else {\r\n        this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n        return this.emitChangeEvent()\r\n      }\r\n    } else {\r\n      for (scopeSelector in this.scopedSettingsStore.propertiesForSource(source)) {\r\n        this.unset(keyPath, {scopeSelector, source})\r\n      }\r\n      if ((keyPath != null) && (source === this.mainSource)) {\r\n        return this.set(keyPath, getValueAtKeyPath(this.defaultSettings, keyPath))\r\n      }\r\n    }\r\n  }\r", "name": "set", "func_location": "Config.unset", "args": [{"type": "object"}, "settings", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 746, "func_start_line": 730}}, {"func_info": {"comment": ["\r\n  Section: Private Scoped Settings\r\n  "], "name": "Config.priorityForSource", "params": ["source"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1209, "start_line": 1200}, "call_info": {"func_end_line": 766, "comment": [" Essential: Restore the setting at `keyPath` to its default value.", "", " * `keyPath` The {String} name of the key.", " * `options` (optional) {Object}", "   * `scopeSelector` (optional) {String}. See {::set}", "   * `source` (optional) {String}. See {::set}"], "code": "  unset (keyPath, options) {\r\n    if (!this.settingsLoaded) {\r\n      this.pendingOperations.push(() => this.unset(keyPath, options))\r\n    }\r\n\r\n    let {scopeSelector, source} = options != null ? options : {}\r\n    if (source == null) { source = this.mainSource }\r\n\r\n    if (scopeSelector != null) {\r\n      if (keyPath != null) {\r\n        let settings = this.scopedSettingsStore.propertiesForSourceAndSelector(source, scopeSelector)\r\n        if (getValueAtKeyPath(settings, keyPath) != null) {\r\n          this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n          setValueAtKeyPath(settings, keyPath, undefined)\r\n          settings = withoutEmptyObjects(settings)\r\n          if (settings != null) {\r\n            this.set(null, settings, {scopeSelector, source, priority: this.priorityForSource(source)})\r\n          }\r\n\r\n          const configIsReady = (source === this.mainSource) && this.settingsLoaded\r\n          if (configIsReady) {\r\n            return this.requestSave()\r\n          }\r\n        }\r\n      } else {\r\n        this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n        return this.emitChangeEvent()\r\n      }\r\n    } else {\r\n      for (scopeSelector in this.scopedSettingsStore.propertiesForSource(source)) {\r\n        this.unset(keyPath, {scopeSelector, source})\r\n      }\r\n      if ((keyPath != null) && (source === this.mainSource)) {\r\n        return this.set(keyPath, getValueAtKeyPath(this.defaultSettings, keyPath))\r\n      }\r\n    }\r\n  }\r", "name": "priorityForSource", "func_location": "Config.unset", "args": [{"type": "object"}, "settings", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 746, "func_start_line": 730}}, {"func_info": {"comment": [], "name": "Config.emitChangeEvent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 1213, "start_line": 1211}, "call_info": {"func_end_line": 766, "comment": [" Essential: Restore the setting at `keyPath` to its default value.", "", " * `keyPath` The {String} name of the key.", " * `options` (optional) {Object}", "   * `scopeSelector` (optional) {String}. See {::set}", "   * `source` (optional) {String}. See {::set}"], "code": "  unset (keyPath, options) {\r\n    if (!this.settingsLoaded) {\r\n      this.pendingOperations.push(() => this.unset(keyPath, options))\r\n    }\r\n\r\n    let {scopeSelector, source} = options != null ? options : {}\r\n    if (source == null) { source = this.mainSource }\r\n\r\n    if (scopeSelector != null) {\r\n      if (keyPath != null) {\r\n        let settings = this.scopedSettingsStore.propertiesForSourceAndSelector(source, scopeSelector)\r\n        if (getValueAtKeyPath(settings, keyPath) != null) {\r\n          this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n          setValueAtKeyPath(settings, keyPath, undefined)\r\n          settings = withoutEmptyObjects(settings)\r\n          if (settings != null) {\r\n            this.set(null, settings, {scopeSelector, source, priority: this.priorityForSource(source)})\r\n          }\r\n\r\n          const configIsReady = (source === this.mainSource) && this.settingsLoaded\r\n          if (configIsReady) {\r\n            return this.requestSave()\r\n          }\r\n        }\r\n      } else {\r\n        this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n        return this.emitChangeEvent()\r\n      }\r\n    } else {\r\n      for (scopeSelector in this.scopedSettingsStore.propertiesForSource(source)) {\r\n        this.unset(keyPath, {scopeSelector, source})\r\n      }\r\n      if ((keyPath != null) && (source === this.mainSource)) {\r\n        return this.set(keyPath, getValueAtKeyPath(this.defaultSettings, keyPath))\r\n      }\r\n    }\r\n  }\r", "name": "emitChangeEvent", "func_location": "Config.unset", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 756, "func_start_line": 730}}, {"func_info": {"comment": [" Essential: Restore the setting at `keyPath` to its default value.", "", " * `keyPath` The {String} name of the key.", " * `options` (optional) {Object}", "   * `scopeSelector` (optional) {String}. See {::set}", "   * `source` (optional) {String}. See {::set}"], "name": "Config.unset", "params": ["keyPath", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 766, "start_line": 730}, "call_info": {"func_end_line": 766, "comment": [" Essential: Restore the setting at `keyPath` to its default value.", "", " * `keyPath` The {String} name of the key.", " * `options` (optional) {Object}", "   * `scopeSelector` (optional) {String}. See {::set}", "   * `source` (optional) {String}. See {::set}"], "code": "  unset (keyPath, options) {\r\n    if (!this.settingsLoaded) {\r\n      this.pendingOperations.push(() => this.unset(keyPath, options))\r\n    }\r\n\r\n    let {scopeSelector, source} = options != null ? options : {}\r\n    if (source == null) { source = this.mainSource }\r\n\r\n    if (scopeSelector != null) {\r\n      if (keyPath != null) {\r\n        let settings = this.scopedSettingsStore.propertiesForSourceAndSelector(source, scopeSelector)\r\n        if (getValueAtKeyPath(settings, keyPath) != null) {\r\n          this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n          setValueAtKeyPath(settings, keyPath, undefined)\r\n          settings = withoutEmptyObjects(settings)\r\n          if (settings != null) {\r\n            this.set(null, settings, {scopeSelector, source, priority: this.priorityForSource(source)})\r\n          }\r\n\r\n          const configIsReady = (source === this.mainSource) && this.settingsLoaded\r\n          if (configIsReady) {\r\n            return this.requestSave()\r\n          }\r\n        }\r\n      } else {\r\n        this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n        return this.emitChangeEvent()\r\n      }\r\n    } else {\r\n      for (scopeSelector in this.scopedSettingsStore.propertiesForSource(source)) {\r\n        this.unset(keyPath, {scopeSelector, source})\r\n      }\r\n      if ((keyPath != null) && (source === this.mainSource)) {\r\n        return this.set(keyPath, getValueAtKeyPath(this.defaultSettings, keyPath))\r\n      }\r\n    }\r\n  }\r", "name": "unset", "func_location": "Config.unset", "args": ["keyPath", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 760, "func_start_line": 730}}, {"func_info": {"comment": [" Essential: Sets the value for a configuration setting.", "", " This value is stored in Atom's internal configuration file.", "", " ### Examples", "", " You might want to change the themes programmatically:", "", " ```coffee", " atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])", " ```", "", " You can also set scoped settings. For example, you might want change the", " `editor.tabLength` only for ruby files.", "", " ```coffee", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4", " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4", "", " # Set ruby to 2", " atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true", "", " # Notice it's only set to 2 in the case of ruby", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4", " ```", "", " * `keyPath` The {String} name of the key.", " * `value` The value of the setting. Passing `undefined` will revert the", "   setting to the default value.", " * `options` (optional) {Object}", "   * `scopeSelector` (optional) {String}. eg. '.source.ruby'", "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)", "     for more information.", "   * `source` (optional) {String} The name of a file with which the setting", "     is associated. Defaults to the user's config file.", "", " Returns a {Boolean}", " * `true` if the value was set.", " * `false` if the value was not able to be coerced to the type specified in the setting's schema."], "name": "Config.set", "params": ["args"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 722, "start_line": 687}, "call_info": {"func_end_line": 766, "comment": [" Essential: Restore the setting at `keyPath` to its default value.", "", " * `keyPath` The {String} name of the key.", " * `options` (optional) {Object}", "   * `scopeSelector` (optional) {String}. See {::set}", "   * `source` (optional) {String}. See {::set}"], "code": "  unset (keyPath, options) {\r\n    if (!this.settingsLoaded) {\r\n      this.pendingOperations.push(() => this.unset(keyPath, options))\r\n    }\r\n\r\n    let {scopeSelector, source} = options != null ? options : {}\r\n    if (source == null) { source = this.mainSource }\r\n\r\n    if (scopeSelector != null) {\r\n      if (keyPath != null) {\r\n        let settings = this.scopedSettingsStore.propertiesForSourceAndSelector(source, scopeSelector)\r\n        if (getValueAtKeyPath(settings, keyPath) != null) {\r\n          this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n          setValueAtKeyPath(settings, keyPath, undefined)\r\n          settings = withoutEmptyObjects(settings)\r\n          if (settings != null) {\r\n            this.set(null, settings, {scopeSelector, source, priority: this.priorityForSource(source)})\r\n          }\r\n\r\n          const configIsReady = (source === this.mainSource) && this.settingsLoaded\r\n          if (configIsReady) {\r\n            return this.requestSave()\r\n          }\r\n        }\r\n      } else {\r\n        this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n        return this.emitChangeEvent()\r\n      }\r\n    } else {\r\n      for (scopeSelector in this.scopedSettingsStore.propertiesForSource(source)) {\r\n        this.unset(keyPath, {scopeSelector, source})\r\n      }\r\n      if ((keyPath != null) && (source === this.mainSource)) {\r\n        return this.set(keyPath, getValueAtKeyPath(this.defaultSettings, keyPath))\r\n      }\r\n    }\r\n  }\r", "name": "set", "func_location": "Config.unset", "args": ["keyPath", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 763, "func_start_line": 730}}, {"func_info": {"comment": ["\r\n  Section: Managing Settings\r\n  ", " Essential: Retrieves the setting for the given key.", "", " ### Examples", "", " You might want to know what themes are enabled, so check `core.themes`", "", " ```coffee", " atom.config.get('core.themes')", " ```", "", " With scope descriptors you can get settings within a specific editor", " scope. For example, you might want to know `editor.tabLength` for ruby", " files.", "", " ```coffee", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " ```", "", " This setting in ruby files might be different than the global tabLength setting", "", " ```coffee", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " ```", "", " You can get the language scope descriptor via", " {TextEditor::getRootScopeDescriptor}. This will get the setting specifically", " for the editor's language.", "", " ```coffee", " atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2", " ```", "", " Additionally, you can get the setting at the specific cursor position.", "", " ```coffee", " scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()", " atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2", " ```", "", " * `keyPath` The {String} name of the key to retrieve.", " * `options` (optional) {Object}", "   * `sources` (optional) {Array} of {String} source names. If provided, only", "     values that were associated with these sources during {::set} will be used.", "   * `excludeSources` (optional) {Array} of {String} source names. If provided,", "     values that  were associated with these sources during {::set} will not", "     be used.", "   * `scope` (optional) {ScopeDescriptor} describing a path from", "     the root of the syntax tree to a token. Get one by calling", "     {editor.getLastCursor().getScopeDescriptor()}", "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)", "     for more information.", "", " Returns the value from Atom's default settings, the user's configuration", " file in the type specified by the configuration schema."], "name": "Config.get", "params": ["args"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 602, "start_line": 585}, "call_info": {"func_end_line": 885, "code": "  unshiftAtKeyPath (keyPath, value) {\r\n    const left = this.get(keyPath)\r\n    const arrayValue = (left == null ? [] : left)\r\n    const result = arrayValue.unshift(value)\r\n    this.set(keyPath, arrayValue)\r\n    return result\r\n  }\r", "name": "get", "func_location": "Config.unshiftAtKeyPath", "args": ["keyPath"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 880, "func_start_line": 879}}, {"func_info": {"comment": [" Essential: Sets the value for a configuration setting.", "", " This value is stored in Atom's internal configuration file.", "", " ### Examples", "", " You might want to change the themes programmatically:", "", " ```coffee", " atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])", " ```", "", " You can also set scoped settings. For example, you might want change the", " `editor.tabLength` only for ruby files.", "", " ```coffee", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4", " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4", "", " # Set ruby to 2", " atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true", "", " # Notice it's only set to 2 in the case of ruby", " atom.config.get('editor.tabLength') # => 4", " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2", " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4", " ```", "", " * `keyPath` The {String} name of the key.", " * `value` The value of the setting. Passing `undefined` will revert the", "   setting to the default value.", " * `options` (optional) {Object}", "   * `scopeSelector` (optional) {String}. eg. '.source.ruby'", "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)", "     for more information.", "   * `source` (optional) {String} The name of a file with which the setting", "     is associated. Defaults to the user's config file.", "", " Returns a {Boolean}", " * `true` if the value was set.", " * `false` if the value was not able to be coerced to the type specified in the setting's schema."], "name": "Config.set", "params": ["args"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "end_line": 722, "start_line": 687}, "call_info": {"func_end_line": 885, "code": "  unshiftAtKeyPath (keyPath, value) {\r\n    const left = this.get(keyPath)\r\n    const arrayValue = (left == null ? [] : left)\r\n    const result = arrayValue.unshift(value)\r\n    this.set(keyPath, arrayValue)\r\n    return result\r\n  }\r", "name": "set", "func_location": "Config.unshiftAtKeyPath", "args": ["keyPath", "arrayValue"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config.js", "line": 883, "func_start_line": 879}}, {"func_info": {"comment": [], "name": "TextEditor.decorateCursorLine", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "end_line": 305, "start_line": 299}, "call_info": {"func_end_line": 539, "code": "  update (params) {\r\n    const displayLayerParams = {}\r\n\r\n    for (let param of Object.keys(params)) {\r\n      const value = params[param]\r\n\r\n      switch (param) {\r\n        case 'autoIndent':\r\n          this.autoIndent = value\r\n          break\r\n\r\n        case 'autoIndentOnPaste':\r\n          this.autoIndentOnPaste = value\r\n          break\r\n\r\n        case 'undoGroupingInterval':\r\n          this.undoGroupingInterval = value\r\n          break\r\n\r\n        case 'scrollSensitivity':\r\n          this.scrollSensitivity = value\r\n          break\r\n\r\n        case 'encoding':\r\n          this.buffer.setEncoding(value)\r\n          break\r\n\r\n        case 'softTabs':\r\n          if (value !== this.softTabs) {\r\n            this.softTabs = value\r\n          }\r\n          break\r\n\r\n        case 'atomicSoftTabs':\r\n          if (value !== this.displayLayer.atomicSoftTabs) {\r\n            displayLayerParams.atomicSoftTabs = value\r\n          }\r\n          break\r\n\r\n        case 'tabLength':\r\n          if (value > 0 && value !== this.displayLayer.tabLength) {\r\n            displayLayerParams.tabLength = value\r\n          }\r\n          break\r\n\r\n        case 'softWrapped':\r\n          if (value !== this.softWrapped) {\r\n            this.softWrapped = value\r\n            displayLayerParams.softWrapColumn = this.getSoftWrapColumn()\r\n            this.emitter.emit('did-change-soft-wrapped', this.isSoftWrapped())\r\n          }\r\n          break\r\n\r\n        case 'softWrapHangingIndentLength':\r\n          if (value !== this.displayLayer.softWrapHangingIndent) {\r\n            displayLayerParams.softWrapHangingIndent = value\r\n          }\r\n          break\r\n\r\n        case 'softWrapAtPreferredLineLength':\r\n          if (value !== this.softWrapAtPreferredLineLength) {\r\n            this.softWrapAtPreferredLineLength = value\r\n            displayLayerParams.softWrapColumn = this.getSoftWrapColumn()\r\n          }\r\n          break\r\n\r\n        case 'preferredLineLength':\r\n          if (value !== this.preferredLineLength) {\r\n            this.preferredLineLength = value\r\n            displayLayerParams.softWrapColumn = this.getSoftWrapColumn()\r\n          }\r\n          break\r\n\r\n        case 'maxScreenLineLength':\r\n          if (value !== this.maxScreenLineLength) {\r\n            this.maxScreenLineLength = value\r\n            displayLayerParams.softWrapColumn = this.getSoftWrapColumn()\r\n          }\r\n          break\r\n\r\n        case 'mini':\r\n          if (value !== this.mini) {\r\n            this.mini = value\r\n            this.emitter.emit('did-change-mini', value)\r\n            displayLayerParams.invisibles = this.getInvisibles()\r\n            displayLayerParams.softWrapColumn = this.getSoftWrapColumn()\r\n            displayLayerParams.showIndentGuides = this.doesShowIndentGuide()\r\n            if (this.mini) {\r\n              for (let decoration of this.cursorLineDecorations) { decoration.destroy() }\r\n              this.cursorLineDecorations = null\r\n            } else {\r\n              this.decorateCursorLine()\r\n            }\r\n            if (this.component != null) {\r\n              this.component.scheduleUpdate()\r\n            }\r\n          }\r\n          break\r\n\r\n        case 'readOnly':\r\n          if (value !== this.readOnly) {\r\n            this.readOnly = value\r\n            if (this.component != null) {\r\n              this.component.scheduleUpdate()\r\n            }\r\n          }\r\n          break\r\n\r\n        case 'keyboardInputEnabled':\r\n          if (value !== this.keyboardInputEnabled) {\r\n            this.keyboardInputEnabled = value\r\n            if (this.component != null) {\r\n              this.component.scheduleUpdate()\r\n            }\r\n          }\r\n          break\r\n\r\n        case 'placeholderText':\r\n          if (value !== this.placeholderText) {\r\n            this.placeholderText = value\r\n            this.emitter.emit('did-change-placeholder-text', value)\r\n          }\r\n          break\r\n\r\n        case 'lineNumberGutterVisible':\r\n          if (value !== this.lineNumberGutterVisible) {\r\n            if (value) {\r\n              this.lineNumberGutter.show()\r\n            } else {\r\n              this.lineNumberGutter.hide()\r\n            }\r\n            this.emitter.emit('did-change-line-number-gutter-visible', this.lineNumberGutter.isVisible())\r\n          }\r\n          break\r\n\r\n        case 'showIndentGuide':\r\n          if (value !== this.showIndentGuide) {\r\n            this.showIndentGuide = value\r\n            displayLayerParams.showIndentGuides = this.doesShowIndentGuide()\r\n          }\r\n          break\r\n\r\n        case 'showLineNumbers':\r\n          if (value !== this.showLineNumbers) {\r\n            this.showLineNumbers = value\r\n            if (this.component != null) {\r\n              this.component.scheduleUpdate()\r\n            }\r\n          }\r\n          break\r\n\r\n        case 'showInvisibles':\r\n          if (value !== this.showInvisibles) {\r\n            this.showInvisibles = value\r\n            displayLayerParams.invisibles = this.getInvisibles()\r\n          }\r\n          break\r\n\r\n        case 'invisibles':\r\n          if (!_.isEqual(value, this.invisibles)) {\r\n            this.invisibles = value\r\n            displayLayerParams.invisibles = this.getInvisibles()\r\n          }\r\n          break\r\n\r\n        case 'editorWidthInChars':\r\n          if (value > 0 && value !== this.editorWidthInChars) {\r\n            this.editorWidthInChars = value\r\n            displayLayerParams.softWrapColumn = this.getSoftWrapColumn()\r\n          }\r\n          break\r\n\r\n        case 'width':\r\n          if (value !== this.width) {\r\n            this.width = value\r\n            displayLayerParams.softWrapColumn = this.getSoftWrapColumn()\r\n          }\r\n          break\r\n\r\n        case 'scrollPastEnd':\r\n          if (value !== this.scrollPastEnd) {\r\n            this.scrollPastEnd = value\r\n            if (this.component) this.component.scheduleUpdate()\r\n          }\r\n          break\r\n\r\n        case 'autoHeight':\r\n          if (value !== this.autoHeight) {\r\n            this.autoHeight = value\r\n          }\r\n          break\r\n\r\n        case 'autoWidth':\r\n          if (value !== this.autoWidth) {\r\n            this.autoWidth = value\r\n          }\r\n          break\r\n\r\n        case 'showCursorOnSelection':\r\n          if (value !== this.showCursorOnSelection) {\r\n            this.showCursorOnSelection = value\r\n            if (this.component) this.component.scheduleUpdate()\r\n          }\r\n          break\r\n\r\n        default:\r\n          if (param !== 'ref' && param !== 'key') {\r\n            throw new TypeError(`Invalid TextEditor parameter: '${param}'`)\r\n          }\r\n      }\r\n    }\r\n\r\n    this.displayLayer.reset(displayLayerParams)\r\n\r\n    if (this.component) {\r\n      return this.component.getNextUpdatePromise()\r\n    } else {\r\n      return Promise.resolve()\r\n    }\r\n  }\r", "name": "decorateCursorLine", "func_location": "TextEditor.update", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor.js", "line": 411, "func_start_line": 320}}, {"func_info": {"comment": [], "name": "TextEditorComponent.scheduleUpdate", "params": ["nextUpdateOnlyBlinksCursors"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 219, "start_line": 204}, "call_info": {"func_end_line": 191, "code": "  update (props) {\r\n    if (props.model !== this.props.model) {\r\n      this.props.model.component = null\r\n      props.model.component = this\r\n    }\r\n    this.props = props\r\n    this.scheduleUpdate()\r\n  }\r", "name": "scheduleUpdate", "func_location": "TextEditorComponent.update", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 190, "func_start_line": 184}}, {"func_info": {"comment": [], "name": "LinesTileComponent.shouldUpdate", "params": ["newProps"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 3925, "start_line": 3882}, "call_info": {"func_end_line": 3669, "code": "  update (newProps) {\r\n    if (this.shouldUpdate(newProps)) {\r\n      const oldProps = this.props\r\n      this.props = newProps\r\n      etch.updateSync(this)\r\n      if (!newProps.measuredContent) {\r\n        this.updateLines(oldProps, newProps)\r\n        this.updateBlockDecorations(oldProps, newProps)\r\n      }\r\n    }\r\n  }\r", "name": "shouldUpdate", "func_location": "LinesTileComponent.update", "args": ["newProps"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3660, "func_start_line": 3659}}, {"func_info": {"comment": [], "name": "LinesTileComponent.updateLines", "params": ["oldProps", "newProps"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 3819, "start_line": 3719}, "call_info": {"func_end_line": 3669, "code": "  update (newProps) {\r\n    if (this.shouldUpdate(newProps)) {\r\n      const oldProps = this.props\r\n      this.props = newProps\r\n      etch.updateSync(this)\r\n      if (!newProps.measuredContent) {\r\n        this.updateLines(oldProps, newProps)\r\n        this.updateBlockDecorations(oldProps, newProps)\r\n      }\r\n    }\r\n  }\r", "name": "updateLines", "func_location": "LinesTileComponent.update", "args": ["oldProps", "newProps"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3665, "func_start_line": 3659}}, {"func_info": {"comment": [], "name": "LinesTileComponent.updateBlockDecorations", "params": ["oldProps", "newProps"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 3880, "start_line": 3845}, "call_info": {"func_end_line": 3669, "code": "  update (newProps) {\r\n    if (this.shouldUpdate(newProps)) {\r\n      const oldProps = this.props\r\n      this.props = newProps\r\n      etch.updateSync(this)\r\n      if (!newProps.measuredContent) {\r\n        this.updateLines(oldProps, newProps)\r\n        this.updateBlockDecorations(oldProps, newProps)\r\n      }\r\n    }\r\n  }\r", "name": "updateBlockDecorations", "func_location": "LinesTileComponent.update", "args": ["oldProps", "newProps"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3666, "func_start_line": 3659}}, {"func_info": {"comment": [], "name": "LineNumberGutterComponent.shouldUpdate", "params": ["newProps"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 3365, "start_line": 3309}, "call_info": {"func_end_line": 3204, "code": "  update (newProps) {\r\n    if (this.shouldUpdate(newProps)) {\r\n      this.props = newProps\r\n      etch.updateSync(this)\r\n    }\r\n  }\r", "name": "shouldUpdate", "func_location": "LineNumberGutterComponent.update", "args": ["newProps"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3200, "func_start_line": 3199}}, {"func_info": {"comment": [], "name": "LineComponent.buildClassName", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4060, "start_line": 4055}, "call_info": {"func_end_line": 3962, "code": "  update (newProps) {\r\n    if (this.props.lineDecoration !== newProps.lineDecoration) {\r\n      this.props.lineDecoration = newProps.lineDecoration\r\n      this.element.className = this.buildClassName()\r\n    }\r\n\r\n    if (this.props.screenRow !== newProps.screenRow) {\r\n      this.props.screenRow = newProps.screenRow\r\n      this.element.dataset.screenRow = newProps.screenRow\r\n    }\r\n\r\n    if (!textDecorationsEqual(this.props.textDecorations, newProps.textDecorations)) {\r\n      this.props.textDecorations = newProps.textDecorations\r\n      this.element.firstChild.remove()\r\n      this.appendContents()\r\n    }\r\n  }\r", "name": "buildClassName", "func_location": "LineComponent.update", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3949, "func_start_line": 3946}}, {"func_info": {"comment": [], "name": "textDecorationsEqual", "params": ["oldDecorations", "newDecorations"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4354, "start_line": 4342}, "call_info": {"func_end_line": 3962, "code": "  update (newProps) {\r\n    if (this.props.lineDecoration !== newProps.lineDecoration) {\r\n      this.props.lineDecoration = newProps.lineDecoration\r\n      this.element.className = this.buildClassName()\r\n    }\r\n\r\n    if (this.props.screenRow !== newProps.screenRow) {\r\n      this.props.screenRow = newProps.screenRow\r\n      this.element.dataset.screenRow = newProps.screenRow\r\n    }\r\n\r\n    if (!textDecorationsEqual(this.props.textDecorations, newProps.textDecorations)) {\r\n      this.props.textDecorations = newProps.textDecorations\r\n      this.element.firstChild.remove()\r\n      this.appendContents()\r\n    }\r\n  }\r", "name": "textDecorationsEqual", "func_location": "LineComponent.update", "args": [".props.textDecorations", "newProps.textDecorations"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3957, "func_start_line": 3946}}, {"func_info": {"comment": [], "name": "LineComponent.appendContents", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4039, "start_line": 3975}, "call_info": {"func_end_line": 3962, "code": "  update (newProps) {\r\n    if (this.props.lineDecoration !== newProps.lineDecoration) {\r\n      this.props.lineDecoration = newProps.lineDecoration\r\n      this.element.className = this.buildClassName()\r\n    }\r\n\r\n    if (this.props.screenRow !== newProps.screenRow) {\r\n      this.props.screenRow = newProps.screenRow\r\n      this.element.dataset.screenRow = newProps.screenRow\r\n    }\r\n\r\n    if (!textDecorationsEqual(this.props.textDecorations, newProps.textDecorations)) {\r\n      this.props.textDecorations = newProps.textDecorations\r\n      this.element.firstChild.remove()\r\n      this.appendContents()\r\n    }\r\n  }\r", "name": "appendContents", "func_location": "LineComponent.update", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3960, "func_start_line": 3946}}, {"func_info": {"comment": [], "name": "HighlightsComponent.shouldUpdate", "params": ["newProps"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4145, "start_line": 4120}, "call_info": {"func_end_line": 4118, "code": "  update (newProps) {\r\n    if (this.shouldUpdate(newProps)) {\r\n      this.props = newProps\r\n      const {height, width, lineHeight, highlightDecorations} = this.props\r\n\r\n      this.element.style.height = height + 'px'\r\n      this.element.style.width = width + 'px'\r\n\r\n      const visibleHighlightDecorations = new Set()\r\n      if (highlightDecorations) {\r\n        for (let i = 0; i < highlightDecorations.length; i++) {\r\n          const highlightDecoration = highlightDecorations[i]\r\n          const highlightProps = Object.assign({lineHeight}, highlightDecorations[i])\r\n\r\n          let highlightComponent = this.highlightComponentsByKey.get(highlightDecoration.key)\r\n          if (highlightComponent) {\r\n            highlightComponent.update(highlightProps)\r\n          } else {\r\n            highlightComponent = new HighlightComponent(highlightProps)\r\n            this.element.appendChild(highlightComponent.element)\r\n            this.highlightComponentsByKey.set(highlightDecoration.key, highlightComponent)\r\n          }\r\n\r\n          highlightDecorations[i].flashRequested = false\r\n          visibleHighlightDecorations.add(highlightDecoration.key)\r\n        }\r\n      }\r\n\r\n      this.highlightComponentsByKey.forEach((highlightComponent, key) => {\r\n        if (!visibleHighlightDecorations.has(key)) {\r\n          highlightComponent.destroy()\r\n          this.highlightComponentsByKey.delete(key)\r\n        }\r\n      })\r\n    }\r\n  }\r", "name": "shouldUpdate", "func_location": "HighlightsComponent.update", "args": ["newProps"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 4084, "func_start_line": 4083}}, {"func_info": {"comment": [], "name": "HighlightComponent.constructor", "params": ["props"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4153, "start_line": 4149}, "call_info": {"func_end_line": 4118, "name": "constructor", "func_location": "HighlightsComponent.update", "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 4101, "func_start_line": 4083}}, {"func_info": {"comment": [], "name": "HighlightComponent.performFlash", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 4190, "start_line": 4172}, "call_info": {"func_end_line": 4170, "code": "  update (newProps) {\r\n    this.props = newProps\r\n    etch.updateSync(this)\r\n    if (newProps.flashRequested) this.performFlash()\r\n  }\r", "name": "performFlash", "func_location": "HighlightComponent.update", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 4169, "func_start_line": 4166}}, {"func_info": {"comment": [], "name": "GutterContainerComponent.shouldUpdate", "params": ["props"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 3087, "start_line": 3082}, "call_info": {"func_end_line": 3080, "code": "  update (props) {\r\n    if (this.shouldUpdate(props)) {\r\n      this.props = props\r\n      etch.updateSync(this)\r\n    }\r\n  }\r", "name": "shouldUpdate", "func_location": "GutterContainerComponent.update", "args": ["props"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3076, "func_start_line": 3075}}, {"func_info": {"comment": [], "name": "DummyScrollbarComponent.flushScrollPosition", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2997, "start_line": 2991}, "call_info": {"func_end_line": 2989, "code": "  update (newProps) {\r\n    const oldProps = this.props\r\n    this.props = newProps\r\n    etch.updateSync(this)\r\n\r\n    const shouldFlushScrollPosition = (\r\n      newProps.scrollTop !== oldProps.scrollTop ||\r\n      newProps.scrollLeft !== oldProps.scrollLeft\r\n    )\r\n    if (shouldFlushScrollPosition) this.flushScrollPosition()\r\n  }\r", "name": "flushScrollPosition", "func_location": "DummyScrollbarComponent.update", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2988, "func_start_line": 2979}}, {"func_info": {"comment": [], "name": "ReopenProjectMenuManager.disposeProjectMenu", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js", "end_line": 117, "start_line": 112}, "call_info": {"func_end_line": 51, "code": "  update () {\r\n    this.disposeProjectMenu()\r\n    this.projects = this.historyManager.getProjects().slice(0, this.config.get('core.reopenProjectMenuCount'))\r\n    const newMenu = ReopenProjectMenuManager.createProjectsMenu(this.projects)\r\n    this.lastProjectMenu = this.menuManager.add([newMenu])\r\n    this.updateWindowsJumpList()\r\n  }\r", "name": "disposeProjectMenu", "func_location": "ReopenProjectMenuManager.update", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js", "line": 46, "func_start_line": 45}}, {"func_info": {"comment": [], "name": "ReopenProjectMenuManager.createProjectsMenu", "params": ["projects"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js", "end_line": 133, "start_line": 119}, "call_info": {"func_end_line": 51, "code": "  update () {\r\n    this.disposeProjectMenu()\r\n    this.projects = this.historyManager.getProjects().slice(0, this.config.get('core.reopenProjectMenuCount'))\r\n    const newMenu = ReopenProjectMenuManager.createProjectsMenu(this.projects)\r\n    this.lastProjectMenu = this.menuManager.add([newMenu])\r\n    this.updateWindowsJumpList()\r\n  }\r", "name": "createProjectsMenu", "func_location": "ReopenProjectMenuManager.update", "args": [".projects"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js", "line": 48, "func_start_line": 45}}, {"func_info": {"comment": [], "name": "ReopenProjectMenuManager.updateWindowsJumpList", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js", "end_line": 102, "start_line": 75}, "call_info": {"func_end_line": 51, "code": "  update () {\r\n    this.disposeProjectMenu()\r\n    this.projects = this.historyManager.getProjects().slice(0, this.config.get('core.reopenProjectMenuCount'))\r\n    const newMenu = ReopenProjectMenuManager.createProjectsMenu(this.projects)\r\n    this.lastProjectMenu = this.menuManager.add([newMenu])\r\n    this.updateWindowsJumpList()\r\n  }\r", "name": "updateWindowsJumpList", "func_location": "ReopenProjectMenuManager.update", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/reopen-project-menu-manager.js", "line": 50, "func_start_line": 45}}, {"func_info": {"comment": [], "name": "LanguageLayer._performUpdate", "params": ["nodeRangeSet", "params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "end_line": 699, "start_line": 623}, "call_info": {"func_end_line": 611, "code": "  async update (nodeRangeSet) {\r\n    if (!this.currentParsePromise) {\r\n      while (!this.destroyed && (!this.tree || this.tree.rootNode.hasChanges())) {\r\n        const params = {async: false}\r\n        this.currentParsePromise = this._performUpdate(nodeRangeSet, params)\r\n        if (!params.async) break\r\n        await this.currentParsePromise\r\n      }\r\n      this.currentParsePromise = null\r\n    }\r\n  }\r", "name": "_performUpdate", "func_location": "LanguageLayer.update", "args": ["nodeRangeSet", "params"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/tree-sitter-language-mode.js", "line": 605, "func_start_line": 601}}, {"func_info": {"comment": [" Combines a menu template with the appropriate keystroke.", "", " template - An Object conforming to atom-shell's menu api but lacking", "            accelerator and click properties.", " keystrokesByCommand - An Object where the keys are commands and the values", "                       are Arrays containing the keystroke.", "", " Returns a complete menu configuration object for atom-shell's menu API."], "name": "ApplicationMenu.translateTemplate", "params": ["template", "keystrokesByCommand"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "end_line": 211, "start_line": 198}, "call_info": {"func_end_line": 30, "comment": [" Public: Updates the entire menu with the given keybindings.", "", " window - The BrowserWindow this menu template is associated with.", " template - The Object which describes the menu to display.", " keystrokesByCommand - An Object where the keys are commands and the values", "                       are Arrays containing the keystroke."], "code": "  update (window, template, keystrokesByCommand) {\r\n    this.translateTemplate(template, keystrokesByCommand)\r\n    this.substituteVersion(template)\r\n    this.windowTemplates.set(window, template)\r\n    if (window === this.lastFocusedWindow) return this.setActiveTemplate(template)\r\n  }\r", "name": "translateTemplate", "func_location": "ApplicationMenu.update", "args": ["template", "keystrokesByCommand"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "line": 26, "func_start_line": 25}}, {"func_info": {"comment": [" Replaces VERSION with the current version."], "name": "ApplicationMenu.substituteVersion", "params": ["template"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "end_line": 106, "start_line": 103}, "call_info": {"func_end_line": 30, "comment": [" Public: Updates the entire menu with the given keybindings.", "", " window - The BrowserWindow this menu template is associated with.", " template - The Object which describes the menu to display.", " keystrokesByCommand - An Object where the keys are commands and the values", "                       are Arrays containing the keystroke."], "code": "  update (window, template, keystrokesByCommand) {\r\n    this.translateTemplate(template, keystrokesByCommand)\r\n    this.substituteVersion(template)\r\n    this.windowTemplates.set(window, template)\r\n    if (window === this.lastFocusedWindow) return this.setActiveTemplate(template)\r\n  }\r", "name": "substituteVersion", "func_location": "ApplicationMenu.update", "args": ["template"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "line": 27, "func_start_line": 25}}, {"func_info": {"comment": [], "name": "ApplicationMenu.setActiveTemplate", "params": ["template"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "end_line": 40, "start_line": 32}, "call_info": {"func_end_line": 30, "comment": [" Public: Updates the entire menu with the given keybindings.", "", " window - The BrowserWindow this menu template is associated with.", " template - The Object which describes the menu to display.", " keystrokesByCommand - An Object where the keys are commands and the values", "                       are Arrays containing the keystroke."], "code": "  update (window, template, keystrokesByCommand) {\r\n    this.translateTemplate(template, keystrokesByCommand)\r\n    this.substituteVersion(template)\r\n    this.windowTemplates.set(window, template)\r\n    if (window === this.lastFocusedWindow) return this.setActiveTemplate(template)\r\n  }\r", "name": "setActiveTemplate", "func_location": "ApplicationMenu.update", "args": ["template"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/application-menu.js", "line": 29, "func_start_line": 25}}, {"func_info": {"comment": [], "name": "TextEditorComponent.updateHighlightsToRender", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1338, "start_line": 1327}, "call_info": {"func_end_line": 1325, "code": "  updateAbsolutePositionedDecorations () {\r\n    this.updateHighlightsToRender()\r\n    this.updateCursorsToRender()\r\n    this.updateOverlaysToRender()\r\n  }\r", "name": "updateHighlightsToRender", "func_location": "TextEditorComponent.updateAbsolutePositionedDecorations", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1322, "func_start_line": 1321}}, {"func_info": {"comment": [], "name": "TextEditorComponent.updateCursorsToRender", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1360, "start_line": 1340}, "call_info": {"func_end_line": 1325, "code": "  updateAbsolutePositionedDecorations () {\r\n    this.updateHighlightsToRender()\r\n    this.updateCursorsToRender()\r\n    this.updateOverlaysToRender()\r\n  }\r", "name": "updateCursorsToRender", "func_location": "TextEditorComponent.updateAbsolutePositionedDecorations", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1323, "func_start_line": 1321}}, {"func_info": {"comment": [], "name": "TextEditorComponent.updateOverlaysToRender", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1403, "start_line": 1395}, "call_info": {"func_end_line": 1325, "code": "  updateAbsolutePositionedDecorations () {\r\n    this.updateHighlightsToRender()\r\n    this.updateCursorsToRender()\r\n    this.updateOverlaysToRender()\r\n  }\r", "name": "updateOverlaysToRender", "func_location": "TextEditorComponent.updateAbsolutePositionedDecorations", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1324, "func_start_line": 1321}}, {"func_info": {"comment": [], "name": "TextEditorRegistry.updateEditorSettingsForLanguageMode", "params": ["editor", "oldLanguageMode"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js", "end_line": 247, "start_line": 224}, "call_info": {"func_end_line": 222, "code": "  async updateAndMonitorEditorSettings (editor, oldLanguageMode) {\r\n    await this.initialPackageActivationPromise\r\n    this.updateEditorSettingsForLanguageMode(editor, oldLanguageMode)\r\n    this.subscribeToSettingsForEditorScope(editor)\r\n  }\r", "name": "updateEditorSettingsForLanguageMode", "func_location": "TextEditorRegistry.updateAndMonitorEditorSettings", "args": ["editor", "oldLanguageMode"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js", "line": 220, "func_start_line": 218}}, {"func_info": {"comment": [], "name": "TextEditorRegistry.subscribeToSettingsForEditorScope", "params": ["editor"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js", "end_line": 286, "start_line": 249}, "call_info": {"func_end_line": 222, "code": "  async updateAndMonitorEditorSettings (editor, oldLanguageMode) {\r\n    await this.initialPackageActivationPromise\r\n    this.updateEditorSettingsForLanguageMode(editor, oldLanguageMode)\r\n    this.subscribeToSettingsForEditorScope(editor)\r\n  }\r", "name": "subscribeToSettingsForEditorScope", "func_location": "TextEditorRegistry.updateAndMonitorEditorSettings", "args": ["editor"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js", "line": 221, "func_start_line": 218}}, {"func_info": {"comment": [], "name": "CursorsAndInputComponent.getCursorsClassName", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 3602, "start_line": 3600}, "call_info": {"func_end_line": 3557, "code": "  updateCursorBlinkSync (cursorsBlinkedOff) {\r\n    this.props.cursorsBlinkedOff = cursorsBlinkedOff\r\n    const className = this.getCursorsClassName()\r\n    this.refs.cursors.className = className\r\n    this.virtualNode.props.className = className\r\n  }\r", "name": "getCursorsClassName", "func_location": "CursorsAndInputComponent.updateCursorBlinkSync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3554, "func_start_line": 3552}}, {"func_info": {"comment": [], "name": "ViewRegistry.requestDocumentUpdate", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/view-registry.js", "end_line": 228, "start_line": 224}, "call_info": {"func_end_line": 193, "code": "  updateDocument (fn) {\r\n    this.documentWriters.push(fn)\r\n    if (!this.documentReadInProgress) { this.requestDocumentUpdate() }\r\n    return new Disposable(() => {\r\n      this.documentWriters = this.documentWriters.filter(writer => writer !== fn)\r\n    })\r\n  }\r", "name": "requestDocumentUpdate", "func_location": "ViewRegistry.updateDocument", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/view-registry.js", "line": 189, "func_start_line": 187}}, {"func_info": {"comment": [" Essential: Get the active {Pane}'s active item.", "", " Returns an pane item {Object}."], "name": "Workspace.getActivePaneItem", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1359, "start_line": 1357}, "call_info": {"func_end_line": 614, "comment": [" On macOS, fades the application window's proxy icon when the current file", " has been modified."], "code": "  updateDocumentEdited () {\r\n    const activePaneItem = this.getActivePaneItem()\r\n    const modified = activePaneItem != null && typeof activePaneItem.isModified === 'function'\r\n      ? activePaneItem.isModified() || false\r\n      : false\r\n    this.applicationDelegate.setWindowDocumentEdited(modified)\r\n  }\r", "name": "getActivePaneItem", "func_location": "Workspace.updateDocumentEdited", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 609, "func_start_line": 608}}, {"func_info": {"comment": [], "name": "TextEditorRegistry.textEditorParamsForScope", "params": ["scopeDescriptor"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js", "end_line": 295, "start_line": 288}, "call_info": {"func_end_line": 247, "code": "  updateEditorSettingsForLanguageMode (editor, oldLanguageMode) {\r\n    const newLanguageMode = editor.buffer.getLanguageMode()\r\n\r\n    if (oldLanguageMode) {\r\n      const newSettings = this.textEditorParamsForScope(newLanguageMode.rootScopeDescriptor)\r\n      const oldSettings = this.textEditorParamsForScope(oldLanguageMode.rootScopeDescriptor)\r\n\r\n      const updatedSettings = {}\r\n      for (const [, paramName] of EDITOR_PARAMS_BY_SETTING_KEY) {\r\n        // Update the setting only if it has changed between the two language\r\n        // modes.  This prevents user-modified settings in an editor (like\r\n        // 'softWrapped') from being reset when the language mode changes.\r\n        if (!_.isEqual(newSettings[paramName], oldSettings[paramName])) {\r\n          updatedSettings[paramName] = newSettings[paramName]\r\n        }\r\n      }\r\n\r\n      if (_.size(updatedSettings) > 0) {\r\n        editor.update(updatedSettings)\r\n      }\r\n    } else {\r\n      editor.update(this.textEditorParamsForScope(newLanguageMode.rootScopeDescriptor))\r\n    }\r\n  }\r", "name": "textEditorParamsForScope", "func_location": "TextEditorRegistry.updateEditorSettingsForLanguageMode", "args": ["newLanguageMode.rootScopeDescriptor"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js", "line": 228, "func_start_line": 224}}, {"func_info": {"comment": [], "name": "TextEditorRegistry.textEditorParamsForScope", "params": ["scopeDescriptor"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js", "end_line": 295, "start_line": 288}, "call_info": {"func_end_line": 247, "code": "  updateEditorSettingsForLanguageMode (editor, oldLanguageMode) {\r\n    const newLanguageMode = editor.buffer.getLanguageMode()\r\n\r\n    if (oldLanguageMode) {\r\n      const newSettings = this.textEditorParamsForScope(newLanguageMode.rootScopeDescriptor)\r\n      const oldSettings = this.textEditorParamsForScope(oldLanguageMode.rootScopeDescriptor)\r\n\r\n      const updatedSettings = {}\r\n      for (const [, paramName] of EDITOR_PARAMS_BY_SETTING_KEY) {\r\n        // Update the setting only if it has changed between the two language\r\n        // modes.  This prevents user-modified settings in an editor (like\r\n        // 'softWrapped') from being reset when the language mode changes.\r\n        if (!_.isEqual(newSettings[paramName], oldSettings[paramName])) {\r\n          updatedSettings[paramName] = newSettings[paramName]\r\n        }\r\n      }\r\n\r\n      if (_.size(updatedSettings) > 0) {\r\n        editor.update(updatedSettings)\r\n      }\r\n    } else {\r\n      editor.update(this.textEditorParamsForScope(newLanguageMode.rootScopeDescriptor))\r\n    }\r\n  }\r", "name": "textEditorParamsForScope", "func_location": "TextEditorRegistry.updateEditorSettingsForLanguageMode", "args": ["oldLanguageMode.rootScopeDescriptor"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js", "line": 229, "func_start_line": 224}}, {"func_info": {"comment": [], "name": "TextEditorRegistry.textEditorParamsForScope", "params": ["scopeDescriptor"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js", "end_line": 295, "start_line": 288}, "call_info": {"func_end_line": 247, "code": "  updateEditorSettingsForLanguageMode (editor, oldLanguageMode) {\r\n    const newLanguageMode = editor.buffer.getLanguageMode()\r\n\r\n    if (oldLanguageMode) {\r\n      const newSettings = this.textEditorParamsForScope(newLanguageMode.rootScopeDescriptor)\r\n      const oldSettings = this.textEditorParamsForScope(oldLanguageMode.rootScopeDescriptor)\r\n\r\n      const updatedSettings = {}\r\n      for (const [, paramName] of EDITOR_PARAMS_BY_SETTING_KEY) {\r\n        // Update the setting only if it has changed between the two language\r\n        // modes.  This prevents user-modified settings in an editor (like\r\n        // 'softWrapped') from being reset when the language mode changes.\r\n        if (!_.isEqual(newSettings[paramName], oldSettings[paramName])) {\r\n          updatedSettings[paramName] = newSettings[paramName]\r\n        }\r\n      }\r\n\r\n      if (_.size(updatedSettings) > 0) {\r\n        editor.update(updatedSettings)\r\n      }\r\n    } else {\r\n      editor.update(this.textEditorParamsForScope(newLanguageMode.rootScopeDescriptor))\r\n    }\r\n  }\r", "name": "textEditorParamsForScope", "func_location": "TextEditorRegistry.updateEditorSettingsForLanguageMode", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-registry.js", "line": 245, "func_start_line": 224}}, {"func_info": {"comment": [], "name": "TextMateLanguageMode.retokenizeLines", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "end_line": 263, "start_line": 253}, "call_info": {"func_end_line": 251, "code": "  updateForInjection (grammar) {\r\n    if (!grammar.injectionSelector) return\r\n    for (const tokenizedLine of this.tokenizedLines) {\r\n      if (tokenizedLine) {\r\n        for (let token of tokenizedLine.tokens) {\r\n          if (grammar.injectionSelector.matches(token.scopes)) {\r\n            this.retokenizeLines()\r\n            return\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r", "name": "retokenizeLines", "func_location": "TextMateLanguageMode.updateForInjection", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-mate-language-mode.js", "line": 245, "func_start_line": 239}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelPositionAfterBlocksForRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2366, "start_line": 2364}, "call_info": {"func_end_line": 1338, "code": "  updateHighlightsToRender () {\r\n    this.decorationsToRender.highlights.length = 0\r\n    for (let i = 0; i < this.decorationsToMeasure.highlights.length; i++) {\r\n      const highlight = this.decorationsToMeasure.highlights[i]\r\n      const {start, end} = highlight.screenRange\r\n      highlight.startPixelTop = this.pixelPositionAfterBlocksForRow(start.row)\r\n      highlight.startPixelLeft = this.pixelLeftForRowAndColumn(start.row, start.column)\r\n      highlight.endPixelTop = this.pixelPositionAfterBlocksForRow(end.row) + this.getLineHeight()\r\n      highlight.endPixelLeft = this.pixelLeftForRowAndColumn(end.row, end.column)\r\n      this.decorationsToRender.highlights.push(highlight)\r\n    }\r\n  }\r", "name": "pixelPositionAfterBlocksForRow", "func_location": "TextEditorComponent.updateHighlightsToRender", "args": ["start.row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1332, "func_start_line": 1327}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelLeftForRowAndColumn", "params": ["row", "column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2377, "start_line": 2368}, "call_info": {"func_end_line": 1338, "code": "  updateHighlightsToRender () {\r\n    this.decorationsToRender.highlights.length = 0\r\n    for (let i = 0; i < this.decorationsToMeasure.highlights.length; i++) {\r\n      const highlight = this.decorationsToMeasure.highlights[i]\r\n      const {start, end} = highlight.screenRange\r\n      highlight.startPixelTop = this.pixelPositionAfterBlocksForRow(start.row)\r\n      highlight.startPixelLeft = this.pixelLeftForRowAndColumn(start.row, start.column)\r\n      highlight.endPixelTop = this.pixelPositionAfterBlocksForRow(end.row) + this.getLineHeight()\r\n      highlight.endPixelLeft = this.pixelLeftForRowAndColumn(end.row, end.column)\r\n      this.decorationsToRender.highlights.push(highlight)\r\n    }\r\n  }\r", "name": "pixelLeftForRowAndColumn", "func_location": "TextEditorComponent.updateHighlightsToRender", "args": ["start.row", "start.column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1333, "func_start_line": 1327}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelPositionAfterBlocksForRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2366, "start_line": 2364}, "call_info": {"func_end_line": 1338, "code": "  updateHighlightsToRender () {\r\n    this.decorationsToRender.highlights.length = 0\r\n    for (let i = 0; i < this.decorationsToMeasure.highlights.length; i++) {\r\n      const highlight = this.decorationsToMeasure.highlights[i]\r\n      const {start, end} = highlight.screenRange\r\n      highlight.startPixelTop = this.pixelPositionAfterBlocksForRow(start.row)\r\n      highlight.startPixelLeft = this.pixelLeftForRowAndColumn(start.row, start.column)\r\n      highlight.endPixelTop = this.pixelPositionAfterBlocksForRow(end.row) + this.getLineHeight()\r\n      highlight.endPixelLeft = this.pixelLeftForRowAndColumn(end.row, end.column)\r\n      this.decorationsToRender.highlights.push(highlight)\r\n    }\r\n  }\r", "name": "pixelPositionAfterBlocksForRow", "func_location": "TextEditorComponent.updateHighlightsToRender", "args": ["end.row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1334, "func_start_line": 1327}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getLineHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2602, "start_line": 2600}, "call_info": {"func_end_line": 1338, "code": "  updateHighlightsToRender () {\r\n    this.decorationsToRender.highlights.length = 0\r\n    for (let i = 0; i < this.decorationsToMeasure.highlights.length; i++) {\r\n      const highlight = this.decorationsToMeasure.highlights[i]\r\n      const {start, end} = highlight.screenRange\r\n      highlight.startPixelTop = this.pixelPositionAfterBlocksForRow(start.row)\r\n      highlight.startPixelLeft = this.pixelLeftForRowAndColumn(start.row, start.column)\r\n      highlight.endPixelTop = this.pixelPositionAfterBlocksForRow(end.row) + this.getLineHeight()\r\n      highlight.endPixelLeft = this.pixelLeftForRowAndColumn(end.row, end.column)\r\n      this.decorationsToRender.highlights.push(highlight)\r\n    }\r\n  }\r", "name": "getLineHeight", "func_location": "TextEditorComponent.updateHighlightsToRender", "args": ["end.row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1334, "func_start_line": 1327}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelLeftForRowAndColumn", "params": ["row", "column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2377, "start_line": 2368}, "call_info": {"func_end_line": 1338, "code": "  updateHighlightsToRender () {\r\n    this.decorationsToRender.highlights.length = 0\r\n    for (let i = 0; i < this.decorationsToMeasure.highlights.length; i++) {\r\n      const highlight = this.decorationsToMeasure.highlights[i]\r\n      const {start, end} = highlight.screenRange\r\n      highlight.startPixelTop = this.pixelPositionAfterBlocksForRow(start.row)\r\n      highlight.startPixelLeft = this.pixelLeftForRowAndColumn(start.row, start.column)\r\n      highlight.endPixelTop = this.pixelPositionAfterBlocksForRow(end.row) + this.getLineHeight()\r\n      highlight.endPixelLeft = this.pixelLeftForRowAndColumn(end.row, end.column)\r\n      this.decorationsToRender.highlights.push(highlight)\r\n    }\r\n  }\r", "name": "pixelLeftForRowAndColumn", "func_location": "TextEditorComponent.updateHighlightsToRender", "args": ["end.row", "end.column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1335, "func_start_line": 1327}}, {"func_info": {"comment": [], "name": "LinesTileComponent.getFirstElementForScreenLine", "params": ["oldProps", "screenLine"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 3843, "start_line": 3821}, "call_info": {"func_end_line": 3819, "code": "  updateLines (oldProps, newProps) {\r\n    var {\r\n      screenLines, tileStartRow, lineDecorations, textDecorations,\r\n      nodePool, displayLayer, lineComponentsByScreenLineId\r\n    } = newProps\r\n\r\n    var oldScreenLines = oldProps.screenLines\r\n    var newScreenLines = screenLines\r\n    var oldScreenLinesEndIndex = oldScreenLines.length\r\n    var newScreenLinesEndIndex = newScreenLines.length\r\n    var oldScreenLineIndex = 0\r\n    var newScreenLineIndex = 0\r\n    var lineComponentIndex = 0\r\n\r\n    while (oldScreenLineIndex < oldScreenLinesEndIndex || newScreenLineIndex < newScreenLinesEndIndex) {\r\n      var oldScreenLine = oldScreenLines[oldScreenLineIndex]\r\n      var newScreenLine = newScreenLines[newScreenLineIndex]\r\n\r\n      if (oldScreenLineIndex >= oldScreenLinesEndIndex) {\r\n        var newScreenLineComponent = new LineComponent({\r\n          screenLine: newScreenLine,\r\n          screenRow: tileStartRow + newScreenLineIndex,\r\n          lineDecoration: lineDecorations[newScreenLineIndex],\r\n          textDecorations: textDecorations[newScreenLineIndex],\r\n          displayLayer,\r\n          nodePool,\r\n          lineComponentsByScreenLineId\r\n        })\r\n        this.element.appendChild(newScreenLineComponent.element)\r\n        this.lineComponents.push(newScreenLineComponent)\r\n\r\n        newScreenLineIndex++\r\n        lineComponentIndex++\r\n      } else if (newScreenLineIndex >= newScreenLinesEndIndex) {\r\n        this.lineComponents[lineComponentIndex].destroy()\r\n        this.lineComponents.splice(lineComponentIndex, 1)\r\n\r\n        oldScreenLineIndex++\r\n      } else if (oldScreenLine === newScreenLine) {\r\n        var lineComponent = this.lineComponents[lineComponentIndex]\r\n        lineComponent.update({\r\n          screenRow: tileStartRow + newScreenLineIndex,\r\n          lineDecoration: lineDecorations[newScreenLineIndex],\r\n          textDecorations: textDecorations[newScreenLineIndex]\r\n        })\r\n\r\n        oldScreenLineIndex++\r\n        newScreenLineIndex++\r\n        lineComponentIndex++\r\n      } else {\r\n        var oldScreenLineIndexInNewScreenLines = newScreenLines.indexOf(oldScreenLine)\r\n        var newScreenLineIndexInOldScreenLines = oldScreenLines.indexOf(newScreenLine)\r\n        if (newScreenLineIndex < oldScreenLineIndexInNewScreenLines && oldScreenLineIndexInNewScreenLines < newScreenLinesEndIndex) {\r\n          var newScreenLineComponents = []\r\n          while (newScreenLineIndex < oldScreenLineIndexInNewScreenLines) {\r\n            var newScreenLineComponent = new LineComponent({ // eslint-disable-line no-redeclare\r\n              screenLine: newScreenLines[newScreenLineIndex],\r\n              screenRow: tileStartRow + newScreenLineIndex,\r\n              lineDecoration: lineDecorations[newScreenLineIndex],\r\n              textDecorations: textDecorations[newScreenLineIndex],\r\n              displayLayer,\r\n              nodePool,\r\n              lineComponentsByScreenLineId\r\n            })\r\n            this.element.insertBefore(newScreenLineComponent.element, this.getFirstElementForScreenLine(oldProps, oldScreenLine))\r\n            newScreenLineComponents.push(newScreenLineComponent)\r\n\r\n            newScreenLineIndex++\r\n          }\r\n\r\n          this.lineComponents.splice(lineComponentIndex, 0, ...newScreenLineComponents)\r\n          lineComponentIndex = lineComponentIndex + newScreenLineComponents.length\r\n        } else if (oldScreenLineIndex < newScreenLineIndexInOldScreenLines && newScreenLineIndexInOldScreenLines < oldScreenLinesEndIndex) {\r\n          while (oldScreenLineIndex < newScreenLineIndexInOldScreenLines) {\r\n            this.lineComponents[lineComponentIndex].destroy()\r\n            this.lineComponents.splice(lineComponentIndex, 1)\r\n\r\n            oldScreenLineIndex++\r\n          }\r\n        } else {\r\n          var oldScreenLineComponent = this.lineComponents[lineComponentIndex]\r\n          var newScreenLineComponent = new LineComponent({ // eslint-disable-line no-redeclare\r\n            screenLine: newScreenLines[newScreenLineIndex],\r\n            screenRow: tileStartRow + newScreenLineIndex,\r\n            lineDecoration: lineDecorations[newScreenLineIndex],\r\n            textDecorations: textDecorations[newScreenLineIndex],\r\n            displayLayer,\r\n            nodePool,\r\n            lineComponentsByScreenLineId\r\n          })\r\n          this.element.insertBefore(newScreenLineComponent.element, oldScreenLineComponent.element)\r\n          oldScreenLineComponent.destroy()\r\n          this.lineComponents[lineComponentIndex] = newScreenLineComponent\r\n\r\n          oldScreenLineIndex++\r\n          newScreenLineIndex++\r\n          lineComponentIndex++\r\n        }\r\n      }\r\n    }\r\n  }\r", "name": "getFirstElementForScreenLine", "func_location": "LinesTileComponent.updateLines", "args": ["newScreenLineComponent.element", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 3783, "func_start_line": 3719}}, {"func_info": {"comment": [], "name": "TextEditorElement.getModel", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 82, "start_line": 80}, "call_info": {"func_end_line": 96, "code": "  updateModelFromAttributes () {\r\n    const props = {mini: this.hasAttribute('mini')}\r\n    if (this.hasAttribute('placeholder-text')) props.placeholderText = this.getAttribute('placeholder-text')\r\n    if (this.hasAttribute('gutter-hidden')) props.lineNumberGutterVisible = false\r\n\r\n    this.getModel().update(props)\r\n    if (this.initialText) this.getModel().setText(this.initialText)\r\n  }\r", "name": "getModel", "func_location": "TextEditorElement.updateModelFromAttributes", "args": ["props"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 94, "func_start_line": 89}}, {"func_info": {"comment": [], "name": "TextEditorElement.getModel", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "end_line": 82, "start_line": 80}, "call_info": {"func_end_line": 96, "code": "  updateModelFromAttributes () {\r\n    const props = {mini: this.hasAttribute('mini')}\r\n    if (this.hasAttribute('placeholder-text')) props.placeholderText = this.getAttribute('placeholder-text')\r\n    if (this.hasAttribute('gutter-hidden')) props.lineNumberGutterVisible = false\r\n\r\n    this.getModel().update(props)\r\n    if (this.initialText) this.getModel().setText(this.initialText)\r\n  }\r", "name": "getModel", "func_location": "TextEditorElement.updateModelFromAttributes", "args": [".initialText"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-element.js", "line": 95, "func_start_line": 89}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollContainerClientWidthInBaseCharacters", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2694, "start_line": 2692}, "call_info": {"func_end_line": 2145, "comment": [" This method is called at the beginning of a frame render to relay any", " potential changes in the editor's width into the model before proceeding."], "code": "  updateModelSoftWrapColumn () {\r\n    const {model} = this.props\r\n    const newEditorWidthInChars = this.getScrollContainerClientWidthInBaseCharacters()\r\n    if (newEditorWidthInChars !== model.getEditorWidthInChars()) {\r\n      this.suppressUpdates = true\r\n\r\n      const renderedStartRow = this.getRenderedStartRow()\r\n      this.props.model.setEditorWidthInChars(newEditorWidthInChars)\r\n\r\n      // Relaying a change in to the editor's client width may cause the\r\n      // vertical scrollbar to appear or disappear, which causes the editor's\r\n      // client width to change *again*. Make sure the display layer is fully\r\n      // populated for the visible area before recalculating the editor's\r\n      // width in characters. Then update the display layer *again* just in\r\n      // case a change in scrollbar visibility causes lines to wrap\r\n      // differently. We capture the renderedStartRow before resetting the\r\n      // display layer because once it has been reset, we can't compute the\r\n      // rendered start row accurately. \ud83d\ude25\r\n      this.populateVisibleRowRange(renderedStartRow)\r\n      this.props.model.setEditorWidthInChars(this.getScrollContainerClientWidthInBaseCharacters())\r\n      this.derivedDimensionsCache = {}\r\n\r\n      this.suppressUpdates = false\r\n    }\r\n  }\r", "name": "getScrollContainerClientWidthInBaseCharacters", "func_location": "TextEditorComponent.updateModelSoftWrapColumn", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2123, "func_start_line": 2121}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedStartRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2726, "start_line": 2720}, "call_info": {"func_end_line": 2145, "comment": [" This method is called at the beginning of a frame render to relay any", " potential changes in the editor's width into the model before proceeding."], "code": "  updateModelSoftWrapColumn () {\r\n    const {model} = this.props\r\n    const newEditorWidthInChars = this.getScrollContainerClientWidthInBaseCharacters()\r\n    if (newEditorWidthInChars !== model.getEditorWidthInChars()) {\r\n      this.suppressUpdates = true\r\n\r\n      const renderedStartRow = this.getRenderedStartRow()\r\n      this.props.model.setEditorWidthInChars(newEditorWidthInChars)\r\n\r\n      // Relaying a change in to the editor's client width may cause the\r\n      // vertical scrollbar to appear or disappear, which causes the editor's\r\n      // client width to change *again*. Make sure the display layer is fully\r\n      // populated for the visible area before recalculating the editor's\r\n      // width in characters. Then update the display layer *again* just in\r\n      // case a change in scrollbar visibility causes lines to wrap\r\n      // differently. We capture the renderedStartRow before resetting the\r\n      // display layer because once it has been reset, we can't compute the\r\n      // rendered start row accurately. \ud83d\ude25\r\n      this.populateVisibleRowRange(renderedStartRow)\r\n      this.props.model.setEditorWidthInChars(this.getScrollContainerClientWidthInBaseCharacters())\r\n      this.derivedDimensionsCache = {}\r\n\r\n      this.suppressUpdates = false\r\n    }\r\n  }\r", "name": "getRenderedStartRow", "func_location": "TextEditorComponent.updateModelSoftWrapColumn", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2127, "func_start_line": 2121}}, {"func_info": {"comment": [" Ensure the spatial index is populated with rows that are currently visible"], "name": "TextEditorComponent.populateVisibleRowRange", "params": ["renderedStartRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2908, "start_line": 2896}, "call_info": {"func_end_line": 2145, "comment": [" This method is called at the beginning of a frame render to relay any", " potential changes in the editor's width into the model before proceeding."], "code": "  updateModelSoftWrapColumn () {\r\n    const {model} = this.props\r\n    const newEditorWidthInChars = this.getScrollContainerClientWidthInBaseCharacters()\r\n    if (newEditorWidthInChars !== model.getEditorWidthInChars()) {\r\n      this.suppressUpdates = true\r\n\r\n      const renderedStartRow = this.getRenderedStartRow()\r\n      this.props.model.setEditorWidthInChars(newEditorWidthInChars)\r\n\r\n      // Relaying a change in to the editor's client width may cause the\r\n      // vertical scrollbar to appear or disappear, which causes the editor's\r\n      // client width to change *again*. Make sure the display layer is fully\r\n      // populated for the visible area before recalculating the editor's\r\n      // width in characters. Then update the display layer *again* just in\r\n      // case a change in scrollbar visibility causes lines to wrap\r\n      // differently. We capture the renderedStartRow before resetting the\r\n      // display layer because once it has been reset, we can't compute the\r\n      // rendered start row accurately. \ud83d\ude25\r\n      this.populateVisibleRowRange(renderedStartRow)\r\n      this.props.model.setEditorWidthInChars(this.getScrollContainerClientWidthInBaseCharacters())\r\n      this.derivedDimensionsCache = {}\r\n\r\n      this.suppressUpdates = false\r\n    }\r\n  }\r", "name": "populateVisibleRowRange", "func_location": "TextEditorComponent.updateModelSoftWrapColumn", "args": ["renderedStartRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2139, "func_start_line": 2121}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollContainerClientWidthInBaseCharacters", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2694, "start_line": 2692}, "call_info": {"func_end_line": 2145, "comment": [" This method is called at the beginning of a frame render to relay any", " potential changes in the editor's width into the model before proceeding."], "code": "  updateModelSoftWrapColumn () {\r\n    const {model} = this.props\r\n    const newEditorWidthInChars = this.getScrollContainerClientWidthInBaseCharacters()\r\n    if (newEditorWidthInChars !== model.getEditorWidthInChars()) {\r\n      this.suppressUpdates = true\r\n\r\n      const renderedStartRow = this.getRenderedStartRow()\r\n      this.props.model.setEditorWidthInChars(newEditorWidthInChars)\r\n\r\n      // Relaying a change in to the editor's client width may cause the\r\n      // vertical scrollbar to appear or disappear, which causes the editor's\r\n      // client width to change *again*. Make sure the display layer is fully\r\n      // populated for the visible area before recalculating the editor's\r\n      // width in characters. Then update the display layer *again* just in\r\n      // case a change in scrollbar visibility causes lines to wrap\r\n      // differently. We capture the renderedStartRow before resetting the\r\n      // display layer because once it has been reset, we can't compute the\r\n      // rendered start row accurately. \ud83d\ude25\r\n      this.populateVisibleRowRange(renderedStartRow)\r\n      this.props.model.setEditorWidthInChars(this.getScrollContainerClientWidthInBaseCharacters())\r\n      this.derivedDimensionsCache = {}\r\n\r\n      this.suppressUpdates = false\r\n    }\r\n  }\r", "name": "getScrollContainerClientWidthInBaseCharacters", "func_location": "TextEditorComponent.updateModelSoftWrapColumn", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 2140, "func_start_line": 2121}}, {"func_info": {"comment": [], "name": "TextEditorComponent.updateOverlayToRender", "params": ["decoration"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1393, "start_line": 1362}, "call_info": {"func_end_line": 1403, "code": "  updateOverlaysToRender () {\r\n    const overlayCount = this.decorationsToRender.overlays.length\r\n    if (overlayCount === 0) return null\r\n\r\n    for (let i = 0; i < overlayCount; i++) {\r\n      const decoration = this.decorationsToRender.overlays[i]\r\n      this.updateOverlayToRender(decoration)\r\n    }\r\n  }\r", "name": "updateOverlayToRender", "func_location": "TextEditorComponent.updateOverlaysToRender", "args": ["decoration"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1401, "func_start_line": 1395}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getWindowInnerHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2594, "start_line": 2592}, "call_info": {"func_end_line": 1393, "code": "  updateOverlayToRender (decoration) {\r\n    const windowInnerHeight = this.getWindowInnerHeight()\r\n    const windowInnerWidth = this.getWindowInnerWidth()\r\n    const contentClientRect = this.refs.content.getBoundingClientRect()\r\n\r\n    const {element, screenPosition, avoidOverflow} = decoration\r\n    const {row, column} = screenPosition\r\n    let wrapperTop = contentClientRect.top + this.pixelPositionAfterBlocksForRow(row) + this.getLineHeight()\r\n    let wrapperLeft = contentClientRect.left + this.pixelLeftForRowAndColumn(row, column)\r\n    const clientRect = element.getBoundingClientRect()\r\n\r\n    if (avoidOverflow !== false) {\r\n      const computedStyle = window.getComputedStyle(element)\r\n      const elementTop = wrapperTop + parseInt(computedStyle.marginTop)\r\n      const elementBottom = elementTop + clientRect.height\r\n      const flippedElementTop = wrapperTop - this.getLineHeight() - clientRect.height - parseInt(computedStyle.marginBottom)\r\n      const elementLeft = wrapperLeft + parseInt(computedStyle.marginLeft)\r\n      const elementRight = elementLeft + clientRect.width\r\n\r\n      if (elementBottom > windowInnerHeight && flippedElementTop >= 0) {\r\n        wrapperTop -= (elementTop - flippedElementTop)\r\n      }\r\n      if (elementLeft < 0) {\r\n        wrapperLeft -= elementLeft\r\n      } else if (elementRight > windowInnerWidth) {\r\n        wrapperLeft -= (elementRight - windowInnerWidth)\r\n      }\r\n    }\r\n\r\n    decoration.pixelTop = Math.round(wrapperTop)\r\n    decoration.pixelLeft = Math.round(wrapperLeft)\r\n  }\r", "name": "getWindowInnerHeight", "func_location": "TextEditorComponent.updateOverlayToRender", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1363, "func_start_line": 1362}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getWindowInnerWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2598, "start_line": 2596}, "call_info": {"func_end_line": 1393, "code": "  updateOverlayToRender (decoration) {\r\n    const windowInnerHeight = this.getWindowInnerHeight()\r\n    const windowInnerWidth = this.getWindowInnerWidth()\r\n    const contentClientRect = this.refs.content.getBoundingClientRect()\r\n\r\n    const {element, screenPosition, avoidOverflow} = decoration\r\n    const {row, column} = screenPosition\r\n    let wrapperTop = contentClientRect.top + this.pixelPositionAfterBlocksForRow(row) + this.getLineHeight()\r\n    let wrapperLeft = contentClientRect.left + this.pixelLeftForRowAndColumn(row, column)\r\n    const clientRect = element.getBoundingClientRect()\r\n\r\n    if (avoidOverflow !== false) {\r\n      const computedStyle = window.getComputedStyle(element)\r\n      const elementTop = wrapperTop + parseInt(computedStyle.marginTop)\r\n      const elementBottom = elementTop + clientRect.height\r\n      const flippedElementTop = wrapperTop - this.getLineHeight() - clientRect.height - parseInt(computedStyle.marginBottom)\r\n      const elementLeft = wrapperLeft + parseInt(computedStyle.marginLeft)\r\n      const elementRight = elementLeft + clientRect.width\r\n\r\n      if (elementBottom > windowInnerHeight && flippedElementTop >= 0) {\r\n        wrapperTop -= (elementTop - flippedElementTop)\r\n      }\r\n      if (elementLeft < 0) {\r\n        wrapperLeft -= elementLeft\r\n      } else if (elementRight > windowInnerWidth) {\r\n        wrapperLeft -= (elementRight - windowInnerWidth)\r\n      }\r\n    }\r\n\r\n    decoration.pixelTop = Math.round(wrapperTop)\r\n    decoration.pixelLeft = Math.round(wrapperLeft)\r\n  }\r", "name": "getWindowInnerWidth", "func_location": "TextEditorComponent.updateOverlayToRender", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1364, "func_start_line": 1362}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelPositionAfterBlocksForRow", "params": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2366, "start_line": 2364}, "call_info": {"func_end_line": 1393, "code": "  updateOverlayToRender (decoration) {\r\n    const windowInnerHeight = this.getWindowInnerHeight()\r\n    const windowInnerWidth = this.getWindowInnerWidth()\r\n    const contentClientRect = this.refs.content.getBoundingClientRect()\r\n\r\n    const {element, screenPosition, avoidOverflow} = decoration\r\n    const {row, column} = screenPosition\r\n    let wrapperTop = contentClientRect.top + this.pixelPositionAfterBlocksForRow(row) + this.getLineHeight()\r\n    let wrapperLeft = contentClientRect.left + this.pixelLeftForRowAndColumn(row, column)\r\n    const clientRect = element.getBoundingClientRect()\r\n\r\n    if (avoidOverflow !== false) {\r\n      const computedStyle = window.getComputedStyle(element)\r\n      const elementTop = wrapperTop + parseInt(computedStyle.marginTop)\r\n      const elementBottom = elementTop + clientRect.height\r\n      const flippedElementTop = wrapperTop - this.getLineHeight() - clientRect.height - parseInt(computedStyle.marginBottom)\r\n      const elementLeft = wrapperLeft + parseInt(computedStyle.marginLeft)\r\n      const elementRight = elementLeft + clientRect.width\r\n\r\n      if (elementBottom > windowInnerHeight && flippedElementTop >= 0) {\r\n        wrapperTop -= (elementTop - flippedElementTop)\r\n      }\r\n      if (elementLeft < 0) {\r\n        wrapperLeft -= elementLeft\r\n      } else if (elementRight > windowInnerWidth) {\r\n        wrapperLeft -= (elementRight - windowInnerWidth)\r\n      }\r\n    }\r\n\r\n    decoration.pixelTop = Math.round(wrapperTop)\r\n    decoration.pixelLeft = Math.round(wrapperLeft)\r\n  }\r", "name": "pixelPositionAfterBlocksForRow", "func_location": "TextEditorComponent.updateOverlayToRender", "args": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1369, "func_start_line": 1362}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getLineHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2602, "start_line": 2600}, "call_info": {"func_end_line": 1393, "code": "  updateOverlayToRender (decoration) {\r\n    const windowInnerHeight = this.getWindowInnerHeight()\r\n    const windowInnerWidth = this.getWindowInnerWidth()\r\n    const contentClientRect = this.refs.content.getBoundingClientRect()\r\n\r\n    const {element, screenPosition, avoidOverflow} = decoration\r\n    const {row, column} = screenPosition\r\n    let wrapperTop = contentClientRect.top + this.pixelPositionAfterBlocksForRow(row) + this.getLineHeight()\r\n    let wrapperLeft = contentClientRect.left + this.pixelLeftForRowAndColumn(row, column)\r\n    const clientRect = element.getBoundingClientRect()\r\n\r\n    if (avoidOverflow !== false) {\r\n      const computedStyle = window.getComputedStyle(element)\r\n      const elementTop = wrapperTop + parseInt(computedStyle.marginTop)\r\n      const elementBottom = elementTop + clientRect.height\r\n      const flippedElementTop = wrapperTop - this.getLineHeight() - clientRect.height - parseInt(computedStyle.marginBottom)\r\n      const elementLeft = wrapperLeft + parseInt(computedStyle.marginLeft)\r\n      const elementRight = elementLeft + clientRect.width\r\n\r\n      if (elementBottom > windowInnerHeight && flippedElementTop >= 0) {\r\n        wrapperTop -= (elementTop - flippedElementTop)\r\n      }\r\n      if (elementLeft < 0) {\r\n        wrapperLeft -= elementLeft\r\n      } else if (elementRight > windowInnerWidth) {\r\n        wrapperLeft -= (elementRight - windowInnerWidth)\r\n      }\r\n    }\r\n\r\n    decoration.pixelTop = Math.round(wrapperTop)\r\n    decoration.pixelLeft = Math.round(wrapperLeft)\r\n  }\r", "name": "getLineHeight", "func_location": "TextEditorComponent.updateOverlayToRender", "args": ["row"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1369, "func_start_line": 1362}}, {"func_info": {"comment": [], "name": "TextEditorComponent.pixelLeftForRowAndColumn", "params": ["row", "column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2377, "start_line": 2368}, "call_info": {"func_end_line": 1393, "code": "  updateOverlayToRender (decoration) {\r\n    const windowInnerHeight = this.getWindowInnerHeight()\r\n    const windowInnerWidth = this.getWindowInnerWidth()\r\n    const contentClientRect = this.refs.content.getBoundingClientRect()\r\n\r\n    const {element, screenPosition, avoidOverflow} = decoration\r\n    const {row, column} = screenPosition\r\n    let wrapperTop = contentClientRect.top + this.pixelPositionAfterBlocksForRow(row) + this.getLineHeight()\r\n    let wrapperLeft = contentClientRect.left + this.pixelLeftForRowAndColumn(row, column)\r\n    const clientRect = element.getBoundingClientRect()\r\n\r\n    if (avoidOverflow !== false) {\r\n      const computedStyle = window.getComputedStyle(element)\r\n      const elementTop = wrapperTop + parseInt(computedStyle.marginTop)\r\n      const elementBottom = elementTop + clientRect.height\r\n      const flippedElementTop = wrapperTop - this.getLineHeight() - clientRect.height - parseInt(computedStyle.marginBottom)\r\n      const elementLeft = wrapperLeft + parseInt(computedStyle.marginLeft)\r\n      const elementRight = elementLeft + clientRect.width\r\n\r\n      if (elementBottom > windowInnerHeight && flippedElementTop >= 0) {\r\n        wrapperTop -= (elementTop - flippedElementTop)\r\n      }\r\n      if (elementLeft < 0) {\r\n        wrapperLeft -= elementLeft\r\n      } else if (elementRight > windowInnerWidth) {\r\n        wrapperLeft -= (elementRight - windowInnerWidth)\r\n      }\r\n    }\r\n\r\n    decoration.pixelTop = Math.round(wrapperTop)\r\n    decoration.pixelLeft = Math.round(wrapperLeft)\r\n  }\r", "name": "pixelLeftForRowAndColumn", "func_location": "TextEditorComponent.updateOverlayToRender", "args": ["row", "column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1370, "func_start_line": 1362}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getLineHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2602, "start_line": 2600}, "call_info": {"func_end_line": 1393, "code": "  updateOverlayToRender (decoration) {\r\n    const windowInnerHeight = this.getWindowInnerHeight()\r\n    const windowInnerWidth = this.getWindowInnerWidth()\r\n    const contentClientRect = this.refs.content.getBoundingClientRect()\r\n\r\n    const {element, screenPosition, avoidOverflow} = decoration\r\n    const {row, column} = screenPosition\r\n    let wrapperTop = contentClientRect.top + this.pixelPositionAfterBlocksForRow(row) + this.getLineHeight()\r\n    let wrapperLeft = contentClientRect.left + this.pixelLeftForRowAndColumn(row, column)\r\n    const clientRect = element.getBoundingClientRect()\r\n\r\n    if (avoidOverflow !== false) {\r\n      const computedStyle = window.getComputedStyle(element)\r\n      const elementTop = wrapperTop + parseInt(computedStyle.marginTop)\r\n      const elementBottom = elementTop + clientRect.height\r\n      const flippedElementTop = wrapperTop - this.getLineHeight() - clientRect.height - parseInt(computedStyle.marginBottom)\r\n      const elementLeft = wrapperLeft + parseInt(computedStyle.marginLeft)\r\n      const elementRight = elementLeft + clientRect.width\r\n\r\n      if (elementBottom > windowInnerHeight && flippedElementTop >= 0) {\r\n        wrapperTop -= (elementTop - flippedElementTop)\r\n      }\r\n      if (elementLeft < 0) {\r\n        wrapperLeft -= elementLeft\r\n      } else if (elementRight > windowInnerWidth) {\r\n        wrapperLeft -= (elementRight - windowInnerWidth)\r\n      }\r\n    }\r\n\r\n    decoration.pixelTop = Math.round(wrapperTop)\r\n    decoration.pixelLeft = Math.round(wrapperLeft)\r\n  }\r", "name": "getLineHeight", "func_location": "TextEditorComponent.updateOverlayToRender", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 1377, "func_start_line": 1362}}, {"func_info": {"comment": [], "name": "shouldGetEnvFromShell", "params": ["env"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/update-process-env.js", "end_line": 59, "start_line": 45}, "call_info": {"func_end_line": 43, "code": "async function updateProcessEnv (launchEnv) {\r\n  let envToAssign\r\n  if (launchEnv) {\r\n    if (shouldGetEnvFromShell(launchEnv)) {\r\n      envToAssign = await getEnvFromShell(launchEnv)\r\n    } else if (launchEnv.PWD || launchEnv.PROMPT || launchEnv.PSModulePath) {\r\n      envToAssign = launchEnv\r\n    }\r\n  }\r\n\r\n  if (envToAssign) {\r\n    for (let key in process.env) {\r\n      if (!ENVIRONMENT_VARIABLES_TO_PRESERVE.has(key)) {\r\n        delete process.env[key]\r\n      }\r\n    }\r\n\r\n    for (let key in envToAssign) {\r\n      if (!ENVIRONMENT_VARIABLES_TO_PRESERVE.has(key) || (!process.env[key] && envToAssign[key])) {\r\n        process.env[key] = envToAssign[key]\r\n      }\r\n    }\r\n\r\n    if (envToAssign.ATOM_HOME && fs.existsSync(envToAssign.ATOM_HOME)) {\r\n      process.env.ATOM_HOME = envToAssign.ATOM_HOME\r\n    }\r\n  }\r\n}\r", "name": "shouldGetEnvFromShell", "func_location": "updateProcessEnv", "args": ["launchEnv"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/update-process-env.js", "line": 19, "func_start_line": 16}}, {"func_info": {"comment": [], "name": "getEnvFromShell", "params": ["env"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/update-process-env.js", "end_line": 119, "start_line": 61}, "call_info": {"func_end_line": 43, "code": "async function updateProcessEnv (launchEnv) {\r\n  let envToAssign\r\n  if (launchEnv) {\r\n    if (shouldGetEnvFromShell(launchEnv)) {\r\n      envToAssign = await getEnvFromShell(launchEnv)\r\n    } else if (launchEnv.PWD || launchEnv.PROMPT || launchEnv.PSModulePath) {\r\n      envToAssign = launchEnv\r\n    }\r\n  }\r\n\r\n  if (envToAssign) {\r\n    for (let key in process.env) {\r\n      if (!ENVIRONMENT_VARIABLES_TO_PRESERVE.has(key)) {\r\n        delete process.env[key]\r\n      }\r\n    }\r\n\r\n    for (let key in envToAssign) {\r\n      if (!ENVIRONMENT_VARIABLES_TO_PRESERVE.has(key) || (!process.env[key] && envToAssign[key])) {\r\n        process.env[key] = envToAssign[key]\r\n      }\r\n    }\r\n\r\n    if (envToAssign.ATOM_HOME && fs.existsSync(envToAssign.ATOM_HOME)) {\r\n      process.env.ATOM_HOME = envToAssign.ATOM_HOME\r\n    }\r\n  }\r\n}\r", "name": "getEnvFromShell", "func_location": "updateProcessEnv", "args": ["launchEnv"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/update-process-env.js", "line": 20, "func_start_line": 16}}, {"func_info": {"comment": [" Public: Get the load settings for the current window.", "", " Returns an {Object} containing all the load setting key/value pairs."], "name": "AtomEnvironment.getLoadSettings", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "end_line": 527, "start_line": 525}, "call_info": {"func_end_line": 975, "code": "  async updateProcessEnvAndTriggerHooks () {\r\n    await this.updateProcessEnv(this.getLoadSettings().env)\r\n    this.shellEnvironmentLoaded = true\r\n    this.emitter.emit('loaded-shell-environment')\r\n    this.packages.triggerActivationHook('core:loaded-shell-environment')\r\n  }\r", "name": "getLoadSettings", "func_location": "AtomEnvironment.updateProcessEnvAndTriggerHooks", "args": [".env"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/atom-environment.js", "line": 971, "func_start_line": 970}}, {"func_info": {"comment": [], "name": "TextEditorComponent.isVisible", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2590, "start_line": 2588}, "call_info": {"func_end_line": 289, "code": "  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r", "name": "isVisible", "func_location": "TextEditorComponent.updateSync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 230, "func_start_line": 221}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getLineHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2602, "start_line": 2600}, "call_info": {"func_end_line": 289, "code": "  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r", "name": "getLineHeight", "func_location": "TextEditorComponent.updateSync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 246, "func_start_line": 221}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getBaseCharacterWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2606, "start_line": 2604}, "call_info": {"func_end_line": 289, "code": "  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r", "name": "getBaseCharacterWidth", "func_location": "TextEditorComponent.updateSync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 247, "func_start_line": 221}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollTopRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2872, "start_line": 2866}, "call_info": {"func_end_line": 289, "code": "  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r", "name": "getScrollTopRow", "func_location": "TextEditorComponent.updateSync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 248, "func_start_line": 221}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getScrollLeftColumn", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2893, "start_line": 2887}, "call_info": {"func_end_line": 289, "code": "  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r", "name": "getScrollLeftColumn", "func_location": "TextEditorComponent.updateSync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 249, "func_start_line": 221}}, {"func_info": {"comment": [], "name": "TextEditorComponent.measureCharacterDimensions", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2173, "start_line": 2158}, "call_info": {"func_end_line": 289, "code": "  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r", "name": "measureCharacterDimensions", "func_location": "TextEditorComponent.updateSync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 251, "func_start_line": 221}}, {"func_info": {"comment": [], "name": "TextEditorComponent.measureGutterDimensions", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2199, "start_line": 2175}, "call_info": {"func_end_line": 289, "code": "  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r", "name": "measureGutterDimensions", "func_location": "TextEditorComponent.updateSync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 252, "func_start_line": 221}}, {"func_info": {"comment": [], "name": "TextEditorComponent.queryLongestLine", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 878, "start_line": 868}, "call_info": {"func_end_line": 289, "code": "  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r", "name": "queryLongestLine", "func_location": "TextEditorComponent.updateSync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 253, "func_start_line": 221}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getLineHeight", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2602, "start_line": 2600}, "call_info": {"func_end_line": 289, "code": "  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r", "name": "getLineHeight", "func_location": "TextEditorComponent.updateSync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 255, "func_start_line": 221}}, {"func_info": {"comment": [], "name": "TextEditorComponent.setScrollTopRow", "params": ["scrollTopRow", "scheduleUpdate"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2864, "start_line": 2853}, "call_info": {"func_end_line": 289, "code": "  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r", "name": "setScrollTopRow", "func_location": "TextEditorComponent.updateSync", "args": ["scrollTopRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 256, "func_start_line": 221}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getBaseCharacterWidth", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2606, "start_line": 2604}, "call_info": {"func_end_line": 289, "code": "  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r", "name": "getBaseCharacterWidth", "func_location": "TextEditorComponent.updateSync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 258, "func_start_line": 221}}, {"func_info": {"comment": [], "name": "TextEditorComponent.setScrollLeftColumn", "params": ["scrollLeftColumn", "scheduleUpdate"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2885, "start_line": 2874}, "call_info": {"func_end_line": 289, "code": "  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r", "name": "setScrollLeftColumn", "func_location": "TextEditorComponent.updateSync", "args": ["scrollLeftColumn"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 259, "func_start_line": 221}}, {"func_info": {"comment": [], "name": "TextEditorComponent.measureBlockDecorations", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 362, "start_line": 291}, "call_info": {"func_end_line": 289, "code": "  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r", "name": "measureBlockDecorations", "func_location": "TextEditorComponent.updateSync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 264, "func_start_line": 221}}, {"func_info": {"comment": [], "name": "TextEditorComponent.updateSyncBeforeMeasuringContent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 387, "start_line": 364}, "call_info": {"func_end_line": 289, "code": "  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r", "name": "updateSyncBeforeMeasuringContent", "func_location": "TextEditorComponent.updateSync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 266, "func_start_line": 221}}, {"func_info": {"comment": [], "name": "TextEditorComponent.measureContentDuringUpdateSync", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 424, "start_line": 389}, "call_info": {"func_end_line": 289, "code": "  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r", "name": "measureContentDuringUpdateSync", "func_location": "TextEditorComponent.updateSync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 280, "func_start_line": 221}}, {"func_info": {"comment": [], "name": "TextEditorComponent.updateSync", "params": ["useScheduler"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 289, "start_line": 221}, "call_info": {"func_end_line": 289, "code": "  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r", "name": "updateSync", "func_location": "TextEditorComponent.updateSync", "args": [{"type": "boolean"}], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 282, "func_start_line": 221}}, {"func_info": {"comment": [], "name": "TextEditorComponent.updateSyncAfterMeasuringContent", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 449, "start_line": 426}, "call_info": {"func_end_line": 289, "code": "  updateSync (useScheduler = false) {\r\n    // Don't proceed if we know we are not visible\r\n    if (!this.visible) {\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    // Don't proceed if we have to pay for a measurement anyway and detect\r\n    // that we are no longer visible.\r\n    if ((this.remeasureCharacterDimensions || this.remeasureAllBlockDecorations) && !this.isVisible()) {\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    const onlyBlinkingCursors = this.nextUpdateOnlyBlinksCursors\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    if (useScheduler && onlyBlinkingCursors) {\r\n      this.refs.cursorsAndInput.updateCursorBlinkSync(this.cursorsBlinkedOff)\r\n      if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n      this.updateScheduled = false\r\n      return\r\n    }\r\n\r\n    if (this.remeasureCharacterDimensions) {\r\n      const originalLineHeight = this.getLineHeight()\r\n      const originalBaseCharacterWidth = this.getBaseCharacterWidth()\r\n      const scrollTopRow = this.getScrollTopRow()\r\n      const scrollLeftColumn = this.getScrollLeftColumn()\r\n\r\n      this.measureCharacterDimensions()\r\n      this.measureGutterDimensions()\r\n      this.queryLongestLine()\r\n\r\n      if (this.getLineHeight() !== originalLineHeight) {\r\n        this.setScrollTopRow(scrollTopRow)\r\n      }\r\n      if (this.getBaseCharacterWidth() !== originalBaseCharacterWidth) {\r\n        this.setScrollLeftColumn(scrollLeftColumn)\r\n      }\r\n      this.remeasureCharacterDimensions = false\r\n    }\r\n\r\n    this.measureBlockDecorations()\r\n\r\n    this.updateSyncBeforeMeasuringContent()\r\n    if (useScheduler === true) {\r\n      const scheduler = etch.getScheduler()\r\n      scheduler.readDocument(() => {\r\n        const restartFrame = this.measureContentDuringUpdateSync()\r\n        scheduler.updateDocument(() => {\r\n          if (restartFrame) {\r\n            this.updateSync(true)\r\n          } else {\r\n            this.updateSyncAfterMeasuringContent()\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      const restartFrame = this.measureContentDuringUpdateSync()\r\n      if (restartFrame) {\r\n        this.updateSync(false)\r\n      } else {\r\n        this.updateSyncAfterMeasuringContent()\r\n      }\r\n    }\r\n\r\n    this.updateScheduled = false\r\n  }\r", "name": "updateSyncAfterMeasuringContent", "func_location": "TextEditorComponent.updateSync", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 284, "func_start_line": 221}}, {"func_info": {"comment": [], "name": "TextEditorComponent.measureScrollbarDimensions", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2229, "start_line": 2221}, "call_info": {"func_end_line": 449, "code": "  updateSyncAfterMeasuringContent () {\r\n    this.derivedDimensionsCache = {}\r\n    etch.updateSync(this)\r\n\r\n    this.currentFrameLineNumberGutterProps = null\r\n    this.scrollTopPending = false\r\n    this.scrollLeftPending = false\r\n    if (this.remeasureScrollbars) {\r\n      // Flush stored scroll positions to the vertical and the horizontal\r\n      // scrollbars. This is because they have just been destroyed and recreated\r\n      // as a result of their remeasurement, but we could not assign the scroll\r\n      // top while they were initialized because they were not attached to the\r\n      // DOM yet.\r\n      this.refs.verticalScrollbar.flushScrollPosition()\r\n      this.refs.horizontalScrollbar.flushScrollPosition()\r\n\r\n      this.measureScrollbarDimensions()\r\n      this.remeasureScrollbars = false\r\n      etch.updateSync(this)\r\n    }\r\n\r\n    this.derivedDimensionsCache = {}\r\n    if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n  }\r", "name": "measureScrollbarDimensions", "func_location": "TextEditorComponent.updateSyncAfterMeasuringContent", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 442, "func_start_line": 426}}, {"func_info": {"comment": [" This method is called at the beginning of a frame render to relay any", " potential changes in the editor's width into the model before proceeding."], "name": "TextEditorComponent.updateModelSoftWrapColumn", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2145, "start_line": 2121}, "call_info": {"func_end_line": 387, "code": "  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r", "name": "updateModelSoftWrapColumn", "func_location": "TextEditorComponent.updateSyncBeforeMeasuringContent", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 367, "func_start_line": 364}}, {"func_info": {"comment": [], "name": "TextEditorComponent.autoscrollVertically", "params": ["screenRange", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2069, "start_line": 2035}, "call_info": {"func_end_line": 387, "code": "  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r", "name": "autoscrollVertically", "func_location": "TextEditorComponent.updateSyncBeforeMeasuringContent", "args": ["screenRange", "options"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 370, "func_start_line": 364}}, {"func_info": {"comment": [], "name": "TextEditorComponent.requestHorizontalMeasurement", "params": ["row", "column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2257, "start_line": 2243}, "call_info": {"func_end_line": 387, "code": "  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r", "name": "requestHorizontalMeasurement", "func_location": "TextEditorComponent.updateSyncBeforeMeasuringContent", "args": ["screenRange.start.row", "screenRange.start.column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 371, "func_start_line": 364}}, {"func_info": {"comment": [], "name": "TextEditorComponent.requestHorizontalMeasurement", "params": ["row", "column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2257, "start_line": 2243}, "call_info": {"func_end_line": 387, "code": "  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r", "name": "requestHorizontalMeasurement", "func_location": "TextEditorComponent.updateSyncBeforeMeasuringContent", "args": ["screenRange.end.row", "screenRange.end.column"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 372, "func_start_line": 364}}, {"func_info": {"comment": [" Ensure the spatial index is populated with rows that are currently visible"], "name": "TextEditorComponent.populateVisibleRowRange", "params": ["renderedStartRow"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2908, "start_line": 2896}, "call_info": {"func_end_line": 387, "code": "  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r", "name": "populateVisibleRowRange", "func_location": "TextEditorComponent.updateSyncBeforeMeasuringContent", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 374, "func_start_line": 364}}, {"func_info": {"comment": [], "name": "TextEditorComponent.getRenderedStartRow", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2726, "start_line": 2720}, "call_info": {"func_end_line": 387, "code": "  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r", "name": "getRenderedStartRow", "func_location": "TextEditorComponent.updateSyncBeforeMeasuringContent", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 374, "func_start_line": 364}}, {"func_info": {"comment": [], "name": "TextEditorComponent.populateVisibleTiles", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 2937, "start_line": 2910}, "call_info": {"func_end_line": 387, "code": "  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r", "name": "populateVisibleTiles", "func_location": "TextEditorComponent.updateSyncBeforeMeasuringContent", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 375, "func_start_line": 364}}, {"func_info": {"comment": [], "name": "TextEditorComponent.queryScreenLinesToRender", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 866, "start_line": 859}, "call_info": {"func_end_line": 387, "code": "  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r", "name": "queryScreenLinesToRender", "func_location": "TextEditorComponent.updateSyncBeforeMeasuringContent", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 376, "func_start_line": 364}}, {"func_info": {"comment": [], "name": "TextEditorComponent.queryLongestLine", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 878, "start_line": 868}, "call_info": {"func_end_line": 387, "code": "  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r", "name": "queryLongestLine", "func_location": "TextEditorComponent.updateSyncBeforeMeasuringContent", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 377, "func_start_line": 364}}, {"func_info": {"comment": [], "name": "TextEditorComponent.queryLineNumbersToRender", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 943, "start_line": 889}, "call_info": {"func_end_line": 387, "code": "  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r", "name": "queryLineNumbersToRender", "func_location": "TextEditorComponent.updateSyncBeforeMeasuringContent", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 378, "func_start_line": 364}}, {"func_info": {"comment": [], "name": "TextEditorComponent.queryGuttersToRender", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 979, "start_line": 963}, "call_info": {"func_end_line": 387, "code": "  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r", "name": "queryGuttersToRender", "func_location": "TextEditorComponent.updateSyncBeforeMeasuringContent", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 379, "func_start_line": 364}}, {"func_info": {"comment": [], "name": "TextEditorComponent.queryDecorationsToRender", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 1009, "start_line": 981}, "call_info": {"func_end_line": 387, "code": "  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r", "name": "queryDecorationsToRender", "func_location": "TextEditorComponent.updateSyncBeforeMeasuringContent", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 380, "func_start_line": 364}}, {"func_info": {"comment": [], "name": "TextEditorComponent.queryExtraScreenLinesToRender", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 887, "start_line": 880}, "call_info": {"func_end_line": 387, "code": "  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r", "name": "queryExtraScreenLinesToRender", "func_location": "TextEditorComponent.updateSyncBeforeMeasuringContent", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 381, "func_start_line": 364}}, {"func_info": {"comment": [" Imperatively manipulate the class list of the root element to avoid", " clearing classes assigned by package authors."], "name": "TextEditorComponent.updateClassList", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "end_line": 857, "start_line": 829}, "call_info": {"func_end_line": 387, "code": "  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r", "name": "updateClassList", "func_location": "TextEditorComponent.updateSyncBeforeMeasuringContent", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/text-editor-component.js", "line": 384, "func_start_line": 364}}, {"func_info": {"comment": [" Essential: Get the active {Pane}'s active item.", "", " Returns an pane item {Object}."], "name": "Workspace.getActivePaneItem", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "end_line": 1359, "start_line": 1357}, "call_info": {"func_end_line": 604, "comment": [" Updates the application's title and proxy icon based on whichever file is", " open."], "code": "  updateWindowTitle () {\r\n    let itemPath, itemTitle, projectPath, representedPath\r\n    const appName = 'Atom'\r\n    const left = this.project.getPaths()\r\n    const projectPaths = left != null ? left : []\r\n    const item = this.getActivePaneItem()\r\n    if (item) {\r\n      itemPath = typeof item.getPath === 'function' ? item.getPath() : undefined\r\n      const longTitle = typeof item.getLongTitle === 'function' ? item.getLongTitle() : undefined\r\n      itemTitle = longTitle == null\r\n        ? (typeof item.getTitle === 'function' ? item.getTitle() : undefined)\r\n        : longTitle\r\n      projectPath = _.find(\r\n        projectPaths,\r\n        projectPath =>\r\n          (itemPath === projectPath) || (itemPath != null ? itemPath.startsWith(projectPath + path.sep) : undefined)\r\n      )\r\n    }\r\n    if (itemTitle == null) { itemTitle = 'untitled' }\r\n    if (projectPath == null) { projectPath = itemPath ? path.dirname(itemPath) : projectPaths[0] }\r\n    if (projectPath != null) {\r\n      projectPath = fs.tildify(projectPath)\r\n    }\r\n\r\n    const titleParts = []\r\n    if ((item != null) && (projectPath != null)) {\r\n      titleParts.push(itemTitle, projectPath)\r\n      representedPath = itemPath != null ? itemPath : projectPath\r\n    } else if (projectPath != null) {\r\n      titleParts.push(projectPath)\r\n      representedPath = projectPath\r\n    } else {\r\n      titleParts.push(itemTitle)\r\n      representedPath = ''\r\n    }\r\n\r\n    if (process.platform !== 'darwin') {\r\n      titleParts.push(appName)\r\n    }\r\n\r\n    document.title = titleParts.join(' \\u2014 ')\r\n    this.applicationDelegate.setRepresentedFilename(representedPath)\r\n    this.emitter.emit('did-change-window-title')\r\n  }\r", "name": "getActivePaneItem", "func_location": "Workspace.updateWindowTitle", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/workspace.js", "line": 566, "func_start_line": 561}}, {"func_info": {"comment": [], "name": "transformDeprecatedShadowDOMSelectors", "params": ["css", "context"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js", "end_line": 331, "start_line": 263}, "call_info": {"func_end_line": 207, "code": "  upgradeDeprecatedSelectorsForStyleSheet (styleSheet, context) {\r\n    if (this.cacheDirPath != null) {\r\n      const hash = crypto.createHash('sha1')\r\n      if (context != null) {\r\n        hash.update(context)\r\n      }\r\n      hash.update(styleSheet)\r\n      const cacheFilePath = path.join(this.cacheDirPath, hash.digest('hex'))\r\n      try {\r\n        return JSON.parse(fs.readFileSync(cacheFilePath))\r\n      } catch (e) {\r\n        const transformed = transformDeprecatedShadowDOMSelectors(styleSheet, context)\r\n        fs.writeFileSync(cacheFilePath, JSON.stringify(transformed))\r\n        return transformed\r\n      }\r\n    } else {\r\n      return transformDeprecatedShadowDOMSelectors(styleSheet, context)\r\n    }\r\n  }\r", "name": "transformDeprecatedShadowDOMSelectors", "func_location": "StyleManager.upgradeDeprecatedSelectorsForStyleSheet", "args": ["styleSheet", "context"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js", "line": 200, "func_start_line": 189}}, {"func_info": {"comment": [], "name": "transformDeprecatedShadowDOMSelectors", "params": ["css", "context"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js", "end_line": 331, "start_line": 263}, "call_info": {"func_end_line": 207, "code": "  upgradeDeprecatedSelectorsForStyleSheet (styleSheet, context) {\r\n    if (this.cacheDirPath != null) {\r\n      const hash = crypto.createHash('sha1')\r\n      if (context != null) {\r\n        hash.update(context)\r\n      }\r\n      hash.update(styleSheet)\r\n      const cacheFilePath = path.join(this.cacheDirPath, hash.digest('hex'))\r\n      try {\r\n        return JSON.parse(fs.readFileSync(cacheFilePath))\r\n      } catch (e) {\r\n        const transformed = transformDeprecatedShadowDOMSelectors(styleSheet, context)\r\n        fs.writeFileSync(cacheFilePath, JSON.stringify(transformed))\r\n        return transformed\r\n      }\r\n    } else {\r\n      return transformDeprecatedShadowDOMSelectors(styleSheet, context)\r\n    }\r\n  }\r", "name": "transformDeprecatedShadowDOMSelectors", "func_location": "StyleManager.upgradeDeprecatedSelectorsForStyleSheet", "args": ["styleSheet", "context"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/style-manager.js", "line": 205, "func_start_line": 189}}, {"func_info": {"comment": [], "name": "compileFileAtPath", "params": ["compiler", "filePath", "extension"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/compile-cache.js", "end_line": 99, "start_line": 84}, "call_info": {"func_end_line": 236, "code": "      value: function (module, filePath) {\r\n        var code = compileFileAtPath(compiler, filePath, extension)\r\n        return module._compile(code, filePath)\r\n      }\r", "name": "compileFileAtPath", "func_location": "value", "args": ["compiler", "filePath", "extension"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/compile-cache.js", "line": 234, "func_start_line": 233}}, {"func_info": {"comment": [], "name": "ConfigFile.reload", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config-file.js", "end_line": 117, "start_line": 102}, "call_info": {"func_end_line": 92, "code": "  async watch (callback) {\r\n    if (!fs.existsSync(this.path)) {\r\n      fs.makeTreeSync(Path.dirname(this.path))\r\n      CSON.writeFileSync(this.path, {}, {flag: 'wx'})\r\n    }\r\n\r\n    await this.reload()\r\n\r\n    try {\r\n      const watcher = await watchPath(this.path, {}, events => {\r\n        if (events.some(event => EVENT_TYPES.has(event.action))) this.requestLoad()\r\n      })\r\n      return watcher\r\n    } catch (error) {\r\n      this.emitter.emit('did-error', dedent `\r\n        Unable to watch path: \\`${Path.basename(this.path)}\\`.\r\n\r\n        Make sure you have permissions to \\`${this.path}\\`.\r\n        On linux there are currently problems with watch sizes.\r\n        See [this document][watches] for more info.\r\n\r\n        [watches]:https://github.com/atom/atom/blob/master/docs/build-instructions/linux.md#typeerror-unable-to-watch-path\\\r\n      `)\r\n    }\r\n  }\r", "name": "reload", "func_location": "ConfigFile.watch", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/config-file.js", "line": 74, "func_start_line": 68}}, {"func_info": {"comment": [], "name": "tryStatFile", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js", "end_line": 147, "start_line": 141}, "call_info": {"func_end_line": 41, "code": "  async willSavePath (window, path) {\r\n    const stats = await tryStatFile(path)\r\n    if (!stats) return\r\n\r\n    const recoveryPath = Path.join(this.recoveryDirectory, RecoveryFile.fileNameForPath(path))\r\n    const recoveryFile =\r\n      this.recoveryFilesByFilePath.get(path) || new RecoveryFile(path, stats.mode, recoveryPath)\r\n\r\n    try {\r\n      await recoveryFile.retain()\r\n    } catch (err) {\r\n      console.log(`Couldn't retain ${recoveryFile.recoveryPath}. Code: ${err.code}. Message: ${err.message}`)\r\n      return\r\n    }\r\n\r\n    if (!this.recoveryFilesByWindow.has(window)) {\r\n      this.recoveryFilesByWindow.set(window, new Set())\r\n    }\r\n    if (!this.windowsByRecoveryFile.has(recoveryFile)) {\r\n      this.windowsByRecoveryFile.set(recoveryFile, new Set())\r\n    }\r\n\r\n    this.recoveryFilesByWindow.get(window).add(recoveryFile)\r\n    this.windowsByRecoveryFile.get(recoveryFile).add(window)\r\n    this.recoveryFilesByFilePath.set(path, recoveryFile)\r\n  }\r", "name": "tryStatFile", "func_location": "FileRecoveryService.willSavePath", "args": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js", "line": 17, "func_start_line": 16}}, {"func_info": {"comment": [], "name": "RecoveryFile.fileNameForPath", "params": ["path"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js", "end_line": 100, "start_line": 95}, "call_info": {"func_end_line": 41, "code": "  async willSavePath (window, path) {\r\n    const stats = await tryStatFile(path)\r\n    if (!stats) return\r\n\r\n    const recoveryPath = Path.join(this.recoveryDirectory, RecoveryFile.fileNameForPath(path))\r\n    const recoveryFile =\r\n      this.recoveryFilesByFilePath.get(path) || new RecoveryFile(path, stats.mode, recoveryPath)\r\n\r\n    try {\r\n      await recoveryFile.retain()\r\n    } catch (err) {\r\n      console.log(`Couldn't retain ${recoveryFile.recoveryPath}. Code: ${err.code}. Message: ${err.message}`)\r\n      return\r\n    }\r\n\r\n    if (!this.recoveryFilesByWindow.has(window)) {\r\n      this.recoveryFilesByWindow.set(window, new Set())\r\n    }\r\n    if (!this.windowsByRecoveryFile.has(recoveryFile)) {\r\n      this.windowsByRecoveryFile.set(recoveryFile, new Set())\r\n    }\r\n\r\n    this.recoveryFilesByWindow.get(window).add(recoveryFile)\r\n    this.windowsByRecoveryFile.get(recoveryFile).add(window)\r\n    this.recoveryFilesByFilePath.set(path, recoveryFile)\r\n  }\r", "name": "fileNameForPath", "func_location": "FileRecoveryService.willSavePath", "args": [".recoveryDirectory", null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/file-recovery-service.js", "line": 20, "func_start_line": 16}}, {"func_info": {"comment": [" Kill the process with the given pid."], "name": "AtomApplication.killProcess", "params": ["pid"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 966, "start_line": 957}, "call_info": {"func_end_line": 954, "code": "  windowDidClosePathWithWaitSession (window, initialPath) {\r\n    const waitSessions = this.waitSessionsByWindow.get(window)\r\n    if (!waitSessions) return\r\n    for (let i = waitSessions.length - 1; i >= 0; i--) {\r\n      const session = waitSessions[i]\r\n      session.remainingPaths.delete(initialPath)\r\n      if (session.remainingPaths.size === 0) {\r\n        this.killProcess(session.pid)\r\n        waitSessions.splice(i, 1)\r\n      }\r\n    }\r\n  }\r", "name": "killProcess", "func_location": "AtomApplication.windowDidClosePathWithWaitSession", "args": ["session.pid"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 950, "func_start_line": 943}}, {"func_info": {"comment": [], "name": "AtomApplication.getAllWindows", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "end_line": 323, "start_line": 321}, "call_info": {"func_end_line": 736, "comment": [" Returns the {AtomWindow} for the given paths."], "code": "  windowForPaths (pathsToOpen, devMode) {\r\n    return this.getAllWindows().find(window =>\r\n      window.devMode === devMode && window.containsPaths(pathsToOpen)\r\n    )\r\n  }\r", "name": "getAllWindows", "func_location": "AtomApplication.windowForPaths", "args": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/main-process/atom-application.js", "line": 733, "func_start_line": 732}}, {"func_info": {"comment": ["\r\n  Section: Private\r\n  "], "name": "Cursor.getNonWordCharacters", "params": [], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "end_line": 718, "start_line": 716}, "call_info": {"func_end_line": 681, "comment": [" Public: Get the RegExp used by the cursor to determine what a \"word\" is.", "", " * `options` (optional) {Object} with the following keys:", "   * `includeNonWordCharacters` A {Boolean} indicating whether to include", "     non-word characters in the regex. (default: true)", "", " Returns a {RegExp}."], "code": "  wordRegExp (options) {\r\n    const nonWordCharacters = _.escapeRegExp(this.getNonWordCharacters())\r\n    let source = `^[\\t ]*$|[^\\\\s${nonWordCharacters}]+`\r\n    if (!options || options.includeNonWordCharacters !== false) {\r\n      source += `|${`[${nonWordCharacters}]+`}`\r\n    }\r\n    return new RegExp(source, 'g')\r\n  }\r", "name": "getNonWordCharacters", "func_location": "Cursor.wordRegExp", "args": [null], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/cursor.js", "line": 675, "func_start_line": 674}}, {"func_info": {"comment": [" Creates an `md5` hash of some text.", "", " * `text` A {String} to hash.", "", " Returns a hashed {String}."], "name": "Clipboard.md5", "params": ["text"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/clipboard.js", "end_line": 33, "start_line": 31}, "call_info": {"func_end_line": 46, "comment": [" Public: Write the given text to the clipboard.", "", " The metadata associated with the text is available by calling", " {::readWithMetadata}.", "", " * `text` The {String} to store.", " * `metadata` (optional) The additional info to associate with the text."], "code": "  write (text, metadata) {\r\n    this.signatureForMetadata = this.md5(text)\r\n    this.metadata = metadata\r\n    clipboard.writeText(text)\r\n  }\r", "name": "md5", "func_location": "Clipboard.write", "args": ["text"], "file": "/home/zcl/Desktop/parametermismatch/dataset/atom/src/clipboard.js", "line": 43, "func_start_line": 42}}]