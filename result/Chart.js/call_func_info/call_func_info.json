[{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"indexMode","line":218,"func_location":"module.exports.modes.'x-axis'","func_start_line":217,"func_end_line":219,"args":["chart","e",null],"comment":["*\r\n\t\t * @function Chart.Interaction.modes.x-axis\r\n\t\t * @deprecated since version 2.4.0. Use index mode and intersect == true\r\n\t\t * @todo remove at version 3\r\n\t\t * @private\r\n\t\t "],"code":"\t\t'x-axis': function(chart, e) {\r\n\t\t\treturn indexMode(chart, e, {intersect: false});\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"indexMode","start_line":112,"end_line":137,"comment":[],"params":["chart","e","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.linear.js","name":"IDMatches","line":45,"func_location":"module.exports.LinearScale.determineDataLimits.(unnamed_function_1)","func_start_line":39,"func_end_line":49,"args":["datasetIndex"],"code":"\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\r\n\t\t\t\t\tif (hasStacks) {\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\r\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\r\n\t\t\t\t\t\tmeta.stack !== undefined) {\r\n\t\t\t\t\t\thasStacks = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.linear.js","name":"module.exports.LinearScale.determineDataLimits.IDMatches","start_line":29,"end_line":31,"comment":[],"params":["meta"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.logarithmic.js","name":"IDMatches","line":96,"func_location":"module.exports.LogarithmicScale.determineDataLimits.(unnamed_function_1)","func_start_line":90,"func_end_line":100,"args":["datasetIndex"],"code":"\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\r\n\t\t\t\t\tif (hasStacks) {\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\r\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\r\n\t\t\t\t\t\tmeta.stack !== undefined) {\r\n\t\t\t\t\t\thasStacks = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.logarithmic.js","name":"module.exports.LogarithmicScale.determineDataLimits.IDMatches","start_line":79,"end_line":81,"comment":[],"params":["meta"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.scale.js","name":"getPixelForGridLine","line":798,"func_location":"draw.(unnamed_function_1)","func_start_line":774,"func_end_line":872,"args":["me","index","gridLines.offsetGridLines"],"comment":[" 0.0000001 is margin in pixels for Accumulated error."],"code":"\t\thelpers.each(ticks, function(tick, index) {\r\n\t\t\t// autoskipper skipped this tick (#4635)\r\n\t\t\tif (helpers.isNullOrUndef(tick.label)) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar label = tick.label;\r\n\t\t\tvar lineWidth, lineColor, borderDash, borderDashOffset;\r\n\t\t\tif (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {\r\n\t\t\t\t// Draw the first index specially\r\n\t\t\t\tlineWidth = gridLines.zeroLineWidth;\r\n\t\t\t\tlineColor = gridLines.zeroLineColor;\r\n\t\t\t\tborderDash = gridLines.zeroLineBorderDash || [];\r\n\t\t\t\tborderDashOffset = gridLines.zeroLineBorderDashOffset || 0.0;\r\n\t\t\t} else {\r\n\t\t\t\tlineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, index);\r\n\t\t\t\tlineColor = helpers.valueAtIndexOrDefault(gridLines.color, index);\r\n\t\t\t\tborderDash = gridLines.borderDash || [];\r\n\t\t\t\tborderDashOffset = gridLines.borderDashOffset || 0.0;\r\n\t\t\t}\r\n\r\n\t\t\t// Common properties\r\n\t\t\tvar tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY, textOffset, textAlign;\r\n\t\t\tvar labelCount = helpers.isArray(label) ? label.length : 1;\r\n\t\t\tvar lineValue = getPixelForGridLine(me, index, gridLines.offsetGridLines);\r\n\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\tvar labelYOffset = tl + tickPadding;\r\n\r\n\t\t\t\tif (lineValue < me.left - epsilon) {\r\n\t\t\t\t\tlineColor = 'rgba(0,0,0,0)';\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttx1 = tx2 = x1 = x2 = alignPixel(chart, lineValue, lineWidth);\r\n\t\t\t\tty1 = tickStart;\r\n\t\t\t\tty2 = tickEnd;\r\n\t\t\t\tlabelX = me.getPixelForTick(index) + labelOffset; // x values for optionTicks (need to consider offsetLabel option)\r\n\r\n\t\t\t\tif (position === 'top') {\r\n\t\t\t\t\ty1 = alignPixel(chart, chartArea.top, axisWidth) + axisWidth / 2;\r\n\t\t\t\t\ty2 = chartArea.bottom;\r\n\t\t\t\t\ttextOffset = ((!isRotated ? 0.5 : 1) - labelCount) * lineHeight;\r\n\t\t\t\t\ttextAlign = !isRotated ? 'center' : 'left';\r\n\t\t\t\t\tlabelY = me.bottom - labelYOffset;\r\n\t\t\t\t} else {\r\n\t\t\t\t\ty1 = chartArea.top;\r\n\t\t\t\t\ty2 = alignPixel(chart, chartArea.bottom, axisWidth) - axisWidth / 2;\r\n\t\t\t\t\ttextOffset = (!isRotated ? 0.5 : 0) * lineHeight;\r\n\t\t\t\t\ttextAlign = !isRotated ? 'center' : 'right';\r\n\t\t\t\t\tlabelY = me.top + labelYOffset;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar labelXOffset = (isMirrored ? 0 : tl) + tickPadding;\r\n\r\n\t\t\t\tif (lineValue < me.top - epsilon) {\r\n\t\t\t\t\tlineColor = 'rgba(0,0,0,0)';\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttx1 = tickStart;\r\n\t\t\t\ttx2 = tickEnd;\r\n\t\t\t\tty1 = ty2 = y1 = y2 = alignPixel(chart, lineValue, lineWidth);\r\n\t\t\t\tlabelY = me.getPixelForTick(index) + labelOffset;\r\n\t\t\t\ttextOffset = (1 - labelCount) * lineHeight / 2;\r\n\r\n\t\t\t\tif (position === 'left') {\r\n\t\t\t\t\tx1 = alignPixel(chart, chartArea.left, axisWidth) + axisWidth / 2;\r\n\t\t\t\t\tx2 = chartArea.right;\r\n\t\t\t\t\ttextAlign = isMirrored ? 'left' : 'right';\r\n\t\t\t\t\tlabelX = me.right - labelXOffset;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tx1 = chartArea.left;\r\n\t\t\t\t\tx2 = alignPixel(chart, chartArea.right, axisWidth) - axisWidth / 2;\r\n\t\t\t\t\ttextAlign = isMirrored ? 'right' : 'left';\r\n\t\t\t\t\tlabelX = me.left + labelXOffset;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\titemsToDraw.push({\r\n\t\t\t\ttx1: tx1,\r\n\t\t\t\tty1: ty1,\r\n\t\t\t\ttx2: tx2,\r\n\t\t\t\tty2: ty2,\r\n\t\t\t\tx1: x1,\r\n\t\t\t\ty1: y1,\r\n\t\t\t\tx2: x2,\r\n\t\t\t\ty2: y2,\r\n\t\t\t\tlabelX: labelX,\r\n\t\t\t\tlabelY: labelY,\r\n\t\t\t\tglWidth: lineWidth,\r\n\t\t\t\tglColor: lineColor,\r\n\t\t\t\tglBorderDash: borderDash,\r\n\t\t\t\tglBorderDashOffset: borderDashOffset,\r\n\t\t\t\trotation: -1 * labelRotationRadians,\r\n\t\t\t\tlabel: label,\r\n\t\t\t\tmajor: tick.major,\r\n\t\t\t\ttextOffset: textOffset,\r\n\t\t\t\ttextAlign: textAlign\r\n\t\t\t});\r\n\t\t});\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.scale.js","name":"getPixelForGridLine","start_line":76,"end_line":91,"comment":[],"params":["scale","index","offsetGridLines"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"fromNativeEvent","line":417,"func_location":"module.exports.addEventListener.proxy.(unnamed_function_10)","func_start_line":416,"func_end_line":418,"args":[null],"code":"\t\tvar proxy = proxies[chart.id + '_' + type] = function(event) {\r\n\t\t\tlistener(fromNativeEvent(event, chart));\r\n\t\t};\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"fromNativeEvent","start_line":145,"end_line":149,"comment":[],"params":["event","chart"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.linear.js","name":"IDMatches","line":75,"func_location":"module.exports.LinearScale.determineDataLimits.(unnamed_function_2)","func_start_line":55,"func_end_line":94,"args":["datasetIndex"],"code":"\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\r\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\r\n\t\t\t\t\tvar key = [\r\n\t\t\t\t\t\tmeta.type,\r\n\t\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\r\n\t\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\r\n\t\t\t\t\t\tmeta.stack\r\n\t\t\t\t\t].join('.');\r\n\r\n\t\t\t\t\tif (valuesPerStack[key] === undefined) {\r\n\t\t\t\t\t\tvaluesPerStack[key] = {\r\n\t\t\t\t\t\t\tpositiveValues: [],\r\n\t\t\t\t\t\t\tnegativeValues: []\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Store these per type\r\n\t\t\t\t\tvar positiveValues = valuesPerStack[key].positiveValues;\r\n\t\t\t\t\tvar negativeValues = valuesPerStack[key].negativeValues;\r\n\r\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\r\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\r\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\r\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tpositiveValues[index] = positiveValues[index] || 0;\r\n\t\t\t\t\t\t\tnegativeValues[index] = negativeValues[index] || 0;\r\n\r\n\t\t\t\t\t\t\tif (opts.relativePoints) {\r\n\t\t\t\t\t\t\t\tpositiveValues[index] = 100;\r\n\t\t\t\t\t\t\t} else if (value < 0) {\r\n\t\t\t\t\t\t\t\tnegativeValues[index] += value;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tpositiveValues[index] += value;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.linear.js","name":"module.exports.LinearScale.determineDataLimits.IDMatches","start_line":29,"end_line":31,"comment":[],"params":["meta"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.logarithmic.js","name":"IDMatches","line":115,"func_location":"module.exports.LogarithmicScale.determineDataLimits.(unnamed_function_2)","func_start_line":106,"func_end_line":131,"args":["datasetIndex"],"code":"\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\r\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\r\n\t\t\t\t\tvar key = [\r\n\t\t\t\t\t\tmeta.type,\r\n\t\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\r\n\t\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\r\n\t\t\t\t\t\tmeta.stack\r\n\t\t\t\t\t].join('.');\r\n\r\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\r\n\t\t\t\t\t\tif (valuesPerStack[key] === undefined) {\r\n\t\t\t\t\t\t\tvaluesPerStack[key] = [];\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\r\n\t\t\t\t\t\t\tvar values = valuesPerStack[key];\r\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\r\n\t\t\t\t\t\t\t// invalid, hidden and negative values are ignored\r\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden || value < 0) {\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvalues[index] = values[index] || 0;\r\n\t\t\t\t\t\t\tvalues[index] += value;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.logarithmic.js","name":"module.exports.LogarithmicScale.determineDataLimits.IDMatches","start_line":79,"end_line":81,"comment":[],"params":["meta"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"pushOrConcat","line":515,"func_location":"exports.getBody.(unnamed_function_3)","func_start_line":509,"func_end_line":520,"args":["bodyItem.before",null],"code":"\t\thelpers.each(tooltipItems, function(tooltipItem) {\r\n\t\t\tvar bodyItem = {\r\n\t\t\t\tbefore: [],\r\n\t\t\t\tlines: [],\r\n\t\t\t\tafter: []\r\n\t\t\t};\r\n\t\t\tpushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));\r\n\t\t\tpushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));\r\n\t\t\tpushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));\r\n\r\n\t\t\tbodyItems.push(bodyItem);\r\n\t\t});\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"pushOrConcat","start_line":172,"end_line":183,"comment":[" Helper to push or concat based on if the 2nd parameter is an array or not"],"params":["base","toPush"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"splitNewlines","line":515,"func_location":"exports.getBody.(unnamed_function_3)","func_start_line":509,"func_end_line":520,"args":["bodyItem.before",null],"code":"\t\thelpers.each(tooltipItems, function(tooltipItem) {\r\n\t\t\tvar bodyItem = {\r\n\t\t\t\tbefore: [],\r\n\t\t\t\tlines: [],\r\n\t\t\t\tafter: []\r\n\t\t\t};\r\n\t\t\tpushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));\r\n\t\t\tpushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));\r\n\t\t\tpushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));\r\n\r\n\t\t\tbodyItems.push(bodyItem);\r\n\t\t});\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"splitNewlines","start_line":191,"end_line":196,"comment":["*\r\n * Returns array of strings split by newline\r\n * @param {String} value - The value to split by newline.\r\n * @returns {Array} value if newline present - Returned from String split() method\r\n * @function\r\n "],"params":["str"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"pushOrConcat","line":516,"func_location":"exports.getBody.(unnamed_function_3)","func_start_line":509,"func_end_line":520,"args":["bodyItem.lines",null],"code":"\t\thelpers.each(tooltipItems, function(tooltipItem) {\r\n\t\t\tvar bodyItem = {\r\n\t\t\t\tbefore: [],\r\n\t\t\t\tlines: [],\r\n\t\t\t\tafter: []\r\n\t\t\t};\r\n\t\t\tpushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));\r\n\t\t\tpushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));\r\n\t\t\tpushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));\r\n\r\n\t\t\tbodyItems.push(bodyItem);\r\n\t\t});\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"pushOrConcat","start_line":172,"end_line":183,"comment":[" Helper to push or concat based on if the 2nd parameter is an array or not"],"params":["base","toPush"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"pushOrConcat","line":517,"func_location":"exports.getBody.(unnamed_function_3)","func_start_line":509,"func_end_line":520,"args":["bodyItem.after",null],"code":"\t\thelpers.each(tooltipItems, function(tooltipItem) {\r\n\t\t\tvar bodyItem = {\r\n\t\t\t\tbefore: [],\r\n\t\t\t\tlines: [],\r\n\t\t\t\tafter: []\r\n\t\t\t};\r\n\t\t\tpushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));\r\n\t\t\tpushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));\r\n\t\t\tpushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));\r\n\r\n\t\t\tbodyItems.push(bodyItem);\r\n\t\t});\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"pushOrConcat","start_line":172,"end_line":183,"comment":[" Helper to push or concat based on if the 2nd parameter is an array or not"],"params":["base","toPush"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"splitNewlines","line":517,"func_location":"exports.getBody.(unnamed_function_3)","func_start_line":509,"func_end_line":520,"args":["bodyItem.after",null],"code":"\t\thelpers.each(tooltipItems, function(tooltipItem) {\r\n\t\t\tvar bodyItem = {\r\n\t\t\t\tbefore: [],\r\n\t\t\t\tlines: [],\r\n\t\t\t\tafter: []\r\n\t\t\t};\r\n\t\t\tpushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));\r\n\t\t\tpushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));\r\n\t\t\tpushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));\r\n\r\n\t\t\tbodyItems.push(bodyItem);\r\n\t\t});\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"splitNewlines","start_line":191,"end_line":196,"comment":["*\r\n * Returns array of strings split by newline\r\n * @param {String} value - The value to split by newline.\r\n * @returns {Array} value if newline present - Returned from String split() method\r\n * @function\r\n "],"params":["str"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.legend.js","name":"getBoxWidth","line":246,"func_location":"Legend.fit.(unnamed_function_3)","func_start_line":245,"func_end_line":263,"args":["labelOpts","fontSize"],"code":"\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\r\n\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\r\n\t\t\t\t\tvar width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\r\n\r\n\t\t\t\t\tif (i === 0 || lineWidths[lineWidths.length - 1] + width + labelOpts.padding > minSize.width) {\r\n\t\t\t\t\t\ttotalHeight += fontSize + labelOpts.padding;\r\n\t\t\t\t\t\tlineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = labelOpts.padding;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\r\n\t\t\t\t\thitboxes[i] = {\r\n\t\t\t\t\t\tleft: 0,\r\n\t\t\t\t\t\ttop: 0,\r\n\t\t\t\t\t\twidth: width,\r\n\t\t\t\t\t\theight: fontSize\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tlineWidths[lineWidths.length - 1] += width + labelOpts.padding;\r\n\t\t\t\t});\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.legend.js","name":"getBoxWidth","start_line":91,"end_line":95,"comment":["*\r\n * Helper function to get the box width based on the usePointStyle option\r\n * @param labelopts {Object} the label options on the legend\r\n * @param fontSize {Number} the label font size\r\n * @return {Number} width of the color box area\r\n "],"params":["labelOpts","fontSize"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"drawRadiusLine","line":491,"func_location":"module.exports.LinearRadialScale.draw.(unnamed_function_3)","func_start_line":484,"func_end_line":520,"args":["me","gridLineOpts","yCenterOffset","index"],"code":"\t\t\t\thelpers.each(me.ticks, function(label, index) {\r\n\t\t\t\t\t// Don't draw a centre value (if it is minimum)\r\n\t\t\t\t\tif (index > 0 || tickOpts.reverse) {\r\n\t\t\t\t\t\tvar yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\r\n\r\n\t\t\t\t\t\t// Draw circular lines around the scale\r\n\t\t\t\t\t\tif (gridLineOpts.display && index !== 0) {\r\n\t\t\t\t\t\t\tdrawRadiusLine(me, gridLineOpts, yCenterOffset, index);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (tickOpts.display) {\r\n\t\t\t\t\t\t\tvar tickFontColor = valueOrDefault(tickOpts.fontColor, defaults.global.defaultFontColor);\r\n\t\t\t\t\t\t\tctx.font = tickFont.string;\r\n\r\n\t\t\t\t\t\t\tctx.save();\r\n\t\t\t\t\t\t\tctx.translate(me.xCenter, me.yCenter);\r\n\t\t\t\t\t\t\tctx.rotate(startAngle);\r\n\r\n\t\t\t\t\t\t\tif (tickOpts.showLabelBackdrop) {\r\n\t\t\t\t\t\t\t\tvar labelWidth = ctx.measureText(label).width;\r\n\t\t\t\t\t\t\t\tctx.fillStyle = tickOpts.backdropColor;\r\n\t\t\t\t\t\t\t\tctx.fillRect(\r\n\t\t\t\t\t\t\t\t\t-labelWidth / 2 - tickOpts.backdropPaddingX,\r\n\t\t\t\t\t\t\t\t\t-yCenterOffset - tickFont.size / 2 - tickOpts.backdropPaddingY,\r\n\t\t\t\t\t\t\t\t\tlabelWidth + tickOpts.backdropPaddingX * 2,\r\n\t\t\t\t\t\t\t\t\ttickFont.size + tickOpts.backdropPaddingY * 2\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tctx.textAlign = 'center';\r\n\t\t\t\t\t\t\tctx.textBaseline = 'middle';\r\n\t\t\t\t\t\t\tctx.fillStyle = tickFontColor;\r\n\t\t\t\t\t\t\tctx.fillText(label, 0, -yCenterOffset);\r\n\t\t\t\t\t\t\tctx.restore();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"module.exports.drawRadiusLine","start_line":277,"end_line":314,"comment":[],"params":["scale","gridLineOpts","radius","index"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"addEventListener","line":242,"func_location":"watchForRender.(unnamed_function_4)","func_start_line":241,"func_end_line":243,"args":["node","type","proxy"],"code":"\thelpers.each(ANIMATION_START_EVENTS, function(type) {\r\n\t\taddEventListener(node, type, proxy);\r\n\t});\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"addEventListener","start_line":127,"end_line":129,"comment":[],"params":["node","type","listener"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.legend.js","name":"getBoxWidth","line":276,"func_location":"Legend.fit.(unnamed_function_4)","func_start_line":275,"func_end_line":299,"args":["labelOpts","fontSize"],"code":"\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\r\n\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\r\n\t\t\t\t\tvar itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\r\n\r\n\t\t\t\t\t// If too tall, go to new column\r\n\t\t\t\t\tif (i > 0 && currentColHeight + itemHeight > minSize.height - vPadding) {\r\n\t\t\t\t\t\ttotalWidth += currentColWidth + labelOpts.padding;\r\n\t\t\t\t\t\tcolumnWidths.push(currentColWidth); // previous column width\r\n\r\n\t\t\t\t\t\tcurrentColWidth = 0;\r\n\t\t\t\t\t\tcurrentColHeight = 0;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Get max width\r\n\t\t\t\t\tcurrentColWidth = Math.max(currentColWidth, itemWidth);\r\n\t\t\t\t\tcurrentColHeight += itemHeight;\r\n\r\n\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\r\n\t\t\t\t\thitboxes[i] = {\r\n\t\t\t\t\t\tleft: 0,\r\n\t\t\t\t\t\ttop: 0,\r\n\t\t\t\t\t\twidth: itemWidth,\r\n\t\t\t\t\t\theight: fontSize\r\n\t\t\t\t\t};\r\n\t\t\t\t});\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.legend.js","name":"getBoxWidth","start_line":91,"end_line":95,"comment":["*\r\n * Helper function to get the box width based on the usePointStyle option\r\n * @param labelopts {Object} the label options on the legend\r\n * @param fontSize {Number} the label font size\r\n * @return {Number} width of the color box area\r\n "],"params":["labelOpts","fontSize"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"removeEventListener","line":261,"func_location":"unwatchForRender.(unnamed_function_5)","func_start_line":260,"func_end_line":262,"args":["node","type","proxy"],"code":"\t\thelpers.each(ANIMATION_START_EVENTS, function(type) {\r\n\t\t\tremoveEventListener(node, type, proxy);\r\n\t\t});\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"removeEventListener","start_line":131,"end_line":133,"comment":[],"params":["node","type","listener"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.legend.js","name":"drawLegendBox","line":444,"func_location":"Legend.draw.(unnamed_function_5)","func_start_line":423,"func_end_line":458,"args":["x","y","legendItem"],"code":"\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\r\n\t\t\t\tvar textWidth = ctx.measureText(legendItem.text).width;\r\n\t\t\t\tvar width = boxWidth + (fontSize / 2) + textWidth;\r\n\t\t\t\tvar x = cursor.x;\r\n\t\t\t\tvar y = cursor.y;\r\n\r\n\t\t\t\t// Use (me.left + me.minSize.width) and (me.top + me.minSize.height)\r\n\t\t\t\t// instead of me.right and me.bottom because me.width and me.height\r\n\t\t\t\t// may have been changed since me.minSize was calculated\r\n\t\t\t\tif (isHorizontal) {\r\n\t\t\t\t\tif (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {\r\n\t\t\t\t\t\ty = cursor.y += itemHeight;\r\n\t\t\t\t\t\tcursor.line++;\r\n\t\t\t\t\t\tx = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2) + labelOpts.padding;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {\r\n\t\t\t\t\tx = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\r\n\t\t\t\t\ty = cursor.y = me.top + labelOpts.padding;\r\n\t\t\t\t\tcursor.line++;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdrawLegendBox(x, y, legendItem);\r\n\r\n\t\t\t\thitboxes[i].left = x;\r\n\t\t\t\thitboxes[i].top = y;\r\n\r\n\t\t\t\t// Fill the actual label\r\n\t\t\t\tfillText(x, y, legendItem, textWidth);\r\n\r\n\t\t\t\tif (isHorizontal) {\r\n\t\t\t\t\tcursor.x += width + labelOpts.padding;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcursor.y += itemHeight;\r\n\t\t\t\t}\r\n\r\n\t\t\t});\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.legend.js","name":"Legend.draw.drawLegendBox","start_line":348,"end_line":388,"comment":[" current position"],"params":["x","y","legendItem"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.legend.js","name":"fillText","line":450,"func_location":"Legend.draw.(unnamed_function_5)","func_start_line":423,"func_end_line":458,"args":["x","y","legendItem","textWidth"],"code":"\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\r\n\t\t\t\tvar textWidth = ctx.measureText(legendItem.text).width;\r\n\t\t\t\tvar width = boxWidth + (fontSize / 2) + textWidth;\r\n\t\t\t\tvar x = cursor.x;\r\n\t\t\t\tvar y = cursor.y;\r\n\r\n\t\t\t\t// Use (me.left + me.minSize.width) and (me.top + me.minSize.height)\r\n\t\t\t\t// instead of me.right and me.bottom because me.width and me.height\r\n\t\t\t\t// may have been changed since me.minSize was calculated\r\n\t\t\t\tif (isHorizontal) {\r\n\t\t\t\t\tif (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {\r\n\t\t\t\t\t\ty = cursor.y += itemHeight;\r\n\t\t\t\t\t\tcursor.line++;\r\n\t\t\t\t\t\tx = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2) + labelOpts.padding;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {\r\n\t\t\t\t\tx = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\r\n\t\t\t\t\ty = cursor.y = me.top + labelOpts.padding;\r\n\t\t\t\t\tcursor.line++;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdrawLegendBox(x, y, legendItem);\r\n\r\n\t\t\t\thitboxes[i].left = x;\r\n\t\t\t\thitboxes[i].top = y;\r\n\r\n\t\t\t\t// Fill the actual label\r\n\t\t\t\tfillText(x, y, legendItem, textWidth);\r\n\r\n\t\t\t\tif (isHorizontal) {\r\n\t\t\t\t\tcursor.x += width + labelOpts.padding;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcursor.y += itemHeight;\r\n\t\t\t\t}\r\n\r\n\t\t\t});\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.legend.js","name":"Legend.draw.fillText","start_line":389,"end_line":404,"comment":[],"params":["x","y","legendItem","textWidth"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.linear.js","name":"IDMatches","line":107,"func_location":"module.exports.LinearScale.determineDataLimits.(unnamed_function_5)","func_start_line":105,"func_end_line":127,"args":["datasetIndex"],"code":"\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\r\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\r\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\r\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\r\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\r\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (me.min === null) {\r\n\t\t\t\t\t\t\t\tme.min = value;\r\n\t\t\t\t\t\t\t} else if (value < me.min) {\r\n\t\t\t\t\t\t\t\tme.min = value;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (me.max === null) {\r\n\t\t\t\t\t\t\t\tme.max = value;\r\n\t\t\t\t\t\t\t} else if (value > me.max) {\r\n\t\t\t\t\t\t\t\tme.max = value;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.linear.js","name":"module.exports.LinearScale.determineDataLimits.IDMatches","start_line":29,"end_line":31,"comment":[],"params":["meta"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.logarithmic.js","name":"IDMatches","line":145,"func_location":"module.exports.LogarithmicScale.determineDataLimits.(unnamed_function_5)","func_start_line":143,"func_end_line":170,"args":["datasetIndex"],"code":"\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\r\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\r\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\r\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\r\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\r\n\t\t\t\t\t\t\t// invalid, hidden and negative values are ignored\r\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden || value < 0) {\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (me.min === null) {\r\n\t\t\t\t\t\t\t\tme.min = value;\r\n\t\t\t\t\t\t\t} else if (value < me.min) {\r\n\t\t\t\t\t\t\t\tme.min = value;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (me.max === null) {\r\n\t\t\t\t\t\t\t\tme.max = value;\r\n\t\t\t\t\t\t\t} else if (value > me.max) {\r\n\t\t\t\t\t\t\t\tme.max = value;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {\r\n\t\t\t\t\t\t\t\tme.minNotZero = value;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.logarithmic.js","name":"module.exports.LogarithmicScale.determineDataLimits.IDMatches","start_line":79,"end_line":81,"comment":[],"params":["meta"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"createEvent","line":276,"func_location":"addResizeListener.resizer.(unnamed_function_6)","func_start_line":274,"func_end_line":278,"args":[null],"comment":[" Let's keep track of this added resizer and thus avoid DOM query when removing it."],"code":"\tvar resizer = expando.resizer = createResizer(throttled(function() {\r\n\t\tif (expando.resizer) {\r\n\t\t\treturn listener(createEvent('resize', chart));\r\n\t\t}\r\n\t}));\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"createEvent","start_line":135,"end_line":143,"comment":[],"params":["type","chart","x","y","nativeEvent"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.controller.js","name":"positionIsHorizontal","line":270,"func_location":"buildOrUpdateScales.(unnamed_function_7)","func_start_line":265,"func_end_line":304,"args":["scaleOptions.position"],"code":"\t\t\thelpers.each(items, function(item) {\r\n\t\t\t\tvar scaleOptions = item.options;\r\n\t\t\t\tvar id = scaleOptions.id;\r\n\t\t\t\tvar scaleType = helpers.valueOrDefault(scaleOptions.type, item.dtype);\r\n\r\n\t\t\t\tif (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {\r\n\t\t\t\t\tscaleOptions.position = item.dposition;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tupdated[id] = true;\r\n\t\t\t\tvar scale = null;\r\n\t\t\t\tif (id in scales && scales[id].type === scaleType) {\r\n\t\t\t\t\tscale = scales[id];\r\n\t\t\t\t\tscale.options = scaleOptions;\r\n\t\t\t\t\tscale.ctx = me.ctx;\r\n\t\t\t\t\tscale.chart = me;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar scaleClass = scaleService.getScaleConstructor(scaleType);\r\n\t\t\t\t\tif (!scaleClass) {\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tscale = new scaleClass({\r\n\t\t\t\t\t\tid: id,\r\n\t\t\t\t\t\ttype: scaleType,\r\n\t\t\t\t\t\toptions: scaleOptions,\r\n\t\t\t\t\t\tctx: me.ctx,\r\n\t\t\t\t\t\tchart: me\r\n\t\t\t\t\t});\r\n\t\t\t\t\tscales[scale.id] = scale;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tscale.mergeTicksOptions();\r\n\r\n\t\t\t\t// TODO(SB): I think we should be able to remove this custom case (options.scale)\r\n\t\t\t\t// and consider it as a regular scale part of the \"scales\"\" map only! This would\r\n\t\t\t\t// make the logic easier and remove some useless? custom code.\r\n\t\t\t\tif (item.isDefault) {\r\n\t\t\t\t\tme.scale = scale;\r\n\t\t\t\t}\r\n\t\t\t});\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.controller.js","name":"module.exports.positionIsHorizontal","start_line":68,"end_line":70,"comment":[],"params":["position"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.controller.js","name":"positionIsHorizontal","line":270,"func_location":"buildOrUpdateScales.(unnamed_function_7)","func_start_line":265,"func_end_line":304,"args":["scaleOptions.position"],"code":"\t\t\thelpers.each(items, function(item) {\r\n\t\t\t\tvar scaleOptions = item.options;\r\n\t\t\t\tvar id = scaleOptions.id;\r\n\t\t\t\tvar scaleType = helpers.valueOrDefault(scaleOptions.type, item.dtype);\r\n\r\n\t\t\t\tif (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {\r\n\t\t\t\t\tscaleOptions.position = item.dposition;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tupdated[id] = true;\r\n\t\t\t\tvar scale = null;\r\n\t\t\t\tif (id in scales && scales[id].type === scaleType) {\r\n\t\t\t\t\tscale = scales[id];\r\n\t\t\t\t\tscale.options = scaleOptions;\r\n\t\t\t\t\tscale.ctx = me.ctx;\r\n\t\t\t\t\tscale.chart = me;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar scaleClass = scaleService.getScaleConstructor(scaleType);\r\n\t\t\t\t\tif (!scaleClass) {\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tscale = new scaleClass({\r\n\t\t\t\t\t\tid: id,\r\n\t\t\t\t\t\ttype: scaleType,\r\n\t\t\t\t\t\toptions: scaleOptions,\r\n\t\t\t\t\t\tctx: me.ctx,\r\n\t\t\t\t\t\tchart: me\r\n\t\t\t\t\t});\r\n\t\t\t\t\tscales[scale.id] = scale;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tscale.mergeTicksOptions();\r\n\r\n\t\t\t\t// TODO(SB): I think we should be able to remove this custom case (options.scale)\r\n\t\t\t\t// and consider it as a regular scale part of the \"scales\"\" map only! This would\r\n\t\t\t\t// make the logic easier and remove some useless? custom code.\r\n\t\t\t\tif (item.isDefault) {\r\n\t\t\t\t\tme.scale = scale;\r\n\t\t\t\t}\r\n\t\t\t});\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.controller.js","name":"module.exports.positionIsHorizontal","start_line":68,"end_line":70,"comment":[],"params":["position"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"fillLineOfText","line":801,"func_location":"exports.drawBody.(unnamed_function_7).(unnamed_function_8)","func_start_line":783,"func_end_line":802,"args":["line"],"code":"\t\t\thelpers.each(bodyItem.lines, function(line) {\r\n\t\t\t\t// Draw Legend-like boxes if needed\r\n\t\t\t\tif (drawColorBoxes) {\r\n\t\t\t\t\t// Fill a white rect so that colours merge nicely if the opacity is < 1\r\n\t\t\t\t\tctx.fillStyle = vm.legendColorBackground;\r\n\t\t\t\t\tctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\r\n\r\n\t\t\t\t\t// Border\r\n\t\t\t\t\tctx.lineWidth = 1;\r\n\t\t\t\t\tctx.strokeStyle = vm.labelColors[i].borderColor;\r\n\t\t\t\t\tctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\r\n\r\n\t\t\t\t\t// Inner square\r\n\t\t\t\t\tctx.fillStyle = vm.labelColors[i].backgroundColor;\r\n\t\t\t\t\tctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);\r\n\t\t\t\t\tctx.fillStyle = textColor;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfillLineOfText(line);\r\n\t\t\t});\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"exports.drawBody.fillLineOfText","start_line":765,"end_line":768,"comment":[],"params":["line"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"isObject","line":202,"func_location":"helpers._merger","func_start_line":198,"func_end_line":207,"args":["tval"],"comment":["*\r\n\t * The default merger when Chart.helpers.merge is called without merger option.\r\n\t * Note(SB): this method is also used by configMerge and scaleMerge as fallback.\r\n\t * @private\r\n\t "],"code":"\t_merger: function(key, target, source, options) {\r\n\t\tvar tval = target[key];\r\n\t\tvar sval = source[key];\r\n\r\n\t\tif (helpers.isObject(tval) && helpers.isObject(sval)) {\r\n\t\t\thelpers.merge(tval, sval, options);\r\n\t\t} else {\r\n\t\t\ttarget[key] = helpers.clone(sval);\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"helpers.isObject","start_line":57,"end_line":59,"comment":["*\r\n\t * Returns true if `value` is an object (excluding null), else returns false.\r\n\t * @param {*} value - The value to test.\r\n\t * @returns {Boolean}\r\n\t * @since 2.7.0\r\n\t "],"params":["value"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"isObject","line":202,"func_location":"helpers._merger","func_start_line":198,"func_end_line":207,"args":["tval"],"comment":["*\r\n\t * The default merger when Chart.helpers.merge is called without merger option.\r\n\t * Note(SB): this method is also used by configMerge and scaleMerge as fallback.\r\n\t * @private\r\n\t "],"code":"\t_merger: function(key, target, source, options) {\r\n\t\tvar tval = target[key];\r\n\t\tvar sval = source[key];\r\n\r\n\t\tif (helpers.isObject(tval) && helpers.isObject(sval)) {\r\n\t\t\thelpers.merge(tval, sval, options);\r\n\t\t} else {\r\n\t\t\ttarget[key] = helpers.clone(sval);\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"helpers.isObject","start_line":57,"end_line":59,"comment":["*\r\n\t * Returns true if `value` is an object (excluding null), else returns false.\r\n\t * @param {*} value - The value to test.\r\n\t * @returns {Boolean}\r\n\t * @since 2.7.0\r\n\t "],"params":["value"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"clone","line":205,"func_location":"helpers._merger","func_start_line":198,"func_end_line":207,"args":["sval"],"comment":["*\r\n\t * The default merger when Chart.helpers.merge is called without merger option.\r\n\t * Note(SB): this method is also used by configMerge and scaleMerge as fallback.\r\n\t * @private\r\n\t "],"code":"\t_merger: function(key, target, source, options) {\r\n\t\tvar tval = target[key];\r\n\t\tvar sval = source[key];\r\n\r\n\t\tif (helpers.isObject(tval) && helpers.isObject(sval)) {\r\n\t\t\thelpers.merge(tval, sval, options);\r\n\t\t} else {\r\n\t\t\ttarget[key] = helpers.clone(sval);\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"helpers.clone","start_line":172,"end_line":191,"comment":["*\r\n\t * Returns a deep copy of `source` without keeping references on objects and arrays.\r\n\t * @param {*} source - The value to clone.\r\n\t * @returns {*}\r\n\t "],"params":["source"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"isObject","line":217,"func_location":"helpers._mergerIf","func_start_line":213,"func_end_line":222,"args":["tval"],"comment":["*\r\n\t * Merges source[key] in target[key] only if target[key] is undefined.\r\n\t * @private\r\n\t "],"code":"\t_mergerIf: function(key, target, source) {\r\n\t\tvar tval = target[key];\r\n\t\tvar sval = source[key];\r\n\r\n\t\tif (helpers.isObject(tval) && helpers.isObject(sval)) {\r\n\t\t\thelpers.mergeIf(tval, sval);\r\n\t\t} else if (!target.hasOwnProperty(key)) {\r\n\t\t\ttarget[key] = helpers.clone(sval);\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"helpers.isObject","start_line":57,"end_line":59,"comment":["*\r\n\t * Returns true if `value` is an object (excluding null), else returns false.\r\n\t * @param {*} value - The value to test.\r\n\t * @returns {Boolean}\r\n\t * @since 2.7.0\r\n\t "],"params":["value"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"isObject","line":217,"func_location":"helpers._mergerIf","func_start_line":213,"func_end_line":222,"args":["tval"],"comment":["*\r\n\t * Merges source[key] in target[key] only if target[key] is undefined.\r\n\t * @private\r\n\t "],"code":"\t_mergerIf: function(key, target, source) {\r\n\t\tvar tval = target[key];\r\n\t\tvar sval = source[key];\r\n\r\n\t\tif (helpers.isObject(tval) && helpers.isObject(sval)) {\r\n\t\t\thelpers.mergeIf(tval, sval);\r\n\t\t} else if (!target.hasOwnProperty(key)) {\r\n\t\t\ttarget[key] = helpers.clone(sval);\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"helpers.isObject","start_line":57,"end_line":59,"comment":["*\r\n\t * Returns true if `value` is an object (excluding null), else returns false.\r\n\t * @param {*} value - The value to test.\r\n\t * @returns {Boolean}\r\n\t * @since 2.7.0\r\n\t "],"params":["value"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"clone","line":220,"func_location":"helpers._mergerIf","func_start_line":213,"func_end_line":222,"args":["sval"],"comment":["*\r\n\t * Merges source[key] in target[key] only if target[key] is undefined.\r\n\t * @private\r\n\t "],"code":"\t_mergerIf: function(key, target, source) {\r\n\t\tvar tval = target[key];\r\n\t\tvar sval = source[key];\r\n\r\n\t\tif (helpers.isObject(tval) && helpers.isObject(sval)) {\r\n\t\t\thelpers.mergeIf(tval, sval);\r\n\t\t} else if (!target.hasOwnProperty(key)) {\r\n\t\t\ttarget[key] = helpers.clone(sval);\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"helpers.clone","start_line":172,"end_line":191,"comment":["*\r\n\t * Returns a deep copy of `source` without keeping references on objects and arrays.\r\n\t * @param {*} source - The value to clone.\r\n\t * @returns {*}\r\n\t "],"params":["source"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.options.js","name":"toFontString","line":106,"func_location":"module.exports._parseFont","func_start_line":93,"func_end_line":108,"args":["font"],"comment":["*\r\n\t * Parses font options and returns the font object.\r\n\t * @param {Object} options - A object that contains font opttons to be parsed.\r\n\t * @return {Object} The font object.\r\n\t * @todo Support font.* options and renamed to toFont().\r\n\t * @private\r\n\t "],"code":"\t_parseFont: function(options) {\r\n\t\tvar valueOrDefault = helpers.valueOrDefault;\r\n\t\tvar globalDefaults = defaults.global;\r\n\t\tvar size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);\r\n\t\tvar font = {\r\n\t\t\tfamily: valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily),\r\n\t\t\tlineHeight: helpers.options.toLineHeight(valueOrDefault(options.lineHeight, globalDefaults.defaultLineHeight), size),\r\n\t\t\tsize: size,\r\n\t\t\tstyle: valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle),\r\n\t\t\tweight: null,\r\n\t\t\tstring: ''\r\n\t\t};\r\n\r\n\t\tfont.string = toFontString(font);\r\n\t\treturn font;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.options.js","name":"toFontString","start_line":12,"end_line":21,"comment":["*\r\n * Converts the given font object into a CSS font string.\r\n * @param {Object} font - A font object.\r\n * @return {Stringg} The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\r\n * @private\r\n "],"params":["font"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"initCanvas","line":369,"func_location":"module.exports.acquireContext","func_start_line":343,"func_end_line":374,"args":["item","config"],"code":"\tacquireContext: function(item, config) {\r\n\t\tif (typeof item === 'string') {\r\n\t\t\titem = document.getElementById(item);\r\n\t\t} else if (item.length) {\r\n\t\t\t// Support for array based queries (such as jQuery)\r\n\t\t\titem = item[0];\r\n\t\t}\r\n\r\n\t\tif (item && item.canvas) {\r\n\t\t\t// Support for any object associated to a canvas (including a context2d)\r\n\t\t\titem = item.canvas;\r\n\t\t}\r\n\r\n\t\t// To prevent canvas fingerprinting, some add-ons undefine the getContext\r\n\t\t// method, for example: https://github.com/kkapsner/CanvasBlocker\r\n\t\t// https://github.com/chartjs/Chart.js/issues/2807\r\n\t\tvar context = item && item.getContext && item.getContext('2d');\r\n\r\n\t\t// `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is\r\n\t\t// inside an iframe or when running in a protected environment. We could guess the\r\n\t\t// types from their toString() value but let's keep things flexible and assume it's\r\n\t\t// a sufficient condition if the item has a context2D which has item as `canvas`.\r\n\t\t// https://github.com/chartjs/Chart.js/issues/3887\r\n\t\t// https://github.com/chartjs/Chart.js/issues/4102\r\n\t\t// https://github.com/chartjs/Chart.js/issues/4152\r\n\t\tif (context && context.canvas === item) {\r\n\t\t\tinitCanvas(item, config);\r\n\t\t\treturn context;\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"initCanvas","start_line":52,"end_line":100,"comment":["*\r\n * Initializes the canvas style and render size without modifying the canvas display size,\r\n * since responsiveness is handled by the controller.resize() method. The config is used\r\n * to determine the aspect ratio to apply in case no explicit height has been specified.\r\n "],"params":["canvas","config"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"addResizeListener","line":410,"func_location":"module.exports.addEventListener","func_start_line":406,"func_end_line":421,"args":["canvas","listener","chart"],"code":"\taddEventListener: function(chart, type, listener) {\r\n\t\tvar canvas = chart.canvas;\r\n\t\tif (type === 'resize') {\r\n\t\t\t// Note: the resize event is not supported on all browsers.\r\n\t\t\taddResizeListener(canvas, listener, chart);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});\r\n\t\tvar proxies = expando.proxies || (expando.proxies = {});\r\n\t\tvar proxy = proxies[chart.id + '_' + type] = function(event) {\r\n\t\t\tlistener(fromNativeEvent(event, chart));\r\n\t\t};\r\n\r\n\t\taddEventListener(canvas, type, proxy);\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"addResizeListener","start_line":270,"end_line":293,"comment":[],"params":["node","listener","chart"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"createResizer","line":274,"func_location":"addResizeListener","func_start_line":270,"func_end_line":293},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"createResizer","start_line":177,"end_line":230,"comment":[" Implementation based on https://github.com/marcj/css-element-queries"],"params":["handler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"throttled","line":274,"func_location":"addResizeListener","func_start_line":270,"func_end_line":293},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"throttled","start_line":151,"end_line":167,"comment":[],"params":["fn","thisArg"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"watchForRender","line":282,"func_location":"addResizeListener","func_start_line":270,"func_end_line":293},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"watchForRender","start_line":233,"end_line":253,"comment":[" https://davidwalsh.name/detect-node-insertion"],"params":["node","handler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.filler.js","name":"decodeFill","line":277,"func_location":"module.exports.afterDatasetsUpdate","func_start_line":263,"func_end_line":297,"args":["el","i","count"],"code":"\tafterDatasetsUpdate: function(chart, options) {\r\n\t\tvar count = (chart.data.datasets || []).length;\r\n\t\tvar propagate = options.propagate;\r\n\t\tvar sources = [];\r\n\t\tvar meta, i, el, source;\r\n\r\n\t\tfor (i = 0; i < count; ++i) {\r\n\t\t\tmeta = chart.getDatasetMeta(i);\r\n\t\t\tel = meta.dataset;\r\n\t\t\tsource = null;\r\n\r\n\t\t\tif (el && el._model && el instanceof elements.Line) {\r\n\t\t\t\tsource = {\r\n\t\t\t\t\tvisible: chart.isDatasetVisible(i),\r\n\t\t\t\t\tfill: decodeFill(el, i, count),\r\n\t\t\t\t\tchart: chart,\r\n\t\t\t\t\tel: el\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tmeta.$filler = source;\r\n\t\t\tsources.push(source);\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < count; ++i) {\r\n\t\t\tsource = sources[i];\r\n\t\t\tif (!source) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tsource.fill = resolveTarget(sources, i, propagate);\r\n\t\t\tsource.boundary = computeBoundary(source);\r\n\t\t\tsource.mapper = createMapper(source);\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.filler.js","name":"decodeFill","start_line":50,"end_line":97,"comment":[" @todo if (fill[0] === '#')"],"params":["el","index","count"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.filler.js","name":"resolveTarget","line":293,"func_location":"module.exports.afterDatasetsUpdate","func_start_line":263,"func_end_line":297,"args":["sources","i","propagate"],"code":"\tafterDatasetsUpdate: function(chart, options) {\r\n\t\tvar count = (chart.data.datasets || []).length;\r\n\t\tvar propagate = options.propagate;\r\n\t\tvar sources = [];\r\n\t\tvar meta, i, el, source;\r\n\r\n\t\tfor (i = 0; i < count; ++i) {\r\n\t\t\tmeta = chart.getDatasetMeta(i);\r\n\t\t\tel = meta.dataset;\r\n\t\t\tsource = null;\r\n\r\n\t\t\tif (el && el._model && el instanceof elements.Line) {\r\n\t\t\t\tsource = {\r\n\t\t\t\t\tvisible: chart.isDatasetVisible(i),\r\n\t\t\t\t\tfill: decodeFill(el, i, count),\r\n\t\t\t\t\tchart: chart,\r\n\t\t\t\t\tel: el\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tmeta.$filler = source;\r\n\t\t\tsources.push(source);\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < count; ++i) {\r\n\t\t\tsource = sources[i];\r\n\t\t\tif (!source) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tsource.fill = resolveTarget(sources, i, propagate);\r\n\t\t\tsource.boundary = computeBoundary(source);\r\n\t\t\tsource.mapper = createMapper(source);\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.filler.js","name":"resolveTarget","start_line":143,"end_line":172,"comment":[],"params":["sources","index","propagate"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.filler.js","name":"computeBoundary","line":294,"func_location":"module.exports.afterDatasetsUpdate","func_start_line":263,"func_end_line":297,"args":["source"],"code":"\tafterDatasetsUpdate: function(chart, options) {\r\n\t\tvar count = (chart.data.datasets || []).length;\r\n\t\tvar propagate = options.propagate;\r\n\t\tvar sources = [];\r\n\t\tvar meta, i, el, source;\r\n\r\n\t\tfor (i = 0; i < count; ++i) {\r\n\t\t\tmeta = chart.getDatasetMeta(i);\r\n\t\t\tel = meta.dataset;\r\n\t\t\tsource = null;\r\n\r\n\t\t\tif (el && el._model && el instanceof elements.Line) {\r\n\t\t\t\tsource = {\r\n\t\t\t\t\tvisible: chart.isDatasetVisible(i),\r\n\t\t\t\t\tfill: decodeFill(el, i, count),\r\n\t\t\t\t\tchart: chart,\r\n\t\t\t\t\tel: el\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tmeta.$filler = source;\r\n\t\t\tsources.push(source);\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < count; ++i) {\r\n\t\t\tsource = sources[i];\r\n\t\t\tif (!source) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tsource.fill = resolveTarget(sources, i, propagate);\r\n\t\t\tsource.boundary = computeBoundary(source);\r\n\t\t\tsource.mapper = createMapper(source);\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.filler.js","name":"computeBoundary","start_line":99,"end_line":141,"comment":[],"params":["source"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.filler.js","name":"createMapper","line":295,"func_location":"module.exports.afterDatasetsUpdate","func_start_line":263,"func_end_line":297,"args":["source"],"code":"\tafterDatasetsUpdate: function(chart, options) {\r\n\t\tvar count = (chart.data.datasets || []).length;\r\n\t\tvar propagate = options.propagate;\r\n\t\tvar sources = [];\r\n\t\tvar meta, i, el, source;\r\n\r\n\t\tfor (i = 0; i < count; ++i) {\r\n\t\t\tmeta = chart.getDatasetMeta(i);\r\n\t\t\tel = meta.dataset;\r\n\t\t\tsource = null;\r\n\r\n\t\t\tif (el && el._model && el instanceof elements.Line) {\r\n\t\t\t\tsource = {\r\n\t\t\t\t\tvisible: chart.isDatasetVisible(i),\r\n\t\t\t\t\tfill: decodeFill(el, i, count),\r\n\t\t\t\t\tchart: chart,\r\n\t\t\t\t\tel: el\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tmeta.$filler = source;\r\n\t\t\tsources.push(source);\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < count; ++i) {\r\n\t\t\tsource = sources[i];\r\n\t\t\tif (!source) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tsource.fill = resolveTarget(sources, i, propagate);\r\n\t\t\tsource.boundary = computeBoundary(source);\r\n\t\t\tsource.mapper = createMapper(source);\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.filler.js","name":"createMapper","start_line":174,"end_line":187,"comment":[],"params":["source"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"arrayEquals","line":155,"func_location":"helpers.arrayEquals","func_start_line":143,"func_end_line":165,"args":["v0","v1"],"comment":["*\r\n\t * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\r\n\t * @see https://stackoverflow.com/a/14853974\r\n\t * @param {Array} a0 - The array to compare\r\n\t * @param {Array} a1 - The array to compare\r\n\t * @returns {Boolean}\r\n\t "],"code":"\tarrayEquals: function(a0, a1) {\r\n\t\tvar i, ilen, v0, v1;\r\n\r\n\t\tif (!a0 || !a1 || a0.length !== a1.length) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tfor (i = 0, ilen = a0.length; i < ilen; ++i) {\r\n\t\t\tv0 = a0[i];\r\n\t\t\tv1 = a1[i];\r\n\r\n\t\t\tif (v0 instanceof Array && v1 instanceof Array) {\r\n\t\t\t\tif (!helpers.arrayEquals(v0, v1)) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t} else if (v0 !== v1) {\r\n\t\t\t\t// NOTE: two different object instances will never be equal: {x:20} != {x:20}\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"helpers.arrayEquals","start_line":143,"end_line":165,"comment":["*\r\n\t * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\r\n\t * @see https://stackoverflow.com/a/14853974\r\n\t * @param {Array} a0 - The array to compare\r\n\t * @param {Array} a1 - The array to compare\r\n\t * @returns {Boolean}\r\n\t "],"params":["a0","a1"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.filler.js","name":"doFill","line":314,"func_location":"module.exports.beforeDatasetDraw","func_start_line":299,"func_end_line":317,"args":["ctx","points","mapper","view","color","el._loop"],"code":"\tbeforeDatasetDraw: function(chart, args) {\r\n\t\tvar meta = args.meta.$filler;\r\n\t\tif (!meta) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar ctx = chart.ctx;\r\n\t\tvar el = meta.el;\r\n\t\tvar view = el._view;\r\n\t\tvar points = el._children || [];\r\n\t\tvar mapper = meta.mapper;\r\n\t\tvar color = view.backgroundColor || defaults.global.defaultColor;\r\n\r\n\t\tif (mapper && color && points.length) {\r\n\t\t\thelpers.canvas.clipArea(ctx, chart.chartArea);\r\n\t\t\tdoFill(ctx, points, mapper, view, color, el._loop);\r\n\t\t\thelpers.canvas.unclipArea(ctx);\r\n\t\t}\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.filler.js","name":"doFill","start_line":215,"end_line":258,"comment":[],"params":["ctx","points","mapper","view","color","loop"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.legend.js","name":"createNewLegendAndAttach","line":545,"func_location":"module.exports.beforeInit","func_start_line":541,"func_end_line":547,"args":["chart","legendOpts"],"code":"\tbeforeInit: function(chart) {\r\n\t\tvar legendOpts = chart.options.legend;\r\n\r\n\t\tif (legendOpts) {\r\n\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.legend.js","name":"createNewLegendAndAttach","start_line":517,"end_line":527,"comment":[],"params":["chart","legendOpts"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.title.js","name":"createNewTitleBlockAndAttach","line":223,"func_location":"module.exports.beforeInit","func_start_line":219,"func_end_line":225,"args":["chart","titleOpts"],"code":"\tbeforeInit: function(chart) {\r\n\t\tvar titleOpts = chart.options.title;\r\n\r\n\t\tif (titleOpts) {\r\n\t\t\tcreateNewTitleBlockAndAttach(chart, titleOpts);\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.title.js","name":"createNewTitleBlockAndAttach","start_line":195,"end_line":205,"comment":[],"params":["chart","titleOpts"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.legend.js","name":"createNewLegendAndAttach","line":560,"func_location":"module.exports.beforeUpdate","func_start_line":549,"func_end_line":566,"args":["chart","legendOpts"],"code":"\tbeforeUpdate: function(chart) {\r\n\t\tvar legendOpts = chart.options.legend;\r\n\t\tvar legend = chart.legend;\r\n\r\n\t\tif (legendOpts) {\r\n\t\t\thelpers.mergeIf(legendOpts, defaults.global.legend);\r\n\r\n\t\t\tif (legend) {\r\n\t\t\t\tlayouts.configure(chart, legend, legendOpts);\r\n\t\t\t\tlegend.options = legendOpts;\r\n\t\t\t} else {\r\n\t\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\r\n\t\t\t}\r\n\t\t} else if (legend) {\r\n\t\t\tlayouts.removeBox(chart, legend);\r\n\t\t\tdelete chart.legend;\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.legend.js","name":"createNewLegendAndAttach","start_line":517,"end_line":527,"comment":[],"params":["chart","legendOpts"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.title.js","name":"createNewTitleBlockAndAttach","line":238,"func_location":"module.exports.beforeUpdate","func_start_line":227,"func_end_line":244,"args":["chart","titleOpts"],"code":"\tbeforeUpdate: function(chart) {\r\n\t\tvar titleOpts = chart.options.title;\r\n\t\tvar titleBlock = chart.titleBlock;\r\n\r\n\t\tif (titleOpts) {\r\n\t\t\thelpers.mergeIf(titleOpts, defaults.global.title);\r\n\r\n\t\t\tif (titleBlock) {\r\n\t\t\t\tlayouts.configure(chart, titleBlock, titleOpts);\r\n\t\t\t\ttitleBlock.options = titleOpts;\r\n\t\t\t} else {\r\n\t\t\t\tcreateNewTitleBlockAndAttach(chart, titleOpts);\r\n\t\t\t}\r\n\t\t} else if (titleBlock) {\r\n\t\t\tlayouts.removeBox(chart, titleBlock);\r\n\t\t\tdelete chart.titleBlock;\r\n\t\t}\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.title.js","name":"createNewTitleBlockAndAttach","start_line":195,"end_line":205,"comment":[],"params":["chart","titleOpts"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.datasetController.js","name":"unlistenArrayEvents","line":195,"func_location":"buildOrUpdateElements","func_start_line":184,"func_end_line":205,"args":["me._data","me"],"code":"\tbuildOrUpdateElements: function() {\r\n\t\tvar me = this;\r\n\t\tvar dataset = me.getDataset();\r\n\t\tvar data = dataset.data || (dataset.data = []);\r\n\r\n\t\t// In order to correctly handle data addition/deletion animation (an thus simulate\r\n\t\t// real-time charts), we need to monitor these data modifications and synchronize\r\n\t\t// the internal meta data accordingly.\r\n\t\tif (me._data !== data) {\r\n\t\t\tif (me._data) {\r\n\t\t\t\t// This case happens when the user replaced the data array instance.\r\n\t\t\t\tunlistenArrayEvents(me._data, me);\r\n\t\t\t}\r\n\r\n\t\t\tlistenArrayEvents(data, me);\r\n\t\t\tme._data = data;\r\n\t\t}\r\n\r\n\t\t// Re-sync meta data in case the user replaced the data array or if we missed\r\n\t\t// any updates and so make sure that we handle number of datapoints changing.\r\n\t\tme.resyncElements();\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.datasetController.js","name":"unlistenArrayEvents","start_line":53,"end_line":74,"comment":["*\r\n * Removes the given array event listener and cleanup extra attached properties (such as\r\n * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\r\n "],"params":["array","listener"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.datasetController.js","name":"listenArrayEvents","line":198,"func_location":"buildOrUpdateElements","func_start_line":184,"func_end_line":205,"args":["data","me"],"code":"\tbuildOrUpdateElements: function() {\r\n\t\tvar me = this;\r\n\t\tvar dataset = me.getDataset();\r\n\t\tvar data = dataset.data || (dataset.data = []);\r\n\r\n\t\t// In order to correctly handle data addition/deletion animation (an thus simulate\r\n\t\t// real-time charts), we need to monitor these data modifications and synchronize\r\n\t\t// the internal meta data accordingly.\r\n\t\tif (me._data !== data) {\r\n\t\t\tif (me._data) {\r\n\t\t\t\t// This case happens when the user replaced the data array instance.\r\n\t\t\t\tunlistenArrayEvents(me._data, me);\r\n\t\t\t}\r\n\r\n\t\t\tlistenArrayEvents(data, me);\r\n\t\t\tme._data = data;\r\n\t\t}\r\n\r\n\t\t// Re-sync meta data in case the user replaced the data array or if we missed\r\n\t\t// any updates and so make sure that we handle number of datapoints changing.\r\n\t\tme.resyncElements();\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.datasetController.js","name":"listenArrayEvents","start_line":12,"end_line":47,"comment":["*\r\n * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\r\n * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\r\n * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.\r\n "],"params":["array","listener"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.linearbase.js","name":"generateTicks","line":171,"func_location":"buildTicks","func_start_line":152,"func_end_line":189,"args":["numericGeneratorOptions","me"],"code":"\t\tbuildTicks: function() {\r\n\t\t\tvar me = this;\r\n\t\t\tvar opts = me.options;\r\n\t\t\tvar tickOpts = opts.ticks;\r\n\r\n\t\t\t// Figure out what the max number of ticks we can support it is based on the size of\r\n\t\t\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\r\n\t\t\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\r\n\t\t\t// the graph. Make sure we always have at least 2 ticks\r\n\t\t\tvar maxTicks = me.getTickLimit();\r\n\t\t\tmaxTicks = Math.max(2, maxTicks);\r\n\r\n\t\t\tvar numericGeneratorOptions = {\r\n\t\t\t\tmaxTicks: maxTicks,\r\n\t\t\t\tmin: tickOpts.min,\r\n\t\t\t\tmax: tickOpts.max,\r\n\t\t\t\tprecision: tickOpts.precision,\r\n\t\t\t\tstepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\r\n\t\t\t};\r\n\t\t\tvar ticks = me.ticks = generateTicks(numericGeneratorOptions, me);\r\n\r\n\t\t\tme.handleDirectionalChanges();\r\n\r\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\r\n\t\t\t// range of the scale\r\n\t\t\tme.max = helpers.max(ticks);\r\n\t\t\tme.min = helpers.min(ticks);\r\n\r\n\t\t\tif (tickOpts.reverse) {\r\n\t\t\t\tticks.reverse();\r\n\r\n\t\t\t\tme.start = me.max;\r\n\t\t\t\tme.end = me.min;\r\n\t\t\t} else {\r\n\t\t\t\tme.start = me.min;\r\n\t\t\t\tme.end = me.max;\r\n\t\t\t}\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.linearbase.js","name":"generateTicks","start_line":12,"end_line":69,"comment":["*\r\n * Generate a set of linear ticks\r\n * @param generationOptions the options used to generate the ticks\r\n * @param dataRange the range of the data\r\n * @returns {Array<Number>} array of tick values\r\n "],"params":["generationOptions","dataRange"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.logarithmic.js","name":"generateTicks","line":224,"func_location":"module.exports.LogarithmicScale.buildTicks","func_start_line":214,"func_end_line":242,"args":["generationOptions","me"],"code":"\t\tbuildTicks: function() {\r\n\t\t\tvar me = this;\r\n\t\t\tvar opts = me.options;\r\n\t\t\tvar tickOpts = opts.ticks;\r\n\t\t\tvar reverse = !me.isHorizontal();\r\n\r\n\t\t\tvar generationOptions = {\r\n\t\t\t\tmin: tickOpts.min,\r\n\t\t\t\tmax: tickOpts.max\r\n\t\t\t};\r\n\t\t\tvar ticks = me.ticks = generateTicks(generationOptions, me);\r\n\r\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\r\n\t\t\t// range of the scale\r\n\t\t\tme.max = helpers.max(ticks);\r\n\t\t\tme.min = helpers.min(ticks);\r\n\r\n\t\t\tif (tickOpts.reverse) {\r\n\t\t\t\treverse = !reverse;\r\n\t\t\t\tme.start = me.max;\r\n\t\t\t\tme.end = me.min;\r\n\t\t\t} else {\r\n\t\t\t\tme.start = me.min;\r\n\t\t\t\tme.end = me.max;\r\n\t\t\t}\r\n\t\t\tif (reverse) {\r\n\t\t\t\tticks.reverse();\r\n\t\t\t}\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.logarithmic.js","name":"generateTicks","start_line":14,"end_line":57,"comment":["*\r\n * Generate a set of logarithmic ticks\r\n * @param generationOptions the options used to generate the ticks\r\n * @param dataRange the range of the data\r\n * @returns {Array<Number>} array of tick values\r\n "],"params":["generationOptions","dataRange"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"generate","line":618,"func_location":"module.exports.TimeScale.buildTicks","func_start_line":599,"func_end_line":653,"args":["min","max",null,"options"],"code":"\t\tbuildTicks: function() {\r\n\t\t\tvar me = this;\r\n\t\t\tvar min = me.min;\r\n\t\t\tvar max = me.max;\r\n\t\t\tvar options = me.options;\r\n\t\t\tvar timeOpts = options.time;\r\n\t\t\tvar timestamps = [];\r\n\t\t\tvar ticks = [];\r\n\t\t\tvar i, ilen, timestamp;\r\n\r\n\t\t\tswitch (options.ticks.source) {\r\n\t\t\tcase 'data':\r\n\t\t\t\ttimestamps = me._timestamps.data;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'labels':\r\n\t\t\t\ttimestamps = me._timestamps.labels;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'auto':\r\n\t\t\tdefault:\r\n\t\t\t\ttimestamps = generate(min, max, me.getLabelCapacity(min), options);\r\n\t\t\t}\r\n\r\n\t\t\tif (options.bounds === 'ticks' && timestamps.length) {\r\n\t\t\t\tmin = timestamps[0];\r\n\t\t\t\tmax = timestamps[timestamps.length - 1];\r\n\t\t\t}\r\n\r\n\t\t\t// Enforce limits with user min/max options\r\n\t\t\tmin = parse(timeOpts.min, me) || min;\r\n\t\t\tmax = parse(timeOpts.max, me) || max;\r\n\r\n\t\t\t// Remove ticks outside the min/max range\r\n\t\t\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\r\n\t\t\t\ttimestamp = timestamps[i];\r\n\t\t\t\tif (timestamp >= min && timestamp <= max) {\r\n\t\t\t\t\tticks.push(timestamp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tme.min = min;\r\n\t\t\tme.max = max;\r\n\r\n\t\t\t// PRIVATE\r\n\t\t\tme._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);\r\n\t\t\tme._majorUnit = determineMajorUnit(me._unit);\r\n\t\t\tme._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);\r\n\t\t\tme._offsets = computeOffsets(me._table, ticks, min, max, options);\r\n\t\t\tme._labelFormat = determineLabelFormat(me._timestamps.data, timeOpts);\r\n\r\n\t\t\tif (options.ticks.reverse) {\r\n\t\t\t\tticks.reverse();\r\n\t\t\t}\r\n\r\n\t\t\treturn ticksFromTimestamps(ticks, me._majorUnit);\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"generate","start_line":307,"end_line":356,"comment":["*\r\n * Generates a maximum of `capacity` timestamps between min and max, rounded to the\r\n * `minor` unit, aligned on the `major` unit and using the given scale time `options`.\r\n * Important: this method can return ticks outside the min and max range, it's the\r\n * responsibility of the calling code to clamp values if needed.\r\n "],"params":["min","max","capacity","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"parse","line":627,"func_location":"module.exports.TimeScale.buildTicks","func_start_line":599,"func_end_line":653,"args":["timeOpts.min","me"],"code":"\t\tbuildTicks: function() {\r\n\t\t\tvar me = this;\r\n\t\t\tvar min = me.min;\r\n\t\t\tvar max = me.max;\r\n\t\t\tvar options = me.options;\r\n\t\t\tvar timeOpts = options.time;\r\n\t\t\tvar timestamps = [];\r\n\t\t\tvar ticks = [];\r\n\t\t\tvar i, ilen, timestamp;\r\n\r\n\t\t\tswitch (options.ticks.source) {\r\n\t\t\tcase 'data':\r\n\t\t\t\ttimestamps = me._timestamps.data;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'labels':\r\n\t\t\t\ttimestamps = me._timestamps.labels;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'auto':\r\n\t\t\tdefault:\r\n\t\t\t\ttimestamps = generate(min, max, me.getLabelCapacity(min), options);\r\n\t\t\t}\r\n\r\n\t\t\tif (options.bounds === 'ticks' && timestamps.length) {\r\n\t\t\t\tmin = timestamps[0];\r\n\t\t\t\tmax = timestamps[timestamps.length - 1];\r\n\t\t\t}\r\n\r\n\t\t\t// Enforce limits with user min/max options\r\n\t\t\tmin = parse(timeOpts.min, me) || min;\r\n\t\t\tmax = parse(timeOpts.max, me) || max;\r\n\r\n\t\t\t// Remove ticks outside the min/max range\r\n\t\t\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\r\n\t\t\t\ttimestamp = timestamps[i];\r\n\t\t\t\tif (timestamp >= min && timestamp <= max) {\r\n\t\t\t\t\tticks.push(timestamp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tme.min = min;\r\n\t\t\tme.max = max;\r\n\r\n\t\t\t// PRIVATE\r\n\t\t\tme._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);\r\n\t\t\tme._majorUnit = determineMajorUnit(me._unit);\r\n\t\t\tme._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);\r\n\t\t\tme._offsets = computeOffsets(me._table, ticks, min, max, options);\r\n\t\t\tme._labelFormat = determineLabelFormat(me._timestamps.data, timeOpts);\r\n\r\n\t\t\tif (options.ticks.reverse) {\r\n\t\t\t\tticks.reverse();\r\n\t\t\t}\r\n\r\n\t\t\treturn ticksFromTimestamps(ticks, me._majorUnit);\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"parse","start_line":213,"end_line":229,"comment":[],"params":["input","scale"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"parse","line":628,"func_location":"module.exports.TimeScale.buildTicks","func_start_line":599,"func_end_line":653,"args":["timeOpts.max","me"],"code":"\t\tbuildTicks: function() {\r\n\t\t\tvar me = this;\r\n\t\t\tvar min = me.min;\r\n\t\t\tvar max = me.max;\r\n\t\t\tvar options = me.options;\r\n\t\t\tvar timeOpts = options.time;\r\n\t\t\tvar timestamps = [];\r\n\t\t\tvar ticks = [];\r\n\t\t\tvar i, ilen, timestamp;\r\n\r\n\t\t\tswitch (options.ticks.source) {\r\n\t\t\tcase 'data':\r\n\t\t\t\ttimestamps = me._timestamps.data;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'labels':\r\n\t\t\t\ttimestamps = me._timestamps.labels;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'auto':\r\n\t\t\tdefault:\r\n\t\t\t\ttimestamps = generate(min, max, me.getLabelCapacity(min), options);\r\n\t\t\t}\r\n\r\n\t\t\tif (options.bounds === 'ticks' && timestamps.length) {\r\n\t\t\t\tmin = timestamps[0];\r\n\t\t\t\tmax = timestamps[timestamps.length - 1];\r\n\t\t\t}\r\n\r\n\t\t\t// Enforce limits with user min/max options\r\n\t\t\tmin = parse(timeOpts.min, me) || min;\r\n\t\t\tmax = parse(timeOpts.max, me) || max;\r\n\r\n\t\t\t// Remove ticks outside the min/max range\r\n\t\t\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\r\n\t\t\t\ttimestamp = timestamps[i];\r\n\t\t\t\tif (timestamp >= min && timestamp <= max) {\r\n\t\t\t\t\tticks.push(timestamp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tme.min = min;\r\n\t\t\tme.max = max;\r\n\r\n\t\t\t// PRIVATE\r\n\t\t\tme._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);\r\n\t\t\tme._majorUnit = determineMajorUnit(me._unit);\r\n\t\t\tme._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);\r\n\t\t\tme._offsets = computeOffsets(me._table, ticks, min, max, options);\r\n\t\t\tme._labelFormat = determineLabelFormat(me._timestamps.data, timeOpts);\r\n\r\n\t\t\tif (options.ticks.reverse) {\r\n\t\t\t\tticks.reverse();\r\n\t\t\t}\r\n\r\n\t\t\treturn ticksFromTimestamps(ticks, me._majorUnit);\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"parse","start_line":213,"end_line":229,"comment":[],"params":["input","scale"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"determineUnitForFormatting","line":642,"func_location":"module.exports.TimeScale.buildTicks","func_start_line":599,"func_end_line":653,"args":["ticks","timeOpts.minUnit","me.min","me.max"],"code":"\t\tbuildTicks: function() {\r\n\t\t\tvar me = this;\r\n\t\t\tvar min = me.min;\r\n\t\t\tvar max = me.max;\r\n\t\t\tvar options = me.options;\r\n\t\t\tvar timeOpts = options.time;\r\n\t\t\tvar timestamps = [];\r\n\t\t\tvar ticks = [];\r\n\t\t\tvar i, ilen, timestamp;\r\n\r\n\t\t\tswitch (options.ticks.source) {\r\n\t\t\tcase 'data':\r\n\t\t\t\ttimestamps = me._timestamps.data;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'labels':\r\n\t\t\t\ttimestamps = me._timestamps.labels;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'auto':\r\n\t\t\tdefault:\r\n\t\t\t\ttimestamps = generate(min, max, me.getLabelCapacity(min), options);\r\n\t\t\t}\r\n\r\n\t\t\tif (options.bounds === 'ticks' && timestamps.length) {\r\n\t\t\t\tmin = timestamps[0];\r\n\t\t\t\tmax = timestamps[timestamps.length - 1];\r\n\t\t\t}\r\n\r\n\t\t\t// Enforce limits with user min/max options\r\n\t\t\tmin = parse(timeOpts.min, me) || min;\r\n\t\t\tmax = parse(timeOpts.max, me) || max;\r\n\r\n\t\t\t// Remove ticks outside the min/max range\r\n\t\t\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\r\n\t\t\t\ttimestamp = timestamps[i];\r\n\t\t\t\tif (timestamp >= min && timestamp <= max) {\r\n\t\t\t\t\tticks.push(timestamp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tme.min = min;\r\n\t\t\tme.max = max;\r\n\r\n\t\t\t// PRIVATE\r\n\t\t\tme._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);\r\n\t\t\tme._majorUnit = determineMajorUnit(me._unit);\r\n\t\t\tme._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);\r\n\t\t\tme._offsets = computeOffsets(me._table, ticks, min, max, options);\r\n\t\t\tme._labelFormat = determineLabelFormat(me._timestamps.data, timeOpts);\r\n\r\n\t\t\tif (options.ticks.reverse) {\r\n\t\t\t\tticks.reverse();\r\n\t\t\t}\r\n\r\n\t\t\treturn ticksFromTimestamps(ticks, me._majorUnit);\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"determineUnitForFormatting","start_line":278,"end_line":291,"comment":["*\r\n * Figures out what unit to format a set of ticks with\r\n "],"params":["ticks","minUnit","min","max"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"determineMajorUnit","line":643,"func_location":"module.exports.TimeScale.buildTicks","func_start_line":599,"func_end_line":653,"args":["me._unit"],"code":"\t\tbuildTicks: function() {\r\n\t\t\tvar me = this;\r\n\t\t\tvar min = me.min;\r\n\t\t\tvar max = me.max;\r\n\t\t\tvar options = me.options;\r\n\t\t\tvar timeOpts = options.time;\r\n\t\t\tvar timestamps = [];\r\n\t\t\tvar ticks = [];\r\n\t\t\tvar i, ilen, timestamp;\r\n\r\n\t\t\tswitch (options.ticks.source) {\r\n\t\t\tcase 'data':\r\n\t\t\t\ttimestamps = me._timestamps.data;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'labels':\r\n\t\t\t\ttimestamps = me._timestamps.labels;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'auto':\r\n\t\t\tdefault:\r\n\t\t\t\ttimestamps = generate(min, max, me.getLabelCapacity(min), options);\r\n\t\t\t}\r\n\r\n\t\t\tif (options.bounds === 'ticks' && timestamps.length) {\r\n\t\t\t\tmin = timestamps[0];\r\n\t\t\t\tmax = timestamps[timestamps.length - 1];\r\n\t\t\t}\r\n\r\n\t\t\t// Enforce limits with user min/max options\r\n\t\t\tmin = parse(timeOpts.min, me) || min;\r\n\t\t\tmax = parse(timeOpts.max, me) || max;\r\n\r\n\t\t\t// Remove ticks outside the min/max range\r\n\t\t\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\r\n\t\t\t\ttimestamp = timestamps[i];\r\n\t\t\t\tif (timestamp >= min && timestamp <= max) {\r\n\t\t\t\t\tticks.push(timestamp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tme.min = min;\r\n\t\t\tme.max = max;\r\n\r\n\t\t\t// PRIVATE\r\n\t\t\tme._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);\r\n\t\t\tme._majorUnit = determineMajorUnit(me._unit);\r\n\t\t\tme._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);\r\n\t\t\tme._offsets = computeOffsets(me._table, ticks, min, max, options);\r\n\t\t\tme._labelFormat = determineLabelFormat(me._timestamps.data, timeOpts);\r\n\r\n\t\t\tif (options.ticks.reverse) {\r\n\t\t\t\tticks.reverse();\r\n\t\t\t}\r\n\r\n\t\t\treturn ticksFromTimestamps(ticks, me._majorUnit);\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"determineMajorUnit","start_line":293,"end_line":299,"comment":[],"params":["unit"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"buildLookupTable","line":644,"func_location":"module.exports.TimeScale.buildTicks","func_start_line":599,"func_end_line":653,"args":["me._timestamps.data","min","max","options.distribution"],"code":"\t\tbuildTicks: function() {\r\n\t\t\tvar me = this;\r\n\t\t\tvar min = me.min;\r\n\t\t\tvar max = me.max;\r\n\t\t\tvar options = me.options;\r\n\t\t\tvar timeOpts = options.time;\r\n\t\t\tvar timestamps = [];\r\n\t\t\tvar ticks = [];\r\n\t\t\tvar i, ilen, timestamp;\r\n\r\n\t\t\tswitch (options.ticks.source) {\r\n\t\t\tcase 'data':\r\n\t\t\t\ttimestamps = me._timestamps.data;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'labels':\r\n\t\t\t\ttimestamps = me._timestamps.labels;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'auto':\r\n\t\t\tdefault:\r\n\t\t\t\ttimestamps = generate(min, max, me.getLabelCapacity(min), options);\r\n\t\t\t}\r\n\r\n\t\t\tif (options.bounds === 'ticks' && timestamps.length) {\r\n\t\t\t\tmin = timestamps[0];\r\n\t\t\t\tmax = timestamps[timestamps.length - 1];\r\n\t\t\t}\r\n\r\n\t\t\t// Enforce limits with user min/max options\r\n\t\t\tmin = parse(timeOpts.min, me) || min;\r\n\t\t\tmax = parse(timeOpts.max, me) || max;\r\n\r\n\t\t\t// Remove ticks outside the min/max range\r\n\t\t\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\r\n\t\t\t\ttimestamp = timestamps[i];\r\n\t\t\t\tif (timestamp >= min && timestamp <= max) {\r\n\t\t\t\t\tticks.push(timestamp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tme.min = min;\r\n\t\t\tme.max = max;\r\n\r\n\t\t\t// PRIVATE\r\n\t\t\tme._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);\r\n\t\t\tme._majorUnit = determineMajorUnit(me._unit);\r\n\t\t\tme._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);\r\n\t\t\tme._offsets = computeOffsets(me._table, ticks, min, max, options);\r\n\t\t\tme._labelFormat = determineLabelFormat(me._timestamps.data, timeOpts);\r\n\r\n\t\t\tif (options.ticks.reverse) {\r\n\t\t\t\tticks.reverse();\r\n\t\t\t}\r\n\r\n\t\t\treturn ticksFromTimestamps(ticks, me._majorUnit);\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"buildLookupTable","start_line":98,"end_line":131,"comment":["*\r\n * Returns an array of {time, pos} objects used to interpolate a specific `time` or position\r\n * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is\r\n * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other\r\n * extremity (left + width or top + height). Note that it would be more optimized to directly\r\n * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need\r\n * to create the lookup table. The table ALWAYS contains at least two items: min and max.\r\n *\r\n * @param {Number[]} timestamps - timestamps sorted from lowest to highest.\r\n * @param {String} distribution - If 'linear', timestamps will be spread linearly along the min\r\n * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.\r\n * If 'series', timestamps will be positioned at the same distance from each other. In this\r\n * case, only timestamps that break the time linearity are registered, meaning that in the\r\n * best case, all timestamps are linear, the table contains only min and max.\r\n "],"params":["timestamps","min","max","distribution"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"computeOffsets","line":645,"func_location":"module.exports.TimeScale.buildTicks","func_start_line":599,"func_end_line":653,"args":["me._table","ticks","min","max","options"],"code":"\t\tbuildTicks: function() {\r\n\t\t\tvar me = this;\r\n\t\t\tvar min = me.min;\r\n\t\t\tvar max = me.max;\r\n\t\t\tvar options = me.options;\r\n\t\t\tvar timeOpts = options.time;\r\n\t\t\tvar timestamps = [];\r\n\t\t\tvar ticks = [];\r\n\t\t\tvar i, ilen, timestamp;\r\n\r\n\t\t\tswitch (options.ticks.source) {\r\n\t\t\tcase 'data':\r\n\t\t\t\ttimestamps = me._timestamps.data;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'labels':\r\n\t\t\t\ttimestamps = me._timestamps.labels;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'auto':\r\n\t\t\tdefault:\r\n\t\t\t\ttimestamps = generate(min, max, me.getLabelCapacity(min), options);\r\n\t\t\t}\r\n\r\n\t\t\tif (options.bounds === 'ticks' && timestamps.length) {\r\n\t\t\t\tmin = timestamps[0];\r\n\t\t\t\tmax = timestamps[timestamps.length - 1];\r\n\t\t\t}\r\n\r\n\t\t\t// Enforce limits with user min/max options\r\n\t\t\tmin = parse(timeOpts.min, me) || min;\r\n\t\t\tmax = parse(timeOpts.max, me) || max;\r\n\r\n\t\t\t// Remove ticks outside the min/max range\r\n\t\t\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\r\n\t\t\t\ttimestamp = timestamps[i];\r\n\t\t\t\tif (timestamp >= min && timestamp <= max) {\r\n\t\t\t\t\tticks.push(timestamp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tme.min = min;\r\n\t\t\tme.max = max;\r\n\r\n\t\t\t// PRIVATE\r\n\t\t\tme._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);\r\n\t\t\tme._majorUnit = determineMajorUnit(me._unit);\r\n\t\t\tme._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);\r\n\t\t\tme._offsets = computeOffsets(me._table, ticks, min, max, options);\r\n\t\t\tme._labelFormat = determineLabelFormat(me._timestamps.data, timeOpts);\r\n\r\n\t\t\tif (options.ticks.reverse) {\r\n\t\t\t\tticks.reverse();\r\n\t\t\t}\r\n\r\n\t\t\treturn ticksFromTimestamps(ticks, me._majorUnit);\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"computeOffsets","start_line":362,"end_line":387,"comment":["*\r\n * Returns the end and start offsets from edges in the form of {start, end}.\r\n * Offsets are added when the `offset` option is true.\r\n "],"params":["table","ticks","min","max","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"determineLabelFormat","line":646,"func_location":"module.exports.TimeScale.buildTicks","func_start_line":599,"func_end_line":653,"args":["me._timestamps.data","timeOpts"],"code":"\t\tbuildTicks: function() {\r\n\t\t\tvar me = this;\r\n\t\t\tvar min = me.min;\r\n\t\t\tvar max = me.max;\r\n\t\t\tvar options = me.options;\r\n\t\t\tvar timeOpts = options.time;\r\n\t\t\tvar timestamps = [];\r\n\t\t\tvar ticks = [];\r\n\t\t\tvar i, ilen, timestamp;\r\n\r\n\t\t\tswitch (options.ticks.source) {\r\n\t\t\tcase 'data':\r\n\t\t\t\ttimestamps = me._timestamps.data;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'labels':\r\n\t\t\t\ttimestamps = me._timestamps.labels;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'auto':\r\n\t\t\tdefault:\r\n\t\t\t\ttimestamps = generate(min, max, me.getLabelCapacity(min), options);\r\n\t\t\t}\r\n\r\n\t\t\tif (options.bounds === 'ticks' && timestamps.length) {\r\n\t\t\t\tmin = timestamps[0];\r\n\t\t\t\tmax = timestamps[timestamps.length - 1];\r\n\t\t\t}\r\n\r\n\t\t\t// Enforce limits with user min/max options\r\n\t\t\tmin = parse(timeOpts.min, me) || min;\r\n\t\t\tmax = parse(timeOpts.max, me) || max;\r\n\r\n\t\t\t// Remove ticks outside the min/max range\r\n\t\t\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\r\n\t\t\t\ttimestamp = timestamps[i];\r\n\t\t\t\tif (timestamp >= min && timestamp <= max) {\r\n\t\t\t\t\tticks.push(timestamp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tme.min = min;\r\n\t\t\tme.max = max;\r\n\r\n\t\t\t// PRIVATE\r\n\t\t\tme._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);\r\n\t\t\tme._majorUnit = determineMajorUnit(me._unit);\r\n\t\t\tme._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);\r\n\t\t\tme._offsets = computeOffsets(me._table, ticks, min, max, options);\r\n\t\t\tme._labelFormat = determineLabelFormat(me._timestamps.data, timeOpts);\r\n\r\n\t\t\tif (options.ticks.reverse) {\r\n\t\t\t\tticks.reverse();\r\n\t\t\t}\r\n\r\n\t\t\treturn ticksFromTimestamps(ticks, me._majorUnit);\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"determineLabelFormat","start_line":406,"end_line":425,"comment":[],"params":["data","timeOpts"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"ticksFromTimestamps","line":652,"func_location":"module.exports.TimeScale.buildTicks","func_start_line":599,"func_end_line":653,"args":["ticks","me._majorUnit"],"code":"\t\tbuildTicks: function() {\r\n\t\t\tvar me = this;\r\n\t\t\tvar min = me.min;\r\n\t\t\tvar max = me.max;\r\n\t\t\tvar options = me.options;\r\n\t\t\tvar timeOpts = options.time;\r\n\t\t\tvar timestamps = [];\r\n\t\t\tvar ticks = [];\r\n\t\t\tvar i, ilen, timestamp;\r\n\r\n\t\t\tswitch (options.ticks.source) {\r\n\t\t\tcase 'data':\r\n\t\t\t\ttimestamps = me._timestamps.data;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'labels':\r\n\t\t\t\ttimestamps = me._timestamps.labels;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'auto':\r\n\t\t\tdefault:\r\n\t\t\t\ttimestamps = generate(min, max, me.getLabelCapacity(min), options);\r\n\t\t\t}\r\n\r\n\t\t\tif (options.bounds === 'ticks' && timestamps.length) {\r\n\t\t\t\tmin = timestamps[0];\r\n\t\t\t\tmax = timestamps[timestamps.length - 1];\r\n\t\t\t}\r\n\r\n\t\t\t// Enforce limits with user min/max options\r\n\t\t\tmin = parse(timeOpts.min, me) || min;\r\n\t\t\tmax = parse(timeOpts.max, me) || max;\r\n\r\n\t\t\t// Remove ticks outside the min/max range\r\n\t\t\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\r\n\t\t\t\ttimestamp = timestamps[i];\r\n\t\t\t\tif (timestamp >= min && timestamp <= max) {\r\n\t\t\t\t\tticks.push(timestamp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tme.min = min;\r\n\t\t\tme.max = max;\r\n\r\n\t\t\t// PRIVATE\r\n\t\t\tme._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);\r\n\t\t\tme._majorUnit = determineMajorUnit(me._unit);\r\n\t\t\tme._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);\r\n\t\t\tme._offsets = computeOffsets(me._table, ticks, min, max, options);\r\n\t\t\tme._labelFormat = determineLabelFormat(me._timestamps.data, timeOpts);\r\n\r\n\t\t\tif (options.ticks.reverse) {\r\n\t\t\t\tticks.reverse();\r\n\t\t\t}\r\n\r\n\t\t\treturn ticksFromTimestamps(ticks, me._majorUnit);\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"ticksFromTimestamps","start_line":389,"end_line":404,"comment":[],"params":["values","majorUnit"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.bar.js","name":"computeFlexCategoryTraits","line":366,"func_location":"calculateBarIndexPixels","func_start_line":362,"func_end_line":381,"args":["index","ruler","options"],"comment":["*\r\n\t * @private\r\n\t "],"code":"\tcalculateBarIndexPixels: function(datasetIndex, index, ruler) {\r\n\t\tvar me = this;\r\n\t\tvar options = ruler.scale.options;\r\n\t\tvar range = options.barThickness === 'flex'\r\n\t\t\t? computeFlexCategoryTraits(index, ruler, options)\r\n\t\t\t: computeFitCategoryTraits(index, ruler, options);\r\n\r\n\t\tvar stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);\r\n\t\tvar center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\r\n\t\tvar size = Math.min(\r\n\t\t\thelpers.valueOrDefault(options.maxBarThickness, Infinity),\r\n\t\t\trange.chunk * range.ratio);\r\n\r\n\t\treturn {\r\n\t\t\tbase: center - size / 2,\r\n\t\t\thead: center + size / 2,\r\n\t\t\tcenter: center,\r\n\t\t\tsize: size\r\n\t\t};\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.bar.js","name":"computeFlexCategoryTraits","start_line":88,"end_line":115,"comment":["*\r\n * Computes an \"optimal\" category that globally arranges bars side by side (no gap when\r\n * percentage options are 1), based on the previous and following categories. This mode\r\n * generates bars with different widths when data are not evenly spaced.\r\n * @private\r\n "],"params":["index","ruler","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.bar.js","name":"computeFitCategoryTraits","line":367,"func_location":"calculateBarIndexPixels","func_start_line":362,"func_end_line":381,"args":["index","ruler","options"],"comment":["*\r\n\t * @private\r\n\t "],"code":"\tcalculateBarIndexPixels: function(datasetIndex, index, ruler) {\r\n\t\tvar me = this;\r\n\t\tvar options = ruler.scale.options;\r\n\t\tvar range = options.barThickness === 'flex'\r\n\t\t\t? computeFlexCategoryTraits(index, ruler, options)\r\n\t\t\t: computeFitCategoryTraits(index, ruler, options);\r\n\r\n\t\tvar stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);\r\n\t\tvar center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\r\n\t\tvar size = Math.min(\r\n\t\t\thelpers.valueOrDefault(options.maxBarThickness, Infinity),\r\n\t\t\trange.chunk * range.ratio);\r\n\r\n\t\treturn {\r\n\t\t\tbase: center - size / 2,\r\n\t\t\thead: center + size / 2,\r\n\t\t\tcenter: center,\r\n\t\t\tsize: size\r\n\t\t};\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.bar.js","name":"computeFitCategoryTraits","start_line":58,"end_line":80,"comment":["*\r\n * Computes an \"ideal\" category based on the absolute bar thickness or, if undefined or null,\r\n * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This\r\n * mode currently always generates bars equally sized (until we introduce scriptable options?).\r\n * @private\r\n "],"params":["index","ruler","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.scale.js","name":"labelsFromTicks","line":316,"func_location":"calculateTickRotation","func_start_line":312,"func_end_line":351,"args":["me._ticks"],"code":"\tcalculateTickRotation: function() {\r\n\t\tvar me = this;\r\n\t\tvar context = me.ctx;\r\n\t\tvar tickOpts = me.options.ticks;\r\n\t\tvar labels = labelsFromTicks(me._ticks);\r\n\r\n\t\t// Get the width of each grid by calculating the difference\r\n\t\t// between x offsets between 0 and 1.\r\n\t\tvar tickFont = helpers.options._parseFont(tickOpts);\r\n\t\tcontext.font = tickFont.string;\r\n\r\n\t\tvar labelRotation = tickOpts.minRotation || 0;\r\n\r\n\t\tif (labels.length && me.options.display && me.isHorizontal()) {\r\n\t\t\tvar originalLabelWidth = helpers.longestText(context, tickFont.string, labels, me.longestTextCache);\r\n\t\t\tvar labelWidth = originalLabelWidth;\r\n\t\t\tvar cosRotation, sinRotation;\r\n\r\n\t\t\t// Allow 3 pixels x2 padding either side for label readability\r\n\t\t\tvar tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;\r\n\r\n\t\t\t// Max label rotation can be set or default to 90 - also act as a loop counter\r\n\t\t\twhile (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {\r\n\t\t\t\tvar angleRadians = helpers.toRadians(labelRotation);\r\n\t\t\t\tcosRotation = Math.cos(angleRadians);\r\n\t\t\t\tsinRotation = Math.sin(angleRadians);\r\n\r\n\t\t\t\tif (sinRotation * originalLabelWidth > me.maxHeight) {\r\n\t\t\t\t\t// go back one step\r\n\t\t\t\t\tlabelRotation--;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlabelRotation++;\r\n\t\t\t\tlabelWidth = cosRotation * originalLabelWidth;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tme.labelRotation = labelRotation;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.scale.js","name":"labelsFromTicks","start_line":65,"end_line":74,"comment":[],"params":["ticks"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"isArray","line":173,"func_location":"helpers.clone","func_start_line":172,"func_end_line":191,"args":["source"],"comment":["*\r\n\t * Returns a deep copy of `source` without keeping references on objects and arrays.\r\n\t * @param {*} source - The value to clone.\r\n\t * @returns {*}\r\n\t "],"code":"\tclone: function(source) {\r\n\t\tif (helpers.isArray(source)) {\r\n\t\t\treturn source.map(helpers.clone);\r\n\t\t}\r\n\r\n\t\tif (helpers.isObject(source)) {\r\n\t\t\tvar target = {};\r\n\t\t\tvar keys = Object.keys(source);\r\n\t\t\tvar klen = keys.length;\r\n\t\t\tvar k = 0;\r\n\r\n\t\t\tfor (; k < klen; ++k) {\r\n\t\t\t\ttarget[keys[k]] = helpers.clone(source[keys[k]]);\r\n\t\t\t}\r\n\r\n\t\t\treturn target;\r\n\t\t}\r\n\r\n\t\treturn source;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"helpers.isArray","start_line":40,"end_line":49,"comment":["*\r\n\t * Returns true if `value` is an array (including typed arrays), else returns false.\r\n\t * @param {*} value - The value to test.\r\n\t * @returns {Boolean}\r\n\t * @function\r\n\t "],"params":["value"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"isObject","line":177,"func_location":"helpers.clone","func_start_line":172,"func_end_line":191,"args":["source"],"comment":["*\r\n\t * Returns a deep copy of `source` without keeping references on objects and arrays.\r\n\t * @param {*} source - The value to clone.\r\n\t * @returns {*}\r\n\t "],"code":"\tclone: function(source) {\r\n\t\tif (helpers.isArray(source)) {\r\n\t\t\treturn source.map(helpers.clone);\r\n\t\t}\r\n\r\n\t\tif (helpers.isObject(source)) {\r\n\t\t\tvar target = {};\r\n\t\t\tvar keys = Object.keys(source);\r\n\t\t\tvar klen = keys.length;\r\n\t\t\tvar k = 0;\r\n\r\n\t\t\tfor (; k < klen; ++k) {\r\n\t\t\t\ttarget[keys[k]] = helpers.clone(source[keys[k]]);\r\n\t\t\t}\r\n\r\n\t\t\treturn target;\r\n\t\t}\r\n\r\n\t\treturn source;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"helpers.isObject","start_line":57,"end_line":59,"comment":["*\r\n\t * Returns true if `value` is an object (excluding null), else returns false.\r\n\t * @param {*} value - The value to test.\r\n\t * @returns {Boolean}\r\n\t * @since 2.7.0\r\n\t "],"params":["value"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"clone","line":184,"func_location":"helpers.clone","func_start_line":172,"func_end_line":191,"args":["source."],"comment":["*\r\n\t * Returns a deep copy of `source` without keeping references on objects and arrays.\r\n\t * @param {*} source - The value to clone.\r\n\t * @returns {*}\r\n\t "],"code":"\tclone: function(source) {\r\n\t\tif (helpers.isArray(source)) {\r\n\t\t\treturn source.map(helpers.clone);\r\n\t\t}\r\n\r\n\t\tif (helpers.isObject(source)) {\r\n\t\t\tvar target = {};\r\n\t\t\tvar keys = Object.keys(source);\r\n\t\t\tvar klen = keys.length;\r\n\t\t\tvar k = 0;\r\n\r\n\t\t\tfor (; k < klen; ++k) {\r\n\t\t\t\ttarget[keys[k]] = helpers.clone(source[keys[k]]);\r\n\t\t\t}\r\n\r\n\t\t\treturn target;\r\n\t\t}\r\n\r\n\t\treturn source;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"helpers.clone","start_line":172,"end_line":191,"comment":["*\r\n\t * Returns a deep copy of `source` without keeping references on objects and arrays.\r\n\t * @param {*} source - The value to clone.\r\n\t * @returns {*}\r\n\t "],"params":["source"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"interpolate","line":372,"func_location":"computeOffsets","func_start_line":362,"func_end_line":387,"args":["table",{"type":"string"},"upper",{"type":"string"}],"comment":["*\r\n * Returns the end and start offsets from edges in the form of {start, end}.\r\n * Offsets are added when the `offset` option is true.\r\n "],"code":"function computeOffsets(table, ticks, min, max, options) {\r\n\tvar start = 0;\r\n\tvar end = 0;\r\n\tvar upper, lower;\r\n\r\n\tif (options.offset && ticks.length) {\r\n\t\tif (!options.time.min) {\r\n\t\t\tupper = ticks.length > 1 ? ticks[1] : max;\r\n\t\t\tlower = ticks[0];\r\n\t\t\tstart = (\r\n\t\t\t\tinterpolate(table, 'time', upper, 'pos') -\r\n\t\t\t\tinterpolate(table, 'time', lower, 'pos')\r\n\t\t\t) / 2;\r\n\t\t}\r\n\t\tif (!options.time.max) {\r\n\t\t\tupper = ticks[ticks.length - 1];\r\n\t\t\tlower = ticks.length > 1 ? ticks[ticks.length - 2] : min;\r\n\t\t\tend = (\r\n\t\t\t\tinterpolate(table, 'time', upper, 'pos') -\r\n\t\t\t\tinterpolate(table, 'time', lower, 'pos')\r\n\t\t\t) / 2;\r\n\t\t}\r\n\t}\r\n\r\n\treturn options.ticks.reverse ? {start: end, end: start} : {start: start, end: end};\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"interpolate","start_line":166,"end_line":178,"comment":["*\r\n * Linearly interpolates the given source `value` using the table items `skey` values and\r\n * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')\r\n * returns the position for a timestamp equal to 42. If value is out of bounds, values at\r\n * index [0, 1] or [n - 1, n] are used for the interpolation.\r\n "],"params":["table","skey","sval","tkey"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"interpolate","line":373,"func_location":"computeOffsets","func_start_line":362,"func_end_line":387,"args":["table",{"type":"string"},"lower",{"type":"string"}],"comment":["*\r\n * Returns the end and start offsets from edges in the form of {start, end}.\r\n * Offsets are added when the `offset` option is true.\r\n "],"code":"function computeOffsets(table, ticks, min, max, options) {\r\n\tvar start = 0;\r\n\tvar end = 0;\r\n\tvar upper, lower;\r\n\r\n\tif (options.offset && ticks.length) {\r\n\t\tif (!options.time.min) {\r\n\t\t\tupper = ticks.length > 1 ? ticks[1] : max;\r\n\t\t\tlower = ticks[0];\r\n\t\t\tstart = (\r\n\t\t\t\tinterpolate(table, 'time', upper, 'pos') -\r\n\t\t\t\tinterpolate(table, 'time', lower, 'pos')\r\n\t\t\t) / 2;\r\n\t\t}\r\n\t\tif (!options.time.max) {\r\n\t\t\tupper = ticks[ticks.length - 1];\r\n\t\t\tlower = ticks.length > 1 ? ticks[ticks.length - 2] : min;\r\n\t\t\tend = (\r\n\t\t\t\tinterpolate(table, 'time', upper, 'pos') -\r\n\t\t\t\tinterpolate(table, 'time', lower, 'pos')\r\n\t\t\t) / 2;\r\n\t\t}\r\n\t}\r\n\r\n\treturn options.ticks.reverse ? {start: end, end: start} : {start: start, end: end};\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"interpolate","start_line":166,"end_line":178,"comment":["*\r\n * Linearly interpolates the given source `value` using the table items `skey` values and\r\n * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')\r\n * returns the position for a timestamp equal to 42. If value is out of bounds, values at\r\n * index [0, 1] or [n - 1, n] are used for the interpolation.\r\n "],"params":["table","skey","sval","tkey"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"interpolate","line":380,"func_location":"computeOffsets","func_start_line":362,"func_end_line":387,"args":["table",{"type":"string"},"upper",{"type":"string"}],"comment":["*\r\n * Returns the end and start offsets from edges in the form of {start, end}.\r\n * Offsets are added when the `offset` option is true.\r\n "],"code":"function computeOffsets(table, ticks, min, max, options) {\r\n\tvar start = 0;\r\n\tvar end = 0;\r\n\tvar upper, lower;\r\n\r\n\tif (options.offset && ticks.length) {\r\n\t\tif (!options.time.min) {\r\n\t\t\tupper = ticks.length > 1 ? ticks[1] : max;\r\n\t\t\tlower = ticks[0];\r\n\t\t\tstart = (\r\n\t\t\t\tinterpolate(table, 'time', upper, 'pos') -\r\n\t\t\t\tinterpolate(table, 'time', lower, 'pos')\r\n\t\t\t) / 2;\r\n\t\t}\r\n\t\tif (!options.time.max) {\r\n\t\t\tupper = ticks[ticks.length - 1];\r\n\t\t\tlower = ticks.length > 1 ? ticks[ticks.length - 2] : min;\r\n\t\t\tend = (\r\n\t\t\t\tinterpolate(table, 'time', upper, 'pos') -\r\n\t\t\t\tinterpolate(table, 'time', lower, 'pos')\r\n\t\t\t) / 2;\r\n\t\t}\r\n\t}\r\n\r\n\treturn options.ticks.reverse ? {start: end, end: start} : {start: start, end: end};\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"interpolate","start_line":166,"end_line":178,"comment":["*\r\n * Linearly interpolates the given source `value` using the table items `skey` values and\r\n * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')\r\n * returns the position for a timestamp equal to 42. If value is out of bounds, values at\r\n * index [0, 1] or [n - 1, n] are used for the interpolation.\r\n "],"params":["table","skey","sval","tkey"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"interpolate","line":381,"func_location":"computeOffsets","func_start_line":362,"func_end_line":387,"args":["table",{"type":"string"},"lower",{"type":"string"}],"comment":["*\r\n * Returns the end and start offsets from edges in the form of {start, end}.\r\n * Offsets are added when the `offset` option is true.\r\n "],"code":"function computeOffsets(table, ticks, min, max, options) {\r\n\tvar start = 0;\r\n\tvar end = 0;\r\n\tvar upper, lower;\r\n\r\n\tif (options.offset && ticks.length) {\r\n\t\tif (!options.time.min) {\r\n\t\t\tupper = ticks.length > 1 ? ticks[1] : max;\r\n\t\t\tlower = ticks[0];\r\n\t\t\tstart = (\r\n\t\t\t\tinterpolate(table, 'time', upper, 'pos') -\r\n\t\t\t\tinterpolate(table, 'time', lower, 'pos')\r\n\t\t\t) / 2;\r\n\t\t}\r\n\t\tif (!options.time.max) {\r\n\t\t\tupper = ticks[ticks.length - 1];\r\n\t\t\tlower = ticks.length > 1 ? ticks[ticks.length - 2] : min;\r\n\t\t\tend = (\r\n\t\t\t\tinterpolate(table, 'time', upper, 'pos') -\r\n\t\t\t\tinterpolate(table, 'time', lower, 'pos')\r\n\t\t\t) / 2;\r\n\t\t}\r\n\t}\r\n\r\n\treturn options.ticks.reverse ? {start: end, end: start} : {start: start, end: end};\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"interpolate","start_line":166,"end_line":178,"comment":["*\r\n * Linearly interpolates the given source `value` using the table items `skey` values and\r\n * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')\r\n * returns the position for a timestamp equal to 42. If value is out of bounds, values at\r\n * index [0, 1] or [n - 1, n] are used for the interpolation.\r\n "],"params":["table","skey","sval","tkey"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.controller.js","name":"initConfig","line":79,"func_location":"construct","func_start_line":76,"func_end_line":131,"args":["config"],"comment":["*\r\n\t\t * @private\r\n\t\t "],"code":"\t\tconstruct: function(item, config) {\r\n\t\t\tvar me = this;\r\n\r\n\t\t\tconfig = initConfig(config);\r\n\r\n\t\t\tvar context = platform.acquireContext(item, config);\r\n\t\t\tvar canvas = context && context.canvas;\r\n\t\t\tvar height = canvas && canvas.height;\r\n\t\t\tvar width = canvas && canvas.width;\r\n\r\n\t\t\tme.id = helpers.uid();\r\n\t\t\tme.ctx = context;\r\n\t\t\tme.canvas = canvas;\r\n\t\t\tme.config = config;\r\n\t\t\tme.width = width;\r\n\t\t\tme.height = height;\r\n\t\t\tme.aspectRatio = height ? width / height : null;\r\n\t\t\tme.options = config.options;\r\n\t\t\tme._bufferedRender = false;\r\n\r\n\t\t\t/**\r\n\t\t\t * Provided for backward compatibility, Chart and Chart.Controller have been merged,\r\n\t\t\t * the \"instance\" still need to be defined since it might be called from plugins.\r\n\t\t\t * @prop Chart#chart\r\n\t\t\t * @deprecated since version 2.6.0\r\n\t\t\t * @todo remove at version 3\r\n\t\t\t * @private\r\n\t\t\t */\r\n\t\t\tme.chart = me;\r\n\t\t\tme.controller = me; // chart.chart.controller #inception\r\n\r\n\t\t\t// Add the chart instance to the global namespace\r\n\t\t\tChart.instances[me.id] = me;\r\n\r\n\t\t\t// Define alias to the config data: `chart.data === chart.config.data`\r\n\t\t\tObject.defineProperty(me, 'data', {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn me.config.data;\r\n\t\t\t\t},\r\n\t\t\t\tset: function(value) {\r\n\t\t\t\t\tme.config.data = value;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tif (!context || !canvas) {\r\n\t\t\t\t// The given item is not a compatible context2d element, let's return before finalizing\r\n\t\t\t\t// the chart initialization but after setting basic chart / controller properties that\r\n\t\t\t\t// can help to figure out that the chart is not valid (e.g chart.canvas !== null);\r\n\t\t\t\t// https://github.com/chartjs/Chart.js/issues/2807\r\n\t\t\t\tconsole.error(\"Failed to create chart: can't acquire context from the given item\");\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tme.initialize();\r\n\t\t\tme.update();\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.controller.js","name":"module.exports.initConfig","start_line":27,"end_line":42,"comment":["*\r\n\t * Initializes the given config with global and chart default values.\r\n\t "],"params":["config"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.linearbase.js","name":"convertTicksToLabels","line":195,"func_location":"convertTicksToLabels","func_start_line":190,"func_end_line":196,"args":["me"],"code":"\t\tconvertTicksToLabels: function() {\r\n\t\t\tvar me = this;\r\n\t\t\tme.ticksAsNumbers = me.ticks.slice();\r\n\t\t\tme.zeroLineIndex = me.ticks.indexOf(0);\r\n\r\n\t\t\tScale.prototype.convertTicksToLabels.call(me);\r\n\t\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.linearbase.js","name":"convertTicksToLabels","start_line":190,"end_line":196,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"createDiv","line":193,"func_location":"createResizer","func_start_line":177,"func_end_line":230,"args":["cls","style"],"comment":[" Implementation based on https://github.com/marcj/css-element-queries"],"code":"function createResizer(handler) {\r\n\tvar cls = CSS_PREFIX + 'size-monitor';\r\n\tvar maxSize = 1000000;\r\n\tvar style =\r\n\t\t'position:absolute;' +\r\n\t\t'left:0;' +\r\n\t\t'top:0;' +\r\n\t\t'right:0;' +\r\n\t\t'bottom:0;' +\r\n\t\t'overflow:hidden;' +\r\n\t\t'pointer-events:none;' +\r\n\t\t'visibility:hidden;' +\r\n\t\t'z-index:-1;';\r\n\r\n\t// NOTE(SB) Don't use innerHTML because it could be considered unsafe.\r\n\t// https://github.com/chartjs/Chart.js/issues/5902\r\n\tvar resizer = createDiv(cls, style);\r\n\tvar expand = createDiv(cls + '-expand', style);\r\n\tvar shrink = createDiv(cls + '-shrink', style);\r\n\r\n\texpand.appendChild(createDiv('',\r\n\t\t'position:absolute;' +\r\n\t\t'height:' + maxSize + 'px;' +\r\n\t\t'width:' + maxSize + 'px;' +\r\n\t\t'left:0;' +\r\n\t\t'top:0;'\r\n\t));\r\n\tshrink.appendChild(createDiv('',\r\n\t\t'position:absolute;' +\r\n\t\t'height:200%;' +\r\n\t\t'width:200%;' +\r\n\t\t'left:0;' +\r\n\t\t'top:0;'\r\n\t));\r\n\r\n\tresizer.appendChild(expand);\r\n\tresizer.appendChild(shrink);\r\n\tresizer._reset = function() {\r\n\t\texpand.scrollLeft = maxSize;\r\n\t\texpand.scrollTop = maxSize;\r\n\t\tshrink.scrollLeft = maxSize;\r\n\t\tshrink.scrollTop = maxSize;\r\n\t};\r\n\r\n\tvar onScroll = function() {\r\n\t\tresizer._reset();\r\n\t\thandler();\r\n\t};\r\n\r\n\taddEventListener(expand, 'scroll', onScroll.bind(expand, 'expand'));\r\n\taddEventListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));\r\n\r\n\treturn resizer;\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"createDiv","start_line":169,"end_line":174,"comment":[],"params":["cls","style"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"createDiv","line":194,"func_location":"createResizer","func_start_line":177,"func_end_line":230,"args":[null,"style"],"comment":[" Implementation based on https://github.com/marcj/css-element-queries"],"code":"function createResizer(handler) {\r\n\tvar cls = CSS_PREFIX + 'size-monitor';\r\n\tvar maxSize = 1000000;\r\n\tvar style =\r\n\t\t'position:absolute;' +\r\n\t\t'left:0;' +\r\n\t\t'top:0;' +\r\n\t\t'right:0;' +\r\n\t\t'bottom:0;' +\r\n\t\t'overflow:hidden;' +\r\n\t\t'pointer-events:none;' +\r\n\t\t'visibility:hidden;' +\r\n\t\t'z-index:-1;';\r\n\r\n\t// NOTE(SB) Don't use innerHTML because it could be considered unsafe.\r\n\t// https://github.com/chartjs/Chart.js/issues/5902\r\n\tvar resizer = createDiv(cls, style);\r\n\tvar expand = createDiv(cls + '-expand', style);\r\n\tvar shrink = createDiv(cls + '-shrink', style);\r\n\r\n\texpand.appendChild(createDiv('',\r\n\t\t'position:absolute;' +\r\n\t\t'height:' + maxSize + 'px;' +\r\n\t\t'width:' + maxSize + 'px;' +\r\n\t\t'left:0;' +\r\n\t\t'top:0;'\r\n\t));\r\n\tshrink.appendChild(createDiv('',\r\n\t\t'position:absolute;' +\r\n\t\t'height:200%;' +\r\n\t\t'width:200%;' +\r\n\t\t'left:0;' +\r\n\t\t'top:0;'\r\n\t));\r\n\r\n\tresizer.appendChild(expand);\r\n\tresizer.appendChild(shrink);\r\n\tresizer._reset = function() {\r\n\t\texpand.scrollLeft = maxSize;\r\n\t\texpand.scrollTop = maxSize;\r\n\t\tshrink.scrollLeft = maxSize;\r\n\t\tshrink.scrollTop = maxSize;\r\n\t};\r\n\r\n\tvar onScroll = function() {\r\n\t\tresizer._reset();\r\n\t\thandler();\r\n\t};\r\n\r\n\taddEventListener(expand, 'scroll', onScroll.bind(expand, 'expand'));\r\n\taddEventListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));\r\n\r\n\treturn resizer;\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"createDiv","start_line":169,"end_line":174,"comment":[],"params":["cls","style"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"createDiv","line":195,"func_location":"createResizer","func_start_line":177,"func_end_line":230,"args":[null,"style"],"comment":[" Implementation based on https://github.com/marcj/css-element-queries"],"code":"function createResizer(handler) {\r\n\tvar cls = CSS_PREFIX + 'size-monitor';\r\n\tvar maxSize = 1000000;\r\n\tvar style =\r\n\t\t'position:absolute;' +\r\n\t\t'left:0;' +\r\n\t\t'top:0;' +\r\n\t\t'right:0;' +\r\n\t\t'bottom:0;' +\r\n\t\t'overflow:hidden;' +\r\n\t\t'pointer-events:none;' +\r\n\t\t'visibility:hidden;' +\r\n\t\t'z-index:-1;';\r\n\r\n\t// NOTE(SB) Don't use innerHTML because it could be considered unsafe.\r\n\t// https://github.com/chartjs/Chart.js/issues/5902\r\n\tvar resizer = createDiv(cls, style);\r\n\tvar expand = createDiv(cls + '-expand', style);\r\n\tvar shrink = createDiv(cls + '-shrink', style);\r\n\r\n\texpand.appendChild(createDiv('',\r\n\t\t'position:absolute;' +\r\n\t\t'height:' + maxSize + 'px;' +\r\n\t\t'width:' + maxSize + 'px;' +\r\n\t\t'left:0;' +\r\n\t\t'top:0;'\r\n\t));\r\n\tshrink.appendChild(createDiv('',\r\n\t\t'position:absolute;' +\r\n\t\t'height:200%;' +\r\n\t\t'width:200%;' +\r\n\t\t'left:0;' +\r\n\t\t'top:0;'\r\n\t));\r\n\r\n\tresizer.appendChild(expand);\r\n\tresizer.appendChild(shrink);\r\n\tresizer._reset = function() {\r\n\t\texpand.scrollLeft = maxSize;\r\n\t\texpand.scrollTop = maxSize;\r\n\t\tshrink.scrollLeft = maxSize;\r\n\t\tshrink.scrollTop = maxSize;\r\n\t};\r\n\r\n\tvar onScroll = function() {\r\n\t\tresizer._reset();\r\n\t\thandler();\r\n\t};\r\n\r\n\taddEventListener(expand, 'scroll', onScroll.bind(expand, 'expand'));\r\n\taddEventListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));\r\n\r\n\treturn resizer;\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"createDiv","start_line":169,"end_line":174,"comment":[],"params":["cls","style"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"createDiv","line":197,"func_location":"createResizer","func_start_line":177,"func_end_line":230},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"createDiv","start_line":169,"end_line":174,"comment":[],"params":["cls","style"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"createDiv","line":204,"func_location":"createResizer","func_start_line":177,"func_end_line":230},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"createDiv","start_line":169,"end_line":174,"comment":[],"params":["cls","style"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"addEventListener","line":226,"func_location":"createResizer","func_start_line":177,"func_end_line":230,"args":["expand",{"type":"string"},null],"comment":[" Implementation based on https://github.com/marcj/css-element-queries"],"code":"function createResizer(handler) {\r\n\tvar cls = CSS_PREFIX + 'size-monitor';\r\n\tvar maxSize = 1000000;\r\n\tvar style =\r\n\t\t'position:absolute;' +\r\n\t\t'left:0;' +\r\n\t\t'top:0;' +\r\n\t\t'right:0;' +\r\n\t\t'bottom:0;' +\r\n\t\t'overflow:hidden;' +\r\n\t\t'pointer-events:none;' +\r\n\t\t'visibility:hidden;' +\r\n\t\t'z-index:-1;';\r\n\r\n\t// NOTE(SB) Don't use innerHTML because it could be considered unsafe.\r\n\t// https://github.com/chartjs/Chart.js/issues/5902\r\n\tvar resizer = createDiv(cls, style);\r\n\tvar expand = createDiv(cls + '-expand', style);\r\n\tvar shrink = createDiv(cls + '-shrink', style);\r\n\r\n\texpand.appendChild(createDiv('',\r\n\t\t'position:absolute;' +\r\n\t\t'height:' + maxSize + 'px;' +\r\n\t\t'width:' + maxSize + 'px;' +\r\n\t\t'left:0;' +\r\n\t\t'top:0;'\r\n\t));\r\n\tshrink.appendChild(createDiv('',\r\n\t\t'position:absolute;' +\r\n\t\t'height:200%;' +\r\n\t\t'width:200%;' +\r\n\t\t'left:0;' +\r\n\t\t'top:0;'\r\n\t));\r\n\r\n\tresizer.appendChild(expand);\r\n\tresizer.appendChild(shrink);\r\n\tresizer._reset = function() {\r\n\t\texpand.scrollLeft = maxSize;\r\n\t\texpand.scrollTop = maxSize;\r\n\t\tshrink.scrollLeft = maxSize;\r\n\t\tshrink.scrollTop = maxSize;\r\n\t};\r\n\r\n\tvar onScroll = function() {\r\n\t\tresizer._reset();\r\n\t\thandler();\r\n\t};\r\n\r\n\taddEventListener(expand, 'scroll', onScroll.bind(expand, 'expand'));\r\n\taddEventListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));\r\n\r\n\treturn resizer;\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"addEventListener","start_line":127,"end_line":129,"comment":[],"params":["node","type","listener"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"addEventListener","line":227,"func_location":"createResizer","func_start_line":177,"func_end_line":230,"args":["shrink",{"type":"string"},null],"comment":[" Implementation based on https://github.com/marcj/css-element-queries"],"code":"function createResizer(handler) {\r\n\tvar cls = CSS_PREFIX + 'size-monitor';\r\n\tvar maxSize = 1000000;\r\n\tvar style =\r\n\t\t'position:absolute;' +\r\n\t\t'left:0;' +\r\n\t\t'top:0;' +\r\n\t\t'right:0;' +\r\n\t\t'bottom:0;' +\r\n\t\t'overflow:hidden;' +\r\n\t\t'pointer-events:none;' +\r\n\t\t'visibility:hidden;' +\r\n\t\t'z-index:-1;';\r\n\r\n\t// NOTE(SB) Don't use innerHTML because it could be considered unsafe.\r\n\t// https://github.com/chartjs/Chart.js/issues/5902\r\n\tvar resizer = createDiv(cls, style);\r\n\tvar expand = createDiv(cls + '-expand', style);\r\n\tvar shrink = createDiv(cls + '-shrink', style);\r\n\r\n\texpand.appendChild(createDiv('',\r\n\t\t'position:absolute;' +\r\n\t\t'height:' + maxSize + 'px;' +\r\n\t\t'width:' + maxSize + 'px;' +\r\n\t\t'left:0;' +\r\n\t\t'top:0;'\r\n\t));\r\n\tshrink.appendChild(createDiv('',\r\n\t\t'position:absolute;' +\r\n\t\t'height:200%;' +\r\n\t\t'width:200%;' +\r\n\t\t'left:0;' +\r\n\t\t'top:0;'\r\n\t));\r\n\r\n\tresizer.appendChild(expand);\r\n\tresizer.appendChild(shrink);\r\n\tresizer._reset = function() {\r\n\t\texpand.scrollLeft = maxSize;\r\n\t\texpand.scrollTop = maxSize;\r\n\t\tshrink.scrollLeft = maxSize;\r\n\t\tshrink.scrollTop = maxSize;\r\n\t};\r\n\r\n\tvar onScroll = function() {\r\n\t\tresizer._reset();\r\n\t\thandler();\r\n\t};\r\n\r\n\taddEventListener(expand, 'scroll', onScroll.bind(expand, 'expand'));\r\n\taddEventListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));\r\n\r\n\treturn resizer;\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"addEventListener","start_line":127,"end_line":129,"comment":[],"params":["node","type","listener"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getRelativePosition","line":199,"func_location":"module.exports.modes.dataset","func_start_line":198,"func_end_line":209,"args":["e","chart"],"comment":["*\r\n\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\r\n\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\r\n\t\t * @function Chart.Interaction.modes.dataset\r\n\t\t * @param chart {chart} the chart we are returning items from\r\n\t\t * @param e {Event} the event we are find things at\r\n\t\t * @param options {IInteractionOptions} options to use during interaction\r\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n\t\t "],"code":"\t\tdataset: function(chart, e, options) {\r\n\t\t\tvar position = getRelativePosition(e, chart);\r\n\t\t\toptions.axis = options.axis || 'xy';\r\n\t\t\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\r\n\t\t\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\r\n\r\n\t\t\tif (items.length > 0) {\r\n\t\t\t\titems = chart.getDatasetMeta(items[0]._datasetIndex).data;\r\n\t\t\t}\r\n\r\n\t\t\treturn items;\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getRelativePosition","start_line":11,"end_line":20,"comment":["*\r\n * Helper function to get relative position for an event\r\n * @param {Event|IEvent} event - The event to get the position for\r\n * @param {Chart} chart - The chart\r\n * @returns {Point} the event position\r\n "],"params":["e","chart"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getDistanceMetricForAxis","line":201,"func_location":"module.exports.modes.dataset","func_start_line":198,"func_end_line":209,"args":["options.axis"],"comment":["*\r\n\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\r\n\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\r\n\t\t * @function Chart.Interaction.modes.dataset\r\n\t\t * @param chart {chart} the chart we are returning items from\r\n\t\t * @param e {Event} the event we are find things at\r\n\t\t * @param options {IInteractionOptions} options to use during interaction\r\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n\t\t "],"code":"\t\tdataset: function(chart, e, options) {\r\n\t\t\tvar position = getRelativePosition(e, chart);\r\n\t\t\toptions.axis = options.axis || 'xy';\r\n\t\t\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\r\n\t\t\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\r\n\r\n\t\t\tif (items.length > 0) {\r\n\t\t\t\titems = chart.getDatasetMeta(items[0]._datasetIndex).data;\r\n\t\t\t}\r\n\r\n\t\t\treturn items;\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getDistanceMetricForAxis","start_line":101,"end_line":110,"comment":["*\r\n * Get a distance metric function for two points based on the\r\n * axis mode setting\r\n * @param {String} axis the axis mode. x|y|xy\r\n "],"params":["axis"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getIntersectItems","line":202,"func_location":"module.exports.modes.dataset","func_start_line":198,"func_end_line":209,"args":["chart","position"],"comment":["*\r\n\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\r\n\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\r\n\t\t * @function Chart.Interaction.modes.dataset\r\n\t\t * @param chart {chart} the chart we are returning items from\r\n\t\t * @param e {Event} the event we are find things at\r\n\t\t * @param options {IInteractionOptions} options to use during interaction\r\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n\t\t "],"code":"\t\tdataset: function(chart, e, options) {\r\n\t\t\tvar position = getRelativePosition(e, chart);\r\n\t\t\toptions.axis = options.axis || 'xy';\r\n\t\t\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\r\n\t\t\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\r\n\r\n\t\t\tif (items.length > 0) {\r\n\t\t\t\titems = chart.getDatasetMeta(items[0]._datasetIndex).data;\r\n\t\t\t}\r\n\r\n\t\t\treturn items;\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getIntersectItems","start_line":52,"end_line":62,"comment":["*\r\n * Helper function to get the items that intersect the event position\r\n * @param items {ChartElement[]} elements to filter\r\n * @param position {Point} the point to be nearest to\r\n * @return {ChartElement[]} the nearest items\r\n "],"params":["chart","position"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getNearestItems","line":202,"func_location":"module.exports.modes.dataset","func_start_line":198,"func_end_line":209,"args":["chart","position"],"comment":["*\r\n\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\r\n\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\r\n\t\t * @function Chart.Interaction.modes.dataset\r\n\t\t * @param chart {chart} the chart we are returning items from\r\n\t\t * @param e {Event} the event we are find things at\r\n\t\t * @param options {IInteractionOptions} options to use during interaction\r\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n\t\t "],"code":"\t\tdataset: function(chart, e, options) {\r\n\t\t\tvar position = getRelativePosition(e, chart);\r\n\t\t\toptions.axis = options.axis || 'xy';\r\n\t\t\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\r\n\t\t\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\r\n\r\n\t\t\tif (items.length > 0) {\r\n\t\t\t\titems = chart.getDatasetMeta(items[0]._datasetIndex).data;\r\n\t\t\t}\r\n\r\n\t\t\treturn items;\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getNearestItems","start_line":72,"end_line":94,"comment":["*\r\n * Helper function to get the items nearest to the event position considering all visible items in teh chart\r\n * @param chart {Chart} the chart to look at elements from\r\n * @param position {Point} the point to be nearest to\r\n * @param intersect {Boolean} if true, only consider items that intersect the position\r\n * @param distanceMetric {Function} function to provide the distance between points\r\n * @return {ChartElement[]} the nearest items\r\n "],"params":["chart","position","intersect","distanceMetric"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.datasetController.js","name":"unlistenArrayEvents","line":141,"func_location":"destroy","func_start_line":139,"func_end_line":143,"args":["._data",null],"comment":["*\r\n\t * @private\r\n\t "],"code":"\tdestroy: function() {\r\n\t\tif (this._data) {\r\n\t\t\tunlistenArrayEvents(this._data, this);\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.datasetController.js","name":"unlistenArrayEvents","start_line":53,"end_line":74,"comment":["*\r\n * Removes the given array event listener and cleanup extra attached properties (such as\r\n * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\r\n "],"params":["array","listener"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"lf","line":387,"func_location":"determineAlignment","func_start_line":342,"func_end_line":410,"args":["model.x"],"comment":["*\r\n * Helper to get the alignment of a tooltip given the size\r\n "],"code":"function determineAlignment(tooltip, size) {\r\n\tvar model = tooltip._model;\r\n\tvar chart = tooltip._chart;\r\n\tvar chartArea = tooltip._chart.chartArea;\r\n\tvar xAlign = 'center';\r\n\tvar yAlign = 'center';\r\n\r\n\tif (model.y < size.height) {\r\n\t\tyAlign = 'top';\r\n\t} else if (model.y > (chart.height - size.height)) {\r\n\t\tyAlign = 'bottom';\r\n\t}\r\n\r\n\tvar lf, rf; // functions to determine left, right alignment\r\n\tvar olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart\r\n\tvar yf; // function to get the y alignment if the tooltip goes outside of the left or right edges\r\n\tvar midX = (chartArea.left + chartArea.right) / 2;\r\n\tvar midY = (chartArea.top + chartArea.bottom) / 2;\r\n\r\n\tif (yAlign === 'center') {\r\n\t\tlf = function(x) {\r\n\t\t\treturn x <= midX;\r\n\t\t};\r\n\t\trf = function(x) {\r\n\t\t\treturn x > midX;\r\n\t\t};\r\n\t} else {\r\n\t\tlf = function(x) {\r\n\t\t\treturn x <= (size.width / 2);\r\n\t\t};\r\n\t\trf = function(x) {\r\n\t\t\treturn x >= (chart.width - (size.width / 2));\r\n\t\t};\r\n\t}\r\n\r\n\tolf = function(x) {\r\n\t\treturn x + size.width + model.caretSize + model.caretPadding > chart.width;\r\n\t};\r\n\torf = function(x) {\r\n\t\treturn x - size.width - model.caretSize - model.caretPadding < 0;\r\n\t};\r\n\tyf = function(y) {\r\n\t\treturn y <= midY ? 'top' : 'bottom';\r\n\t};\r\n\r\n\tif (lf(model.x)) {\r\n\t\txAlign = 'left';\r\n\r\n\t\t// Is tooltip too wide and goes over the right side of the chart.?\r\n\t\tif (olf(model.x)) {\r\n\t\t\txAlign = 'center';\r\n\t\t\tyAlign = yf(model.y);\r\n\t\t}\r\n\t} else if (rf(model.x)) {\r\n\t\txAlign = 'right';\r\n\r\n\t\t// Is tooltip too wide and goes outside left edge of canvas?\r\n\t\tif (orf(model.x)) {\r\n\t\t\txAlign = 'center';\r\n\t\t\tyAlign = yf(model.y);\r\n\t\t}\r\n\t}\r\n\r\n\tvar opts = tooltip._options;\r\n\treturn {\r\n\t\txAlign: opts.xAlign ? opts.xAlign : xAlign,\r\n\t\tyAlign: opts.yAlign ? opts.yAlign : yAlign\r\n\t};\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"determineAlignment.lf","start_line":355,"end_line":364}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"olf","line":391,"func_location":"determineAlignment","func_start_line":342,"func_end_line":410,"args":["model.x"],"comment":["*\r\n * Helper to get the alignment of a tooltip given the size\r\n "],"code":"function determineAlignment(tooltip, size) {\r\n\tvar model = tooltip._model;\r\n\tvar chart = tooltip._chart;\r\n\tvar chartArea = tooltip._chart.chartArea;\r\n\tvar xAlign = 'center';\r\n\tvar yAlign = 'center';\r\n\r\n\tif (model.y < size.height) {\r\n\t\tyAlign = 'top';\r\n\t} else if (model.y > (chart.height - size.height)) {\r\n\t\tyAlign = 'bottom';\r\n\t}\r\n\r\n\tvar lf, rf; // functions to determine left, right alignment\r\n\tvar olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart\r\n\tvar yf; // function to get the y alignment if the tooltip goes outside of the left or right edges\r\n\tvar midX = (chartArea.left + chartArea.right) / 2;\r\n\tvar midY = (chartArea.top + chartArea.bottom) / 2;\r\n\r\n\tif (yAlign === 'center') {\r\n\t\tlf = function(x) {\r\n\t\t\treturn x <= midX;\r\n\t\t};\r\n\t\trf = function(x) {\r\n\t\t\treturn x > midX;\r\n\t\t};\r\n\t} else {\r\n\t\tlf = function(x) {\r\n\t\t\treturn x <= (size.width / 2);\r\n\t\t};\r\n\t\trf = function(x) {\r\n\t\t\treturn x >= (chart.width - (size.width / 2));\r\n\t\t};\r\n\t}\r\n\r\n\tolf = function(x) {\r\n\t\treturn x + size.width + model.caretSize + model.caretPadding > chart.width;\r\n\t};\r\n\torf = function(x) {\r\n\t\treturn x - size.width - model.caretSize - model.caretPadding < 0;\r\n\t};\r\n\tyf = function(y) {\r\n\t\treturn y <= midY ? 'top' : 'bottom';\r\n\t};\r\n\r\n\tif (lf(model.x)) {\r\n\t\txAlign = 'left';\r\n\r\n\t\t// Is tooltip too wide and goes over the right side of the chart.?\r\n\t\tif (olf(model.x)) {\r\n\t\t\txAlign = 'center';\r\n\t\t\tyAlign = yf(model.y);\r\n\t\t}\r\n\t} else if (rf(model.x)) {\r\n\t\txAlign = 'right';\r\n\r\n\t\t// Is tooltip too wide and goes outside left edge of canvas?\r\n\t\tif (orf(model.x)) {\r\n\t\t\txAlign = 'center';\r\n\t\t\tyAlign = yf(model.y);\r\n\t\t}\r\n\t}\r\n\r\n\tvar opts = tooltip._options;\r\n\treturn {\r\n\t\txAlign: opts.xAlign ? opts.xAlign : xAlign,\r\n\t\tyAlign: opts.yAlign ? opts.yAlign : yAlign\r\n\t};\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"determineAlignment.olf","start_line":356,"end_line":379}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"yf","line":393,"func_location":"determineAlignment","func_start_line":342,"func_end_line":410,"args":["model.y"],"comment":["*\r\n * Helper to get the alignment of a tooltip given the size\r\n "],"code":"function determineAlignment(tooltip, size) {\r\n\tvar model = tooltip._model;\r\n\tvar chart = tooltip._chart;\r\n\tvar chartArea = tooltip._chart.chartArea;\r\n\tvar xAlign = 'center';\r\n\tvar yAlign = 'center';\r\n\r\n\tif (model.y < size.height) {\r\n\t\tyAlign = 'top';\r\n\t} else if (model.y > (chart.height - size.height)) {\r\n\t\tyAlign = 'bottom';\r\n\t}\r\n\r\n\tvar lf, rf; // functions to determine left, right alignment\r\n\tvar olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart\r\n\tvar yf; // function to get the y alignment if the tooltip goes outside of the left or right edges\r\n\tvar midX = (chartArea.left + chartArea.right) / 2;\r\n\tvar midY = (chartArea.top + chartArea.bottom) / 2;\r\n\r\n\tif (yAlign === 'center') {\r\n\t\tlf = function(x) {\r\n\t\t\treturn x <= midX;\r\n\t\t};\r\n\t\trf = function(x) {\r\n\t\t\treturn x > midX;\r\n\t\t};\r\n\t} else {\r\n\t\tlf = function(x) {\r\n\t\t\treturn x <= (size.width / 2);\r\n\t\t};\r\n\t\trf = function(x) {\r\n\t\t\treturn x >= (chart.width - (size.width / 2));\r\n\t\t};\r\n\t}\r\n\r\n\tolf = function(x) {\r\n\t\treturn x + size.width + model.caretSize + model.caretPadding > chart.width;\r\n\t};\r\n\torf = function(x) {\r\n\t\treturn x - size.width - model.caretSize - model.caretPadding < 0;\r\n\t};\r\n\tyf = function(y) {\r\n\t\treturn y <= midY ? 'top' : 'bottom';\r\n\t};\r\n\r\n\tif (lf(model.x)) {\r\n\t\txAlign = 'left';\r\n\r\n\t\t// Is tooltip too wide and goes over the right side of the chart.?\r\n\t\tif (olf(model.x)) {\r\n\t\t\txAlign = 'center';\r\n\t\t\tyAlign = yf(model.y);\r\n\t\t}\r\n\t} else if (rf(model.x)) {\r\n\t\txAlign = 'right';\r\n\r\n\t\t// Is tooltip too wide and goes outside left edge of canvas?\r\n\t\tif (orf(model.x)) {\r\n\t\t\txAlign = 'center';\r\n\t\t\tyAlign = yf(model.y);\r\n\t\t}\r\n\t}\r\n\r\n\tvar opts = tooltip._options;\r\n\treturn {\r\n\t\txAlign: opts.xAlign ? opts.xAlign : xAlign,\r\n\t\tyAlign: opts.yAlign ? opts.yAlign : yAlign\r\n\t};\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"determineAlignment.yf","start_line":357,"end_line":385}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"rf","line":395,"func_location":"determineAlignment","func_start_line":342,"func_end_line":410,"args":["model.x"],"comment":["*\r\n * Helper to get the alignment of a tooltip given the size\r\n "],"code":"function determineAlignment(tooltip, size) {\r\n\tvar model = tooltip._model;\r\n\tvar chart = tooltip._chart;\r\n\tvar chartArea = tooltip._chart.chartArea;\r\n\tvar xAlign = 'center';\r\n\tvar yAlign = 'center';\r\n\r\n\tif (model.y < size.height) {\r\n\t\tyAlign = 'top';\r\n\t} else if (model.y > (chart.height - size.height)) {\r\n\t\tyAlign = 'bottom';\r\n\t}\r\n\r\n\tvar lf, rf; // functions to determine left, right alignment\r\n\tvar olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart\r\n\tvar yf; // function to get the y alignment if the tooltip goes outside of the left or right edges\r\n\tvar midX = (chartArea.left + chartArea.right) / 2;\r\n\tvar midY = (chartArea.top + chartArea.bottom) / 2;\r\n\r\n\tif (yAlign === 'center') {\r\n\t\tlf = function(x) {\r\n\t\t\treturn x <= midX;\r\n\t\t};\r\n\t\trf = function(x) {\r\n\t\t\treturn x > midX;\r\n\t\t};\r\n\t} else {\r\n\t\tlf = function(x) {\r\n\t\t\treturn x <= (size.width / 2);\r\n\t\t};\r\n\t\trf = function(x) {\r\n\t\t\treturn x >= (chart.width - (size.width / 2));\r\n\t\t};\r\n\t}\r\n\r\n\tolf = function(x) {\r\n\t\treturn x + size.width + model.caretSize + model.caretPadding > chart.width;\r\n\t};\r\n\torf = function(x) {\r\n\t\treturn x - size.width - model.caretSize - model.caretPadding < 0;\r\n\t};\r\n\tyf = function(y) {\r\n\t\treturn y <= midY ? 'top' : 'bottom';\r\n\t};\r\n\r\n\tif (lf(model.x)) {\r\n\t\txAlign = 'left';\r\n\r\n\t\t// Is tooltip too wide and goes over the right side of the chart.?\r\n\t\tif (olf(model.x)) {\r\n\t\t\txAlign = 'center';\r\n\t\t\tyAlign = yf(model.y);\r\n\t\t}\r\n\t} else if (rf(model.x)) {\r\n\t\txAlign = 'right';\r\n\r\n\t\t// Is tooltip too wide and goes outside left edge of canvas?\r\n\t\tif (orf(model.x)) {\r\n\t\t\txAlign = 'center';\r\n\t\t\tyAlign = yf(model.y);\r\n\t\t}\r\n\t}\r\n\r\n\tvar opts = tooltip._options;\r\n\treturn {\r\n\t\txAlign: opts.xAlign ? opts.xAlign : xAlign,\r\n\t\tyAlign: opts.yAlign ? opts.yAlign : yAlign\r\n\t};\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"determineAlignment.rf","start_line":355,"end_line":367}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"orf","line":399,"func_location":"determineAlignment","func_start_line":342,"func_end_line":410,"args":["model.x"],"comment":["*\r\n * Helper to get the alignment of a tooltip given the size\r\n "],"code":"function determineAlignment(tooltip, size) {\r\n\tvar model = tooltip._model;\r\n\tvar chart = tooltip._chart;\r\n\tvar chartArea = tooltip._chart.chartArea;\r\n\tvar xAlign = 'center';\r\n\tvar yAlign = 'center';\r\n\r\n\tif (model.y < size.height) {\r\n\t\tyAlign = 'top';\r\n\t} else if (model.y > (chart.height - size.height)) {\r\n\t\tyAlign = 'bottom';\r\n\t}\r\n\r\n\tvar lf, rf; // functions to determine left, right alignment\r\n\tvar olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart\r\n\tvar yf; // function to get the y alignment if the tooltip goes outside of the left or right edges\r\n\tvar midX = (chartArea.left + chartArea.right) / 2;\r\n\tvar midY = (chartArea.top + chartArea.bottom) / 2;\r\n\r\n\tif (yAlign === 'center') {\r\n\t\tlf = function(x) {\r\n\t\t\treturn x <= midX;\r\n\t\t};\r\n\t\trf = function(x) {\r\n\t\t\treturn x > midX;\r\n\t\t};\r\n\t} else {\r\n\t\tlf = function(x) {\r\n\t\t\treturn x <= (size.width / 2);\r\n\t\t};\r\n\t\trf = function(x) {\r\n\t\t\treturn x >= (chart.width - (size.width / 2));\r\n\t\t};\r\n\t}\r\n\r\n\tolf = function(x) {\r\n\t\treturn x + size.width + model.caretSize + model.caretPadding > chart.width;\r\n\t};\r\n\torf = function(x) {\r\n\t\treturn x - size.width - model.caretSize - model.caretPadding < 0;\r\n\t};\r\n\tyf = function(y) {\r\n\t\treturn y <= midY ? 'top' : 'bottom';\r\n\t};\r\n\r\n\tif (lf(model.x)) {\r\n\t\txAlign = 'left';\r\n\r\n\t\t// Is tooltip too wide and goes over the right side of the chart.?\r\n\t\tif (olf(model.x)) {\r\n\t\t\txAlign = 'center';\r\n\t\t\tyAlign = yf(model.y);\r\n\t\t}\r\n\t} else if (rf(model.x)) {\r\n\t\txAlign = 'right';\r\n\r\n\t\t// Is tooltip too wide and goes outside left edge of canvas?\r\n\t\tif (orf(model.x)) {\r\n\t\t\txAlign = 'center';\r\n\t\t\tyAlign = yf(model.y);\r\n\t\t}\r\n\t}\r\n\r\n\tvar opts = tooltip._options;\r\n\treturn {\r\n\t\txAlign: opts.xAlign ? opts.xAlign : xAlign,\r\n\t\tyAlign: opts.yAlign ? opts.yAlign : yAlign\r\n\t};\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"determineAlignment.orf","start_line":356,"end_line":382}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"yf","line":401,"func_location":"determineAlignment","func_start_line":342,"func_end_line":410,"args":["model.y"],"comment":["*\r\n * Helper to get the alignment of a tooltip given the size\r\n "],"code":"function determineAlignment(tooltip, size) {\r\n\tvar model = tooltip._model;\r\n\tvar chart = tooltip._chart;\r\n\tvar chartArea = tooltip._chart.chartArea;\r\n\tvar xAlign = 'center';\r\n\tvar yAlign = 'center';\r\n\r\n\tif (model.y < size.height) {\r\n\t\tyAlign = 'top';\r\n\t} else if (model.y > (chart.height - size.height)) {\r\n\t\tyAlign = 'bottom';\r\n\t}\r\n\r\n\tvar lf, rf; // functions to determine left, right alignment\r\n\tvar olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart\r\n\tvar yf; // function to get the y alignment if the tooltip goes outside of the left or right edges\r\n\tvar midX = (chartArea.left + chartArea.right) / 2;\r\n\tvar midY = (chartArea.top + chartArea.bottom) / 2;\r\n\r\n\tif (yAlign === 'center') {\r\n\t\tlf = function(x) {\r\n\t\t\treturn x <= midX;\r\n\t\t};\r\n\t\trf = function(x) {\r\n\t\t\treturn x > midX;\r\n\t\t};\r\n\t} else {\r\n\t\tlf = function(x) {\r\n\t\t\treturn x <= (size.width / 2);\r\n\t\t};\r\n\t\trf = function(x) {\r\n\t\t\treturn x >= (chart.width - (size.width / 2));\r\n\t\t};\r\n\t}\r\n\r\n\tolf = function(x) {\r\n\t\treturn x + size.width + model.caretSize + model.caretPadding > chart.width;\r\n\t};\r\n\torf = function(x) {\r\n\t\treturn x - size.width - model.caretSize - model.caretPadding < 0;\r\n\t};\r\n\tyf = function(y) {\r\n\t\treturn y <= midY ? 'top' : 'bottom';\r\n\t};\r\n\r\n\tif (lf(model.x)) {\r\n\t\txAlign = 'left';\r\n\r\n\t\t// Is tooltip too wide and goes over the right side of the chart.?\r\n\t\tif (olf(model.x)) {\r\n\t\t\txAlign = 'center';\r\n\t\t\tyAlign = yf(model.y);\r\n\t\t}\r\n\t} else if (rf(model.x)) {\r\n\t\txAlign = 'right';\r\n\r\n\t\t// Is tooltip too wide and goes outside left edge of canvas?\r\n\t\tif (orf(model.x)) {\r\n\t\t\txAlign = 'center';\r\n\t\t\tyAlign = yf(model.y);\r\n\t\t}\r\n\t}\r\n\r\n\tvar opts = tooltip._options;\r\n\treturn {\r\n\t\txAlign: opts.xAlign ? opts.xAlign : xAlign,\r\n\t\tyAlign: opts.yAlign ? opts.yAlign : yAlign\r\n\t};\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"determineAlignment.yf","start_line":357,"end_line":385}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"parse","line":539,"func_location":"module.exports.TimeScale.determineDataLimits","func_start_line":524,"func_end_line":597,"args":[null],"code":"\t\tdetermineDataLimits: function() {\r\n\t\t\tvar me = this;\r\n\t\t\tvar chart = me.chart;\r\n\t\t\tvar timeOpts = me.options.time;\r\n\t\t\tvar unit = timeOpts.unit || 'day';\r\n\t\t\tvar min = MAX_INTEGER;\r\n\t\t\tvar max = MIN_INTEGER;\r\n\t\t\tvar timestamps = [];\r\n\t\t\tvar datasets = [];\r\n\t\t\tvar labels = [];\r\n\t\t\tvar i, j, ilen, jlen, data, timestamp;\r\n\t\t\tvar dataLabels = chart.data.labels || [];\r\n\r\n\t\t\t// Convert labels to timestamps\r\n\t\t\tfor (i = 0, ilen = dataLabels.length; i < ilen; ++i) {\r\n\t\t\t\tlabels.push(parse(dataLabels[i], me));\r\n\t\t\t}\r\n\r\n\t\t\t// Convert data to timestamps\r\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\r\n\t\t\t\tif (chart.isDatasetVisible(i)) {\r\n\t\t\t\t\tdata = chart.data.datasets[i].data;\r\n\r\n\t\t\t\t\t// Let's consider that all data have the same format.\r\n\t\t\t\t\tif (helpers.isObject(data[0])) {\r\n\t\t\t\t\t\tdatasets[i] = [];\r\n\r\n\t\t\t\t\t\tfor (j = 0, jlen = data.length; j < jlen; ++j) {\r\n\t\t\t\t\t\t\ttimestamp = parse(data[j], me);\r\n\t\t\t\t\t\t\ttimestamps.push(timestamp);\r\n\t\t\t\t\t\t\tdatasets[i][j] = timestamp;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttimestamps.push.apply(timestamps, labels);\r\n\t\t\t\t\t\tdatasets[i] = labels.slice(0);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdatasets[i] = [];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (labels.length) {\r\n\t\t\t\t// Sort labels **after** data have been converted\r\n\t\t\t\tlabels = arrayUnique(labels).sort(sorter);\r\n\t\t\t\tmin = Math.min(min, labels[0]);\r\n\t\t\t\tmax = Math.max(max, labels[labels.length - 1]);\r\n\t\t\t}\r\n\r\n\t\t\tif (timestamps.length) {\r\n\t\t\t\ttimestamps = arrayUnique(timestamps).sort(sorter);\r\n\t\t\t\tmin = Math.min(min, timestamps[0]);\r\n\t\t\t\tmax = Math.max(max, timestamps[timestamps.length - 1]);\r\n\t\t\t}\r\n\r\n\t\t\tmin = parse(timeOpts.min, me) || min;\r\n\t\t\tmax = parse(timeOpts.max, me) || max;\r\n\r\n\t\t\t// In case there is no valid min/max, set limits based on unit time option\r\n\t\t\tmin = min === MAX_INTEGER ? +moment().startOf(unit) : min;\r\n\t\t\tmax = max === MIN_INTEGER ? +moment().endOf(unit) + 1 : max;\r\n\r\n\t\t\t// Make sure that max is strictly higher than min (required by the lookup table)\r\n\t\t\tme.min = Math.min(min, max);\r\n\t\t\tme.max = Math.max(min + 1, max);\r\n\r\n\t\t\t// PRIVATE\r\n\t\t\tme._horizontal = me.isHorizontal();\r\n\t\t\tme._table = [];\r\n\t\t\tme._timestamps = {\r\n\t\t\t\tdata: timestamps,\r\n\t\t\t\tdatasets: datasets,\r\n\t\t\t\tlabels: labels\r\n\t\t\t};\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"parse","start_line":213,"end_line":229,"comment":[],"params":["input","scale"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"parse","line":552,"func_location":"module.exports.TimeScale.determineDataLimits","func_start_line":524,"func_end_line":597,"args":["data.j","me"],"code":"\t\tdetermineDataLimits: function() {\r\n\t\t\tvar me = this;\r\n\t\t\tvar chart = me.chart;\r\n\t\t\tvar timeOpts = me.options.time;\r\n\t\t\tvar unit = timeOpts.unit || 'day';\r\n\t\t\tvar min = MAX_INTEGER;\r\n\t\t\tvar max = MIN_INTEGER;\r\n\t\t\tvar timestamps = [];\r\n\t\t\tvar datasets = [];\r\n\t\t\tvar labels = [];\r\n\t\t\tvar i, j, ilen, jlen, data, timestamp;\r\n\t\t\tvar dataLabels = chart.data.labels || [];\r\n\r\n\t\t\t// Convert labels to timestamps\r\n\t\t\tfor (i = 0, ilen = dataLabels.length; i < ilen; ++i) {\r\n\t\t\t\tlabels.push(parse(dataLabels[i], me));\r\n\t\t\t}\r\n\r\n\t\t\t// Convert data to timestamps\r\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\r\n\t\t\t\tif (chart.isDatasetVisible(i)) {\r\n\t\t\t\t\tdata = chart.data.datasets[i].data;\r\n\r\n\t\t\t\t\t// Let's consider that all data have the same format.\r\n\t\t\t\t\tif (helpers.isObject(data[0])) {\r\n\t\t\t\t\t\tdatasets[i] = [];\r\n\r\n\t\t\t\t\t\tfor (j = 0, jlen = data.length; j < jlen; ++j) {\r\n\t\t\t\t\t\t\ttimestamp = parse(data[j], me);\r\n\t\t\t\t\t\t\ttimestamps.push(timestamp);\r\n\t\t\t\t\t\t\tdatasets[i][j] = timestamp;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttimestamps.push.apply(timestamps, labels);\r\n\t\t\t\t\t\tdatasets[i] = labels.slice(0);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdatasets[i] = [];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (labels.length) {\r\n\t\t\t\t// Sort labels **after** data have been converted\r\n\t\t\t\tlabels = arrayUnique(labels).sort(sorter);\r\n\t\t\t\tmin = Math.min(min, labels[0]);\r\n\t\t\t\tmax = Math.max(max, labels[labels.length - 1]);\r\n\t\t\t}\r\n\r\n\t\t\tif (timestamps.length) {\r\n\t\t\t\ttimestamps = arrayUnique(timestamps).sort(sorter);\r\n\t\t\t\tmin = Math.min(min, timestamps[0]);\r\n\t\t\t\tmax = Math.max(max, timestamps[timestamps.length - 1]);\r\n\t\t\t}\r\n\r\n\t\t\tmin = parse(timeOpts.min, me) || min;\r\n\t\t\tmax = parse(timeOpts.max, me) || max;\r\n\r\n\t\t\t// In case there is no valid min/max, set limits based on unit time option\r\n\t\t\tmin = min === MAX_INTEGER ? +moment().startOf(unit) : min;\r\n\t\t\tmax = max === MIN_INTEGER ? +moment().endOf(unit) + 1 : max;\r\n\r\n\t\t\t// Make sure that max is strictly higher than min (required by the lookup table)\r\n\t\t\tme.min = Math.min(min, max);\r\n\t\t\tme.max = Math.max(min + 1, max);\r\n\r\n\t\t\t// PRIVATE\r\n\t\t\tme._horizontal = me.isHorizontal();\r\n\t\t\tme._table = [];\r\n\t\t\tme._timestamps = {\r\n\t\t\t\tdata: timestamps,\r\n\t\t\t\tdatasets: datasets,\r\n\t\t\t\tlabels: labels\r\n\t\t\t};\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"parse","start_line":213,"end_line":229,"comment":[],"params":["input","scale"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"arrayUnique","line":567,"func_location":"module.exports.TimeScale.determineDataLimits","func_start_line":524,"func_end_line":597,"args":["sorter"],"code":"\t\tdetermineDataLimits: function() {\r\n\t\t\tvar me = this;\r\n\t\t\tvar chart = me.chart;\r\n\t\t\tvar timeOpts = me.options.time;\r\n\t\t\tvar unit = timeOpts.unit || 'day';\r\n\t\t\tvar min = MAX_INTEGER;\r\n\t\t\tvar max = MIN_INTEGER;\r\n\t\t\tvar timestamps = [];\r\n\t\t\tvar datasets = [];\r\n\t\t\tvar labels = [];\r\n\t\t\tvar i, j, ilen, jlen, data, timestamp;\r\n\t\t\tvar dataLabels = chart.data.labels || [];\r\n\r\n\t\t\t// Convert labels to timestamps\r\n\t\t\tfor (i = 0, ilen = dataLabels.length; i < ilen; ++i) {\r\n\t\t\t\tlabels.push(parse(dataLabels[i], me));\r\n\t\t\t}\r\n\r\n\t\t\t// Convert data to timestamps\r\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\r\n\t\t\t\tif (chart.isDatasetVisible(i)) {\r\n\t\t\t\t\tdata = chart.data.datasets[i].data;\r\n\r\n\t\t\t\t\t// Let's consider that all data have the same format.\r\n\t\t\t\t\tif (helpers.isObject(data[0])) {\r\n\t\t\t\t\t\tdatasets[i] = [];\r\n\r\n\t\t\t\t\t\tfor (j = 0, jlen = data.length; j < jlen; ++j) {\r\n\t\t\t\t\t\t\ttimestamp = parse(data[j], me);\r\n\t\t\t\t\t\t\ttimestamps.push(timestamp);\r\n\t\t\t\t\t\t\tdatasets[i][j] = timestamp;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttimestamps.push.apply(timestamps, labels);\r\n\t\t\t\t\t\tdatasets[i] = labels.slice(0);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdatasets[i] = [];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (labels.length) {\r\n\t\t\t\t// Sort labels **after** data have been converted\r\n\t\t\t\tlabels = arrayUnique(labels).sort(sorter);\r\n\t\t\t\tmin = Math.min(min, labels[0]);\r\n\t\t\t\tmax = Math.max(max, labels[labels.length - 1]);\r\n\t\t\t}\r\n\r\n\t\t\tif (timestamps.length) {\r\n\t\t\t\ttimestamps = arrayUnique(timestamps).sort(sorter);\r\n\t\t\t\tmin = Math.min(min, timestamps[0]);\r\n\t\t\t\tmax = Math.max(max, timestamps[timestamps.length - 1]);\r\n\t\t\t}\r\n\r\n\t\t\tmin = parse(timeOpts.min, me) || min;\r\n\t\t\tmax = parse(timeOpts.max, me) || max;\r\n\r\n\t\t\t// In case there is no valid min/max, set limits based on unit time option\r\n\t\t\tmin = min === MAX_INTEGER ? +moment().startOf(unit) : min;\r\n\t\t\tmax = max === MIN_INTEGER ? +moment().endOf(unit) + 1 : max;\r\n\r\n\t\t\t// Make sure that max is strictly higher than min (required by the lookup table)\r\n\t\t\tme.min = Math.min(min, max);\r\n\t\t\tme.max = Math.max(min + 1, max);\r\n\r\n\t\t\t// PRIVATE\r\n\t\t\tme._horizontal = me.isHorizontal();\r\n\t\t\tme._table = [];\r\n\t\t\tme._timestamps = {\r\n\t\t\t\tdata: timestamps,\r\n\t\t\t\tdatasets: datasets,\r\n\t\t\t\tlabels: labels\r\n\t\t\t};\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"arrayUnique","start_line":67,"end_line":81,"comment":[],"params":["items"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"arrayUnique","line":573,"func_location":"module.exports.TimeScale.determineDataLimits","func_start_line":524,"func_end_line":597,"args":["sorter"],"code":"\t\tdetermineDataLimits: function() {\r\n\t\t\tvar me = this;\r\n\t\t\tvar chart = me.chart;\r\n\t\t\tvar timeOpts = me.options.time;\r\n\t\t\tvar unit = timeOpts.unit || 'day';\r\n\t\t\tvar min = MAX_INTEGER;\r\n\t\t\tvar max = MIN_INTEGER;\r\n\t\t\tvar timestamps = [];\r\n\t\t\tvar datasets = [];\r\n\t\t\tvar labels = [];\r\n\t\t\tvar i, j, ilen, jlen, data, timestamp;\r\n\t\t\tvar dataLabels = chart.data.labels || [];\r\n\r\n\t\t\t// Convert labels to timestamps\r\n\t\t\tfor (i = 0, ilen = dataLabels.length; i < ilen; ++i) {\r\n\t\t\t\tlabels.push(parse(dataLabels[i], me));\r\n\t\t\t}\r\n\r\n\t\t\t// Convert data to timestamps\r\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\r\n\t\t\t\tif (chart.isDatasetVisible(i)) {\r\n\t\t\t\t\tdata = chart.data.datasets[i].data;\r\n\r\n\t\t\t\t\t// Let's consider that all data have the same format.\r\n\t\t\t\t\tif (helpers.isObject(data[0])) {\r\n\t\t\t\t\t\tdatasets[i] = [];\r\n\r\n\t\t\t\t\t\tfor (j = 0, jlen = data.length; j < jlen; ++j) {\r\n\t\t\t\t\t\t\ttimestamp = parse(data[j], me);\r\n\t\t\t\t\t\t\ttimestamps.push(timestamp);\r\n\t\t\t\t\t\t\tdatasets[i][j] = timestamp;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttimestamps.push.apply(timestamps, labels);\r\n\t\t\t\t\t\tdatasets[i] = labels.slice(0);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdatasets[i] = [];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (labels.length) {\r\n\t\t\t\t// Sort labels **after** data have been converted\r\n\t\t\t\tlabels = arrayUnique(labels).sort(sorter);\r\n\t\t\t\tmin = Math.min(min, labels[0]);\r\n\t\t\t\tmax = Math.max(max, labels[labels.length - 1]);\r\n\t\t\t}\r\n\r\n\t\t\tif (timestamps.length) {\r\n\t\t\t\ttimestamps = arrayUnique(timestamps).sort(sorter);\r\n\t\t\t\tmin = Math.min(min, timestamps[0]);\r\n\t\t\t\tmax = Math.max(max, timestamps[timestamps.length - 1]);\r\n\t\t\t}\r\n\r\n\t\t\tmin = parse(timeOpts.min, me) || min;\r\n\t\t\tmax = parse(timeOpts.max, me) || max;\r\n\r\n\t\t\t// In case there is no valid min/max, set limits based on unit time option\r\n\t\t\tmin = min === MAX_INTEGER ? +moment().startOf(unit) : min;\r\n\t\t\tmax = max === MIN_INTEGER ? +moment().endOf(unit) + 1 : max;\r\n\r\n\t\t\t// Make sure that max is strictly higher than min (required by the lookup table)\r\n\t\t\tme.min = Math.min(min, max);\r\n\t\t\tme.max = Math.max(min + 1, max);\r\n\r\n\t\t\t// PRIVATE\r\n\t\t\tme._horizontal = me.isHorizontal();\r\n\t\t\tme._table = [];\r\n\t\t\tme._timestamps = {\r\n\t\t\t\tdata: timestamps,\r\n\t\t\t\tdatasets: datasets,\r\n\t\t\t\tlabels: labels\r\n\t\t\t};\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"arrayUnique","start_line":67,"end_line":81,"comment":[],"params":["items"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"parse","line":578,"func_location":"module.exports.TimeScale.determineDataLimits","func_start_line":524,"func_end_line":597,"args":["timeOpts.min","me"],"code":"\t\tdetermineDataLimits: function() {\r\n\t\t\tvar me = this;\r\n\t\t\tvar chart = me.chart;\r\n\t\t\tvar timeOpts = me.options.time;\r\n\t\t\tvar unit = timeOpts.unit || 'day';\r\n\t\t\tvar min = MAX_INTEGER;\r\n\t\t\tvar max = MIN_INTEGER;\r\n\t\t\tvar timestamps = [];\r\n\t\t\tvar datasets = [];\r\n\t\t\tvar labels = [];\r\n\t\t\tvar i, j, ilen, jlen, data, timestamp;\r\n\t\t\tvar dataLabels = chart.data.labels || [];\r\n\r\n\t\t\t// Convert labels to timestamps\r\n\t\t\tfor (i = 0, ilen = dataLabels.length; i < ilen; ++i) {\r\n\t\t\t\tlabels.push(parse(dataLabels[i], me));\r\n\t\t\t}\r\n\r\n\t\t\t// Convert data to timestamps\r\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\r\n\t\t\t\tif (chart.isDatasetVisible(i)) {\r\n\t\t\t\t\tdata = chart.data.datasets[i].data;\r\n\r\n\t\t\t\t\t// Let's consider that all data have the same format.\r\n\t\t\t\t\tif (helpers.isObject(data[0])) {\r\n\t\t\t\t\t\tdatasets[i] = [];\r\n\r\n\t\t\t\t\t\tfor (j = 0, jlen = data.length; j < jlen; ++j) {\r\n\t\t\t\t\t\t\ttimestamp = parse(data[j], me);\r\n\t\t\t\t\t\t\ttimestamps.push(timestamp);\r\n\t\t\t\t\t\t\tdatasets[i][j] = timestamp;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttimestamps.push.apply(timestamps, labels);\r\n\t\t\t\t\t\tdatasets[i] = labels.slice(0);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdatasets[i] = [];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (labels.length) {\r\n\t\t\t\t// Sort labels **after** data have been converted\r\n\t\t\t\tlabels = arrayUnique(labels).sort(sorter);\r\n\t\t\t\tmin = Math.min(min, labels[0]);\r\n\t\t\t\tmax = Math.max(max, labels[labels.length - 1]);\r\n\t\t\t}\r\n\r\n\t\t\tif (timestamps.length) {\r\n\t\t\t\ttimestamps = arrayUnique(timestamps).sort(sorter);\r\n\t\t\t\tmin = Math.min(min, timestamps[0]);\r\n\t\t\t\tmax = Math.max(max, timestamps[timestamps.length - 1]);\r\n\t\t\t}\r\n\r\n\t\t\tmin = parse(timeOpts.min, me) || min;\r\n\t\t\tmax = parse(timeOpts.max, me) || max;\r\n\r\n\t\t\t// In case there is no valid min/max, set limits based on unit time option\r\n\t\t\tmin = min === MAX_INTEGER ? +moment().startOf(unit) : min;\r\n\t\t\tmax = max === MIN_INTEGER ? +moment().endOf(unit) + 1 : max;\r\n\r\n\t\t\t// Make sure that max is strictly higher than min (required by the lookup table)\r\n\t\t\tme.min = Math.min(min, max);\r\n\t\t\tme.max = Math.max(min + 1, max);\r\n\r\n\t\t\t// PRIVATE\r\n\t\t\tme._horizontal = me.isHorizontal();\r\n\t\t\tme._table = [];\r\n\t\t\tme._timestamps = {\r\n\t\t\t\tdata: timestamps,\r\n\t\t\t\tdatasets: datasets,\r\n\t\t\t\tlabels: labels\r\n\t\t\t};\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"parse","start_line":213,"end_line":229,"comment":[],"params":["input","scale"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"parse","line":579,"func_location":"module.exports.TimeScale.determineDataLimits","func_start_line":524,"func_end_line":597,"args":["timeOpts.max","me"],"code":"\t\tdetermineDataLimits: function() {\r\n\t\t\tvar me = this;\r\n\t\t\tvar chart = me.chart;\r\n\t\t\tvar timeOpts = me.options.time;\r\n\t\t\tvar unit = timeOpts.unit || 'day';\r\n\t\t\tvar min = MAX_INTEGER;\r\n\t\t\tvar max = MIN_INTEGER;\r\n\t\t\tvar timestamps = [];\r\n\t\t\tvar datasets = [];\r\n\t\t\tvar labels = [];\r\n\t\t\tvar i, j, ilen, jlen, data, timestamp;\r\n\t\t\tvar dataLabels = chart.data.labels || [];\r\n\r\n\t\t\t// Convert labels to timestamps\r\n\t\t\tfor (i = 0, ilen = dataLabels.length; i < ilen; ++i) {\r\n\t\t\t\tlabels.push(parse(dataLabels[i], me));\r\n\t\t\t}\r\n\r\n\t\t\t// Convert data to timestamps\r\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\r\n\t\t\t\tif (chart.isDatasetVisible(i)) {\r\n\t\t\t\t\tdata = chart.data.datasets[i].data;\r\n\r\n\t\t\t\t\t// Let's consider that all data have the same format.\r\n\t\t\t\t\tif (helpers.isObject(data[0])) {\r\n\t\t\t\t\t\tdatasets[i] = [];\r\n\r\n\t\t\t\t\t\tfor (j = 0, jlen = data.length; j < jlen; ++j) {\r\n\t\t\t\t\t\t\ttimestamp = parse(data[j], me);\r\n\t\t\t\t\t\t\ttimestamps.push(timestamp);\r\n\t\t\t\t\t\t\tdatasets[i][j] = timestamp;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttimestamps.push.apply(timestamps, labels);\r\n\t\t\t\t\t\tdatasets[i] = labels.slice(0);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdatasets[i] = [];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (labels.length) {\r\n\t\t\t\t// Sort labels **after** data have been converted\r\n\t\t\t\tlabels = arrayUnique(labels).sort(sorter);\r\n\t\t\t\tmin = Math.min(min, labels[0]);\r\n\t\t\t\tmax = Math.max(max, labels[labels.length - 1]);\r\n\t\t\t}\r\n\r\n\t\t\tif (timestamps.length) {\r\n\t\t\t\ttimestamps = arrayUnique(timestamps).sort(sorter);\r\n\t\t\t\tmin = Math.min(min, timestamps[0]);\r\n\t\t\t\tmax = Math.max(max, timestamps[timestamps.length - 1]);\r\n\t\t\t}\r\n\r\n\t\t\tmin = parse(timeOpts.min, me) || min;\r\n\t\t\tmax = parse(timeOpts.max, me) || max;\r\n\r\n\t\t\t// In case there is no valid min/max, set limits based on unit time option\r\n\t\t\tmin = min === MAX_INTEGER ? +moment().startOf(unit) : min;\r\n\t\t\tmax = max === MIN_INTEGER ? +moment().endOf(unit) + 1 : max;\r\n\r\n\t\t\t// Make sure that max is strictly higher than min (required by the lookup table)\r\n\t\t\tme.min = Math.min(min, max);\r\n\t\t\tme.max = Math.max(min + 1, max);\r\n\r\n\t\t\t// PRIVATE\r\n\t\t\tme._horizontal = me.isHorizontal();\r\n\t\t\tme._table = [];\r\n\t\t\tme._timestamps = {\r\n\t\t\t\tdata: timestamps,\r\n\t\t\t\tdatasets: datasets,\r\n\t\t\t\tlabels: labels\r\n\t\t\t};\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"parse","start_line":213,"end_line":229,"comment":[],"params":["input","scale"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"momentify","line":413,"func_location":"determineLabelFormat","func_start_line":406,"func_end_line":425,"args":["data.i","timeOpts"],"code":"function determineLabelFormat(data, timeOpts) {\r\n\tvar i, momentDate, hasTime;\r\n\tvar ilen = data.length;\r\n\r\n\t// find the label with the most parts (milliseconds, minutes, etc.)\r\n\t// format all labels with the same level of detail as the most specific label\r\n\tfor (i = 0; i < ilen; i++) {\r\n\t\tmomentDate = momentify(data[i], timeOpts);\r\n\t\tif (momentDate.millisecond() !== 0) {\r\n\t\t\treturn 'MMM D, YYYY h:mm:ss.SSS a';\r\n\t\t}\r\n\t\tif (momentDate.second() !== 0 || momentDate.minute() !== 0 || momentDate.hour() !== 0) {\r\n\t\t\thasTime = true;\r\n\t\t}\r\n\t}\r\n\tif (hasTime) {\r\n\t\treturn 'MMM D, YYYY h:mm:ss a';\r\n\t}\r\n\treturn 'MMM D, YYYY';\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"momentify","start_line":184,"end_line":211,"comment":["*\r\n * Convert the given value to a moment object using the given time options.\r\n * @see https://momentjs.com/docs/#/parsing/\r\n "],"params":["value","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.filler.js","name":"isDrawable","line":230,"func_location":"doFill","func_start_line":215,"func_end_line":258,"args":["p0"],"code":"function doFill(ctx, points, mapper, view, color, loop) {\r\n\tvar count = points.length;\r\n\tvar span = view.spanGaps;\r\n\tvar curve0 = [];\r\n\tvar curve1 = [];\r\n\tvar len0 = 0;\r\n\tvar len1 = 0;\r\n\tvar i, ilen, index, p0, p1, d0, d1;\r\n\r\n\tctx.beginPath();\r\n\r\n\tfor (i = 0, ilen = (count + !!loop); i < ilen; ++i) {\r\n\t\tindex = i % count;\r\n\t\tp0 = points[index]._view;\r\n\t\tp1 = mapper(p0, index, view);\r\n\t\td0 = isDrawable(p0);\r\n\t\td1 = isDrawable(p1);\r\n\r\n\t\tif (d0 && d1) {\r\n\t\t\tlen0 = curve0.push(p0);\r\n\t\t\tlen1 = curve1.push(p1);\r\n\t\t} else if (len0 && len1) {\r\n\t\t\tif (!span) {\r\n\t\t\t\tdrawArea(ctx, curve0, curve1, len0, len1);\r\n\t\t\t\tlen0 = len1 = 0;\r\n\t\t\t\tcurve0 = [];\r\n\t\t\t\tcurve1 = [];\r\n\t\t\t} else {\r\n\t\t\t\tif (d0) {\r\n\t\t\t\t\tcurve0.push(p0);\r\n\t\t\t\t}\r\n\t\t\t\tif (d1) {\r\n\t\t\t\t\tcurve1.push(p1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tdrawArea(ctx, curve0, curve1, len0, len1);\r\n\r\n\tctx.closePath();\r\n\tctx.fillStyle = color;\r\n\tctx.fill();\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.filler.js","name":"isDrawable","start_line":189,"end_line":191,"comment":[],"params":["point"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.filler.js","name":"isDrawable","line":231,"func_location":"doFill","func_start_line":215,"func_end_line":258,"args":["p1"],"code":"function doFill(ctx, points, mapper, view, color, loop) {\r\n\tvar count = points.length;\r\n\tvar span = view.spanGaps;\r\n\tvar curve0 = [];\r\n\tvar curve1 = [];\r\n\tvar len0 = 0;\r\n\tvar len1 = 0;\r\n\tvar i, ilen, index, p0, p1, d0, d1;\r\n\r\n\tctx.beginPath();\r\n\r\n\tfor (i = 0, ilen = (count + !!loop); i < ilen; ++i) {\r\n\t\tindex = i % count;\r\n\t\tp0 = points[index]._view;\r\n\t\tp1 = mapper(p0, index, view);\r\n\t\td0 = isDrawable(p0);\r\n\t\td1 = isDrawable(p1);\r\n\r\n\t\tif (d0 && d1) {\r\n\t\t\tlen0 = curve0.push(p0);\r\n\t\t\tlen1 = curve1.push(p1);\r\n\t\t} else if (len0 && len1) {\r\n\t\t\tif (!span) {\r\n\t\t\t\tdrawArea(ctx, curve0, curve1, len0, len1);\r\n\t\t\t\tlen0 = len1 = 0;\r\n\t\t\t\tcurve0 = [];\r\n\t\t\t\tcurve1 = [];\r\n\t\t\t} else {\r\n\t\t\t\tif (d0) {\r\n\t\t\t\t\tcurve0.push(p0);\r\n\t\t\t\t}\r\n\t\t\t\tif (d1) {\r\n\t\t\t\t\tcurve1.push(p1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tdrawArea(ctx, curve0, curve1, len0, len1);\r\n\r\n\tctx.closePath();\r\n\tctx.fillStyle = color;\r\n\tctx.fill();\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.filler.js","name":"isDrawable","start_line":189,"end_line":191,"comment":[],"params":["point"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.filler.js","name":"drawArea","line":238,"func_location":"doFill","func_start_line":215,"func_end_line":258,"args":["ctx","curve0","curve1","len0","len1"],"code":"function doFill(ctx, points, mapper, view, color, loop) {\r\n\tvar count = points.length;\r\n\tvar span = view.spanGaps;\r\n\tvar curve0 = [];\r\n\tvar curve1 = [];\r\n\tvar len0 = 0;\r\n\tvar len1 = 0;\r\n\tvar i, ilen, index, p0, p1, d0, d1;\r\n\r\n\tctx.beginPath();\r\n\r\n\tfor (i = 0, ilen = (count + !!loop); i < ilen; ++i) {\r\n\t\tindex = i % count;\r\n\t\tp0 = points[index]._view;\r\n\t\tp1 = mapper(p0, index, view);\r\n\t\td0 = isDrawable(p0);\r\n\t\td1 = isDrawable(p1);\r\n\r\n\t\tif (d0 && d1) {\r\n\t\t\tlen0 = curve0.push(p0);\r\n\t\t\tlen1 = curve1.push(p1);\r\n\t\t} else if (len0 && len1) {\r\n\t\t\tif (!span) {\r\n\t\t\t\tdrawArea(ctx, curve0, curve1, len0, len1);\r\n\t\t\t\tlen0 = len1 = 0;\r\n\t\t\t\tcurve0 = [];\r\n\t\t\t\tcurve1 = [];\r\n\t\t\t} else {\r\n\t\t\t\tif (d0) {\r\n\t\t\t\t\tcurve0.push(p0);\r\n\t\t\t\t}\r\n\t\t\t\tif (d1) {\r\n\t\t\t\t\tcurve1.push(p1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tdrawArea(ctx, curve0, curve1, len0, len1);\r\n\r\n\tctx.closePath();\r\n\tctx.fillStyle = color;\r\n\tctx.fill();\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.filler.js","name":"drawArea","start_line":193,"end_line":213,"comment":[],"params":["ctx","curve0","curve1","len0","len1"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.filler.js","name":"drawArea","line":253,"func_location":"doFill","func_start_line":215,"func_end_line":258,"args":["ctx","curve0","curve1","len0","len1"],"code":"function doFill(ctx, points, mapper, view, color, loop) {\r\n\tvar count = points.length;\r\n\tvar span = view.spanGaps;\r\n\tvar curve0 = [];\r\n\tvar curve1 = [];\r\n\tvar len0 = 0;\r\n\tvar len1 = 0;\r\n\tvar i, ilen, index, p0, p1, d0, d1;\r\n\r\n\tctx.beginPath();\r\n\r\n\tfor (i = 0, ilen = (count + !!loop); i < ilen; ++i) {\r\n\t\tindex = i % count;\r\n\t\tp0 = points[index]._view;\r\n\t\tp1 = mapper(p0, index, view);\r\n\t\td0 = isDrawable(p0);\r\n\t\td1 = isDrawable(p1);\r\n\r\n\t\tif (d0 && d1) {\r\n\t\t\tlen0 = curve0.push(p0);\r\n\t\t\tlen1 = curve1.push(p1);\r\n\t\t} else if (len0 && len1) {\r\n\t\t\tif (!span) {\r\n\t\t\t\tdrawArea(ctx, curve0, curve1, len0, len1);\r\n\t\t\t\tlen0 = len1 = 0;\r\n\t\t\t\tcurve0 = [];\r\n\t\t\t\tcurve1 = [];\r\n\t\t\t} else {\r\n\t\t\t\tif (d0) {\r\n\t\t\t\t\tcurve0.push(p0);\r\n\t\t\t\t}\r\n\t\t\t\tif (d1) {\r\n\t\t\t\t\tcurve1.push(p1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tdrawArea(ctx, curve0, curve1, len0, len1);\r\n\r\n\tctx.closePath();\r\n\tctx.fillStyle = color;\r\n\tctx.fill();\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.filler.js","name":"drawArea","start_line":193,"end_line":213,"comment":[],"params":["ctx","curve0","curve1","len0","len1"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.legend.js","name":"getBoxWidth","line":344,"func_location":"Legend.draw","func_start_line":318,"func_end_line":460,"args":["labelOpts","fontSize"],"comment":[" Actually draw the legend on the canvas"],"code":"\tdraw: function() {\r\n\t\tvar me = this;\r\n\t\tvar opts = me.options;\r\n\t\tvar labelOpts = opts.labels;\r\n\t\tvar globalDefaults = defaults.global;\r\n\t\tvar defaultColor = globalDefaults.defaultColor;\r\n\t\tvar lineDefault = globalDefaults.elements.line;\r\n\t\tvar legendWidth = me.width;\r\n\t\tvar lineWidths = me.lineWidths;\r\n\r\n\t\tif (opts.display) {\r\n\t\t\tvar ctx = me.ctx;\r\n\t\t\tvar valueOrDefault = helpers.valueOrDefault;\r\n\t\t\tvar fontColor = valueOrDefault(labelOpts.fontColor, globalDefaults.defaultFontColor);\r\n\t\t\tvar labelFont = helpers.options._parseFont(labelOpts);\r\n\t\t\tvar fontSize = labelFont.size;\r\n\t\t\tvar cursor;\r\n\r\n\t\t\t// Canvas setup\r\n\t\t\tctx.textAlign = 'left';\r\n\t\t\tctx.textBaseline = 'middle';\r\n\t\t\tctx.lineWidth = 0.5;\r\n\t\t\tctx.strokeStyle = fontColor; // for strikethrough effect\r\n\t\t\tctx.fillStyle = fontColor; // render in correct colour\r\n\t\t\tctx.font = labelFont.string;\r\n\r\n\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\r\n\t\t\tvar hitboxes = me.legendHitBoxes;\r\n\r\n\t\t\t// current position\r\n\t\t\tvar drawLegendBox = function(x, y, legendItem) {\r\n\t\t\t\tif (isNaN(boxWidth) || boxWidth <= 0) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Set the ctx for the box\r\n\t\t\t\tctx.save();\r\n\r\n\t\t\t\tvar lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);\r\n\t\t\t\tctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\r\n\t\t\t\tctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);\r\n\t\t\t\tctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);\r\n\t\t\t\tctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);\r\n\t\t\t\tctx.lineWidth = lineWidth;\r\n\t\t\t\tctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\r\n\r\n\t\t\t\tif (ctx.setLineDash) {\r\n\t\t\t\t\t// IE 9 and 10 do not support line dash\r\n\t\t\t\t\tctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (opts.labels && opts.labels.usePointStyle) {\r\n\t\t\t\t\t// Recalculate x and y for drawPoint() because its expecting\r\n\t\t\t\t\t// x and y to be center of figure (instead of top left)\r\n\t\t\t\t\tvar radius = fontSize * Math.SQRT2 / 2;\r\n\t\t\t\t\tvar offSet = radius / Math.SQRT2;\r\n\t\t\t\t\tvar centerX = x + offSet;\r\n\t\t\t\t\tvar centerY = y + offSet;\r\n\r\n\t\t\t\t\t// Draw pointStyle as legend symbol\r\n\t\t\t\t\thelpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Draw box as legend symbol\r\n\t\t\t\t\tif (lineWidth !== 0) {\r\n\t\t\t\t\t\tctx.strokeRect(x, y, boxWidth, fontSize);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tctx.fillRect(x, y, boxWidth, fontSize);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tctx.restore();\r\n\t\t\t};\r\n\t\t\tvar fillText = function(x, y, legendItem, textWidth) {\r\n\t\t\t\tvar halfFontSize = fontSize / 2;\r\n\t\t\t\tvar xLeft = boxWidth + halfFontSize + x;\r\n\t\t\t\tvar yMiddle = y + halfFontSize;\r\n\r\n\t\t\t\tctx.fillText(legendItem.text, xLeft, yMiddle);\r\n\r\n\t\t\t\tif (legendItem.hidden) {\r\n\t\t\t\t\t// Strikethrough the text if hidden\r\n\t\t\t\t\tctx.beginPath();\r\n\t\t\t\t\tctx.lineWidth = 2;\r\n\t\t\t\t\tctx.moveTo(xLeft, yMiddle);\r\n\t\t\t\t\tctx.lineTo(xLeft + textWidth, yMiddle);\r\n\t\t\t\t\tctx.stroke();\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t// Horizontal\r\n\t\t\tvar isHorizontal = me.isHorizontal();\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\tcursor = {\r\n\t\t\t\t\tx: me.left + ((legendWidth - lineWidths[0]) / 2) + labelOpts.padding,\r\n\t\t\t\t\ty: me.top + labelOpts.padding,\r\n\t\t\t\t\tline: 0\r\n\t\t\t\t};\r\n\t\t\t} else {\r\n\t\t\t\tcursor = {\r\n\t\t\t\t\tx: me.left + labelOpts.padding,\r\n\t\t\t\t\ty: me.top + labelOpts.padding,\r\n\t\t\t\t\tline: 0\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tvar itemHeight = fontSize + labelOpts.padding;\r\n\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\r\n\t\t\t\tvar textWidth = ctx.measureText(legendItem.text).width;\r\n\t\t\t\tvar width = boxWidth + (fontSize / 2) + textWidth;\r\n\t\t\t\tvar x = cursor.x;\r\n\t\t\t\tvar y = cursor.y;\r\n\r\n\t\t\t\t// Use (me.left + me.minSize.width) and (me.top + me.minSize.height)\r\n\t\t\t\t// instead of me.right and me.bottom because me.width and me.height\r\n\t\t\t\t// may have been changed since me.minSize was calculated\r\n\t\t\t\tif (isHorizontal) {\r\n\t\t\t\t\tif (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {\r\n\t\t\t\t\t\ty = cursor.y += itemHeight;\r\n\t\t\t\t\t\tcursor.line++;\r\n\t\t\t\t\t\tx = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2) + labelOpts.padding;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {\r\n\t\t\t\t\tx = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\r\n\t\t\t\t\ty = cursor.y = me.top + labelOpts.padding;\r\n\t\t\t\t\tcursor.line++;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdrawLegendBox(x, y, legendItem);\r\n\r\n\t\t\t\thitboxes[i].left = x;\r\n\t\t\t\thitboxes[i].top = y;\r\n\r\n\t\t\t\t// Fill the actual label\r\n\t\t\t\tfillText(x, y, legendItem, textWidth);\r\n\r\n\t\t\t\tif (isHorizontal) {\r\n\t\t\t\t\tcursor.x += width + labelOpts.padding;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcursor.y += itemHeight;\r\n\t\t\t\t}\r\n\r\n\t\t\t});\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/plugins/plugin.legend.js","name":"getBoxWidth","start_line":91,"end_line":95,"comment":["*\r\n * Helper function to get the box width based on the usePointStyle option\r\n * @param labelopts {Object} the label options on the legend\r\n * @param fontSize {Number} the label font size\r\n * @return {Number} width of the color box area\r\n "],"params":["labelOpts","fontSize"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"drawPointLabels","line":481,"func_location":"module.exports.LinearRadialScale.draw","func_start_line":468,"func_end_line":522,"args":["me"],"code":"\t\tdraw: function() {\r\n\t\t\tvar me = this;\r\n\t\t\tvar opts = me.options;\r\n\t\t\tvar gridLineOpts = opts.gridLines;\r\n\t\t\tvar tickOpts = opts.ticks;\r\n\t\t\tvar valueOrDefault = helpers.valueOrDefault;\r\n\r\n\t\t\tif (opts.display) {\r\n\t\t\t\tvar ctx = me.ctx;\r\n\t\t\t\tvar startAngle = this.getIndexAngle(0);\r\n\t\t\t\tvar tickFont = helpers.options._parseFont(tickOpts);\r\n\r\n\t\t\t\tif (opts.angleLines.display || opts.pointLabels.display) {\r\n\t\t\t\t\tdrawPointLabels(me);\r\n\t\t\t\t}\r\n\r\n\t\t\t\thelpers.each(me.ticks, function(label, index) {\r\n\t\t\t\t\t// Don't draw a centre value (if it is minimum)\r\n\t\t\t\t\tif (index > 0 || tickOpts.reverse) {\r\n\t\t\t\t\t\tvar yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\r\n\r\n\t\t\t\t\t\t// Draw circular lines around the scale\r\n\t\t\t\t\t\tif (gridLineOpts.display && index !== 0) {\r\n\t\t\t\t\t\t\tdrawRadiusLine(me, gridLineOpts, yCenterOffset, index);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (tickOpts.display) {\r\n\t\t\t\t\t\t\tvar tickFontColor = valueOrDefault(tickOpts.fontColor, defaults.global.defaultFontColor);\r\n\t\t\t\t\t\t\tctx.font = tickFont.string;\r\n\r\n\t\t\t\t\t\t\tctx.save();\r\n\t\t\t\t\t\t\tctx.translate(me.xCenter, me.yCenter);\r\n\t\t\t\t\t\t\tctx.rotate(startAngle);\r\n\r\n\t\t\t\t\t\t\tif (tickOpts.showLabelBackdrop) {\r\n\t\t\t\t\t\t\t\tvar labelWidth = ctx.measureText(label).width;\r\n\t\t\t\t\t\t\t\tctx.fillStyle = tickOpts.backdropColor;\r\n\t\t\t\t\t\t\t\tctx.fillRect(\r\n\t\t\t\t\t\t\t\t\t-labelWidth / 2 - tickOpts.backdropPaddingX,\r\n\t\t\t\t\t\t\t\t\t-yCenterOffset - tickFont.size / 2 - tickOpts.backdropPaddingY,\r\n\t\t\t\t\t\t\t\t\tlabelWidth + tickOpts.backdropPaddingX * 2,\r\n\t\t\t\t\t\t\t\t\ttickFont.size + tickOpts.backdropPaddingY * 2\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tctx.textAlign = 'center';\r\n\t\t\t\t\t\t\tctx.textBaseline = 'middle';\r\n\t\t\t\t\t\t\tctx.fillStyle = tickFontColor;\r\n\t\t\t\t\t\t\tctx.fillText(label, 0, -yCenterOffset);\r\n\t\t\t\t\t\t\tctx.restore();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"module.exports.drawPointLabels","start_line":223,"end_line":275,"comment":[],"params":["scale"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/elements/element.rectangle.js","name":"cornerAt","line":135,"func_location":"draw","func_start_line":58,"func_end_line":147,"args":[{"type":"number"}],"code":"\tdraw: function() {\r\n\t\tvar ctx = this._chart.ctx;\r\n\t\tvar vm = this._view;\r\n\t\tvar left, right, top, bottom, signX, signY, borderSkipped;\r\n\t\tvar borderWidth = vm.borderWidth;\r\n\r\n\t\tif (!vm.horizontal) {\r\n\t\t\t// bar\r\n\t\t\tleft = vm.x - vm.width / 2;\r\n\t\t\tright = vm.x + vm.width / 2;\r\n\t\t\ttop = vm.y;\r\n\t\t\tbottom = vm.base;\r\n\t\t\tsignX = 1;\r\n\t\t\tsignY = bottom > top ? 1 : -1;\r\n\t\t\tborderSkipped = vm.borderSkipped || 'bottom';\r\n\t\t} else {\r\n\t\t\t// horizontal bar\r\n\t\t\tleft = vm.base;\r\n\t\t\tright = vm.x;\r\n\t\t\ttop = vm.y - vm.height / 2;\r\n\t\t\tbottom = vm.y + vm.height / 2;\r\n\t\t\tsignX = right > left ? 1 : -1;\r\n\t\t\tsignY = 1;\r\n\t\t\tborderSkipped = vm.borderSkipped || 'left';\r\n\t\t}\r\n\r\n\t\t// Canvas doesn't allow us to stroke inside the width so we can\r\n\t\t// adjust the sizes to fit if we're setting a stroke on the line\r\n\t\tif (borderWidth) {\r\n\t\t\t// borderWidth shold be less than bar width and bar height.\r\n\t\t\tvar barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));\r\n\t\t\tborderWidth = borderWidth > barSize ? barSize : borderWidth;\r\n\t\t\tvar halfStroke = borderWidth / 2;\r\n\t\t\t// Adjust borderWidth when bar top position is near vm.base(zero).\r\n\t\t\tvar borderLeft = left + (borderSkipped !== 'left' ? halfStroke * signX : 0);\r\n\t\t\tvar borderRight = right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);\r\n\t\t\tvar borderTop = top + (borderSkipped !== 'top' ? halfStroke * signY : 0);\r\n\t\t\tvar borderBottom = bottom + (borderSkipped !== 'bottom' ? -halfStroke * signY : 0);\r\n\t\t\t// not become a vertical line?\r\n\t\t\tif (borderLeft !== borderRight) {\r\n\t\t\t\ttop = borderTop;\r\n\t\t\t\tbottom = borderBottom;\r\n\t\t\t}\r\n\t\t\t// not become a horizontal line?\r\n\t\t\tif (borderTop !== borderBottom) {\r\n\t\t\t\tleft = borderLeft;\r\n\t\t\t\tright = borderRight;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tctx.beginPath();\r\n\t\tctx.fillStyle = vm.backgroundColor;\r\n\t\tctx.strokeStyle = vm.borderColor;\r\n\t\tctx.lineWidth = borderWidth;\r\n\r\n\t\t// Corner points, from bottom-left to bottom-right clockwise\r\n\t\t// | 1 2 |\r\n\t\t// | 0 3 |\r\n\t\tvar corners = [\r\n\t\t\t[left, bottom],\r\n\t\t\t[left, top],\r\n\t\t\t[right, top],\r\n\t\t\t[right, bottom]\r\n\t\t];\r\n\r\n\t\t// Find first (starting) corner with fallback to 'bottom'\r\n\t\tvar borders = ['bottom', 'left', 'top', 'right'];\r\n\t\tvar startCorner = borders.indexOf(borderSkipped, 0);\r\n\t\tif (startCorner === -1) {\r\n\t\t\tstartCorner = 0;\r\n\t\t}\r\n\r\n\t\tfunction cornerAt(index) {\r\n\t\t\treturn corners[(startCorner + index) % 4];\r\n\t\t}\r\n\r\n\t\t// Draw rectangle from 'startCorner'\r\n\t\tvar corner = cornerAt(0);\r\n\t\tctx.moveTo(corner[0], corner[1]);\r\n\r\n\t\tfor (var i = 1; i < 4; i++) {\r\n\t\t\tcorner = cornerAt(i);\r\n\t\t\tctx.lineTo(corner[0], corner[1]);\r\n\t\t}\r\n\r\n\t\tctx.fill();\r\n\t\tif (borderWidth) {\r\n\t\t\tctx.stroke();\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/elements/element.rectangle.js","name":"draw.cornerAt","start_line":130,"end_line":132,"comment":[],"params":["index"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/elements/element.rectangle.js","name":"cornerAt","line":139,"func_location":"draw","func_start_line":58,"func_end_line":147,"args":["i"],"code":"\tdraw: function() {\r\n\t\tvar ctx = this._chart.ctx;\r\n\t\tvar vm = this._view;\r\n\t\tvar left, right, top, bottom, signX, signY, borderSkipped;\r\n\t\tvar borderWidth = vm.borderWidth;\r\n\r\n\t\tif (!vm.horizontal) {\r\n\t\t\t// bar\r\n\t\t\tleft = vm.x - vm.width / 2;\r\n\t\t\tright = vm.x + vm.width / 2;\r\n\t\t\ttop = vm.y;\r\n\t\t\tbottom = vm.base;\r\n\t\t\tsignX = 1;\r\n\t\t\tsignY = bottom > top ? 1 : -1;\r\n\t\t\tborderSkipped = vm.borderSkipped || 'bottom';\r\n\t\t} else {\r\n\t\t\t// horizontal bar\r\n\t\t\tleft = vm.base;\r\n\t\t\tright = vm.x;\r\n\t\t\ttop = vm.y - vm.height / 2;\r\n\t\t\tbottom = vm.y + vm.height / 2;\r\n\t\t\tsignX = right > left ? 1 : -1;\r\n\t\t\tsignY = 1;\r\n\t\t\tborderSkipped = vm.borderSkipped || 'left';\r\n\t\t}\r\n\r\n\t\t// Canvas doesn't allow us to stroke inside the width so we can\r\n\t\t// adjust the sizes to fit if we're setting a stroke on the line\r\n\t\tif (borderWidth) {\r\n\t\t\t// borderWidth shold be less than bar width and bar height.\r\n\t\t\tvar barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));\r\n\t\t\tborderWidth = borderWidth > barSize ? barSize : borderWidth;\r\n\t\t\tvar halfStroke = borderWidth / 2;\r\n\t\t\t// Adjust borderWidth when bar top position is near vm.base(zero).\r\n\t\t\tvar borderLeft = left + (borderSkipped !== 'left' ? halfStroke * signX : 0);\r\n\t\t\tvar borderRight = right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);\r\n\t\t\tvar borderTop = top + (borderSkipped !== 'top' ? halfStroke * signY : 0);\r\n\t\t\tvar borderBottom = bottom + (borderSkipped !== 'bottom' ? -halfStroke * signY : 0);\r\n\t\t\t// not become a vertical line?\r\n\t\t\tif (borderLeft !== borderRight) {\r\n\t\t\t\ttop = borderTop;\r\n\t\t\t\tbottom = borderBottom;\r\n\t\t\t}\r\n\t\t\t// not become a horizontal line?\r\n\t\t\tif (borderTop !== borderBottom) {\r\n\t\t\t\tleft = borderLeft;\r\n\t\t\t\tright = borderRight;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tctx.beginPath();\r\n\t\tctx.fillStyle = vm.backgroundColor;\r\n\t\tctx.strokeStyle = vm.borderColor;\r\n\t\tctx.lineWidth = borderWidth;\r\n\r\n\t\t// Corner points, from bottom-left to bottom-right clockwise\r\n\t\t// | 1 2 |\r\n\t\t// | 0 3 |\r\n\t\tvar corners = [\r\n\t\t\t[left, bottom],\r\n\t\t\t[left, top],\r\n\t\t\t[right, top],\r\n\t\t\t[right, bottom]\r\n\t\t];\r\n\r\n\t\t// Find first (starting) corner with fallback to 'bottom'\r\n\t\tvar borders = ['bottom', 'left', 'top', 'right'];\r\n\t\tvar startCorner = borders.indexOf(borderSkipped, 0);\r\n\t\tif (startCorner === -1) {\r\n\t\t\tstartCorner = 0;\r\n\t\t}\r\n\r\n\t\tfunction cornerAt(index) {\r\n\t\t\treturn corners[(startCorner + index) % 4];\r\n\t\t}\r\n\r\n\t\t// Draw rectangle from 'startCorner'\r\n\t\tvar corner = cornerAt(0);\r\n\t\tctx.moveTo(corner[0], corner[1]);\r\n\r\n\t\tfor (var i = 1; i < 4; i++) {\r\n\t\t\tcorner = cornerAt(i);\r\n\t\t\tctx.lineTo(corner[0], corner[1]);\r\n\t\t}\r\n\r\n\t\tctx.fill();\r\n\t\tif (borderWidth) {\r\n\t\t\tctx.stroke();\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/elements/element.rectangle.js","name":"draw.cornerAt","start_line":130,"end_line":132,"comment":[],"params":["index"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.line.js","name":"lineEnabled","line":302,"func_location":"draw","func_start_line":292,"func_end_line":321,"args":[null,"chart.options"],"code":"\tdraw: function() {\r\n\t\tvar me = this;\r\n\t\tvar chart = me.chart;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar points = meta.data || [];\r\n\t\tvar area = chart.chartArea;\r\n\t\tvar ilen = points.length;\r\n\t\tvar halfBorderWidth;\r\n\t\tvar i = 0;\r\n\r\n\t\tif (lineEnabled(me.getDataset(), chart.options)) {\r\n\t\t\thalfBorderWidth = (meta.dataset._model.borderWidth || 0) / 2;\r\n\r\n\t\t\thelpers.canvas.clipArea(chart.ctx, {\r\n\t\t\t\tleft: area.left,\r\n\t\t\t\tright: area.right,\r\n\t\t\t\ttop: area.top - halfBorderWidth,\r\n\t\t\t\tbottom: area.bottom + halfBorderWidth\r\n\t\t\t});\r\n\r\n\t\t\tmeta.dataset.draw();\r\n\r\n\t\t\thelpers.canvas.unclipArea(chart.ctx);\r\n\t\t}\r\n\r\n\t\t// Draw the points\r\n\t\tfor (; i < ilen; ++i) {\r\n\t\t\tpoints[i].draw(area);\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.line.js","name":"lineEnabled","start_line":28,"end_line":30,"comment":[],"params":["dataset","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"getTickBackdropHeight","line":231,"func_location":"module.exports.drawPointLabels","func_start_line":223,"func_end_line":275,"args":["opts"],"code":"\tfunction drawPointLabels(scale) {\r\n\t\tvar ctx = scale.ctx;\r\n\t\tvar opts = scale.options;\r\n\t\tvar angleLineOpts = opts.angleLines;\r\n\t\tvar gridLineOpts = opts.gridLines;\r\n\t\tvar pointLabelOpts = opts.pointLabels;\r\n\t\tvar lineWidth = helpers.valueOrDefault(angleLineOpts.lineWidth, gridLineOpts.lineWidth);\r\n\t\tvar lineColor = helpers.valueOrDefault(angleLineOpts.color, gridLineOpts.color);\r\n\t\tvar tickBackdropHeight = getTickBackdropHeight(opts);\r\n\r\n\t\tctx.save();\r\n\t\tctx.lineWidth = lineWidth;\r\n\t\tctx.strokeStyle = lineColor;\r\n\t\tif (ctx.setLineDash) {\r\n\t\t\tctx.setLineDash(helpers.valueOrDefault(angleLineOpts.borderDash, gridLineOpts.borderDash) || []);\r\n\t\t\tctx.lineDashOffset = helpers.valueOrDefault(angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset) || 0.0;\r\n\t\t}\r\n\r\n\t\tvar outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);\r\n\r\n\t\t// Point Label Font\r\n\t\tvar plFont = helpers.options._parseFont(pointLabelOpts);\r\n\r\n\t\tctx.font = plFont.string;\r\n\t\tctx.textBaseline = 'middle';\r\n\r\n\t\tfor (var i = getValueCount(scale) - 1; i >= 0; i--) {\r\n\t\t\tif (angleLineOpts.display && lineWidth && lineColor) {\r\n\t\t\t\tvar outerPosition = scale.getPointPosition(i, outerDistance);\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tctx.moveTo(scale.xCenter, scale.yCenter);\r\n\t\t\t\tctx.lineTo(outerPosition.x, outerPosition.y);\r\n\t\t\t\tctx.stroke();\r\n\t\t\t}\r\n\r\n\t\t\tif (pointLabelOpts.display) {\r\n\t\t\t\t// Extra pixels out for some label spacing\r\n\t\t\t\tvar extra = (i === 0 ? tickBackdropHeight / 2 : 0);\r\n\t\t\t\tvar pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + 5);\r\n\r\n\t\t\t\t// Keep this in loop since we may support array properties here\r\n\t\t\t\tvar pointLabelFontColor = helpers.valueAtIndexOrDefault(pointLabelOpts.fontColor, i, defaults.global.defaultFontColor);\r\n\t\t\t\tctx.fillStyle = pointLabelFontColor;\r\n\r\n\t\t\t\tvar angleRadians = scale.getIndexAngle(i);\r\n\t\t\t\tvar angle = helpers.toDegrees(angleRadians);\r\n\t\t\t\tctx.textAlign = getTextAlignForAngle(angle);\r\n\t\t\t\tadjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\r\n\t\t\t\tfillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.lineHeight);\r\n\t\t\t}\r\n\t\t}\r\n\t\tctx.restore();\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"module.exports.getTickBackdropHeight","start_line":65,"end_line":72,"comment":[],"params":["opts"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"getValueCount","line":249,"func_location":"module.exports.drawPointLabels","func_start_line":223,"func_end_line":275,"args":["scale"],"code":"\tfunction drawPointLabels(scale) {\r\n\t\tvar ctx = scale.ctx;\r\n\t\tvar opts = scale.options;\r\n\t\tvar angleLineOpts = opts.angleLines;\r\n\t\tvar gridLineOpts = opts.gridLines;\r\n\t\tvar pointLabelOpts = opts.pointLabels;\r\n\t\tvar lineWidth = helpers.valueOrDefault(angleLineOpts.lineWidth, gridLineOpts.lineWidth);\r\n\t\tvar lineColor = helpers.valueOrDefault(angleLineOpts.color, gridLineOpts.color);\r\n\t\tvar tickBackdropHeight = getTickBackdropHeight(opts);\r\n\r\n\t\tctx.save();\r\n\t\tctx.lineWidth = lineWidth;\r\n\t\tctx.strokeStyle = lineColor;\r\n\t\tif (ctx.setLineDash) {\r\n\t\t\tctx.setLineDash(helpers.valueOrDefault(angleLineOpts.borderDash, gridLineOpts.borderDash) || []);\r\n\t\t\tctx.lineDashOffset = helpers.valueOrDefault(angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset) || 0.0;\r\n\t\t}\r\n\r\n\t\tvar outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);\r\n\r\n\t\t// Point Label Font\r\n\t\tvar plFont = helpers.options._parseFont(pointLabelOpts);\r\n\r\n\t\tctx.font = plFont.string;\r\n\t\tctx.textBaseline = 'middle';\r\n\r\n\t\tfor (var i = getValueCount(scale) - 1; i >= 0; i--) {\r\n\t\t\tif (angleLineOpts.display && lineWidth && lineColor) {\r\n\t\t\t\tvar outerPosition = scale.getPointPosition(i, outerDistance);\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tctx.moveTo(scale.xCenter, scale.yCenter);\r\n\t\t\t\tctx.lineTo(outerPosition.x, outerPosition.y);\r\n\t\t\t\tctx.stroke();\r\n\t\t\t}\r\n\r\n\t\t\tif (pointLabelOpts.display) {\r\n\t\t\t\t// Extra pixels out for some label spacing\r\n\t\t\t\tvar extra = (i === 0 ? tickBackdropHeight / 2 : 0);\r\n\t\t\t\tvar pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + 5);\r\n\r\n\t\t\t\t// Keep this in loop since we may support array properties here\r\n\t\t\t\tvar pointLabelFontColor = helpers.valueAtIndexOrDefault(pointLabelOpts.fontColor, i, defaults.global.defaultFontColor);\r\n\t\t\t\tctx.fillStyle = pointLabelFontColor;\r\n\r\n\t\t\t\tvar angleRadians = scale.getIndexAngle(i);\r\n\t\t\t\tvar angle = helpers.toDegrees(angleRadians);\r\n\t\t\t\tctx.textAlign = getTextAlignForAngle(angle);\r\n\t\t\t\tadjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\r\n\t\t\t\tfillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.lineHeight);\r\n\t\t\t}\r\n\t\t}\r\n\t\tctx.restore();\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"module.exports.getValueCount","start_line":60,"end_line":63,"comment":[],"params":["scale"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"getTextAlignForAngle","line":269,"func_location":"module.exports.drawPointLabels","func_start_line":223,"func_end_line":275,"args":["angle"],"code":"\tfunction drawPointLabels(scale) {\r\n\t\tvar ctx = scale.ctx;\r\n\t\tvar opts = scale.options;\r\n\t\tvar angleLineOpts = opts.angleLines;\r\n\t\tvar gridLineOpts = opts.gridLines;\r\n\t\tvar pointLabelOpts = opts.pointLabels;\r\n\t\tvar lineWidth = helpers.valueOrDefault(angleLineOpts.lineWidth, gridLineOpts.lineWidth);\r\n\t\tvar lineColor = helpers.valueOrDefault(angleLineOpts.color, gridLineOpts.color);\r\n\t\tvar tickBackdropHeight = getTickBackdropHeight(opts);\r\n\r\n\t\tctx.save();\r\n\t\tctx.lineWidth = lineWidth;\r\n\t\tctx.strokeStyle = lineColor;\r\n\t\tif (ctx.setLineDash) {\r\n\t\t\tctx.setLineDash(helpers.valueOrDefault(angleLineOpts.borderDash, gridLineOpts.borderDash) || []);\r\n\t\t\tctx.lineDashOffset = helpers.valueOrDefault(angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset) || 0.0;\r\n\t\t}\r\n\r\n\t\tvar outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);\r\n\r\n\t\t// Point Label Font\r\n\t\tvar plFont = helpers.options._parseFont(pointLabelOpts);\r\n\r\n\t\tctx.font = plFont.string;\r\n\t\tctx.textBaseline = 'middle';\r\n\r\n\t\tfor (var i = getValueCount(scale) - 1; i >= 0; i--) {\r\n\t\t\tif (angleLineOpts.display && lineWidth && lineColor) {\r\n\t\t\t\tvar outerPosition = scale.getPointPosition(i, outerDistance);\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tctx.moveTo(scale.xCenter, scale.yCenter);\r\n\t\t\t\tctx.lineTo(outerPosition.x, outerPosition.y);\r\n\t\t\t\tctx.stroke();\r\n\t\t\t}\r\n\r\n\t\t\tif (pointLabelOpts.display) {\r\n\t\t\t\t// Extra pixels out for some label spacing\r\n\t\t\t\tvar extra = (i === 0 ? tickBackdropHeight / 2 : 0);\r\n\t\t\t\tvar pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + 5);\r\n\r\n\t\t\t\t// Keep this in loop since we may support array properties here\r\n\t\t\t\tvar pointLabelFontColor = helpers.valueAtIndexOrDefault(pointLabelOpts.fontColor, i, defaults.global.defaultFontColor);\r\n\t\t\t\tctx.fillStyle = pointLabelFontColor;\r\n\r\n\t\t\t\tvar angleRadians = scale.getIndexAngle(i);\r\n\t\t\t\tvar angle = helpers.toDegrees(angleRadians);\r\n\t\t\t\tctx.textAlign = getTextAlignForAngle(angle);\r\n\t\t\t\tadjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\r\n\t\t\t\tfillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.lineHeight);\r\n\t\t\t}\r\n\t\t}\r\n\t\tctx.restore();\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"module.exports.getTextAlignForAngle","start_line":191,"end_line":199,"comment":[],"params":["angle"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"adjustPointPositionForLabelHeight","line":270,"func_location":"module.exports.drawPointLabels","func_start_line":223,"func_end_line":275,"args":["angle","scale._pointLabelSizes.i","pointLabelPosition"],"code":"\tfunction drawPointLabels(scale) {\r\n\t\tvar ctx = scale.ctx;\r\n\t\tvar opts = scale.options;\r\n\t\tvar angleLineOpts = opts.angleLines;\r\n\t\tvar gridLineOpts = opts.gridLines;\r\n\t\tvar pointLabelOpts = opts.pointLabels;\r\n\t\tvar lineWidth = helpers.valueOrDefault(angleLineOpts.lineWidth, gridLineOpts.lineWidth);\r\n\t\tvar lineColor = helpers.valueOrDefault(angleLineOpts.color, gridLineOpts.color);\r\n\t\tvar tickBackdropHeight = getTickBackdropHeight(opts);\r\n\r\n\t\tctx.save();\r\n\t\tctx.lineWidth = lineWidth;\r\n\t\tctx.strokeStyle = lineColor;\r\n\t\tif (ctx.setLineDash) {\r\n\t\t\tctx.setLineDash(helpers.valueOrDefault(angleLineOpts.borderDash, gridLineOpts.borderDash) || []);\r\n\t\t\tctx.lineDashOffset = helpers.valueOrDefault(angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset) || 0.0;\r\n\t\t}\r\n\r\n\t\tvar outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);\r\n\r\n\t\t// Point Label Font\r\n\t\tvar plFont = helpers.options._parseFont(pointLabelOpts);\r\n\r\n\t\tctx.font = plFont.string;\r\n\t\tctx.textBaseline = 'middle';\r\n\r\n\t\tfor (var i = getValueCount(scale) - 1; i >= 0; i--) {\r\n\t\t\tif (angleLineOpts.display && lineWidth && lineColor) {\r\n\t\t\t\tvar outerPosition = scale.getPointPosition(i, outerDistance);\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tctx.moveTo(scale.xCenter, scale.yCenter);\r\n\t\t\t\tctx.lineTo(outerPosition.x, outerPosition.y);\r\n\t\t\t\tctx.stroke();\r\n\t\t\t}\r\n\r\n\t\t\tif (pointLabelOpts.display) {\r\n\t\t\t\t// Extra pixels out for some label spacing\r\n\t\t\t\tvar extra = (i === 0 ? tickBackdropHeight / 2 : 0);\r\n\t\t\t\tvar pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + 5);\r\n\r\n\t\t\t\t// Keep this in loop since we may support array properties here\r\n\t\t\t\tvar pointLabelFontColor = helpers.valueAtIndexOrDefault(pointLabelOpts.fontColor, i, defaults.global.defaultFontColor);\r\n\t\t\t\tctx.fillStyle = pointLabelFontColor;\r\n\r\n\t\t\t\tvar angleRadians = scale.getIndexAngle(i);\r\n\t\t\t\tvar angle = helpers.toDegrees(angleRadians);\r\n\t\t\t\tctx.textAlign = getTextAlignForAngle(angle);\r\n\t\t\t\tadjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\r\n\t\t\t\tfillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.lineHeight);\r\n\t\t\t}\r\n\t\t}\r\n\t\tctx.restore();\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"module.exports.adjustPointPositionForLabelHeight","start_line":215,"end_line":221,"comment":[],"params":["angle","textSize","position"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"fillText","line":271,"func_location":"module.exports.drawPointLabels","func_start_line":223,"func_end_line":275,"args":["ctx",null,"pointLabelPosition","plFont.lineHeight"],"code":"\tfunction drawPointLabels(scale) {\r\n\t\tvar ctx = scale.ctx;\r\n\t\tvar opts = scale.options;\r\n\t\tvar angleLineOpts = opts.angleLines;\r\n\t\tvar gridLineOpts = opts.gridLines;\r\n\t\tvar pointLabelOpts = opts.pointLabels;\r\n\t\tvar lineWidth = helpers.valueOrDefault(angleLineOpts.lineWidth, gridLineOpts.lineWidth);\r\n\t\tvar lineColor = helpers.valueOrDefault(angleLineOpts.color, gridLineOpts.color);\r\n\t\tvar tickBackdropHeight = getTickBackdropHeight(opts);\r\n\r\n\t\tctx.save();\r\n\t\tctx.lineWidth = lineWidth;\r\n\t\tctx.strokeStyle = lineColor;\r\n\t\tif (ctx.setLineDash) {\r\n\t\t\tctx.setLineDash(helpers.valueOrDefault(angleLineOpts.borderDash, gridLineOpts.borderDash) || []);\r\n\t\t\tctx.lineDashOffset = helpers.valueOrDefault(angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset) || 0.0;\r\n\t\t}\r\n\r\n\t\tvar outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);\r\n\r\n\t\t// Point Label Font\r\n\t\tvar plFont = helpers.options._parseFont(pointLabelOpts);\r\n\r\n\t\tctx.font = plFont.string;\r\n\t\tctx.textBaseline = 'middle';\r\n\r\n\t\tfor (var i = getValueCount(scale) - 1; i >= 0; i--) {\r\n\t\t\tif (angleLineOpts.display && lineWidth && lineColor) {\r\n\t\t\t\tvar outerPosition = scale.getPointPosition(i, outerDistance);\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tctx.moveTo(scale.xCenter, scale.yCenter);\r\n\t\t\t\tctx.lineTo(outerPosition.x, outerPosition.y);\r\n\t\t\t\tctx.stroke();\r\n\t\t\t}\r\n\r\n\t\t\tif (pointLabelOpts.display) {\r\n\t\t\t\t// Extra pixels out for some label spacing\r\n\t\t\t\tvar extra = (i === 0 ? tickBackdropHeight / 2 : 0);\r\n\t\t\t\tvar pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + 5);\r\n\r\n\t\t\t\t// Keep this in loop since we may support array properties here\r\n\t\t\t\tvar pointLabelFontColor = helpers.valueAtIndexOrDefault(pointLabelOpts.fontColor, i, defaults.global.defaultFontColor);\r\n\t\t\t\tctx.fillStyle = pointLabelFontColor;\r\n\r\n\t\t\t\tvar angleRadians = scale.getIndexAngle(i);\r\n\t\t\t\tvar angle = helpers.toDegrees(angleRadians);\r\n\t\t\t\tctx.textAlign = getTextAlignForAngle(angle);\r\n\t\t\t\tadjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\r\n\t\t\t\tfillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.lineHeight);\r\n\t\t\t}\r\n\t\t}\r\n\t\tctx.restore();\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"module.exports.fillText","start_line":201,"end_line":213,"comment":[],"params":["ctx","text","position","lineHeight"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"getValueCount","line":280,"func_location":"module.exports.drawRadiusLine","func_start_line":277,"func_end_line":314,"args":["scale"],"code":"\tfunction drawRadiusLine(scale, gridLineOpts, radius, index) {\r\n\t\tvar ctx = scale.ctx;\r\n\t\tvar circular = gridLineOpts.circular;\r\n\t\tvar valueCount = getValueCount(scale);\r\n\t\tvar lineColor = helpers.valueAtIndexOrDefault(gridLineOpts.color, index - 1);\r\n\t\tvar lineWidth = helpers.valueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);\r\n\t\tvar pointPosition;\r\n\r\n\t\tif ((!circular && !valueCount) || !lineColor || !lineWidth) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tctx.save();\r\n\t\tctx.strokeStyle = lineColor;\r\n\t\tctx.lineWidth = lineWidth;\r\n\t\tif (ctx.setLineDash) {\r\n\t\t\tctx.setLineDash(gridLineOpts.borderDash || []);\r\n\t\t\tctx.lineDashOffset = gridLineOpts.borderDashOffset || 0.0;\r\n\t\t}\r\n\r\n\t\tctx.beginPath();\r\n\t\tif (circular) {\r\n\t\t\t// Draw circular arcs between the points\r\n\t\t\tctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);\r\n\t\t} else {\r\n\t\t\t// Draw straight lines connecting each index\r\n\t\t\tpointPosition = scale.getPointPosition(0, radius);\r\n\t\t\tctx.moveTo(pointPosition.x, pointPosition.y);\r\n\r\n\t\t\tfor (var i = 1; i < valueCount; i++) {\r\n\t\t\t\tpointPosition = scale.getPointPosition(i, radius);\r\n\t\t\t\tctx.lineTo(pointPosition.x, pointPosition.y);\r\n\t\t\t}\r\n\t\t}\r\n\t\tctx.closePath();\r\n\t\tctx.stroke();\r\n\t\tctx.restore();\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"module.exports.getValueCount","start_line":60,"end_line":63,"comment":[],"params":["scale"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.canvas.js","name":"roundedRect","line":239,"func_location":"helpers.drawRoundedRectangle","func_start_line":237,"func_end_line":240,"args":["exports","arguments"],"comment":["*\r\n * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.\r\n * @namespace Chart.helpers.drawRoundedRectangle\r\n * @deprecated since version 2.7.0\r\n * @todo remove at version 3\r\n * @private\r\n "],"code":"helpers.drawRoundedRectangle = function(ctx) {\r\n\tctx.beginPath();\r\n\texports.roundedRect.apply(exports, arguments);\r\n};\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.canvas.js","name":"exports.roundedRect","start_line":35,"end_line":64,"comment":["*\r\n\t * Creates a \"path\" for a rectangle with rounded corners at position (x, y) with a\r\n\t * given size (width, height) and the same `radius` for all corners.\r\n\t * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.\r\n\t * @param {Number} x - The x axis of the coordinate for the rectangle starting point.\r\n\t * @param {Number} y - The y axis of the coordinate for the rectangle starting point.\r\n\t * @param {Number} width - The rectangle's width.\r\n\t * @param {Number} height - The rectangle's height.\r\n\t * @param {Number} radius - The rounded amount (in pixels) for the four corners.\r\n\t * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?\r\n\t "],"params":["ctx","x","y","width","height","radius"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"isArray","line":116,"func_location":"helpers.each","func_start_line":114,"func_end_line":134,"args":["loopable"],"comment":["*\r\n\t * Note(SB) for performance sake, this method should only be used when loopable type\r\n\t * is unknown or in none intensive code (not called often and small loopable). Else\r\n\t * it's preferable to use a regular for() loop and save extra function calls.\r\n\t * @param {Object|Array} loopable - The object or array to be iterated.\r\n\t * @param {Function} fn - The function to call for each item.\r\n\t * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.\r\n\t * @param {Boolean} [reverse] - If true, iterates backward on the loopable.\r\n\t "],"code":"\teach: function(loopable, fn, thisArg, reverse) {\r\n\t\tvar i, len, keys;\r\n\t\tif (helpers.isArray(loopable)) {\r\n\t\t\tlen = loopable.length;\r\n\t\t\tif (reverse) {\r\n\t\t\t\tfor (i = len - 1; i >= 0; i--) {\r\n\t\t\t\t\tfn.call(thisArg, loopable[i], i);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfor (i = 0; i < len; i++) {\r\n\t\t\t\t\tfn.call(thisArg, loopable[i], i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (helpers.isObject(loopable)) {\r\n\t\t\tkeys = Object.keys(loopable);\r\n\t\t\tlen = keys.length;\r\n\t\t\tfor (i = 0; i < len; i++) {\r\n\t\t\t\tfn.call(thisArg, loopable[keys[i]], keys[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"helpers.isArray","start_line":40,"end_line":49,"comment":["*\r\n\t * Returns true if `value` is an array (including typed arrays), else returns false.\r\n\t * @param {*} value - The value to test.\r\n\t * @returns {Boolean}\r\n\t * @function\r\n\t "],"params":["value"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"isObject","line":127,"func_location":"helpers.each","func_start_line":114,"func_end_line":134,"args":["loopable"],"comment":["*\r\n\t * Note(SB) for performance sake, this method should only be used when loopable type\r\n\t * is unknown or in none intensive code (not called often and small loopable). Else\r\n\t * it's preferable to use a regular for() loop and save extra function calls.\r\n\t * @param {Object|Array} loopable - The object or array to be iterated.\r\n\t * @param {Function} fn - The function to call for each item.\r\n\t * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.\r\n\t * @param {Boolean} [reverse] - If true, iterates backward on the loopable.\r\n\t "],"code":"\teach: function(loopable, fn, thisArg, reverse) {\r\n\t\tvar i, len, keys;\r\n\t\tif (helpers.isArray(loopable)) {\r\n\t\t\tlen = loopable.length;\r\n\t\t\tif (reverse) {\r\n\t\t\t\tfor (i = len - 1; i >= 0; i--) {\r\n\t\t\t\t\tfn.call(thisArg, loopable[i], i);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfor (i = 0; i < len; i++) {\r\n\t\t\t\t\tfn.call(thisArg, loopable[i], i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (helpers.isObject(loopable)) {\r\n\t\t\tkeys = Object.keys(loopable);\r\n\t\t\tlen = keys.length;\r\n\t\t\tfor (i = 0; i < len; i++) {\r\n\t\t\t\tfn.call(thisArg, loopable[keys[i]], keys[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"helpers.isObject","start_line":57,"end_line":59,"comment":["*\r\n\t * Returns true if `value` is an object (excluding null), else returns false.\r\n\t * @param {*} value - The value to test.\r\n\t * @returns {Boolean}\r\n\t * @since 2.7.0\r\n\t "],"params":["value"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.easing.js","name":"easeInBounce","line":231,"func_location":"effects.easeInOutBounce","func_start_line":229,"func_end_line":234,"args":[null],"code":"\teaseInOutBounce: function(t) {\r\n\t\tif (t < 0.5) {\r\n\t\t\treturn effects.easeInBounce(t * 2) * 0.5;\r\n\t\t}\r\n\t\treturn effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.easing.js","name":"effects.easeInBounce","start_line":212,"end_line":214,"comment":[],"params":["t"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"each","line":283,"func_location":"helpers.extend","func_start_line":278,"func_end_line":286,"args":["arguments.i","setFn"],"comment":["*\r\n\t * Applies the contents of two or more objects together into the first object.\r\n\t * @param {Object} target - The target object in which all objects are merged into.\r\n\t * @param {Object} arg1 - Object containing additional properties to merge in target.\r\n\t * @param {Object} argN - Additional objects containing properties to merge in target.\r\n\t * @returns {Object} The `target` object.\r\n\t "],"code":"\textend: function(target) {\r\n\t\tvar setFn = function(value, key) {\r\n\t\t\ttarget[key] = value;\r\n\t\t};\r\n\t\tfor (var i = 1, ilen = arguments.length; i < ilen; ++i) {\r\n\t\t\thelpers.each(arguments[i], setFn);\r\n\t\t}\r\n\t\treturn target;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"helpers.each","start_line":114,"end_line":134,"comment":["*\r\n\t * Note(SB) for performance sake, this method should only be used when loopable type\r\n\t * is unknown or in none intensive code (not called often and small loopable). Else\r\n\t * it's preferable to use a regular for() loop and save extra function calls.\r\n\t * @param {Object|Array} loopable - The object or array to be iterated.\r\n\t * @param {Function} fn - The function to call for each item.\r\n\t * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.\r\n\t * @param {Boolean} [reverse] - If true, iterates backward on the loopable.\r\n\t "],"params":["loopable","fn","thisArg","reverse"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"fitWithPointLabels","line":382,"func_location":"module.exports.LinearRadialScale.fit","func_start_line":377,"func_end_line":386,"args":["me"],"code":"\t\tfit: function() {\r\n\t\t\tvar me = this;\r\n\t\t\tvar opts = me.options;\r\n\r\n\t\t\tif (opts.display && opts.pointLabels.display) {\r\n\t\t\t\tfitWithPointLabels(me);\r\n\t\t\t} else {\r\n\t\t\t\tme.setCenterPoint(0, 0, 0, 0);\r\n\t\t\t}\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"module.exports.fitWithPointLabels","start_line":110,"end_line":189,"comment":["*\r\n\t * Helper function to fit a radial linear scale with point labels\r\n\t "],"params":["scale"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.scale.js","name":"labelsFromTicks","line":369,"func_location":"fit","func_start_line":361,"func_end_line":476,"args":["me._ticks"],"code":"\tfit: function() {\r\n\t\tvar me = this;\r\n\t\t// Reset\r\n\t\tvar minSize = me.minSize = {\r\n\t\t\twidth: 0,\r\n\t\t\theight: 0\r\n\t\t};\r\n\r\n\t\tvar labels = labelsFromTicks(me._ticks);\r\n\r\n\t\tvar opts = me.options;\r\n\t\tvar tickOpts = opts.ticks;\r\n\t\tvar scaleLabelOpts = opts.scaleLabel;\r\n\t\tvar gridLineOpts = opts.gridLines;\r\n\t\tvar display = me._isVisible();\r\n\t\tvar position = opts.position;\r\n\t\tvar isHorizontal = me.isHorizontal();\r\n\r\n\t\tvar parseFont = helpers.options._parseFont;\r\n\t\tvar tickFont = parseFont(tickOpts);\r\n\t\tvar tickMarkLength = opts.gridLines.tickMarkLength;\r\n\r\n\t\t// Width\r\n\t\tif (isHorizontal) {\r\n\t\t\t// subtract the margins to line up with the chartArea if we are a full width scale\r\n\t\t\tminSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;\r\n\t\t} else {\r\n\t\t\tminSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\r\n\t\t}\r\n\r\n\t\t// height\r\n\t\tif (isHorizontal) {\r\n\t\t\tminSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\r\n\t\t} else {\r\n\t\t\tminSize.height = me.maxHeight; // fill all the height\r\n\t\t}\r\n\r\n\t\t// Are we showing a title for the scale?\r\n\t\tif (scaleLabelOpts.display && display) {\r\n\t\t\tvar scaleLabelFont = parseFont(scaleLabelOpts);\r\n\t\t\tvar scaleLabelPadding = helpers.options.toPadding(scaleLabelOpts.padding);\r\n\t\t\tvar deltaHeight = scaleLabelFont.lineHeight + scaleLabelPadding.height;\r\n\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\tminSize.height += deltaHeight;\r\n\t\t\t} else {\r\n\t\t\t\tminSize.width += deltaHeight;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Don't bother fitting the ticks if we are not showing them\r\n\t\tif (tickOpts.display && display) {\r\n\t\t\tvar largestTextWidth = helpers.longestText(me.ctx, tickFont.string, labels, me.longestTextCache);\r\n\t\t\tvar tallestLabelHeightInLines = helpers.numberOfLabelLines(labels);\r\n\t\t\tvar lineSpace = tickFont.size * 0.5;\r\n\t\t\tvar tickPadding = me.options.ticks.padding;\r\n\r\n\t\t\t// Store max number of lines used in labels for _autoSkip\r\n\t\t\tme._maxLabelLines = tallestLabelHeightInLines;\r\n\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\t// A horizontal axis is more constrained by the height.\r\n\t\t\t\tme.longestLabelWidth = largestTextWidth;\r\n\r\n\t\t\t\tvar angleRadians = helpers.toRadians(me.labelRotation);\r\n\t\t\t\tvar cosRotation = Math.cos(angleRadians);\r\n\t\t\t\tvar sinRotation = Math.sin(angleRadians);\r\n\r\n\t\t\t\t// TODO - improve this calculation\r\n\t\t\t\tvar labelHeight = (sinRotation * largestTextWidth)\r\n\t\t\t\t\t+ (tickFont.lineHeight * tallestLabelHeightInLines)\r\n\t\t\t\t\t+ lineSpace; // padding\r\n\r\n\t\t\t\tminSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);\r\n\r\n\t\t\t\tme.ctx.font = tickFont.string;\r\n\t\t\t\tvar firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.string);\r\n\t\t\t\tvar lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.string);\r\n\t\t\t\tvar offsetLeft = me.getPixelForTick(0) - me.left;\r\n\t\t\t\tvar offsetRight = me.right - me.getPixelForTick(labels.length - 1);\r\n\t\t\t\tvar paddingLeft, paddingRight;\r\n\r\n\t\t\t\t// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned\r\n\t\t\t\t// which means that the right padding is dominated by the font height\r\n\t\t\t\tif (me.labelRotation !== 0) {\r\n\t\t\t\t\tpaddingLeft = position === 'bottom' ? (cosRotation * firstLabelWidth) : (cosRotation * lineSpace);\r\n\t\t\t\t\tpaddingRight = position === 'bottom' ? (cosRotation * lineSpace) : (cosRotation * lastLabelWidth);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpaddingLeft = firstLabelWidth / 2;\r\n\t\t\t\t\tpaddingRight = lastLabelWidth / 2;\r\n\t\t\t\t}\r\n\t\t\t\tme.paddingLeft = Math.max(paddingLeft - offsetLeft, 0) + 3; // add 3 px to move away from canvas edges\r\n\t\t\t\tme.paddingRight = Math.max(paddingRight - offsetRight, 0) + 3;\r\n\t\t\t} else {\r\n\t\t\t\t// A vertical axis is more constrained by the width. Labels are the\r\n\t\t\t\t// dominant factor here, so get that length first and account for padding\r\n\t\t\t\tif (tickOpts.mirror) {\r\n\t\t\t\t\tlargestTextWidth = 0;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// use lineSpace for consistency with horizontal axis\r\n\t\t\t\t\t// tickPadding is not implemented for horizontal\r\n\t\t\t\t\tlargestTextWidth += tickPadding + lineSpace;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tminSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);\r\n\r\n\t\t\t\tme.paddingTop = tickFont.size / 2;\r\n\t\t\t\tme.paddingBottom = tickFont.size / 2;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tme.handleMargins();\r\n\r\n\t\tme.width = minSize.width;\r\n\t\tme.height = minSize.height;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.scale.js","name":"labelsFromTicks","start_line":65,"end_line":74,"comment":[],"params":["ticks"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.scale.js","name":"computeTextSize","line":437,"func_location":"fit","func_start_line":361,"func_end_line":476,"args":["me.ctx","labels.","tickFont.string"],"code":"\tfit: function() {\r\n\t\tvar me = this;\r\n\t\t// Reset\r\n\t\tvar minSize = me.minSize = {\r\n\t\t\twidth: 0,\r\n\t\t\theight: 0\r\n\t\t};\r\n\r\n\t\tvar labels = labelsFromTicks(me._ticks);\r\n\r\n\t\tvar opts = me.options;\r\n\t\tvar tickOpts = opts.ticks;\r\n\t\tvar scaleLabelOpts = opts.scaleLabel;\r\n\t\tvar gridLineOpts = opts.gridLines;\r\n\t\tvar display = me._isVisible();\r\n\t\tvar position = opts.position;\r\n\t\tvar isHorizontal = me.isHorizontal();\r\n\r\n\t\tvar parseFont = helpers.options._parseFont;\r\n\t\tvar tickFont = parseFont(tickOpts);\r\n\t\tvar tickMarkLength = opts.gridLines.tickMarkLength;\r\n\r\n\t\t// Width\r\n\t\tif (isHorizontal) {\r\n\t\t\t// subtract the margins to line up with the chartArea if we are a full width scale\r\n\t\t\tminSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;\r\n\t\t} else {\r\n\t\t\tminSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\r\n\t\t}\r\n\r\n\t\t// height\r\n\t\tif (isHorizontal) {\r\n\t\t\tminSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\r\n\t\t} else {\r\n\t\t\tminSize.height = me.maxHeight; // fill all the height\r\n\t\t}\r\n\r\n\t\t// Are we showing a title for the scale?\r\n\t\tif (scaleLabelOpts.display && display) {\r\n\t\t\tvar scaleLabelFont = parseFont(scaleLabelOpts);\r\n\t\t\tvar scaleLabelPadding = helpers.options.toPadding(scaleLabelOpts.padding);\r\n\t\t\tvar deltaHeight = scaleLabelFont.lineHeight + scaleLabelPadding.height;\r\n\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\tminSize.height += deltaHeight;\r\n\t\t\t} else {\r\n\t\t\t\tminSize.width += deltaHeight;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Don't bother fitting the ticks if we are not showing them\r\n\t\tif (tickOpts.display && display) {\r\n\t\t\tvar largestTextWidth = helpers.longestText(me.ctx, tickFont.string, labels, me.longestTextCache);\r\n\t\t\tvar tallestLabelHeightInLines = helpers.numberOfLabelLines(labels);\r\n\t\t\tvar lineSpace = tickFont.size * 0.5;\r\n\t\t\tvar tickPadding = me.options.ticks.padding;\r\n\r\n\t\t\t// Store max number of lines used in labels for _autoSkip\r\n\t\t\tme._maxLabelLines = tallestLabelHeightInLines;\r\n\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\t// A horizontal axis is more constrained by the height.\r\n\t\t\t\tme.longestLabelWidth = largestTextWidth;\r\n\r\n\t\t\t\tvar angleRadians = helpers.toRadians(me.labelRotation);\r\n\t\t\t\tvar cosRotation = Math.cos(angleRadians);\r\n\t\t\t\tvar sinRotation = Math.sin(angleRadians);\r\n\r\n\t\t\t\t// TODO - improve this calculation\r\n\t\t\t\tvar labelHeight = (sinRotation * largestTextWidth)\r\n\t\t\t\t\t+ (tickFont.lineHeight * tallestLabelHeightInLines)\r\n\t\t\t\t\t+ lineSpace; // padding\r\n\r\n\t\t\t\tminSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);\r\n\r\n\t\t\t\tme.ctx.font = tickFont.string;\r\n\t\t\t\tvar firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.string);\r\n\t\t\t\tvar lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.string);\r\n\t\t\t\tvar offsetLeft = me.getPixelForTick(0) - me.left;\r\n\t\t\t\tvar offsetRight = me.right - me.getPixelForTick(labels.length - 1);\r\n\t\t\t\tvar paddingLeft, paddingRight;\r\n\r\n\t\t\t\t// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned\r\n\t\t\t\t// which means that the right padding is dominated by the font height\r\n\t\t\t\tif (me.labelRotation !== 0) {\r\n\t\t\t\t\tpaddingLeft = position === 'bottom' ? (cosRotation * firstLabelWidth) : (cosRotation * lineSpace);\r\n\t\t\t\t\tpaddingRight = position === 'bottom' ? (cosRotation * lineSpace) : (cosRotation * lastLabelWidth);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpaddingLeft = firstLabelWidth / 2;\r\n\t\t\t\t\tpaddingRight = lastLabelWidth / 2;\r\n\t\t\t\t}\r\n\t\t\t\tme.paddingLeft = Math.max(paddingLeft - offsetLeft, 0) + 3; // add 3 px to move away from canvas edges\r\n\t\t\t\tme.paddingRight = Math.max(paddingRight - offsetRight, 0) + 3;\r\n\t\t\t} else {\r\n\t\t\t\t// A vertical axis is more constrained by the width. Labels are the\r\n\t\t\t\t// dominant factor here, so get that length first and account for padding\r\n\t\t\t\tif (tickOpts.mirror) {\r\n\t\t\t\t\tlargestTextWidth = 0;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// use lineSpace for consistency with horizontal axis\r\n\t\t\t\t\t// tickPadding is not implemented for horizontal\r\n\t\t\t\t\tlargestTextWidth += tickPadding + lineSpace;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tminSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);\r\n\r\n\t\t\t\tme.paddingTop = tickFont.size / 2;\r\n\t\t\t\tme.paddingBottom = tickFont.size / 2;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tme.handleMargins();\r\n\r\n\t\tme.width = minSize.width;\r\n\t\tme.height = minSize.height;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.scale.js","name":"computeTextSize","start_line":93,"end_line":97,"comment":[],"params":["context","tick","font"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.scale.js","name":"computeTextSize","line":438,"func_location":"fit","func_start_line":361,"func_end_line":476,"args":["me.ctx","labels.","tickFont.string"],"code":"\tfit: function() {\r\n\t\tvar me = this;\r\n\t\t// Reset\r\n\t\tvar minSize = me.minSize = {\r\n\t\t\twidth: 0,\r\n\t\t\theight: 0\r\n\t\t};\r\n\r\n\t\tvar labels = labelsFromTicks(me._ticks);\r\n\r\n\t\tvar opts = me.options;\r\n\t\tvar tickOpts = opts.ticks;\r\n\t\tvar scaleLabelOpts = opts.scaleLabel;\r\n\t\tvar gridLineOpts = opts.gridLines;\r\n\t\tvar display = me._isVisible();\r\n\t\tvar position = opts.position;\r\n\t\tvar isHorizontal = me.isHorizontal();\r\n\r\n\t\tvar parseFont = helpers.options._parseFont;\r\n\t\tvar tickFont = parseFont(tickOpts);\r\n\t\tvar tickMarkLength = opts.gridLines.tickMarkLength;\r\n\r\n\t\t// Width\r\n\t\tif (isHorizontal) {\r\n\t\t\t// subtract the margins to line up with the chartArea if we are a full width scale\r\n\t\t\tminSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;\r\n\t\t} else {\r\n\t\t\tminSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\r\n\t\t}\r\n\r\n\t\t// height\r\n\t\tif (isHorizontal) {\r\n\t\t\tminSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\r\n\t\t} else {\r\n\t\t\tminSize.height = me.maxHeight; // fill all the height\r\n\t\t}\r\n\r\n\t\t// Are we showing a title for the scale?\r\n\t\tif (scaleLabelOpts.display && display) {\r\n\t\t\tvar scaleLabelFont = parseFont(scaleLabelOpts);\r\n\t\t\tvar scaleLabelPadding = helpers.options.toPadding(scaleLabelOpts.padding);\r\n\t\t\tvar deltaHeight = scaleLabelFont.lineHeight + scaleLabelPadding.height;\r\n\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\tminSize.height += deltaHeight;\r\n\t\t\t} else {\r\n\t\t\t\tminSize.width += deltaHeight;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Don't bother fitting the ticks if we are not showing them\r\n\t\tif (tickOpts.display && display) {\r\n\t\t\tvar largestTextWidth = helpers.longestText(me.ctx, tickFont.string, labels, me.longestTextCache);\r\n\t\t\tvar tallestLabelHeightInLines = helpers.numberOfLabelLines(labels);\r\n\t\t\tvar lineSpace = tickFont.size * 0.5;\r\n\t\t\tvar tickPadding = me.options.ticks.padding;\r\n\r\n\t\t\t// Store max number of lines used in labels for _autoSkip\r\n\t\t\tme._maxLabelLines = tallestLabelHeightInLines;\r\n\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\t// A horizontal axis is more constrained by the height.\r\n\t\t\t\tme.longestLabelWidth = largestTextWidth;\r\n\r\n\t\t\t\tvar angleRadians = helpers.toRadians(me.labelRotation);\r\n\t\t\t\tvar cosRotation = Math.cos(angleRadians);\r\n\t\t\t\tvar sinRotation = Math.sin(angleRadians);\r\n\r\n\t\t\t\t// TODO - improve this calculation\r\n\t\t\t\tvar labelHeight = (sinRotation * largestTextWidth)\r\n\t\t\t\t\t+ (tickFont.lineHeight * tallestLabelHeightInLines)\r\n\t\t\t\t\t+ lineSpace; // padding\r\n\r\n\t\t\t\tminSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);\r\n\r\n\t\t\t\tme.ctx.font = tickFont.string;\r\n\t\t\t\tvar firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.string);\r\n\t\t\t\tvar lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.string);\r\n\t\t\t\tvar offsetLeft = me.getPixelForTick(0) - me.left;\r\n\t\t\t\tvar offsetRight = me.right - me.getPixelForTick(labels.length - 1);\r\n\t\t\t\tvar paddingLeft, paddingRight;\r\n\r\n\t\t\t\t// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned\r\n\t\t\t\t// which means that the right padding is dominated by the font height\r\n\t\t\t\tif (me.labelRotation !== 0) {\r\n\t\t\t\t\tpaddingLeft = position === 'bottom' ? (cosRotation * firstLabelWidth) : (cosRotation * lineSpace);\r\n\t\t\t\t\tpaddingRight = position === 'bottom' ? (cosRotation * lineSpace) : (cosRotation * lastLabelWidth);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpaddingLeft = firstLabelWidth / 2;\r\n\t\t\t\t\tpaddingRight = lastLabelWidth / 2;\r\n\t\t\t\t}\r\n\t\t\t\tme.paddingLeft = Math.max(paddingLeft - offsetLeft, 0) + 3; // add 3 px to move away from canvas edges\r\n\t\t\t\tme.paddingRight = Math.max(paddingRight - offsetRight, 0) + 3;\r\n\t\t\t} else {\r\n\t\t\t\t// A vertical axis is more constrained by the width. Labels are the\r\n\t\t\t\t// dominant factor here, so get that length first and account for padding\r\n\t\t\t\tif (tickOpts.mirror) {\r\n\t\t\t\t\tlargestTextWidth = 0;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// use lineSpace for consistency with horizontal axis\r\n\t\t\t\t\t// tickPadding is not implemented for horizontal\r\n\t\t\t\t\tlargestTextWidth += tickPadding + lineSpace;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tminSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);\r\n\r\n\t\t\t\tme.paddingTop = tickFont.size / 2;\r\n\t\t\t\tme.paddingBottom = tickFont.size / 2;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tme.handleMargins();\r\n\r\n\t\tme.width = minSize.width;\r\n\t\tme.height = minSize.height;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.scale.js","name":"computeTextSize","start_line":93,"end_line":97,"comment":[],"params":["context","tick","font"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"getValueCount","line":155,"func_location":"module.exports.fitWithPointLabels","func_start_line":110,"func_end_line":189,"args":["scale"],"comment":["*\r\n\t * Helper function to fit a radial linear scale with point labels\r\n\t "],"code":"\tfunction fitWithPointLabels(scale) {\r\n\t\t/*\r\n\t\t * Right, this is really confusing and there is a lot of maths going on here\r\n\t\t * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\r\n\t\t *\r\n\t\t * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\r\n\t\t *\r\n\t\t * Solution:\r\n\t\t *\r\n\t\t * We assume the radius of the polygon is half the size of the canvas at first\r\n\t\t * at each index we check if the text overlaps.\r\n\t\t *\r\n\t\t * Where it does, we store that angle and that index.\r\n\t\t *\r\n\t\t * After finding the largest index and angle we calculate how much we need to remove\r\n\t\t * from the shape radius to move the point inwards by that x.\r\n\t\t *\r\n\t\t * We average the left and right distances to get the maximum shape radius that can fit in the box\r\n\t\t * along with labels.\r\n\t\t *\r\n\t\t * Once we have that, we can find the centre point for the chart, by taking the x text protrusion\r\n\t\t * on each side, removing that from the size, halving it and adding the left x protrusion width.\r\n\t\t *\r\n\t\t * This will mean we have a shape fitted to the canvas, as large as it can be with the labels\r\n\t\t * and position it in the most space efficient manner\r\n\t\t *\r\n\t\t * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\r\n\t\t */\r\n\r\n\t\tvar plFont = helpers.options._parseFont(scale.options.pointLabels);\r\n\r\n\t\t// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\r\n\t\t// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\r\n\t\tvar furthestLimits = {\r\n\t\t\tl: 0,\r\n\t\t\tr: scale.width,\r\n\t\t\tt: 0,\r\n\t\t\tb: scale.height\r\n\t\t};\r\n\t\tvar furthestAngles = {};\r\n\t\tvar i, textSize, pointPosition;\r\n\r\n\t\tscale.ctx.font = plFont.string;\r\n\t\tscale._pointLabelSizes = [];\r\n\r\n\t\tvar valueCount = getValueCount(scale);\r\n\t\tfor (i = 0; i < valueCount; i++) {\r\n\t\t\tpointPosition = scale.getPointPosition(i, scale.drawingArea + 5);\r\n\t\t\ttextSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale.pointLabels[i] || '');\r\n\t\t\tscale._pointLabelSizes[i] = textSize;\r\n\r\n\t\t\t// Add quarter circle to make degree 0 mean top of circle\r\n\t\t\tvar angleRadians = scale.getIndexAngle(i);\r\n\t\t\tvar angle = helpers.toDegrees(angleRadians) % 360;\r\n\t\t\tvar hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\r\n\t\t\tvar vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\r\n\r\n\t\t\tif (hLimits.start < furthestLimits.l) {\r\n\t\t\t\tfurthestLimits.l = hLimits.start;\r\n\t\t\t\tfurthestAngles.l = angleRadians;\r\n\t\t\t}\r\n\r\n\t\t\tif (hLimits.end > furthestLimits.r) {\r\n\t\t\t\tfurthestLimits.r = hLimits.end;\r\n\t\t\t\tfurthestAngles.r = angleRadians;\r\n\t\t\t}\r\n\r\n\t\t\tif (vLimits.start < furthestLimits.t) {\r\n\t\t\t\tfurthestLimits.t = vLimits.start;\r\n\t\t\t\tfurthestAngles.t = angleRadians;\r\n\t\t\t}\r\n\r\n\t\t\tif (vLimits.end > furthestLimits.b) {\r\n\t\t\t\tfurthestLimits.b = vLimits.end;\r\n\t\t\t\tfurthestAngles.b = angleRadians;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tscale.setReductions(scale.drawingArea, furthestLimits, furthestAngles);\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"module.exports.getValueCount","start_line":60,"end_line":63,"comment":[],"params":["scale"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"measureLabelSize","line":158,"func_location":"module.exports.fitWithPointLabels","func_start_line":110,"func_end_line":189,"args":["scale.ctx","plFont.lineHeight",null],"comment":["*\r\n\t * Helper function to fit a radial linear scale with point labels\r\n\t "],"code":"\tfunction fitWithPointLabels(scale) {\r\n\t\t/*\r\n\t\t * Right, this is really confusing and there is a lot of maths going on here\r\n\t\t * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\r\n\t\t *\r\n\t\t * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\r\n\t\t *\r\n\t\t * Solution:\r\n\t\t *\r\n\t\t * We assume the radius of the polygon is half the size of the canvas at first\r\n\t\t * at each index we check if the text overlaps.\r\n\t\t *\r\n\t\t * Where it does, we store that angle and that index.\r\n\t\t *\r\n\t\t * After finding the largest index and angle we calculate how much we need to remove\r\n\t\t * from the shape radius to move the point inwards by that x.\r\n\t\t *\r\n\t\t * We average the left and right distances to get the maximum shape radius that can fit in the box\r\n\t\t * along with labels.\r\n\t\t *\r\n\t\t * Once we have that, we can find the centre point for the chart, by taking the x text protrusion\r\n\t\t * on each side, removing that from the size, halving it and adding the left x protrusion width.\r\n\t\t *\r\n\t\t * This will mean we have a shape fitted to the canvas, as large as it can be with the labels\r\n\t\t * and position it in the most space efficient manner\r\n\t\t *\r\n\t\t * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\r\n\t\t */\r\n\r\n\t\tvar plFont = helpers.options._parseFont(scale.options.pointLabels);\r\n\r\n\t\t// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\r\n\t\t// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\r\n\t\tvar furthestLimits = {\r\n\t\t\tl: 0,\r\n\t\t\tr: scale.width,\r\n\t\t\tt: 0,\r\n\t\t\tb: scale.height\r\n\t\t};\r\n\t\tvar furthestAngles = {};\r\n\t\tvar i, textSize, pointPosition;\r\n\r\n\t\tscale.ctx.font = plFont.string;\r\n\t\tscale._pointLabelSizes = [];\r\n\r\n\t\tvar valueCount = getValueCount(scale);\r\n\t\tfor (i = 0; i < valueCount; i++) {\r\n\t\t\tpointPosition = scale.getPointPosition(i, scale.drawingArea + 5);\r\n\t\t\ttextSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale.pointLabels[i] || '');\r\n\t\t\tscale._pointLabelSizes[i] = textSize;\r\n\r\n\t\t\t// Add quarter circle to make degree 0 mean top of circle\r\n\t\t\tvar angleRadians = scale.getIndexAngle(i);\r\n\t\t\tvar angle = helpers.toDegrees(angleRadians) % 360;\r\n\t\t\tvar hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\r\n\t\t\tvar vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\r\n\r\n\t\t\tif (hLimits.start < furthestLimits.l) {\r\n\t\t\t\tfurthestLimits.l = hLimits.start;\r\n\t\t\t\tfurthestAngles.l = angleRadians;\r\n\t\t\t}\r\n\r\n\t\t\tif (hLimits.end > furthestLimits.r) {\r\n\t\t\t\tfurthestLimits.r = hLimits.end;\r\n\t\t\t\tfurthestAngles.r = angleRadians;\r\n\t\t\t}\r\n\r\n\t\t\tif (vLimits.start < furthestLimits.t) {\r\n\t\t\t\tfurthestLimits.t = vLimits.start;\r\n\t\t\t\tfurthestAngles.t = angleRadians;\r\n\t\t\t}\r\n\r\n\t\t\tif (vLimits.end > furthestLimits.b) {\r\n\t\t\t\tfurthestLimits.b = vLimits.end;\r\n\t\t\t\tfurthestAngles.b = angleRadians;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tscale.setReductions(scale.drawingArea, furthestLimits, furthestAngles);\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"module.exports.measureLabelSize","start_line":74,"end_line":86,"comment":[],"params":["ctx","lineHeight","label"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"determineLimits","line":164,"func_location":"module.exports.fitWithPointLabels","func_start_line":110,"func_end_line":189,"args":["angle","pointPosition.x","textSize.w",{"type":"number"},{"type":"number"}],"comment":["*\r\n\t * Helper function to fit a radial linear scale with point labels\r\n\t "],"code":"\tfunction fitWithPointLabels(scale) {\r\n\t\t/*\r\n\t\t * Right, this is really confusing and there is a lot of maths going on here\r\n\t\t * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\r\n\t\t *\r\n\t\t * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\r\n\t\t *\r\n\t\t * Solution:\r\n\t\t *\r\n\t\t * We assume the radius of the polygon is half the size of the canvas at first\r\n\t\t * at each index we check if the text overlaps.\r\n\t\t *\r\n\t\t * Where it does, we store that angle and that index.\r\n\t\t *\r\n\t\t * After finding the largest index and angle we calculate how much we need to remove\r\n\t\t * from the shape radius to move the point inwards by that x.\r\n\t\t *\r\n\t\t * We average the left and right distances to get the maximum shape radius that can fit in the box\r\n\t\t * along with labels.\r\n\t\t *\r\n\t\t * Once we have that, we can find the centre point for the chart, by taking the x text protrusion\r\n\t\t * on each side, removing that from the size, halving it and adding the left x protrusion width.\r\n\t\t *\r\n\t\t * This will mean we have a shape fitted to the canvas, as large as it can be with the labels\r\n\t\t * and position it in the most space efficient manner\r\n\t\t *\r\n\t\t * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\r\n\t\t */\r\n\r\n\t\tvar plFont = helpers.options._parseFont(scale.options.pointLabels);\r\n\r\n\t\t// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\r\n\t\t// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\r\n\t\tvar furthestLimits = {\r\n\t\t\tl: 0,\r\n\t\t\tr: scale.width,\r\n\t\t\tt: 0,\r\n\t\t\tb: scale.height\r\n\t\t};\r\n\t\tvar furthestAngles = {};\r\n\t\tvar i, textSize, pointPosition;\r\n\r\n\t\tscale.ctx.font = plFont.string;\r\n\t\tscale._pointLabelSizes = [];\r\n\r\n\t\tvar valueCount = getValueCount(scale);\r\n\t\tfor (i = 0; i < valueCount; i++) {\r\n\t\t\tpointPosition = scale.getPointPosition(i, scale.drawingArea + 5);\r\n\t\t\ttextSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale.pointLabels[i] || '');\r\n\t\t\tscale._pointLabelSizes[i] = textSize;\r\n\r\n\t\t\t// Add quarter circle to make degree 0 mean top of circle\r\n\t\t\tvar angleRadians = scale.getIndexAngle(i);\r\n\t\t\tvar angle = helpers.toDegrees(angleRadians) % 360;\r\n\t\t\tvar hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\r\n\t\t\tvar vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\r\n\r\n\t\t\tif (hLimits.start < furthestLimits.l) {\r\n\t\t\t\tfurthestLimits.l = hLimits.start;\r\n\t\t\t\tfurthestAngles.l = angleRadians;\r\n\t\t\t}\r\n\r\n\t\t\tif (hLimits.end > furthestLimits.r) {\r\n\t\t\t\tfurthestLimits.r = hLimits.end;\r\n\t\t\t\tfurthestAngles.r = angleRadians;\r\n\t\t\t}\r\n\r\n\t\t\tif (vLimits.start < furthestLimits.t) {\r\n\t\t\t\tfurthestLimits.t = vLimits.start;\r\n\t\t\t\tfurthestAngles.t = angleRadians;\r\n\t\t\t}\r\n\r\n\t\t\tif (vLimits.end > furthestLimits.b) {\r\n\t\t\t\tfurthestLimits.b = vLimits.end;\r\n\t\t\t\tfurthestAngles.b = angleRadians;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tscale.setReductions(scale.drawingArea, furthestLimits, furthestAngles);\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"module.exports.determineLimits","start_line":88,"end_line":105,"comment":[],"params":["angle","pos","size","min","max"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"determineLimits","line":165,"func_location":"module.exports.fitWithPointLabels","func_start_line":110,"func_end_line":189,"args":["angle","pointPosition.y","textSize.h",{"type":"number"},{"type":"number"}],"comment":["*\r\n\t * Helper function to fit a radial linear scale with point labels\r\n\t "],"code":"\tfunction fitWithPointLabels(scale) {\r\n\t\t/*\r\n\t\t * Right, this is really confusing and there is a lot of maths going on here\r\n\t\t * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\r\n\t\t *\r\n\t\t * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\r\n\t\t *\r\n\t\t * Solution:\r\n\t\t *\r\n\t\t * We assume the radius of the polygon is half the size of the canvas at first\r\n\t\t * at each index we check if the text overlaps.\r\n\t\t *\r\n\t\t * Where it does, we store that angle and that index.\r\n\t\t *\r\n\t\t * After finding the largest index and angle we calculate how much we need to remove\r\n\t\t * from the shape radius to move the point inwards by that x.\r\n\t\t *\r\n\t\t * We average the left and right distances to get the maximum shape radius that can fit in the box\r\n\t\t * along with labels.\r\n\t\t *\r\n\t\t * Once we have that, we can find the centre point for the chart, by taking the x text protrusion\r\n\t\t * on each side, removing that from the size, halving it and adding the left x protrusion width.\r\n\t\t *\r\n\t\t * This will mean we have a shape fitted to the canvas, as large as it can be with the labels\r\n\t\t * and position it in the most space efficient manner\r\n\t\t *\r\n\t\t * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\r\n\t\t */\r\n\r\n\t\tvar plFont = helpers.options._parseFont(scale.options.pointLabels);\r\n\r\n\t\t// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\r\n\t\t// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\r\n\t\tvar furthestLimits = {\r\n\t\t\tl: 0,\r\n\t\t\tr: scale.width,\r\n\t\t\tt: 0,\r\n\t\t\tb: scale.height\r\n\t\t};\r\n\t\tvar furthestAngles = {};\r\n\t\tvar i, textSize, pointPosition;\r\n\r\n\t\tscale.ctx.font = plFont.string;\r\n\t\tscale._pointLabelSizes = [];\r\n\r\n\t\tvar valueCount = getValueCount(scale);\r\n\t\tfor (i = 0; i < valueCount; i++) {\r\n\t\t\tpointPosition = scale.getPointPosition(i, scale.drawingArea + 5);\r\n\t\t\ttextSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale.pointLabels[i] || '');\r\n\t\t\tscale._pointLabelSizes[i] = textSize;\r\n\r\n\t\t\t// Add quarter circle to make degree 0 mean top of circle\r\n\t\t\tvar angleRadians = scale.getIndexAngle(i);\r\n\t\t\tvar angle = helpers.toDegrees(angleRadians) % 360;\r\n\t\t\tvar hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\r\n\t\t\tvar vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\r\n\r\n\t\t\tif (hLimits.start < furthestLimits.l) {\r\n\t\t\t\tfurthestLimits.l = hLimits.start;\r\n\t\t\t\tfurthestAngles.l = angleRadians;\r\n\t\t\t}\r\n\r\n\t\t\tif (hLimits.end > furthestLimits.r) {\r\n\t\t\t\tfurthestLimits.r = hLimits.end;\r\n\t\t\t\tfurthestAngles.r = angleRadians;\r\n\t\t\t}\r\n\r\n\t\t\tif (vLimits.start < furthestLimits.t) {\r\n\t\t\t\tfurthestLimits.t = vLimits.start;\r\n\t\t\t\tfurthestAngles.t = angleRadians;\r\n\t\t\t}\r\n\r\n\t\t\tif (vLimits.end > furthestLimits.b) {\r\n\t\t\t\tfurthestLimits.b = vLimits.end;\r\n\t\t\t\tfurthestAngles.b = angleRadians;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tscale.setReductions(scale.drawingArea, furthestLimits, furthestAngles);\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"module.exports.determineLimits","start_line":88,"end_line":105,"comment":[],"params":["angle","pos","size","min","max"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"createEvent","line":148,"func_location":"fromNativeEvent","func_start_line":145,"func_end_line":149,"args":["type","chart","pos.x","pos.y","event"],"code":"function fromNativeEvent(event, chart) {\r\n\tvar type = EVENT_TYPES[event.type] || event.type;\r\n\tvar pos = helpers.getRelativePosition(event, chart);\r\n\treturn createEvent(type, chart, pos.x, pos.y, event);\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"createEvent","start_line":135,"end_line":143,"comment":[],"params":["type","chart","x","y","nativeEvent"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"determineUnitForAutoTicks","line":309,"func_location":"generate","func_start_line":307,"func_end_line":356,"args":["timeOpts.minUnit","min","max","capacity"],"comment":["*\r\n * Generates a maximum of `capacity` timestamps between min and max, rounded to the\r\n * `minor` unit, aligned on the `major` unit and using the given scale time `options`.\r\n * Important: this method can return ticks outside the min and max range, it's the\r\n * responsibility of the calling code to clamp values if needed.\r\n "],"code":"function generate(min, max, capacity, options) {\r\n\tvar timeOpts = options.time;\r\n\tvar minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);\r\n\tvar major = determineMajorUnit(minor);\r\n\tvar stepSize = helpers.valueOrDefault(timeOpts.stepSize, timeOpts.unitStepSize);\r\n\tvar weekday = minor === 'week' ? timeOpts.isoWeekday : false;\r\n\tvar majorTicksEnabled = options.ticks.major.enabled;\r\n\tvar interval = INTERVALS[minor];\r\n\tvar first = moment(min);\r\n\tvar last = moment(max);\r\n\tvar ticks = [];\r\n\tvar time;\r\n\r\n\tif (!stepSize) {\r\n\t\tstepSize = determineStepSize(min, max, minor, capacity);\r\n\t}\r\n\r\n\t// For 'week' unit, handle the first day of week option\r\n\tif (weekday) {\r\n\t\tfirst = first.isoWeekday(weekday);\r\n\t\tlast = last.isoWeekday(weekday);\r\n\t}\r\n\r\n\t// Align first/last ticks on unit\r\n\tfirst = first.startOf(weekday ? 'day' : minor);\r\n\tlast = last.startOf(weekday ? 'day' : minor);\r\n\r\n\t// Make sure that the last tick include max\r\n\tif (last < max) {\r\n\t\tlast.add(1, minor);\r\n\t}\r\n\r\n\ttime = moment(first);\r\n\r\n\tif (majorTicksEnabled && major && !weekday && !timeOpts.round) {\r\n\t\t// Align the first tick on the previous `minor` unit aligned on the `major` unit:\r\n\t\t// we first aligned time on the previous `major` unit then add the number of full\r\n\t\t// stepSize there is between first and the previous major time.\r\n\t\ttime.startOf(major);\r\n\t\ttime.add(~~((first - time) / (interval.size * stepSize)) * stepSize, minor);\r\n\t}\r\n\r\n\tfor (; time < last; time.add(stepSize, minor)) {\r\n\t\tticks.push(+time);\r\n\t}\r\n\r\n\tticks.push(+time);\r\n\r\n\treturn ticks;\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"determineUnitForAutoTicks","start_line":259,"end_line":273,"comment":["*\r\n * Figures out what unit results in an appropriate number of auto-generated ticks\r\n "],"params":["minUnit","min","max","capacity"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"determineMajorUnit","line":310,"func_location":"generate","func_start_line":307,"func_end_line":356,"args":["minor"],"comment":["*\r\n * Generates a maximum of `capacity` timestamps between min and max, rounded to the\r\n * `minor` unit, aligned on the `major` unit and using the given scale time `options`.\r\n * Important: this method can return ticks outside the min and max range, it's the\r\n * responsibility of the calling code to clamp values if needed.\r\n "],"code":"function generate(min, max, capacity, options) {\r\n\tvar timeOpts = options.time;\r\n\tvar minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);\r\n\tvar major = determineMajorUnit(minor);\r\n\tvar stepSize = helpers.valueOrDefault(timeOpts.stepSize, timeOpts.unitStepSize);\r\n\tvar weekday = minor === 'week' ? timeOpts.isoWeekday : false;\r\n\tvar majorTicksEnabled = options.ticks.major.enabled;\r\n\tvar interval = INTERVALS[minor];\r\n\tvar first = moment(min);\r\n\tvar last = moment(max);\r\n\tvar ticks = [];\r\n\tvar time;\r\n\r\n\tif (!stepSize) {\r\n\t\tstepSize = determineStepSize(min, max, minor, capacity);\r\n\t}\r\n\r\n\t// For 'week' unit, handle the first day of week option\r\n\tif (weekday) {\r\n\t\tfirst = first.isoWeekday(weekday);\r\n\t\tlast = last.isoWeekday(weekday);\r\n\t}\r\n\r\n\t// Align first/last ticks on unit\r\n\tfirst = first.startOf(weekday ? 'day' : minor);\r\n\tlast = last.startOf(weekday ? 'day' : minor);\r\n\r\n\t// Make sure that the last tick include max\r\n\tif (last < max) {\r\n\t\tlast.add(1, minor);\r\n\t}\r\n\r\n\ttime = moment(first);\r\n\r\n\tif (majorTicksEnabled && major && !weekday && !timeOpts.round) {\r\n\t\t// Align the first tick on the previous `minor` unit aligned on the `major` unit:\r\n\t\t// we first aligned time on the previous `major` unit then add the number of full\r\n\t\t// stepSize there is between first and the previous major time.\r\n\t\ttime.startOf(major);\r\n\t\ttime.add(~~((first - time) / (interval.size * stepSize)) * stepSize, minor);\r\n\t}\r\n\r\n\tfor (; time < last; time.add(stepSize, minor)) {\r\n\t\tticks.push(+time);\r\n\t}\r\n\r\n\tticks.push(+time);\r\n\r\n\treturn ticks;\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"determineMajorUnit","start_line":293,"end_line":299,"comment":[],"params":["unit"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"determineStepSize","line":321,"func_location":"generate","func_start_line":307,"func_end_line":356,"args":["min","max","minor","capacity"],"comment":["*\r\n * Generates a maximum of `capacity` timestamps between min and max, rounded to the\r\n * `minor` unit, aligned on the `major` unit and using the given scale time `options`.\r\n * Important: this method can return ticks outside the min and max range, it's the\r\n * responsibility of the calling code to clamp values if needed.\r\n "],"code":"function generate(min, max, capacity, options) {\r\n\tvar timeOpts = options.time;\r\n\tvar minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);\r\n\tvar major = determineMajorUnit(minor);\r\n\tvar stepSize = helpers.valueOrDefault(timeOpts.stepSize, timeOpts.unitStepSize);\r\n\tvar weekday = minor === 'week' ? timeOpts.isoWeekday : false;\r\n\tvar majorTicksEnabled = options.ticks.major.enabled;\r\n\tvar interval = INTERVALS[minor];\r\n\tvar first = moment(min);\r\n\tvar last = moment(max);\r\n\tvar ticks = [];\r\n\tvar time;\r\n\r\n\tif (!stepSize) {\r\n\t\tstepSize = determineStepSize(min, max, minor, capacity);\r\n\t}\r\n\r\n\t// For 'week' unit, handle the first day of week option\r\n\tif (weekday) {\r\n\t\tfirst = first.isoWeekday(weekday);\r\n\t\tlast = last.isoWeekday(weekday);\r\n\t}\r\n\r\n\t// Align first/last ticks on unit\r\n\tfirst = first.startOf(weekday ? 'day' : minor);\r\n\tlast = last.startOf(weekday ? 'day' : minor);\r\n\r\n\t// Make sure that the last tick include max\r\n\tif (last < max) {\r\n\t\tlast.add(1, minor);\r\n\t}\r\n\r\n\ttime = moment(first);\r\n\r\n\tif (majorTicksEnabled && major && !weekday && !timeOpts.round) {\r\n\t\t// Align the first tick on the previous `minor` unit aligned on the `major` unit:\r\n\t\t// we first aligned time on the previous `major` unit then add the number of full\r\n\t\t// stepSize there is between first and the previous major time.\r\n\t\ttime.startOf(major);\r\n\t\ttime.add(~~((first - time) / (interval.size * stepSize)) * stepSize, minor);\r\n\t}\r\n\r\n\tfor (; time < last; time.add(stepSize, minor)) {\r\n\t\tticks.push(+time);\r\n\t}\r\n\r\n\tticks.push(+time);\r\n\r\n\treturn ticks;\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"determineStepSize","start_line":235,"end_line":254,"comment":["*\r\n * Returns the number of unit to skip to be able to display up to `capacity` number of ticks\r\n * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.\r\n "],"params":["min","max","unit","capacity"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"getBeforeAfterBodyLines","line":527,"func_location":"exports.getAfterBody","func_start_line":526,"func_end_line":528,"args":[null],"comment":[" Args are: (tooltipItem, data)"],"code":"\tgetAfterBody: function() {\r\n\t\treturn getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"getBeforeAfterBodyLines","start_line":469,"end_line":471,"comment":["*\r\n * Helper to build before and after body lines\r\n "],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/elements/element.rectangle.js","name":"isVertical","line":33,"func_location":"getBarBounds","func_start_line":29,"func_end_line":55,"args":["bar"],"comment":["*\r\n * Helper function to get the bounds of the bar regardless of the orientation\r\n * @param bar {Chart.Element.Rectangle} the bar\r\n * @return {Bounds} bounds of the bar\r\n * @private\r\n "],"code":"function getBarBounds(bar) {\r\n\tvar vm = bar._view;\r\n\tvar x1, x2, y1, y2;\r\n\r\n\tif (isVertical(bar)) {\r\n\t\t// vertical\r\n\t\tvar halfWidth = vm.width / 2;\r\n\t\tx1 = vm.x - halfWidth;\r\n\t\tx2 = vm.x + halfWidth;\r\n\t\ty1 = Math.min(vm.y, vm.base);\r\n\t\ty2 = Math.max(vm.y, vm.base);\r\n\t} else {\r\n\t\t// horizontal bar\r\n\t\tvar halfHeight = vm.height / 2;\r\n\t\tx1 = Math.min(vm.x, vm.base);\r\n\t\tx2 = Math.max(vm.x, vm.base);\r\n\t\ty1 = vm.y - halfHeight;\r\n\t\ty2 = vm.y + halfHeight;\r\n\t}\r\n\r\n\treturn {\r\n\t\tleft: x1,\r\n\t\ttop: y1,\r\n\t\tright: x2,\r\n\t\tbottom: y2\r\n\t};\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/elements/element.rectangle.js","name":"isVertical","start_line":19,"end_line":21,"comment":[],"params":["bar"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"pushOrConcat","line":470,"func_location":"getBeforeAfterBodyLines","func_start_line":469,"func_end_line":471,"args":[null,null],"comment":["*\r\n * Helper to build before and after body lines\r\n "],"code":"function getBeforeAfterBodyLines(callback) {\r\n\treturn pushOrConcat([], splitNewlines(callback));\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"pushOrConcat","start_line":172,"end_line":183,"comment":[" Helper to push or concat based on if the 2nd parameter is an array or not"],"params":["base","toPush"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"splitNewlines","line":470,"func_location":"getBeforeAfterBodyLines","func_start_line":469,"func_end_line":471,"args":[null,null],"comment":["*\r\n * Helper to build before and after body lines\r\n "],"code":"function getBeforeAfterBodyLines(callback) {\r\n\treturn pushOrConcat([], splitNewlines(callback));\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"splitNewlines","start_line":191,"end_line":196,"comment":["*\r\n * Returns array of strings split by newline\r\n * @param {String} value - The value to split by newline.\r\n * @returns {Array} value if newline present - Returned from String split() method\r\n * @function\r\n "],"params":["str"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"getBeforeAfterBodyLines","line":500,"func_location":"exports.getBeforeBody","func_start_line":499,"func_end_line":501,"args":[null],"comment":[" Args are: (tooltipItem, data)"],"code":"\tgetBeforeBody: function() {\r\n\t\treturn getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"getBeforeAfterBodyLines","start_line":469,"end_line":471,"comment":["*\r\n * Helper to build before and after body lines\r\n "],"params":["callback"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/elements/element.rectangle.js","name":"isVertical","line":196,"func_location":"getCenterPoint","func_start_line":193,"func_end_line":205,"args":[null],"code":"\tgetCenterPoint: function() {\r\n\t\tvar vm = this._view;\r\n\t\tvar x, y;\r\n\t\tif (isVertical(this)) {\r\n\t\t\tx = vm.x;\r\n\t\t\ty = (vm.y + vm.base) / 2;\r\n\t\t} else {\r\n\t\t\tx = (vm.x + vm.base) / 2;\r\n\t\t\ty = vm.y;\r\n\t\t}\r\n\r\n\t\treturn {x: x, y: y};\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/elements/element.rectangle.js","name":"isVertical","start_line":19,"end_line":21,"comment":[],"params":["bar"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.helpers.js","name":"isConstrainedValue","line":498,"func_location":"module.exports.getConstraintDimension","func_start_line":493,"func_end_line":509,"args":["constrainedNode"],"comment":[" Private helper to get a constraint dimension"," @param domNode : the node to check the constraint on"," @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)"," @param percentageProperty : property of parent to use when calculating width as a percentage"," @see https://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser"],"code":"\tfunction getConstraintDimension(domNode, maxStyle, percentageProperty) {\r\n\t\tvar view = document.defaultView;\r\n\t\tvar parentNode = helpers._getParentNode(domNode);\r\n\t\tvar constrainedNode = view.getComputedStyle(domNode)[maxStyle];\r\n\t\tvar constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];\r\n\t\tvar hasCNode = isConstrainedValue(constrainedNode);\r\n\t\tvar hasCContainer = isConstrainedValue(constrainedContainer);\r\n\t\tvar infinity = Number.POSITIVE_INFINITY;\r\n\r\n\t\tif (hasCNode || hasCContainer) {\r\n\t\t\treturn Math.min(\r\n\t\t\t\thasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,\r\n\t\t\t\thasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);\r\n\t\t}\r\n\r\n\t\treturn 'none';\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.helpers.js","name":"module.exports.isConstrainedValue","start_line":484,"end_line":486,"comment":["*\r\n\t * Returns if the given value contains an effective constraint.\r\n\t * @private\r\n\t "],"params":["value"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.helpers.js","name":"isConstrainedValue","line":499,"func_location":"module.exports.getConstraintDimension","func_start_line":493,"func_end_line":509,"args":["constrainedContainer"],"comment":[" Private helper to get a constraint dimension"," @param domNode : the node to check the constraint on"," @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)"," @param percentageProperty : property of parent to use when calculating width as a percentage"," @see https://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser"],"code":"\tfunction getConstraintDimension(domNode, maxStyle, percentageProperty) {\r\n\t\tvar view = document.defaultView;\r\n\t\tvar parentNode = helpers._getParentNode(domNode);\r\n\t\tvar constrainedNode = view.getComputedStyle(domNode)[maxStyle];\r\n\t\tvar constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];\r\n\t\tvar hasCNode = isConstrainedValue(constrainedNode);\r\n\t\tvar hasCContainer = isConstrainedValue(constrainedContainer);\r\n\t\tvar infinity = Number.POSITIVE_INFINITY;\r\n\r\n\t\tif (hasCNode || hasCContainer) {\r\n\t\t\treturn Math.min(\r\n\t\t\t\thasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,\r\n\t\t\t\thasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);\r\n\t\t}\r\n\r\n\t\treturn 'none';\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.helpers.js","name":"module.exports.isConstrainedValue","start_line":484,"end_line":486,"comment":["*\r\n\t * Returns if the given value contains an effective constraint.\r\n\t * @private\r\n\t "],"params":["value"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.helpers.js","name":"parseMaxStyle","line":504,"func_location":"module.exports.getConstraintDimension","func_start_line":493,"func_end_line":509,"args":["constrainedNode","domNode","percentageProperty"],"comment":[" Private helper to get a constraint dimension"," @param domNode : the node to check the constraint on"," @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)"," @param percentageProperty : property of parent to use when calculating width as a percentage"," @see https://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser"],"code":"\tfunction getConstraintDimension(domNode, maxStyle, percentageProperty) {\r\n\t\tvar view = document.defaultView;\r\n\t\tvar parentNode = helpers._getParentNode(domNode);\r\n\t\tvar constrainedNode = view.getComputedStyle(domNode)[maxStyle];\r\n\t\tvar constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];\r\n\t\tvar hasCNode = isConstrainedValue(constrainedNode);\r\n\t\tvar hasCContainer = isConstrainedValue(constrainedContainer);\r\n\t\tvar infinity = Number.POSITIVE_INFINITY;\r\n\r\n\t\tif (hasCNode || hasCContainer) {\r\n\t\t\treturn Math.min(\r\n\t\t\t\thasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,\r\n\t\t\t\thasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);\r\n\t\t}\r\n\r\n\t\treturn 'none';\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.helpers.js","name":"module.exports.parseMaxStyle","start_line":464,"end_line":478,"comment":[" Private helper function to convert max-width/max-height values that may be percentages into a number"],"params":["styleValue","node","parentProperty"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.helpers.js","name":"parseMaxStyle","line":505,"func_location":"module.exports.getConstraintDimension","func_start_line":493,"func_end_line":509,"args":["constrainedContainer","parentNode","percentageProperty"],"comment":[" Private helper to get a constraint dimension"," @param domNode : the node to check the constraint on"," @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)"," @param percentageProperty : property of parent to use when calculating width as a percentage"," @see https://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser"],"code":"\tfunction getConstraintDimension(domNode, maxStyle, percentageProperty) {\r\n\t\tvar view = document.defaultView;\r\n\t\tvar parentNode = helpers._getParentNode(domNode);\r\n\t\tvar constrainedNode = view.getComputedStyle(domNode)[maxStyle];\r\n\t\tvar constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];\r\n\t\tvar hasCNode = isConstrainedValue(constrainedNode);\r\n\t\tvar hasCContainer = isConstrainedValue(constrainedContainer);\r\n\t\tvar infinity = Number.POSITIVE_INFINITY;\r\n\r\n\t\tif (hasCNode || hasCContainer) {\r\n\t\t\treturn Math.min(\r\n\t\t\t\thasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,\r\n\t\t\t\thasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);\r\n\t\t}\r\n\r\n\t\treturn 'none';\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.helpers.js","name":"module.exports.parseMaxStyle","start_line":464,"end_line":478,"comment":[" Private helper function to convert max-width/max-height values that may be percentages into a number"],"params":["styleValue","node","parentProperty"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.helpers.js","name":"getConstraintDimension","line":516,"func_location":"helpers.getConstraintHeight","func_start_line":515,"func_end_line":517,"args":["domNode",{"type":"string"},{"type":"string"}],"comment":[" returns Number or undefined if no constraint"],"code":"\thelpers.getConstraintHeight = function(domNode) {\r\n\t\treturn getConstraintDimension(domNode, 'max-height', 'clientHeight');\r\n\t};\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.helpers.js","name":"module.exports.getConstraintDimension","start_line":493,"end_line":509,"comment":[" Private helper to get a constraint dimension"," @param domNode : the node to check the constraint on"," @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)"," @param percentageProperty : property of parent to use when calculating width as a percentage"," @see https://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser"],"params":["domNode","maxStyle","percentageProperty"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.helpers.js","name":"getConstraintDimension","line":512,"func_location":"helpers.getConstraintWidth","func_start_line":511,"func_end_line":513,"args":["domNode",{"type":"string"},{"type":"string"}],"comment":[" returns Number or undefined if no constraint"],"code":"\thelpers.getConstraintWidth = function(domNode) {\r\n\t\treturn getConstraintDimension(domNode, 'max-width', 'clientWidth');\r\n\t};\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.helpers.js","name":"module.exports.getConstraintDimension","start_line":493,"end_line":509,"comment":[" Private helper to get a constraint dimension"," @param domNode : the node to check the constraint on"," @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)"," @param percentageProperty : property of parent to use when calculating width as a percentage"," @see https://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser"],"params":["domNode","maxStyle","percentageProperty"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"pushOrConcat","line":541,"func_location":"exports.getFooter","func_start_line":532,"func_end_line":546,"args":["lines",null],"comment":[" Get the footer and beforeFooter and afterFooter lines"," Args are: (tooltipItem, data)"],"code":"\tgetFooter: function() {\r\n\t\tvar me = this;\r\n\t\tvar callbacks = me._options.callbacks;\r\n\r\n\t\tvar beforeFooter = callbacks.beforeFooter.apply(me, arguments);\r\n\t\tvar footer = callbacks.footer.apply(me, arguments);\r\n\t\tvar afterFooter = callbacks.afterFooter.apply(me, arguments);\r\n\r\n\t\tvar lines = [];\r\n\t\tlines = pushOrConcat(lines, splitNewlines(beforeFooter));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(footer));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(afterFooter));\r\n\r\n\t\treturn lines;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"pushOrConcat","start_line":172,"end_line":183,"comment":[" Helper to push or concat based on if the 2nd parameter is an array or not"],"params":["base","toPush"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"splitNewlines","line":541,"func_location":"exports.getFooter","func_start_line":532,"func_end_line":546,"args":["lines",null],"comment":[" Get the footer and beforeFooter and afterFooter lines"," Args are: (tooltipItem, data)"],"code":"\tgetFooter: function() {\r\n\t\tvar me = this;\r\n\t\tvar callbacks = me._options.callbacks;\r\n\r\n\t\tvar beforeFooter = callbacks.beforeFooter.apply(me, arguments);\r\n\t\tvar footer = callbacks.footer.apply(me, arguments);\r\n\t\tvar afterFooter = callbacks.afterFooter.apply(me, arguments);\r\n\r\n\t\tvar lines = [];\r\n\t\tlines = pushOrConcat(lines, splitNewlines(beforeFooter));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(footer));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(afterFooter));\r\n\r\n\t\treturn lines;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"splitNewlines","start_line":191,"end_line":196,"comment":["*\r\n * Returns array of strings split by newline\r\n * @param {String} value - The value to split by newline.\r\n * @returns {Array} value if newline present - Returned from String split() method\r\n * @function\r\n "],"params":["str"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"pushOrConcat","line":542,"func_location":"exports.getFooter","func_start_line":532,"func_end_line":546,"args":["lines",null],"comment":[" Get the footer and beforeFooter and afterFooter lines"," Args are: (tooltipItem, data)"],"code":"\tgetFooter: function() {\r\n\t\tvar me = this;\r\n\t\tvar callbacks = me._options.callbacks;\r\n\r\n\t\tvar beforeFooter = callbacks.beforeFooter.apply(me, arguments);\r\n\t\tvar footer = callbacks.footer.apply(me, arguments);\r\n\t\tvar afterFooter = callbacks.afterFooter.apply(me, arguments);\r\n\r\n\t\tvar lines = [];\r\n\t\tlines = pushOrConcat(lines, splitNewlines(beforeFooter));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(footer));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(afterFooter));\r\n\r\n\t\treturn lines;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"pushOrConcat","start_line":172,"end_line":183,"comment":[" Helper to push or concat based on if the 2nd parameter is an array or not"],"params":["base","toPush"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"splitNewlines","line":542,"func_location":"exports.getFooter","func_start_line":532,"func_end_line":546,"args":["lines",null],"comment":[" Get the footer and beforeFooter and afterFooter lines"," Args are: (tooltipItem, data)"],"code":"\tgetFooter: function() {\r\n\t\tvar me = this;\r\n\t\tvar callbacks = me._options.callbacks;\r\n\r\n\t\tvar beforeFooter = callbacks.beforeFooter.apply(me, arguments);\r\n\t\tvar footer = callbacks.footer.apply(me, arguments);\r\n\t\tvar afterFooter = callbacks.afterFooter.apply(me, arguments);\r\n\r\n\t\tvar lines = [];\r\n\t\tlines = pushOrConcat(lines, splitNewlines(beforeFooter));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(footer));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(afterFooter));\r\n\r\n\t\treturn lines;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"splitNewlines","start_line":191,"end_line":196,"comment":["*\r\n * Returns array of strings split by newline\r\n * @param {String} value - The value to split by newline.\r\n * @returns {Array} value if newline present - Returned from String split() method\r\n * @function\r\n "],"params":["str"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"pushOrConcat","line":543,"func_location":"exports.getFooter","func_start_line":532,"func_end_line":546,"args":["lines",null],"comment":[" Get the footer and beforeFooter and afterFooter lines"," Args are: (tooltipItem, data)"],"code":"\tgetFooter: function() {\r\n\t\tvar me = this;\r\n\t\tvar callbacks = me._options.callbacks;\r\n\r\n\t\tvar beforeFooter = callbacks.beforeFooter.apply(me, arguments);\r\n\t\tvar footer = callbacks.footer.apply(me, arguments);\r\n\t\tvar afterFooter = callbacks.afterFooter.apply(me, arguments);\r\n\r\n\t\tvar lines = [];\r\n\t\tlines = pushOrConcat(lines, splitNewlines(beforeFooter));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(footer));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(afterFooter));\r\n\r\n\t\treturn lines;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"pushOrConcat","start_line":172,"end_line":183,"comment":[" Helper to push or concat based on if the 2nd parameter is an array or not"],"params":["base","toPush"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"splitNewlines","line":543,"func_location":"exports.getFooter","func_start_line":532,"func_end_line":546,"args":["lines",null],"comment":[" Get the footer and beforeFooter and afterFooter lines"," Args are: (tooltipItem, data)"],"code":"\tgetFooter: function() {\r\n\t\tvar me = this;\r\n\t\tvar callbacks = me._options.callbacks;\r\n\r\n\t\tvar beforeFooter = callbacks.beforeFooter.apply(me, arguments);\r\n\t\tvar footer = callbacks.footer.apply(me, arguments);\r\n\t\tvar afterFooter = callbacks.afterFooter.apply(me, arguments);\r\n\r\n\t\tvar lines = [];\r\n\t\tlines = pushOrConcat(lines, splitNewlines(beforeFooter));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(footer));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(afterFooter));\r\n\r\n\t\treturn lines;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"splitNewlines","start_line":191,"end_line":196,"comment":["*\r\n * Returns array of strings split by newline\r\n * @param {String} value - The value to split by newline.\r\n * @returns {Array} value if newline present - Returned from String split() method\r\n * @function\r\n "],"params":["str"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"getValueCount","line":420,"func_location":"module.exports.LinearRadialScale.getIndexAngle","func_start_line":419,"func_end_line":429,"args":[null],"code":"\t\tgetIndexAngle: function(index) {\r\n\t\t\tvar angleMultiplier = (Math.PI * 2) / getValueCount(this);\r\n\t\t\tvar startAngle = this.chart.options && this.chart.options.startAngle ?\r\n\t\t\t\tthis.chart.options.startAngle :\r\n\t\t\t\t0;\r\n\r\n\t\t\tvar startAngleRadians = startAngle * Math.PI * 2 / 360;\r\n\r\n\t\t\t// Start from the top instead of right, so remove a quarter of the circle\r\n\t\t\treturn index * angleMultiplier + startAngleRadians;\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"module.exports.getValueCount","start_line":60,"end_line":63,"comment":[],"params":["scale"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"parseVisibleItems","line":55,"func_location":"getIntersectItems","func_start_line":52,"func_end_line":62},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"parseVisibleItems","start_line":27,"end_line":44,"comment":["*\r\n * Helper function to traverse all of the visible elements in the chart\r\n * @param chart {chart} the chart\r\n * @param handler {Function} the callback to execute for each visible item\r\n "],"params":["chart","handler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"momentify","line":666,"func_location":"module.exports.TimeScale.getLabelForIndex","func_start_line":655,"func_end_line":673,"args":["timeOpts.tooltipFormat"],"code":"\t\tgetLabelForIndex: function(index, datasetIndex) {\r\n\t\t\tvar me = this;\r\n\t\t\tvar data = me.chart.data;\r\n\t\t\tvar timeOpts = me.options.time;\r\n\t\t\tvar label = data.labels && index < data.labels.length ? data.labels[index] : '';\r\n\t\t\tvar value = data.datasets[datasetIndex].data[index];\r\n\r\n\t\t\tif (helpers.isObject(value)) {\r\n\t\t\t\tlabel = me.getRightValue(value);\r\n\t\t\t}\r\n\t\t\tif (timeOpts.tooltipFormat) {\r\n\t\t\t\treturn momentify(label, timeOpts).format(timeOpts.tooltipFormat);\r\n\t\t\t}\r\n\t\t\tif (typeof label === 'string') {\r\n\t\t\t\treturn label;\r\n\t\t\t}\r\n\r\n\t\t\treturn momentify(label, timeOpts).format(me._labelFormat);\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"momentify","start_line":184,"end_line":211,"comment":["*\r\n * Convert the given value to a moment object using the given time options.\r\n * @see https://momentjs.com/docs/#/parsing/\r\n "],"params":["value","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"momentify","line":672,"func_location":"module.exports.TimeScale.getLabelForIndex","func_start_line":655,"func_end_line":673,"args":["me._labelFormat"],"code":"\t\tgetLabelForIndex: function(index, datasetIndex) {\r\n\t\t\tvar me = this;\r\n\t\t\tvar data = me.chart.data;\r\n\t\t\tvar timeOpts = me.options.time;\r\n\t\t\tvar label = data.labels && index < data.labels.length ? data.labels[index] : '';\r\n\t\t\tvar value = data.datasets[datasetIndex].data[index];\r\n\r\n\t\t\tif (helpers.isObject(value)) {\r\n\t\t\t\tlabel = me.getRightValue(value);\r\n\t\t\t}\r\n\t\t\tif (timeOpts.tooltipFormat) {\r\n\t\t\t\treturn momentify(label, timeOpts).format(timeOpts.tooltipFormat);\r\n\t\t\t}\r\n\t\t\tif (typeof label === 'string') {\r\n\t\t\t\treturn label;\r\n\t\t\t}\r\n\r\n\t\t\treturn momentify(label, timeOpts).format(me._labelFormat);\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"momentify","start_line":184,"end_line":211,"comment":["*\r\n * Convert the given value to a moment object using the given time options.\r\n * @see https://momentjs.com/docs/#/parsing/\r\n "],"params":["value","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"parseVisibleItems","line":76,"func_location":"getNearestItems","func_start_line":72,"func_end_line":94},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"parseVisibleItems","start_line":27,"end_line":44,"comment":["*\r\n * Helper function to traverse all of the visible elements in the chart\r\n * @param chart {chart} the chart\r\n * @param handler {Function} the callback to execute for each visible item\r\n "],"params":["chart","handler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"interpolate","line":716,"func_location":"module.exports.TimeScale.getPixelForOffset","func_start_line":711,"func_end_line":720,"args":["me._table",{"type":"string"},"time",{"type":"string"}],"comment":["*\r\n\t\t * @private\r\n\t\t "],"code":"\t\tgetPixelForOffset: function(time) {\r\n\t\t\tvar me = this;\r\n\t\t\tvar isReverse = me.options.ticks.reverse;\r\n\t\t\tvar size = me._horizontal ? me.width : me.height;\r\n\t\t\tvar start = me._horizontal ? isReverse ? me.right : me.left : isReverse ? me.bottom : me.top;\r\n\t\t\tvar pos = interpolate(me._table, 'time', time, 'pos');\r\n\t\t\tvar offset = size * (me._offsets.start + pos) / (me._offsets.start + 1 + me._offsets.end);\r\n\r\n\t\t\treturn isReverse ? start - offset : start + offset;\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"interpolate","start_line":166,"end_line":178,"comment":["*\r\n * Linearly interpolates the given source `value` using the table items `skey` values and\r\n * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')\r\n * returns the position for a timestamp equal to 42. If value is out of bounds, values at\r\n * index [0, 1] or [n - 1, n] are used for the interpolation.\r\n "],"params":["table","skey","sval","tkey"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"parse","line":731,"func_location":"module.exports.TimeScale.getPixelForValue","func_start_line":722,"func_end_line":737,"args":["value","me"],"code":"\t\tgetPixelForValue: function(value, index, datasetIndex) {\r\n\t\t\tvar me = this;\r\n\t\t\tvar time = null;\r\n\r\n\t\t\tif (index !== undefined && datasetIndex !== undefined) {\r\n\t\t\t\ttime = me._timestamps.datasets[datasetIndex][index];\r\n\t\t\t}\r\n\r\n\t\t\tif (time === null) {\r\n\t\t\t\ttime = parse(value, me);\r\n\t\t\t}\r\n\r\n\t\t\tif (time !== null) {\r\n\t\t\t\treturn me.getPixelForOffset(time);\r\n\t\t\t}\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"parse","start_line":213,"end_line":229,"comment":[],"params":["input","scale"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.linearbase.js","name":"getRightValue","line":80,"func_location":"getRightValue","func_start_line":76,"func_end_line":81,"args":[null,"value"],"code":"\t\tgetRightValue: function(value) {\r\n\t\t\tif (typeof value === 'string') {\r\n\t\t\t\treturn +value;\r\n\t\t\t}\r\n\t\t\treturn Scale.prototype.getRightValue.call(this, value);\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.linearbase.js","name":"getRightValue","start_line":76,"end_line":81,"comment":[],"params":["value"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.bar.js","name":"computeMinSampleSize","line":290,"func_location":"getRuler","func_start_line":274,"func_end_line":301,"args":["scale","pixels"],"comment":["*\r\n\t * @private\r\n\t "],"code":"\tgetRuler: function() {\r\n\t\tvar me = this;\r\n\t\tvar scale = me.getIndexScale();\r\n\t\tvar stackCount = me.getStackCount();\r\n\t\tvar datasetIndex = me.index;\r\n\t\tvar isHorizontal = scale.isHorizontal();\r\n\t\tvar start = isHorizontal ? scale.left : scale.top;\r\n\t\tvar end = start + (isHorizontal ? scale.width : scale.height);\r\n\t\tvar pixels = [];\r\n\t\tvar i, ilen, min;\r\n\r\n\t\tfor (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {\r\n\t\t\tpixels.push(scale.getPixelForValue(null, i, datasetIndex));\r\n\t\t}\r\n\r\n\t\tmin = helpers.isNullOrUndef(scale.options.barThickness)\r\n\t\t\t? computeMinSampleSize(scale, pixels)\r\n\t\t\t: -1;\r\n\r\n\t\treturn {\r\n\t\t\tmin: min,\r\n\t\t\tpixels: pixels,\r\n\t\t\tstart: start,\r\n\t\t\tend: end,\r\n\t\t\tstackCount: stackCount,\r\n\t\t\tscale: scale\r\n\t\t};\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.bar.js","name":"computeMinSampleSize","start_line":34,"end_line":50,"comment":["*\r\n * Computes the \"optimal\" sample size to maintain bars equally sized while preventing overlap.\r\n * @private\r\n "],"params":["scale","pixels"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"getTickBackdropHeight","line":363,"func_location":"module.exports.LinearRadialScale.getTickLimit","func_start_line":360,"func_end_line":365,"args":["opts"],"code":"\t\tgetTickLimit: function() {\r\n\t\t\tvar opts = this.options;\r\n\t\t\tvar tickOpts = opts.ticks;\r\n\t\t\tvar tickBackdropHeight = getTickBackdropHeight(opts);\r\n\t\t\treturn Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / tickBackdropHeight));\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"module.exports.getTickBackdropHeight","start_line":65,"end_line":72,"comment":[],"params":["opts"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"pushOrConcat","line":491,"func_location":"exports.getTitle","func_start_line":481,"func_end_line":496,"args":["lines",null],"comment":[" Get the title"," Args are: (tooltipItem, data)"],"code":"\tgetTitle: function() {\r\n\t\tvar me = this;\r\n\t\tvar opts = me._options;\r\n\t\tvar callbacks = opts.callbacks;\r\n\r\n\t\tvar beforeTitle = callbacks.beforeTitle.apply(me, arguments);\r\n\t\tvar title = callbacks.title.apply(me, arguments);\r\n\t\tvar afterTitle = callbacks.afterTitle.apply(me, arguments);\r\n\r\n\t\tvar lines = [];\r\n\t\tlines = pushOrConcat(lines, splitNewlines(beforeTitle));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(title));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(afterTitle));\r\n\r\n\t\treturn lines;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"pushOrConcat","start_line":172,"end_line":183,"comment":[" Helper to push or concat based on if the 2nd parameter is an array or not"],"params":["base","toPush"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"splitNewlines","line":491,"func_location":"exports.getTitle","func_start_line":481,"func_end_line":496,"args":["lines",null],"comment":[" Get the title"," Args are: (tooltipItem, data)"],"code":"\tgetTitle: function() {\r\n\t\tvar me = this;\r\n\t\tvar opts = me._options;\r\n\t\tvar callbacks = opts.callbacks;\r\n\r\n\t\tvar beforeTitle = callbacks.beforeTitle.apply(me, arguments);\r\n\t\tvar title = callbacks.title.apply(me, arguments);\r\n\t\tvar afterTitle = callbacks.afterTitle.apply(me, arguments);\r\n\r\n\t\tvar lines = [];\r\n\t\tlines = pushOrConcat(lines, splitNewlines(beforeTitle));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(title));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(afterTitle));\r\n\r\n\t\treturn lines;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"splitNewlines","start_line":191,"end_line":196,"comment":["*\r\n * Returns array of strings split by newline\r\n * @param {String} value - The value to split by newline.\r\n * @returns {Array} value if newline present - Returned from String split() method\r\n * @function\r\n "],"params":["str"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"pushOrConcat","line":492,"func_location":"exports.getTitle","func_start_line":481,"func_end_line":496,"args":["lines",null],"comment":[" Get the title"," Args are: (tooltipItem, data)"],"code":"\tgetTitle: function() {\r\n\t\tvar me = this;\r\n\t\tvar opts = me._options;\r\n\t\tvar callbacks = opts.callbacks;\r\n\r\n\t\tvar beforeTitle = callbacks.beforeTitle.apply(me, arguments);\r\n\t\tvar title = callbacks.title.apply(me, arguments);\r\n\t\tvar afterTitle = callbacks.afterTitle.apply(me, arguments);\r\n\r\n\t\tvar lines = [];\r\n\t\tlines = pushOrConcat(lines, splitNewlines(beforeTitle));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(title));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(afterTitle));\r\n\r\n\t\treturn lines;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"pushOrConcat","start_line":172,"end_line":183,"comment":[" Helper to push or concat based on if the 2nd parameter is an array or not"],"params":["base","toPush"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"splitNewlines","line":492,"func_location":"exports.getTitle","func_start_line":481,"func_end_line":496,"args":["lines",null],"comment":[" Get the title"," Args are: (tooltipItem, data)"],"code":"\tgetTitle: function() {\r\n\t\tvar me = this;\r\n\t\tvar opts = me._options;\r\n\t\tvar callbacks = opts.callbacks;\r\n\r\n\t\tvar beforeTitle = callbacks.beforeTitle.apply(me, arguments);\r\n\t\tvar title = callbacks.title.apply(me, arguments);\r\n\t\tvar afterTitle = callbacks.afterTitle.apply(me, arguments);\r\n\r\n\t\tvar lines = [];\r\n\t\tlines = pushOrConcat(lines, splitNewlines(beforeTitle));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(title));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(afterTitle));\r\n\r\n\t\treturn lines;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"splitNewlines","start_line":191,"end_line":196,"comment":["*\r\n * Returns array of strings split by newline\r\n * @param {String} value - The value to split by newline.\r\n * @returns {Array} value if newline present - Returned from String split() method\r\n * @function\r\n "],"params":["str"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"pushOrConcat","line":493,"func_location":"exports.getTitle","func_start_line":481,"func_end_line":496,"args":["lines",null],"comment":[" Get the title"," Args are: (tooltipItem, data)"],"code":"\tgetTitle: function() {\r\n\t\tvar me = this;\r\n\t\tvar opts = me._options;\r\n\t\tvar callbacks = opts.callbacks;\r\n\r\n\t\tvar beforeTitle = callbacks.beforeTitle.apply(me, arguments);\r\n\t\tvar title = callbacks.title.apply(me, arguments);\r\n\t\tvar afterTitle = callbacks.afterTitle.apply(me, arguments);\r\n\r\n\t\tvar lines = [];\r\n\t\tlines = pushOrConcat(lines, splitNewlines(beforeTitle));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(title));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(afterTitle));\r\n\r\n\t\treturn lines;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"pushOrConcat","start_line":172,"end_line":183,"comment":[" Helper to push or concat based on if the 2nd parameter is an array or not"],"params":["base","toPush"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"splitNewlines","line":493,"func_location":"exports.getTitle","func_start_line":481,"func_end_line":496,"args":["lines",null],"comment":[" Get the title"," Args are: (tooltipItem, data)"],"code":"\tgetTitle: function() {\r\n\t\tvar me = this;\r\n\t\tvar opts = me._options;\r\n\t\tvar callbacks = opts.callbacks;\r\n\r\n\t\tvar beforeTitle = callbacks.beforeTitle.apply(me, arguments);\r\n\t\tvar title = callbacks.title.apply(me, arguments);\r\n\t\tvar afterTitle = callbacks.afterTitle.apply(me, arguments);\r\n\r\n\t\tvar lines = [];\r\n\t\tlines = pushOrConcat(lines, splitNewlines(beforeTitle));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(title));\r\n\t\tlines = pushOrConcat(lines, splitNewlines(afterTitle));\r\n\r\n\t\treturn lines;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"splitNewlines","start_line":191,"end_line":196,"comment":["*\r\n * Returns array of strings split by newline\r\n * @param {String} value - The value to split by newline.\r\n * @returns {Array} value if newline present - Returned from String split() method\r\n * @function\r\n "],"params":["str"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"interpolate","line":751,"func_location":"module.exports.TimeScale.getValueForPixel","func_start_line":746,"func_end_line":754,"args":["me._table",{"type":"string"},"pos",{"type":"string"}],"code":"\t\tgetValueForPixel: function(pixel) {\r\n\t\t\tvar me = this;\r\n\t\t\tvar size = me._horizontal ? me.width : me.height;\r\n\t\t\tvar start = me._horizontal ? me.left : me.top;\r\n\t\t\tvar pos = (size ? (pixel - start) / size : 0) * (me._offsets.start + 1 + me._offsets.start) - me._offsets.end;\r\n\t\t\tvar time = interpolate(me._table, 'pos', pos, 'time');\r\n\r\n\t\t\treturn moment(time);\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"interpolate","start_line":166,"end_line":178,"comment":["*\r\n * Linearly interpolates the given source `value` using the table items `skey` values and\r\n * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')\r\n * returns the position for a timestamp equal to 42. If value is out of bounds, values at\r\n * index [0, 1] or [n - 1, n] are used for the interpolation.\r\n "],"params":["table","skey","sval","tkey"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getRelativePosition","line":113,"func_location":"indexMode","func_start_line":112,"func_end_line":137,"args":["e","chart"],"code":"function indexMode(chart, e, options) {\r\n\tvar position = getRelativePosition(e, chart);\r\n\t// Default axis for index mode is 'x' to match old behaviour\r\n\toptions.axis = options.axis || 'x';\r\n\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\r\n\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\r\n\tvar elements = [];\r\n\r\n\tif (!items.length) {\r\n\t\treturn [];\r\n\t}\r\n\r\n\tchart.data.datasets.forEach(function(dataset, datasetIndex) {\r\n\t\tif (chart.isDatasetVisible(datasetIndex)) {\r\n\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\r\n\t\t\tvar element = meta.data[items[0]._index];\r\n\r\n\t\t\t// don't count items that are skipped (null data)\r\n\t\t\tif (element && !element._view.skip) {\r\n\t\t\t\telements.push(element);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\treturn elements;\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getRelativePosition","start_line":11,"end_line":20,"comment":["*\r\n * Helper function to get relative position for an event\r\n * @param {Event|IEvent} event - The event to get the position for\r\n * @param {Chart} chart - The chart\r\n * @returns {Point} the event position\r\n "],"params":["e","chart"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getDistanceMetricForAxis","line":116,"func_location":"indexMode","func_start_line":112,"func_end_line":137,"args":["options.axis"],"code":"function indexMode(chart, e, options) {\r\n\tvar position = getRelativePosition(e, chart);\r\n\t// Default axis for index mode is 'x' to match old behaviour\r\n\toptions.axis = options.axis || 'x';\r\n\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\r\n\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\r\n\tvar elements = [];\r\n\r\n\tif (!items.length) {\r\n\t\treturn [];\r\n\t}\r\n\r\n\tchart.data.datasets.forEach(function(dataset, datasetIndex) {\r\n\t\tif (chart.isDatasetVisible(datasetIndex)) {\r\n\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\r\n\t\t\tvar element = meta.data[items[0]._index];\r\n\r\n\t\t\t// don't count items that are skipped (null data)\r\n\t\t\tif (element && !element._view.skip) {\r\n\t\t\t\telements.push(element);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\treturn elements;\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getDistanceMetricForAxis","start_line":101,"end_line":110,"comment":["*\r\n * Get a distance metric function for two points based on the\r\n * axis mode setting\r\n * @param {String} axis the axis mode. x|y|xy\r\n "],"params":["axis"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getIntersectItems","line":117,"func_location":"indexMode","func_start_line":112,"func_end_line":137,"args":["chart","position"],"code":"function indexMode(chart, e, options) {\r\n\tvar position = getRelativePosition(e, chart);\r\n\t// Default axis for index mode is 'x' to match old behaviour\r\n\toptions.axis = options.axis || 'x';\r\n\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\r\n\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\r\n\tvar elements = [];\r\n\r\n\tif (!items.length) {\r\n\t\treturn [];\r\n\t}\r\n\r\n\tchart.data.datasets.forEach(function(dataset, datasetIndex) {\r\n\t\tif (chart.isDatasetVisible(datasetIndex)) {\r\n\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\r\n\t\t\tvar element = meta.data[items[0]._index];\r\n\r\n\t\t\t// don't count items that are skipped (null data)\r\n\t\t\tif (element && !element._view.skip) {\r\n\t\t\t\telements.push(element);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\treturn elements;\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getIntersectItems","start_line":52,"end_line":62,"comment":["*\r\n * Helper function to get the items that intersect the event position\r\n * @param items {ChartElement[]} elements to filter\r\n * @param position {Point} the point to be nearest to\r\n * @return {ChartElement[]} the nearest items\r\n "],"params":["chart","position"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getNearestItems","line":117,"func_location":"indexMode","func_start_line":112,"func_end_line":137,"args":["chart","position"],"code":"function indexMode(chart, e, options) {\r\n\tvar position = getRelativePosition(e, chart);\r\n\t// Default axis for index mode is 'x' to match old behaviour\r\n\toptions.axis = options.axis || 'x';\r\n\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\r\n\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\r\n\tvar elements = [];\r\n\r\n\tif (!items.length) {\r\n\t\treturn [];\r\n\t}\r\n\r\n\tchart.data.datasets.forEach(function(dataset, datasetIndex) {\r\n\t\tif (chart.isDatasetVisible(datasetIndex)) {\r\n\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\r\n\t\t\tvar element = meta.data[items[0]._index];\r\n\r\n\t\t\t// don't count items that are skipped (null data)\r\n\t\t\tif (element && !element._view.skip) {\r\n\t\t\t\telements.push(element);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\treturn elements;\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getNearestItems","start_line":72,"end_line":94,"comment":["*\r\n * Helper function to get the items nearest to the event position considering all visible items in teh chart\r\n * @param chart {Chart} the chart to look at elements from\r\n * @param position {Point} the point to be nearest to\r\n * @param intersect {Boolean} if true, only consider items that intersect the position\r\n * @param distanceMetric {Function} function to provide the distance between points\r\n * @return {ChartElement[]} the nearest items\r\n "],"params":["chart","position","intersect","distanceMetric"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"Surrogate","line":302,"func_location":"helpers.inherits","func_start_line":291,"func_end_line":311},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"helpers.inherits.Surrogate","start_line":297,"end_line":299,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"extend","line":306,"func_location":"helpers.inherits","func_start_line":291,"func_end_line":311,"args":["ChartElement.prototype","extensions"],"comment":["*\r\n\t * Basic javascript inheritance based on the model created in Backbone.js\r\n\t "],"code":"\tinherits: function(extensions) {\r\n\t\tvar me = this;\r\n\t\tvar ChartElement = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor : function() {\r\n\t\t\treturn me.apply(this, arguments);\r\n\t\t};\r\n\r\n\t\tvar Surrogate = function() {\r\n\t\t\tthis.constructor = ChartElement;\r\n\t\t};\r\n\r\n\t\tSurrogate.prototype = me.prototype;\r\n\t\tChartElement.prototype = new Surrogate();\r\n\t\tChartElement.extend = helpers.inherits;\r\n\r\n\t\tif (extensions) {\r\n\t\t\thelpers.extend(ChartElement.prototype, extensions);\r\n\t\t}\r\n\r\n\t\tChartElement.__super__ = me.prototype;\r\n\t\treturn ChartElement;\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"helpers.extend","start_line":278,"end_line":286,"comment":["*\r\n\t * Applies the contents of two or more objects together into the first object.\r\n\t * @param {Object} target - The target object in which all objects are merged into.\r\n\t * @param {Object} arg1 - Object containing additional properties to merge in target.\r\n\t * @param {Object} argN - Additional objects containing properties to merge in target.\r\n\t * @returns {Object} The `target` object.\r\n\t "],"params":["target"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"readUsedSize","line":79,"func_location":"initCanvas","func_start_line":52,"func_end_line":100,"args":["canvas",{"type":"string"}],"comment":["*\r\n * Initializes the canvas style and render size without modifying the canvas display size,\r\n * since responsiveness is handled by the controller.resize() method. The config is used\r\n * to determine the aspect ratio to apply in case no explicit height has been specified.\r\n "],"code":"function initCanvas(canvas, config) {\r\n\tvar style = canvas.style;\r\n\r\n\t// NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\r\n\t// returns null or '' if no explicit value has been set to the canvas attribute.\r\n\tvar renderHeight = canvas.getAttribute('height');\r\n\tvar renderWidth = canvas.getAttribute('width');\r\n\r\n\t// Chart.js modifies some canvas values that we want to restore on destroy\r\n\tcanvas[EXPANDO_KEY] = {\r\n\t\tinitial: {\r\n\t\t\theight: renderHeight,\r\n\t\t\twidth: renderWidth,\r\n\t\t\tstyle: {\r\n\t\t\t\tdisplay: style.display,\r\n\t\t\t\theight: style.height,\r\n\t\t\t\twidth: style.width\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t// Force canvas to display as block to avoid extra space caused by inline\r\n\t// elements, which would interfere with the responsive resize process.\r\n\t// https://github.com/chartjs/Chart.js/issues/2538\r\n\tstyle.display = style.display || 'block';\r\n\r\n\tif (renderWidth === null || renderWidth === '') {\r\n\t\tvar displayWidth = readUsedSize(canvas, 'width');\r\n\t\tif (displayWidth !== undefined) {\r\n\t\t\tcanvas.width = displayWidth;\r\n\t\t}\r\n\t}\r\n\r\n\tif (renderHeight === null || renderHeight === '') {\r\n\t\tif (canvas.style.height === '') {\r\n\t\t\t// If no explicit render height and style height, let's apply the aspect ratio,\r\n\t\t\t// which one can be specified by the user but also by charts as default option\r\n\t\t\t// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\r\n\t\t\tcanvas.height = canvas.width / (config.options.aspectRatio || 2);\r\n\t\t} else {\r\n\t\t\tvar displayHeight = readUsedSize(canvas, 'height');\r\n\t\t\tif (displayWidth !== undefined) {\r\n\t\t\t\tcanvas.height = displayHeight;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn canvas;\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"readUsedSize","start_line":41,"end_line":45,"comment":["*\r\n * The \"used\" size is the final value of a dimension property after all calculations have\r\n * been performed. This method uses the computed style of `element` but returns undefined\r\n * if the computed style is not expressed in pixels. That can happen in some cases where\r\n * `element` has a size relative to its parent and this last one is not yet displayed,\r\n * for example because of `display: none` on a parent node.\r\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\r\n * @returns {Number} Size in pixels or undefined if unknown.\r\n "],"params":["element","property"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"readUsedSize","line":92,"func_location":"initCanvas","func_start_line":52,"func_end_line":100,"args":["canvas",{"type":"string"}],"comment":["*\r\n * Initializes the canvas style and render size without modifying the canvas display size,\r\n * since responsiveness is handled by the controller.resize() method. The config is used\r\n * to determine the aspect ratio to apply in case no explicit height has been specified.\r\n "],"code":"function initCanvas(canvas, config) {\r\n\tvar style = canvas.style;\r\n\r\n\t// NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\r\n\t// returns null or '' if no explicit value has been set to the canvas attribute.\r\n\tvar renderHeight = canvas.getAttribute('height');\r\n\tvar renderWidth = canvas.getAttribute('width');\r\n\r\n\t// Chart.js modifies some canvas values that we want to restore on destroy\r\n\tcanvas[EXPANDO_KEY] = {\r\n\t\tinitial: {\r\n\t\t\theight: renderHeight,\r\n\t\t\twidth: renderWidth,\r\n\t\t\tstyle: {\r\n\t\t\t\tdisplay: style.display,\r\n\t\t\t\theight: style.height,\r\n\t\t\t\twidth: style.width\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t// Force canvas to display as block to avoid extra space caused by inline\r\n\t// elements, which would interfere with the responsive resize process.\r\n\t// https://github.com/chartjs/Chart.js/issues/2538\r\n\tstyle.display = style.display || 'block';\r\n\r\n\tif (renderWidth === null || renderWidth === '') {\r\n\t\tvar displayWidth = readUsedSize(canvas, 'width');\r\n\t\tif (displayWidth !== undefined) {\r\n\t\t\tcanvas.width = displayWidth;\r\n\t\t}\r\n\t}\r\n\r\n\tif (renderHeight === null || renderHeight === '') {\r\n\t\tif (canvas.style.height === '') {\r\n\t\t\t// If no explicit render height and style height, let's apply the aspect ratio,\r\n\t\t\t// which one can be specified by the user but also by charts as default option\r\n\t\t\t// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\r\n\t\t\tcanvas.height = canvas.width / (config.options.aspectRatio || 2);\r\n\t\t} else {\r\n\t\t\tvar displayHeight = readUsedSize(canvas, 'height');\r\n\t\t\tif (displayWidth !== undefined) {\r\n\t\t\t\tcanvas.height = displayHeight;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn canvas;\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"readUsedSize","start_line":41,"end_line":45,"comment":["*\r\n * The \"used\" size is the final value of a dimension property after all calculations have\r\n * been performed. This method uses the computed style of `element` but returns undefined\r\n * if the computed style is not expressed in pixels. That can happen in some cases where\r\n * `element` has a size relative to its parent and this last one is not yet displayed,\r\n * for example because of `display: none` on a parent node.\r\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\r\n * @returns {Number} Size in pixels or undefined if unknown.\r\n "],"params":["element","property"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"injectCSS","line":331,"func_location":"module.exports.initialize","func_start_line":328,"func_end_line":341},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"injectCSS","start_line":307,"end_line":318,"comment":[],"params":["platform","css"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"getBaseModel","line":475,"func_location":"exports.initialize","func_start_line":474,"func_end_line":477,"args":["._options"],"code":"\tinitialize: function() {\r\n\t\tthis._model = getBaseModel(this._options);\r\n\t\tthis._lastActive = [];\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"getBaseModel","start_line":222,"end_line":269,"comment":["*\r\n * Helper to get the reset model for the tooltip\r\n * @param tooltipOpts {Object} the tooltip options\r\n "],"params":["tooltipOpts"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.bar.js","name":"initialize","line":125,"func_location":"initialize","func_start_line":121,"func_end_line":130,"args":["me","arguments"],"code":"\tinitialize: function() {\r\n\t\tvar me = this;\r\n\t\tvar meta;\r\n\r\n\t\tDatasetController.prototype.initialize.apply(me, arguments);\r\n\r\n\t\tmeta = me.getMeta();\r\n\t\tmeta.stack = me.getDataset().stack;\r\n\t\tmeta.bar = true;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.bar.js","name":"initialize","start_line":121,"end_line":130,"comment":[],"params":[]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/elements/element.rectangle.js","name":"getBarBounds","line":172,"func_location":"inLabelRange","func_start_line":165,"func_end_line":181,"args":["me"],"code":"\tinLabelRange: function(mouseX, mouseY) {\r\n\t\tvar me = this;\r\n\t\tif (!me._view) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tvar inRange = false;\r\n\t\tvar bounds = getBarBounds(me);\r\n\r\n\t\tif (isVertical(me)) {\r\n\t\t\tinRange = mouseX >= bounds.left && mouseX <= bounds.right;\r\n\t\t} else {\r\n\t\t\tinRange = mouseY >= bounds.top && mouseY <= bounds.bottom;\r\n\t\t}\r\n\r\n\t\treturn inRange;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/elements/element.rectangle.js","name":"getBarBounds","start_line":29,"end_line":55,"comment":["*\r\n * Helper function to get the bounds of the bar regardless of the orientation\r\n * @param bar {Chart.Element.Rectangle} the bar\r\n * @return {Bounds} bounds of the bar\r\n * @private\r\n "],"params":["bar"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/elements/element.rectangle.js","name":"isVertical","line":174,"func_location":"inLabelRange","func_start_line":165,"func_end_line":181,"args":["me"],"code":"\tinLabelRange: function(mouseX, mouseY) {\r\n\t\tvar me = this;\r\n\t\tif (!me._view) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tvar inRange = false;\r\n\t\tvar bounds = getBarBounds(me);\r\n\r\n\t\tif (isVertical(me)) {\r\n\t\t\tinRange = mouseX >= bounds.left && mouseX <= bounds.right;\r\n\t\t} else {\r\n\t\t\tinRange = mouseY >= bounds.top && mouseY <= bounds.bottom;\r\n\t\t}\r\n\r\n\t\treturn inRange;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/elements/element.rectangle.js","name":"isVertical","start_line":19,"end_line":21,"comment":[],"params":["bar"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/elements/element.rectangle.js","name":"getBarBounds","line":158,"func_location":"inRange","func_start_line":154,"func_end_line":163,"args":[null],"code":"\tinRange: function(mouseX, mouseY) {\r\n\t\tvar inRange = false;\r\n\r\n\t\tif (this._view) {\r\n\t\t\tvar bounds = getBarBounds(this);\r\n\t\t\tinRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;\r\n\t\t}\r\n\r\n\t\treturn inRange;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/elements/element.rectangle.js","name":"getBarBounds","start_line":29,"end_line":55,"comment":["*\r\n * Helper function to get the bounds of the bar regardless of the orientation\r\n * @param bar {Chart.Element.Rectangle} the bar\r\n * @return {Bounds} bounds of the bar\r\n * @private\r\n "],"params":["bar"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"lookup","line":167,"func_location":"interpolate","func_start_line":166,"func_end_line":178,"args":["table","skey","sval"],"comment":["*\r\n * Linearly interpolates the given source `value` using the table items `skey` values and\r\n * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')\r\n * returns the position for a timestamp equal to 42. If value is out of bounds, values at\r\n * index [0, 1] or [n - 1, n] are used for the interpolation.\r\n "],"code":"function interpolate(table, skey, sval, tkey) {\r\n\tvar range = lookup(table, skey, sval);\r\n\r\n\t// Note: the lookup table ALWAYS contains at least 2 items (min and max)\r\n\tvar prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;\r\n\tvar next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;\r\n\r\n\tvar span = next[skey] - prev[skey];\r\n\tvar ratio = span ? (sval - prev[skey]) / span : 0;\r\n\tvar offset = (next[tkey] - prev[tkey]) * ratio;\r\n\r\n\treturn prev[tkey] + offset;\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"lookup","start_line":134,"end_line":158,"comment":[" @see adapted from https://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/"],"params":["table","key","value"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/elements/element.rectangle.js","name":"getBarBounds","line":184,"func_location":"inXRange","func_start_line":183,"func_end_line":186,"args":[null],"code":"\tinXRange: function(mouseX) {\r\n\t\tvar bounds = getBarBounds(this);\r\n\t\treturn mouseX >= bounds.left && mouseX <= bounds.right;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/elements/element.rectangle.js","name":"getBarBounds","start_line":29,"end_line":55,"comment":["*\r\n * Helper function to get the bounds of the bar regardless of the orientation\r\n * @param bar {Chart.Element.Rectangle} the bar\r\n * @return {Bounds} bounds of the bar\r\n * @private\r\n "],"params":["bar"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/elements/element.rectangle.js","name":"getBarBounds","line":189,"func_location":"inYRange","func_start_line":188,"func_end_line":191,"args":[null],"code":"\tinYRange: function(mouseY) {\r\n\t\tvar bounds = getBarBounds(this);\r\n\t\treturn mouseY >= bounds.top && mouseY <= bounds.bottom;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/elements/element.rectangle.js","name":"getBarBounds","start_line":29,"end_line":55,"comment":["*\r\n * Helper function to get the bounds of the bar regardless of the orientation\r\n * @param bar {Chart.Element.Rectangle} the bar\r\n * @return {Bounds} bounds of the bar\r\n * @private\r\n "],"params":["bar"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"isArray","line":234,"func_location":"helpers.merge","func_start_line":233,"func_end_line":258,"args":["source"],"comment":["*\r\n\t * Recursively deep copies `source` properties into `target` with the given `options`.\r\n\t * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\r\n\t * @param {Object} target - The target object in which all sources are merged into.\r\n\t * @param {Object|Array(Object)} source - Object(s) to merge into `target`.\r\n\t * @param {Object} [options] - Merging options:\r\n\t * @param {Function} [options.merger] - The merge method (key, target, source, options)\r\n\t * @returns {Object} The `target` object.\r\n\t "],"code":"\tmerge: function(target, source, options) {\r\n\t\tvar sources = helpers.isArray(source) ? source : [source];\r\n\t\tvar ilen = sources.length;\r\n\t\tvar merge, i, keys, klen, k;\r\n\r\n\t\tif (!helpers.isObject(target)) {\r\n\t\t\treturn target;\r\n\t\t}\r\n\r\n\t\toptions = options || {};\r\n\t\tmerge = options.merger || helpers._merger;\r\n\r\n\t\tfor (i = 0; i < ilen; ++i) {\r\n\t\t\tsource = sources[i];\r\n\t\t\tif (!helpers.isObject(source)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tkeys = Object.keys(source);\r\n\t\t\tfor (k = 0, klen = keys.length; k < klen; ++k) {\r\n\t\t\t\tmerge(keys[k], target, source, options);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn target;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"helpers.isArray","start_line":40,"end_line":49,"comment":["*\r\n\t * Returns true if `value` is an array (including typed arrays), else returns false.\r\n\t * @param {*} value - The value to test.\r\n\t * @returns {Boolean}\r\n\t * @function\r\n\t "],"params":["value"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"isObject","line":238,"func_location":"helpers.merge","func_start_line":233,"func_end_line":258,"args":["target"],"comment":["*\r\n\t * Recursively deep copies `source` properties into `target` with the given `options`.\r\n\t * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\r\n\t * @param {Object} target - The target object in which all sources are merged into.\r\n\t * @param {Object|Array(Object)} source - Object(s) to merge into `target`.\r\n\t * @param {Object} [options] - Merging options:\r\n\t * @param {Function} [options.merger] - The merge method (key, target, source, options)\r\n\t * @returns {Object} The `target` object.\r\n\t "],"code":"\tmerge: function(target, source, options) {\r\n\t\tvar sources = helpers.isArray(source) ? source : [source];\r\n\t\tvar ilen = sources.length;\r\n\t\tvar merge, i, keys, klen, k;\r\n\r\n\t\tif (!helpers.isObject(target)) {\r\n\t\t\treturn target;\r\n\t\t}\r\n\r\n\t\toptions = options || {};\r\n\t\tmerge = options.merger || helpers._merger;\r\n\r\n\t\tfor (i = 0; i < ilen; ++i) {\r\n\t\t\tsource = sources[i];\r\n\t\t\tif (!helpers.isObject(source)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tkeys = Object.keys(source);\r\n\t\t\tfor (k = 0, klen = keys.length; k < klen; ++k) {\r\n\t\t\t\tmerge(keys[k], target, source, options);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn target;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"helpers.isObject","start_line":57,"end_line":59,"comment":["*\r\n\t * Returns true if `value` is an object (excluding null), else returns false.\r\n\t * @param {*} value - The value to test.\r\n\t * @returns {Boolean}\r\n\t * @since 2.7.0\r\n\t "],"params":["value"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"isObject","line":247,"func_location":"helpers.merge","func_start_line":233,"func_end_line":258,"args":["source"],"comment":["*\r\n\t * Recursively deep copies `source` properties into `target` with the given `options`.\r\n\t * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\r\n\t * @param {Object} target - The target object in which all sources are merged into.\r\n\t * @param {Object|Array(Object)} source - Object(s) to merge into `target`.\r\n\t * @param {Object} [options] - Merging options:\r\n\t * @param {Function} [options.merger] - The merge method (key, target, source, options)\r\n\t * @returns {Object} The `target` object.\r\n\t "],"code":"\tmerge: function(target, source, options) {\r\n\t\tvar sources = helpers.isArray(source) ? source : [source];\r\n\t\tvar ilen = sources.length;\r\n\t\tvar merge, i, keys, klen, k;\r\n\r\n\t\tif (!helpers.isObject(target)) {\r\n\t\t\treturn target;\r\n\t\t}\r\n\r\n\t\toptions = options || {};\r\n\t\tmerge = options.merger || helpers._merger;\r\n\r\n\t\tfor (i = 0; i < ilen; ++i) {\r\n\t\t\tsource = sources[i];\r\n\t\t\tif (!helpers.isObject(source)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tkeys = Object.keys(source);\r\n\t\t\tfor (k = 0, klen = keys.length; k < klen; ++k) {\r\n\t\t\t\tmerge(keys[k], target, source, options);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn target;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"helpers.isObject","start_line":57,"end_line":59,"comment":["*\r\n\t * Returns true if `value` is an object (excluding null), else returns false.\r\n\t * @param {*} value - The value to test.\r\n\t * @returns {Boolean}\r\n\t * @since 2.7.0\r\n\t "],"params":["value"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getRelativePosition","line":243,"func_location":"module.exports.modes.nearest","func_start_line":242,"func_end_line":247,"args":["e","chart"],"comment":["*\r\n\t\t * nearest mode returns the element closest to the point\r\n\t\t * @function Chart.Interaction.modes.intersect\r\n\t\t * @param chart {chart} the chart we are returning items from\r\n\t\t * @param e {Event} the event we are find things at\r\n\t\t * @param options {IInteractionOptions} options to use\r\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n\t\t "],"code":"\t\tnearest: function(chart, e, options) {\r\n\t\t\tvar position = getRelativePosition(e, chart);\r\n\t\t\toptions.axis = options.axis || 'xy';\r\n\t\t\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\r\n\t\t\treturn getNearestItems(chart, position, options.intersect, distanceMetric);\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getRelativePosition","start_line":11,"end_line":20,"comment":["*\r\n * Helper function to get relative position for an event\r\n * @param {Event|IEvent} event - The event to get the position for\r\n * @param {Chart} chart - The chart\r\n * @returns {Point} the event position\r\n "],"params":["e","chart"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getDistanceMetricForAxis","line":245,"func_location":"module.exports.modes.nearest","func_start_line":242,"func_end_line":247,"args":["options.axis"],"comment":["*\r\n\t\t * nearest mode returns the element closest to the point\r\n\t\t * @function Chart.Interaction.modes.intersect\r\n\t\t * @param chart {chart} the chart we are returning items from\r\n\t\t * @param e {Event} the event we are find things at\r\n\t\t * @param options {IInteractionOptions} options to use\r\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n\t\t "],"code":"\t\tnearest: function(chart, e, options) {\r\n\t\t\tvar position = getRelativePosition(e, chart);\r\n\t\t\toptions.axis = options.axis || 'xy';\r\n\t\t\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\r\n\t\t\treturn getNearestItems(chart, position, options.intersect, distanceMetric);\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getDistanceMetricForAxis","start_line":101,"end_line":110,"comment":["*\r\n * Get a distance metric function for two points based on the\r\n * axis mode setting\r\n * @param {String} axis the axis mode. x|y|xy\r\n "],"params":["axis"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getNearestItems","line":246,"func_location":"module.exports.modes.nearest","func_start_line":242,"func_end_line":247,"args":["chart","position","options.intersect","distanceMetric"],"comment":["*\r\n\t\t * nearest mode returns the element closest to the point\r\n\t\t * @function Chart.Interaction.modes.intersect\r\n\t\t * @param chart {chart} the chart we are returning items from\r\n\t\t * @param e {Event} the event we are find things at\r\n\t\t * @param options {IInteractionOptions} options to use\r\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n\t\t "],"code":"\t\tnearest: function(chart, e, options) {\r\n\t\t\tvar position = getRelativePosition(e, chart);\r\n\t\t\toptions.axis = options.axis || 'xy';\r\n\t\t\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\r\n\t\t\treturn getNearestItems(chart, position, options.intersect, distanceMetric);\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getNearestItems","start_line":72,"end_line":94,"comment":["*\r\n * Helper function to get the items nearest to the event position considering all visible items in teh chart\r\n * @param chart {Chart} the chart to look at elements from\r\n * @param position {Point} the point to be nearest to\r\n * @param intersect {Boolean} if true, only consider items that intersect the position\r\n * @param distanceMetric {Function} function to provide the distance between points\r\n * @return {ChartElement[]} the nearest items\r\n "],"params":["chart","position","intersect","distanceMetric"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"momentify","line":219,"func_location":"parse","func_start_line":213,"func_end_line":229,"args":[null,"options"],"code":"function parse(input, scale) {\r\n\tif (helpers.isNullOrUndef(input)) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tvar options = scale.options.time;\r\n\tvar value = momentify(scale.getRightValue(input), options);\r\n\tif (!value.isValid()) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tif (options.round) {\r\n\t\tvalue.startOf(options.round);\r\n\t}\r\n\r\n\treturn value.valueOf();\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.time.js","name":"momentify","start_line":184,"end_line":211,"comment":["*\r\n * Convert the given value to a moment object using the given time options.\r\n * @see https://momentjs.com/docs/#/parsing/\r\n "],"params":["value","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getRelativePosition","line":230,"func_location":"module.exports.modes.point","func_start_line":229,"func_end_line":232,"args":["e","chart"],"comment":["*\r\n\t\t * Point mode returns all elements that hit test based on the event position\r\n\t\t * of the event\r\n\t\t * @function Chart.Interaction.modes.intersect\r\n\t\t * @param chart {chart} the chart we are returning items from\r\n\t\t * @param e {Event} the event we are find things at\r\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n\t\t "],"code":"\t\tpoint: function(chart, e) {\r\n\t\t\tvar position = getRelativePosition(e, chart);\r\n\t\t\treturn getIntersectItems(chart, position);\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getRelativePosition","start_line":11,"end_line":20,"comment":["*\r\n * Helper function to get relative position for an event\r\n * @param {Event|IEvent} event - The event to get the position for\r\n * @param {Chart} chart - The chart\r\n * @returns {Point} the event position\r\n "],"params":["e","chart"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getIntersectItems","line":231,"func_location":"module.exports.modes.point","func_start_line":229,"func_end_line":232,"args":["chart","position"],"comment":["*\r\n\t\t * Point mode returns all elements that hit test based on the event position\r\n\t\t * of the event\r\n\t\t * @function Chart.Interaction.modes.intersect\r\n\t\t * @param chart {chart} the chart we are returning items from\r\n\t\t * @param e {Event} the event we are find things at\r\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n\t\t "],"code":"\t\tpoint: function(chart, e) {\r\n\t\t\tvar position = getRelativePosition(e, chart);\r\n\t\t\treturn getIntersectItems(chart, position);\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getIntersectItems","start_line":52,"end_line":62,"comment":["*\r\n * Helper function to get the items that intersect the event position\r\n * @param items {ChartElement[]} elements to filter\r\n * @param position {Point} the point to be nearest to\r\n * @return {ChartElement[]} the nearest items\r\n "],"params":["chart","position"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"removeResizeListener","line":427,"func_location":"module.exports.removeEventListener","func_start_line":423,"func_end_line":439,"args":["canvas","listener"],"code":"\tremoveEventListener: function(chart, type, listener) {\r\n\t\tvar canvas = chart.canvas;\r\n\t\tif (type === 'resize') {\r\n\t\t\t// Note: the resize event is not supported on all browsers.\r\n\t\t\tremoveResizeListener(canvas, listener);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar expando = listener[EXPANDO_KEY] || {};\r\n\t\tvar proxies = expando.proxies || {};\r\n\t\tvar proxy = proxies[chart.id + '_' + type];\r\n\t\tif (!proxy) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tremoveEventListener(canvas, type, proxy);\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"removeResizeListener","start_line":295,"end_line":305,"comment":[],"params":["node"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"unwatchForRender","line":300,"func_location":"removeResizeListener","func_start_line":295,"func_end_line":305,"args":["node"],"code":"function removeResizeListener(node) {\r\n\tvar expando = node[EXPANDO_KEY] || {};\r\n\tvar resizer = expando.resizer;\r\n\r\n\tdelete expando.resizer;\r\n\tunwatchForRender(node);\r\n\r\n\tif (resizer && resizer.parentNode) {\r\n\t\tresizer.parentNode.removeChild(resizer);\r\n\t}\r\n}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/platforms/platform.dom.js","name":"unwatchForRender","start_line":255,"end_line":268,"comment":[],"params":["node"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.controller.js","name":"onComplete","line":547,"func_location":"render","func_start_line":501,"func_end_line":551,"args":[null],"code":"\t\trender: function(config) {\r\n\t\t\tvar me = this;\r\n\r\n\t\t\tif (!config || typeof config !== 'object') {\r\n\t\t\t\t// backwards compatibility\r\n\t\t\t\tconfig = {\r\n\t\t\t\t\tduration: config,\r\n\t\t\t\t\tlazy: arguments[1]\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tvar duration = config.duration;\r\n\t\t\tvar lazy = config.lazy;\r\n\r\n\t\t\tif (plugins.notify(me, 'beforeRender') === false) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar animationOptions = me.options.animation;\r\n\t\t\tvar onComplete = function(animation) {\r\n\t\t\t\tplugins.notify(me, 'afterRender');\r\n\t\t\t\thelpers.callback(animationOptions && animationOptions.onComplete, [animation], me);\r\n\t\t\t};\r\n\r\n\t\t\tif (animationOptions && ((typeof duration !== 'undefined' && duration !== 0) || (typeof duration === 'undefined' && animationOptions.duration !== 0))) {\r\n\t\t\t\tvar animation = new Animation({\r\n\t\t\t\t\tnumSteps: (duration || animationOptions.duration) / 16.66, // 60 fps\r\n\t\t\t\t\teasing: config.easing || animationOptions.easing,\r\n\r\n\t\t\t\t\trender: function(chart, animationObject) {\r\n\t\t\t\t\t\tvar easingFunction = helpers.easing.effects[animationObject.easing];\r\n\t\t\t\t\t\tvar currentStep = animationObject.currentStep;\r\n\t\t\t\t\t\tvar stepDecimal = currentStep / animationObject.numSteps;\r\n\r\n\t\t\t\t\t\tchart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tonAnimationProgress: animationOptions.onProgress,\r\n\t\t\t\t\tonAnimationComplete: onComplete\r\n\t\t\t\t});\r\n\r\n\t\t\t\tanimations.addAnimation(me, animation, duration, lazy);\r\n\t\t\t} else {\r\n\t\t\t\tme.draw();\r\n\r\n\t\t\t\t// See https://github.com/chartjs/Chart.js/issues/3781\r\n\t\t\t\tonComplete(new Animation({numSteps: 0, chart: me}));\r\n\t\t\t}\r\n\r\n\t\t\treturn me;\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.controller.js","name":"render.onComplete","start_line":520,"end_line":523,"comment":[],"params":["animation"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"getTickBackdropHeight","line":327,"func_location":"module.exports.LinearRadialScale.setDimensions","func_start_line":321,"func_end_line":331,"args":["me.options"],"code":"\t\tsetDimensions: function() {\r\n\t\t\tvar me = this;\r\n\r\n\t\t\t// Set the unconstrained dimension before label rotation\r\n\t\t\tme.width = me.maxWidth;\r\n\t\t\tme.height = me.maxHeight;\r\n\t\t\tme.paddingTop = getTickBackdropHeight(me.options) / 2;\r\n\t\t\tme.xCenter = Math.floor(me.width / 2);\r\n\t\t\tme.yCenter = Math.floor((me.height - me.paddingTop) / 2);\r\n\t\t\tme.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"module.exports.getTickBackdropHeight","start_line":65,"end_line":72,"comment":[],"params":["opts"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"numberOrZero","line":398,"func_location":"module.exports.LinearRadialScale.setReductions","func_start_line":391,"func_end_line":407,"args":["radiusReductionLeft"],"comment":["*\r\n\t\t * Set radius reductions and determine new radius and center point\r\n\t\t * @private\r\n\t\t "],"code":"\t\tsetReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {\r\n\t\t\tvar me = this;\r\n\t\t\tvar radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\r\n\t\t\tvar radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\r\n\t\t\tvar radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\r\n\t\t\tvar radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);\r\n\r\n\t\t\tradiusReductionLeft = numberOrZero(radiusReductionLeft);\r\n\t\t\tradiusReductionRight = numberOrZero(radiusReductionRight);\r\n\t\t\tradiusReductionTop = numberOrZero(radiusReductionTop);\r\n\t\t\tradiusReductionBottom = numberOrZero(radiusReductionBottom);\r\n\r\n\t\t\tme.drawingArea = Math.min(\r\n\t\t\t\tMath.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),\r\n\t\t\t\tMath.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));\r\n\t\t\tme.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"module.exports.numberOrZero","start_line":316,"end_line":318,"comment":[],"params":["param"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"numberOrZero","line":399,"func_location":"module.exports.LinearRadialScale.setReductions","func_start_line":391,"func_end_line":407,"args":["radiusReductionRight"],"comment":["*\r\n\t\t * Set radius reductions and determine new radius and center point\r\n\t\t * @private\r\n\t\t "],"code":"\t\tsetReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {\r\n\t\t\tvar me = this;\r\n\t\t\tvar radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\r\n\t\t\tvar radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\r\n\t\t\tvar radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\r\n\t\t\tvar radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);\r\n\r\n\t\t\tradiusReductionLeft = numberOrZero(radiusReductionLeft);\r\n\t\t\tradiusReductionRight = numberOrZero(radiusReductionRight);\r\n\t\t\tradiusReductionTop = numberOrZero(radiusReductionTop);\r\n\t\t\tradiusReductionBottom = numberOrZero(radiusReductionBottom);\r\n\r\n\t\t\tme.drawingArea = Math.min(\r\n\t\t\t\tMath.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),\r\n\t\t\t\tMath.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));\r\n\t\t\tme.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"module.exports.numberOrZero","start_line":316,"end_line":318,"comment":[],"params":["param"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"numberOrZero","line":400,"func_location":"module.exports.LinearRadialScale.setReductions","func_start_line":391,"func_end_line":407,"args":["radiusReductionTop"],"comment":["*\r\n\t\t * Set radius reductions and determine new radius and center point\r\n\t\t * @private\r\n\t\t "],"code":"\t\tsetReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {\r\n\t\t\tvar me = this;\r\n\t\t\tvar radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\r\n\t\t\tvar radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\r\n\t\t\tvar radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\r\n\t\t\tvar radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);\r\n\r\n\t\t\tradiusReductionLeft = numberOrZero(radiusReductionLeft);\r\n\t\t\tradiusReductionRight = numberOrZero(radiusReductionRight);\r\n\t\t\tradiusReductionTop = numberOrZero(radiusReductionTop);\r\n\t\t\tradiusReductionBottom = numberOrZero(radiusReductionBottom);\r\n\r\n\t\t\tme.drawingArea = Math.min(\r\n\t\t\t\tMath.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),\r\n\t\t\t\tMath.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));\r\n\t\t\tme.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"module.exports.numberOrZero","start_line":316,"end_line":318,"comment":[],"params":["param"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"numberOrZero","line":401,"func_location":"module.exports.LinearRadialScale.setReductions","func_start_line":391,"func_end_line":407,"args":["radiusReductionBottom"],"comment":["*\r\n\t\t * Set radius reductions and determine new radius and center point\r\n\t\t * @private\r\n\t\t "],"code":"\t\tsetReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {\r\n\t\t\tvar me = this;\r\n\t\t\tvar radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\r\n\t\t\tvar radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\r\n\t\t\tvar radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\r\n\t\t\tvar radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);\r\n\r\n\t\t\tradiusReductionLeft = numberOrZero(radiusReductionLeft);\r\n\t\t\tradiusReductionRight = numberOrZero(radiusReductionRight);\r\n\t\t\tradiusReductionTop = numberOrZero(radiusReductionTop);\r\n\t\t\tradiusReductionBottom = numberOrZero(radiusReductionBottom);\r\n\r\n\t\t\tme.drawingArea = Math.min(\r\n\t\t\t\tMath.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),\r\n\t\t\t\tMath.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));\r\n\t\t\tme.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/scales/scale.radialLinear.js","name":"module.exports.numberOrZero","start_line":316,"end_line":318,"comment":[],"params":["param"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getRelativePosition","line":156,"func_location":"module.exports.modes.single","func_start_line":155,"func_end_line":167,"args":["e","chart"],"code":"\t\tsingle: function(chart, e) {\r\n\t\t\tvar position = getRelativePosition(e, chart);\r\n\t\t\tvar elements = [];\r\n\r\n\t\t\tparseVisibleItems(chart, function(element) {\r\n\t\t\t\tif (element.inRange(position.x, position.y)) {\r\n\t\t\t\t\telements.push(element);\r\n\t\t\t\t\treturn elements;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\treturn elements.slice(0, 1);\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getRelativePosition","start_line":11,"end_line":20,"comment":["*\r\n * Helper function to get relative position for an event\r\n * @param {Event|IEvent} event - The event to get the position for\r\n * @param {Chart} chart - The chart\r\n * @returns {Point} the event position\r\n "],"params":["e","chart"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"parseVisibleItems","line":159,"func_location":"module.exports.modes.single","func_start_line":155,"func_end_line":167},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"parseVisibleItems","start_line":27,"end_line":44,"comment":["*\r\n * Helper function to traverse all of the visible elements in the chart\r\n * @param chart {chart} the chart\r\n * @param handler {Function} the callback to execute for each visible item\r\n "],"params":["chart","handler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.element.js","name":"interpolate","line":96,"func_location":"transition","func_start_line":75,"func_end_line":99,"args":["start","view","model","ease"],"code":"\ttransition: function(ease) {\r\n\t\tvar me = this;\r\n\t\tvar model = me._model;\r\n\t\tvar start = me._start;\r\n\t\tvar view = me._view;\r\n\r\n\t\t// No animation -> No Transition\r\n\t\tif (!model || ease === 1) {\r\n\t\t\tme._view = model;\r\n\t\t\tme._start = null;\r\n\t\t\treturn me;\r\n\t\t}\r\n\r\n\t\tif (!view) {\r\n\t\t\tview = me._view = {};\r\n\t\t}\r\n\r\n\t\tif (!start) {\r\n\t\t\tstart = me._start = {};\r\n\t\t}\r\n\r\n\t\tinterpolate(start, view, model, ease);\r\n\r\n\t\treturn me;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.element.js","name":"interpolate","start_line":6,"end_line":53,"comment":[],"params":["start","view","model","ease"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"getBaseModel","line":556,"func_location":"exports.update","func_start_line":548,"func_end_line":658,"args":["opts"],"code":"\tupdate: function(changed) {\r\n\t\tvar me = this;\r\n\t\tvar opts = me._options;\r\n\r\n\t\t// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition\r\n\t\t// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time\r\n\t\t// which breaks any animations.\r\n\t\tvar existingModel = me._model;\r\n\t\tvar model = me._model = getBaseModel(opts);\r\n\t\tvar active = me._active;\r\n\r\n\t\tvar data = me._data;\r\n\r\n\t\t// In the case where active.length === 0 we need to keep these at existing values for good animations\r\n\t\tvar alignment = {\r\n\t\t\txAlign: existingModel.xAlign,\r\n\t\t\tyAlign: existingModel.yAlign\r\n\t\t};\r\n\t\tvar backgroundPoint = {\r\n\t\t\tx: existingModel.x,\r\n\t\t\ty: existingModel.y\r\n\t\t};\r\n\t\tvar tooltipSize = {\r\n\t\t\twidth: existingModel.width,\r\n\t\t\theight: existingModel.height\r\n\t\t};\r\n\t\tvar tooltipPosition = {\r\n\t\t\tx: existingModel.caretX,\r\n\t\t\ty: existingModel.caretY\r\n\t\t};\r\n\r\n\t\tvar i, len;\r\n\r\n\t\tif (active.length) {\r\n\t\t\tmodel.opacity = 1;\r\n\r\n\t\t\tvar labelColors = [];\r\n\t\t\tvar labelTextColors = [];\r\n\t\t\ttooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);\r\n\r\n\t\t\tvar tooltipItems = [];\r\n\t\t\tfor (i = 0, len = active.length; i < len; ++i) {\r\n\t\t\t\ttooltipItems.push(createTooltipItem(active[i]));\r\n\t\t\t}\r\n\r\n\t\t\t// If the user provided a filter function, use it to modify the tooltip items\r\n\t\t\tif (opts.filter) {\r\n\t\t\t\ttooltipItems = tooltipItems.filter(function(a) {\r\n\t\t\t\t\treturn opts.filter(a, data);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// If the user provided a sorting function, use it to modify the tooltip items\r\n\t\t\tif (opts.itemSort) {\r\n\t\t\t\ttooltipItems = tooltipItems.sort(function(a, b) {\r\n\t\t\t\t\treturn opts.itemSort(a, b, data);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Determine colors for boxes\r\n\t\t\thelpers.each(tooltipItems, function(tooltipItem) {\r\n\t\t\t\tlabelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));\r\n\t\t\t\tlabelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));\r\n\t\t\t});\r\n\r\n\r\n\t\t\t// Build the Text Lines\r\n\t\t\tmodel.title = me.getTitle(tooltipItems, data);\r\n\t\t\tmodel.beforeBody = me.getBeforeBody(tooltipItems, data);\r\n\t\t\tmodel.body = me.getBody(tooltipItems, data);\r\n\t\t\tmodel.afterBody = me.getAfterBody(tooltipItems, data);\r\n\t\t\tmodel.footer = me.getFooter(tooltipItems, data);\r\n\r\n\t\t\t// Initial positioning and colors\r\n\t\t\tmodel.x = tooltipPosition.x;\r\n\t\t\tmodel.y = tooltipPosition.y;\r\n\t\t\tmodel.caretPadding = opts.caretPadding;\r\n\t\t\tmodel.labelColors = labelColors;\r\n\t\t\tmodel.labelTextColors = labelTextColors;\r\n\r\n\t\t\t// data points\r\n\t\t\tmodel.dataPoints = tooltipItems;\r\n\r\n\t\t\t// We need to determine alignment of the tooltip\r\n\t\t\ttooltipSize = getTooltipSize(this, model);\r\n\t\t\talignment = determineAlignment(this, tooltipSize);\r\n\t\t\t// Final Size and Position\r\n\t\t\tbackgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);\r\n\t\t} else {\r\n\t\t\tmodel.opacity = 0;\r\n\t\t}\r\n\r\n\t\tmodel.xAlign = alignment.xAlign;\r\n\t\tmodel.yAlign = alignment.yAlign;\r\n\t\tmodel.x = backgroundPoint.x;\r\n\t\tmodel.y = backgroundPoint.y;\r\n\t\tmodel.width = tooltipSize.width;\r\n\t\tmodel.height = tooltipSize.height;\r\n\r\n\t\t// Point where the caret on the tooltip points to\r\n\t\tmodel.caretX = tooltipPosition.x;\r\n\t\tmodel.caretY = tooltipPosition.y;\r\n\r\n\t\tme._model = model;\r\n\r\n\t\tif (changed && opts.custom) {\r\n\t\t\topts.custom.call(me, model);\r\n\t\t}\r\n\r\n\t\treturn me;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"getBaseModel","start_line":222,"end_line":269,"comment":["*\r\n * Helper to get the reset model for the tooltip\r\n * @param tooltipOpts {Object} the tooltip options\r\n "],"params":["tooltipOpts"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"createTooltipItem","line":590,"func_location":"exports.update","func_start_line":548,"func_end_line":658,"args":[null],"code":"\tupdate: function(changed) {\r\n\t\tvar me = this;\r\n\t\tvar opts = me._options;\r\n\r\n\t\t// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition\r\n\t\t// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time\r\n\t\t// which breaks any animations.\r\n\t\tvar existingModel = me._model;\r\n\t\tvar model = me._model = getBaseModel(opts);\r\n\t\tvar active = me._active;\r\n\r\n\t\tvar data = me._data;\r\n\r\n\t\t// In the case where active.length === 0 we need to keep these at existing values for good animations\r\n\t\tvar alignment = {\r\n\t\t\txAlign: existingModel.xAlign,\r\n\t\t\tyAlign: existingModel.yAlign\r\n\t\t};\r\n\t\tvar backgroundPoint = {\r\n\t\t\tx: existingModel.x,\r\n\t\t\ty: existingModel.y\r\n\t\t};\r\n\t\tvar tooltipSize = {\r\n\t\t\twidth: existingModel.width,\r\n\t\t\theight: existingModel.height\r\n\t\t};\r\n\t\tvar tooltipPosition = {\r\n\t\t\tx: existingModel.caretX,\r\n\t\t\ty: existingModel.caretY\r\n\t\t};\r\n\r\n\t\tvar i, len;\r\n\r\n\t\tif (active.length) {\r\n\t\t\tmodel.opacity = 1;\r\n\r\n\t\t\tvar labelColors = [];\r\n\t\t\tvar labelTextColors = [];\r\n\t\t\ttooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);\r\n\r\n\t\t\tvar tooltipItems = [];\r\n\t\t\tfor (i = 0, len = active.length; i < len; ++i) {\r\n\t\t\t\ttooltipItems.push(createTooltipItem(active[i]));\r\n\t\t\t}\r\n\r\n\t\t\t// If the user provided a filter function, use it to modify the tooltip items\r\n\t\t\tif (opts.filter) {\r\n\t\t\t\ttooltipItems = tooltipItems.filter(function(a) {\r\n\t\t\t\t\treturn opts.filter(a, data);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// If the user provided a sorting function, use it to modify the tooltip items\r\n\t\t\tif (opts.itemSort) {\r\n\t\t\t\ttooltipItems = tooltipItems.sort(function(a, b) {\r\n\t\t\t\t\treturn opts.itemSort(a, b, data);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Determine colors for boxes\r\n\t\t\thelpers.each(tooltipItems, function(tooltipItem) {\r\n\t\t\t\tlabelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));\r\n\t\t\t\tlabelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));\r\n\t\t\t});\r\n\r\n\r\n\t\t\t// Build the Text Lines\r\n\t\t\tmodel.title = me.getTitle(tooltipItems, data);\r\n\t\t\tmodel.beforeBody = me.getBeforeBody(tooltipItems, data);\r\n\t\t\tmodel.body = me.getBody(tooltipItems, data);\r\n\t\t\tmodel.afterBody = me.getAfterBody(tooltipItems, data);\r\n\t\t\tmodel.footer = me.getFooter(tooltipItems, data);\r\n\r\n\t\t\t// Initial positioning and colors\r\n\t\t\tmodel.x = tooltipPosition.x;\r\n\t\t\tmodel.y = tooltipPosition.y;\r\n\t\t\tmodel.caretPadding = opts.caretPadding;\r\n\t\t\tmodel.labelColors = labelColors;\r\n\t\t\tmodel.labelTextColors = labelTextColors;\r\n\r\n\t\t\t// data points\r\n\t\t\tmodel.dataPoints = tooltipItems;\r\n\r\n\t\t\t// We need to determine alignment of the tooltip\r\n\t\t\ttooltipSize = getTooltipSize(this, model);\r\n\t\t\talignment = determineAlignment(this, tooltipSize);\r\n\t\t\t// Final Size and Position\r\n\t\t\tbackgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);\r\n\t\t} else {\r\n\t\t\tmodel.opacity = 0;\r\n\t\t}\r\n\r\n\t\tmodel.xAlign = alignment.xAlign;\r\n\t\tmodel.yAlign = alignment.yAlign;\r\n\t\tmodel.x = backgroundPoint.x;\r\n\t\tmodel.y = backgroundPoint.y;\r\n\t\tmodel.width = tooltipSize.width;\r\n\t\tmodel.height = tooltipSize.height;\r\n\r\n\t\t// Point where the caret on the tooltip points to\r\n\t\tmodel.caretX = tooltipPosition.x;\r\n\t\tmodel.caretY = tooltipPosition.y;\r\n\r\n\t\tme._model = model;\r\n\r\n\t\tif (changed && opts.custom) {\r\n\t\t\topts.custom.call(me, model);\r\n\t\t}\r\n\r\n\t\treturn me;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"createTooltipItem","start_line":202,"end_line":216,"comment":[" Private helper to create a tooltip item model"," @param element : the chart element (point, arc, bar) to create the tooltip item for"," @return : new tooltip item"],"params":["element"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"getTooltipSize","line":632,"func_location":"exports.update","func_start_line":548,"func_end_line":658,"args":[null,"model"],"code":"\tupdate: function(changed) {\r\n\t\tvar me = this;\r\n\t\tvar opts = me._options;\r\n\r\n\t\t// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition\r\n\t\t// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time\r\n\t\t// which breaks any animations.\r\n\t\tvar existingModel = me._model;\r\n\t\tvar model = me._model = getBaseModel(opts);\r\n\t\tvar active = me._active;\r\n\r\n\t\tvar data = me._data;\r\n\r\n\t\t// In the case where active.length === 0 we need to keep these at existing values for good animations\r\n\t\tvar alignment = {\r\n\t\t\txAlign: existingModel.xAlign,\r\n\t\t\tyAlign: existingModel.yAlign\r\n\t\t};\r\n\t\tvar backgroundPoint = {\r\n\t\t\tx: existingModel.x,\r\n\t\t\ty: existingModel.y\r\n\t\t};\r\n\t\tvar tooltipSize = {\r\n\t\t\twidth: existingModel.width,\r\n\t\t\theight: existingModel.height\r\n\t\t};\r\n\t\tvar tooltipPosition = {\r\n\t\t\tx: existingModel.caretX,\r\n\t\t\ty: existingModel.caretY\r\n\t\t};\r\n\r\n\t\tvar i, len;\r\n\r\n\t\tif (active.length) {\r\n\t\t\tmodel.opacity = 1;\r\n\r\n\t\t\tvar labelColors = [];\r\n\t\t\tvar labelTextColors = [];\r\n\t\t\ttooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);\r\n\r\n\t\t\tvar tooltipItems = [];\r\n\t\t\tfor (i = 0, len = active.length; i < len; ++i) {\r\n\t\t\t\ttooltipItems.push(createTooltipItem(active[i]));\r\n\t\t\t}\r\n\r\n\t\t\t// If the user provided a filter function, use it to modify the tooltip items\r\n\t\t\tif (opts.filter) {\r\n\t\t\t\ttooltipItems = tooltipItems.filter(function(a) {\r\n\t\t\t\t\treturn opts.filter(a, data);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// If the user provided a sorting function, use it to modify the tooltip items\r\n\t\t\tif (opts.itemSort) {\r\n\t\t\t\ttooltipItems = tooltipItems.sort(function(a, b) {\r\n\t\t\t\t\treturn opts.itemSort(a, b, data);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Determine colors for boxes\r\n\t\t\thelpers.each(tooltipItems, function(tooltipItem) {\r\n\t\t\t\tlabelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));\r\n\t\t\t\tlabelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));\r\n\t\t\t});\r\n\r\n\r\n\t\t\t// Build the Text Lines\r\n\t\t\tmodel.title = me.getTitle(tooltipItems, data);\r\n\t\t\tmodel.beforeBody = me.getBeforeBody(tooltipItems, data);\r\n\t\t\tmodel.body = me.getBody(tooltipItems, data);\r\n\t\t\tmodel.afterBody = me.getAfterBody(tooltipItems, data);\r\n\t\t\tmodel.footer = me.getFooter(tooltipItems, data);\r\n\r\n\t\t\t// Initial positioning and colors\r\n\t\t\tmodel.x = tooltipPosition.x;\r\n\t\t\tmodel.y = tooltipPosition.y;\r\n\t\t\tmodel.caretPadding = opts.caretPadding;\r\n\t\t\tmodel.labelColors = labelColors;\r\n\t\t\tmodel.labelTextColors = labelTextColors;\r\n\r\n\t\t\t// data points\r\n\t\t\tmodel.dataPoints = tooltipItems;\r\n\r\n\t\t\t// We need to determine alignment of the tooltip\r\n\t\t\ttooltipSize = getTooltipSize(this, model);\r\n\t\t\talignment = determineAlignment(this, tooltipSize);\r\n\t\t\t// Final Size and Position\r\n\t\t\tbackgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);\r\n\t\t} else {\r\n\t\t\tmodel.opacity = 0;\r\n\t\t}\r\n\r\n\t\tmodel.xAlign = alignment.xAlign;\r\n\t\tmodel.yAlign = alignment.yAlign;\r\n\t\tmodel.x = backgroundPoint.x;\r\n\t\tmodel.y = backgroundPoint.y;\r\n\t\tmodel.width = tooltipSize.width;\r\n\t\tmodel.height = tooltipSize.height;\r\n\r\n\t\t// Point where the caret on the tooltip points to\r\n\t\tmodel.caretX = tooltipPosition.x;\r\n\t\tmodel.caretY = tooltipPosition.y;\r\n\r\n\t\tme._model = model;\r\n\r\n\t\tif (changed && opts.custom) {\r\n\t\t\topts.custom.call(me, model);\r\n\t\t}\r\n\r\n\t\treturn me;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"getTooltipSize","start_line":274,"end_line":337,"comment":["*\r\n * Get the size of the tooltip\r\n "],"params":["tooltip","model"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"determineAlignment","line":633,"func_location":"exports.update","func_start_line":548,"func_end_line":658,"args":[null,"tooltipSize"],"code":"\tupdate: function(changed) {\r\n\t\tvar me = this;\r\n\t\tvar opts = me._options;\r\n\r\n\t\t// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition\r\n\t\t// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time\r\n\t\t// which breaks any animations.\r\n\t\tvar existingModel = me._model;\r\n\t\tvar model = me._model = getBaseModel(opts);\r\n\t\tvar active = me._active;\r\n\r\n\t\tvar data = me._data;\r\n\r\n\t\t// In the case where active.length === 0 we need to keep these at existing values for good animations\r\n\t\tvar alignment = {\r\n\t\t\txAlign: existingModel.xAlign,\r\n\t\t\tyAlign: existingModel.yAlign\r\n\t\t};\r\n\t\tvar backgroundPoint = {\r\n\t\t\tx: existingModel.x,\r\n\t\t\ty: existingModel.y\r\n\t\t};\r\n\t\tvar tooltipSize = {\r\n\t\t\twidth: existingModel.width,\r\n\t\t\theight: existingModel.height\r\n\t\t};\r\n\t\tvar tooltipPosition = {\r\n\t\t\tx: existingModel.caretX,\r\n\t\t\ty: existingModel.caretY\r\n\t\t};\r\n\r\n\t\tvar i, len;\r\n\r\n\t\tif (active.length) {\r\n\t\t\tmodel.opacity = 1;\r\n\r\n\t\t\tvar labelColors = [];\r\n\t\t\tvar labelTextColors = [];\r\n\t\t\ttooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);\r\n\r\n\t\t\tvar tooltipItems = [];\r\n\t\t\tfor (i = 0, len = active.length; i < len; ++i) {\r\n\t\t\t\ttooltipItems.push(createTooltipItem(active[i]));\r\n\t\t\t}\r\n\r\n\t\t\t// If the user provided a filter function, use it to modify the tooltip items\r\n\t\t\tif (opts.filter) {\r\n\t\t\t\ttooltipItems = tooltipItems.filter(function(a) {\r\n\t\t\t\t\treturn opts.filter(a, data);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// If the user provided a sorting function, use it to modify the tooltip items\r\n\t\t\tif (opts.itemSort) {\r\n\t\t\t\ttooltipItems = tooltipItems.sort(function(a, b) {\r\n\t\t\t\t\treturn opts.itemSort(a, b, data);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Determine colors for boxes\r\n\t\t\thelpers.each(tooltipItems, function(tooltipItem) {\r\n\t\t\t\tlabelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));\r\n\t\t\t\tlabelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));\r\n\t\t\t});\r\n\r\n\r\n\t\t\t// Build the Text Lines\r\n\t\t\tmodel.title = me.getTitle(tooltipItems, data);\r\n\t\t\tmodel.beforeBody = me.getBeforeBody(tooltipItems, data);\r\n\t\t\tmodel.body = me.getBody(tooltipItems, data);\r\n\t\t\tmodel.afterBody = me.getAfterBody(tooltipItems, data);\r\n\t\t\tmodel.footer = me.getFooter(tooltipItems, data);\r\n\r\n\t\t\t// Initial positioning and colors\r\n\t\t\tmodel.x = tooltipPosition.x;\r\n\t\t\tmodel.y = tooltipPosition.y;\r\n\t\t\tmodel.caretPadding = opts.caretPadding;\r\n\t\t\tmodel.labelColors = labelColors;\r\n\t\t\tmodel.labelTextColors = labelTextColors;\r\n\r\n\t\t\t// data points\r\n\t\t\tmodel.dataPoints = tooltipItems;\r\n\r\n\t\t\t// We need to determine alignment of the tooltip\r\n\t\t\ttooltipSize = getTooltipSize(this, model);\r\n\t\t\talignment = determineAlignment(this, tooltipSize);\r\n\t\t\t// Final Size and Position\r\n\t\t\tbackgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);\r\n\t\t} else {\r\n\t\t\tmodel.opacity = 0;\r\n\t\t}\r\n\r\n\t\tmodel.xAlign = alignment.xAlign;\r\n\t\tmodel.yAlign = alignment.yAlign;\r\n\t\tmodel.x = backgroundPoint.x;\r\n\t\tmodel.y = backgroundPoint.y;\r\n\t\tmodel.width = tooltipSize.width;\r\n\t\tmodel.height = tooltipSize.height;\r\n\r\n\t\t// Point where the caret on the tooltip points to\r\n\t\tmodel.caretX = tooltipPosition.x;\r\n\t\tmodel.caretY = tooltipPosition.y;\r\n\r\n\t\tme._model = model;\r\n\r\n\t\tif (changed && opts.custom) {\r\n\t\t\topts.custom.call(me, model);\r\n\t\t}\r\n\r\n\t\treturn me;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"determineAlignment","start_line":342,"end_line":410,"comment":["*\r\n * Helper to get the alignment of a tooltip given the size\r\n "],"params":["tooltip","size"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"getBackgroundPoint","line":635,"func_location":"exports.update","func_start_line":548,"func_end_line":658,"args":["model","tooltipSize","alignment","me._chart"],"code":"\tupdate: function(changed) {\r\n\t\tvar me = this;\r\n\t\tvar opts = me._options;\r\n\r\n\t\t// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition\r\n\t\t// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time\r\n\t\t// which breaks any animations.\r\n\t\tvar existingModel = me._model;\r\n\t\tvar model = me._model = getBaseModel(opts);\r\n\t\tvar active = me._active;\r\n\r\n\t\tvar data = me._data;\r\n\r\n\t\t// In the case where active.length === 0 we need to keep these at existing values for good animations\r\n\t\tvar alignment = {\r\n\t\t\txAlign: existingModel.xAlign,\r\n\t\t\tyAlign: existingModel.yAlign\r\n\t\t};\r\n\t\tvar backgroundPoint = {\r\n\t\t\tx: existingModel.x,\r\n\t\t\ty: existingModel.y\r\n\t\t};\r\n\t\tvar tooltipSize = {\r\n\t\t\twidth: existingModel.width,\r\n\t\t\theight: existingModel.height\r\n\t\t};\r\n\t\tvar tooltipPosition = {\r\n\t\t\tx: existingModel.caretX,\r\n\t\t\ty: existingModel.caretY\r\n\t\t};\r\n\r\n\t\tvar i, len;\r\n\r\n\t\tif (active.length) {\r\n\t\t\tmodel.opacity = 1;\r\n\r\n\t\t\tvar labelColors = [];\r\n\t\t\tvar labelTextColors = [];\r\n\t\t\ttooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);\r\n\r\n\t\t\tvar tooltipItems = [];\r\n\t\t\tfor (i = 0, len = active.length; i < len; ++i) {\r\n\t\t\t\ttooltipItems.push(createTooltipItem(active[i]));\r\n\t\t\t}\r\n\r\n\t\t\t// If the user provided a filter function, use it to modify the tooltip items\r\n\t\t\tif (opts.filter) {\r\n\t\t\t\ttooltipItems = tooltipItems.filter(function(a) {\r\n\t\t\t\t\treturn opts.filter(a, data);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// If the user provided a sorting function, use it to modify the tooltip items\r\n\t\t\tif (opts.itemSort) {\r\n\t\t\t\ttooltipItems = tooltipItems.sort(function(a, b) {\r\n\t\t\t\t\treturn opts.itemSort(a, b, data);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Determine colors for boxes\r\n\t\t\thelpers.each(tooltipItems, function(tooltipItem) {\r\n\t\t\t\tlabelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));\r\n\t\t\t\tlabelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));\r\n\t\t\t});\r\n\r\n\r\n\t\t\t// Build the Text Lines\r\n\t\t\tmodel.title = me.getTitle(tooltipItems, data);\r\n\t\t\tmodel.beforeBody = me.getBeforeBody(tooltipItems, data);\r\n\t\t\tmodel.body = me.getBody(tooltipItems, data);\r\n\t\t\tmodel.afterBody = me.getAfterBody(tooltipItems, data);\r\n\t\t\tmodel.footer = me.getFooter(tooltipItems, data);\r\n\r\n\t\t\t// Initial positioning and colors\r\n\t\t\tmodel.x = tooltipPosition.x;\r\n\t\t\tmodel.y = tooltipPosition.y;\r\n\t\t\tmodel.caretPadding = opts.caretPadding;\r\n\t\t\tmodel.labelColors = labelColors;\r\n\t\t\tmodel.labelTextColors = labelTextColors;\r\n\r\n\t\t\t// data points\r\n\t\t\tmodel.dataPoints = tooltipItems;\r\n\r\n\t\t\t// We need to determine alignment of the tooltip\r\n\t\t\ttooltipSize = getTooltipSize(this, model);\r\n\t\t\talignment = determineAlignment(this, tooltipSize);\r\n\t\t\t// Final Size and Position\r\n\t\t\tbackgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);\r\n\t\t} else {\r\n\t\t\tmodel.opacity = 0;\r\n\t\t}\r\n\r\n\t\tmodel.xAlign = alignment.xAlign;\r\n\t\tmodel.yAlign = alignment.yAlign;\r\n\t\tmodel.x = backgroundPoint.x;\r\n\t\tmodel.y = backgroundPoint.y;\r\n\t\tmodel.width = tooltipSize.width;\r\n\t\tmodel.height = tooltipSize.height;\r\n\r\n\t\t// Point where the caret on the tooltip points to\r\n\t\tmodel.caretX = tooltipPosition.x;\r\n\t\tmodel.caretY = tooltipPosition.y;\r\n\r\n\t\tme._model = model;\r\n\r\n\t\tif (changed && opts.custom) {\r\n\t\t\topts.custom.call(me, model);\r\n\t\t}\r\n\r\n\t\treturn me;\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.tooltip.js","name":"getBackgroundPoint","start_line":415,"end_line":464,"comment":["*\r\n * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\r\n "],"params":["vm","size","alignment","chart"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.line.js","name":"lineEnabled","line":48,"func_location":"update","func_start_line":38,"func_end_line":100,"args":["dataset","options"],"code":"\tupdate: function(reset) {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar line = meta.dataset;\r\n\t\tvar points = meta.data || [];\r\n\t\tvar options = me.chart.options;\r\n\t\tvar lineElementOptions = options.elements.line;\r\n\t\tvar scale = me.getScaleForId(meta.yAxisID);\r\n\t\tvar i, ilen, custom;\r\n\t\tvar dataset = me.getDataset();\r\n\t\tvar showLine = lineEnabled(dataset, options);\r\n\r\n\t\t// Update Line\r\n\t\tif (showLine) {\r\n\t\t\tcustom = line.custom || {};\r\n\r\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\r\n\t\t\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\r\n\t\t\t\tdataset.lineTension = dataset.tension;\r\n\t\t\t}\r\n\r\n\t\t\t// Utility\r\n\t\t\tline._scale = scale;\r\n\t\t\tline._datasetIndex = me.index;\r\n\t\t\t// Data\r\n\t\t\tline._children = points;\r\n\t\t\t// Model\r\n\t\t\tline._model = {\r\n\t\t\t\t// Appearance\r\n\t\t\t\t// The default behavior of lines is to break at null values, according\r\n\t\t\t\t// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158\r\n\t\t\t\t// This option gives lines the ability to span gaps\r\n\t\t\t\tspanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,\r\n\t\t\t\ttension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),\r\n\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),\r\n\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),\r\n\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),\r\n\t\t\t\tborderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),\r\n\t\t\t\tborderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),\r\n\t\t\t\tborderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),\r\n\t\t\t\tborderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),\r\n\t\t\t\tfill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),\r\n\t\t\t\tsteppedLine: custom.steppedLine ? custom.steppedLine : helpers.valueOrDefault(dataset.steppedLine, lineElementOptions.stepped),\r\n\t\t\t\tcubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.valueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode),\r\n\t\t\t};\r\n\r\n\t\t\tline.pivot();\r\n\t\t}\r\n\r\n\t\t// Update Points\r\n\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\r\n\t\t\tme.updateElement(points[i], i, reset);\r\n\t\t}\r\n\r\n\t\tif (showLine && line._model.tension !== 0) {\r\n\t\t\tme.updateBezierControlPoints();\r\n\t\t}\r\n\r\n\t\t// Now pivot the point for animation\r\n\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\r\n\t\t\tpoints[i].pivot();\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.line.js","name":"lineEnabled","start_line":28,"end_line":30,"comment":[],"params":["dataset","options"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.layouts.js","name":"filterByPosition","line":121,"func_location":"module.exports.update","func_start_line":109,"func_end_line":418,"args":["chart.boxes",{"type":"string"}],"comment":["*\r\n\t * Fits boxes of the given chart into the given size by having each box measure itself\r\n\t * then running a fitting algorithm\r\n\t * @param {Chart} chart - the chart\r\n\t * @param {Number} width - the width to fit into\r\n\t * @param {Number} height - the height to fit into\r\n\t "],"code":"\tupdate: function(chart, width, height) {\r\n\t\tif (!chart) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar layoutOptions = chart.options.layout || {};\r\n\t\tvar padding = helpers.options.toPadding(layoutOptions.padding);\r\n\t\tvar leftPadding = padding.left;\r\n\t\tvar rightPadding = padding.right;\r\n\t\tvar topPadding = padding.top;\r\n\t\tvar bottomPadding = padding.bottom;\r\n\r\n\t\tvar leftBoxes = filterByPosition(chart.boxes, 'left');\r\n\t\tvar rightBoxes = filterByPosition(chart.boxes, 'right');\r\n\t\tvar topBoxes = filterByPosition(chart.boxes, 'top');\r\n\t\tvar bottomBoxes = filterByPosition(chart.boxes, 'bottom');\r\n\t\tvar chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');\r\n\r\n\t\t// Sort boxes by weight. A higher weight is further away from the chart area\r\n\t\tsortByWeight(leftBoxes, true);\r\n\t\tsortByWeight(rightBoxes, false);\r\n\t\tsortByWeight(topBoxes, true);\r\n\t\tsortByWeight(bottomBoxes, false);\r\n\r\n\t\t// Essentially we now have any number of boxes on each of the 4 sides.\r\n\t\t// Our canvas looks like the following.\r\n\t\t// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\r\n\t\t// B1 is the bottom axis\r\n\t\t// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\r\n\t\t// These locations are single-box locations only, when trying to register a chartArea location that is already taken,\r\n\t\t// an error will be thrown.\r\n\t\t//\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |                  T1 (Full Width)                   |\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |    |    |                 T2                  |    |\r\n\t\t// |    |----|-------------------------------------|----|\r\n\t\t// |    |    | C1 |                           | C2 |    |\r\n\t\t// |    |    |----|                           |----|    |\r\n\t\t// |    |    |                                     |    |\r\n\t\t// | L1 | L2 |           ChartArea (C0)            | R1 |\r\n\t\t// |    |    |                                     |    |\r\n\t\t// |    |    |----|                           |----|    |\r\n\t\t// |    |    | C3 |                           | C4 |    |\r\n\t\t// |    |----|-------------------------------------|----|\r\n\t\t// |    |    |                 B1                  |    |\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |                  B2 (Full Width)                   |\r\n\t\t// |----------------------------------------------------|\r\n\t\t//\r\n\t\t// What we do to find the best sizing, we do the following\r\n\t\t// 1. Determine the minimum size of the chart area.\r\n\t\t// 2. Split the remaining width equally between each vertical axis\r\n\t\t// 3. Split the remaining height equally between each horizontal axis\r\n\t\t// 4. Give each layout the maximum size it can be. The layout will return it's minimum size\r\n\t\t// 5. Adjust the sizes of each axis based on it's minimum reported size.\r\n\t\t// 6. Refit each axis\r\n\t\t// 7. Position each axis in the final location\r\n\t\t// 8. Tell the chart the final location of the chart area\r\n\t\t// 9. Tell any axes that overlay the chart area the positions of the chart area\r\n\r\n\t\t// Step 1\r\n\t\tvar chartWidth = width - leftPadding - rightPadding;\r\n\t\tvar chartHeight = height - topPadding - bottomPadding;\r\n\t\tvar chartAreaWidth = chartWidth / 2; // min 50%\r\n\t\tvar chartAreaHeight = chartHeight / 2; // min 50%\r\n\r\n\t\t// Step 2\r\n\t\tvar verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);\r\n\r\n\t\t// Step 3\r\n\t\tvar horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);\r\n\r\n\t\t// Step 4\r\n\t\tvar maxChartAreaWidth = chartWidth;\r\n\t\tvar maxChartAreaHeight = chartHeight;\r\n\t\tvar minBoxSizes = [];\r\n\r\n\t\tfunction getMinimumBoxSize(box) {\r\n\t\t\tvar minSize;\r\n\t\t\tvar isHorizontal = box.isHorizontal();\r\n\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\tminSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);\r\n\t\t\t\tmaxChartAreaHeight -= minSize.height;\r\n\t\t\t} else {\r\n\t\t\t\tminSize = box.update(verticalBoxWidth, maxChartAreaHeight);\r\n\t\t\t\tmaxChartAreaWidth -= minSize.width;\r\n\t\t\t}\r\n\r\n\t\t\tminBoxSizes.push({\r\n\t\t\t\thorizontal: isHorizontal,\r\n\t\t\t\tminSize: minSize,\r\n\t\t\t\tbox: box,\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);\r\n\r\n\t\t// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)\r\n\t\tvar maxHorizontalLeftPadding = 0;\r\n\t\tvar maxHorizontalRightPadding = 0;\r\n\t\tvar maxVerticalTopPadding = 0;\r\n\t\tvar maxVerticalBottomPadding = 0;\r\n\r\n\t\thelpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {\r\n\t\t\tif (horizontalBox.getPadding) {\r\n\t\t\t\tvar boxPadding = horizontalBox.getPadding();\r\n\t\t\t\tmaxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);\r\n\t\t\t\tmaxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {\r\n\t\t\tif (verticalBox.getPadding) {\r\n\t\t\t\tvar boxPadding = verticalBox.getPadding();\r\n\t\t\t\tmaxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);\r\n\t\t\t\tmaxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\r\n\t\t// be if the axes are drawn at their minimum sizes.\r\n\t\t// Steps 5 & 6\r\n\t\tvar totalLeftBoxesWidth = leftPadding;\r\n\t\tvar totalRightBoxesWidth = rightPadding;\r\n\t\tvar totalTopBoxesHeight = topPadding;\r\n\t\tvar totalBottomBoxesHeight = bottomPadding;\r\n\r\n\t\t// Function to fit a box\r\n\t\tfunction fitBox(box) {\r\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {\r\n\t\t\t\treturn minBox.box === box;\r\n\t\t\t});\r\n\r\n\t\t\tif (minBoxSize) {\r\n\t\t\t\tif (box.isHorizontal()) {\r\n\t\t\t\t\tvar scaleMargin = {\r\n\t\t\t\t\t\tleft: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),\r\n\t\t\t\t\t\tright: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),\r\n\t\t\t\t\t\ttop: 0,\r\n\t\t\t\t\t\tbottom: 0\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\r\n\t\t\t\t\t// on the margin. Sometimes they need to increase in size slightly\r\n\t\t\t\t\tbox.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Update, and calculate the left and right margins for the horizontal boxes\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes), fitBox);\r\n\r\n\t\thelpers.each(leftBoxes, function(box) {\r\n\t\t\ttotalLeftBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\thelpers.each(rightBoxes, function(box) {\r\n\t\t\ttotalRightBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\t// Set the Left and Right margins for the horizontal boxes\r\n\t\thelpers.each(topBoxes.concat(bottomBoxes), fitBox);\r\n\r\n\t\t// Figure out how much margin is on the top and bottom of the vertical boxes\r\n\t\thelpers.each(topBoxes, function(box) {\r\n\t\t\ttotalTopBoxesHeight += box.height;\r\n\t\t});\r\n\r\n\t\thelpers.each(bottomBoxes, function(box) {\r\n\t\t\ttotalBottomBoxesHeight += box.height;\r\n\t\t});\r\n\r\n\t\tfunction finalFitVerticalBox(box) {\r\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {\r\n\t\t\t\treturn minSize.box === box;\r\n\t\t\t});\r\n\r\n\t\t\tvar scaleMargin = {\r\n\t\t\t\tleft: 0,\r\n\t\t\t\tright: 0,\r\n\t\t\t\ttop: totalTopBoxesHeight,\r\n\t\t\t\tbottom: totalBottomBoxesHeight\r\n\t\t\t};\r\n\r\n\t\t\tif (minBoxSize) {\r\n\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Let the left layout know the final margin\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);\r\n\r\n\t\t// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\r\n\t\ttotalLeftBoxesWidth = leftPadding;\r\n\t\ttotalRightBoxesWidth = rightPadding;\r\n\t\ttotalTopBoxesHeight = topPadding;\r\n\t\ttotalBottomBoxesHeight = bottomPadding;\r\n\r\n\t\thelpers.each(leftBoxes, function(box) {\r\n\t\t\ttotalLeftBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\thelpers.each(rightBoxes, function(box) {\r\n\t\t\ttotalRightBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\thelpers.each(topBoxes, function(box) {\r\n\t\t\ttotalTopBoxesHeight += box.height;\r\n\t\t});\r\n\t\thelpers.each(bottomBoxes, function(box) {\r\n\t\t\ttotalBottomBoxesHeight += box.height;\r\n\t\t});\r\n\r\n\t\t// We may be adding some padding to account for rotated x axis labels\r\n\t\tvar leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);\r\n\t\ttotalLeftBoxesWidth += leftPaddingAddition;\r\n\t\ttotalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);\r\n\r\n\t\tvar topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);\r\n\t\ttotalTopBoxesHeight += topPaddingAddition;\r\n\t\ttotalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);\r\n\r\n\t\t// Figure out if our chart area changed. This would occur if the dataset layout label rotation\r\n\t\t// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\r\n\t\t// without calling `fit` again\r\n\t\tvar newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;\r\n\t\tvar newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;\r\n\r\n\t\tif (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\r\n\t\t\thelpers.each(leftBoxes, function(box) {\r\n\t\t\t\tbox.height = newMaxChartAreaHeight;\r\n\t\t\t});\r\n\r\n\t\t\thelpers.each(rightBoxes, function(box) {\r\n\t\t\t\tbox.height = newMaxChartAreaHeight;\r\n\t\t\t});\r\n\r\n\t\t\thelpers.each(topBoxes, function(box) {\r\n\t\t\t\tif (!box.fullWidth) {\r\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\thelpers.each(bottomBoxes, function(box) {\r\n\t\t\t\tif (!box.fullWidth) {\r\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tmaxChartAreaHeight = newMaxChartAreaHeight;\r\n\t\t\tmaxChartAreaWidth = newMaxChartAreaWidth;\r\n\t\t}\r\n\r\n\t\t// Step 7 - Position the boxes\r\n\t\tvar left = leftPadding + leftPaddingAddition;\r\n\t\tvar top = topPadding + topPaddingAddition;\r\n\r\n\t\tfunction placeBox(box) {\r\n\t\t\tif (box.isHorizontal()) {\r\n\t\t\t\tbox.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;\r\n\t\t\t\tbox.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;\r\n\t\t\t\tbox.top = top;\r\n\t\t\t\tbox.bottom = top + box.height;\r\n\r\n\t\t\t\t// Move to next point\r\n\t\t\t\ttop = box.bottom;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbox.left = left;\r\n\t\t\t\tbox.right = left + box.width;\r\n\t\t\t\tbox.top = totalTopBoxesHeight;\r\n\t\t\t\tbox.bottom = totalTopBoxesHeight + maxChartAreaHeight;\r\n\r\n\t\t\t\t// Move to next point\r\n\t\t\t\tleft = box.right;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\thelpers.each(leftBoxes.concat(topBoxes), placeBox);\r\n\r\n\t\t// Account for chart width and height\r\n\t\tleft += maxChartAreaWidth;\r\n\t\ttop += maxChartAreaHeight;\r\n\r\n\t\thelpers.each(rightBoxes, placeBox);\r\n\t\thelpers.each(bottomBoxes, placeBox);\r\n\r\n\t\t// Step 8\r\n\t\tchart.chartArea = {\r\n\t\t\tleft: totalLeftBoxesWidth,\r\n\t\t\ttop: totalTopBoxesHeight,\r\n\t\t\tright: totalLeftBoxesWidth + maxChartAreaWidth,\r\n\t\t\tbottom: totalTopBoxesHeight + maxChartAreaHeight\r\n\t\t};\r\n\r\n\t\t// Step 9\r\n\t\thelpers.each(chartAreaBoxes, function(box) {\r\n\t\t\tbox.left = chart.chartArea.left;\r\n\t\t\tbox.top = chart.chartArea.top;\r\n\t\t\tbox.right = chart.chartArea.right;\r\n\t\t\tbox.bottom = chart.chartArea.bottom;\r\n\r\n\t\t\tbox.update(maxChartAreaWidth, maxChartAreaHeight);\r\n\t\t});\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.layouts.js","name":"filterByPosition","start_line":5,"end_line":9,"comment":[],"params":["array","position"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.layouts.js","name":"filterByPosition","line":122,"func_location":"module.exports.update","func_start_line":109,"func_end_line":418,"args":["chart.boxes",{"type":"string"}],"comment":["*\r\n\t * Fits boxes of the given chart into the given size by having each box measure itself\r\n\t * then running a fitting algorithm\r\n\t * @param {Chart} chart - the chart\r\n\t * @param {Number} width - the width to fit into\r\n\t * @param {Number} height - the height to fit into\r\n\t "],"code":"\tupdate: function(chart, width, height) {\r\n\t\tif (!chart) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar layoutOptions = chart.options.layout || {};\r\n\t\tvar padding = helpers.options.toPadding(layoutOptions.padding);\r\n\t\tvar leftPadding = padding.left;\r\n\t\tvar rightPadding = padding.right;\r\n\t\tvar topPadding = padding.top;\r\n\t\tvar bottomPadding = padding.bottom;\r\n\r\n\t\tvar leftBoxes = filterByPosition(chart.boxes, 'left');\r\n\t\tvar rightBoxes = filterByPosition(chart.boxes, 'right');\r\n\t\tvar topBoxes = filterByPosition(chart.boxes, 'top');\r\n\t\tvar bottomBoxes = filterByPosition(chart.boxes, 'bottom');\r\n\t\tvar chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');\r\n\r\n\t\t// Sort boxes by weight. A higher weight is further away from the chart area\r\n\t\tsortByWeight(leftBoxes, true);\r\n\t\tsortByWeight(rightBoxes, false);\r\n\t\tsortByWeight(topBoxes, true);\r\n\t\tsortByWeight(bottomBoxes, false);\r\n\r\n\t\t// Essentially we now have any number of boxes on each of the 4 sides.\r\n\t\t// Our canvas looks like the following.\r\n\t\t// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\r\n\t\t// B1 is the bottom axis\r\n\t\t// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\r\n\t\t// These locations are single-box locations only, when trying to register a chartArea location that is already taken,\r\n\t\t// an error will be thrown.\r\n\t\t//\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |                  T1 (Full Width)                   |\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |    |    |                 T2                  |    |\r\n\t\t// |    |----|-------------------------------------|----|\r\n\t\t// |    |    | C1 |                           | C2 |    |\r\n\t\t// |    |    |----|                           |----|    |\r\n\t\t// |    |    |                                     |    |\r\n\t\t// | L1 | L2 |           ChartArea (C0)            | R1 |\r\n\t\t// |    |    |                                     |    |\r\n\t\t// |    |    |----|                           |----|    |\r\n\t\t// |    |    | C3 |                           | C4 |    |\r\n\t\t// |    |----|-------------------------------------|----|\r\n\t\t// |    |    |                 B1                  |    |\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |                  B2 (Full Width)                   |\r\n\t\t// |----------------------------------------------------|\r\n\t\t//\r\n\t\t// What we do to find the best sizing, we do the following\r\n\t\t// 1. Determine the minimum size of the chart area.\r\n\t\t// 2. Split the remaining width equally between each vertical axis\r\n\t\t// 3. Split the remaining height equally between each horizontal axis\r\n\t\t// 4. Give each layout the maximum size it can be. The layout will return it's minimum size\r\n\t\t// 5. Adjust the sizes of each axis based on it's minimum reported size.\r\n\t\t// 6. Refit each axis\r\n\t\t// 7. Position each axis in the final location\r\n\t\t// 8. Tell the chart the final location of the chart area\r\n\t\t// 9. Tell any axes that overlay the chart area the positions of the chart area\r\n\r\n\t\t// Step 1\r\n\t\tvar chartWidth = width - leftPadding - rightPadding;\r\n\t\tvar chartHeight = height - topPadding - bottomPadding;\r\n\t\tvar chartAreaWidth = chartWidth / 2; // min 50%\r\n\t\tvar chartAreaHeight = chartHeight / 2; // min 50%\r\n\r\n\t\t// Step 2\r\n\t\tvar verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);\r\n\r\n\t\t// Step 3\r\n\t\tvar horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);\r\n\r\n\t\t// Step 4\r\n\t\tvar maxChartAreaWidth = chartWidth;\r\n\t\tvar maxChartAreaHeight = chartHeight;\r\n\t\tvar minBoxSizes = [];\r\n\r\n\t\tfunction getMinimumBoxSize(box) {\r\n\t\t\tvar minSize;\r\n\t\t\tvar isHorizontal = box.isHorizontal();\r\n\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\tminSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);\r\n\t\t\t\tmaxChartAreaHeight -= minSize.height;\r\n\t\t\t} else {\r\n\t\t\t\tminSize = box.update(verticalBoxWidth, maxChartAreaHeight);\r\n\t\t\t\tmaxChartAreaWidth -= minSize.width;\r\n\t\t\t}\r\n\r\n\t\t\tminBoxSizes.push({\r\n\t\t\t\thorizontal: isHorizontal,\r\n\t\t\t\tminSize: minSize,\r\n\t\t\t\tbox: box,\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);\r\n\r\n\t\t// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)\r\n\t\tvar maxHorizontalLeftPadding = 0;\r\n\t\tvar maxHorizontalRightPadding = 0;\r\n\t\tvar maxVerticalTopPadding = 0;\r\n\t\tvar maxVerticalBottomPadding = 0;\r\n\r\n\t\thelpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {\r\n\t\t\tif (horizontalBox.getPadding) {\r\n\t\t\t\tvar boxPadding = horizontalBox.getPadding();\r\n\t\t\t\tmaxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);\r\n\t\t\t\tmaxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {\r\n\t\t\tif (verticalBox.getPadding) {\r\n\t\t\t\tvar boxPadding = verticalBox.getPadding();\r\n\t\t\t\tmaxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);\r\n\t\t\t\tmaxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\r\n\t\t// be if the axes are drawn at their minimum sizes.\r\n\t\t// Steps 5 & 6\r\n\t\tvar totalLeftBoxesWidth = leftPadding;\r\n\t\tvar totalRightBoxesWidth = rightPadding;\r\n\t\tvar totalTopBoxesHeight = topPadding;\r\n\t\tvar totalBottomBoxesHeight = bottomPadding;\r\n\r\n\t\t// Function to fit a box\r\n\t\tfunction fitBox(box) {\r\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {\r\n\t\t\t\treturn minBox.box === box;\r\n\t\t\t});\r\n\r\n\t\t\tif (minBoxSize) {\r\n\t\t\t\tif (box.isHorizontal()) {\r\n\t\t\t\t\tvar scaleMargin = {\r\n\t\t\t\t\t\tleft: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),\r\n\t\t\t\t\t\tright: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),\r\n\t\t\t\t\t\ttop: 0,\r\n\t\t\t\t\t\tbottom: 0\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\r\n\t\t\t\t\t// on the margin. Sometimes they need to increase in size slightly\r\n\t\t\t\t\tbox.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Update, and calculate the left and right margins for the horizontal boxes\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes), fitBox);\r\n\r\n\t\thelpers.each(leftBoxes, function(box) {\r\n\t\t\ttotalLeftBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\thelpers.each(rightBoxes, function(box) {\r\n\t\t\ttotalRightBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\t// Set the Left and Right margins for the horizontal boxes\r\n\t\thelpers.each(topBoxes.concat(bottomBoxes), fitBox);\r\n\r\n\t\t// Figure out how much margin is on the top and bottom of the vertical boxes\r\n\t\thelpers.each(topBoxes, function(box) {\r\n\t\t\ttotalTopBoxesHeight += box.height;\r\n\t\t});\r\n\r\n\t\thelpers.each(bottomBoxes, function(box) {\r\n\t\t\ttotalBottomBoxesHeight += box.height;\r\n\t\t});\r\n\r\n\t\tfunction finalFitVerticalBox(box) {\r\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {\r\n\t\t\t\treturn minSize.box === box;\r\n\t\t\t});\r\n\r\n\t\t\tvar scaleMargin = {\r\n\t\t\t\tleft: 0,\r\n\t\t\t\tright: 0,\r\n\t\t\t\ttop: totalTopBoxesHeight,\r\n\t\t\t\tbottom: totalBottomBoxesHeight\r\n\t\t\t};\r\n\r\n\t\t\tif (minBoxSize) {\r\n\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Let the left layout know the final margin\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);\r\n\r\n\t\t// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\r\n\t\ttotalLeftBoxesWidth = leftPadding;\r\n\t\ttotalRightBoxesWidth = rightPadding;\r\n\t\ttotalTopBoxesHeight = topPadding;\r\n\t\ttotalBottomBoxesHeight = bottomPadding;\r\n\r\n\t\thelpers.each(leftBoxes, function(box) {\r\n\t\t\ttotalLeftBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\thelpers.each(rightBoxes, function(box) {\r\n\t\t\ttotalRightBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\thelpers.each(topBoxes, function(box) {\r\n\t\t\ttotalTopBoxesHeight += box.height;\r\n\t\t});\r\n\t\thelpers.each(bottomBoxes, function(box) {\r\n\t\t\ttotalBottomBoxesHeight += box.height;\r\n\t\t});\r\n\r\n\t\t// We may be adding some padding to account for rotated x axis labels\r\n\t\tvar leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);\r\n\t\ttotalLeftBoxesWidth += leftPaddingAddition;\r\n\t\ttotalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);\r\n\r\n\t\tvar topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);\r\n\t\ttotalTopBoxesHeight += topPaddingAddition;\r\n\t\ttotalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);\r\n\r\n\t\t// Figure out if our chart area changed. This would occur if the dataset layout label rotation\r\n\t\t// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\r\n\t\t// without calling `fit` again\r\n\t\tvar newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;\r\n\t\tvar newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;\r\n\r\n\t\tif (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\r\n\t\t\thelpers.each(leftBoxes, function(box) {\r\n\t\t\t\tbox.height = newMaxChartAreaHeight;\r\n\t\t\t});\r\n\r\n\t\t\thelpers.each(rightBoxes, function(box) {\r\n\t\t\t\tbox.height = newMaxChartAreaHeight;\r\n\t\t\t});\r\n\r\n\t\t\thelpers.each(topBoxes, function(box) {\r\n\t\t\t\tif (!box.fullWidth) {\r\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\thelpers.each(bottomBoxes, function(box) {\r\n\t\t\t\tif (!box.fullWidth) {\r\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tmaxChartAreaHeight = newMaxChartAreaHeight;\r\n\t\t\tmaxChartAreaWidth = newMaxChartAreaWidth;\r\n\t\t}\r\n\r\n\t\t// Step 7 - Position the boxes\r\n\t\tvar left = leftPadding + leftPaddingAddition;\r\n\t\tvar top = topPadding + topPaddingAddition;\r\n\r\n\t\tfunction placeBox(box) {\r\n\t\t\tif (box.isHorizontal()) {\r\n\t\t\t\tbox.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;\r\n\t\t\t\tbox.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;\r\n\t\t\t\tbox.top = top;\r\n\t\t\t\tbox.bottom = top + box.height;\r\n\r\n\t\t\t\t// Move to next point\r\n\t\t\t\ttop = box.bottom;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbox.left = left;\r\n\t\t\t\tbox.right = left + box.width;\r\n\t\t\t\tbox.top = totalTopBoxesHeight;\r\n\t\t\t\tbox.bottom = totalTopBoxesHeight + maxChartAreaHeight;\r\n\r\n\t\t\t\t// Move to next point\r\n\t\t\t\tleft = box.right;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\thelpers.each(leftBoxes.concat(topBoxes), placeBox);\r\n\r\n\t\t// Account for chart width and height\r\n\t\tleft += maxChartAreaWidth;\r\n\t\ttop += maxChartAreaHeight;\r\n\r\n\t\thelpers.each(rightBoxes, placeBox);\r\n\t\thelpers.each(bottomBoxes, placeBox);\r\n\r\n\t\t// Step 8\r\n\t\tchart.chartArea = {\r\n\t\t\tleft: totalLeftBoxesWidth,\r\n\t\t\ttop: totalTopBoxesHeight,\r\n\t\t\tright: totalLeftBoxesWidth + maxChartAreaWidth,\r\n\t\t\tbottom: totalTopBoxesHeight + maxChartAreaHeight\r\n\t\t};\r\n\r\n\t\t// Step 9\r\n\t\thelpers.each(chartAreaBoxes, function(box) {\r\n\t\t\tbox.left = chart.chartArea.left;\r\n\t\t\tbox.top = chart.chartArea.top;\r\n\t\t\tbox.right = chart.chartArea.right;\r\n\t\t\tbox.bottom = chart.chartArea.bottom;\r\n\r\n\t\t\tbox.update(maxChartAreaWidth, maxChartAreaHeight);\r\n\t\t});\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.layouts.js","name":"filterByPosition","start_line":5,"end_line":9,"comment":[],"params":["array","position"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.layouts.js","name":"filterByPosition","line":123,"func_location":"module.exports.update","func_start_line":109,"func_end_line":418,"args":["chart.boxes",{"type":"string"}],"comment":["*\r\n\t * Fits boxes of the given chart into the given size by having each box measure itself\r\n\t * then running a fitting algorithm\r\n\t * @param {Chart} chart - the chart\r\n\t * @param {Number} width - the width to fit into\r\n\t * @param {Number} height - the height to fit into\r\n\t "],"code":"\tupdate: function(chart, width, height) {\r\n\t\tif (!chart) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar layoutOptions = chart.options.layout || {};\r\n\t\tvar padding = helpers.options.toPadding(layoutOptions.padding);\r\n\t\tvar leftPadding = padding.left;\r\n\t\tvar rightPadding = padding.right;\r\n\t\tvar topPadding = padding.top;\r\n\t\tvar bottomPadding = padding.bottom;\r\n\r\n\t\tvar leftBoxes = filterByPosition(chart.boxes, 'left');\r\n\t\tvar rightBoxes = filterByPosition(chart.boxes, 'right');\r\n\t\tvar topBoxes = filterByPosition(chart.boxes, 'top');\r\n\t\tvar bottomBoxes = filterByPosition(chart.boxes, 'bottom');\r\n\t\tvar chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');\r\n\r\n\t\t// Sort boxes by weight. A higher weight is further away from the chart area\r\n\t\tsortByWeight(leftBoxes, true);\r\n\t\tsortByWeight(rightBoxes, false);\r\n\t\tsortByWeight(topBoxes, true);\r\n\t\tsortByWeight(bottomBoxes, false);\r\n\r\n\t\t// Essentially we now have any number of boxes on each of the 4 sides.\r\n\t\t// Our canvas looks like the following.\r\n\t\t// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\r\n\t\t// B1 is the bottom axis\r\n\t\t// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\r\n\t\t// These locations are single-box locations only, when trying to register a chartArea location that is already taken,\r\n\t\t// an error will be thrown.\r\n\t\t//\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |                  T1 (Full Width)                   |\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |    |    |                 T2                  |    |\r\n\t\t// |    |----|-------------------------------------|----|\r\n\t\t// |    |    | C1 |                           | C2 |    |\r\n\t\t// |    |    |----|                           |----|    |\r\n\t\t// |    |    |                                     |    |\r\n\t\t// | L1 | L2 |           ChartArea (C0)            | R1 |\r\n\t\t// |    |    |                                     |    |\r\n\t\t// |    |    |----|                           |----|    |\r\n\t\t// |    |    | C3 |                           | C4 |    |\r\n\t\t// |    |----|-------------------------------------|----|\r\n\t\t// |    |    |                 B1                  |    |\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |                  B2 (Full Width)                   |\r\n\t\t// |----------------------------------------------------|\r\n\t\t//\r\n\t\t// What we do to find the best sizing, we do the following\r\n\t\t// 1. Determine the minimum size of the chart area.\r\n\t\t// 2. Split the remaining width equally between each vertical axis\r\n\t\t// 3. Split the remaining height equally between each horizontal axis\r\n\t\t// 4. Give each layout the maximum size it can be. The layout will return it's minimum size\r\n\t\t// 5. Adjust the sizes of each axis based on it's minimum reported size.\r\n\t\t// 6. Refit each axis\r\n\t\t// 7. Position each axis in the final location\r\n\t\t// 8. Tell the chart the final location of the chart area\r\n\t\t// 9. Tell any axes that overlay the chart area the positions of the chart area\r\n\r\n\t\t// Step 1\r\n\t\tvar chartWidth = width - leftPadding - rightPadding;\r\n\t\tvar chartHeight = height - topPadding - bottomPadding;\r\n\t\tvar chartAreaWidth = chartWidth / 2; // min 50%\r\n\t\tvar chartAreaHeight = chartHeight / 2; // min 50%\r\n\r\n\t\t// Step 2\r\n\t\tvar verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);\r\n\r\n\t\t// Step 3\r\n\t\tvar horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);\r\n\r\n\t\t// Step 4\r\n\t\tvar maxChartAreaWidth = chartWidth;\r\n\t\tvar maxChartAreaHeight = chartHeight;\r\n\t\tvar minBoxSizes = [];\r\n\r\n\t\tfunction getMinimumBoxSize(box) {\r\n\t\t\tvar minSize;\r\n\t\t\tvar isHorizontal = box.isHorizontal();\r\n\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\tminSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);\r\n\t\t\t\tmaxChartAreaHeight -= minSize.height;\r\n\t\t\t} else {\r\n\t\t\t\tminSize = box.update(verticalBoxWidth, maxChartAreaHeight);\r\n\t\t\t\tmaxChartAreaWidth -= minSize.width;\r\n\t\t\t}\r\n\r\n\t\t\tminBoxSizes.push({\r\n\t\t\t\thorizontal: isHorizontal,\r\n\t\t\t\tminSize: minSize,\r\n\t\t\t\tbox: box,\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);\r\n\r\n\t\t// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)\r\n\t\tvar maxHorizontalLeftPadding = 0;\r\n\t\tvar maxHorizontalRightPadding = 0;\r\n\t\tvar maxVerticalTopPadding = 0;\r\n\t\tvar maxVerticalBottomPadding = 0;\r\n\r\n\t\thelpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {\r\n\t\t\tif (horizontalBox.getPadding) {\r\n\t\t\t\tvar boxPadding = horizontalBox.getPadding();\r\n\t\t\t\tmaxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);\r\n\t\t\t\tmaxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {\r\n\t\t\tif (verticalBox.getPadding) {\r\n\t\t\t\tvar boxPadding = verticalBox.getPadding();\r\n\t\t\t\tmaxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);\r\n\t\t\t\tmaxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\r\n\t\t// be if the axes are drawn at their minimum sizes.\r\n\t\t// Steps 5 & 6\r\n\t\tvar totalLeftBoxesWidth = leftPadding;\r\n\t\tvar totalRightBoxesWidth = rightPadding;\r\n\t\tvar totalTopBoxesHeight = topPadding;\r\n\t\tvar totalBottomBoxesHeight = bottomPadding;\r\n\r\n\t\t// Function to fit a box\r\n\t\tfunction fitBox(box) {\r\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {\r\n\t\t\t\treturn minBox.box === box;\r\n\t\t\t});\r\n\r\n\t\t\tif (minBoxSize) {\r\n\t\t\t\tif (box.isHorizontal()) {\r\n\t\t\t\t\tvar scaleMargin = {\r\n\t\t\t\t\t\tleft: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),\r\n\t\t\t\t\t\tright: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),\r\n\t\t\t\t\t\ttop: 0,\r\n\t\t\t\t\t\tbottom: 0\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\r\n\t\t\t\t\t// on the margin. Sometimes they need to increase in size slightly\r\n\t\t\t\t\tbox.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Update, and calculate the left and right margins for the horizontal boxes\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes), fitBox);\r\n\r\n\t\thelpers.each(leftBoxes, function(box) {\r\n\t\t\ttotalLeftBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\thelpers.each(rightBoxes, function(box) {\r\n\t\t\ttotalRightBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\t// Set the Left and Right margins for the horizontal boxes\r\n\t\thelpers.each(topBoxes.concat(bottomBoxes), fitBox);\r\n\r\n\t\t// Figure out how much margin is on the top and bottom of the vertical boxes\r\n\t\thelpers.each(topBoxes, function(box) {\r\n\t\t\ttotalTopBoxesHeight += box.height;\r\n\t\t});\r\n\r\n\t\thelpers.each(bottomBoxes, function(box) {\r\n\t\t\ttotalBottomBoxesHeight += box.height;\r\n\t\t});\r\n\r\n\t\tfunction finalFitVerticalBox(box) {\r\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {\r\n\t\t\t\treturn minSize.box === box;\r\n\t\t\t});\r\n\r\n\t\t\tvar scaleMargin = {\r\n\t\t\t\tleft: 0,\r\n\t\t\t\tright: 0,\r\n\t\t\t\ttop: totalTopBoxesHeight,\r\n\t\t\t\tbottom: totalBottomBoxesHeight\r\n\t\t\t};\r\n\r\n\t\t\tif (minBoxSize) {\r\n\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Let the left layout know the final margin\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);\r\n\r\n\t\t// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\r\n\t\ttotalLeftBoxesWidth = leftPadding;\r\n\t\ttotalRightBoxesWidth = rightPadding;\r\n\t\ttotalTopBoxesHeight = topPadding;\r\n\t\ttotalBottomBoxesHeight = bottomPadding;\r\n\r\n\t\thelpers.each(leftBoxes, function(box) {\r\n\t\t\ttotalLeftBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\thelpers.each(rightBoxes, function(box) {\r\n\t\t\ttotalRightBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\thelpers.each(topBoxes, function(box) {\r\n\t\t\ttotalTopBoxesHeight += box.height;\r\n\t\t});\r\n\t\thelpers.each(bottomBoxes, function(box) {\r\n\t\t\ttotalBottomBoxesHeight += box.height;\r\n\t\t});\r\n\r\n\t\t// We may be adding some padding to account for rotated x axis labels\r\n\t\tvar leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);\r\n\t\ttotalLeftBoxesWidth += leftPaddingAddition;\r\n\t\ttotalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);\r\n\r\n\t\tvar topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);\r\n\t\ttotalTopBoxesHeight += topPaddingAddition;\r\n\t\ttotalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);\r\n\r\n\t\t// Figure out if our chart area changed. This would occur if the dataset layout label rotation\r\n\t\t// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\r\n\t\t// without calling `fit` again\r\n\t\tvar newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;\r\n\t\tvar newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;\r\n\r\n\t\tif (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\r\n\t\t\thelpers.each(leftBoxes, function(box) {\r\n\t\t\t\tbox.height = newMaxChartAreaHeight;\r\n\t\t\t});\r\n\r\n\t\t\thelpers.each(rightBoxes, function(box) {\r\n\t\t\t\tbox.height = newMaxChartAreaHeight;\r\n\t\t\t});\r\n\r\n\t\t\thelpers.each(topBoxes, function(box) {\r\n\t\t\t\tif (!box.fullWidth) {\r\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\thelpers.each(bottomBoxes, function(box) {\r\n\t\t\t\tif (!box.fullWidth) {\r\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tmaxChartAreaHeight = newMaxChartAreaHeight;\r\n\t\t\tmaxChartAreaWidth = newMaxChartAreaWidth;\r\n\t\t}\r\n\r\n\t\t// Step 7 - Position the boxes\r\n\t\tvar left = leftPadding + leftPaddingAddition;\r\n\t\tvar top = topPadding + topPaddingAddition;\r\n\r\n\t\tfunction placeBox(box) {\r\n\t\t\tif (box.isHorizontal()) {\r\n\t\t\t\tbox.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;\r\n\t\t\t\tbox.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;\r\n\t\t\t\tbox.top = top;\r\n\t\t\t\tbox.bottom = top + box.height;\r\n\r\n\t\t\t\t// Move to next point\r\n\t\t\t\ttop = box.bottom;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbox.left = left;\r\n\t\t\t\tbox.right = left + box.width;\r\n\t\t\t\tbox.top = totalTopBoxesHeight;\r\n\t\t\t\tbox.bottom = totalTopBoxesHeight + maxChartAreaHeight;\r\n\r\n\t\t\t\t// Move to next point\r\n\t\t\t\tleft = box.right;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\thelpers.each(leftBoxes.concat(topBoxes), placeBox);\r\n\r\n\t\t// Account for chart width and height\r\n\t\tleft += maxChartAreaWidth;\r\n\t\ttop += maxChartAreaHeight;\r\n\r\n\t\thelpers.each(rightBoxes, placeBox);\r\n\t\thelpers.each(bottomBoxes, placeBox);\r\n\r\n\t\t// Step 8\r\n\t\tchart.chartArea = {\r\n\t\t\tleft: totalLeftBoxesWidth,\r\n\t\t\ttop: totalTopBoxesHeight,\r\n\t\t\tright: totalLeftBoxesWidth + maxChartAreaWidth,\r\n\t\t\tbottom: totalTopBoxesHeight + maxChartAreaHeight\r\n\t\t};\r\n\r\n\t\t// Step 9\r\n\t\thelpers.each(chartAreaBoxes, function(box) {\r\n\t\t\tbox.left = chart.chartArea.left;\r\n\t\t\tbox.top = chart.chartArea.top;\r\n\t\t\tbox.right = chart.chartArea.right;\r\n\t\t\tbox.bottom = chart.chartArea.bottom;\r\n\r\n\t\t\tbox.update(maxChartAreaWidth, maxChartAreaHeight);\r\n\t\t});\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.layouts.js","name":"filterByPosition","start_line":5,"end_line":9,"comment":[],"params":["array","position"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.layouts.js","name":"filterByPosition","line":124,"func_location":"module.exports.update","func_start_line":109,"func_end_line":418,"args":["chart.boxes",{"type":"string"}],"comment":["*\r\n\t * Fits boxes of the given chart into the given size by having each box measure itself\r\n\t * then running a fitting algorithm\r\n\t * @param {Chart} chart - the chart\r\n\t * @param {Number} width - the width to fit into\r\n\t * @param {Number} height - the height to fit into\r\n\t "],"code":"\tupdate: function(chart, width, height) {\r\n\t\tif (!chart) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar layoutOptions = chart.options.layout || {};\r\n\t\tvar padding = helpers.options.toPadding(layoutOptions.padding);\r\n\t\tvar leftPadding = padding.left;\r\n\t\tvar rightPadding = padding.right;\r\n\t\tvar topPadding = padding.top;\r\n\t\tvar bottomPadding = padding.bottom;\r\n\r\n\t\tvar leftBoxes = filterByPosition(chart.boxes, 'left');\r\n\t\tvar rightBoxes = filterByPosition(chart.boxes, 'right');\r\n\t\tvar topBoxes = filterByPosition(chart.boxes, 'top');\r\n\t\tvar bottomBoxes = filterByPosition(chart.boxes, 'bottom');\r\n\t\tvar chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');\r\n\r\n\t\t// Sort boxes by weight. A higher weight is further away from the chart area\r\n\t\tsortByWeight(leftBoxes, true);\r\n\t\tsortByWeight(rightBoxes, false);\r\n\t\tsortByWeight(topBoxes, true);\r\n\t\tsortByWeight(bottomBoxes, false);\r\n\r\n\t\t// Essentially we now have any number of boxes on each of the 4 sides.\r\n\t\t// Our canvas looks like the following.\r\n\t\t// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\r\n\t\t// B1 is the bottom axis\r\n\t\t// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\r\n\t\t// These locations are single-box locations only, when trying to register a chartArea location that is already taken,\r\n\t\t// an error will be thrown.\r\n\t\t//\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |                  T1 (Full Width)                   |\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |    |    |                 T2                  |    |\r\n\t\t// |    |----|-------------------------------------|----|\r\n\t\t// |    |    | C1 |                           | C2 |    |\r\n\t\t// |    |    |----|                           |----|    |\r\n\t\t// |    |    |                                     |    |\r\n\t\t// | L1 | L2 |           ChartArea (C0)            | R1 |\r\n\t\t// |    |    |                                     |    |\r\n\t\t// |    |    |----|                           |----|    |\r\n\t\t// |    |    | C3 |                           | C4 |    |\r\n\t\t// |    |----|-------------------------------------|----|\r\n\t\t// |    |    |                 B1                  |    |\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |                  B2 (Full Width)                   |\r\n\t\t// |----------------------------------------------------|\r\n\t\t//\r\n\t\t// What we do to find the best sizing, we do the following\r\n\t\t// 1. Determine the minimum size of the chart area.\r\n\t\t// 2. Split the remaining width equally between each vertical axis\r\n\t\t// 3. Split the remaining height equally between each horizontal axis\r\n\t\t// 4. Give each layout the maximum size it can be. The layout will return it's minimum size\r\n\t\t// 5. Adjust the sizes of each axis based on it's minimum reported size.\r\n\t\t// 6. Refit each axis\r\n\t\t// 7. Position each axis in the final location\r\n\t\t// 8. Tell the chart the final location of the chart area\r\n\t\t// 9. Tell any axes that overlay the chart area the positions of the chart area\r\n\r\n\t\t// Step 1\r\n\t\tvar chartWidth = width - leftPadding - rightPadding;\r\n\t\tvar chartHeight = height - topPadding - bottomPadding;\r\n\t\tvar chartAreaWidth = chartWidth / 2; // min 50%\r\n\t\tvar chartAreaHeight = chartHeight / 2; // min 50%\r\n\r\n\t\t// Step 2\r\n\t\tvar verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);\r\n\r\n\t\t// Step 3\r\n\t\tvar horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);\r\n\r\n\t\t// Step 4\r\n\t\tvar maxChartAreaWidth = chartWidth;\r\n\t\tvar maxChartAreaHeight = chartHeight;\r\n\t\tvar minBoxSizes = [];\r\n\r\n\t\tfunction getMinimumBoxSize(box) {\r\n\t\t\tvar minSize;\r\n\t\t\tvar isHorizontal = box.isHorizontal();\r\n\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\tminSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);\r\n\t\t\t\tmaxChartAreaHeight -= minSize.height;\r\n\t\t\t} else {\r\n\t\t\t\tminSize = box.update(verticalBoxWidth, maxChartAreaHeight);\r\n\t\t\t\tmaxChartAreaWidth -= minSize.width;\r\n\t\t\t}\r\n\r\n\t\t\tminBoxSizes.push({\r\n\t\t\t\thorizontal: isHorizontal,\r\n\t\t\t\tminSize: minSize,\r\n\t\t\t\tbox: box,\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);\r\n\r\n\t\t// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)\r\n\t\tvar maxHorizontalLeftPadding = 0;\r\n\t\tvar maxHorizontalRightPadding = 0;\r\n\t\tvar maxVerticalTopPadding = 0;\r\n\t\tvar maxVerticalBottomPadding = 0;\r\n\r\n\t\thelpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {\r\n\t\t\tif (horizontalBox.getPadding) {\r\n\t\t\t\tvar boxPadding = horizontalBox.getPadding();\r\n\t\t\t\tmaxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);\r\n\t\t\t\tmaxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {\r\n\t\t\tif (verticalBox.getPadding) {\r\n\t\t\t\tvar boxPadding = verticalBox.getPadding();\r\n\t\t\t\tmaxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);\r\n\t\t\t\tmaxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\r\n\t\t// be if the axes are drawn at their minimum sizes.\r\n\t\t// Steps 5 & 6\r\n\t\tvar totalLeftBoxesWidth = leftPadding;\r\n\t\tvar totalRightBoxesWidth = rightPadding;\r\n\t\tvar totalTopBoxesHeight = topPadding;\r\n\t\tvar totalBottomBoxesHeight = bottomPadding;\r\n\r\n\t\t// Function to fit a box\r\n\t\tfunction fitBox(box) {\r\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {\r\n\t\t\t\treturn minBox.box === box;\r\n\t\t\t});\r\n\r\n\t\t\tif (minBoxSize) {\r\n\t\t\t\tif (box.isHorizontal()) {\r\n\t\t\t\t\tvar scaleMargin = {\r\n\t\t\t\t\t\tleft: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),\r\n\t\t\t\t\t\tright: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),\r\n\t\t\t\t\t\ttop: 0,\r\n\t\t\t\t\t\tbottom: 0\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\r\n\t\t\t\t\t// on the margin. Sometimes they need to increase in size slightly\r\n\t\t\t\t\tbox.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Update, and calculate the left and right margins for the horizontal boxes\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes), fitBox);\r\n\r\n\t\thelpers.each(leftBoxes, function(box) {\r\n\t\t\ttotalLeftBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\thelpers.each(rightBoxes, function(box) {\r\n\t\t\ttotalRightBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\t// Set the Left and Right margins for the horizontal boxes\r\n\t\thelpers.each(topBoxes.concat(bottomBoxes), fitBox);\r\n\r\n\t\t// Figure out how much margin is on the top and bottom of the vertical boxes\r\n\t\thelpers.each(topBoxes, function(box) {\r\n\t\t\ttotalTopBoxesHeight += box.height;\r\n\t\t});\r\n\r\n\t\thelpers.each(bottomBoxes, function(box) {\r\n\t\t\ttotalBottomBoxesHeight += box.height;\r\n\t\t});\r\n\r\n\t\tfunction finalFitVerticalBox(box) {\r\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {\r\n\t\t\t\treturn minSize.box === box;\r\n\t\t\t});\r\n\r\n\t\t\tvar scaleMargin = {\r\n\t\t\t\tleft: 0,\r\n\t\t\t\tright: 0,\r\n\t\t\t\ttop: totalTopBoxesHeight,\r\n\t\t\t\tbottom: totalBottomBoxesHeight\r\n\t\t\t};\r\n\r\n\t\t\tif (minBoxSize) {\r\n\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Let the left layout know the final margin\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);\r\n\r\n\t\t// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\r\n\t\ttotalLeftBoxesWidth = leftPadding;\r\n\t\ttotalRightBoxesWidth = rightPadding;\r\n\t\ttotalTopBoxesHeight = topPadding;\r\n\t\ttotalBottomBoxesHeight = bottomPadding;\r\n\r\n\t\thelpers.each(leftBoxes, function(box) {\r\n\t\t\ttotalLeftBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\thelpers.each(rightBoxes, function(box) {\r\n\t\t\ttotalRightBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\thelpers.each(topBoxes, function(box) {\r\n\t\t\ttotalTopBoxesHeight += box.height;\r\n\t\t});\r\n\t\thelpers.each(bottomBoxes, function(box) {\r\n\t\t\ttotalBottomBoxesHeight += box.height;\r\n\t\t});\r\n\r\n\t\t// We may be adding some padding to account for rotated x axis labels\r\n\t\tvar leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);\r\n\t\ttotalLeftBoxesWidth += leftPaddingAddition;\r\n\t\ttotalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);\r\n\r\n\t\tvar topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);\r\n\t\ttotalTopBoxesHeight += topPaddingAddition;\r\n\t\ttotalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);\r\n\r\n\t\t// Figure out if our chart area changed. This would occur if the dataset layout label rotation\r\n\t\t// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\r\n\t\t// without calling `fit` again\r\n\t\tvar newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;\r\n\t\tvar newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;\r\n\r\n\t\tif (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\r\n\t\t\thelpers.each(leftBoxes, function(box) {\r\n\t\t\t\tbox.height = newMaxChartAreaHeight;\r\n\t\t\t});\r\n\r\n\t\t\thelpers.each(rightBoxes, function(box) {\r\n\t\t\t\tbox.height = newMaxChartAreaHeight;\r\n\t\t\t});\r\n\r\n\t\t\thelpers.each(topBoxes, function(box) {\r\n\t\t\t\tif (!box.fullWidth) {\r\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\thelpers.each(bottomBoxes, function(box) {\r\n\t\t\t\tif (!box.fullWidth) {\r\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tmaxChartAreaHeight = newMaxChartAreaHeight;\r\n\t\t\tmaxChartAreaWidth = newMaxChartAreaWidth;\r\n\t\t}\r\n\r\n\t\t// Step 7 - Position the boxes\r\n\t\tvar left = leftPadding + leftPaddingAddition;\r\n\t\tvar top = topPadding + topPaddingAddition;\r\n\r\n\t\tfunction placeBox(box) {\r\n\t\t\tif (box.isHorizontal()) {\r\n\t\t\t\tbox.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;\r\n\t\t\t\tbox.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;\r\n\t\t\t\tbox.top = top;\r\n\t\t\t\tbox.bottom = top + box.height;\r\n\r\n\t\t\t\t// Move to next point\r\n\t\t\t\ttop = box.bottom;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbox.left = left;\r\n\t\t\t\tbox.right = left + box.width;\r\n\t\t\t\tbox.top = totalTopBoxesHeight;\r\n\t\t\t\tbox.bottom = totalTopBoxesHeight + maxChartAreaHeight;\r\n\r\n\t\t\t\t// Move to next point\r\n\t\t\t\tleft = box.right;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\thelpers.each(leftBoxes.concat(topBoxes), placeBox);\r\n\r\n\t\t// Account for chart width and height\r\n\t\tleft += maxChartAreaWidth;\r\n\t\ttop += maxChartAreaHeight;\r\n\r\n\t\thelpers.each(rightBoxes, placeBox);\r\n\t\thelpers.each(bottomBoxes, placeBox);\r\n\r\n\t\t// Step 8\r\n\t\tchart.chartArea = {\r\n\t\t\tleft: totalLeftBoxesWidth,\r\n\t\t\ttop: totalTopBoxesHeight,\r\n\t\t\tright: totalLeftBoxesWidth + maxChartAreaWidth,\r\n\t\t\tbottom: totalTopBoxesHeight + maxChartAreaHeight\r\n\t\t};\r\n\r\n\t\t// Step 9\r\n\t\thelpers.each(chartAreaBoxes, function(box) {\r\n\t\t\tbox.left = chart.chartArea.left;\r\n\t\t\tbox.top = chart.chartArea.top;\r\n\t\t\tbox.right = chart.chartArea.right;\r\n\t\t\tbox.bottom = chart.chartArea.bottom;\r\n\r\n\t\t\tbox.update(maxChartAreaWidth, maxChartAreaHeight);\r\n\t\t});\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.layouts.js","name":"filterByPosition","start_line":5,"end_line":9,"comment":[],"params":["array","position"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.layouts.js","name":"filterByPosition","line":125,"func_location":"module.exports.update","func_start_line":109,"func_end_line":418,"args":["chart.boxes",{"type":"string"}],"comment":["*\r\n\t * Fits boxes of the given chart into the given size by having each box measure itself\r\n\t * then running a fitting algorithm\r\n\t * @param {Chart} chart - the chart\r\n\t * @param {Number} width - the width to fit into\r\n\t * @param {Number} height - the height to fit into\r\n\t "],"code":"\tupdate: function(chart, width, height) {\r\n\t\tif (!chart) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar layoutOptions = chart.options.layout || {};\r\n\t\tvar padding = helpers.options.toPadding(layoutOptions.padding);\r\n\t\tvar leftPadding = padding.left;\r\n\t\tvar rightPadding = padding.right;\r\n\t\tvar topPadding = padding.top;\r\n\t\tvar bottomPadding = padding.bottom;\r\n\r\n\t\tvar leftBoxes = filterByPosition(chart.boxes, 'left');\r\n\t\tvar rightBoxes = filterByPosition(chart.boxes, 'right');\r\n\t\tvar topBoxes = filterByPosition(chart.boxes, 'top');\r\n\t\tvar bottomBoxes = filterByPosition(chart.boxes, 'bottom');\r\n\t\tvar chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');\r\n\r\n\t\t// Sort boxes by weight. A higher weight is further away from the chart area\r\n\t\tsortByWeight(leftBoxes, true);\r\n\t\tsortByWeight(rightBoxes, false);\r\n\t\tsortByWeight(topBoxes, true);\r\n\t\tsortByWeight(bottomBoxes, false);\r\n\r\n\t\t// Essentially we now have any number of boxes on each of the 4 sides.\r\n\t\t// Our canvas looks like the following.\r\n\t\t// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\r\n\t\t// B1 is the bottom axis\r\n\t\t// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\r\n\t\t// These locations are single-box locations only, when trying to register a chartArea location that is already taken,\r\n\t\t// an error will be thrown.\r\n\t\t//\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |                  T1 (Full Width)                   |\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |    |    |                 T2                  |    |\r\n\t\t// |    |----|-------------------------------------|----|\r\n\t\t// |    |    | C1 |                           | C2 |    |\r\n\t\t// |    |    |----|                           |----|    |\r\n\t\t// |    |    |                                     |    |\r\n\t\t// | L1 | L2 |           ChartArea (C0)            | R1 |\r\n\t\t// |    |    |                                     |    |\r\n\t\t// |    |    |----|                           |----|    |\r\n\t\t// |    |    | C3 |                           | C4 |    |\r\n\t\t// |    |----|-------------------------------------|----|\r\n\t\t// |    |    |                 B1                  |    |\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |                  B2 (Full Width)                   |\r\n\t\t// |----------------------------------------------------|\r\n\t\t//\r\n\t\t// What we do to find the best sizing, we do the following\r\n\t\t// 1. Determine the minimum size of the chart area.\r\n\t\t// 2. Split the remaining width equally between each vertical axis\r\n\t\t// 3. Split the remaining height equally between each horizontal axis\r\n\t\t// 4. Give each layout the maximum size it can be. The layout will return it's minimum size\r\n\t\t// 5. Adjust the sizes of each axis based on it's minimum reported size.\r\n\t\t// 6. Refit each axis\r\n\t\t// 7. Position each axis in the final location\r\n\t\t// 8. Tell the chart the final location of the chart area\r\n\t\t// 9. Tell any axes that overlay the chart area the positions of the chart area\r\n\r\n\t\t// Step 1\r\n\t\tvar chartWidth = width - leftPadding - rightPadding;\r\n\t\tvar chartHeight = height - topPadding - bottomPadding;\r\n\t\tvar chartAreaWidth = chartWidth / 2; // min 50%\r\n\t\tvar chartAreaHeight = chartHeight / 2; // min 50%\r\n\r\n\t\t// Step 2\r\n\t\tvar verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);\r\n\r\n\t\t// Step 3\r\n\t\tvar horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);\r\n\r\n\t\t// Step 4\r\n\t\tvar maxChartAreaWidth = chartWidth;\r\n\t\tvar maxChartAreaHeight = chartHeight;\r\n\t\tvar minBoxSizes = [];\r\n\r\n\t\tfunction getMinimumBoxSize(box) {\r\n\t\t\tvar minSize;\r\n\t\t\tvar isHorizontal = box.isHorizontal();\r\n\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\tminSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);\r\n\t\t\t\tmaxChartAreaHeight -= minSize.height;\r\n\t\t\t} else {\r\n\t\t\t\tminSize = box.update(verticalBoxWidth, maxChartAreaHeight);\r\n\t\t\t\tmaxChartAreaWidth -= minSize.width;\r\n\t\t\t}\r\n\r\n\t\t\tminBoxSizes.push({\r\n\t\t\t\thorizontal: isHorizontal,\r\n\t\t\t\tminSize: minSize,\r\n\t\t\t\tbox: box,\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);\r\n\r\n\t\t// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)\r\n\t\tvar maxHorizontalLeftPadding = 0;\r\n\t\tvar maxHorizontalRightPadding = 0;\r\n\t\tvar maxVerticalTopPadding = 0;\r\n\t\tvar maxVerticalBottomPadding = 0;\r\n\r\n\t\thelpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {\r\n\t\t\tif (horizontalBox.getPadding) {\r\n\t\t\t\tvar boxPadding = horizontalBox.getPadding();\r\n\t\t\t\tmaxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);\r\n\t\t\t\tmaxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {\r\n\t\t\tif (verticalBox.getPadding) {\r\n\t\t\t\tvar boxPadding = verticalBox.getPadding();\r\n\t\t\t\tmaxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);\r\n\t\t\t\tmaxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\r\n\t\t// be if the axes are drawn at their minimum sizes.\r\n\t\t// Steps 5 & 6\r\n\t\tvar totalLeftBoxesWidth = leftPadding;\r\n\t\tvar totalRightBoxesWidth = rightPadding;\r\n\t\tvar totalTopBoxesHeight = topPadding;\r\n\t\tvar totalBottomBoxesHeight = bottomPadding;\r\n\r\n\t\t// Function to fit a box\r\n\t\tfunction fitBox(box) {\r\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {\r\n\t\t\t\treturn minBox.box === box;\r\n\t\t\t});\r\n\r\n\t\t\tif (minBoxSize) {\r\n\t\t\t\tif (box.isHorizontal()) {\r\n\t\t\t\t\tvar scaleMargin = {\r\n\t\t\t\t\t\tleft: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),\r\n\t\t\t\t\t\tright: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),\r\n\t\t\t\t\t\ttop: 0,\r\n\t\t\t\t\t\tbottom: 0\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\r\n\t\t\t\t\t// on the margin. Sometimes they need to increase in size slightly\r\n\t\t\t\t\tbox.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Update, and calculate the left and right margins for the horizontal boxes\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes), fitBox);\r\n\r\n\t\thelpers.each(leftBoxes, function(box) {\r\n\t\t\ttotalLeftBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\thelpers.each(rightBoxes, function(box) {\r\n\t\t\ttotalRightBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\t// Set the Left and Right margins for the horizontal boxes\r\n\t\thelpers.each(topBoxes.concat(bottomBoxes), fitBox);\r\n\r\n\t\t// Figure out how much margin is on the top and bottom of the vertical boxes\r\n\t\thelpers.each(topBoxes, function(box) {\r\n\t\t\ttotalTopBoxesHeight += box.height;\r\n\t\t});\r\n\r\n\t\thelpers.each(bottomBoxes, function(box) {\r\n\t\t\ttotalBottomBoxesHeight += box.height;\r\n\t\t});\r\n\r\n\t\tfunction finalFitVerticalBox(box) {\r\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {\r\n\t\t\t\treturn minSize.box === box;\r\n\t\t\t});\r\n\r\n\t\t\tvar scaleMargin = {\r\n\t\t\t\tleft: 0,\r\n\t\t\t\tright: 0,\r\n\t\t\t\ttop: totalTopBoxesHeight,\r\n\t\t\t\tbottom: totalBottomBoxesHeight\r\n\t\t\t};\r\n\r\n\t\t\tif (minBoxSize) {\r\n\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Let the left layout know the final margin\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);\r\n\r\n\t\t// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\r\n\t\ttotalLeftBoxesWidth = leftPadding;\r\n\t\ttotalRightBoxesWidth = rightPadding;\r\n\t\ttotalTopBoxesHeight = topPadding;\r\n\t\ttotalBottomBoxesHeight = bottomPadding;\r\n\r\n\t\thelpers.each(leftBoxes, function(box) {\r\n\t\t\ttotalLeftBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\thelpers.each(rightBoxes, function(box) {\r\n\t\t\ttotalRightBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\thelpers.each(topBoxes, function(box) {\r\n\t\t\ttotalTopBoxesHeight += box.height;\r\n\t\t});\r\n\t\thelpers.each(bottomBoxes, function(box) {\r\n\t\t\ttotalBottomBoxesHeight += box.height;\r\n\t\t});\r\n\r\n\t\t// We may be adding some padding to account for rotated x axis labels\r\n\t\tvar leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);\r\n\t\ttotalLeftBoxesWidth += leftPaddingAddition;\r\n\t\ttotalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);\r\n\r\n\t\tvar topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);\r\n\t\ttotalTopBoxesHeight += topPaddingAddition;\r\n\t\ttotalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);\r\n\r\n\t\t// Figure out if our chart area changed. This would occur if the dataset layout label rotation\r\n\t\t// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\r\n\t\t// without calling `fit` again\r\n\t\tvar newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;\r\n\t\tvar newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;\r\n\r\n\t\tif (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\r\n\t\t\thelpers.each(leftBoxes, function(box) {\r\n\t\t\t\tbox.height = newMaxChartAreaHeight;\r\n\t\t\t});\r\n\r\n\t\t\thelpers.each(rightBoxes, function(box) {\r\n\t\t\t\tbox.height = newMaxChartAreaHeight;\r\n\t\t\t});\r\n\r\n\t\t\thelpers.each(topBoxes, function(box) {\r\n\t\t\t\tif (!box.fullWidth) {\r\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\thelpers.each(bottomBoxes, function(box) {\r\n\t\t\t\tif (!box.fullWidth) {\r\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tmaxChartAreaHeight = newMaxChartAreaHeight;\r\n\t\t\tmaxChartAreaWidth = newMaxChartAreaWidth;\r\n\t\t}\r\n\r\n\t\t// Step 7 - Position the boxes\r\n\t\tvar left = leftPadding + leftPaddingAddition;\r\n\t\tvar top = topPadding + topPaddingAddition;\r\n\r\n\t\tfunction placeBox(box) {\r\n\t\t\tif (box.isHorizontal()) {\r\n\t\t\t\tbox.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;\r\n\t\t\t\tbox.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;\r\n\t\t\t\tbox.top = top;\r\n\t\t\t\tbox.bottom = top + box.height;\r\n\r\n\t\t\t\t// Move to next point\r\n\t\t\t\ttop = box.bottom;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbox.left = left;\r\n\t\t\t\tbox.right = left + box.width;\r\n\t\t\t\tbox.top = totalTopBoxesHeight;\r\n\t\t\t\tbox.bottom = totalTopBoxesHeight + maxChartAreaHeight;\r\n\r\n\t\t\t\t// Move to next point\r\n\t\t\t\tleft = box.right;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\thelpers.each(leftBoxes.concat(topBoxes), placeBox);\r\n\r\n\t\t// Account for chart width and height\r\n\t\tleft += maxChartAreaWidth;\r\n\t\ttop += maxChartAreaHeight;\r\n\r\n\t\thelpers.each(rightBoxes, placeBox);\r\n\t\thelpers.each(bottomBoxes, placeBox);\r\n\r\n\t\t// Step 8\r\n\t\tchart.chartArea = {\r\n\t\t\tleft: totalLeftBoxesWidth,\r\n\t\t\ttop: totalTopBoxesHeight,\r\n\t\t\tright: totalLeftBoxesWidth + maxChartAreaWidth,\r\n\t\t\tbottom: totalTopBoxesHeight + maxChartAreaHeight\r\n\t\t};\r\n\r\n\t\t// Step 9\r\n\t\thelpers.each(chartAreaBoxes, function(box) {\r\n\t\t\tbox.left = chart.chartArea.left;\r\n\t\t\tbox.top = chart.chartArea.top;\r\n\t\t\tbox.right = chart.chartArea.right;\r\n\t\t\tbox.bottom = chart.chartArea.bottom;\r\n\r\n\t\t\tbox.update(maxChartAreaWidth, maxChartAreaHeight);\r\n\t\t});\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.layouts.js","name":"filterByPosition","start_line":5,"end_line":9,"comment":[],"params":["array","position"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.layouts.js","name":"sortByWeight","line":128,"func_location":"module.exports.update","func_start_line":109,"func_end_line":418,"args":["leftBoxes",{"type":"boolean"}],"comment":["*\r\n\t * Fits boxes of the given chart into the given size by having each box measure itself\r\n\t * then running a fitting algorithm\r\n\t * @param {Chart} chart - the chart\r\n\t * @param {Number} width - the width to fit into\r\n\t * @param {Number} height - the height to fit into\r\n\t "],"code":"\tupdate: function(chart, width, height) {\r\n\t\tif (!chart) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar layoutOptions = chart.options.layout || {};\r\n\t\tvar padding = helpers.options.toPadding(layoutOptions.padding);\r\n\t\tvar leftPadding = padding.left;\r\n\t\tvar rightPadding = padding.right;\r\n\t\tvar topPadding = padding.top;\r\n\t\tvar bottomPadding = padding.bottom;\r\n\r\n\t\tvar leftBoxes = filterByPosition(chart.boxes, 'left');\r\n\t\tvar rightBoxes = filterByPosition(chart.boxes, 'right');\r\n\t\tvar topBoxes = filterByPosition(chart.boxes, 'top');\r\n\t\tvar bottomBoxes = filterByPosition(chart.boxes, 'bottom');\r\n\t\tvar chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');\r\n\r\n\t\t// Sort boxes by weight. A higher weight is further away from the chart area\r\n\t\tsortByWeight(leftBoxes, true);\r\n\t\tsortByWeight(rightBoxes, false);\r\n\t\tsortByWeight(topBoxes, true);\r\n\t\tsortByWeight(bottomBoxes, false);\r\n\r\n\t\t// Essentially we now have any number of boxes on each of the 4 sides.\r\n\t\t// Our canvas looks like the following.\r\n\t\t// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\r\n\t\t// B1 is the bottom axis\r\n\t\t// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\r\n\t\t// These locations are single-box locations only, when trying to register a chartArea location that is already taken,\r\n\t\t// an error will be thrown.\r\n\t\t//\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |                  T1 (Full Width)                   |\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |    |    |                 T2                  |    |\r\n\t\t// |    |----|-------------------------------------|----|\r\n\t\t// |    |    | C1 |                           | C2 |    |\r\n\t\t// |    |    |----|                           |----|    |\r\n\t\t// |    |    |                                     |    |\r\n\t\t// | L1 | L2 |           ChartArea (C0)            | R1 |\r\n\t\t// |    |    |                                     |    |\r\n\t\t// |    |    |----|                           |----|    |\r\n\t\t// |    |    | C3 |                           | C4 |    |\r\n\t\t// |    |----|-------------------------------------|----|\r\n\t\t// |    |    |                 B1                  |    |\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |                  B2 (Full Width)                   |\r\n\t\t// |----------------------------------------------------|\r\n\t\t//\r\n\t\t// What we do to find the best sizing, we do the following\r\n\t\t// 1. Determine the minimum size of the chart area.\r\n\t\t// 2. Split the remaining width equally between each vertical axis\r\n\t\t// 3. Split the remaining height equally between each horizontal axis\r\n\t\t// 4. Give each layout the maximum size it can be. The layout will return it's minimum size\r\n\t\t// 5. Adjust the sizes of each axis based on it's minimum reported size.\r\n\t\t// 6. Refit each axis\r\n\t\t// 7. Position each axis in the final location\r\n\t\t// 8. Tell the chart the final location of the chart area\r\n\t\t// 9. Tell any axes that overlay the chart area the positions of the chart area\r\n\r\n\t\t// Step 1\r\n\t\tvar chartWidth = width - leftPadding - rightPadding;\r\n\t\tvar chartHeight = height - topPadding - bottomPadding;\r\n\t\tvar chartAreaWidth = chartWidth / 2; // min 50%\r\n\t\tvar chartAreaHeight = chartHeight / 2; // min 50%\r\n\r\n\t\t// Step 2\r\n\t\tvar verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);\r\n\r\n\t\t// Step 3\r\n\t\tvar horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);\r\n\r\n\t\t// Step 4\r\n\t\tvar maxChartAreaWidth = chartWidth;\r\n\t\tvar maxChartAreaHeight = chartHeight;\r\n\t\tvar minBoxSizes = [];\r\n\r\n\t\tfunction getMinimumBoxSize(box) {\r\n\t\t\tvar minSize;\r\n\t\t\tvar isHorizontal = box.isHorizontal();\r\n\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\tminSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);\r\n\t\t\t\tmaxChartAreaHeight -= minSize.height;\r\n\t\t\t} else {\r\n\t\t\t\tminSize = box.update(verticalBoxWidth, maxChartAreaHeight);\r\n\t\t\t\tmaxChartAreaWidth -= minSize.width;\r\n\t\t\t}\r\n\r\n\t\t\tminBoxSizes.push({\r\n\t\t\t\thorizontal: isHorizontal,\r\n\t\t\t\tminSize: minSize,\r\n\t\t\t\tbox: box,\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);\r\n\r\n\t\t// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)\r\n\t\tvar maxHorizontalLeftPadding = 0;\r\n\t\tvar maxHorizontalRightPadding = 0;\r\n\t\tvar maxVerticalTopPadding = 0;\r\n\t\tvar maxVerticalBottomPadding = 0;\r\n\r\n\t\thelpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {\r\n\t\t\tif (horizontalBox.getPadding) {\r\n\t\t\t\tvar boxPadding = horizontalBox.getPadding();\r\n\t\t\t\tmaxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);\r\n\t\t\t\tmaxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {\r\n\t\t\tif (verticalBox.getPadding) {\r\n\t\t\t\tvar boxPadding = verticalBox.getPadding();\r\n\t\t\t\tmaxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);\r\n\t\t\t\tmaxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\r\n\t\t// be if the axes are drawn at their minimum sizes.\r\n\t\t// Steps 5 & 6\r\n\t\tvar totalLeftBoxesWidth = leftPadding;\r\n\t\tvar totalRightBoxesWidth = rightPadding;\r\n\t\tvar totalTopBoxesHeight = topPadding;\r\n\t\tvar totalBottomBoxesHeight = bottomPadding;\r\n\r\n\t\t// Function to fit a box\r\n\t\tfunction fitBox(box) {\r\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {\r\n\t\t\t\treturn minBox.box === box;\r\n\t\t\t});\r\n\r\n\t\t\tif (minBoxSize) {\r\n\t\t\t\tif (box.isHorizontal()) {\r\n\t\t\t\t\tvar scaleMargin = {\r\n\t\t\t\t\t\tleft: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),\r\n\t\t\t\t\t\tright: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),\r\n\t\t\t\t\t\ttop: 0,\r\n\t\t\t\t\t\tbottom: 0\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\r\n\t\t\t\t\t// on the margin. Sometimes they need to increase in size slightly\r\n\t\t\t\t\tbox.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Update, and calculate the left and right margins for the horizontal boxes\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes), fitBox);\r\n\r\n\t\thelpers.each(leftBoxes, function(box) {\r\n\t\t\ttotalLeftBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\thelpers.each(rightBoxes, function(box) {\r\n\t\t\ttotalRightBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\t// Set the Left and Right margins for the horizontal boxes\r\n\t\thelpers.each(topBoxes.concat(bottomBoxes), fitBox);\r\n\r\n\t\t// Figure out how much margin is on the top and bottom of the vertical boxes\r\n\t\thelpers.each(topBoxes, function(box) {\r\n\t\t\ttotalTopBoxesHeight += box.height;\r\n\t\t});\r\n\r\n\t\thelpers.each(bottomBoxes, function(box) {\r\n\t\t\ttotalBottomBoxesHeight += box.height;\r\n\t\t});\r\n\r\n\t\tfunction finalFitVerticalBox(box) {\r\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {\r\n\t\t\t\treturn minSize.box === box;\r\n\t\t\t});\r\n\r\n\t\t\tvar scaleMargin = {\r\n\t\t\t\tleft: 0,\r\n\t\t\t\tright: 0,\r\n\t\t\t\ttop: totalTopBoxesHeight,\r\n\t\t\t\tbottom: totalBottomBoxesHeight\r\n\t\t\t};\r\n\r\n\t\t\tif (minBoxSize) {\r\n\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Let the left layout know the final margin\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);\r\n\r\n\t\t// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\r\n\t\ttotalLeftBoxesWidth = leftPadding;\r\n\t\ttotalRightBoxesWidth = rightPadding;\r\n\t\ttotalTopBoxesHeight = topPadding;\r\n\t\ttotalBottomBoxesHeight = bottomPadding;\r\n\r\n\t\thelpers.each(leftBoxes, function(box) {\r\n\t\t\ttotalLeftBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\thelpers.each(rightBoxes, function(box) {\r\n\t\t\ttotalRightBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\thelpers.each(topBoxes, function(box) {\r\n\t\t\ttotalTopBoxesHeight += box.height;\r\n\t\t});\r\n\t\thelpers.each(bottomBoxes, function(box) {\r\n\t\t\ttotalBottomBoxesHeight += box.height;\r\n\t\t});\r\n\r\n\t\t// We may be adding some padding to account for rotated x axis labels\r\n\t\tvar leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);\r\n\t\ttotalLeftBoxesWidth += leftPaddingAddition;\r\n\t\ttotalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);\r\n\r\n\t\tvar topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);\r\n\t\ttotalTopBoxesHeight += topPaddingAddition;\r\n\t\ttotalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);\r\n\r\n\t\t// Figure out if our chart area changed. This would occur if the dataset layout label rotation\r\n\t\t// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\r\n\t\t// without calling `fit` again\r\n\t\tvar newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;\r\n\t\tvar newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;\r\n\r\n\t\tif (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\r\n\t\t\thelpers.each(leftBoxes, function(box) {\r\n\t\t\t\tbox.height = newMaxChartAreaHeight;\r\n\t\t\t});\r\n\r\n\t\t\thelpers.each(rightBoxes, function(box) {\r\n\t\t\t\tbox.height = newMaxChartAreaHeight;\r\n\t\t\t});\r\n\r\n\t\t\thelpers.each(topBoxes, function(box) {\r\n\t\t\t\tif (!box.fullWidth) {\r\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\thelpers.each(bottomBoxes, function(box) {\r\n\t\t\t\tif (!box.fullWidth) {\r\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tmaxChartAreaHeight = newMaxChartAreaHeight;\r\n\t\t\tmaxChartAreaWidth = newMaxChartAreaWidth;\r\n\t\t}\r\n\r\n\t\t// Step 7 - Position the boxes\r\n\t\tvar left = leftPadding + leftPaddingAddition;\r\n\t\tvar top = topPadding + topPaddingAddition;\r\n\r\n\t\tfunction placeBox(box) {\r\n\t\t\tif (box.isHorizontal()) {\r\n\t\t\t\tbox.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;\r\n\t\t\t\tbox.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;\r\n\t\t\t\tbox.top = top;\r\n\t\t\t\tbox.bottom = top + box.height;\r\n\r\n\t\t\t\t// Move to next point\r\n\t\t\t\ttop = box.bottom;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbox.left = left;\r\n\t\t\t\tbox.right = left + box.width;\r\n\t\t\t\tbox.top = totalTopBoxesHeight;\r\n\t\t\t\tbox.bottom = totalTopBoxesHeight + maxChartAreaHeight;\r\n\r\n\t\t\t\t// Move to next point\r\n\t\t\t\tleft = box.right;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\thelpers.each(leftBoxes.concat(topBoxes), placeBox);\r\n\r\n\t\t// Account for chart width and height\r\n\t\tleft += maxChartAreaWidth;\r\n\t\ttop += maxChartAreaHeight;\r\n\r\n\t\thelpers.each(rightBoxes, placeBox);\r\n\t\thelpers.each(bottomBoxes, placeBox);\r\n\r\n\t\t// Step 8\r\n\t\tchart.chartArea = {\r\n\t\t\tleft: totalLeftBoxesWidth,\r\n\t\t\ttop: totalTopBoxesHeight,\r\n\t\t\tright: totalLeftBoxesWidth + maxChartAreaWidth,\r\n\t\t\tbottom: totalTopBoxesHeight + maxChartAreaHeight\r\n\t\t};\r\n\r\n\t\t// Step 9\r\n\t\thelpers.each(chartAreaBoxes, function(box) {\r\n\t\t\tbox.left = chart.chartArea.left;\r\n\t\t\tbox.top = chart.chartArea.top;\r\n\t\t\tbox.right = chart.chartArea.right;\r\n\t\t\tbox.bottom = chart.chartArea.bottom;\r\n\r\n\t\t\tbox.update(maxChartAreaWidth, maxChartAreaHeight);\r\n\t\t});\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.layouts.js","name":"sortByWeight","start_line":11,"end_line":26,"comment":[],"params":["array","reverse"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.layouts.js","name":"sortByWeight","line":129,"func_location":"module.exports.update","func_start_line":109,"func_end_line":418,"args":["rightBoxes",{"type":"boolean"}],"comment":["*\r\n\t * Fits boxes of the given chart into the given size by having each box measure itself\r\n\t * then running a fitting algorithm\r\n\t * @param {Chart} chart - the chart\r\n\t * @param {Number} width - the width to fit into\r\n\t * @param {Number} height - the height to fit into\r\n\t "],"code":"\tupdate: function(chart, width, height) {\r\n\t\tif (!chart) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar layoutOptions = chart.options.layout || {};\r\n\t\tvar padding = helpers.options.toPadding(layoutOptions.padding);\r\n\t\tvar leftPadding = padding.left;\r\n\t\tvar rightPadding = padding.right;\r\n\t\tvar topPadding = padding.top;\r\n\t\tvar bottomPadding = padding.bottom;\r\n\r\n\t\tvar leftBoxes = filterByPosition(chart.boxes, 'left');\r\n\t\tvar rightBoxes = filterByPosition(chart.boxes, 'right');\r\n\t\tvar topBoxes = filterByPosition(chart.boxes, 'top');\r\n\t\tvar bottomBoxes = filterByPosition(chart.boxes, 'bottom');\r\n\t\tvar chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');\r\n\r\n\t\t// Sort boxes by weight. A higher weight is further away from the chart area\r\n\t\tsortByWeight(leftBoxes, true);\r\n\t\tsortByWeight(rightBoxes, false);\r\n\t\tsortByWeight(topBoxes, true);\r\n\t\tsortByWeight(bottomBoxes, false);\r\n\r\n\t\t// Essentially we now have any number of boxes on each of the 4 sides.\r\n\t\t// Our canvas looks like the following.\r\n\t\t// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\r\n\t\t// B1 is the bottom axis\r\n\t\t// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\r\n\t\t// These locations are single-box locations only, when trying to register a chartArea location that is already taken,\r\n\t\t// an error will be thrown.\r\n\t\t//\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |                  T1 (Full Width)                   |\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |    |    |                 T2                  |    |\r\n\t\t// |    |----|-------------------------------------|----|\r\n\t\t// |    |    | C1 |                           | C2 |    |\r\n\t\t// |    |    |----|                           |----|    |\r\n\t\t// |    |    |                                     |    |\r\n\t\t// | L1 | L2 |           ChartArea (C0)            | R1 |\r\n\t\t// |    |    |                                     |    |\r\n\t\t// |    |    |----|                           |----|    |\r\n\t\t// |    |    | C3 |                           | C4 |    |\r\n\t\t// |    |----|-------------------------------------|----|\r\n\t\t// |    |    |                 B1                  |    |\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |                  B2 (Full Width)                   |\r\n\t\t// |----------------------------------------------------|\r\n\t\t//\r\n\t\t// What we do to find the best sizing, we do the following\r\n\t\t// 1. Determine the minimum size of the chart area.\r\n\t\t// 2. Split the remaining width equally between each vertical axis\r\n\t\t// 3. Split the remaining height equally between each horizontal axis\r\n\t\t// 4. Give each layout the maximum size it can be. The layout will return it's minimum size\r\n\t\t// 5. Adjust the sizes of each axis based on it's minimum reported size.\r\n\t\t// 6. Refit each axis\r\n\t\t// 7. Position each axis in the final location\r\n\t\t// 8. Tell the chart the final location of the chart area\r\n\t\t// 9. Tell any axes that overlay the chart area the positions of the chart area\r\n\r\n\t\t// Step 1\r\n\t\tvar chartWidth = width - leftPadding - rightPadding;\r\n\t\tvar chartHeight = height - topPadding - bottomPadding;\r\n\t\tvar chartAreaWidth = chartWidth / 2; // min 50%\r\n\t\tvar chartAreaHeight = chartHeight / 2; // min 50%\r\n\r\n\t\t// Step 2\r\n\t\tvar verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);\r\n\r\n\t\t// Step 3\r\n\t\tvar horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);\r\n\r\n\t\t// Step 4\r\n\t\tvar maxChartAreaWidth = chartWidth;\r\n\t\tvar maxChartAreaHeight = chartHeight;\r\n\t\tvar minBoxSizes = [];\r\n\r\n\t\tfunction getMinimumBoxSize(box) {\r\n\t\t\tvar minSize;\r\n\t\t\tvar isHorizontal = box.isHorizontal();\r\n\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\tminSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);\r\n\t\t\t\tmaxChartAreaHeight -= minSize.height;\r\n\t\t\t} else {\r\n\t\t\t\tminSize = box.update(verticalBoxWidth, maxChartAreaHeight);\r\n\t\t\t\tmaxChartAreaWidth -= minSize.width;\r\n\t\t\t}\r\n\r\n\t\t\tminBoxSizes.push({\r\n\t\t\t\thorizontal: isHorizontal,\r\n\t\t\t\tminSize: minSize,\r\n\t\t\t\tbox: box,\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);\r\n\r\n\t\t// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)\r\n\t\tvar maxHorizontalLeftPadding = 0;\r\n\t\tvar maxHorizontalRightPadding = 0;\r\n\t\tvar maxVerticalTopPadding = 0;\r\n\t\tvar maxVerticalBottomPadding = 0;\r\n\r\n\t\thelpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {\r\n\t\t\tif (horizontalBox.getPadding) {\r\n\t\t\t\tvar boxPadding = horizontalBox.getPadding();\r\n\t\t\t\tmaxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);\r\n\t\t\t\tmaxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {\r\n\t\t\tif (verticalBox.getPadding) {\r\n\t\t\t\tvar boxPadding = verticalBox.getPadding();\r\n\t\t\t\tmaxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);\r\n\t\t\t\tmaxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\r\n\t\t// be if the axes are drawn at their minimum sizes.\r\n\t\t// Steps 5 & 6\r\n\t\tvar totalLeftBoxesWidth = leftPadding;\r\n\t\tvar totalRightBoxesWidth = rightPadding;\r\n\t\tvar totalTopBoxesHeight = topPadding;\r\n\t\tvar totalBottomBoxesHeight = bottomPadding;\r\n\r\n\t\t// Function to fit a box\r\n\t\tfunction fitBox(box) {\r\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {\r\n\t\t\t\treturn minBox.box === box;\r\n\t\t\t});\r\n\r\n\t\t\tif (minBoxSize) {\r\n\t\t\t\tif (box.isHorizontal()) {\r\n\t\t\t\t\tvar scaleMargin = {\r\n\t\t\t\t\t\tleft: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),\r\n\t\t\t\t\t\tright: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),\r\n\t\t\t\t\t\ttop: 0,\r\n\t\t\t\t\t\tbottom: 0\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\r\n\t\t\t\t\t// on the margin. Sometimes they need to increase in size slightly\r\n\t\t\t\t\tbox.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Update, and calculate the left and right margins for the horizontal boxes\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes), fitBox);\r\n\r\n\t\thelpers.each(leftBoxes, function(box) {\r\n\t\t\ttotalLeftBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\thelpers.each(rightBoxes, function(box) {\r\n\t\t\ttotalRightBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\t// Set the Left and Right margins for the horizontal boxes\r\n\t\thelpers.each(topBoxes.concat(bottomBoxes), fitBox);\r\n\r\n\t\t// Figure out how much margin is on the top and bottom of the vertical boxes\r\n\t\thelpers.each(topBoxes, function(box) {\r\n\t\t\ttotalTopBoxesHeight += box.height;\r\n\t\t});\r\n\r\n\t\thelpers.each(bottomBoxes, function(box) {\r\n\t\t\ttotalBottomBoxesHeight += box.height;\r\n\t\t});\r\n\r\n\t\tfunction finalFitVerticalBox(box) {\r\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {\r\n\t\t\t\treturn minSize.box === box;\r\n\t\t\t});\r\n\r\n\t\t\tvar scaleMargin = {\r\n\t\t\t\tleft: 0,\r\n\t\t\t\tright: 0,\r\n\t\t\t\ttop: totalTopBoxesHeight,\r\n\t\t\t\tbottom: totalBottomBoxesHeight\r\n\t\t\t};\r\n\r\n\t\t\tif (minBoxSize) {\r\n\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Let the left layout know the final margin\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);\r\n\r\n\t\t// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\r\n\t\ttotalLeftBoxesWidth = leftPadding;\r\n\t\ttotalRightBoxesWidth = rightPadding;\r\n\t\ttotalTopBoxesHeight = topPadding;\r\n\t\ttotalBottomBoxesHeight = bottomPadding;\r\n\r\n\t\thelpers.each(leftBoxes, function(box) {\r\n\t\t\ttotalLeftBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\thelpers.each(rightBoxes, function(box) {\r\n\t\t\ttotalRightBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\thelpers.each(topBoxes, function(box) {\r\n\t\t\ttotalTopBoxesHeight += box.height;\r\n\t\t});\r\n\t\thelpers.each(bottomBoxes, function(box) {\r\n\t\t\ttotalBottomBoxesHeight += box.height;\r\n\t\t});\r\n\r\n\t\t// We may be adding some padding to account for rotated x axis labels\r\n\t\tvar leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);\r\n\t\ttotalLeftBoxesWidth += leftPaddingAddition;\r\n\t\ttotalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);\r\n\r\n\t\tvar topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);\r\n\t\ttotalTopBoxesHeight += topPaddingAddition;\r\n\t\ttotalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);\r\n\r\n\t\t// Figure out if our chart area changed. This would occur if the dataset layout label rotation\r\n\t\t// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\r\n\t\t// without calling `fit` again\r\n\t\tvar newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;\r\n\t\tvar newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;\r\n\r\n\t\tif (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\r\n\t\t\thelpers.each(leftBoxes, function(box) {\r\n\t\t\t\tbox.height = newMaxChartAreaHeight;\r\n\t\t\t});\r\n\r\n\t\t\thelpers.each(rightBoxes, function(box) {\r\n\t\t\t\tbox.height = newMaxChartAreaHeight;\r\n\t\t\t});\r\n\r\n\t\t\thelpers.each(topBoxes, function(box) {\r\n\t\t\t\tif (!box.fullWidth) {\r\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\thelpers.each(bottomBoxes, function(box) {\r\n\t\t\t\tif (!box.fullWidth) {\r\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tmaxChartAreaHeight = newMaxChartAreaHeight;\r\n\t\t\tmaxChartAreaWidth = newMaxChartAreaWidth;\r\n\t\t}\r\n\r\n\t\t// Step 7 - Position the boxes\r\n\t\tvar left = leftPadding + leftPaddingAddition;\r\n\t\tvar top = topPadding + topPaddingAddition;\r\n\r\n\t\tfunction placeBox(box) {\r\n\t\t\tif (box.isHorizontal()) {\r\n\t\t\t\tbox.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;\r\n\t\t\t\tbox.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;\r\n\t\t\t\tbox.top = top;\r\n\t\t\t\tbox.bottom = top + box.height;\r\n\r\n\t\t\t\t// Move to next point\r\n\t\t\t\ttop = box.bottom;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbox.left = left;\r\n\t\t\t\tbox.right = left + box.width;\r\n\t\t\t\tbox.top = totalTopBoxesHeight;\r\n\t\t\t\tbox.bottom = totalTopBoxesHeight + maxChartAreaHeight;\r\n\r\n\t\t\t\t// Move to next point\r\n\t\t\t\tleft = box.right;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\thelpers.each(leftBoxes.concat(topBoxes), placeBox);\r\n\r\n\t\t// Account for chart width and height\r\n\t\tleft += maxChartAreaWidth;\r\n\t\ttop += maxChartAreaHeight;\r\n\r\n\t\thelpers.each(rightBoxes, placeBox);\r\n\t\thelpers.each(bottomBoxes, placeBox);\r\n\r\n\t\t// Step 8\r\n\t\tchart.chartArea = {\r\n\t\t\tleft: totalLeftBoxesWidth,\r\n\t\t\ttop: totalTopBoxesHeight,\r\n\t\t\tright: totalLeftBoxesWidth + maxChartAreaWidth,\r\n\t\t\tbottom: totalTopBoxesHeight + maxChartAreaHeight\r\n\t\t};\r\n\r\n\t\t// Step 9\r\n\t\thelpers.each(chartAreaBoxes, function(box) {\r\n\t\t\tbox.left = chart.chartArea.left;\r\n\t\t\tbox.top = chart.chartArea.top;\r\n\t\t\tbox.right = chart.chartArea.right;\r\n\t\t\tbox.bottom = chart.chartArea.bottom;\r\n\r\n\t\t\tbox.update(maxChartAreaWidth, maxChartAreaHeight);\r\n\t\t});\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.layouts.js","name":"sortByWeight","start_line":11,"end_line":26,"comment":[],"params":["array","reverse"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.layouts.js","name":"sortByWeight","line":130,"func_location":"module.exports.update","func_start_line":109,"func_end_line":418,"args":["topBoxes",{"type":"boolean"}],"comment":["*\r\n\t * Fits boxes of the given chart into the given size by having each box measure itself\r\n\t * then running a fitting algorithm\r\n\t * @param {Chart} chart - the chart\r\n\t * @param {Number} width - the width to fit into\r\n\t * @param {Number} height - the height to fit into\r\n\t "],"code":"\tupdate: function(chart, width, height) {\r\n\t\tif (!chart) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar layoutOptions = chart.options.layout || {};\r\n\t\tvar padding = helpers.options.toPadding(layoutOptions.padding);\r\n\t\tvar leftPadding = padding.left;\r\n\t\tvar rightPadding = padding.right;\r\n\t\tvar topPadding = padding.top;\r\n\t\tvar bottomPadding = padding.bottom;\r\n\r\n\t\tvar leftBoxes = filterByPosition(chart.boxes, 'left');\r\n\t\tvar rightBoxes = filterByPosition(chart.boxes, 'right');\r\n\t\tvar topBoxes = filterByPosition(chart.boxes, 'top');\r\n\t\tvar bottomBoxes = filterByPosition(chart.boxes, 'bottom');\r\n\t\tvar chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');\r\n\r\n\t\t// Sort boxes by weight. A higher weight is further away from the chart area\r\n\t\tsortByWeight(leftBoxes, true);\r\n\t\tsortByWeight(rightBoxes, false);\r\n\t\tsortByWeight(topBoxes, true);\r\n\t\tsortByWeight(bottomBoxes, false);\r\n\r\n\t\t// Essentially we now have any number of boxes on each of the 4 sides.\r\n\t\t// Our canvas looks like the following.\r\n\t\t// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\r\n\t\t// B1 is the bottom axis\r\n\t\t// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\r\n\t\t// These locations are single-box locations only, when trying to register a chartArea location that is already taken,\r\n\t\t// an error will be thrown.\r\n\t\t//\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |                  T1 (Full Width)                   |\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |    |    |                 T2                  |    |\r\n\t\t// |    |----|-------------------------------------|----|\r\n\t\t// |    |    | C1 |                           | C2 |    |\r\n\t\t// |    |    |----|                           |----|    |\r\n\t\t// |    |    |                                     |    |\r\n\t\t// | L1 | L2 |           ChartArea (C0)            | R1 |\r\n\t\t// |    |    |                                     |    |\r\n\t\t// |    |    |----|                           |----|    |\r\n\t\t// |    |    | C3 |                           | C4 |    |\r\n\t\t// |    |----|-------------------------------------|----|\r\n\t\t// |    |    |                 B1                  |    |\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |                  B2 (Full Width)                   |\r\n\t\t// |----------------------------------------------------|\r\n\t\t//\r\n\t\t// What we do to find the best sizing, we do the following\r\n\t\t// 1. Determine the minimum size of the chart area.\r\n\t\t// 2. Split the remaining width equally between each vertical axis\r\n\t\t// 3. Split the remaining height equally between each horizontal axis\r\n\t\t// 4. Give each layout the maximum size it can be. The layout will return it's minimum size\r\n\t\t// 5. Adjust the sizes of each axis based on it's minimum reported size.\r\n\t\t// 6. Refit each axis\r\n\t\t// 7. Position each axis in the final location\r\n\t\t// 8. Tell the chart the final location of the chart area\r\n\t\t// 9. Tell any axes that overlay the chart area the positions of the chart area\r\n\r\n\t\t// Step 1\r\n\t\tvar chartWidth = width - leftPadding - rightPadding;\r\n\t\tvar chartHeight = height - topPadding - bottomPadding;\r\n\t\tvar chartAreaWidth = chartWidth / 2; // min 50%\r\n\t\tvar chartAreaHeight = chartHeight / 2; // min 50%\r\n\r\n\t\t// Step 2\r\n\t\tvar verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);\r\n\r\n\t\t// Step 3\r\n\t\tvar horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);\r\n\r\n\t\t// Step 4\r\n\t\tvar maxChartAreaWidth = chartWidth;\r\n\t\tvar maxChartAreaHeight = chartHeight;\r\n\t\tvar minBoxSizes = [];\r\n\r\n\t\tfunction getMinimumBoxSize(box) {\r\n\t\t\tvar minSize;\r\n\t\t\tvar isHorizontal = box.isHorizontal();\r\n\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\tminSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);\r\n\t\t\t\tmaxChartAreaHeight -= minSize.height;\r\n\t\t\t} else {\r\n\t\t\t\tminSize = box.update(verticalBoxWidth, maxChartAreaHeight);\r\n\t\t\t\tmaxChartAreaWidth -= minSize.width;\r\n\t\t\t}\r\n\r\n\t\t\tminBoxSizes.push({\r\n\t\t\t\thorizontal: isHorizontal,\r\n\t\t\t\tminSize: minSize,\r\n\t\t\t\tbox: box,\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);\r\n\r\n\t\t// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)\r\n\t\tvar maxHorizontalLeftPadding = 0;\r\n\t\tvar maxHorizontalRightPadding = 0;\r\n\t\tvar maxVerticalTopPadding = 0;\r\n\t\tvar maxVerticalBottomPadding = 0;\r\n\r\n\t\thelpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {\r\n\t\t\tif (horizontalBox.getPadding) {\r\n\t\t\t\tvar boxPadding = horizontalBox.getPadding();\r\n\t\t\t\tmaxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);\r\n\t\t\t\tmaxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {\r\n\t\t\tif (verticalBox.getPadding) {\r\n\t\t\t\tvar boxPadding = verticalBox.getPadding();\r\n\t\t\t\tmaxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);\r\n\t\t\t\tmaxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\r\n\t\t// be if the axes are drawn at their minimum sizes.\r\n\t\t// Steps 5 & 6\r\n\t\tvar totalLeftBoxesWidth = leftPadding;\r\n\t\tvar totalRightBoxesWidth = rightPadding;\r\n\t\tvar totalTopBoxesHeight = topPadding;\r\n\t\tvar totalBottomBoxesHeight = bottomPadding;\r\n\r\n\t\t// Function to fit a box\r\n\t\tfunction fitBox(box) {\r\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {\r\n\t\t\t\treturn minBox.box === box;\r\n\t\t\t});\r\n\r\n\t\t\tif (minBoxSize) {\r\n\t\t\t\tif (box.isHorizontal()) {\r\n\t\t\t\t\tvar scaleMargin = {\r\n\t\t\t\t\t\tleft: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),\r\n\t\t\t\t\t\tright: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),\r\n\t\t\t\t\t\ttop: 0,\r\n\t\t\t\t\t\tbottom: 0\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\r\n\t\t\t\t\t// on the margin. Sometimes they need to increase in size slightly\r\n\t\t\t\t\tbox.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Update, and calculate the left and right margins for the horizontal boxes\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes), fitBox);\r\n\r\n\t\thelpers.each(leftBoxes, function(box) {\r\n\t\t\ttotalLeftBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\thelpers.each(rightBoxes, function(box) {\r\n\t\t\ttotalRightBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\t// Set the Left and Right margins for the horizontal boxes\r\n\t\thelpers.each(topBoxes.concat(bottomBoxes), fitBox);\r\n\r\n\t\t// Figure out how much margin is on the top and bottom of the vertical boxes\r\n\t\thelpers.each(topBoxes, function(box) {\r\n\t\t\ttotalTopBoxesHeight += box.height;\r\n\t\t});\r\n\r\n\t\thelpers.each(bottomBoxes, function(box) {\r\n\t\t\ttotalBottomBoxesHeight += box.height;\r\n\t\t});\r\n\r\n\t\tfunction finalFitVerticalBox(box) {\r\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {\r\n\t\t\t\treturn minSize.box === box;\r\n\t\t\t});\r\n\r\n\t\t\tvar scaleMargin = {\r\n\t\t\t\tleft: 0,\r\n\t\t\t\tright: 0,\r\n\t\t\t\ttop: totalTopBoxesHeight,\r\n\t\t\t\tbottom: totalBottomBoxesHeight\r\n\t\t\t};\r\n\r\n\t\t\tif (minBoxSize) {\r\n\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Let the left layout know the final margin\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);\r\n\r\n\t\t// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\r\n\t\ttotalLeftBoxesWidth = leftPadding;\r\n\t\ttotalRightBoxesWidth = rightPadding;\r\n\t\ttotalTopBoxesHeight = topPadding;\r\n\t\ttotalBottomBoxesHeight = bottomPadding;\r\n\r\n\t\thelpers.each(leftBoxes, function(box) {\r\n\t\t\ttotalLeftBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\thelpers.each(rightBoxes, function(box) {\r\n\t\t\ttotalRightBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\thelpers.each(topBoxes, function(box) {\r\n\t\t\ttotalTopBoxesHeight += box.height;\r\n\t\t});\r\n\t\thelpers.each(bottomBoxes, function(box) {\r\n\t\t\ttotalBottomBoxesHeight += box.height;\r\n\t\t});\r\n\r\n\t\t// We may be adding some padding to account for rotated x axis labels\r\n\t\tvar leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);\r\n\t\ttotalLeftBoxesWidth += leftPaddingAddition;\r\n\t\ttotalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);\r\n\r\n\t\tvar topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);\r\n\t\ttotalTopBoxesHeight += topPaddingAddition;\r\n\t\ttotalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);\r\n\r\n\t\t// Figure out if our chart area changed. This would occur if the dataset layout label rotation\r\n\t\t// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\r\n\t\t// without calling `fit` again\r\n\t\tvar newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;\r\n\t\tvar newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;\r\n\r\n\t\tif (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\r\n\t\t\thelpers.each(leftBoxes, function(box) {\r\n\t\t\t\tbox.height = newMaxChartAreaHeight;\r\n\t\t\t});\r\n\r\n\t\t\thelpers.each(rightBoxes, function(box) {\r\n\t\t\t\tbox.height = newMaxChartAreaHeight;\r\n\t\t\t});\r\n\r\n\t\t\thelpers.each(topBoxes, function(box) {\r\n\t\t\t\tif (!box.fullWidth) {\r\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\thelpers.each(bottomBoxes, function(box) {\r\n\t\t\t\tif (!box.fullWidth) {\r\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tmaxChartAreaHeight = newMaxChartAreaHeight;\r\n\t\t\tmaxChartAreaWidth = newMaxChartAreaWidth;\r\n\t\t}\r\n\r\n\t\t// Step 7 - Position the boxes\r\n\t\tvar left = leftPadding + leftPaddingAddition;\r\n\t\tvar top = topPadding + topPaddingAddition;\r\n\r\n\t\tfunction placeBox(box) {\r\n\t\t\tif (box.isHorizontal()) {\r\n\t\t\t\tbox.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;\r\n\t\t\t\tbox.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;\r\n\t\t\t\tbox.top = top;\r\n\t\t\t\tbox.bottom = top + box.height;\r\n\r\n\t\t\t\t// Move to next point\r\n\t\t\t\ttop = box.bottom;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbox.left = left;\r\n\t\t\t\tbox.right = left + box.width;\r\n\t\t\t\tbox.top = totalTopBoxesHeight;\r\n\t\t\t\tbox.bottom = totalTopBoxesHeight + maxChartAreaHeight;\r\n\r\n\t\t\t\t// Move to next point\r\n\t\t\t\tleft = box.right;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\thelpers.each(leftBoxes.concat(topBoxes), placeBox);\r\n\r\n\t\t// Account for chart width and height\r\n\t\tleft += maxChartAreaWidth;\r\n\t\ttop += maxChartAreaHeight;\r\n\r\n\t\thelpers.each(rightBoxes, placeBox);\r\n\t\thelpers.each(bottomBoxes, placeBox);\r\n\r\n\t\t// Step 8\r\n\t\tchart.chartArea = {\r\n\t\t\tleft: totalLeftBoxesWidth,\r\n\t\t\ttop: totalTopBoxesHeight,\r\n\t\t\tright: totalLeftBoxesWidth + maxChartAreaWidth,\r\n\t\t\tbottom: totalTopBoxesHeight + maxChartAreaHeight\r\n\t\t};\r\n\r\n\t\t// Step 9\r\n\t\thelpers.each(chartAreaBoxes, function(box) {\r\n\t\t\tbox.left = chart.chartArea.left;\r\n\t\t\tbox.top = chart.chartArea.top;\r\n\t\t\tbox.right = chart.chartArea.right;\r\n\t\t\tbox.bottom = chart.chartArea.bottom;\r\n\r\n\t\t\tbox.update(maxChartAreaWidth, maxChartAreaHeight);\r\n\t\t});\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.layouts.js","name":"sortByWeight","start_line":11,"end_line":26,"comment":[],"params":["array","reverse"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.layouts.js","name":"sortByWeight","line":131,"func_location":"module.exports.update","func_start_line":109,"func_end_line":418,"args":["bottomBoxes",{"type":"boolean"}],"comment":["*\r\n\t * Fits boxes of the given chart into the given size by having each box measure itself\r\n\t * then running a fitting algorithm\r\n\t * @param {Chart} chart - the chart\r\n\t * @param {Number} width - the width to fit into\r\n\t * @param {Number} height - the height to fit into\r\n\t "],"code":"\tupdate: function(chart, width, height) {\r\n\t\tif (!chart) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar layoutOptions = chart.options.layout || {};\r\n\t\tvar padding = helpers.options.toPadding(layoutOptions.padding);\r\n\t\tvar leftPadding = padding.left;\r\n\t\tvar rightPadding = padding.right;\r\n\t\tvar topPadding = padding.top;\r\n\t\tvar bottomPadding = padding.bottom;\r\n\r\n\t\tvar leftBoxes = filterByPosition(chart.boxes, 'left');\r\n\t\tvar rightBoxes = filterByPosition(chart.boxes, 'right');\r\n\t\tvar topBoxes = filterByPosition(chart.boxes, 'top');\r\n\t\tvar bottomBoxes = filterByPosition(chart.boxes, 'bottom');\r\n\t\tvar chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');\r\n\r\n\t\t// Sort boxes by weight. A higher weight is further away from the chart area\r\n\t\tsortByWeight(leftBoxes, true);\r\n\t\tsortByWeight(rightBoxes, false);\r\n\t\tsortByWeight(topBoxes, true);\r\n\t\tsortByWeight(bottomBoxes, false);\r\n\r\n\t\t// Essentially we now have any number of boxes on each of the 4 sides.\r\n\t\t// Our canvas looks like the following.\r\n\t\t// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\r\n\t\t// B1 is the bottom axis\r\n\t\t// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\r\n\t\t// These locations are single-box locations only, when trying to register a chartArea location that is already taken,\r\n\t\t// an error will be thrown.\r\n\t\t//\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |                  T1 (Full Width)                   |\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |    |    |                 T2                  |    |\r\n\t\t// |    |----|-------------------------------------|----|\r\n\t\t// |    |    | C1 |                           | C2 |    |\r\n\t\t// |    |    |----|                           |----|    |\r\n\t\t// |    |    |                                     |    |\r\n\t\t// | L1 | L2 |           ChartArea (C0)            | R1 |\r\n\t\t// |    |    |                                     |    |\r\n\t\t// |    |    |----|                           |----|    |\r\n\t\t// |    |    | C3 |                           | C4 |    |\r\n\t\t// |    |----|-------------------------------------|----|\r\n\t\t// |    |    |                 B1                  |    |\r\n\t\t// |----------------------------------------------------|\r\n\t\t// |                  B2 (Full Width)                   |\r\n\t\t// |----------------------------------------------------|\r\n\t\t//\r\n\t\t// What we do to find the best sizing, we do the following\r\n\t\t// 1. Determine the minimum size of the chart area.\r\n\t\t// 2. Split the remaining width equally between each vertical axis\r\n\t\t// 3. Split the remaining height equally between each horizontal axis\r\n\t\t// 4. Give each layout the maximum size it can be. The layout will return it's minimum size\r\n\t\t// 5. Adjust the sizes of each axis based on it's minimum reported size.\r\n\t\t// 6. Refit each axis\r\n\t\t// 7. Position each axis in the final location\r\n\t\t// 8. Tell the chart the final location of the chart area\r\n\t\t// 9. Tell any axes that overlay the chart area the positions of the chart area\r\n\r\n\t\t// Step 1\r\n\t\tvar chartWidth = width - leftPadding - rightPadding;\r\n\t\tvar chartHeight = height - topPadding - bottomPadding;\r\n\t\tvar chartAreaWidth = chartWidth / 2; // min 50%\r\n\t\tvar chartAreaHeight = chartHeight / 2; // min 50%\r\n\r\n\t\t// Step 2\r\n\t\tvar verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);\r\n\r\n\t\t// Step 3\r\n\t\tvar horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);\r\n\r\n\t\t// Step 4\r\n\t\tvar maxChartAreaWidth = chartWidth;\r\n\t\tvar maxChartAreaHeight = chartHeight;\r\n\t\tvar minBoxSizes = [];\r\n\r\n\t\tfunction getMinimumBoxSize(box) {\r\n\t\t\tvar minSize;\r\n\t\t\tvar isHorizontal = box.isHorizontal();\r\n\r\n\t\t\tif (isHorizontal) {\r\n\t\t\t\tminSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);\r\n\t\t\t\tmaxChartAreaHeight -= minSize.height;\r\n\t\t\t} else {\r\n\t\t\t\tminSize = box.update(verticalBoxWidth, maxChartAreaHeight);\r\n\t\t\t\tmaxChartAreaWidth -= minSize.width;\r\n\t\t\t}\r\n\r\n\t\t\tminBoxSizes.push({\r\n\t\t\t\thorizontal: isHorizontal,\r\n\t\t\t\tminSize: minSize,\r\n\t\t\t\tbox: box,\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);\r\n\r\n\t\t// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)\r\n\t\tvar maxHorizontalLeftPadding = 0;\r\n\t\tvar maxHorizontalRightPadding = 0;\r\n\t\tvar maxVerticalTopPadding = 0;\r\n\t\tvar maxVerticalBottomPadding = 0;\r\n\r\n\t\thelpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {\r\n\t\t\tif (horizontalBox.getPadding) {\r\n\t\t\t\tvar boxPadding = horizontalBox.getPadding();\r\n\t\t\t\tmaxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);\r\n\t\t\t\tmaxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {\r\n\t\t\tif (verticalBox.getPadding) {\r\n\t\t\t\tvar boxPadding = verticalBox.getPadding();\r\n\t\t\t\tmaxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);\r\n\t\t\t\tmaxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\r\n\t\t// be if the axes are drawn at their minimum sizes.\r\n\t\t// Steps 5 & 6\r\n\t\tvar totalLeftBoxesWidth = leftPadding;\r\n\t\tvar totalRightBoxesWidth = rightPadding;\r\n\t\tvar totalTopBoxesHeight = topPadding;\r\n\t\tvar totalBottomBoxesHeight = bottomPadding;\r\n\r\n\t\t// Function to fit a box\r\n\t\tfunction fitBox(box) {\r\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {\r\n\t\t\t\treturn minBox.box === box;\r\n\t\t\t});\r\n\r\n\t\t\tif (minBoxSize) {\r\n\t\t\t\tif (box.isHorizontal()) {\r\n\t\t\t\t\tvar scaleMargin = {\r\n\t\t\t\t\t\tleft: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),\r\n\t\t\t\t\t\tright: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),\r\n\t\t\t\t\t\ttop: 0,\r\n\t\t\t\t\t\tbottom: 0\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\r\n\t\t\t\t\t// on the margin. Sometimes they need to increase in size slightly\r\n\t\t\t\t\tbox.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Update, and calculate the left and right margins for the horizontal boxes\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes), fitBox);\r\n\r\n\t\thelpers.each(leftBoxes, function(box) {\r\n\t\t\ttotalLeftBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\thelpers.each(rightBoxes, function(box) {\r\n\t\t\ttotalRightBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\t// Set the Left and Right margins for the horizontal boxes\r\n\t\thelpers.each(topBoxes.concat(bottomBoxes), fitBox);\r\n\r\n\t\t// Figure out how much margin is on the top and bottom of the vertical boxes\r\n\t\thelpers.each(topBoxes, function(box) {\r\n\t\t\ttotalTopBoxesHeight += box.height;\r\n\t\t});\r\n\r\n\t\thelpers.each(bottomBoxes, function(box) {\r\n\t\t\ttotalBottomBoxesHeight += box.height;\r\n\t\t});\r\n\r\n\t\tfunction finalFitVerticalBox(box) {\r\n\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {\r\n\t\t\t\treturn minSize.box === box;\r\n\t\t\t});\r\n\r\n\t\t\tvar scaleMargin = {\r\n\t\t\t\tleft: 0,\r\n\t\t\t\tright: 0,\r\n\t\t\t\ttop: totalTopBoxesHeight,\r\n\t\t\t\tbottom: totalBottomBoxesHeight\r\n\t\t\t};\r\n\r\n\t\t\tif (minBoxSize) {\r\n\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Let the left layout know the final margin\r\n\t\thelpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);\r\n\r\n\t\t// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\r\n\t\ttotalLeftBoxesWidth = leftPadding;\r\n\t\ttotalRightBoxesWidth = rightPadding;\r\n\t\ttotalTopBoxesHeight = topPadding;\r\n\t\ttotalBottomBoxesHeight = bottomPadding;\r\n\r\n\t\thelpers.each(leftBoxes, function(box) {\r\n\t\t\ttotalLeftBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\thelpers.each(rightBoxes, function(box) {\r\n\t\t\ttotalRightBoxesWidth += box.width;\r\n\t\t});\r\n\r\n\t\thelpers.each(topBoxes, function(box) {\r\n\t\t\ttotalTopBoxesHeight += box.height;\r\n\t\t});\r\n\t\thelpers.each(bottomBoxes, function(box) {\r\n\t\t\ttotalBottomBoxesHeight += box.height;\r\n\t\t});\r\n\r\n\t\t// We may be adding some padding to account for rotated x axis labels\r\n\t\tvar leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);\r\n\t\ttotalLeftBoxesWidth += leftPaddingAddition;\r\n\t\ttotalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);\r\n\r\n\t\tvar topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);\r\n\t\ttotalTopBoxesHeight += topPaddingAddition;\r\n\t\ttotalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);\r\n\r\n\t\t// Figure out if our chart area changed. This would occur if the dataset layout label rotation\r\n\t\t// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\r\n\t\t// without calling `fit` again\r\n\t\tvar newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;\r\n\t\tvar newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;\r\n\r\n\t\tif (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\r\n\t\t\thelpers.each(leftBoxes, function(box) {\r\n\t\t\t\tbox.height = newMaxChartAreaHeight;\r\n\t\t\t});\r\n\r\n\t\t\thelpers.each(rightBoxes, function(box) {\r\n\t\t\t\tbox.height = newMaxChartAreaHeight;\r\n\t\t\t});\r\n\r\n\t\t\thelpers.each(topBoxes, function(box) {\r\n\t\t\t\tif (!box.fullWidth) {\r\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\thelpers.each(bottomBoxes, function(box) {\r\n\t\t\t\tif (!box.fullWidth) {\r\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tmaxChartAreaHeight = newMaxChartAreaHeight;\r\n\t\t\tmaxChartAreaWidth = newMaxChartAreaWidth;\r\n\t\t}\r\n\r\n\t\t// Step 7 - Position the boxes\r\n\t\tvar left = leftPadding + leftPaddingAddition;\r\n\t\tvar top = topPadding + topPaddingAddition;\r\n\r\n\t\tfunction placeBox(box) {\r\n\t\t\tif (box.isHorizontal()) {\r\n\t\t\t\tbox.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;\r\n\t\t\t\tbox.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;\r\n\t\t\t\tbox.top = top;\r\n\t\t\t\tbox.bottom = top + box.height;\r\n\r\n\t\t\t\t// Move to next point\r\n\t\t\t\ttop = box.bottom;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbox.left = left;\r\n\t\t\t\tbox.right = left + box.width;\r\n\t\t\t\tbox.top = totalTopBoxesHeight;\r\n\t\t\t\tbox.bottom = totalTopBoxesHeight + maxChartAreaHeight;\r\n\r\n\t\t\t\t// Move to next point\r\n\t\t\t\tleft = box.right;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\thelpers.each(leftBoxes.concat(topBoxes), placeBox);\r\n\r\n\t\t// Account for chart width and height\r\n\t\tleft += maxChartAreaWidth;\r\n\t\ttop += maxChartAreaHeight;\r\n\r\n\t\thelpers.each(rightBoxes, placeBox);\r\n\t\thelpers.each(bottomBoxes, placeBox);\r\n\r\n\t\t// Step 8\r\n\t\tchart.chartArea = {\r\n\t\t\tleft: totalLeftBoxesWidth,\r\n\t\t\ttop: totalTopBoxesHeight,\r\n\t\t\tright: totalLeftBoxesWidth + maxChartAreaWidth,\r\n\t\t\tbottom: totalTopBoxesHeight + maxChartAreaHeight\r\n\t\t};\r\n\r\n\t\t// Step 9\r\n\t\thelpers.each(chartAreaBoxes, function(box) {\r\n\t\t\tbox.left = chart.chartArea.left;\r\n\t\t\tbox.top = chart.chartArea.top;\r\n\t\t\tbox.right = chart.chartArea.right;\r\n\t\t\tbox.bottom = chart.chartArea.bottom;\r\n\r\n\t\t\tbox.update(maxChartAreaWidth, maxChartAreaHeight);\r\n\t\t});\r\n\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.layouts.js","name":"sortByWeight","start_line":11,"end_line":26,"comment":[],"params":["array","reverse"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.controller.js","name":"updateConfig","line":381,"func_location":"update","func_start_line":370,"func_end_line":433,"args":["me"],"code":"\t\tupdate: function(config) {\r\n\t\t\tvar me = this;\r\n\r\n\t\t\tif (!config || typeof config !== 'object') {\r\n\t\t\t\t// backwards compatibility\r\n\t\t\t\tconfig = {\r\n\t\t\t\t\tduration: config,\r\n\t\t\t\t\tlazy: arguments[1]\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tupdateConfig(me);\r\n\r\n\t\t\t// plugins options references might have change, let's invalidate the cache\r\n\t\t\t// https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\r\n\t\t\tplugins._invalidate(me);\r\n\r\n\t\t\tif (plugins.notify(me, 'beforeUpdate') === false) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// In case the entire data object changed\r\n\t\t\tme.tooltip._data = me.data;\r\n\r\n\t\t\t// Make sure dataset controllers are updated and new controllers are reset\r\n\t\t\tvar newControllers = me.buildOrUpdateControllers();\r\n\r\n\t\t\t// Make sure all dataset controllers have correct meta data counts\r\n\t\t\thelpers.each(me.data.datasets, function(dataset, datasetIndex) {\r\n\t\t\t\tme.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();\r\n\t\t\t}, me);\r\n\r\n\t\t\tme.updateLayout();\r\n\r\n\t\t\t// Can only reset the new controllers after the scales have been updated\r\n\t\t\tif (me.options.animation && me.options.animation.duration) {\r\n\t\t\t\thelpers.each(newControllers, function(controller) {\r\n\t\t\t\t\tcontroller.reset();\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tme.updateDatasets();\r\n\r\n\t\t\t// Need to reset tooltip in case it is displayed with elements that are removed\r\n\t\t\t// after update.\r\n\t\t\tme.tooltip.initialize();\r\n\r\n\t\t\t// Last active contains items that were previously in the tooltip.\r\n\t\t\t// When we reset the tooltip, we need to clear it\r\n\t\t\tme.lastActive = [];\r\n\r\n\t\t\t// Do this before render so that any plugins that need final scale updates can use it\r\n\t\t\tplugins.notify(me, 'afterUpdate');\r\n\r\n\t\t\tif (me._bufferedRender) {\r\n\t\t\t\tme._bufferedRequest = {\r\n\t\t\t\t\tduration: config.duration,\r\n\t\t\t\t\teasing: config.easing,\r\n\t\t\t\t\tlazy: config.lazy\r\n\t\t\t\t};\r\n\t\t\t} else {\r\n\t\t\t\tme.render(config);\r\n\t\t\t}\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.controller.js","name":"module.exports.updateConfig","start_line":48,"end_line":66,"comment":["*\r\n\t * Updates the config of the chart\r\n\t * @param chart {Chart} chart to update the options for\r\n\t "],"params":["chart"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.radar.js","name":"capControlPoint","line":146,"func_location":"updateBezierControlPoints","func_start_line":125,"func_end_line":151,"args":["controlPoints.previous.x","area.left","area.right"],"code":"\tupdateBezierControlPoints: function() {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar area = me.chart.chartArea;\r\n\t\tvar points = meta.data || [];\r\n\t\tvar i, ilen, model, controlPoints;\r\n\r\n\t\tfunction capControlPoint(pt, min, max) {\r\n\t\t\treturn Math.max(Math.min(pt, max), min);\r\n\t\t}\r\n\r\n\t\tfor (i = 0, ilen = points.length; i < ilen; i++) {\r\n\t\t\tmodel = points[i]._model;\r\n\t\t\tcontrolPoints = helpers.splineCurve(\r\n\t\t\t\thelpers.previousItem(points, i, true)._model,\r\n\t\t\t\tmodel,\r\n\t\t\t\thelpers.nextItem(points, i, true)._model,\r\n\t\t\t\tmodel.tension\r\n\t\t\t);\r\n\r\n\t\t\t// Prevent the bezier going outside of the bounds of the graph\r\n\t\t\tmodel.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area.left, area.right);\r\n\t\t\tmodel.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area.top, area.bottom);\r\n\t\t\tmodel.controlPointNextX = capControlPoint(controlPoints.next.x, area.left, area.right);\r\n\t\t\tmodel.controlPointNextY = capControlPoint(controlPoints.next.y, area.top, area.bottom);\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.radar.js","name":"updateBezierControlPoints.capControlPoint","start_line":132,"end_line":134,"comment":[],"params":["pt","min","max"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.radar.js","name":"capControlPoint","line":147,"func_location":"updateBezierControlPoints","func_start_line":125,"func_end_line":151,"args":["controlPoints.previous.y","area.top","area.bottom"],"code":"\tupdateBezierControlPoints: function() {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar area = me.chart.chartArea;\r\n\t\tvar points = meta.data || [];\r\n\t\tvar i, ilen, model, controlPoints;\r\n\r\n\t\tfunction capControlPoint(pt, min, max) {\r\n\t\t\treturn Math.max(Math.min(pt, max), min);\r\n\t\t}\r\n\r\n\t\tfor (i = 0, ilen = points.length; i < ilen; i++) {\r\n\t\t\tmodel = points[i]._model;\r\n\t\t\tcontrolPoints = helpers.splineCurve(\r\n\t\t\t\thelpers.previousItem(points, i, true)._model,\r\n\t\t\t\tmodel,\r\n\t\t\t\thelpers.nextItem(points, i, true)._model,\r\n\t\t\t\tmodel.tension\r\n\t\t\t);\r\n\r\n\t\t\t// Prevent the bezier going outside of the bounds of the graph\r\n\t\t\tmodel.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area.left, area.right);\r\n\t\t\tmodel.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area.top, area.bottom);\r\n\t\t\tmodel.controlPointNextX = capControlPoint(controlPoints.next.x, area.left, area.right);\r\n\t\t\tmodel.controlPointNextY = capControlPoint(controlPoints.next.y, area.top, area.bottom);\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.radar.js","name":"updateBezierControlPoints.capControlPoint","start_line":132,"end_line":134,"comment":[],"params":["pt","min","max"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.radar.js","name":"capControlPoint","line":148,"func_location":"updateBezierControlPoints","func_start_line":125,"func_end_line":151,"args":["controlPoints.next.x","area.left","area.right"],"code":"\tupdateBezierControlPoints: function() {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar area = me.chart.chartArea;\r\n\t\tvar points = meta.data || [];\r\n\t\tvar i, ilen, model, controlPoints;\r\n\r\n\t\tfunction capControlPoint(pt, min, max) {\r\n\t\t\treturn Math.max(Math.min(pt, max), min);\r\n\t\t}\r\n\r\n\t\tfor (i = 0, ilen = points.length; i < ilen; i++) {\r\n\t\t\tmodel = points[i]._model;\r\n\t\t\tcontrolPoints = helpers.splineCurve(\r\n\t\t\t\thelpers.previousItem(points, i, true)._model,\r\n\t\t\t\tmodel,\r\n\t\t\t\thelpers.nextItem(points, i, true)._model,\r\n\t\t\t\tmodel.tension\r\n\t\t\t);\r\n\r\n\t\t\t// Prevent the bezier going outside of the bounds of the graph\r\n\t\t\tmodel.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area.left, area.right);\r\n\t\t\tmodel.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area.top, area.bottom);\r\n\t\t\tmodel.controlPointNextX = capControlPoint(controlPoints.next.x, area.left, area.right);\r\n\t\t\tmodel.controlPointNextY = capControlPoint(controlPoints.next.y, area.top, area.bottom);\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.radar.js","name":"updateBezierControlPoints.capControlPoint","start_line":132,"end_line":134,"comment":[],"params":["pt","min","max"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.radar.js","name":"capControlPoint","line":149,"func_location":"updateBezierControlPoints","func_start_line":125,"func_end_line":151,"args":["controlPoints.next.y","area.top","area.bottom"],"code":"\tupdateBezierControlPoints: function() {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar area = me.chart.chartArea;\r\n\t\tvar points = meta.data || [];\r\n\t\tvar i, ilen, model, controlPoints;\r\n\r\n\t\tfunction capControlPoint(pt, min, max) {\r\n\t\t\treturn Math.max(Math.min(pt, max), min);\r\n\t\t}\r\n\r\n\t\tfor (i = 0, ilen = points.length; i < ilen; i++) {\r\n\t\t\tmodel = points[i]._model;\r\n\t\t\tcontrolPoints = helpers.splineCurve(\r\n\t\t\t\thelpers.previousItem(points, i, true)._model,\r\n\t\t\t\tmodel,\r\n\t\t\t\thelpers.nextItem(points, i, true)._model,\r\n\t\t\t\tmodel.tension\r\n\t\t\t);\r\n\r\n\t\t\t// Prevent the bezier going outside of the bounds of the graph\r\n\t\t\tmodel.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area.left, area.right);\r\n\t\t\tmodel.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area.top, area.bottom);\r\n\t\t\tmodel.controlPointNextX = capControlPoint(controlPoints.next.x, area.left, area.right);\r\n\t\t\tmodel.controlPointNextY = capControlPoint(controlPoints.next.y, area.top, area.bottom);\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.radar.js","name":"updateBezierControlPoints.capControlPoint","start_line":132,"end_line":134,"comment":[],"params":["pt","min","max"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.line.js","name":"capControlPoint","line":284,"func_location":"updateBezierControlPoints","func_start_line":244,"func_end_line":290,"args":["model.controlPointPreviousX","area.left","area.right"],"code":"\tupdateBezierControlPoints: function() {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar area = me.chart.chartArea;\r\n\t\tvar points = (meta.data || []);\r\n\t\tvar i, ilen, point, model, controlPoints;\r\n\r\n\t\t// Only consider points that are drawn in case the spanGaps option is used\r\n\t\tif (meta.dataset._model.spanGaps) {\r\n\t\t\tpoints = points.filter(function(pt) {\r\n\t\t\t\treturn !pt._model.skip;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tfunction capControlPoint(pt, min, max) {\r\n\t\t\treturn Math.max(Math.min(pt, max), min);\r\n\t\t}\r\n\r\n\t\tif (meta.dataset._model.cubicInterpolationMode === 'monotone') {\r\n\t\t\thelpers.splineCurveMonotone(points);\r\n\t\t} else {\r\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\r\n\t\t\t\tpoint = points[i];\r\n\t\t\t\tmodel = point._model;\r\n\t\t\t\tcontrolPoints = helpers.splineCurve(\r\n\t\t\t\t\thelpers.previousItem(points, i)._model,\r\n\t\t\t\t\tmodel,\r\n\t\t\t\t\thelpers.nextItem(points, i)._model,\r\n\t\t\t\t\tmeta.dataset._model.tension\r\n\t\t\t\t);\r\n\t\t\t\tmodel.controlPointPreviousX = controlPoints.previous.x;\r\n\t\t\t\tmodel.controlPointPreviousY = controlPoints.previous.y;\r\n\t\t\t\tmodel.controlPointNextX = controlPoints.next.x;\r\n\t\t\t\tmodel.controlPointNextY = controlPoints.next.y;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (me.chart.options.elements.line.capBezierPoints) {\r\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\r\n\t\t\t\tmodel = points[i]._model;\r\n\t\t\t\tmodel.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);\r\n\t\t\t\tmodel.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);\r\n\t\t\t\tmodel.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);\r\n\t\t\t\tmodel.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.line.js","name":"updateBezierControlPoints.capControlPoint","start_line":258,"end_line":260,"comment":[],"params":["pt","min","max"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.line.js","name":"capControlPoint","line":285,"func_location":"updateBezierControlPoints","func_start_line":244,"func_end_line":290,"args":["model.controlPointPreviousY","area.top","area.bottom"],"code":"\tupdateBezierControlPoints: function() {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar area = me.chart.chartArea;\r\n\t\tvar points = (meta.data || []);\r\n\t\tvar i, ilen, point, model, controlPoints;\r\n\r\n\t\t// Only consider points that are drawn in case the spanGaps option is used\r\n\t\tif (meta.dataset._model.spanGaps) {\r\n\t\t\tpoints = points.filter(function(pt) {\r\n\t\t\t\treturn !pt._model.skip;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tfunction capControlPoint(pt, min, max) {\r\n\t\t\treturn Math.max(Math.min(pt, max), min);\r\n\t\t}\r\n\r\n\t\tif (meta.dataset._model.cubicInterpolationMode === 'monotone') {\r\n\t\t\thelpers.splineCurveMonotone(points);\r\n\t\t} else {\r\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\r\n\t\t\t\tpoint = points[i];\r\n\t\t\t\tmodel = point._model;\r\n\t\t\t\tcontrolPoints = helpers.splineCurve(\r\n\t\t\t\t\thelpers.previousItem(points, i)._model,\r\n\t\t\t\t\tmodel,\r\n\t\t\t\t\thelpers.nextItem(points, i)._model,\r\n\t\t\t\t\tmeta.dataset._model.tension\r\n\t\t\t\t);\r\n\t\t\t\tmodel.controlPointPreviousX = controlPoints.previous.x;\r\n\t\t\t\tmodel.controlPointPreviousY = controlPoints.previous.y;\r\n\t\t\t\tmodel.controlPointNextX = controlPoints.next.x;\r\n\t\t\t\tmodel.controlPointNextY = controlPoints.next.y;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (me.chart.options.elements.line.capBezierPoints) {\r\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\r\n\t\t\t\tmodel = points[i]._model;\r\n\t\t\t\tmodel.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);\r\n\t\t\t\tmodel.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);\r\n\t\t\t\tmodel.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);\r\n\t\t\t\tmodel.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.line.js","name":"updateBezierControlPoints.capControlPoint","start_line":258,"end_line":260,"comment":[],"params":["pt","min","max"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.line.js","name":"capControlPoint","line":286,"func_location":"updateBezierControlPoints","func_start_line":244,"func_end_line":290,"args":["model.controlPointNextX","area.left","area.right"],"code":"\tupdateBezierControlPoints: function() {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar area = me.chart.chartArea;\r\n\t\tvar points = (meta.data || []);\r\n\t\tvar i, ilen, point, model, controlPoints;\r\n\r\n\t\t// Only consider points that are drawn in case the spanGaps option is used\r\n\t\tif (meta.dataset._model.spanGaps) {\r\n\t\t\tpoints = points.filter(function(pt) {\r\n\t\t\t\treturn !pt._model.skip;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tfunction capControlPoint(pt, min, max) {\r\n\t\t\treturn Math.max(Math.min(pt, max), min);\r\n\t\t}\r\n\r\n\t\tif (meta.dataset._model.cubicInterpolationMode === 'monotone') {\r\n\t\t\thelpers.splineCurveMonotone(points);\r\n\t\t} else {\r\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\r\n\t\t\t\tpoint = points[i];\r\n\t\t\t\tmodel = point._model;\r\n\t\t\t\tcontrolPoints = helpers.splineCurve(\r\n\t\t\t\t\thelpers.previousItem(points, i)._model,\r\n\t\t\t\t\tmodel,\r\n\t\t\t\t\thelpers.nextItem(points, i)._model,\r\n\t\t\t\t\tmeta.dataset._model.tension\r\n\t\t\t\t);\r\n\t\t\t\tmodel.controlPointPreviousX = controlPoints.previous.x;\r\n\t\t\t\tmodel.controlPointPreviousY = controlPoints.previous.y;\r\n\t\t\t\tmodel.controlPointNextX = controlPoints.next.x;\r\n\t\t\t\tmodel.controlPointNextY = controlPoints.next.y;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (me.chart.options.elements.line.capBezierPoints) {\r\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\r\n\t\t\t\tmodel = points[i]._model;\r\n\t\t\t\tmodel.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);\r\n\t\t\t\tmodel.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);\r\n\t\t\t\tmodel.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);\r\n\t\t\t\tmodel.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.line.js","name":"updateBezierControlPoints.capControlPoint","start_line":258,"end_line":260,"comment":[],"params":["pt","min","max"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.line.js","name":"capControlPoint","line":287,"func_location":"updateBezierControlPoints","func_start_line":244,"func_end_line":290,"args":["model.controlPointNextY","area.top","area.bottom"],"code":"\tupdateBezierControlPoints: function() {\r\n\t\tvar me = this;\r\n\t\tvar meta = me.getMeta();\r\n\t\tvar area = me.chart.chartArea;\r\n\t\tvar points = (meta.data || []);\r\n\t\tvar i, ilen, point, model, controlPoints;\r\n\r\n\t\t// Only consider points that are drawn in case the spanGaps option is used\r\n\t\tif (meta.dataset._model.spanGaps) {\r\n\t\t\tpoints = points.filter(function(pt) {\r\n\t\t\t\treturn !pt._model.skip;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tfunction capControlPoint(pt, min, max) {\r\n\t\t\treturn Math.max(Math.min(pt, max), min);\r\n\t\t}\r\n\r\n\t\tif (meta.dataset._model.cubicInterpolationMode === 'monotone') {\r\n\t\t\thelpers.splineCurveMonotone(points);\r\n\t\t} else {\r\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\r\n\t\t\t\tpoint = points[i];\r\n\t\t\t\tmodel = point._model;\r\n\t\t\t\tcontrolPoints = helpers.splineCurve(\r\n\t\t\t\t\thelpers.previousItem(points, i)._model,\r\n\t\t\t\t\tmodel,\r\n\t\t\t\t\thelpers.nextItem(points, i)._model,\r\n\t\t\t\t\tmeta.dataset._model.tension\r\n\t\t\t\t);\r\n\t\t\t\tmodel.controlPointPreviousX = controlPoints.previous.x;\r\n\t\t\t\tmodel.controlPointPreviousY = controlPoints.previous.y;\r\n\t\t\t\tmodel.controlPointNextX = controlPoints.next.x;\r\n\t\t\t\tmodel.controlPointNextY = controlPoints.next.y;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (me.chart.options.elements.line.capBezierPoints) {\r\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\r\n\t\t\t\tmodel = points[i]._model;\r\n\t\t\t\tmodel.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);\r\n\t\t\t\tmodel.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);\r\n\t\t\t\tmodel.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);\r\n\t\t\t\tmodel.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/controllers/controller.line.js","name":"updateBezierControlPoints.capControlPoint","start_line":258,"end_line":260,"comment":[],"params":["pt","min","max"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"valueOrDefault","line":88,"func_location":"helpers.valueAtIndexOrDefault","func_start_line":87,"func_end_line":89,"args":[null,"defaultValue"],"comment":["*\r\n\t * Returns value at the given `index` in array if defined, else returns `defaultValue`.\r\n\t * @param {Array} value - The array to lookup for value at `index`.\r\n\t * @param {Number} index - The index in `value` to lookup for value.\r\n\t * @param {*} defaultValue - The value to return if `value[index]` is undefined.\r\n\t * @returns {*}\r\n\t "],"code":"\tvalueAtIndexOrDefault: function(value, index, defaultValue) {\r\n\t\treturn helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"helpers.valueOrDefault","start_line":76,"end_line":78,"comment":["*\r\n\t * Returns `value` if defined, else returns `defaultValue`.\r\n\t * @param {*} value - The value to return if defined.\r\n\t * @param {*} defaultValue - The value to return if `value` is undefined.\r\n\t * @returns {*}\r\n\t "],"params":["value","defaultValue"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"isArray","line":88,"func_location":"helpers.valueAtIndexOrDefault","func_start_line":87,"func_end_line":89,"args":[null,"defaultValue"],"comment":["*\r\n\t * Returns value at the given `index` in array if defined, else returns `defaultValue`.\r\n\t * @param {Array} value - The array to lookup for value at `index`.\r\n\t * @param {Number} index - The index in `value` to lookup for value.\r\n\t * @param {*} defaultValue - The value to return if `value[index]` is undefined.\r\n\t * @returns {*}\r\n\t "],"code":"\tvalueAtIndexOrDefault: function(value, index, defaultValue) {\r\n\t\treturn helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);\r\n\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/helpers/helpers.core.js","name":"helpers.isArray","start_line":40,"end_line":49,"comment":["*\r\n\t * Returns true if `value` is an array (including typed arrays), else returns false.\r\n\t * @param {*} value - The value to test.\r\n\t * @returns {Boolean}\r\n\t * @function\r\n\t "],"params":["value"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getRelativePosition","line":258,"func_location":"module.exports.modes.x","func_start_line":257,"func_end_line":278,"args":["e","chart"],"comment":["*\r\n\t\t * x mode returns the elements that hit-test at the current x coordinate\r\n\t\t * @function Chart.Interaction.modes.x\r\n\t\t * @param chart {chart} the chart we are returning items from\r\n\t\t * @param e {Event} the event we are find things at\r\n\t\t * @param options {IInteractionOptions} options to use\r\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n\t\t "],"code":"\t\tx: function(chart, e, options) {\r\n\t\t\tvar position = getRelativePosition(e, chart);\r\n\t\t\tvar items = [];\r\n\t\t\tvar intersectsItem = false;\r\n\r\n\t\t\tparseVisibleItems(chart, function(element) {\r\n\t\t\t\tif (element.inXRange(position.x)) {\r\n\t\t\t\t\titems.push(element);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (element.inRange(position.x, position.y)) {\r\n\t\t\t\t\tintersectsItem = true;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t// If we want to trigger on an intersect and we don't have any items\r\n\t\t\t// that intersect the position, return nothing\r\n\t\t\tif (options.intersect && !intersectsItem) {\r\n\t\t\t\titems = [];\r\n\t\t\t}\r\n\t\t\treturn items;\r\n\t\t},\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getRelativePosition","start_line":11,"end_line":20,"comment":["*\r\n * Helper function to get relative position for an event\r\n * @param {Event|IEvent} event - The event to get the position for\r\n * @param {Chart} chart - The chart\r\n * @returns {Point} the event position\r\n "],"params":["e","chart"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"parseVisibleItems","line":262,"func_location":"module.exports.modes.x","func_start_line":257,"func_end_line":278},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"parseVisibleItems","start_line":27,"end_line":44,"comment":["*\r\n * Helper function to traverse all of the visible elements in the chart\r\n * @param chart {chart} the chart\r\n * @param handler {Function} the callback to execute for each visible item\r\n "],"params":["chart","handler"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getRelativePosition","line":289,"func_location":"module.exports.modes.y","func_start_line":288,"func_end_line":309,"args":["e","chart"],"comment":["*\r\n\t\t * y mode returns the elements that hit-test at the current y coordinate\r\n\t\t * @function Chart.Interaction.modes.y\r\n\t\t * @param chart {chart} the chart we are returning items from\r\n\t\t * @param e {Event} the event we are find things at\r\n\t\t * @param options {IInteractionOptions} options to use\r\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n\t\t "],"code":"\t\ty: function(chart, e, options) {\r\n\t\t\tvar position = getRelativePosition(e, chart);\r\n\t\t\tvar items = [];\r\n\t\t\tvar intersectsItem = false;\r\n\r\n\t\t\tparseVisibleItems(chart, function(element) {\r\n\t\t\t\tif (element.inYRange(position.y)) {\r\n\t\t\t\t\titems.push(element);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (element.inRange(position.x, position.y)) {\r\n\t\t\t\t\tintersectsItem = true;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t// If we want to trigger on an intersect and we don't have any items\r\n\t\t\t// that intersect the position, return nothing\r\n\t\t\tif (options.intersect && !intersectsItem) {\r\n\t\t\t\titems = [];\r\n\t\t\t}\r\n\t\t\treturn items;\r\n\t\t}\r"},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"getRelativePosition","start_line":11,"end_line":20,"comment":["*\r\n * Helper function to get relative position for an event\r\n * @param {Event|IEvent} event - The event to get the position for\r\n * @param {Chart} chart - The chart\r\n * @returns {Point} the event position\r\n "],"params":["e","chart"]}},{"call_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"parseVisibleItems","line":293,"func_location":"module.exports.modes.y","func_start_line":288,"func_end_line":309},"func_info":{"file":"/home/zcl/Desktop/parametermismatch/dataset/Chart.js/src/core/core.interaction.js","name":"parseVisibleItems","start_line":27,"end_line":44,"comment":["*\r\n * Helper function to traverse all of the visible elements in the chart\r\n * @param chart {chart} the chart\r\n * @param handler {Function} the callback to execute for each visible item\r\n "],"params":["chart","handler"]}}]