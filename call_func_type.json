[
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/auto-updater-win32.js",
            "name": "parse",
            "line": 25,
            "func_location": "AutoUpdater.downloadUpdate.(unnamed_function_1)",
            "func_start_line": 18,
            "func_end_line": 34,
            "args": [
                "json"
            ],
            "code": "    SquirrelUpdate.spawn(['--download', this.updateUrl], function (error, stdout) {\r\n      let update\r\n      if (error != null) return callback(error)\r\n\r\n      try {\r\n        // Last line of output is the JSON details about the releases\r\n        const json = stdout.trim().split('\\n').pop()\r\n        const data = JSON.parse(json)\r\n        const releasesToApply = data && data.releasesToApply\r\n        if (releasesToApply.pop) update = releasesToApply.pop()\r\n      } catch (error) {\r\n        error.stdout = stdout\r\n        return callback(error)\r\n      }\r\n\r\n      callback(null, update)\r\n    })\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/color.js",
            "name": "Color.parse",
            "start_line": 14,
            "end_line": 36,
            "comment": [
                " Essential: Parse a {String} or {Object} into a {Color}.",
                "",
                " * `value` A {String} such as `'white'`, `#ff00ff`, or",
                "   `'rgba(255, 15, 60, .75)'` or an {Object} with `red`, `green`, `blue`,",
                "   and `alpha` properties.",
                "",
                " Returns a {Color} or `null` if it cannot be parsed."
            ],
            "params": [
                {
                    "name": "value",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "null"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/theme-manager.js",
            "name": "onDidChangeActiveThemes",
            "line": 27,
            "func_location": "ThemeManager.constructor.(unnamed_function_1)",
            "func_start_line": 26,
            "func_end_line": 28,
            "args": [
                null
            ],
            "code": "    this.packageManager.onDidActivateInitialPackages(() => {\r\n      this.onDidChangeActiveThemes(() => this.packageManager.reloadActivePackageStyleSheets())\r\n    })\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/theme-manager.js",
            "name": "ThemeManager.onDidChangeActiveThemes",
            "start_line": 55,
            "end_line": 57,
            "comment": [
                "\r\n  Section: Event Subscription\r\n  ",
                " Essential: Invoke `callback` when style sheet changes associated with",
                " updating the list of active themes have completed.",
                "",
                " * `callback` {Function}",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "showUpdateMenuItem",
            "line": 16,
            "func_location": "ApplicationMenu.constructor.(unnamed_function_1)",
            "func_start_line": 16,
            "func_end_line": 16,
            "args": [
                {
                    "type": "string"
                },
                null
            ],
            "code": "    this.autoUpdateManager.on('state-changed', state => this.showUpdateMenuItem(state))\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "ApplicationMenu.showUpdateMenuItem",
            "start_line": 109,
            "end_line": 140,
            "comment": [
                " Sets the proper visible state the update menu items"
            ],
            "params": [
                {
                    "name": "state",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/context-menu.js",
            "name": "createClickHandlers",
            "line": 29,
            "func_location": "ContextMenu.createClickHandlers.(unnamed_function_1)",
            "func_start_line": 16,
            "func_end_line": 31,
            "args": [
                "item.submenu"
            ],
            "code": "    template.forEach(item => {\r\n      if (item.command) {\r\n        if (!item.commandDetail) item.commandDetail = {}\r\n        item.commandDetail.contextCommand = true\r\n        item.commandDetail.atomWindow = this.atomWindow\r\n        item.click = () => {\r\n          global.atomApplication.sendCommandToWindow(\r\n            item.command,\r\n            this.atomWindow,\r\n            item.commandDetail\r\n          )\r\n        }\r\n      } else if (item.submenu) {\r\n        this.createClickHandlers(item.submenu)\r\n      }\r\n    })\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/context-menu.js",
            "name": "ContextMenu.createClickHandlers",
            "start_line": 15,
            "end_line": 32,
            "comment": [
                " It's necessary to build the event handlers in this process, otherwise",
                " closures are dragged across processes and failed to be garbage collected",
                " appropriately."
            ],
            "params": [
                {
                    "name": "template",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/workspace-element.js",
            "name": "remove",
            "line": 40,
            "func_location": "WorkspaceElement.observeScrollbarStyle.(unnamed_function_1)",
            "func_start_line": 37,
            "func_end_line": 48,
            "args": [
                {
                    "type": "string"
                }
            ],
            "code": "    this.subscriptions.add(scrollbarStyle.observePreferredScrollbarStyle(style => {\r\n      switch (style) {\r\n        case 'legacy':\r\n          this.classList.remove('scrollbars-visible-when-scrolling')\r\n          this.classList.add('scrollbars-visible-always')\r\n          break\r\n        case 'overlay':\r\n          this.classList.remove('scrollbars-visible-always')\r\n          this.classList.add('scrollbars-visible-when-scrolling')\r\n          break\r\n      }\r\n    }))\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/workspace-element.js",
            "name": "remove",
            "line": 44,
            "func_location": "WorkspaceElement.observeScrollbarStyle.(unnamed_function_1)",
            "func_start_line": 37,
            "func_end_line": 48,
            "args": [
                {
                    "type": "string"
                }
            ],
            "code": "    this.subscriptions.add(scrollbarStyle.observePreferredScrollbarStyle(style => {\r\n      switch (style) {\r\n        case 'legacy':\r\n          this.classList.remove('scrollbars-visible-when-scrolling')\r\n          this.classList.add('scrollbars-visible-always')\r\n          break\r\n        case 'overlay':\r\n          this.classList.remove('scrollbars-visible-always')\r\n          this.classList.add('scrollbars-visible-when-scrolling')\r\n          break\r\n      }\r\n    }))\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/atom-application.js",
            "name": "write",
            "line": 78,
            "func_location": "AtomApplication.open.client.(unnamed_function_1)",
            "func_start_line": 77,
            "func_end_line": 82,
            "args": [
                "options"
            ],
            "code": "    const client = net.connect({path: options.socketPath}, () => {\r\n      client.write(JSON.stringify(options), () => {\r\n        client.end()\r\n        app.quit()\r\n      })\r\n    })\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/clipboard.js",
            "name": "Clipboard.write",
            "start_line": 42,
            "end_line": 46,
            "comment": [
                " Public: Write the given text to the clipboard.",
                "",
                " The metadata associated with the text is available by calling",
                " {::readWithMetadata}.",
                "",
                " * `text` The {String} to store.",
                " * `metadata` (optional) The additional info to associate with the text."
            ],
            "params": [
                {
                    "name": "text",
                    "type": [
                        "string",
                        "optional"
                    ]
                },
                {
                    "name": "metadata",
                    "type": [
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/win-powershell.js",
            "name": "spawnPowershell",
            "line": 37,
            "func_location": "(unnamed_function_1)",
            "func_start_line": 36,
            "func_end_line": 45
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/win-powershell.js",
            "name": "spawnPowershell",
            "start_line": 13,
            "end_line": 28,
            "comment": [
                " Spawn powershell.exe and callback when it completes"
            ],
            "params": [
                {
                    "name": "args",
                    "type": []
                },
                {
                    "name": "callback",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/get-window-load-settings.js",
            "name": "parse",
            "line": 7,
            "func_location": "(unnamed_function_1)",
            "func_start_line": 5,
            "func_end_line": 10,
            "args": [
                ".loadSettingsJSON"
            ],
            "code": "module.exports = () => {\r\n  if (!windowLoadSettings) {\r\n    windowLoadSettings = JSON.parse(remote.getCurrentWindow().loadSettingsJSON)\r\n  }\r\n  return windowLoadSettings\r\n}\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/color.js",
            "name": "Color.parse",
            "start_line": 14,
            "end_line": 36,
            "comment": [
                " Essential: Parse a {String} or {Object} into a {Color}.",
                "",
                " * `value` A {String} such as `'white'`, `#ff00ff`, or",
                "   `'rgba(255, 15, 60, .75)'` or an {Object} with `red`, `green`, `blue`,",
                "   and `alpha` properties.",
                "",
                " Returns a {Color} or `null` if it cannot be parsed."
            ],
            "params": [
                {
                    "name": "value",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "null"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "acceleratorForCommand",
            "line": 202,
            "func_location": "ApplicationMenu.translateTemplate.(unnamed_function_14)",
            "func_start_line": 199,
            "func_end_line": 209,
            "args": [
                "item.command",
                "keystrokesByCommand"
            ],
            "code": "    template.forEach(item => {\r\n      if (item.metadata == null) item.metadata = {}\r\n      if (item.command) {\r\n        item.accelerator = this.acceleratorForCommand(item.command, keystrokesByCommand)\r\n        item.click = () => global.atomApplication.sendCommand(item.command, item.commandDetail)\r\n        if (!/^application:/.test(item.command)) {\r\n          item.metadata.windowSpecific = true\r\n        }\r\n      }\r\n      if (item.submenu) this.translateTemplate(item.submenu, keystrokesByCommand)\r\n    })\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "ApplicationMenu.acceleratorForCommand",
            "start_line": 221,
            "end_line": 224,
            "comment": [
                " Determine the accelerator for a given command.",
                "",
                " command - The name of the command.",
                " keystrokesByCommand - An Object where the keys are commands and the values",
                "                       are Arrays containing the keystroke.",
                "",
                " Returns a String containing the keystroke in a format that can be interpreted",
                "   by Electron to provide nice icons where available."
            ],
            "params": [
                {
                    "name": "command",
                    "type": [
                        "object"
                    ]
                },
                {
                    "name": "keystrokesByCommand",
                    "type": [
                        "object"
                    ]
                }
            ],
            "return_type": [
                "string"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "translateTemplate",
            "line": 208,
            "func_location": "ApplicationMenu.translateTemplate.(unnamed_function_14)",
            "func_start_line": 199,
            "func_end_line": 209,
            "args": [
                "item.submenu",
                "keystrokesByCommand"
            ],
            "code": "    template.forEach(item => {\r\n      if (item.metadata == null) item.metadata = {}\r\n      if (item.command) {\r\n        item.accelerator = this.acceleratorForCommand(item.command, keystrokesByCommand)\r\n        item.click = () => global.atomApplication.sendCommand(item.command, item.commandDetail)\r\n        if (!/^application:/.test(item.command)) {\r\n          item.metadata.windowSpecific = true\r\n        }\r\n      }\r\n      if (item.submenu) this.translateTemplate(item.submenu, keystrokesByCommand)\r\n    })\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "ApplicationMenu.translateTemplate",
            "start_line": 198,
            "end_line": 211,
            "comment": [
                " Combines a menu template with the appropriate keystroke.",
                "",
                " template - An Object conforming to atom-shell's menu api but lacking",
                "            accelerator and click properties.",
                " keystrokesByCommand - An Object where the keys are commands and the values",
                "                       are Arrays containing the keystroke.",
                "",
                " Returns a complete menu configuration object for atom-shell's menu API."
            ],
            "params": [
                {
                    "name": "template",
                    "type": [
                        "object"
                    ]
                },
                {
                    "name": "keystrokesByCommand",
                    "type": [
                        "object"
                    ]
                }
            ],
            "return_type": [
                "object"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "compare",
            "line": 1211,
            "func_location": "TextEditorComponent.populateTextDecorationsToRender.(unnamed_function_15)",
            "func_start_line": 1211,
            "func_end_line": 1211,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Sort all boundaries in ascending order of position"
            ],
            "code": "    this.textDecorationBoundaries.sort((a, b) => a.position.compare(b.position))\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.compare",
            "start_line": 654,
            "end_line": 656,
            "comment": [
                "\r\n  Section: Visibility\r\n  ",
                "\r\n  Section: Comparing to another cursor\r\n  ",
                " Public: Compare this cursor's buffer position to another cursor's buffer position.",
                "",
                " See {Point::compare} for more details.",
                "",
                " * `otherCursor`{Cursor} to compare against"
            ],
            "params": [
                {
                    "name": "otherCursor",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "compare",
            "line": 1211,
            "func_location": "TextEditorComponent.populateTextDecorationsToRender.(unnamed_function_15)",
            "func_start_line": 1211,
            "func_end_line": 1211,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Sort all boundaries in ascending order of position"
            ],
            "code": "    this.textDecorationBoundaries.sort((a, b) => a.position.compare(b.position))\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.compare",
            "start_line": 654,
            "end_line": 656,
            "comment": [
                "\r\n  Section: Visibility\r\n  ",
                "\r\n  Section: Comparing to another cursor\r\n  ",
                " Public: Compare this cursor's buffer position to another cursor's buffer position.",
                "",
                " See {Point::compare} for more details.",
                "",
                " * `otherCursor`{Cursor} to compare against"
            ],
            "params": [
                {
                    "name": "otherCursor",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "compare",
            "line": 1250,
            "func_location": "TextEditorComponent.populateTextDecorationsToRender.(unnamed_function_16)",
            "func_start_line": 1250,
            "func_end_line": 1250,
            "args": [
                null
            ],
            "code": "        boundary.starting.sort((a, b) => a.compare(b))\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.compare",
            "start_line": 654,
            "end_line": 656,
            "comment": [
                "\r\n  Section: Visibility\r\n  ",
                "\r\n  Section: Comparing to another cursor\r\n  ",
                " Public: Compare this cursor's buffer position to another cursor's buffer position.",
                "",
                " See {Point::compare} for more details.",
                "",
                " * `otherCursor`{Cursor} to compare against"
            ],
            "params": [
                {
                    "name": "otherCursor",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "compare",
            "line": 1255,
            "func_location": "TextEditorComponent.populateTextDecorationsToRender.(unnamed_function_17)",
            "func_start_line": 1255,
            "func_end_line": 1255,
            "args": [
                null
            ],
            "code": "        boundary.ending.sort((a, b) => b.compare(a))\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.compare",
            "start_line": 654,
            "end_line": 656,
            "comment": [
                "\r\n  Section: Visibility\r\n  ",
                "\r\n  Section: Comparing to another cursor\r\n  ",
                " Public: Compare this cursor's buffer position to another cursor's buffer position.",
                "",
                " See {Point::compare} for more details.",
                "",
                " * `otherCursor`{Cursor} to compare against"
            ],
            "params": [
                {
                    "name": "otherCursor",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/win-powershell.js",
            "name": "replace",
            "line": 42,
            "func_location": "(unnamed_function_1).(unnamed_function_2)",
            "func_start_line": 37,
            "func_end_line": 44,
            "args": [
                {
                    "type": "object"
                },
                {
                    "type": "string"
                }
            ],
            "code": "  spawnPowershell(['[environment]::GetEnvironmentVariable(\\'Path\\',\\'User\\')'], function (error, stdout) {\r\n    if (error != null) {\r\n      return callback(error)\r\n    }\r\n\r\n    const pathOutput = stdout.replace(/^\\s+|\\s+$/g, '')\r\n    return callback(null, pathOutput)\r\n  })\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "Project.replace",
            "start_line": 82,
            "end_line": 99,
            "comment": [
                " Layers the contents of a project's file's config",
                " on top of the current global config."
            ],
            "params": [
                {
                    "name": "projectSpecification",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/menu-helpers.js",
            "name": "replace",
            "line": 116,
            "func_location": "acceleratorForKeystroke.(unnamed_function_2)",
            "func_start_line": 114,
            "func_end_line": 120
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "Project.replace",
            "start_line": 82,
            "end_line": 99,
            "comment": [
                " Layers the contents of a project's file's config",
                " on top of the current global config."
            ],
            "params": [
                {
                    "name": "projectSpecification",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/menu-helpers.js",
            "name": "replace",
            "line": 117,
            "func_location": "acceleratorForKeystroke.(unnamed_function_2)",
            "func_start_line": 114,
            "func_end_line": 120
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "Project.replace",
            "start_line": 82,
            "end_line": 99,
            "comment": [
                " Layers the contents of a project's file's config",
                " on top of the current global config."
            ],
            "params": [
                {
                    "name": "projectSpecification",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/menu-helpers.js",
            "name": "replace",
            "line": 118,
            "func_location": "acceleratorForKeystroke.(unnamed_function_2)",
            "func_start_line": 114,
            "func_end_line": 120
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "Project.replace",
            "start_line": 82,
            "end_line": 99,
            "comment": [
                " Layers the contents of a project's file's config",
                " on top of the current global config."
            ],
            "params": [
                {
                    "name": "projectSpecification",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/menu-helpers.js",
            "name": "replace",
            "line": 119,
            "func_location": "acceleratorForKeystroke.(unnamed_function_2)",
            "func_start_line": 114,
            "func_end_line": 120
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "Project.replace",
            "start_line": 82,
            "end_line": 99,
            "comment": [
                " Layers the contents of a project's file's config",
                " on top of the current global config."
            ],
            "params": [
                {
                    "name": "projectSpecification",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-element.js",
            "name": "didBlur",
            "line": 37,
            "func_location": "TextEditorElement.createdCallback.(unnamed_function_2)",
            "func_start_line": 37,
            "func_end_line": 37,
            "args": [
                {
                    "type": "string"
                },
                null
            ],
            "code": "    this.addEventListener('blur', (event) => this.getComponent().didBlur(event))\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "TextEditorComponent.didBlur",
            "start_line": 1500,
            "end_line": 1504,
            "comment": [
                " Called by TextEditorElement so that this function is always the first",
                " listener to be fired, even if other listeners are bound before creating",
                " the component."
            ],
            "params": [
                {
                    "name": "event",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selectors.js",
            "name": "parse",
            "line": 27,
            "func_location": "matcherForSelector.(unnamed_function_2)",
            "func_start_line": 27,
            "func_end_line": 28
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selectors.js",
            "name": "parse",
            "start_line": 10,
            "end_line": 14,
            "comment": [
                " Private: Parse a selector into parts.",
                "          If already parsed, returns the selector unmodified.",
                "",
                " * `selector` a {String|Array<String>} specifying what to match",
                " Returns selector parts, an {Array<String>}."
            ],
            "params": [
                {
                    "name": "selector",
                    "type": [
                        "string",
                        "array"
                    ]
                }
            ],
            "return_type": [
                "string",
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "remove",
            "line": 98,
            "func_location": "TextEditorRegistry.add.(unnamed_function_2)",
            "func_start_line": 98,
            "func_end_line": 98,
            "args": [
                "editor"
            ],
            "code": "    return new Disposable(() => this.remove(editor))\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/initialize-benchmark-window.js",
            "name": "getView",
            "line": 55,
            "func_location": "(unnamed_function_2)",
            "func_start_line": 55,
            "func_end_line": 57
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/view-registry.js",
            "name": "ViewRegistry.getView",
            "start_line": 122,
            "end_line": 131,
            "comment": [
                " Essential: Get the view associated with an object in the workspace.",
                "",
                " If you're just *using* the workspace, you shouldn't need to access the view",
                " layer, but view layer access may be necessary if you want to perform DOM",
                " manipulation that isn't supported via the model API.",
                "",
                " ## View Resolution Algorithm",
                "",
                " The view associated with the object is resolved using the following",
                " sequence",
                "",
                "  1. Is the object an instance of `HTMLElement`? If true, return the object.",
                "  2. Does the object have a method named `getElement` that returns an",
                "     instance of `HTMLElement`? If true, return that value.",
                "  3. Does the object have a property named `element` with a value which is",
                "     an instance of `HTMLElement`? If true, return the property value.",
                "  4. Is the object a jQuery object, indicated by the presence of a `jquery`",
                "     property? If true, return the root DOM element (i.e. `object[0]`).",
                "  5. Has a view provider been registered for the object? If true, use the",
                "     provider to create a view associated with the object, and return the",
                "     view.",
                "",
                " If no associated view is returned by the sequence an error is thrown.",
                "",
                " Returns a DOM element."
            ],
            "params": [
                {
                    "name": "object",
                    "type": [
                        "object"
                    ]
                }
            ],
            "return_type": [
                "object"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "selectToScreenPosition",
            "line": 1817,
            "func_location": "didDrag.(unnamed_function_26)",
            "func_start_line": 1814,
            "func_end_line": 1819,
            "args": [
                "screenPosition",
                null
            ],
            "code": "      didDrag: (event) => {\r\n        this.autoscrollOnMouseDrag(event)\r\n        const screenPosition = this.screenPositionForMouseEvent(event)\r\n        model.selectToScreenPosition(screenPosition, {suppressSelectionMerge: true, autoscroll: false})\r\n        this.updateSync()\r\n      },\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.selectToScreenPosition",
            "start_line": 211,
            "end_line": 231,
            "comment": [
                " Public: Selects the text from the current cursor position to a given screen",
                " position.",
                "",
                " * `position` An instance of {Point}, with a given `row` and `column`."
            ],
            "params": [
                {
                    "name": "position",
                    "type": []
                },
                {
                    "name": "options",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "setScreenRange",
            "line": 1872,
            "func_location": "didDrag.(unnamed_function_28)",
            "func_start_line": 1868,
            "func_end_line": 1878,
            "args": [],
            "code": "      didDrag: (event) => {\r\n        this.autoscrollOnMouseDrag(event, true)\r\n        const dragRow = this.screenPositionForMouseEvent(event).row\r\n        const draggedLineScreenRange = Range(Point(dragRow, 0), Point(dragRow + 1, 0))\r\n        model.getLastSelection().setScreenRange(draggedLineScreenRange.union(initialScreenRange), {\r\n          reversed: dragRow < initialScreenRange.start.row,\r\n          autoscroll: false,\r\n          preserveFolds: true\r\n        })\r\n        this.updateSync()\r\n      },\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.setScreenRange",
            "start_line": 74,
            "end_line": 76,
            "comment": [
                " Public: Modifies the screen range for the selection.",
                "",
                " * `screenRange` The new {Range} to use.",
                " * `options` (optional) {Object} options matching those found in {::setBufferRange}."
            ],
            "params": [
                {
                    "name": "screenRange",
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "setBufferRange",
            "line": 99,
            "func_location": "Selection.setBufferRange.(unnamed_function_3)",
            "func_start_line": 96,
            "func_end_line": 103,
            "args": [
                "bufferRange",
                "options"
            ],
            "code": "    this.modifySelection(() => {\r\n      const needsFlash = options.flash\r\n      options.flash = null\r\n      this.marker.setBufferRange(bufferRange, options)\r\n      const autoscroll = options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n      if (autoscroll) this.autoscroll()\r\n      if (needsFlash) this.decoration.flash('flash', this.editor.selectionFlashDuration)\r\n    })\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.setBufferRange",
            "start_line": 92,
            "end_line": 104,
            "comment": [
                " Public: Modifies the buffer {Range} for the selection.",
                "",
                " * `bufferRange` The new {Range} to select.",
                " * `options` (optional) {Object} with the keys:",
                "   * `preserveFolds` if `true`, the fold settings are preserved after the",
                "     selection moves.",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     range. Defaults to `true` if this is the most recently added selection,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferRange",
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "unset",
            "line": 732,
            "func_location": "Config.unset.(unnamed_function_3)",
            "func_start_line": 732,
            "func_end_line": 732,
            "args": [
                null
            ],
            "code": "      this.pendingOperations.push(() => this.unset(keyPath, options))\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.unset",
            "start_line": 730,
            "end_line": 766,
            "comment": [
                " Essential: Restore the setting at `keyPath` to its default value.",
                "",
                " * `keyPath` The {String} name of the key.",
                " * `options` (optional) {Object}",
                "   * `scopeSelector` (optional) {String}. See {::set}",
                "   * `source` (optional) {String}. See {::set}"
            ],
            "params": [
                {
                    "name": "keyPath",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/workspace-element.js",
            "name": "onDidChangeHovered",
            "line": 97,
            "func_location": "WorkspaceElement.initialize.(unnamed_function_3)",
            "func_start_line": 97,
            "func_end_line": 101
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/dock.js",
            "name": "Dock.onDidChangeHovered",
            "start_line": 631,
            "end_line": 633,
            "comment": [
                " Extended: Invoke the given callback when the hovered state of the dock changes.",
                "",
                " * `callback` {Function} to be called when the hovered state changes.",
                "   * `hovered` {Boolean} Is the dock now hovered?",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/storage-folder.js",
            "name": "parse",
            "line": 33,
            "func_location": "StorageFolder.load.(unnamed_function_3).(unnamed_function_4)",
            "func_start_line": 25,
            "func_end_line": 38,
            "args": [
                null
            ],
            "code": "      fs.readFile(statePath, 'utf8', (error, stateString) => {\r\n        if (error && error.code !== 'ENOENT') {\r\n          console.warn(`Error reading state file: ${statePath}`, error.stack, error)\r\n        }\r\n\r\n        if (!stateString) return resolve(null)\r\n\r\n        try {\r\n          resolve(JSON.parse(stateString))\r\n        } catch (error) {\r\n          console.warn(`Error parsing state file: ${statePath}`, error.stack, error)\r\n          resolve(null)\r\n        }\r\n      })\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/color.js",
            "name": "Color.parse",
            "start_line": 14,
            "end_line": 36,
            "comment": [
                " Essential: Parse a {String} or {Object} into a {Color}.",
                "",
                " * `value` A {String} such as `'white'`, `#ff00ff`, or",
                "   `'rgba(255, 15, 60, .75)'` or an {Object} with `red`, `green`, `blue`,",
                "   and `alpha` properties.",
                "",
                " Returns a {Color} or `null` if it cannot be parsed."
            ],
            "params": [
                {
                    "name": "value",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "null"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "setScreenRange",
            "line": 217,
            "func_location": "Selection.selectToScreenPosition.(unnamed_function_4)",
            "func_start_line": 214,
            "func_end_line": 230,
            "args": [
                null,
                null
            ],
            "code": "    this.modifySelection(() => {\r\n      if (this.initialScreenRange) {\r\n        if (position.isLessThan(this.initialScreenRange.start)) {\r\n          this.marker.setScreenRange([position, this.initialScreenRange.end], {reversed: true})\r\n        } else {\r\n          this.marker.setScreenRange([this.initialScreenRange.start, position], {reversed: false})\r\n        }\r\n      } else {\r\n        this.cursor.setScreenPosition(position, options)\r\n      }\r\n\r\n      if (this.linewise) {\r\n        this.expandOverLine(options)\r\n      } else if (this.wordwise) {\r\n        this.expandOverWord(options)\r\n      }\r\n    })\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.setScreenRange",
            "start_line": 74,
            "end_line": 76,
            "comment": [
                " Public: Modifies the screen range for the selection.",
                "",
                " * `screenRange` The new {Range} to use.",
                " * `options` (optional) {Object} options matching those found in {::setBufferRange}."
            ],
            "params": [
                {
                    "name": "screenRange",
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "setScreenRange",
            "line": 219,
            "func_location": "Selection.selectToScreenPosition.(unnamed_function_4)",
            "func_start_line": 214,
            "func_end_line": 230,
            "args": [
                null,
                null
            ],
            "code": "    this.modifySelection(() => {\r\n      if (this.initialScreenRange) {\r\n        if (position.isLessThan(this.initialScreenRange.start)) {\r\n          this.marker.setScreenRange([position, this.initialScreenRange.end], {reversed: true})\r\n        } else {\r\n          this.marker.setScreenRange([this.initialScreenRange.start, position], {reversed: false})\r\n        }\r\n      } else {\r\n        this.cursor.setScreenPosition(position, options)\r\n      }\r\n\r\n      if (this.linewise) {\r\n        this.expandOverLine(options)\r\n      } else if (this.wordwise) {\r\n        this.expandOverWord(options)\r\n      }\r\n    })\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.setScreenRange",
            "start_line": 74,
            "end_line": 76,
            "comment": [
                " Public: Modifies the screen range for the selection.",
                "",
                " * `screenRange` The new {Range} to use.",
                " * `options` (optional) {Object} options matching those found in {::setBufferRange}."
            ],
            "params": [
                {
                    "name": "screenRange",
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "setScreenPosition",
            "line": 222,
            "func_location": "Selection.selectToScreenPosition.(unnamed_function_4)",
            "func_start_line": 214,
            "func_end_line": 230,
            "args": [
                "position",
                "options"
            ],
            "code": "    this.modifySelection(() => {\r\n      if (this.initialScreenRange) {\r\n        if (position.isLessThan(this.initialScreenRange.start)) {\r\n          this.marker.setScreenRange([position, this.initialScreenRange.end], {reversed: true})\r\n        } else {\r\n          this.marker.setScreenRange([this.initialScreenRange.start, position], {reversed: false})\r\n        }\r\n      } else {\r\n        this.cursor.setScreenPosition(position, options)\r\n      }\r\n\r\n      if (this.linewise) {\r\n        this.expandOverLine(options)\r\n      } else if (this.wordwise) {\r\n        this.expandOverWord(options)\r\n      }\r\n    })\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setScreenPosition",
            "start_line": 66,
            "end_line": 70,
            "comment": [
                "\r\n  Section: Managing Cursor Position\r\n  ",
                " Public: Moves a cursor to a given screen position.",
                "",
                " * `screenPosition` {Array} of two numbers: the screen row, and the screen column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever",
                "     the cursor moves to."
            ],
            "params": [
                {
                    "name": "screenPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "expandOverLine",
            "line": 226,
            "func_location": "Selection.selectToScreenPosition.(unnamed_function_4)",
            "func_start_line": 214,
            "func_end_line": 230,
            "args": [
                "options"
            ],
            "code": "    this.modifySelection(() => {\r\n      if (this.initialScreenRange) {\r\n        if (position.isLessThan(this.initialScreenRange.start)) {\r\n          this.marker.setScreenRange([position, this.initialScreenRange.end], {reversed: true})\r\n        } else {\r\n          this.marker.setScreenRange([this.initialScreenRange.start, position], {reversed: false})\r\n        }\r\n      } else {\r\n        this.cursor.setScreenPosition(position, options)\r\n      }\r\n\r\n      if (this.linewise) {\r\n        this.expandOverLine(options)\r\n      } else if (this.wordwise) {\r\n        this.expandOverWord(options)\r\n      }\r\n    })\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.expandOverLine",
            "start_line": 403,
            "end_line": 408,
            "comment": [
                " Public: Expands the newest selection to include the entire line on which",
                " the cursor currently rests.",
                "",
                " It also includes the newline character."
            ],
            "params": [
                {
                    "name": "options",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "expandOverWord",
            "line": 228,
            "func_location": "Selection.selectToScreenPosition.(unnamed_function_4)",
            "func_start_line": 214,
            "func_end_line": 230,
            "args": [
                "options"
            ],
            "code": "    this.modifySelection(() => {\r\n      if (this.initialScreenRange) {\r\n        if (position.isLessThan(this.initialScreenRange.start)) {\r\n          this.marker.setScreenRange([position, this.initialScreenRange.end], {reversed: true})\r\n        } else {\r\n          this.marker.setScreenRange([this.initialScreenRange.start, position], {reversed: false})\r\n        }\r\n      } else {\r\n        this.cursor.setScreenPosition(position, options)\r\n      }\r\n\r\n      if (this.linewise) {\r\n        this.expandOverLine(options)\r\n      } else if (this.wordwise) {\r\n        this.expandOverWord(options)\r\n      }\r\n    })\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.expandOverWord",
            "start_line": 376,
            "end_line": 380,
            "comment": [
                " Public: Expands the newest selection to include the entire word on which",
                " the cursors rests."
            ],
            "params": [
                {
                    "name": "options",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "remove",
            "line": 3858,
            "func_location": "LinesTileComponent.updateBlockDecorations.(unnamed_function_47)",
            "func_start_line": 3849,
            "func_end_line": 3860,
            "args": [],
            "code": "      oldProps.blockDecorations.forEach((oldDecorations, screenLineId) => {\r\n        var newDecorations = newProps.blockDecorations ? newProps.blockDecorations.get(screenLineId) : null\r\n        for (var i = 0; i < oldDecorations.length; i++) {\r\n          var oldDecoration = oldDecorations[i]\r\n          if (newDecorations && newDecorations.includes(oldDecoration)) continue\r\n\r\n          var element = TextEditor.viewForItem(oldDecoration.item)\r\n          if (element.parentElement !== this.element) continue\r\n\r\n          element.remove()\r\n        }\r\n      })\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getPathStatus",
            "line": 498,
            "func_location": "GitRepository.subscribeToBuffer.getBufferPathStatus.(unnamed_function_5)",
            "func_start_line": 496,
            "func_end_line": 499,
            "args": [
                "bufferPath"
            ],
            "code": "    const getBufferPathStatus = () => {\r\n      const bufferPath = buffer.getPath()\r\n      if (bufferPath) this.getPathStatus(bufferPath)\r\n    }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getPathStatus",
            "start_line": 374,
            "end_line": 390,
            "comment": [
                " Public: Get the status of a single path in the repository.",
                "",
                " * `path` A {String} repository-relative path.",
                "",
                " Returns a {Number} representing the status. This value can be passed to",
                " {::isStatusModified} or {::isStatusNew} to get more information."
            ],
            "params": [
                {
                    "name": "path",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "number"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "setBufferPosition",
            "line": 238,
            "func_location": "Selection.selectToBufferPosition.(unnamed_function_5)",
            "func_start_line": 238,
            "func_end_line": 238,
            "args": [
                null
            ],
            "code": "    this.modifySelection(() => this.cursor.setBufferPosition(position))\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "remove",
            "line": 174,
            "func_location": "TextEditorRegistry.maintainConfig.(unnamed_function_5)",
            "func_start_line": 170,
            "func_end_line": 176,
            "args": [
                "languageChangeSubscription"
            ],
            "code": "    return new Disposable(() => {\r\n      this.editorsWithMaintainedConfig.delete(editor)\r\n      tokenizeSubscription.dispose()\r\n      languageChangeSubscription.dispose()\r\n      this.subscriptions.remove(languageChangeSubscription)\r\n      this.subscriptions.remove(tokenizeSubscription)\r\n    })\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "remove",
            "line": 175,
            "func_location": "TextEditorRegistry.maintainConfig.(unnamed_function_5)",
            "func_start_line": 170,
            "func_end_line": 176,
            "args": [
                "tokenizeSubscription"
            ],
            "code": "    return new Disposable(() => {\r\n      this.editorsWithMaintainedConfig.delete(editor)\r\n      tokenizeSubscription.dispose()\r\n      languageChangeSubscription.dispose()\r\n      this.subscriptions.remove(languageChangeSubscription)\r\n      this.subscriptions.remove(tokenizeSubscription)\r\n    })\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/workspace-element.js",
            "name": "pointWithinHoverArea",
            "line": 200,
            "func_location": "WorkspaceElement.updateHoveredDock.nextHoveredDock.(unnamed_function_5)",
            "func_start_line": 200,
            "func_end_line": 200,
            "args": [
                null
            ],
            "code": "      docks.find(dock => dock !== this.hoveredDock && dock.pointWithinHoverArea(mousePosition))\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/dock.js",
            "name": "Dock.pointWithinHoverArea",
            "start_line": 333,
            "end_line": 405,
            "comment": [
                " Determine whether the cursor is within the dock hover area. This isn't as simple as just using",
                " mouseenter/leave because we want to be a little more forgiving. For example, if the cursor is",
                " over the footer, we want to show the bottom dock's toggle button. Also note that our criteria",
                " for detecting entry are different than detecting exit but, in order for us to avoid jitter, the",
                " area considered when detecting exit MUST fully encompass the area considered when detecting",
                " entry."
            ],
            "params": [
                {
                    "name": "point",
                    "type": []
                },
                {
                    "name": "detectingExit",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "remove",
            "line": 4187,
            "func_location": "HighlightComponent.performFlash.(unnamed_function_55)",
            "func_start_line": 4186,
            "func_end_line": 4188,
            "args": [
                "flashClass"
            ],
            "code": "      this.timeoutsByClassName.set(flashClass, window.setTimeout(() => {\r\n        this.element.classList.remove(flashClass)\r\n      }, flashDuration))\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "remove",
            "line": 508,
            "func_location": "GitRepository.subscribeToBuffer.(unnamed_function_6)",
            "func_start_line": 506,
            "func_end_line": 509,
            "args": [
                "bufferSubscriptions"
            ],
            "code": "    bufferSubscriptions.add(buffer.onDidDestroy(() => {\r\n      bufferSubscriptions.dispose()\r\n      return this.subscriptions.remove(bufferSubscriptions)\r\n    }))\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "moveRight",
            "line": 245,
            "func_location": "Selection.selectRight.(unnamed_function_6)",
            "func_start_line": 245,
            "func_end_line": 245,
            "args": [
                null
            ],
            "code": "    this.modifySelection(() => this.cursor.moveRight(columnCount))\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.moveRight",
            "start_line": 305,
            "end_line": 327,
            "comment": [
                " Public: Moves the cursor right one screen column.",
                "",
                " * `columnCount` (optional) {Number} number of columns to move (default: 1)",
                " * `options` (optional) {Object} with the following keys:",
                "   * `moveToEndOfSelection` if true, move to the right of the selection if a",
                "     selection exists."
            ],
            "params": [
                {
                    "name": "columnCount",
                    "type": [
                        "number",
                        "optional"
                    ]
                },
                {
                    "name": [
                        "moveToEndOfSelection"
                    ],
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "moveLeft",
            "line": 252,
            "func_location": "Selection.selectLeft.(unnamed_function_7)",
            "func_start_line": 252,
            "func_end_line": 252,
            "args": [
                null
            ],
            "code": "    this.modifySelection(() => this.cursor.moveLeft(columnCount))\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.moveLeft",
            "start_line": 281,
            "end_line": 297,
            "comment": [
                " Public: Moves the cursor left one screen column.",
                "",
                " * `columnCount` (optional) {Number} number of columns to move (default: 1)",
                " * `options` (optional) {Object} with the following keys:",
                "   * `moveToEndOfSelection` if true, move to the left of the selection if a",
                "     selection exists."
            ],
            "params": [
                {
                    "name": "columnCount",
                    "type": [
                        "number",
                        "optional"
                    ]
                },
                {
                    "name": [
                        "moveToEndOfSelection"
                    ],
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "setScopedDefaultsFromSchema",
            "line": 918,
            "func_location": "Config.setSchema.(unnamed_function_7)",
            "func_start_line": 916,
            "func_end_line": 920,
            "args": [
                "keyPath",
                "schema"
            ],
            "code": "    this.transact(() => {\r\n      this.setDefaults(keyPath, this.extractDefaultsFromSchema(schema))\r\n      this.setScopedDefaultsFromSchema(keyPath, schema)\r\n      this.resetSettingsForSchemaChange()\r\n    })\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.setScopedDefaultsFromSchema",
            "start_line": 1131,
            "end_line": 1151,
            "comment": [
                " `schema` will look something like this",
                "",
                " ```coffee",
                " type: 'string'",
                " default: 'ok'",
                " scopes:",
                "   '.source.js':",
                "     default: 'omg'",
                " ```"
            ],
            "params": [
                {
                    "name": "keyPath",
                    "type": []
                },
                {
                    "name": "schema",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "resetSettingsForSchemaChange",
            "line": 919,
            "func_location": "Config.setSchema.(unnamed_function_7)",
            "func_start_line": 916,
            "func_end_line": 920,
            "args": [],
            "code": "    this.transact(() => {\r\n      this.setDefaults(keyPath, this.extractDefaultsFromSchema(schema))\r\n      this.setScopedDefaultsFromSchema(keyPath, schema)\r\n      this.resetSettingsForSchemaChange()\r\n    })\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.resetSettingsForSchemaChange",
            "start_line": 1182,
            "end_line": 1194,
            "comment": [
                " When the schema is changed / added, there may be values set in the config",
                " that do not conform to the schema. This will reset make them conform."
            ],
            "params": [
                {
                    "name": "source",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/workspace.js",
            "name": "maintainConfig",
            "line": 500,
            "func_location": "Workspace.subscribeToAddedItems.(unnamed_function_8)",
            "func_start_line": 496,
            "func_end_line": 517,
            "args": [
                "item"
            ],
            "code": "    this.onDidAddPaneItem(({item, pane, index}) => {\r\n      if (item instanceof TextEditor) {\r\n        const subscriptions = new CompositeDisposable(\r\n          this.textEditorRegistry.add(item),\r\n          this.textEditorRegistry.maintainConfig(item)\r\n        )\r\n        if (!this.project.findBufferForId(item.buffer.id)) {\r\n          this.project.addBuffer(item.buffer)\r\n        }\r\n        item.onDidDestroy(() => { subscriptions.dispose() })\r\n        this.emitter.emit('did-add-text-editor', {textEditor: item, pane, index})\r\n        // It's important to call handleGrammarUsed after emitting the did-add event:\r\n        // if we activate a package between adding the editor to the registry and emitting\r\n        // the package may receive the editor twice from `observeTextEditors`.\r\n        // (Note that the item can be destroyed by an `observeTextEditors` handler.)\r\n        if (!item.isDestroyed()) {\r\n          subscriptions.add(\r\n            item.observeGrammar(this.handleGrammarUsed.bind(this))\r\n          )\r\n        }\r\n      }\r\n    })\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.maintainConfig",
            "start_line": 145,
            "end_line": 177,
            "comment": [
                " Keep a {TextEditor}'s configuration in sync with Atom's settings.",
                "",
                " * `editor` The editor whose configuration will be maintained.",
                "",
                " Returns a {Disposable} that can be used to stop updating the editor's",
                " configuration."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/workspace.js",
            "name": "observeGrammar",
            "line": 513,
            "func_location": "Workspace.subscribeToAddedItems.(unnamed_function_8)",
            "func_start_line": 496,
            "func_end_line": 517,
            "args": [
                null
            ],
            "code": "    this.onDidAddPaneItem(({item, pane, index}) => {\r\n      if (item instanceof TextEditor) {\r\n        const subscriptions = new CompositeDisposable(\r\n          this.textEditorRegistry.add(item),\r\n          this.textEditorRegistry.maintainConfig(item)\r\n        )\r\n        if (!this.project.findBufferForId(item.buffer.id)) {\r\n          this.project.addBuffer(item.buffer)\r\n        }\r\n        item.onDidDestroy(() => { subscriptions.dispose() })\r\n        this.emitter.emit('did-add-text-editor', {textEditor: item, pane, index})\r\n        // It's important to call handleGrammarUsed after emitting the did-add event:\r\n        // if we activate a package between adding the editor to the registry and emitting\r\n        // the package may receive the editor twice from `observeTextEditors`.\r\n        // (Note that the item can be destroyed by an `observeTextEditors` handler.)\r\n        if (!item.isDestroyed()) {\r\n          subscriptions.add(\r\n            item.observeGrammar(this.handleGrammarUsed.bind(this))\r\n          )\r\n        }\r\n      }\r\n    })\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.observeGrammar",
            "start_line": 747,
            "end_line": 750,
            "comment": [
                " Extended: Calls your `callback` when the grammar that interprets and",
                " colorizes the text has been changed. Immediately calls your callback with",
                " the current grammar.",
                "",
                " * `callback` {Function}",
                "   * `grammar` {Grammar}",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "moveUp",
            "line": 259,
            "func_location": "Selection.selectUp.(unnamed_function_8)",
            "func_start_line": 259,
            "func_end_line": 259,
            "args": [
                null
            ],
            "code": "    this.modifySelection(() => this.cursor.moveUp(rowCount))\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.moveUp",
            "start_line": 241,
            "end_line": 253,
            "comment": [
                "\r\n  Section: Moving the Cursor\r\n  ",
                " Public: Moves the cursor up one screen row.",
                "",
                " * `rowCount` (optional) {Number} number of rows to move (default: 1)",
                " * `options` (optional) {Object} with the following keys:",
                "   * `moveToEndOfSelection` if true, move to the left of the selection if a",
                "     selection exists."
            ],
            "params": [
                {
                    "name": "rowCount",
                    "type": [
                        "number",
                        "optional"
                    ]
                },
                {
                    "name": [
                        "moveToEndOfSelection"
                    ],
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "remove",
            "line": 356,
            "func_location": "TextEditorComponent.measureBlockDecorations.(unnamed_function_8)",
            "func_start_line": 356,
            "func_end_line": 356,
            "args": [
                null
            ],
            "code": "      sentinelElements.forEach((sentinelElement) => sentinelElement.remove())\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "moveDown",
            "line": 266,
            "func_location": "Selection.selectDown.(unnamed_function_9)",
            "func_start_line": 266,
            "func_end_line": 266,
            "args": [
                null
            ],
            "code": "    this.modifySelection(() => this.cursor.moveDown(rowCount))\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.moveDown",
            "start_line": 261,
            "end_line": 273,
            "comment": [
                " Public: Moves the cursor down one screen row.",
                "",
                " * `rowCount` (optional) {Number} number of rows to move (default: 1)",
                " * `options` (optional) {Object} with the following keys:",
                "   * `moveToEndOfSelection` if true, move to the left of the selection if a",
                "     selection exists."
            ],
            "params": [
                {
                    "name": "rowCount",
                    "type": [
                        "number",
                        "optional"
                    ]
                },
                {
                    "name": [
                        "moveToEndOfSelection"
                    ],
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "transact",
            "line": 955,
            "func_location": "Config._resetSettings",
            "func_start_line": 940,
            "func_end_line": 967
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.transact",
            "start_line": 816,
            "end_line": 823,
            "comment": [
                " Extended: Suppress calls to handler functions registered with {::onDidChange}",
                " and {::observe} for the duration of `callback`. After `callback` executes,",
                " handlers will be called once if the value for their key-path has changed.",
                "",
                " * `callback` {Function} to execute while suppressing calls to handlers."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/menu-helpers.js",
            "name": "replace",
            "line": 112,
            "func_location": "acceleratorForKeystroke",
            "func_start_line": 104,
            "func_end_line": 124
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "Project.replace",
            "start_line": 82,
            "end_line": 99,
            "comment": [
                " Layers the contents of a project's file's config",
                " on top of the current global config."
            ],
            "params": [
                {
                    "name": "projectSpecification",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/pane-element.js",
            "name": "getView",
            "line": 138,
            "func_location": "PaneElement.activeItemChanged",
            "func_start_line": 128,
            "func_end_line": 162
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/view-registry.js",
            "name": "ViewRegistry.getView",
            "start_line": 122,
            "end_line": 131,
            "comment": [
                " Essential: Get the view associated with an object in the workspace.",
                "",
                " If you're just *using* the workspace, you shouldn't need to access the view",
                " layer, but view layer access may be necessary if you want to perform DOM",
                " manipulation that isn't supported via the model API.",
                "",
                " ## View Resolution Algorithm",
                "",
                " The view associated with the object is resolved using the following",
                " sequence",
                "",
                "  1. Is the object an instance of `HTMLElement`? If true, return the object.",
                "  2. Does the object have a method named `getElement` that returns an",
                "     instance of `HTMLElement`? If true, return that value.",
                "  3. Does the object have a property named `element` with a value which is",
                "     an instance of `HTMLElement`? If true, return the property value.",
                "  4. Is the object a jQuery object, indicated by the presence of a `jquery`",
                "     property? If true, return the root DOM element (i.e. `object[0]`).",
                "  5. Has a view provider been registered for the object? If true, use the",
                "     provider to create a view associated with the object, and return the",
                "     view.",
                "",
                " If no associated view is returned by the sequence an error is thrown.",
                "",
                " Returns a DOM element."
            ],
            "params": [
                {
                    "name": "object",
                    "type": [
                        "object"
                    ]
                }
            ],
            "return_type": [
                "object"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/pane-element.js",
            "name": "remove",
            "line": 124,
            "func_location": "PaneElement.activeStatusChanged",
            "func_start_line": 120,
            "func_end_line": 126,
            "args": [
                {
                    "type": "string"
                }
            ],
            "code": "  activeStatusChanged (active) {\r\n    if (active) {\r\n      this.classList.add('active')\r\n    } else {\r\n      this.classList.remove('active')\r\n    }\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/native-watcher-registry.js",
            "name": "absolute",
            "line": 40,
            "func_location": "RegistryTree.add",
            "func_start_line": 38,
            "func_end_line": 54
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/native-watcher-registry.js",
            "name": "absolute",
            "start_line": 4,
            "end_line": 7,
            "comment": [
                " Private: re-join the segments split from an absolute path to form another absolute path."
            ],
            "params": [
                {
                    "name": "parts",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/native-watcher-registry.js",
            "name": "remove",
            "line": 49,
            "func_location": "RegistryTree.add",
            "func_start_line": 38,
            "func_end_line": 54
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/tooltip-manager.js",
            "name": "add",
            "line": 118,
            "func_location": "TooltipManager.add",
            "func_start_line": 114,
            "func_end_line": 177,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Essential: Add a tooltip to the given element.",
                "",
                " * `target` An `HTMLElement`",
                " * `options` An object with one or more of the following options:",
                "   * `title` A {String} or {Function} to use for the text in the tip. If",
                "     a function is passed, `this` will be set to the `target` element. This",
                "     option is mutually exclusive with the `item` option.",
                "   * `html` A {Boolean} affecting the interpretation of the `title` option.",
                "     If `true` (the default), the `title` string will be interpreted as HTML.",
                "     Otherwise it will be interpreted as plain text.",
                "   * `item` A view (object with an `.element` property) or a DOM element",
                "     containing custom content for the tooltip. This option is mutually",
                "     exclusive with the `title` option.",
                "   * `class` A {String} with a class to apply to the tooltip element to",
                "     enable custom styling.",
                "   * `placement` A {String} or {Function} returning a string to indicate",
                "     the position of the tooltip relative to `element`. Can be `'top'`,",
                "     `'bottom'`, `'left'`, `'right'`, or `'auto'`. When `'auto'` is",
                "     specified, it will dynamically reorient the tooltip. For example, if",
                "     placement is `'auto left'`, the tooltip will display to the left when",
                "     possible, otherwise it will display right.",
                "     When a function is used to determine the placement, it is called with",
                "     the tooltip DOM node as its first argument and the triggering element",
                "     DOM node as its second. The `this` context is set to the tooltip",
                "     instance.",
                "   * `trigger` A {String} indicating how the tooltip should be displayed.",
                "     Choose from one of the following options:",
                "       * `'hover'` Show the tooltip when the mouse hovers over the element.",
                "         This is the default.",
                "       * `'click'` Show the tooltip when the element is clicked. The tooltip",
                "         will be hidden after clicking the element again or anywhere else",
                "         outside of the tooltip itself.",
                "       * `'focus'` Show the tooltip when the element is focused.",
                "       * `'manual'` Show the tooltip immediately and only hide it when the",
                "         returned disposable is disposed.",
                "   * `delay` An object specifying the show and hide delay in milliseconds.",
                "     Defaults to `{show: 1000, hide: 100}` if the `trigger` is `hover` and",
                "     otherwise defaults to `0` for both values.",
                "   * `keyBindingCommand` A {String} containing a command name. If you specify",
                "     this option and a key binding exists that matches the command, it will",
                "     be appended to the title or rendered alone if no title is specified.",
                "   * `keyBindingTarget` An `HTMLElement` on which to look up the key binding.",
                "     If this option is not supplied, the first of all matching key bindings",
                "     for the given command will be rendered.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to remove the",
                " tooltip."
            ],
            "code": "  add (target, options) {\r\n    if (target.jquery) {\r\n      const disposable = new CompositeDisposable()\r\n      for (let i = 0; i < target.length; i++) {\r\n        disposable.add(this.add(target[i], options))\r\n      }\r\n      return disposable\r\n    }\r\n\r\n    if (Tooltip == null) { Tooltip = require('./tooltip') }\r\n\r\n    const {keyBindingCommand, keyBindingTarget} = options\r\n\r\n    if (keyBindingCommand != null) {\r\n      const bindings = this.keymapManager.findKeyBindings({command: keyBindingCommand, target: keyBindingTarget})\r\n      const keystroke = getKeystroke(bindings)\r\n      if ((options.title != null) && (keystroke != null)) {\r\n        options.title += ` ${getKeystroke(bindings)}`\r\n      } else if (keystroke != null) {\r\n        options.title = getKeystroke(bindings)\r\n      }\r\n    }\r\n\r\n    delete options.selector\r\n    options = _.defaults(options, this.defaults)\r\n    if (options.trigger === 'hover') {\r\n      options = _.defaults(options, this.hoverDefaults)\r\n    }\r\n\r\n    const tooltip = new Tooltip(target, options, this.viewRegistry)\r\n\r\n    if (!this.tooltips.has(target)) {\r\n      this.tooltips.set(target, [])\r\n    }\r\n    this.tooltips.get(target).push(tooltip)\r\n\r\n    const hideTooltip = function () {\r\n      tooltip.leave({currentTarget: target})\r\n      tooltip.hide()\r\n    }\r\n\r\n    // note: adding a listener here adds a new listener for every tooltip element that's registered.  Adding unnecessary listeners is bad for performance.  It would be better to add/remove listeners when tooltips are actually created in the dom.\r\n    window.addEventListener('resize', hideTooltip)\r\n\r\n    const disposable = new Disposable(() => {\r\n      window.removeEventListener('resize', hideTooltip)\r\n\r\n      hideTooltip()\r\n      tooltip.destroy()\r\n\r\n      if (this.tooltips.has(target)) {\r\n        const tooltipsForTarget = this.tooltips.get(target)\r\n        const index = tooltipsForTarget.indexOf(tooltip)\r\n        if (index !== -1) {\r\n          tooltipsForTarget.splice(index, 1)\r\n        }\r\n        if (tooltipsForTarget.length === 0) {\r\n          this.tooltips.delete(target)\r\n        }\r\n      }\r\n    })\r\n\r\n    return disposable\r\n  }\r",
            "return_type": [
                "string",
                "function"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/tooltip-manager.js",
            "name": "TooltipManager.add",
            "start_line": 114,
            "end_line": 177,
            "comment": [
                " Essential: Add a tooltip to the given element.",
                "",
                " * `target` An `HTMLElement`",
                " * `options` An object with one or more of the following options:",
                "   * `title` A {String} or {Function} to use for the text in the tip. If",
                "     a function is passed, `this` will be set to the `target` element. This",
                "     option is mutually exclusive with the `item` option.",
                "   * `html` A {Boolean} affecting the interpretation of the `title` option.",
                "     If `true` (the default), the `title` string will be interpreted as HTML.",
                "     Otherwise it will be interpreted as plain text.",
                "   * `item` A view (object with an `.element` property) or a DOM element",
                "     containing custom content for the tooltip. This option is mutually",
                "     exclusive with the `title` option.",
                "   * `class` A {String} with a class to apply to the tooltip element to",
                "     enable custom styling.",
                "   * `placement` A {String} or {Function} returning a string to indicate",
                "     the position of the tooltip relative to `element`. Can be `'top'`,",
                "     `'bottom'`, `'left'`, `'right'`, or `'auto'`. When `'auto'` is",
                "     specified, it will dynamically reorient the tooltip. For example, if",
                "     placement is `'auto left'`, the tooltip will display to the left when",
                "     possible, otherwise it will display right.",
                "     When a function is used to determine the placement, it is called with",
                "     the tooltip DOM node as its first argument and the triggering element",
                "     DOM node as its second. The `this` context is set to the tooltip",
                "     instance.",
                "   * `trigger` A {String} indicating how the tooltip should be displayed.",
                "     Choose from one of the following options:",
                "       * `'hover'` Show the tooltip when the mouse hovers over the element.",
                "         This is the default.",
                "       * `'click'` Show the tooltip when the element is clicked. The tooltip",
                "         will be hidden after clicking the element again or anywhere else",
                "         outside of the tooltip itself.",
                "       * `'focus'` Show the tooltip when the element is focused.",
                "       * `'manual'` Show the tooltip immediately and only hide it when the",
                "         returned disposable is disposed.",
                "   * `delay` An object specifying the show and hide delay in milliseconds.",
                "     Defaults to `{show: 1000, hide: 100}` if the `trigger` is `hover` and",
                "     otherwise defaults to `0` for both values.",
                "   * `keyBindingCommand` A {String} containing a command name. If you specify",
                "     this option and a key binding exists that matches the command, it will",
                "     be appended to the title or rendered alone if no title is specified.",
                "   * `keyBindingTarget` An `HTMLElement` on which to look up the key binding.",
                "     If this option is not supplied, the first of all matching key bindings",
                "     for the given command will be rendered.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to remove the",
                " tooltip."
            ],
            "params": [
                {
                    "name": "target",
                    "type": [
                        "function"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object"
                    ]
                }
            ],
            "return_type": [
                "string",
                "function"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/tooltip-manager.js",
            "name": "add",
            "line": 118,
            "func_location": "TooltipManager.add",
            "func_start_line": 114,
            "func_end_line": 177,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Essential: Add a tooltip to the given element.",
                "",
                " * `target` An `HTMLElement`",
                " * `options` An object with one or more of the following options:",
                "   * `title` A {String} or {Function} to use for the text in the tip. If",
                "     a function is passed, `this` will be set to the `target` element. This",
                "     option is mutually exclusive with the `item` option.",
                "   * `html` A {Boolean} affecting the interpretation of the `title` option.",
                "     If `true` (the default), the `title` string will be interpreted as HTML.",
                "     Otherwise it will be interpreted as plain text.",
                "   * `item` A view (object with an `.element` property) or a DOM element",
                "     containing custom content for the tooltip. This option is mutually",
                "     exclusive with the `title` option.",
                "   * `class` A {String} with a class to apply to the tooltip element to",
                "     enable custom styling.",
                "   * `placement` A {String} or {Function} returning a string to indicate",
                "     the position of the tooltip relative to `element`. Can be `'top'`,",
                "     `'bottom'`, `'left'`, `'right'`, or `'auto'`. When `'auto'` is",
                "     specified, it will dynamically reorient the tooltip. For example, if",
                "     placement is `'auto left'`, the tooltip will display to the left when",
                "     possible, otherwise it will display right.",
                "     When a function is used to determine the placement, it is called with",
                "     the tooltip DOM node as its first argument and the triggering element",
                "     DOM node as its second. The `this` context is set to the tooltip",
                "     instance.",
                "   * `trigger` A {String} indicating how the tooltip should be displayed.",
                "     Choose from one of the following options:",
                "       * `'hover'` Show the tooltip when the mouse hovers over the element.",
                "         This is the default.",
                "       * `'click'` Show the tooltip when the element is clicked. The tooltip",
                "         will be hidden after clicking the element again or anywhere else",
                "         outside of the tooltip itself.",
                "       * `'focus'` Show the tooltip when the element is focused.",
                "       * `'manual'` Show the tooltip immediately and only hide it when the",
                "         returned disposable is disposed.",
                "   * `delay` An object specifying the show and hide delay in milliseconds.",
                "     Defaults to `{show: 1000, hide: 100}` if the `trigger` is `hover` and",
                "     otherwise defaults to `0` for both values.",
                "   * `keyBindingCommand` A {String} containing a command name. If you specify",
                "     this option and a key binding exists that matches the command, it will",
                "     be appended to the title or rendered alone if no title is specified.",
                "   * `keyBindingTarget` An `HTMLElement` on which to look up the key binding.",
                "     If this option is not supplied, the first of all matching key bindings",
                "     for the given command will be rendered.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to remove the",
                " tooltip."
            ],
            "code": "  add (target, options) {\r\n    if (target.jquery) {\r\n      const disposable = new CompositeDisposable()\r\n      for (let i = 0; i < target.length; i++) {\r\n        disposable.add(this.add(target[i], options))\r\n      }\r\n      return disposable\r\n    }\r\n\r\n    if (Tooltip == null) { Tooltip = require('./tooltip') }\r\n\r\n    const {keyBindingCommand, keyBindingTarget} = options\r\n\r\n    if (keyBindingCommand != null) {\r\n      const bindings = this.keymapManager.findKeyBindings({command: keyBindingCommand, target: keyBindingTarget})\r\n      const keystroke = getKeystroke(bindings)\r\n      if ((options.title != null) && (keystroke != null)) {\r\n        options.title += ` ${getKeystroke(bindings)}`\r\n      } else if (keystroke != null) {\r\n        options.title = getKeystroke(bindings)\r\n      }\r\n    }\r\n\r\n    delete options.selector\r\n    options = _.defaults(options, this.defaults)\r\n    if (options.trigger === 'hover') {\r\n      options = _.defaults(options, this.hoverDefaults)\r\n    }\r\n\r\n    const tooltip = new Tooltip(target, options, this.viewRegistry)\r\n\r\n    if (!this.tooltips.has(target)) {\r\n      this.tooltips.set(target, [])\r\n    }\r\n    this.tooltips.get(target).push(tooltip)\r\n\r\n    const hideTooltip = function () {\r\n      tooltip.leave({currentTarget: target})\r\n      tooltip.hide()\r\n    }\r\n\r\n    // note: adding a listener here adds a new listener for every tooltip element that's registered.  Adding unnecessary listeners is bad for performance.  It would be better to add/remove listeners when tooltips are actually created in the dom.\r\n    window.addEventListener('resize', hideTooltip)\r\n\r\n    const disposable = new Disposable(() => {\r\n      window.removeEventListener('resize', hideTooltip)\r\n\r\n      hideTooltip()\r\n      tooltip.destroy()\r\n\r\n      if (this.tooltips.has(target)) {\r\n        const tooltipsForTarget = this.tooltips.get(target)\r\n        const index = tooltipsForTarget.indexOf(tooltip)\r\n        if (index !== -1) {\r\n          tooltipsForTarget.splice(index, 1)\r\n        }\r\n        if (tooltipsForTarget.length === 0) {\r\n          this.tooltips.delete(target)\r\n        }\r\n      }\r\n    })\r\n\r\n    return disposable\r\n  }\r",
            "return_type": [
                "string",
                "function"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/tooltip-manager.js",
            "name": "TooltipManager.add",
            "start_line": 114,
            "end_line": 177,
            "comment": [
                " Essential: Add a tooltip to the given element.",
                "",
                " * `target` An `HTMLElement`",
                " * `options` An object with one or more of the following options:",
                "   * `title` A {String} or {Function} to use for the text in the tip. If",
                "     a function is passed, `this` will be set to the `target` element. This",
                "     option is mutually exclusive with the `item` option.",
                "   * `html` A {Boolean} affecting the interpretation of the `title` option.",
                "     If `true` (the default), the `title` string will be interpreted as HTML.",
                "     Otherwise it will be interpreted as plain text.",
                "   * `item` A view (object with an `.element` property) or a DOM element",
                "     containing custom content for the tooltip. This option is mutually",
                "     exclusive with the `title` option.",
                "   * `class` A {String} with a class to apply to the tooltip element to",
                "     enable custom styling.",
                "   * `placement` A {String} or {Function} returning a string to indicate",
                "     the position of the tooltip relative to `element`. Can be `'top'`,",
                "     `'bottom'`, `'left'`, `'right'`, or `'auto'`. When `'auto'` is",
                "     specified, it will dynamically reorient the tooltip. For example, if",
                "     placement is `'auto left'`, the tooltip will display to the left when",
                "     possible, otherwise it will display right.",
                "     When a function is used to determine the placement, it is called with",
                "     the tooltip DOM node as its first argument and the triggering element",
                "     DOM node as its second. The `this` context is set to the tooltip",
                "     instance.",
                "   * `trigger` A {String} indicating how the tooltip should be displayed.",
                "     Choose from one of the following options:",
                "       * `'hover'` Show the tooltip when the mouse hovers over the element.",
                "         This is the default.",
                "       * `'click'` Show the tooltip when the element is clicked. The tooltip",
                "         will be hidden after clicking the element again or anywhere else",
                "         outside of the tooltip itself.",
                "       * `'focus'` Show the tooltip when the element is focused.",
                "       * `'manual'` Show the tooltip immediately and only hide it when the",
                "         returned disposable is disposed.",
                "   * `delay` An object specifying the show and hide delay in milliseconds.",
                "     Defaults to `{show: 1000, hide: 100}` if the `trigger` is `hover` and",
                "     otherwise defaults to `0` for both values.",
                "   * `keyBindingCommand` A {String} containing a command name. If you specify",
                "     this option and a key binding exists that matches the command, it will",
                "     be appended to the title or rendered alone if no title is specified.",
                "   * `keyBindingTarget` An `HTMLElement` on which to look up the key binding.",
                "     If this option is not supplied, the first of all matching key bindings",
                "     for the given command will be rendered.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to remove the",
                " tooltip."
            ],
            "params": [
                {
                    "name": "target",
                    "type": [
                        "function"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object"
                    ]
                }
            ],
            "return_type": [
                "string",
                "function"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/tooltip-manager.js",
            "name": "getKeystroke",
            "line": 129,
            "func_location": "TooltipManager.add",
            "func_start_line": 114,
            "func_end_line": 177,
            "args": [
                {
                    "name": "bindings",
                    "type": []
                }
            ],
            "comment": [
                " Essential: Add a tooltip to the given element.",
                "",
                " * `target` An `HTMLElement`",
                " * `options` An object with one or more of the following options:",
                "   * `title` A {String} or {Function} to use for the text in the tip. If",
                "     a function is passed, `this` will be set to the `target` element. This",
                "     option is mutually exclusive with the `item` option.",
                "   * `html` A {Boolean} affecting the interpretation of the `title` option.",
                "     If `true` (the default), the `title` string will be interpreted as HTML.",
                "     Otherwise it will be interpreted as plain text.",
                "   * `item` A view (object with an `.element` property) or a DOM element",
                "     containing custom content for the tooltip. This option is mutually",
                "     exclusive with the `title` option.",
                "   * `class` A {String} with a class to apply to the tooltip element to",
                "     enable custom styling.",
                "   * `placement` A {String} or {Function} returning a string to indicate",
                "     the position of the tooltip relative to `element`. Can be `'top'`,",
                "     `'bottom'`, `'left'`, `'right'`, or `'auto'`. When `'auto'` is",
                "     specified, it will dynamically reorient the tooltip. For example, if",
                "     placement is `'auto left'`, the tooltip will display to the left when",
                "     possible, otherwise it will display right.",
                "     When a function is used to determine the placement, it is called with",
                "     the tooltip DOM node as its first argument and the triggering element",
                "     DOM node as its second. The `this` context is set to the tooltip",
                "     instance.",
                "   * `trigger` A {String} indicating how the tooltip should be displayed.",
                "     Choose from one of the following options:",
                "       * `'hover'` Show the tooltip when the mouse hovers over the element.",
                "         This is the default.",
                "       * `'click'` Show the tooltip when the element is clicked. The tooltip",
                "         will be hidden after clicking the element again or anywhere else",
                "         outside of the tooltip itself.",
                "       * `'focus'` Show the tooltip when the element is focused.",
                "       * `'manual'` Show the tooltip immediately and only hide it when the",
                "         returned disposable is disposed.",
                "   * `delay` An object specifying the show and hide delay in milliseconds.",
                "     Defaults to `{show: 1000, hide: 100}` if the `trigger` is `hover` and",
                "     otherwise defaults to `0` for both values.",
                "   * `keyBindingCommand` A {String} containing a command name. If you specify",
                "     this option and a key binding exists that matches the command, it will",
                "     be appended to the title or rendered alone if no title is specified.",
                "   * `keyBindingTarget` An `HTMLElement` on which to look up the key binding.",
                "     If this option is not supplied, the first of all matching key bindings",
                "     for the given command will be rendered.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to remove the",
                " tooltip."
            ],
            "code": "  add (target, options) {\r\n    if (target.jquery) {\r\n      const disposable = new CompositeDisposable()\r\n      for (let i = 0; i < target.length; i++) {\r\n        disposable.add(this.add(target[i], options))\r\n      }\r\n      return disposable\r\n    }\r\n\r\n    if (Tooltip == null) { Tooltip = require('./tooltip') }\r\n\r\n    const {keyBindingCommand, keyBindingTarget} = options\r\n\r\n    if (keyBindingCommand != null) {\r\n      const bindings = this.keymapManager.findKeyBindings({command: keyBindingCommand, target: keyBindingTarget})\r\n      const keystroke = getKeystroke(bindings)\r\n      if ((options.title != null) && (keystroke != null)) {\r\n        options.title += ` ${getKeystroke(bindings)}`\r\n      } else if (keystroke != null) {\r\n        options.title = getKeystroke(bindings)\r\n      }\r\n    }\r\n\r\n    delete options.selector\r\n    options = _.defaults(options, this.defaults)\r\n    if (options.trigger === 'hover') {\r\n      options = _.defaults(options, this.hoverDefaults)\r\n    }\r\n\r\n    const tooltip = new Tooltip(target, options, this.viewRegistry)\r\n\r\n    if (!this.tooltips.has(target)) {\r\n      this.tooltips.set(target, [])\r\n    }\r\n    this.tooltips.get(target).push(tooltip)\r\n\r\n    const hideTooltip = function () {\r\n      tooltip.leave({currentTarget: target})\r\n      tooltip.hide()\r\n    }\r\n\r\n    // note: adding a listener here adds a new listener for every tooltip element that's registered.  Adding unnecessary listeners is bad for performance.  It would be better to add/remove listeners when tooltips are actually created in the dom.\r\n    window.addEventListener('resize', hideTooltip)\r\n\r\n    const disposable = new Disposable(() => {\r\n      window.removeEventListener('resize', hideTooltip)\r\n\r\n      hideTooltip()\r\n      tooltip.destroy()\r\n\r\n      if (this.tooltips.has(target)) {\r\n        const tooltipsForTarget = this.tooltips.get(target)\r\n        const index = tooltipsForTarget.indexOf(tooltip)\r\n        if (index !== -1) {\r\n          tooltipsForTarget.splice(index, 1)\r\n        }\r\n        if (tooltipsForTarget.length === 0) {\r\n          this.tooltips.delete(target)\r\n        }\r\n      }\r\n    })\r\n\r\n    return disposable\r\n  }\r",
            "return_type": [
                "string",
                "function"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/tooltip-manager.js",
            "name": "getKeystroke",
            "start_line": 199,
            "end_line": 203,
            "comment": [],
            "params": [
                "bindings"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/tooltip-manager.js",
            "name": "getKeystroke",
            "line": 133,
            "func_location": "TooltipManager.add",
            "func_start_line": 114,
            "func_end_line": 177,
            "args": [
                {
                    "name": "bindings",
                    "type": []
                }
            ],
            "comment": [
                " Essential: Add a tooltip to the given element.",
                "",
                " * `target` An `HTMLElement`",
                " * `options` An object with one or more of the following options:",
                "   * `title` A {String} or {Function} to use for the text in the tip. If",
                "     a function is passed, `this` will be set to the `target` element. This",
                "     option is mutually exclusive with the `item` option.",
                "   * `html` A {Boolean} affecting the interpretation of the `title` option.",
                "     If `true` (the default), the `title` string will be interpreted as HTML.",
                "     Otherwise it will be interpreted as plain text.",
                "   * `item` A view (object with an `.element` property) or a DOM element",
                "     containing custom content for the tooltip. This option is mutually",
                "     exclusive with the `title` option.",
                "   * `class` A {String} with a class to apply to the tooltip element to",
                "     enable custom styling.",
                "   * `placement` A {String} or {Function} returning a string to indicate",
                "     the position of the tooltip relative to `element`. Can be `'top'`,",
                "     `'bottom'`, `'left'`, `'right'`, or `'auto'`. When `'auto'` is",
                "     specified, it will dynamically reorient the tooltip. For example, if",
                "     placement is `'auto left'`, the tooltip will display to the left when",
                "     possible, otherwise it will display right.",
                "     When a function is used to determine the placement, it is called with",
                "     the tooltip DOM node as its first argument and the triggering element",
                "     DOM node as its second. The `this` context is set to the tooltip",
                "     instance.",
                "   * `trigger` A {String} indicating how the tooltip should be displayed.",
                "     Choose from one of the following options:",
                "       * `'hover'` Show the tooltip when the mouse hovers over the element.",
                "         This is the default.",
                "       * `'click'` Show the tooltip when the element is clicked. The tooltip",
                "         will be hidden after clicking the element again or anywhere else",
                "         outside of the tooltip itself.",
                "       * `'focus'` Show the tooltip when the element is focused.",
                "       * `'manual'` Show the tooltip immediately and only hide it when the",
                "         returned disposable is disposed.",
                "   * `delay` An object specifying the show and hide delay in milliseconds.",
                "     Defaults to `{show: 1000, hide: 100}` if the `trigger` is `hover` and",
                "     otherwise defaults to `0` for both values.",
                "   * `keyBindingCommand` A {String} containing a command name. If you specify",
                "     this option and a key binding exists that matches the command, it will",
                "     be appended to the title or rendered alone if no title is specified.",
                "   * `keyBindingTarget` An `HTMLElement` on which to look up the key binding.",
                "     If this option is not supplied, the first of all matching key bindings",
                "     for the given command will be rendered.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to remove the",
                " tooltip."
            ],
            "code": "  add (target, options) {\r\n    if (target.jquery) {\r\n      const disposable = new CompositeDisposable()\r\n      for (let i = 0; i < target.length; i++) {\r\n        disposable.add(this.add(target[i], options))\r\n      }\r\n      return disposable\r\n    }\r\n\r\n    if (Tooltip == null) { Tooltip = require('./tooltip') }\r\n\r\n    const {keyBindingCommand, keyBindingTarget} = options\r\n\r\n    if (keyBindingCommand != null) {\r\n      const bindings = this.keymapManager.findKeyBindings({command: keyBindingCommand, target: keyBindingTarget})\r\n      const keystroke = getKeystroke(bindings)\r\n      if ((options.title != null) && (keystroke != null)) {\r\n        options.title += ` ${getKeystroke(bindings)}`\r\n      } else if (keystroke != null) {\r\n        options.title = getKeystroke(bindings)\r\n      }\r\n    }\r\n\r\n    delete options.selector\r\n    options = _.defaults(options, this.defaults)\r\n    if (options.trigger === 'hover') {\r\n      options = _.defaults(options, this.hoverDefaults)\r\n    }\r\n\r\n    const tooltip = new Tooltip(target, options, this.viewRegistry)\r\n\r\n    if (!this.tooltips.has(target)) {\r\n      this.tooltips.set(target, [])\r\n    }\r\n    this.tooltips.get(target).push(tooltip)\r\n\r\n    const hideTooltip = function () {\r\n      tooltip.leave({currentTarget: target})\r\n      tooltip.hide()\r\n    }\r\n\r\n    // note: adding a listener here adds a new listener for every tooltip element that's registered.  Adding unnecessary listeners is bad for performance.  It would be better to add/remove listeners when tooltips are actually created in the dom.\r\n    window.addEventListener('resize', hideTooltip)\r\n\r\n    const disposable = new Disposable(() => {\r\n      window.removeEventListener('resize', hideTooltip)\r\n\r\n      hideTooltip()\r\n      tooltip.destroy()\r\n\r\n      if (this.tooltips.has(target)) {\r\n        const tooltipsForTarget = this.tooltips.get(target)\r\n        const index = tooltipsForTarget.indexOf(tooltip)\r\n        if (index !== -1) {\r\n          tooltipsForTarget.splice(index, 1)\r\n        }\r\n        if (tooltipsForTarget.length === 0) {\r\n          this.tooltips.delete(target)\r\n        }\r\n      }\r\n    })\r\n\r\n    return disposable\r\n  }\r",
            "return_type": [
                "string",
                "function"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/tooltip-manager.js",
            "name": "getKeystroke",
            "start_line": 199,
            "end_line": 203,
            "comment": [],
            "params": [
                "bindings"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/tooltip-manager.js",
            "name": "has",
            "line": 145,
            "func_location": "TooltipManager.add",
            "func_start_line": 114,
            "func_end_line": 177,
            "args": [
                {
                    "name": "target",
                    "type": [
                        "function"
                    ]
                }
            ],
            "comment": [
                " Essential: Add a tooltip to the given element.",
                "",
                " * `target` An `HTMLElement`",
                " * `options` An object with one or more of the following options:",
                "   * `title` A {String} or {Function} to use for the text in the tip. If",
                "     a function is passed, `this` will be set to the `target` element. This",
                "     option is mutually exclusive with the `item` option.",
                "   * `html` A {Boolean} affecting the interpretation of the `title` option.",
                "     If `true` (the default), the `title` string will be interpreted as HTML.",
                "     Otherwise it will be interpreted as plain text.",
                "   * `item` A view (object with an `.element` property) or a DOM element",
                "     containing custom content for the tooltip. This option is mutually",
                "     exclusive with the `title` option.",
                "   * `class` A {String} with a class to apply to the tooltip element to",
                "     enable custom styling.",
                "   * `placement` A {String} or {Function} returning a string to indicate",
                "     the position of the tooltip relative to `element`. Can be `'top'`,",
                "     `'bottom'`, `'left'`, `'right'`, or `'auto'`. When `'auto'` is",
                "     specified, it will dynamically reorient the tooltip. For example, if",
                "     placement is `'auto left'`, the tooltip will display to the left when",
                "     possible, otherwise it will display right.",
                "     When a function is used to determine the placement, it is called with",
                "     the tooltip DOM node as its first argument and the triggering element",
                "     DOM node as its second. The `this` context is set to the tooltip",
                "     instance.",
                "   * `trigger` A {String} indicating how the tooltip should be displayed.",
                "     Choose from one of the following options:",
                "       * `'hover'` Show the tooltip when the mouse hovers over the element.",
                "         This is the default.",
                "       * `'click'` Show the tooltip when the element is clicked. The tooltip",
                "         will be hidden after clicking the element again or anywhere else",
                "         outside of the tooltip itself.",
                "       * `'focus'` Show the tooltip when the element is focused.",
                "       * `'manual'` Show the tooltip immediately and only hide it when the",
                "         returned disposable is disposed.",
                "   * `delay` An object specifying the show and hide delay in milliseconds.",
                "     Defaults to `{show: 1000, hide: 100}` if the `trigger` is `hover` and",
                "     otherwise defaults to `0` for both values.",
                "   * `keyBindingCommand` A {String} containing a command name. If you specify",
                "     this option and a key binding exists that matches the command, it will",
                "     be appended to the title or rendered alone if no title is specified.",
                "   * `keyBindingTarget` An `HTMLElement` on which to look up the key binding.",
                "     If this option is not supplied, the first of all matching key bindings",
                "     for the given command will be rendered.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to remove the",
                " tooltip."
            ],
            "code": "  add (target, options) {\r\n    if (target.jquery) {\r\n      const disposable = new CompositeDisposable()\r\n      for (let i = 0; i < target.length; i++) {\r\n        disposable.add(this.add(target[i], options))\r\n      }\r\n      return disposable\r\n    }\r\n\r\n    if (Tooltip == null) { Tooltip = require('./tooltip') }\r\n\r\n    const {keyBindingCommand, keyBindingTarget} = options\r\n\r\n    if (keyBindingCommand != null) {\r\n      const bindings = this.keymapManager.findKeyBindings({command: keyBindingCommand, target: keyBindingTarget})\r\n      const keystroke = getKeystroke(bindings)\r\n      if ((options.title != null) && (keystroke != null)) {\r\n        options.title += ` ${getKeystroke(bindings)}`\r\n      } else if (keystroke != null) {\r\n        options.title = getKeystroke(bindings)\r\n      }\r\n    }\r\n\r\n    delete options.selector\r\n    options = _.defaults(options, this.defaults)\r\n    if (options.trigger === 'hover') {\r\n      options = _.defaults(options, this.hoverDefaults)\r\n    }\r\n\r\n    const tooltip = new Tooltip(target, options, this.viewRegistry)\r\n\r\n    if (!this.tooltips.has(target)) {\r\n      this.tooltips.set(target, [])\r\n    }\r\n    this.tooltips.get(target).push(tooltip)\r\n\r\n    const hideTooltip = function () {\r\n      tooltip.leave({currentTarget: target})\r\n      tooltip.hide()\r\n    }\r\n\r\n    // note: adding a listener here adds a new listener for every tooltip element that's registered.  Adding unnecessary listeners is bad for performance.  It would be better to add/remove listeners when tooltips are actually created in the dom.\r\n    window.addEventListener('resize', hideTooltip)\r\n\r\n    const disposable = new Disposable(() => {\r\n      window.removeEventListener('resize', hideTooltip)\r\n\r\n      hideTooltip()\r\n      tooltip.destroy()\r\n\r\n      if (this.tooltips.has(target)) {\r\n        const tooltipsForTarget = this.tooltips.get(target)\r\n        const index = tooltipsForTarget.indexOf(tooltip)\r\n        if (index !== -1) {\r\n          tooltipsForTarget.splice(index, 1)\r\n        }\r\n        if (tooltipsForTarget.length === 0) {\r\n          this.tooltips.delete(target)\r\n        }\r\n      }\r\n    })\r\n\r\n    return disposable\r\n  }\r",
            "return_type": [
                "string",
                "function"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/file-system-blob-store.js",
            "name": "FileSystemBlobStore.has",
            "start_line": 68,
            "end_line": 70,
            "comment": [],
            "params": [
                "key"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/tooltip-manager.js",
            "name": "hideTooltip",
            "line": 156,
            "func_location": "TooltipManager.add",
            "func_start_line": 114,
            "func_end_line": 177,
            "args": [
                {
                    "name": {
                        "type": "string"
                    },
                    "type": []
                },
                {
                    "name": "hideTooltip",
                    "type": []
                }
            ],
            "comment": [
                " Essential: Add a tooltip to the given element.",
                "",
                " * `target` An `HTMLElement`",
                " * `options` An object with one or more of the following options:",
                "   * `title` A {String} or {Function} to use for the text in the tip. If",
                "     a function is passed, `this` will be set to the `target` element. This",
                "     option is mutually exclusive with the `item` option.",
                "   * `html` A {Boolean} affecting the interpretation of the `title` option.",
                "     If `true` (the default), the `title` string will be interpreted as HTML.",
                "     Otherwise it will be interpreted as plain text.",
                "   * `item` A view (object with an `.element` property) or a DOM element",
                "     containing custom content for the tooltip. This option is mutually",
                "     exclusive with the `title` option.",
                "   * `class` A {String} with a class to apply to the tooltip element to",
                "     enable custom styling.",
                "   * `placement` A {String} or {Function} returning a string to indicate",
                "     the position of the tooltip relative to `element`. Can be `'top'`,",
                "     `'bottom'`, `'left'`, `'right'`, or `'auto'`. When `'auto'` is",
                "     specified, it will dynamically reorient the tooltip. For example, if",
                "     placement is `'auto left'`, the tooltip will display to the left when",
                "     possible, otherwise it will display right.",
                "     When a function is used to determine the placement, it is called with",
                "     the tooltip DOM node as its first argument and the triggering element",
                "     DOM node as its second. The `this` context is set to the tooltip",
                "     instance.",
                "   * `trigger` A {String} indicating how the tooltip should be displayed.",
                "     Choose from one of the following options:",
                "       * `'hover'` Show the tooltip when the mouse hovers over the element.",
                "         This is the default.",
                "       * `'click'` Show the tooltip when the element is clicked. The tooltip",
                "         will be hidden after clicking the element again or anywhere else",
                "         outside of the tooltip itself.",
                "       * `'focus'` Show the tooltip when the element is focused.",
                "       * `'manual'` Show the tooltip immediately and only hide it when the",
                "         returned disposable is disposed.",
                "   * `delay` An object specifying the show and hide delay in milliseconds.",
                "     Defaults to `{show: 1000, hide: 100}` if the `trigger` is `hover` and",
                "     otherwise defaults to `0` for both values.",
                "   * `keyBindingCommand` A {String} containing a command name. If you specify",
                "     this option and a key binding exists that matches the command, it will",
                "     be appended to the title or rendered alone if no title is specified.",
                "   * `keyBindingTarget` An `HTMLElement` on which to look up the key binding.",
                "     If this option is not supplied, the first of all matching key bindings",
                "     for the given command will be rendered.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to remove the",
                " tooltip."
            ],
            "code": "  add (target, options) {\r\n    if (target.jquery) {\r\n      const disposable = new CompositeDisposable()\r\n      for (let i = 0; i < target.length; i++) {\r\n        disposable.add(this.add(target[i], options))\r\n      }\r\n      return disposable\r\n    }\r\n\r\n    if (Tooltip == null) { Tooltip = require('./tooltip') }\r\n\r\n    const {keyBindingCommand, keyBindingTarget} = options\r\n\r\n    if (keyBindingCommand != null) {\r\n      const bindings = this.keymapManager.findKeyBindings({command: keyBindingCommand, target: keyBindingTarget})\r\n      const keystroke = getKeystroke(bindings)\r\n      if ((options.title != null) && (keystroke != null)) {\r\n        options.title += ` ${getKeystroke(bindings)}`\r\n      } else if (keystroke != null) {\r\n        options.title = getKeystroke(bindings)\r\n      }\r\n    }\r\n\r\n    delete options.selector\r\n    options = _.defaults(options, this.defaults)\r\n    if (options.trigger === 'hover') {\r\n      options = _.defaults(options, this.hoverDefaults)\r\n    }\r\n\r\n    const tooltip = new Tooltip(target, options, this.viewRegistry)\r\n\r\n    if (!this.tooltips.has(target)) {\r\n      this.tooltips.set(target, [])\r\n    }\r\n    this.tooltips.get(target).push(tooltip)\r\n\r\n    const hideTooltip = function () {\r\n      tooltip.leave({currentTarget: target})\r\n      tooltip.hide()\r\n    }\r\n\r\n    // note: adding a listener here adds a new listener for every tooltip element that's registered.  Adding unnecessary listeners is bad for performance.  It would be better to add/remove listeners when tooltips are actually created in the dom.\r\n    window.addEventListener('resize', hideTooltip)\r\n\r\n    const disposable = new Disposable(() => {\r\n      window.removeEventListener('resize', hideTooltip)\r\n\r\n      hideTooltip()\r\n      tooltip.destroy()\r\n\r\n      if (this.tooltips.has(target)) {\r\n        const tooltipsForTarget = this.tooltips.get(target)\r\n        const index = tooltipsForTarget.indexOf(tooltip)\r\n        if (index !== -1) {\r\n          tooltipsForTarget.splice(index, 1)\r\n        }\r\n        if (tooltipsForTarget.length === 0) {\r\n          this.tooltips.delete(target)\r\n        }\r\n      }\r\n    })\r\n\r\n    return disposable\r\n  }\r",
            "return_type": [
                "string",
                "function"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/tooltip-manager.js",
            "name": "TooltipManager.add.hideTooltip",
            "start_line": 150,
            "end_line": 153,
            "comment": [],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/notification-manager.js",
            "name": "addNotification",
            "line": 154,
            "func_location": "NotificationManager.addError",
            "func_start_line": 153,
            "func_end_line": 155,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Add an error notification.",
                "",
                " * `message` A {String} message",
                " * `options` (optional) An options {Object} with the following keys:",
                "    * `buttons` (optional) An {Array} of {Object} where each {Object} has",
                "      the following options:",
                "      * `className` (optional) {String} a class name to add to the button's",
                "        default class name (`btn btn-error`).",
                "      * `onDidClick` (optional) {Function} callback to call when the button",
                "        has been clicked. The context will be set to the",
                "        {NotificationElement} instance.",
                "      * `text` {String} inner text for the button",
                "    * `description` (optional) A Markdown {String} containing a longer",
                "      description about the notification. By default, this **will not**",
                "      preserve newlines and whitespace when it is rendered.",
                "    * `detail` (optional) A plain-text {String} containing additional",
                "      details about the notification. By default, this **will** preserve",
                "      newlines and whitespace when it is rendered.",
                "    * `dismissable` (optional) A {Boolean} indicating whether this",
                "      notification can be dismissed by the user. Defaults to `false`.",
                "    * `icon` (optional) A {String} name of an icon from Octicons to display",
                "      in the notification header. Defaults to `'flame'`.",
                "    * `stack` (optional) A preformatted {String} with stack trace",
                "      information describing the location of the error.",
                "",
                " Returns the {Notification} that was added."
            ],
            "code": "  addError (message, options) {\r\n    return this.addNotification(new Notification('error', message, options))\r\n  }\r",
            "return_type": [
                "string",
                "function"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/notification-manager.js",
            "name": "NotificationManager.addNotification",
            "start_line": 191,
            "end_line": 195,
            "comment": [],
            "params": [
                "notification"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/notification-manager.js",
            "name": "addNotification",
            "line": 184,
            "func_location": "NotificationManager.addFatalError",
            "func_start_line": 183,
            "func_end_line": 185,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Add a fatal error notification.",
                "",
                " * `message` A {String} message",
                " * `options` (optional) An options {Object} with the following keys:",
                "    * `buttons` (optional) An {Array} of {Object} where each {Object} has",
                "      the following options:",
                "      * `className` (optional) {String} a class name to add to the button's",
                "        default class name (`btn btn-error`).",
                "      * `onDidClick` (optional) {Function} callback to call when the button",
                "        has been clicked. The context will be set to the",
                "        {NotificationElement} instance.",
                "      * `text` {String} inner text for the button",
                "    * `description` (optional) A Markdown {String} containing a longer",
                "      description about the notification. By default, this **will not**",
                "      preserve newlines and whitespace when it is rendered.",
                "    * `detail` (optional) A plain-text {String} containing additional",
                "      details about the notification. By default, this **will** preserve",
                "      newlines and whitespace when it is rendered.",
                "    * `dismissable` (optional) A {Boolean} indicating whether this",
                "      notification can be dismissed by the user. Defaults to `false`.",
                "    * `icon` (optional) A {String} name of an icon from Octicons to display",
                "      in the notification header. Defaults to `'bug'`.",
                "    * `stack` (optional) A preformatted {String} with stack trace",
                "      information describing the location of the error.",
                "",
                " Returns the {Notification} that was added."
            ],
            "code": "  addFatalError (message, options) {\r\n    return this.addNotification(new Notification('fatal', message, options))\r\n  }\r",
            "return_type": [
                "string",
                "function"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/notification-manager.js",
            "name": "NotificationManager.addNotification",
            "start_line": 191,
            "end_line": 195,
            "comment": [],
            "params": [
                "notification"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/gutter-container.js",
            "name": "decorateMarker",
            "line": 106,
            "func_location": "GutterContainer.addGutterDecoration",
            "func_start_line": 99,
            "func_end_line": 107,
            "args": [
                {
                    "name": "marker",
                    "type": []
                },
                {
                    "name": "options",
                    "type": []
                }
            ],
            "comment": [
                " The public interface is Gutter::decorateMarker or TextEditor::decorateMarker."
            ],
            "code": "  addGutterDecoration (gutter, marker, options) {\r\n    if (gutter.type === 'line-number') {\r\n      options.type = 'line-number'\r\n    } else {\r\n      options.type = 'gutter'\r\n    }\r\n    options.gutterName = gutter.name\r\n    return this.textEditor.decorateMarker(marker, options)\r\n  }\r",
            "return_type": [
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/gutter.js",
            "name": "Gutter.decorateMarker",
            "start_line": 105,
            "end_line": 107,
            "comment": [
                " Essential: Add a decoration that tracks a {DisplayMarker}. When the marker moves,",
                " is invalidated, or is destroyed, the decoration will be updated to reflect",
                " the marker's state.",
                "",
                " ## Arguments",
                "",
                " * `marker` A {DisplayMarker} you want this decoration to follow.",
                " * `decorationParams` An {Object} representing the decoration. It is passed",
                "   to {TextEditor::decorateMarker} as its `decorationParams` and so supports",
                "   all options documented there.",
                "   * `type` __Caveat__: set to `'line-number'` if this is the line-number",
                "     gutter, `'gutter'` otherwise. This cannot be overridden.",
                "",
                " Returns a {Decoration} object"
            ],
            "params": [
                {
                    "name": "marker",
                    "type": []
                },
                {
                    "name": "options",
                    "type": []
                }
            ],
            "return_type": [
                "object"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/gutter-container.js",
            "name": "decorateMarker",
            "line": 106,
            "func_location": "GutterContainer.addGutterDecoration",
            "func_start_line": 99,
            "func_end_line": 107,
            "args": [
                {
                    "name": "marker",
                    "type": []
                },
                {
                    "name": "options",
                    "type": []
                }
            ],
            "comment": [
                " The public interface is Gutter::decorateMarker or TextEditor::decorateMarker."
            ],
            "code": "  addGutterDecoration (gutter, marker, options) {\r\n    if (gutter.type === 'line-number') {\r\n      options.type = 'line-number'\r\n    } else {\r\n      options.type = 'gutter'\r\n    }\r\n    options.gutterName = gutter.name\r\n    return this.textEditor.decorateMarker(marker, options)\r\n  }\r",
            "return_type": [
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/gutter.js",
            "name": "Gutter.decorateMarker",
            "start_line": 105,
            "end_line": 107,
            "comment": [
                " Essential: Add a decoration that tracks a {DisplayMarker}. When the marker moves,",
                " is invalidated, or is destroyed, the decoration will be updated to reflect",
                " the marker's state.",
                "",
                " ## Arguments",
                "",
                " * `marker` A {DisplayMarker} you want this decoration to follow.",
                " * `decorationParams` An {Object} representing the decoration. It is passed",
                "   to {TextEditor::decorateMarker} as its `decorationParams` and so supports",
                "   all options documented there.",
                "   * `type` __Caveat__: set to `'line-number'` if this is the line-number",
                "     gutter, `'gutter'` otherwise. This cannot be overridden.",
                "",
                " Returns a {Decoration} object"
            ],
            "params": [
                {
                    "name": "marker",
                    "type": []
                },
                {
                    "name": "options",
                    "type": []
                }
            ],
            "return_type": [
                "object"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/notification-manager.js",
            "name": "addNotification",
            "line": 96,
            "func_location": "NotificationManager.addInfo",
            "func_start_line": 95,
            "func_end_line": 97,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Add an informational notification.",
                "",
                " * `message` A {String} message",
                " * `options` (optional) An options {Object} with the following keys:",
                "    * `buttons` (optional) An {Array} of {Object} where each {Object} has",
                "      the following options:",
                "      * `className` (optional) {String} a class name to add to the button's",
                "        default class name (`btn btn-info`).",
                "      * `onDidClick` (optional) {Function} callback to call when the button",
                "        has been clicked. The context will be set to the",
                "        {NotificationElement} instance.",
                "      * `text` {String} inner text for the button",
                "    * `description` (optional) A Markdown {String} containing a longer",
                "      description about the notification. By default, this **will not**",
                "      preserve newlines and whitespace when it is rendered.",
                "    * `detail` (optional) A plain-text {String} containing additional",
                "      details about the notification. By default, this **will** preserve",
                "      newlines and whitespace when it is rendered.",
                "    * `dismissable` (optional) A {Boolean} indicating whether this",
                "      notification can be dismissed by the user. Defaults to `false`.",
                "    * `icon` (optional) A {String} name of an icon from Octicons to display",
                "      in the notification header. Defaults to `'info'`.",
                "",
                " Returns the {Notification} that was added."
            ],
            "code": "  addInfo (message, options) {\r\n    return this.addNotification(new Notification('info', message, options))\r\n  }\r",
            "return_type": [
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/notification-manager.js",
            "name": "NotificationManager.addNotification",
            "start_line": 191,
            "end_line": 195,
            "comment": [],
            "params": [
                "notification"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/notification-manager.js",
            "name": "addNotification",
            "line": 68,
            "func_location": "NotificationManager.addSuccess",
            "func_start_line": 67,
            "func_end_line": 69,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Adding Notifications\r\n  ",
                " Public: Add a success notification.",
                "",
                " * `message` A {String} message",
                " * `options` (optional) An options {Object} with the following keys:",
                "    * `buttons` (optional) An {Array} of {Object} where each {Object} has",
                "      the following options:",
                "      * `className` (optional) {String} a class name to add to the button's",
                "        default class name (`btn btn-success`).",
                "      * `onDidClick` (optional) {Function} callback to call when the button",
                "        has been clicked. The context will be set to the",
                "        {NotificationElement} instance.",
                "      * `text` {String} inner text for the button",
                "    * `description` (optional) A Markdown {String} containing a longer",
                "      description about the notification. By default, this **will not**",
                "      preserve newlines and whitespace when it is rendered.",
                "    * `detail` (optional) A plain-text {String} containing additional",
                "      details about the notification. By default, this **will** preserve",
                "      newlines and whitespace when it is rendered.",
                "    * `dismissable` (optional) A {Boolean} indicating whether this",
                "      notification can be dismissed by the user. Defaults to `false`.",
                "    * `icon` (optional) A {String} name of an icon from Octicons to display",
                "      in the notification header. Defaults to `'check'`.",
                "",
                " Returns the {Notification} that was added."
            ],
            "code": "  addSuccess (message, options) {\r\n    return this.addNotification(new Notification('success', message, options))\r\n  }\r",
            "return_type": [
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/notification-manager.js",
            "name": "NotificationManager.addNotification",
            "start_line": 191,
            "end_line": 195,
            "comment": [],
            "params": [
                "notification"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/notification-manager.js",
            "name": "addNotification",
            "line": 124,
            "func_location": "NotificationManager.addWarning",
            "func_start_line": 123,
            "func_end_line": 125,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Add a warning notification.",
                "",
                " * `message` A {String} message",
                " * `options` (optional) An options {Object} with the following keys:",
                "    * `buttons` (optional) An {Array} of {Object} where each {Object} has",
                "      the following options:",
                "      * `className` (optional) {String} a class name to add to the button's",
                "        default class name (`btn btn-warning`).",
                "      * `onDidClick` (optional) {Function} callback to call when the button",
                "        has been clicked. The context will be set to the",
                "        {NotificationElement} instance.",
                "      * `text` {String} inner text for the button",
                "    * `description` (optional) A Markdown {String} containing a longer",
                "      description about the notification. By default, this **will not**",
                "      preserve newlines and whitespace when it is rendered.",
                "    * `detail` (optional) A plain-text {String} containing additional",
                "      details about the notification. By default, this **will** preserve",
                "      newlines and whitespace when it is rendered.",
                "    * `dismissable` (optional) A {Boolean} indicating whether this",
                "      notification can be dismissed by the user. Defaults to `false`.",
                "    * `icon` (optional) A {String} name of an icon from Octicons to display",
                "      in the notification header. Defaults to `'alert'`.",
                "",
                " Returns the {Notification} that was added."
            ],
            "code": "  addWarning (message, options) {\r\n    return this.addNotification(new Notification('warning', message, options))\r\n  }\r",
            "return_type": [
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/notification-manager.js",
            "name": "NotificationManager.addNotification",
            "start_line": 191,
            "end_line": 195,
            "comment": [],
            "params": [
                "notification"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "enableWindowSpecificItems",
            "line": 59,
            "func_location": "ApplicationMenu.addWindow",
            "func_start_line": 43,
            "func_end_line": 60,
            "args": [
                {
                    "name": {
                        "type": "boolean"
                    },
                    "type": []
                }
            ],
            "comment": [
                " Register a BrowserWindow with this application menu."
            ],
            "code": "  addWindow (window) {\r\n    if (this.lastFocusedWindow == null) this.lastFocusedWindow = window\r\n\r\n    const focusHandler = () => {\r\n      this.lastFocusedWindow = window\r\n      const template = this.windowTemplates.get(window)\r\n      if (template) this.setActiveTemplate(template)\r\n    }\r\n\r\n    window.on('focus', focusHandler)\r\n    window.once('closed', () => {\r\n      if (window === this.lastFocusedWindow) this.lastFocusedWindow = null\r\n      this.windowTemplates.delete(window)\r\n      window.removeListener('focus', focusHandler)\r\n    })\r\n\r\n    this.enableWindowSpecificItems(true)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "ApplicationMenu.enableWindowSpecificItems",
            "start_line": 96,
            "end_line": 100,
            "comment": [
                " Public: Used to make all window related menu items are active.",
                "",
                " enable - If true enables all window specific items, if false disables all",
                "          window specific items."
            ],
            "params": [
                {
                    "name": "enable",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "enableWindowSpecificItems",
            "line": 59,
            "func_location": "ApplicationMenu.addWindow",
            "func_start_line": 43,
            "func_end_line": 60,
            "args": [
                {
                    "name": {
                        "type": "boolean"
                    },
                    "type": []
                }
            ],
            "comment": [
                " Register a BrowserWindow with this application menu."
            ],
            "code": "  addWindow (window) {\r\n    if (this.lastFocusedWindow == null) this.lastFocusedWindow = window\r\n\r\n    const focusHandler = () => {\r\n      this.lastFocusedWindow = window\r\n      const template = this.windowTemplates.get(window)\r\n      if (template) this.setActiveTemplate(template)\r\n    }\r\n\r\n    window.on('focus', focusHandler)\r\n    window.once('closed', () => {\r\n      if (window === this.lastFocusedWindow) this.lastFocusedWindow = null\r\n      this.windowTemplates.delete(window)\r\n      window.removeListener('focus', focusHandler)\r\n    })\r\n\r\n    this.enableWindowSpecificItems(true)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "ApplicationMenu.enableWindowSpecificItems",
            "start_line": 96,
            "end_line": 100,
            "comment": [
                " Public: Used to make all window related menu items are active.",
                "",
                " enable - If true enables all window specific items, if false disables all",
                "          window specific items."
            ],
            "params": [
                {
                    "name": "enable",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "ensureWritable",
            "line": 521,
            "func_location": "Selection.backspace",
            "func_start_line": 520,
            "func_end_line": 524,
            "args": [
                {
                    "name": {
                        "type": "string"
                    },
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Removes the first character before the selection if the selection",
                " is empty otherwise it deletes the selection.",
                "",
                " * `options` (optional) {Object}",
                "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"
            ],
            "code": "  backspace (options = {}) {\r\n    if (!this.ensureWritable('backspace', options)) return\r\n    if (this.isEmpty()) this.selectLeft()\r\n    this.deleteSelectedText(options)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.ensureWritable",
            "start_line": 412,
            "end_line": 427,
            "comment": [
                " Private: Ensure that the {TextEditor} is not marked read-only before allowing a buffer modification to occur. if",
                " the editor is read-only, require an explicit opt-in option to proceed (`bypassReadOnly`) or throw an Error."
            ],
            "params": [
                {
                    "name": "methodName",
                    "type": []
                },
                {
                    "name": "opts",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "ensureWritable",
            "line": 521,
            "func_location": "Selection.backspace",
            "func_start_line": 520,
            "func_end_line": 524,
            "args": [
                {
                    "name": {
                        "type": "string"
                    },
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Removes the first character before the selection if the selection",
                " is empty otherwise it deletes the selection.",
                "",
                " * `options` (optional) {Object}",
                "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"
            ],
            "code": "  backspace (options = {}) {\r\n    if (!this.ensureWritable('backspace', options)) return\r\n    if (this.isEmpty()) this.selectLeft()\r\n    this.deleteSelectedText(options)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.ensureWritable",
            "start_line": 412,
            "end_line": 427,
            "comment": [
                " Private: Ensure that the {TextEditor} is not marked read-only before allowing a buffer modification to occur. if",
                " the editor is read-only, require an explicit opt-in option to proceed (`bypassReadOnly`) or throw an Error."
            ],
            "params": [
                {
                    "name": "methodName",
                    "type": []
                },
                {
                    "name": "opts",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "selectLeft",
            "line": 522,
            "func_location": "Selection.backspace",
            "func_start_line": 520,
            "func_end_line": 524,
            "args": [],
            "comment": [
                " Public: Removes the first character before the selection if the selection",
                " is empty otherwise it deletes the selection.",
                "",
                " * `options` (optional) {Object}",
                "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"
            ],
            "code": "  backspace (options = {}) {\r\n    if (!this.ensureWritable('backspace', options)) return\r\n    if (this.isEmpty()) this.selectLeft()\r\n    this.deleteSelectedText(options)\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.selectLeft",
            "start_line": 251,
            "end_line": 253,
            "comment": [
                " Public: Selects the text one position left of the cursor.",
                "",
                " * `columnCount` (optional) {Number} number of columns to select (default: 1)"
            ],
            "params": [
                {
                    "name": "columnCount",
                    "type": [
                        "number",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 473,
            "func_location": "GitRepository.checkoutHead",
            "func_start_line": 472,
            "func_end_line": 477,
            "args": [
                {
                    "name": "path",
                    "type": [
                        "string"
                    ]
                }
            ],
            "comment": [
                "\r\n  Section: Checking Out\r\n  ",
                " Public: Restore the contents of a path in the working directory and index",
                " to the version at `HEAD`.",
                "",
                " This is essentially the same as running:",
                "",
                " ```sh",
                "   git reset HEAD -- <path>",
                "   git checkout HEAD -- <path>",
                " ```",
                "",
                " * `path` The {String} path to checkout.",
                "",
                " Returns a {Boolean} that's true if the method was successful."
            ],
            "code": "  checkoutHead (path) {\r\n    const repo = this.getRepo(path)\r\n    const headCheckedOut = repo.checkoutHead(repo.relativize(path))\r\n    if (headCheckedOut) this.getPathStatus(path)\r\n    return headCheckedOut\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 473,
            "func_location": "GitRepository.checkoutHead",
            "func_start_line": 472,
            "func_end_line": 477,
            "args": [
                {
                    "name": "path",
                    "type": [
                        "string"
                    ]
                }
            ],
            "comment": [
                "\r\n  Section: Checking Out\r\n  ",
                " Public: Restore the contents of a path in the working directory and index",
                " to the version at `HEAD`.",
                "",
                " This is essentially the same as running:",
                "",
                " ```sh",
                "   git reset HEAD -- <path>",
                "   git checkout HEAD -- <path>",
                " ```",
                "",
                " * `path` The {String} path to checkout.",
                "",
                " Returns a {Boolean} that's true if the method was successful."
            ],
            "code": "  checkoutHead (path) {\r\n    const repo = this.getRepo(path)\r\n    const headCheckedOut = repo.checkoutHead(repo.relativize(path))\r\n    if (headCheckedOut) this.getPathStatus(path)\r\n    return headCheckedOut\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "checkoutHead",
            "line": 474,
            "func_location": "GitRepository.checkoutHead",
            "func_start_line": 472,
            "func_end_line": 477,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Checking Out\r\n  ",
                " Public: Restore the contents of a path in the working directory and index",
                " to the version at `HEAD`.",
                "",
                " This is essentially the same as running:",
                "",
                " ```sh",
                "   git reset HEAD -- <path>",
                "   git checkout HEAD -- <path>",
                " ```",
                "",
                " * `path` The {String} path to checkout.",
                "",
                " Returns a {Boolean} that's true if the method was successful."
            ],
            "code": "  checkoutHead (path) {\r\n    const repo = this.getRepo(path)\r\n    const headCheckedOut = repo.checkoutHead(repo.relativize(path))\r\n    if (headCheckedOut) this.getPathStatus(path)\r\n    return headCheckedOut\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.checkoutHead",
            "start_line": 472,
            "end_line": 477,
            "comment": [
                "\r\n  Section: Checking Out\r\n  ",
                " Public: Restore the contents of a path in the working directory and index",
                " to the version at `HEAD`.",
                "",
                " This is essentially the same as running:",
                "",
                " ```sh",
                "   git reset HEAD -- <path>",
                "   git checkout HEAD -- <path>",
                " ```",
                "",
                " * `path` The {String} path to checkout.",
                "",
                " Returns a {Boolean} that's true if the method was successful."
            ],
            "params": [
                {
                    "name": "path",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "checkoutHead",
            "line": 474,
            "func_location": "GitRepository.checkoutHead",
            "func_start_line": 472,
            "func_end_line": 477,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Checking Out\r\n  ",
                " Public: Restore the contents of a path in the working directory and index",
                " to the version at `HEAD`.",
                "",
                " This is essentially the same as running:",
                "",
                " ```sh",
                "   git reset HEAD -- <path>",
                "   git checkout HEAD -- <path>",
                " ```",
                "",
                " * `path` The {String} path to checkout.",
                "",
                " Returns a {Boolean} that's true if the method was successful."
            ],
            "code": "  checkoutHead (path) {\r\n    const repo = this.getRepo(path)\r\n    const headCheckedOut = repo.checkoutHead(repo.relativize(path))\r\n    if (headCheckedOut) this.getPathStatus(path)\r\n    return headCheckedOut\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.checkoutHead",
            "start_line": 472,
            "end_line": 477,
            "comment": [
                "\r\n  Section: Checking Out\r\n  ",
                " Public: Restore the contents of a path in the working directory and index",
                " to the version at `HEAD`.",
                "",
                " This is essentially the same as running:",
                "",
                " ```sh",
                "   git reset HEAD -- <path>",
                "   git checkout HEAD -- <path>",
                " ```",
                "",
                " * `path` The {String} path to checkout.",
                "",
                " Returns a {Boolean} that's true if the method was successful."
            ],
            "params": [
                {
                    "name": "path",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "relativize",
            "line": 474,
            "func_location": "GitRepository.checkoutHead",
            "func_start_line": 472,
            "func_end_line": 477,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Checking Out\r\n  ",
                " Public: Restore the contents of a path in the working directory and index",
                " to the version at `HEAD`.",
                "",
                " This is essentially the same as running:",
                "",
                " ```sh",
                "   git reset HEAD -- <path>",
                "   git checkout HEAD -- <path>",
                " ```",
                "",
                " * `path` The {String} path to checkout.",
                "",
                " Returns a {Boolean} that's true if the method was successful."
            ],
            "code": "  checkoutHead (path) {\r\n    const repo = this.getRepo(path)\r\n    const headCheckedOut = repo.checkoutHead(repo.relativize(path))\r\n    if (headCheckedOut) this.getPathStatus(path)\r\n    return headCheckedOut\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.relativize",
            "start_line": 208,
            "end_line": 210,
            "comment": [
                " Public: Makes a path relative to the repository's working directory."
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "relativize",
            "line": 474,
            "func_location": "GitRepository.checkoutHead",
            "func_start_line": 472,
            "func_end_line": 477,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Checking Out\r\n  ",
                " Public: Restore the contents of a path in the working directory and index",
                " to the version at `HEAD`.",
                "",
                " This is essentially the same as running:",
                "",
                " ```sh",
                "   git reset HEAD -- <path>",
                "   git checkout HEAD -- <path>",
                " ```",
                "",
                " * `path` The {String} path to checkout.",
                "",
                " Returns a {Boolean} that's true if the method was successful."
            ],
            "code": "  checkoutHead (path) {\r\n    const repo = this.getRepo(path)\r\n    const headCheckedOut = repo.checkoutHead(repo.relativize(path))\r\n    if (headCheckedOut) this.getPathStatus(path)\r\n    return headCheckedOut\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.relativize",
            "start_line": 208,
            "end_line": 210,
            "comment": [
                " Public: Makes a path relative to the repository's working directory."
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getPathStatus",
            "line": 475,
            "func_location": "GitRepository.checkoutHead",
            "func_start_line": 472,
            "func_end_line": 477,
            "args": [
                {
                    "name": "path",
                    "type": [
                        "string"
                    ]
                }
            ],
            "comment": [
                "\r\n  Section: Checking Out\r\n  ",
                " Public: Restore the contents of a path in the working directory and index",
                " to the version at `HEAD`.",
                "",
                " This is essentially the same as running:",
                "",
                " ```sh",
                "   git reset HEAD -- <path>",
                "   git checkout HEAD -- <path>",
                " ```",
                "",
                " * `path` The {String} path to checkout.",
                "",
                " Returns a {Boolean} that's true if the method was successful."
            ],
            "code": "  checkoutHead (path) {\r\n    const repo = this.getRepo(path)\r\n    const headCheckedOut = repo.checkoutHead(repo.relativize(path))\r\n    if (headCheckedOut) this.getPathStatus(path)\r\n    return headCheckedOut\r\n  }\r",
            "return_type": [
                "number",
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getPathStatus",
            "start_line": 374,
            "end_line": 390,
            "comment": [
                " Public: Get the status of a single path in the repository.",
                "",
                " * `path` A {String} repository-relative path.",
                "",
                " Returns a {Number} representing the status. This value can be passed to",
                " {::isStatusModified} or {::isStatusNew} to get more information."
            ],
            "params": [
                {
                    "name": "path",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "number",
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getPathStatus",
            "line": 475,
            "func_location": "GitRepository.checkoutHead",
            "func_start_line": 472,
            "func_end_line": 477,
            "args": [
                {
                    "name": "path",
                    "type": [
                        "string"
                    ]
                }
            ],
            "comment": [
                "\r\n  Section: Checking Out\r\n  ",
                " Public: Restore the contents of a path in the working directory and index",
                " to the version at `HEAD`.",
                "",
                " This is essentially the same as running:",
                "",
                " ```sh",
                "   git reset HEAD -- <path>",
                "   git checkout HEAD -- <path>",
                " ```",
                "",
                " * `path` The {String} path to checkout.",
                "",
                " Returns a {Boolean} that's true if the method was successful."
            ],
            "code": "  checkoutHead (path) {\r\n    const repo = this.getRepo(path)\r\n    const headCheckedOut = repo.checkoutHead(repo.relativize(path))\r\n    if (headCheckedOut) this.getPathStatus(path)\r\n    return headCheckedOut\r\n  }\r",
            "return_type": [
                "number",
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getPathStatus",
            "start_line": 374,
            "end_line": 390,
            "comment": [
                " Public: Get the status of a single path in the repository.",
                "",
                " * `path` A {String} repository-relative path.",
                "",
                " Returns a {Number} representing the status. This value can be passed to",
                " {::isStatusModified} or {::isStatusNew} to get more information."
            ],
            "params": [
                {
                    "name": "path",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "number",
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "checkoutHead",
            "line": 518,
            "func_location": "GitRepository.checkoutHeadForEditor",
            "func_start_line": 514,
            "func_end_line": 521,
            "args": [
                {
                    "name": "bufferPath",
                    "type": []
                }
            ],
            "comment": [
                " Subscribes to editor view event."
            ],
            "code": "  checkoutHeadForEditor (editor) {\r\n    const buffer = editor.getBuffer()\r\n    const bufferPath = buffer.getPath()\r\n    if (bufferPath) {\r\n      this.checkoutHead(bufferPath)\r\n      return buffer.reload()\r\n    }\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.checkoutHead",
            "start_line": 472,
            "end_line": 477,
            "comment": [
                "\r\n  Section: Checking Out\r\n  ",
                " Public: Restore the contents of a path in the working directory and index",
                " to the version at `HEAD`.",
                "",
                " This is essentially the same as running:",
                "",
                " ```sh",
                "   git reset HEAD -- <path>",
                "   git checkout HEAD -- <path>",
                " ```",
                "",
                " * `path` The {String} path to checkout.",
                "",
                " Returns a {Boolean} that's true if the method was successful."
            ],
            "params": [
                {
                    "name": "path",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "checkoutHead",
            "line": 518,
            "func_location": "GitRepository.checkoutHeadForEditor",
            "func_start_line": 514,
            "func_end_line": 521,
            "args": [
                {
                    "name": "bufferPath",
                    "type": []
                }
            ],
            "comment": [
                " Subscribes to editor view event."
            ],
            "code": "  checkoutHeadForEditor (editor) {\r\n    const buffer = editor.getBuffer()\r\n    const bufferPath = buffer.getPath()\r\n    if (bufferPath) {\r\n      this.checkoutHead(bufferPath)\r\n      return buffer.reload()\r\n    }\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.checkoutHead",
            "start_line": 472,
            "end_line": 477,
            "comment": [
                "\r\n  Section: Checking Out\r\n  ",
                " Public: Restore the contents of a path in the working directory and index",
                " to the version at `HEAD`.",
                "",
                " This is essentially the same as running:",
                "",
                " ```sh",
                "   git reset HEAD -- <path>",
                "   git checkout HEAD -- <path>",
                " ```",
                "",
                " * `path` The {String} path to checkout.",
                "",
                " Returns a {Boolean} that's true if the method was successful."
            ],
            "params": [
                {
                    "name": "path",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 487,
            "func_location": "GitRepository.checkoutReference",
            "func_start_line": 486,
            "func_end_line": 488,
            "args": [
                {
                    "name": "reference",
                    "type": [
                        "string",
                        "boolean"
                    ]
                },
                {
                    "name": "create",
                    "type": [
                        "boolean"
                    ]
                }
            ],
            "comment": [
                " Public: Checks out a branch in your repository.",
                "",
                " * `reference` The {String} reference to checkout.",
                " * `create`    A {Boolean} value which, if true creates the new reference if",
                "   it doesn't exist.",
                "",
                " Returns a Boolean that's true if the method was successful."
            ],
            "code": "  checkoutReference (reference, create) {\r\n    return this.getRepo().checkoutReference(reference, create)\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 487,
            "func_location": "GitRepository.checkoutReference",
            "func_start_line": 486,
            "func_end_line": 488,
            "args": [
                {
                    "name": "reference",
                    "type": [
                        "string",
                        "boolean"
                    ]
                },
                {
                    "name": "create",
                    "type": [
                        "boolean"
                    ]
                }
            ],
            "comment": [
                " Public: Checks out a branch in your repository.",
                "",
                " * `reference` The {String} reference to checkout.",
                " * `create`    A {Boolean} value which, if true creates the new reference if",
                "   it doesn't exist.",
                "",
                " Returns a Boolean that's true if the method was successful."
            ],
            "code": "  checkoutReference (reference, create) {\r\n    return this.getRepo().checkoutReference(reference, create)\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "checkoutReference",
            "line": 487,
            "func_location": "GitRepository.checkoutReference",
            "func_start_line": 486,
            "func_end_line": 488,
            "args": [
                {
                    "name": "reference",
                    "type": [
                        "string",
                        "boolean"
                    ]
                },
                {
                    "name": "create",
                    "type": [
                        "boolean"
                    ]
                }
            ],
            "comment": [
                " Public: Checks out a branch in your repository.",
                "",
                " * `reference` The {String} reference to checkout.",
                " * `create`    A {Boolean} value which, if true creates the new reference if",
                "   it doesn't exist.",
                "",
                " Returns a Boolean that's true if the method was successful."
            ],
            "code": "  checkoutReference (reference, create) {\r\n    return this.getRepo().checkoutReference(reference, create)\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.checkoutReference",
            "start_line": 486,
            "end_line": 488,
            "comment": [
                " Public: Checks out a branch in your repository.",
                "",
                " * `reference` The {String} reference to checkout.",
                " * `create`    A {Boolean} value which, if true creates the new reference if",
                "   it doesn't exist.",
                "",
                " Returns a Boolean that's true if the method was successful."
            ],
            "params": [
                {
                    "name": "reference",
                    "type": [
                        "string",
                        "boolean"
                    ]
                },
                {
                    "name": "create",
                    "type": [
                        "boolean"
                    ]
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "checkoutReference",
            "line": 487,
            "func_location": "GitRepository.checkoutReference",
            "func_start_line": 486,
            "func_end_line": 488,
            "args": [
                {
                    "name": "reference",
                    "type": [
                        "string",
                        "boolean"
                    ]
                },
                {
                    "name": "create",
                    "type": [
                        "boolean"
                    ]
                }
            ],
            "comment": [
                " Public: Checks out a branch in your repository.",
                "",
                " * `reference` The {String} reference to checkout.",
                " * `create`    A {Boolean} value which, if true creates the new reference if",
                "   it doesn't exist.",
                "",
                " Returns a Boolean that's true if the method was successful."
            ],
            "code": "  checkoutReference (reference, create) {\r\n    return this.getRepo().checkoutReference(reference, create)\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.checkoutReference",
            "start_line": 486,
            "end_line": 488,
            "comment": [
                " Public: Checks out a branch in your repository.",
                "",
                " * `reference` The {String} reference to checkout.",
                " * `create`    A {Boolean} value which, if true creates the new reference if",
                "   it doesn't exist.",
                "",
                " Returns a Boolean that's true if the method was successful."
            ],
            "params": [
                {
                    "name": "reference",
                    "type": [
                        "string",
                        "boolean"
                    ]
                },
                {
                    "name": "create",
                    "type": [
                        "boolean"
                    ]
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "getBuffer",
            "line": 215,
            "func_location": "TextEditorRegistry.clearGrammarOverride",
            "func_start_line": 214,
            "func_end_line": 216,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Deprecated: Remove any grammar override that has been set for the given {TextEditor}.",
                "",
                " * `editor` The editor."
            ],
            "code": "  clearGrammarOverride (editor) {\r\n    atom.grammars.autoAssignLanguageMode(editor.getBuffer())\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.getBuffer",
            "start_line": 963,
            "end_line": 963,
            "comment": [
                " Essential: Retrieves the current {TextBuffer}."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "parse",
            "line": 1415,
            "func_location": "color.coerce",
            "func_start_line": 1414,
            "func_end_line": 1420,
            "args": [
                "value"
            ],
            "code": "    coerce (keyPath, value, schema) {\r\n      const color = Color.parse(value)\r\n      if (color == null) {\r\n        throw new Error(`Validation failed at ${keyPath}, ${JSON.stringify(value)} cannot be coerced into a color`)\r\n      }\r\n      return color\r\n    }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/color.js",
            "name": "Color.parse",
            "start_line": 14,
            "end_line": 36,
            "comment": [
                " Essential: Parse a {String} or {Object} into a {Color}.",
                "",
                " * `value` A {String} such as `'white'`, `#ff00ff`, or",
                "   `'rgba(255, 15, 60, .75)'` or an {Object} with `red`, `green`, `blue`,",
                "   and `alpha` properties.",
                "",
                " Returns a {Color} or `null` if it cannot be parsed."
            ],
            "params": [
                {
                    "name": "value",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "null"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-mate-language-mode.js",
            "name": "getAll",
            "line": 187,
            "func_location": "TextMateLanguageMode.commentStringsForPosition",
            "func_start_line": 185,
            "func_end_line": 197,
            "args": [
                {
                    "name": {
                        "type": "string"
                    },
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section - Comments\r\n  "
            ],
            "code": "  commentStringsForPosition (position) {\r\n    const scope = this.scopeDescriptorForPosition(position)\r\n    const commentStartEntries = this.config.getAll('editor.commentStart', {scope})\r\n    const commentEndEntries = this.config.getAll('editor.commentEnd', {scope})\r\n    const commentStartEntry = commentStartEntries[0]\r\n    const commentEndEntry = commentEndEntries.find((entry) => {\r\n      return entry.scopeSelector === commentStartEntry.scopeSelector\r\n    })\r\n    return {\r\n      commentStartString: commentStartEntry && commentStartEntry.value,\r\n      commentEndString: commentEndEntry && commentEndEntry.value\r\n    }\r\n  }\r",
            "return_type": [
                "object",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.getAll",
            "start_line": 613,
            "end_line": 643,
            "comment": [
                " Extended: Get all of the values for the given key-path, along with their",
                " associated scope selector.",
                "",
                " * `keyPath` The {String} name of the key to retrieve",
                " * `options` (optional) {Object} see the `options` argument to {::get}",
                "",
                " Returns an {Array} of {Object}s with the following keys:",
                "  * `scopeDescriptor` The {ScopeDescriptor} with which the value is associated",
                "  * `value` The value for the key-path"
            ],
            "params": [
                {
                    "name": "keyPath",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": [
                "object",
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-mate-language-mode.js",
            "name": "getAll",
            "line": 187,
            "func_location": "TextMateLanguageMode.commentStringsForPosition",
            "func_start_line": 185,
            "func_end_line": 197,
            "args": [
                {
                    "name": {
                        "type": "string"
                    },
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section - Comments\r\n  "
            ],
            "code": "  commentStringsForPosition (position) {\r\n    const scope = this.scopeDescriptorForPosition(position)\r\n    const commentStartEntries = this.config.getAll('editor.commentStart', {scope})\r\n    const commentEndEntries = this.config.getAll('editor.commentEnd', {scope})\r\n    const commentStartEntry = commentStartEntries[0]\r\n    const commentEndEntry = commentEndEntries.find((entry) => {\r\n      return entry.scopeSelector === commentStartEntry.scopeSelector\r\n    })\r\n    return {\r\n      commentStartString: commentStartEntry && commentStartEntry.value,\r\n      commentEndString: commentEndEntry && commentEndEntry.value\r\n    }\r\n  }\r",
            "return_type": [
                "object",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.getAll",
            "start_line": 613,
            "end_line": 643,
            "comment": [
                " Extended: Get all of the values for the given key-path, along with their",
                " associated scope selector.",
                "",
                " * `keyPath` The {String} name of the key to retrieve",
                " * `options` (optional) {Object} see the `options` argument to {::get}",
                "",
                " Returns an {Array} of {Object}s with the following keys:",
                "  * `scopeDescriptor` The {ScopeDescriptor} with which the value is associated",
                "  * `value` The value for the key-path"
            ],
            "params": [
                {
                    "name": "keyPath",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": [
                "object",
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-mate-language-mode.js",
            "name": "getAll",
            "line": 188,
            "func_location": "TextMateLanguageMode.commentStringsForPosition",
            "func_start_line": 185,
            "func_end_line": 197,
            "args": [
                {
                    "name": {
                        "type": "string"
                    },
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section - Comments\r\n  "
            ],
            "code": "  commentStringsForPosition (position) {\r\n    const scope = this.scopeDescriptorForPosition(position)\r\n    const commentStartEntries = this.config.getAll('editor.commentStart', {scope})\r\n    const commentEndEntries = this.config.getAll('editor.commentEnd', {scope})\r\n    const commentStartEntry = commentStartEntries[0]\r\n    const commentEndEntry = commentEndEntries.find((entry) => {\r\n      return entry.scopeSelector === commentStartEntry.scopeSelector\r\n    })\r\n    return {\r\n      commentStartString: commentStartEntry && commentStartEntry.value,\r\n      commentEndString: commentEndEntry && commentEndEntry.value\r\n    }\r\n  }\r",
            "return_type": [
                "object",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.getAll",
            "start_line": 613,
            "end_line": 643,
            "comment": [
                " Extended: Get all of the values for the given key-path, along with their",
                " associated scope selector.",
                "",
                " * `keyPath` The {String} name of the key to retrieve",
                " * `options` (optional) {Object} see the `options` argument to {::get}",
                "",
                " Returns an {Array} of {Object}s with the following keys:",
                "  * `scopeDescriptor` The {ScopeDescriptor} with which the value is associated",
                "  * `value` The value for the key-path"
            ],
            "params": [
                {
                    "name": "keyPath",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": [
                "object",
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-mate-language-mode.js",
            "name": "getAll",
            "line": 188,
            "func_location": "TextMateLanguageMode.commentStringsForPosition",
            "func_start_line": 185,
            "func_end_line": 197,
            "args": [
                {
                    "name": {
                        "type": "string"
                    },
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section - Comments\r\n  "
            ],
            "code": "  commentStringsForPosition (position) {\r\n    const scope = this.scopeDescriptorForPosition(position)\r\n    const commentStartEntries = this.config.getAll('editor.commentStart', {scope})\r\n    const commentEndEntries = this.config.getAll('editor.commentEnd', {scope})\r\n    const commentStartEntry = commentStartEntries[0]\r\n    const commentEndEntry = commentEndEntries.find((entry) => {\r\n      return entry.scopeSelector === commentStartEntry.scopeSelector\r\n    })\r\n    return {\r\n      commentStartString: commentStartEntry && commentStartEntry.value,\r\n      commentEndString: commentEndEntry && commentEndEntry.value\r\n    }\r\n  }\r",
            "return_type": [
                "object",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.getAll",
            "start_line": 613,
            "end_line": 643,
            "comment": [
                " Extended: Get all of the values for the given key-path, along with their",
                " associated scope selector.",
                "",
                " * `keyPath` The {String} name of the key to retrieve",
                " * `options` (optional) {Object} see the `options` argument to {::get}",
                "",
                " Returns an {Array} of {Object}s with the following keys:",
                "  * `scopeDescriptor` The {ScopeDescriptor} with which the value is associated",
                "  * `value` The value for the key-path"
            ],
            "params": [
                {
                    "name": "keyPath",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": [
                "object",
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getBufferPosition",
            "line": 655,
            "func_location": "Cursor.compare",
            "func_start_line": 654,
            "func_end_line": 656,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Visibility\r\n  ",
                "\r\n  Section: Comparing to another cursor\r\n  ",
                " Public: Compare this cursor's buffer position to another cursor's buffer position.",
                "",
                " See {Point::compare} for more details.",
                "",
                " * `otherCursor`{Cursor} to compare against"
            ],
            "code": "  compare (otherCursor) {\r\n    return this.getBufferPosition().compare(otherCursor.getBufferPosition())\r\n  }\r",
            "return_type": [
                "object",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getBufferPosition",
            "start_line": 91,
            "end_line": 93,
            "comment": [
                " Public: Returns the current buffer position as an Array."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "compare",
            "line": 655,
            "func_location": "Cursor.compare",
            "func_start_line": 654,
            "func_end_line": 656,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Visibility\r\n  ",
                "\r\n  Section: Comparing to another cursor\r\n  ",
                " Public: Compare this cursor's buffer position to another cursor's buffer position.",
                "",
                " See {Point::compare} for more details.",
                "",
                " * `otherCursor`{Cursor} to compare against"
            ],
            "code": "  compare (otherCursor) {\r\n    return this.getBufferPosition().compare(otherCursor.getBufferPosition())\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.compare",
            "start_line": 654,
            "end_line": 656,
            "comment": [
                "\r\n  Section: Visibility\r\n  ",
                "\r\n  Section: Comparing to another cursor\r\n  ",
                " Public: Compare this cursor's buffer position to another cursor's buffer position.",
                "",
                " See {Point::compare} for more details.",
                "",
                " * `otherCursor`{Cursor} to compare against"
            ],
            "params": [
                {
                    "name": "otherCursor",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "compare",
            "line": 655,
            "func_location": "Cursor.compare",
            "func_start_line": 654,
            "func_end_line": 656,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Visibility\r\n  ",
                "\r\n  Section: Comparing to another cursor\r\n  ",
                " Public: Compare this cursor's buffer position to another cursor's buffer position.",
                "",
                " See {Point::compare} for more details.",
                "",
                " * `otherCursor`{Cursor} to compare against"
            ],
            "code": "  compare (otherCursor) {\r\n    return this.getBufferPosition().compare(otherCursor.getBufferPosition())\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.compare",
            "start_line": 654,
            "end_line": 656,
            "comment": [
                "\r\n  Section: Visibility\r\n  ",
                "\r\n  Section: Comparing to another cursor\r\n  ",
                " Public: Compare this cursor's buffer position to another cursor's buffer position.",
                "",
                " See {Point::compare} for more details.",
                "",
                " * `otherCursor`{Cursor} to compare against"
            ],
            "params": [
                {
                    "name": "otherCursor",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getBufferPosition",
            "line": 655,
            "func_location": "Cursor.compare",
            "func_start_line": 654,
            "func_end_line": 656,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Visibility\r\n  ",
                "\r\n  Section: Comparing to another cursor\r\n  ",
                " Public: Compare this cursor's buffer position to another cursor's buffer position.",
                "",
                " See {Point::compare} for more details.",
                "",
                " * `otherCursor`{Cursor} to compare against"
            ],
            "code": "  compare (otherCursor) {\r\n    return this.getBufferPosition().compare(otherCursor.getBufferPosition())\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getBufferPosition",
            "start_line": 91,
            "end_line": 93,
            "comment": [
                " Public: Returns the current buffer position as an Array."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/babel.js",
            "name": "replace",
            "line": 54,
            "func_location": "exports.compile",
            "func_start_line": 44,
            "func_end_line": 62,
            "args": [
                {
                    "type": "object"
                },
                {
                    "type": "string"
                }
            ],
            "code": "exports.compile = function (sourceCode, filePath) {\r\n  if (!babel) {\r\n    babel = require('babel-core')\r\n    var Logger = require('babel-core/lib/transformation/file/logger')\r\n    var noop = function () {}\r\n    Logger.prototype.debug = noop\r\n    Logger.prototype.verbose = noop\r\n  }\r\n\r\n  if (process.platform === 'win32') {\r\n    filePath = 'file:///' + path.resolve(filePath).replace(/\\\\/g, '/')\r\n  }\r\n\r\n  var options = {filename: filePath}\r\n  for (var key in defaultOptions) {\r\n    options[key] = defaultOptions[key]\r\n  }\r\n  return babel.transform(sourceCode, options).code\r\n}\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "Project.replace",
            "start_line": 82,
            "end_line": 99,
            "comment": [
                " Layers the contents of a project's file's config",
                " on top of the current global config."
            ],
            "params": [
                {
                    "name": "projectSpecification",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/coffee-script.js",
            "name": "replace",
            "line": 33,
            "func_location": "exports.compile",
            "func_start_line": 21,
            "func_end_line": 45,
            "args": [
                {
                    "type": "object"
                },
                {
                    "type": "string"
                }
            ],
            "code": "exports.compile = function (sourceCode, filePath) {\r\n  if (!CoffeeScript) {\r\n    var previousPrepareStackTrace = Error.prepareStackTrace\r\n    CoffeeScript = require('coffee-script')\r\n\r\n    // When it loads, coffee-script reassigns Error.prepareStackTrace. We have\r\n    // already reassigned it via the 'source-map-support' module, so we need\r\n    // to set it back.\r\n    Error.prepareStackTrace = previousPrepareStackTrace\r\n  }\r\n\r\n  if (process.platform === 'win32') {\r\n    filePath = 'file:///' + path.resolve(filePath).replace(/\\\\/g, '/')\r\n  }\r\n\r\n  var output = CoffeeScript.compile(sourceCode, {\r\n    filename: filePath,\r\n    sourceFiles: [filePath],\r\n    inlineMap: true\r\n  })\r\n\r\n  // Strip sourceURL from output so there wouldn't be duplicate entries\r\n  // in devtools.\r\n  return output.replace(/\\/\\/# sourceURL=[^'\"\\n]+\\s*$/, '')\r\n}\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "Project.replace",
            "start_line": 82,
            "end_line": 99,
            "comment": [
                " Layers the contents of a project's file's config",
                " on top of the current global config."
            ],
            "params": [
                {
                    "name": "projectSpecification",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/coffee-script.js",
            "name": "replace",
            "line": 44,
            "func_location": "exports.compile",
            "func_start_line": 21,
            "func_end_line": 45,
            "args": [
                {
                    "type": "object"
                },
                {
                    "type": "string"
                }
            ],
            "code": "exports.compile = function (sourceCode, filePath) {\r\n  if (!CoffeeScript) {\r\n    var previousPrepareStackTrace = Error.prepareStackTrace\r\n    CoffeeScript = require('coffee-script')\r\n\r\n    // When it loads, coffee-script reassigns Error.prepareStackTrace. We have\r\n    // already reassigned it via the 'source-map-support' module, so we need\r\n    // to set it back.\r\n    Error.prepareStackTrace = previousPrepareStackTrace\r\n  }\r\n\r\n  if (process.platform === 'win32') {\r\n    filePath = 'file:///' + path.resolve(filePath).replace(/\\\\/g, '/')\r\n  }\r\n\r\n  var output = CoffeeScript.compile(sourceCode, {\r\n    filename: filePath,\r\n    sourceFiles: [filePath],\r\n    inlineMap: true\r\n  })\r\n\r\n  // Strip sourceURL from output so there wouldn't be duplicate entries\r\n  // in devtools.\r\n  return output.replace(/\\/\\/# sourceURL=[^'\"\\n]+\\s*$/, '')\r\n}\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "Project.replace",
            "start_line": 82,
            "end_line": 99,
            "comment": [
                " Layers the contents of a project's file's config",
                " on top of the current global config."
            ],
            "params": [
                {
                    "name": "projectSpecification",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/typescript.js",
            "name": "replace",
            "line": 41,
            "func_location": "exports.compile",
            "func_start_line": 35,
            "func_end_line": 46,
            "args": [
                {
                    "type": "object"
                },
                {
                    "type": "string"
                }
            ],
            "code": "exports.compile = function (sourceCode, filePath) {\r\n  if (!TypeScriptSimple) {\r\n    TypeScriptSimple = require('typescript-simple').TypeScriptSimple\r\n  }\r\n\r\n  if (process.platform === 'win32') {\r\n    filePath = 'file:///' + path.resolve(filePath).replace(/\\\\/g, '/')\r\n  }\r\n\r\n  var options = _.defaults({filename: filePath}, defaultOptions)\r\n  return new TypeScriptSimple(options, false).compile(sourceCode, filePath)\r\n}\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "Project.replace",
            "start_line": 82,
            "end_line": 99,
            "comment": [
                " Layers the contents of a project's file's config",
                " on top of the current global config."
            ],
            "params": [
                {
                    "name": "projectSpecification",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/history-manager.js",
            "name": "onDidChangePaths",
            "line": 15,
            "func_location": "HistoryManager.constructor",
            "func_start_line": 9,
            "func_end_line": 16,
            "args": [
                null
            ],
            "code": "  constructor ({project, commands, stateStore}) {\r\n    this.stateStore = stateStore\r\n    this.emitter = new Emitter()\r\n    this.projects = []\r\n    this.disposables = new CompositeDisposable()\r\n    this.disposables.add(commands.add('atom-workspace', {'application:clear-project-history': this.clearProjects.bind(this)}, false))\r\n    this.disposables.add(project.onDidChangePaths((projectPaths) => this.addProject(projectPaths)))\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "Project.onDidChangePaths",
            "start_line": 168,
            "end_line": 170,
            "comment": [
                "\r\n  Section: Event Subscription\r\n  ",
                " Public: Invoke the given callback when the project paths change.",
                "",
                " * `callback` {Function} to be called after the project paths change.",
                "    * `projectPaths` An {Array} of {String} project paths.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/decoration.js",
            "name": "setProperties",
            "line": 79,
            "func_location": "Decoration.constructor",
            "func_start_line": 74,
            "func_end_line": 82,
            "args": [
                {
                    "name": "properties",
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Construction and Destruction\r\n  "
            ],
            "code": "  constructor (marker, decorationManager, properties) {\r\n    this.marker = marker\r\n    this.decorationManager = decorationManager\r\n    this.emitter = new Emitter()\r\n    this.id = nextId()\r\n    this.setProperties(properties)\r\n    this.destroyed = false\r\n    this.markerDestroyDisposable = this.marker.onDidDestroy(() => this.destroy())\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/decoration.js",
            "name": "Decoration.setProperties",
            "start_line": 164,
            "end_line": 173,
            "comment": [
                " Essential: Update the marker with new Properties. Allows you to change the decoration's class.",
                "",
                " ## Examples",
                "",
                " ```coffee",
                " decoration.setProperties({type: 'line-number', class: 'my-new-class'})",
                " ```",
                "",
                " * `newProperties` {Object} eg. `{type: 'line-number', class: 'my-new-class'}`"
            ],
            "params": [
                {
                    "name": "newProperties",
                    "type": [
                        "number",
                        "object"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/decoration.js",
            "name": "setProperties",
            "line": 79,
            "func_location": "Decoration.constructor",
            "func_start_line": 74,
            "func_end_line": 82,
            "args": [
                {
                    "name": "properties",
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Construction and Destruction\r\n  "
            ],
            "code": "  constructor (marker, decorationManager, properties) {\r\n    this.marker = marker\r\n    this.decorationManager = decorationManager\r\n    this.emitter = new Emitter()\r\n    this.id = nextId()\r\n    this.setProperties(properties)\r\n    this.destroyed = false\r\n    this.markerDestroyDisposable = this.marker.onDidDestroy(() => this.destroy())\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/decoration.js",
            "name": "Decoration.setProperties",
            "start_line": 164,
            "end_line": 173,
            "comment": [
                " Essential: Update the marker with new Properties. Allows you to change the decoration's class.",
                "",
                " ## Examples",
                "",
                " ```coffee",
                " decoration.setProperties({type: 'line-number', class: 'my-new-class'})",
                " ```",
                "",
                " * `newProperties` {Object} eg. `{type: 'line-number', class: 'my-new-class'}`"
            ],
            "params": [
                {
                    "name": "newProperties",
                    "type": [
                        "number",
                        "object"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "onDidAddBuffer",
            "line": 106,
            "func_location": "GitRepository.constructor",
            "func_start_line": 74,
            "func_end_line": 108,
            "args": [
                null
            ],
            "code": "  constructor (path, options = {}) {\r\n    this.id = nextId++\r\n    this.emitter = new Emitter()\r\n    this.subscriptions = new CompositeDisposable()\r\n    this.repo = GitUtils.open(path)\r\n    if (this.repo == null) {\r\n      throw new Error(`No Git repository found searching path: ${path}`)\r\n    }\r\n\r\n    this.statusRefreshCount = 0\r\n    this.statuses = {}\r\n    this.upstream = {ahead: 0, behind: 0}\r\n    for (let submodulePath in this.repo.submodules) {\r\n      const submoduleRepo = this.repo.submodules[submodulePath]\r\n      submoduleRepo.upstream = {ahead: 0, behind: 0}\r\n    }\r\n\r\n    this.project = options.project\r\n    this.config = options.config\r\n\r\n    if (options.refreshOnWindowFocus || options.refreshOnWindowFocus == null) {\r\n      const onWindowFocus = () => {\r\n        this.refreshIndex()\r\n        this.refreshStatus()\r\n      }\r\n\r\n      window.addEventListener('focus', onWindowFocus)\r\n      this.subscriptions.add(new Disposable(() => window.removeEventListener('focus', onWindowFocus)))\r\n    }\r\n\r\n    if (this.project != null) {\r\n      this.project.getBuffers().forEach(buffer => this.subscribeToBuffer(buffer))\r\n      this.subscriptions.add(this.project.onDidAddBuffer(buffer => this.subscribeToBuffer(buffer)))\r\n    }\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "Project.onDidAddBuffer",
            "start_line": 179,
            "end_line": 181,
            "comment": [
                " Public: Invoke the given callback when a text buffer is added to the",
                " project.",
                "",
                " * `callback` {Function} to be called when a text buffer is added.",
                "   * `buffer` A {TextBuffer} item.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/atom-environment.js",
            "name": "setSchema",
            "line": 93,
            "func_location": "AtomEnvironment.constructor",
            "func_start_line": 57,
            "func_end_line": 199,
            "args": [
                {
                    "name": {
                        "type": "object"
                    },
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Properties\r\n  "
            ],
            "code": "  constructor (params = {}) {\r\n    this.id = (params.id != null) ? params.id : nextId++\r\n\r\n    // Public: A {Clipboard} instance\r\n    this.clipboard = params.clipboard\r\n    this.updateProcessEnv = params.updateProcessEnv || updateProcessEnv\r\n    this.enablePersistence = params.enablePersistence\r\n    this.applicationDelegate = params.applicationDelegate\r\n\r\n    this.nextProxyRequestId = 0\r\n    this.unloading = false\r\n    this.loadTime = null\r\n    this.emitter = new Emitter()\r\n    this.disposables = new CompositeDisposable()\r\n    this.pathsWithWaitSessions = new Set()\r\n\r\n    // Public: A {DeserializerManager} instance\r\n    this.deserializers = new DeserializerManager(this)\r\n    this.deserializeTimings = {}\r\n\r\n    // Public: A {ViewRegistry} instance\r\n    this.views = new ViewRegistry(this)\r\n\r\n    // Public: A {NotificationManager} instance\r\n    this.notifications = new NotificationManager()\r\n\r\n    this.stateStore = new StateStore('AtomEnvironments', 1)\r\n\r\n    // Public: A {Config} instance\r\n    this.config = new Config({\r\n      saveCallback: settings => {\r\n        if (this.enablePersistence) {\r\n          this.applicationDelegate.setUserSettings(settings, this.config.getUserConfigPath())\r\n        }\r\n      }\r\n    })\r\n    this.config.setSchema(null, {type: 'object', properties: _.clone(ConfigSchema)})\r\n\r\n    // Public: A {KeymapManager} instance\r\n    this.keymaps = new KeymapManager({notificationManager: this.notifications})\r\n\r\n    // Public: A {TooltipManager} instance\r\n    this.tooltips = new TooltipManager({keymapManager: this.keymaps, viewRegistry: this.views})\r\n\r\n    // Public: A {CommandRegistry} instance\r\n    this.commands = new CommandRegistry()\r\n    this.uriHandlerRegistry = new URIHandlerRegistry()\r\n\r\n    // Public: A {GrammarRegistry} instance\r\n    this.grammars = new GrammarRegistry({config: this.config})\r\n\r\n    // Public: A {StyleManager} instance\r\n    this.styles = new StyleManager()\r\n\r\n    // Public: A {PackageManager} instance\r\n    this.packages = new PackageManager({\r\n      config: this.config,\r\n      styleManager: this.styles,\r\n      commandRegistry: this.commands,\r\n      keymapManager: this.keymaps,\r\n      notificationManager: this.notifications,\r\n      grammarRegistry: this.grammars,\r\n      deserializerManager: this.deserializers,\r\n      viewRegistry: this.views,\r\n      uriHandlerRegistry: this.uriHandlerRegistry\r\n    })\r\n\r\n    // Public: A {ThemeManager} instance\r\n    this.themes = new ThemeManager({\r\n      packageManager: this.packages,\r\n      config: this.config,\r\n      styleManager: this.styles,\r\n      notificationManager: this.notifications,\r\n      viewRegistry: this.views\r\n    })\r\n\r\n    // Public: A {MenuManager} instance\r\n    this.menu = new MenuManager({keymapManager: this.keymaps, packageManager: this.packages})\r\n\r\n    // Public: A {ContextMenuManager} instance\r\n    this.contextMenu = new ContextMenuManager({keymapManager: this.keymaps})\r\n\r\n    this.packages.setMenuManager(this.menu)\r\n    this.packages.setContextMenuManager(this.contextMenu)\r\n    this.packages.setThemeManager(this.themes)\r\n\r\n    // Public: A {Project} instance\r\n    this.project = new Project({\r\n      notificationManager: this.notifications,\r\n      packageManager: this.packages,\r\n      grammarRegistry: this.grammars,\r\n      config: this.config,\r\n      applicationDelegate: this.applicationDelegate\r\n    })\r\n    this.commandInstaller = new CommandInstaller(this.applicationDelegate)\r\n    this.protocolHandlerInstaller = new ProtocolHandlerInstaller()\r\n\r\n    // Public: A {TextEditorRegistry} instance\r\n    this.textEditors = new TextEditorRegistry({\r\n      config: this.config,\r\n      grammarRegistry: this.grammars,\r\n      assert: this.assert.bind(this),\r\n      packageManager: this.packages\r\n    })\r\n\r\n    // Public: A {Workspace} instance\r\n    this.workspace = new Workspace({\r\n      config: this.config,\r\n      project: this.project,\r\n      packageManager: this.packages,\r\n      grammarRegistry: this.grammars,\r\n      deserializerManager: this.deserializers,\r\n      notificationManager: this.notifications,\r\n      applicationDelegate: this.applicationDelegate,\r\n      viewRegistry: this.views,\r\n      assert: this.assert.bind(this),\r\n      textEditorRegistry: this.textEditors,\r\n      styleManager: this.styles,\r\n      enablePersistence: this.enablePersistence\r\n    })\r\n\r\n    this.themes.workspace = this.workspace\r\n\r\n    this.autoUpdater = new AutoUpdateManager({applicationDelegate: this.applicationDelegate})\r\n\r\n    if (this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.registerDefaultCommands()\r\n    this.registerDefaultOpeners()\r\n    this.registerDefaultDeserializers()\r\n\r\n    this.windowEventHandler = new WindowEventHandler({atomEnvironment: this, applicationDelegate: this.applicationDelegate})\r\n\r\n    // Public: A {HistoryManager} instance\r\n    this.history = new HistoryManager({project: this.project, commands: this.commands, stateStore: this.stateStore})\r\n\r\n    // Keep instances of HistoryManager in sync\r\n    this.disposables.add(this.history.onDidChangeProjects(event => {\r\n      if (!event.reloaded) this.applicationDelegate.didChangeHistoryManager()\r\n    }))\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.setSchema",
            "start_line": 895,
            "end_line": 921,
            "comment": [],
            "params": [
                "keyPath",
                "schema"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/atom-environment.js",
            "name": "clone",
            "line": 93,
            "func_location": "AtomEnvironment.constructor",
            "func_start_line": 57,
            "func_end_line": 199,
            "args": [
                {
                    "name": {
                        "type": "object"
                    },
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Properties\r\n  "
            ],
            "code": "  constructor (params = {}) {\r\n    this.id = (params.id != null) ? params.id : nextId++\r\n\r\n    // Public: A {Clipboard} instance\r\n    this.clipboard = params.clipboard\r\n    this.updateProcessEnv = params.updateProcessEnv || updateProcessEnv\r\n    this.enablePersistence = params.enablePersistence\r\n    this.applicationDelegate = params.applicationDelegate\r\n\r\n    this.nextProxyRequestId = 0\r\n    this.unloading = false\r\n    this.loadTime = null\r\n    this.emitter = new Emitter()\r\n    this.disposables = new CompositeDisposable()\r\n    this.pathsWithWaitSessions = new Set()\r\n\r\n    // Public: A {DeserializerManager} instance\r\n    this.deserializers = new DeserializerManager(this)\r\n    this.deserializeTimings = {}\r\n\r\n    // Public: A {ViewRegistry} instance\r\n    this.views = new ViewRegistry(this)\r\n\r\n    // Public: A {NotificationManager} instance\r\n    this.notifications = new NotificationManager()\r\n\r\n    this.stateStore = new StateStore('AtomEnvironments', 1)\r\n\r\n    // Public: A {Config} instance\r\n    this.config = new Config({\r\n      saveCallback: settings => {\r\n        if (this.enablePersistence) {\r\n          this.applicationDelegate.setUserSettings(settings, this.config.getUserConfigPath())\r\n        }\r\n      }\r\n    })\r\n    this.config.setSchema(null, {type: 'object', properties: _.clone(ConfigSchema)})\r\n\r\n    // Public: A {KeymapManager} instance\r\n    this.keymaps = new KeymapManager({notificationManager: this.notifications})\r\n\r\n    // Public: A {TooltipManager} instance\r\n    this.tooltips = new TooltipManager({keymapManager: this.keymaps, viewRegistry: this.views})\r\n\r\n    // Public: A {CommandRegistry} instance\r\n    this.commands = new CommandRegistry()\r\n    this.uriHandlerRegistry = new URIHandlerRegistry()\r\n\r\n    // Public: A {GrammarRegistry} instance\r\n    this.grammars = new GrammarRegistry({config: this.config})\r\n\r\n    // Public: A {StyleManager} instance\r\n    this.styles = new StyleManager()\r\n\r\n    // Public: A {PackageManager} instance\r\n    this.packages = new PackageManager({\r\n      config: this.config,\r\n      styleManager: this.styles,\r\n      commandRegistry: this.commands,\r\n      keymapManager: this.keymaps,\r\n      notificationManager: this.notifications,\r\n      grammarRegistry: this.grammars,\r\n      deserializerManager: this.deserializers,\r\n      viewRegistry: this.views,\r\n      uriHandlerRegistry: this.uriHandlerRegistry\r\n    })\r\n\r\n    // Public: A {ThemeManager} instance\r\n    this.themes = new ThemeManager({\r\n      packageManager: this.packages,\r\n      config: this.config,\r\n      styleManager: this.styles,\r\n      notificationManager: this.notifications,\r\n      viewRegistry: this.views\r\n    })\r\n\r\n    // Public: A {MenuManager} instance\r\n    this.menu = new MenuManager({keymapManager: this.keymaps, packageManager: this.packages})\r\n\r\n    // Public: A {ContextMenuManager} instance\r\n    this.contextMenu = new ContextMenuManager({keymapManager: this.keymaps})\r\n\r\n    this.packages.setMenuManager(this.menu)\r\n    this.packages.setContextMenuManager(this.contextMenu)\r\n    this.packages.setThemeManager(this.themes)\r\n\r\n    // Public: A {Project} instance\r\n    this.project = new Project({\r\n      notificationManager: this.notifications,\r\n      packageManager: this.packages,\r\n      grammarRegistry: this.grammars,\r\n      config: this.config,\r\n      applicationDelegate: this.applicationDelegate\r\n    })\r\n    this.commandInstaller = new CommandInstaller(this.applicationDelegate)\r\n    this.protocolHandlerInstaller = new ProtocolHandlerInstaller()\r\n\r\n    // Public: A {TextEditorRegistry} instance\r\n    this.textEditors = new TextEditorRegistry({\r\n      config: this.config,\r\n      grammarRegistry: this.grammars,\r\n      assert: this.assert.bind(this),\r\n      packageManager: this.packages\r\n    })\r\n\r\n    // Public: A {Workspace} instance\r\n    this.workspace = new Workspace({\r\n      config: this.config,\r\n      project: this.project,\r\n      packageManager: this.packages,\r\n      grammarRegistry: this.grammars,\r\n      deserializerManager: this.deserializers,\r\n      notificationManager: this.notifications,\r\n      applicationDelegate: this.applicationDelegate,\r\n      viewRegistry: this.views,\r\n      assert: this.assert.bind(this),\r\n      textEditorRegistry: this.textEditors,\r\n      styleManager: this.styles,\r\n      enablePersistence: this.enablePersistence\r\n    })\r\n\r\n    this.themes.workspace = this.workspace\r\n\r\n    this.autoUpdater = new AutoUpdateManager({applicationDelegate: this.applicationDelegate})\r\n\r\n    if (this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.registerDefaultCommands()\r\n    this.registerDefaultOpeners()\r\n    this.registerDefaultDeserializers()\r\n\r\n    this.windowEventHandler = new WindowEventHandler({atomEnvironment: this, applicationDelegate: this.applicationDelegate})\r\n\r\n    // Public: A {HistoryManager} instance\r\n    this.history = new HistoryManager({project: this.project, commands: this.commands, stateStore: this.stateStore})\r\n\r\n    // Keep instances of HistoryManager in sync\r\n    this.disposables.add(this.history.onDidChangeProjects(event => {\r\n      if (!event.reloaded) this.applicationDelegate.didChangeHistoryManager()\r\n    }))\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/color.js",
            "name": "Color.clone",
            "start_line": 111,
            "end_line": 113,
            "comment": [],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/atom-environment.js",
            "name": "setMenuManager",
            "line": 139,
            "func_location": "AtomEnvironment.constructor",
            "func_start_line": 57,
            "func_end_line": 199,
            "args": [
                {
                    "name": ".menu",
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Properties\r\n  "
            ],
            "code": "  constructor (params = {}) {\r\n    this.id = (params.id != null) ? params.id : nextId++\r\n\r\n    // Public: A {Clipboard} instance\r\n    this.clipboard = params.clipboard\r\n    this.updateProcessEnv = params.updateProcessEnv || updateProcessEnv\r\n    this.enablePersistence = params.enablePersistence\r\n    this.applicationDelegate = params.applicationDelegate\r\n\r\n    this.nextProxyRequestId = 0\r\n    this.unloading = false\r\n    this.loadTime = null\r\n    this.emitter = new Emitter()\r\n    this.disposables = new CompositeDisposable()\r\n    this.pathsWithWaitSessions = new Set()\r\n\r\n    // Public: A {DeserializerManager} instance\r\n    this.deserializers = new DeserializerManager(this)\r\n    this.deserializeTimings = {}\r\n\r\n    // Public: A {ViewRegistry} instance\r\n    this.views = new ViewRegistry(this)\r\n\r\n    // Public: A {NotificationManager} instance\r\n    this.notifications = new NotificationManager()\r\n\r\n    this.stateStore = new StateStore('AtomEnvironments', 1)\r\n\r\n    // Public: A {Config} instance\r\n    this.config = new Config({\r\n      saveCallback: settings => {\r\n        if (this.enablePersistence) {\r\n          this.applicationDelegate.setUserSettings(settings, this.config.getUserConfigPath())\r\n        }\r\n      }\r\n    })\r\n    this.config.setSchema(null, {type: 'object', properties: _.clone(ConfigSchema)})\r\n\r\n    // Public: A {KeymapManager} instance\r\n    this.keymaps = new KeymapManager({notificationManager: this.notifications})\r\n\r\n    // Public: A {TooltipManager} instance\r\n    this.tooltips = new TooltipManager({keymapManager: this.keymaps, viewRegistry: this.views})\r\n\r\n    // Public: A {CommandRegistry} instance\r\n    this.commands = new CommandRegistry()\r\n    this.uriHandlerRegistry = new URIHandlerRegistry()\r\n\r\n    // Public: A {GrammarRegistry} instance\r\n    this.grammars = new GrammarRegistry({config: this.config})\r\n\r\n    // Public: A {StyleManager} instance\r\n    this.styles = new StyleManager()\r\n\r\n    // Public: A {PackageManager} instance\r\n    this.packages = new PackageManager({\r\n      config: this.config,\r\n      styleManager: this.styles,\r\n      commandRegistry: this.commands,\r\n      keymapManager: this.keymaps,\r\n      notificationManager: this.notifications,\r\n      grammarRegistry: this.grammars,\r\n      deserializerManager: this.deserializers,\r\n      viewRegistry: this.views,\r\n      uriHandlerRegistry: this.uriHandlerRegistry\r\n    })\r\n\r\n    // Public: A {ThemeManager} instance\r\n    this.themes = new ThemeManager({\r\n      packageManager: this.packages,\r\n      config: this.config,\r\n      styleManager: this.styles,\r\n      notificationManager: this.notifications,\r\n      viewRegistry: this.views\r\n    })\r\n\r\n    // Public: A {MenuManager} instance\r\n    this.menu = new MenuManager({keymapManager: this.keymaps, packageManager: this.packages})\r\n\r\n    // Public: A {ContextMenuManager} instance\r\n    this.contextMenu = new ContextMenuManager({keymapManager: this.keymaps})\r\n\r\n    this.packages.setMenuManager(this.menu)\r\n    this.packages.setContextMenuManager(this.contextMenu)\r\n    this.packages.setThemeManager(this.themes)\r\n\r\n    // Public: A {Project} instance\r\n    this.project = new Project({\r\n      notificationManager: this.notifications,\r\n      packageManager: this.packages,\r\n      grammarRegistry: this.grammars,\r\n      config: this.config,\r\n      applicationDelegate: this.applicationDelegate\r\n    })\r\n    this.commandInstaller = new CommandInstaller(this.applicationDelegate)\r\n    this.protocolHandlerInstaller = new ProtocolHandlerInstaller()\r\n\r\n    // Public: A {TextEditorRegistry} instance\r\n    this.textEditors = new TextEditorRegistry({\r\n      config: this.config,\r\n      grammarRegistry: this.grammars,\r\n      assert: this.assert.bind(this),\r\n      packageManager: this.packages\r\n    })\r\n\r\n    // Public: A {Workspace} instance\r\n    this.workspace = new Workspace({\r\n      config: this.config,\r\n      project: this.project,\r\n      packageManager: this.packages,\r\n      grammarRegistry: this.grammars,\r\n      deserializerManager: this.deserializers,\r\n      notificationManager: this.notifications,\r\n      applicationDelegate: this.applicationDelegate,\r\n      viewRegistry: this.views,\r\n      assert: this.assert.bind(this),\r\n      textEditorRegistry: this.textEditors,\r\n      styleManager: this.styles,\r\n      enablePersistence: this.enablePersistence\r\n    })\r\n\r\n    this.themes.workspace = this.workspace\r\n\r\n    this.autoUpdater = new AutoUpdateManager({applicationDelegate: this.applicationDelegate})\r\n\r\n    if (this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.registerDefaultCommands()\r\n    this.registerDefaultOpeners()\r\n    this.registerDefaultDeserializers()\r\n\r\n    this.windowEventHandler = new WindowEventHandler({atomEnvironment: this, applicationDelegate: this.applicationDelegate})\r\n\r\n    // Public: A {HistoryManager} instance\r\n    this.history = new HistoryManager({project: this.project, commands: this.commands, stateStore: this.stateStore})\r\n\r\n    // Keep instances of HistoryManager in sync\r\n    this.disposables.add(this.history.onDidChangeProjects(event => {\r\n      if (!event.reloaded) this.applicationDelegate.didChangeHistoryManager()\r\n    }))\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/package-manager.js",
            "name": "PackageManager.setMenuManager",
            "start_line": 76,
            "end_line": 78,
            "comment": [],
            "params": [
                "menuManager"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/atom-environment.js",
            "name": "setContextMenuManager",
            "line": 140,
            "func_location": "AtomEnvironment.constructor",
            "func_start_line": 57,
            "func_end_line": 199,
            "args": [
                {
                    "name": ".contextMenu",
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Properties\r\n  "
            ],
            "code": "  constructor (params = {}) {\r\n    this.id = (params.id != null) ? params.id : nextId++\r\n\r\n    // Public: A {Clipboard} instance\r\n    this.clipboard = params.clipboard\r\n    this.updateProcessEnv = params.updateProcessEnv || updateProcessEnv\r\n    this.enablePersistence = params.enablePersistence\r\n    this.applicationDelegate = params.applicationDelegate\r\n\r\n    this.nextProxyRequestId = 0\r\n    this.unloading = false\r\n    this.loadTime = null\r\n    this.emitter = new Emitter()\r\n    this.disposables = new CompositeDisposable()\r\n    this.pathsWithWaitSessions = new Set()\r\n\r\n    // Public: A {DeserializerManager} instance\r\n    this.deserializers = new DeserializerManager(this)\r\n    this.deserializeTimings = {}\r\n\r\n    // Public: A {ViewRegistry} instance\r\n    this.views = new ViewRegistry(this)\r\n\r\n    // Public: A {NotificationManager} instance\r\n    this.notifications = new NotificationManager()\r\n\r\n    this.stateStore = new StateStore('AtomEnvironments', 1)\r\n\r\n    // Public: A {Config} instance\r\n    this.config = new Config({\r\n      saveCallback: settings => {\r\n        if (this.enablePersistence) {\r\n          this.applicationDelegate.setUserSettings(settings, this.config.getUserConfigPath())\r\n        }\r\n      }\r\n    })\r\n    this.config.setSchema(null, {type: 'object', properties: _.clone(ConfigSchema)})\r\n\r\n    // Public: A {KeymapManager} instance\r\n    this.keymaps = new KeymapManager({notificationManager: this.notifications})\r\n\r\n    // Public: A {TooltipManager} instance\r\n    this.tooltips = new TooltipManager({keymapManager: this.keymaps, viewRegistry: this.views})\r\n\r\n    // Public: A {CommandRegistry} instance\r\n    this.commands = new CommandRegistry()\r\n    this.uriHandlerRegistry = new URIHandlerRegistry()\r\n\r\n    // Public: A {GrammarRegistry} instance\r\n    this.grammars = new GrammarRegistry({config: this.config})\r\n\r\n    // Public: A {StyleManager} instance\r\n    this.styles = new StyleManager()\r\n\r\n    // Public: A {PackageManager} instance\r\n    this.packages = new PackageManager({\r\n      config: this.config,\r\n      styleManager: this.styles,\r\n      commandRegistry: this.commands,\r\n      keymapManager: this.keymaps,\r\n      notificationManager: this.notifications,\r\n      grammarRegistry: this.grammars,\r\n      deserializerManager: this.deserializers,\r\n      viewRegistry: this.views,\r\n      uriHandlerRegistry: this.uriHandlerRegistry\r\n    })\r\n\r\n    // Public: A {ThemeManager} instance\r\n    this.themes = new ThemeManager({\r\n      packageManager: this.packages,\r\n      config: this.config,\r\n      styleManager: this.styles,\r\n      notificationManager: this.notifications,\r\n      viewRegistry: this.views\r\n    })\r\n\r\n    // Public: A {MenuManager} instance\r\n    this.menu = new MenuManager({keymapManager: this.keymaps, packageManager: this.packages})\r\n\r\n    // Public: A {ContextMenuManager} instance\r\n    this.contextMenu = new ContextMenuManager({keymapManager: this.keymaps})\r\n\r\n    this.packages.setMenuManager(this.menu)\r\n    this.packages.setContextMenuManager(this.contextMenu)\r\n    this.packages.setThemeManager(this.themes)\r\n\r\n    // Public: A {Project} instance\r\n    this.project = new Project({\r\n      notificationManager: this.notifications,\r\n      packageManager: this.packages,\r\n      grammarRegistry: this.grammars,\r\n      config: this.config,\r\n      applicationDelegate: this.applicationDelegate\r\n    })\r\n    this.commandInstaller = new CommandInstaller(this.applicationDelegate)\r\n    this.protocolHandlerInstaller = new ProtocolHandlerInstaller()\r\n\r\n    // Public: A {TextEditorRegistry} instance\r\n    this.textEditors = new TextEditorRegistry({\r\n      config: this.config,\r\n      grammarRegistry: this.grammars,\r\n      assert: this.assert.bind(this),\r\n      packageManager: this.packages\r\n    })\r\n\r\n    // Public: A {Workspace} instance\r\n    this.workspace = new Workspace({\r\n      config: this.config,\r\n      project: this.project,\r\n      packageManager: this.packages,\r\n      grammarRegistry: this.grammars,\r\n      deserializerManager: this.deserializers,\r\n      notificationManager: this.notifications,\r\n      applicationDelegate: this.applicationDelegate,\r\n      viewRegistry: this.views,\r\n      assert: this.assert.bind(this),\r\n      textEditorRegistry: this.textEditors,\r\n      styleManager: this.styles,\r\n      enablePersistence: this.enablePersistence\r\n    })\r\n\r\n    this.themes.workspace = this.workspace\r\n\r\n    this.autoUpdater = new AutoUpdateManager({applicationDelegate: this.applicationDelegate})\r\n\r\n    if (this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.registerDefaultCommands()\r\n    this.registerDefaultOpeners()\r\n    this.registerDefaultDeserializers()\r\n\r\n    this.windowEventHandler = new WindowEventHandler({atomEnvironment: this, applicationDelegate: this.applicationDelegate})\r\n\r\n    // Public: A {HistoryManager} instance\r\n    this.history = new HistoryManager({project: this.project, commands: this.commands, stateStore: this.stateStore})\r\n\r\n    // Keep instances of HistoryManager in sync\r\n    this.disposables.add(this.history.onDidChangeProjects(event => {\r\n      if (!event.reloaded) this.applicationDelegate.didChangeHistoryManager()\r\n    }))\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/package-manager.js",
            "name": "PackageManager.setContextMenuManager",
            "start_line": 72,
            "end_line": 74,
            "comment": [],
            "params": [
                "contextMenuManager"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/atom-environment.js",
            "name": "setThemeManager",
            "line": 141,
            "func_location": "AtomEnvironment.constructor",
            "func_start_line": 57,
            "func_end_line": 199,
            "args": [
                {
                    "name": ".themes",
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Properties\r\n  "
            ],
            "code": "  constructor (params = {}) {\r\n    this.id = (params.id != null) ? params.id : nextId++\r\n\r\n    // Public: A {Clipboard} instance\r\n    this.clipboard = params.clipboard\r\n    this.updateProcessEnv = params.updateProcessEnv || updateProcessEnv\r\n    this.enablePersistence = params.enablePersistence\r\n    this.applicationDelegate = params.applicationDelegate\r\n\r\n    this.nextProxyRequestId = 0\r\n    this.unloading = false\r\n    this.loadTime = null\r\n    this.emitter = new Emitter()\r\n    this.disposables = new CompositeDisposable()\r\n    this.pathsWithWaitSessions = new Set()\r\n\r\n    // Public: A {DeserializerManager} instance\r\n    this.deserializers = new DeserializerManager(this)\r\n    this.deserializeTimings = {}\r\n\r\n    // Public: A {ViewRegistry} instance\r\n    this.views = new ViewRegistry(this)\r\n\r\n    // Public: A {NotificationManager} instance\r\n    this.notifications = new NotificationManager()\r\n\r\n    this.stateStore = new StateStore('AtomEnvironments', 1)\r\n\r\n    // Public: A {Config} instance\r\n    this.config = new Config({\r\n      saveCallback: settings => {\r\n        if (this.enablePersistence) {\r\n          this.applicationDelegate.setUserSettings(settings, this.config.getUserConfigPath())\r\n        }\r\n      }\r\n    })\r\n    this.config.setSchema(null, {type: 'object', properties: _.clone(ConfigSchema)})\r\n\r\n    // Public: A {KeymapManager} instance\r\n    this.keymaps = new KeymapManager({notificationManager: this.notifications})\r\n\r\n    // Public: A {TooltipManager} instance\r\n    this.tooltips = new TooltipManager({keymapManager: this.keymaps, viewRegistry: this.views})\r\n\r\n    // Public: A {CommandRegistry} instance\r\n    this.commands = new CommandRegistry()\r\n    this.uriHandlerRegistry = new URIHandlerRegistry()\r\n\r\n    // Public: A {GrammarRegistry} instance\r\n    this.grammars = new GrammarRegistry({config: this.config})\r\n\r\n    // Public: A {StyleManager} instance\r\n    this.styles = new StyleManager()\r\n\r\n    // Public: A {PackageManager} instance\r\n    this.packages = new PackageManager({\r\n      config: this.config,\r\n      styleManager: this.styles,\r\n      commandRegistry: this.commands,\r\n      keymapManager: this.keymaps,\r\n      notificationManager: this.notifications,\r\n      grammarRegistry: this.grammars,\r\n      deserializerManager: this.deserializers,\r\n      viewRegistry: this.views,\r\n      uriHandlerRegistry: this.uriHandlerRegistry\r\n    })\r\n\r\n    // Public: A {ThemeManager} instance\r\n    this.themes = new ThemeManager({\r\n      packageManager: this.packages,\r\n      config: this.config,\r\n      styleManager: this.styles,\r\n      notificationManager: this.notifications,\r\n      viewRegistry: this.views\r\n    })\r\n\r\n    // Public: A {MenuManager} instance\r\n    this.menu = new MenuManager({keymapManager: this.keymaps, packageManager: this.packages})\r\n\r\n    // Public: A {ContextMenuManager} instance\r\n    this.contextMenu = new ContextMenuManager({keymapManager: this.keymaps})\r\n\r\n    this.packages.setMenuManager(this.menu)\r\n    this.packages.setContextMenuManager(this.contextMenu)\r\n    this.packages.setThemeManager(this.themes)\r\n\r\n    // Public: A {Project} instance\r\n    this.project = new Project({\r\n      notificationManager: this.notifications,\r\n      packageManager: this.packages,\r\n      grammarRegistry: this.grammars,\r\n      config: this.config,\r\n      applicationDelegate: this.applicationDelegate\r\n    })\r\n    this.commandInstaller = new CommandInstaller(this.applicationDelegate)\r\n    this.protocolHandlerInstaller = new ProtocolHandlerInstaller()\r\n\r\n    // Public: A {TextEditorRegistry} instance\r\n    this.textEditors = new TextEditorRegistry({\r\n      config: this.config,\r\n      grammarRegistry: this.grammars,\r\n      assert: this.assert.bind(this),\r\n      packageManager: this.packages\r\n    })\r\n\r\n    // Public: A {Workspace} instance\r\n    this.workspace = new Workspace({\r\n      config: this.config,\r\n      project: this.project,\r\n      packageManager: this.packages,\r\n      grammarRegistry: this.grammars,\r\n      deserializerManager: this.deserializers,\r\n      notificationManager: this.notifications,\r\n      applicationDelegate: this.applicationDelegate,\r\n      viewRegistry: this.views,\r\n      assert: this.assert.bind(this),\r\n      textEditorRegistry: this.textEditors,\r\n      styleManager: this.styles,\r\n      enablePersistence: this.enablePersistence\r\n    })\r\n\r\n    this.themes.workspace = this.workspace\r\n\r\n    this.autoUpdater = new AutoUpdateManager({applicationDelegate: this.applicationDelegate})\r\n\r\n    if (this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.registerDefaultCommands()\r\n    this.registerDefaultOpeners()\r\n    this.registerDefaultDeserializers()\r\n\r\n    this.windowEventHandler = new WindowEventHandler({atomEnvironment: this, applicationDelegate: this.applicationDelegate})\r\n\r\n    // Public: A {HistoryManager} instance\r\n    this.history = new HistoryManager({project: this.project, commands: this.commands, stateStore: this.stateStore})\r\n\r\n    // Keep instances of HistoryManager in sync\r\n    this.disposables.add(this.history.onDidChangeProjects(event => {\r\n      if (!event.reloaded) this.applicationDelegate.didChangeHistoryManager()\r\n    }))\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/package-manager.js",
            "name": "PackageManager.setThemeManager",
            "start_line": 80,
            "end_line": 82,
            "comment": [],
            "params": [
                "themeManager"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "decorateMarker",
            "line": 20,
            "func_location": "Selection.constructor",
            "func_start_line": 11,
            "func_end_line": 23,
            "args": [
                ".marker",
                null
            ],
            "code": "  constructor ({cursor, marker, editor, id}) {\r\n    this.id = (id != null) ? id : nextId++\r\n    this.cursor = cursor\r\n    this.marker = marker\r\n    this.editor = editor\r\n    this.emitter = new Emitter()\r\n    this.initialScreenRange = null\r\n    this.wordwise = false\r\n    this.cursor.selection = this\r\n    this.decoration = this.editor.decorateMarker(this.marker, {type: 'highlight', class: 'selection'})\r\n    this.marker.onDidChange(e => this.markerDidChange(e))\r\n    this.marker.onDidDestroy(() => this.markerDidDestroy())\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/gutter.js",
            "name": "Gutter.decorateMarker",
            "start_line": 105,
            "end_line": 107,
            "comment": [
                " Essential: Add a decoration that tracks a {DisplayMarker}. When the marker moves,",
                " is invalidated, or is destroyed, the decoration will be updated to reflect",
                " the marker's state.",
                "",
                " ## Arguments",
                "",
                " * `marker` A {DisplayMarker} you want this decoration to follow.",
                " * `decorationParams` An {Object} representing the decoration. It is passed",
                "   to {TextEditor::decorateMarker} as its `decorationParams` and so supports",
                "   all options documented there.",
                "   * `type` __Caveat__: set to `'line-number'` if this is the line-number",
                "     gutter, `'gutter'` otherwise. This cannot be overridden.",
                "",
                " Returns a {Decoration} object"
            ],
            "params": [
                {
                    "name": "marker",
                    "type": []
                },
                {
                    "name": "options",
                    "type": []
                }
            ],
            "return_type": [
                "object"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "initialize",
            "line": 405,
            "func_location": "Config.constructor",
            "func_start_line": 403,
            "func_end_line": 406,
            "args": [
                {
                    "name": "params",
                    "type": []
                }
            ],
            "comment": [
                " Created during initialization, available as `atom.config`"
            ],
            "code": "  constructor (params = {}) {\r\n    this.clear()\r\n    this.initialize(params)\r\n  }\r",
            "return_type": [
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.initialize",
            "start_line": 408,
            "end_line": 417,
            "comment": [],
            "params": [
                [
                    "saveCallback",
                    "mainSource",
                    "projectHomeSchema"
                ]
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/context-menu.js",
            "name": "createClickHandlers",
            "line": 7,
            "func_location": "ContextMenu.constructor",
            "func_start_line": 5,
            "func_end_line": 10,
            "args": [
                "template"
            ],
            "code": "  constructor (template, atomWindow) {\r\n    this.atomWindow = atomWindow\r\n    this.createClickHandlers(template)\r\n    const menu = Menu.buildFromTemplate(template)\r\n    menu.popup(this.atomWindow.browserWindow, {async: true})\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/context-menu.js",
            "name": "ContextMenu.createClickHandlers",
            "start_line": 15,
            "end_line": 32,
            "comment": [
                " It's necessary to build the event handlers in this process, otherwise",
                " closures are dragged across processes and failed to be garbage collected",
                " appropriately."
            ],
            "params": [
                {
                    "name": "template",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "didKeydown",
            "line": 79,
            "func_location": "TextEditorComponent.constructor",
            "func_start_line": 55,
            "func_end_line": 182,
            "args": [
                null
            ],
            "code": "  constructor (props) {\r\n    this.props = props\r\n\r\n    if (!props.model) {\r\n      props.model = new TextEditor({mini: props.mini, readOnly: props.readOnly})\r\n    }\r\n    this.props.model.component = this\r\n\r\n    if (props.element) {\r\n      this.element = props.element\r\n    } else {\r\n      if (!TextEditorElement) TextEditorElement = require('./text-editor-element')\r\n      this.element = new TextEditorElement()\r\n    }\r\n    this.element.initialize(this)\r\n    this.virtualNode = $('atom-text-editor')\r\n    this.virtualNode.domNode = this.element\r\n    this.refs = {}\r\n\r\n    this.updateSync = this.updateSync.bind(this)\r\n    this.didBlurHiddenInput = this.didBlurHiddenInput.bind(this)\r\n    this.didFocusHiddenInput = this.didFocusHiddenInput.bind(this)\r\n    this.didPaste = this.didPaste.bind(this)\r\n    this.didTextInput = this.didTextInput.bind(this)\r\n    this.didKeydown = this.didKeydown.bind(this)\r\n    this.didKeyup = this.didKeyup.bind(this)\r\n    this.didKeypress = this.didKeypress.bind(this)\r\n    this.didCompositionStart = this.didCompositionStart.bind(this)\r\n    this.didCompositionUpdate = this.didCompositionUpdate.bind(this)\r\n    this.didCompositionEnd = this.didCompositionEnd.bind(this)\r\n\r\n    this.updatedSynchronously = this.props.updatedSynchronously\r\n    this.didScrollDummyScrollbar = this.didScrollDummyScrollbar.bind(this)\r\n    this.didMouseDownOnContent = this.didMouseDownOnContent.bind(this)\r\n    this.debouncedResumeCursorBlinking = debounce(\r\n      this.resumeCursorBlinking.bind(this),\r\n      (this.props.cursorBlinkResumeDelay || CURSOR_BLINK_RESUME_DELAY)\r\n    )\r\n    this.lineTopIndex = new LineTopIndex()\r\n    this.lineNodesPool = new NodePool()\r\n    this.updateScheduled = false\r\n    this.suppressUpdates = false\r\n    this.hasInitialMeasurements = false\r\n    this.measurements = {\r\n      lineHeight: 0,\r\n      baseCharacterWidth: 0,\r\n      doubleWidthCharacterWidth: 0,\r\n      halfWidthCharacterWidth: 0,\r\n      koreanCharacterWidth: 0,\r\n      gutterContainerWidth: 0,\r\n      lineNumberGutterWidth: 0,\r\n      clientContainerHeight: 0,\r\n      clientContainerWidth: 0,\r\n      verticalScrollbarWidth: 0,\r\n      horizontalScrollbarHeight: 0,\r\n      longestLineWidth: 0\r\n    }\r\n    this.derivedDimensionsCache = {}\r\n    this.visible = false\r\n    this.cursorsBlinking = false\r\n    this.cursorsBlinkedOff = false\r\n    this.nextUpdateOnlyBlinksCursors = null\r\n    this.linesToMeasure = new Map()\r\n    this.extraRenderedScreenLines = new Map()\r\n    this.horizontalPositionsToMeasure = new Map() // Keys are rows with positions we want to measure, values are arrays of columns to measure\r\n    this.horizontalPixelPositionsByScreenLineId = new Map() // Values are maps from column to horizontal pixel positions\r\n    this.blockDecorationsToMeasure = new Set()\r\n    this.blockDecorationsByElement = new WeakMap()\r\n    this.blockDecorationSentinel = document.createElement('div')\r\n    this.blockDecorationSentinel.style.height = '1px'\r\n    this.heightsByBlockDecoration = new WeakMap()\r\n    this.blockDecorationResizeObserver = new ResizeObserver(this.didResizeBlockDecorations.bind(this))\r\n    this.lineComponentsByScreenLineId = new Map()\r\n    this.overlayComponents = new Set()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.remeasureScrollbars = false\r\n    this.pendingAutoscroll = null\r\n    this.scrollTopPending = false\r\n    this.scrollLeftPending = false\r\n    this.scrollTop = 0\r\n    this.scrollLeft = 0\r\n    this.previousScrollWidth = 0\r\n    this.previousScrollHeight = 0\r\n    this.lastKeydown = null\r\n    this.lastKeydownBeforeKeypress = null\r\n    this.accentedCharacterMenuIsOpen = false\r\n    this.remeasureGutterDimensions = false\r\n    this.guttersToRender = [this.props.model.getLineNumberGutter()]\r\n    this.guttersVisibility = [this.guttersToRender[0].visible]\r\n    this.idsByTileStartRow = new Map()\r\n    this.nextTileId = 0\r\n    this.renderedTileStartRows = []\r\n    this.showLineNumbers = this.props.model.doesShowLineNumbers()\r\n    this.lineNumbersToRender = {\r\n      maxDigits: 2,\r\n      bufferRows: [],\r\n      screenRows: [],\r\n      keys: [],\r\n      softWrappedFlags: [],\r\n      foldableFlags: []\r\n    }\r\n    this.decorationsToRender = {\r\n      lineNumbers: new Map(),\r\n      lines: null,\r\n      highlights: [],\r\n      cursors: [],\r\n      overlays: [],\r\n      customGutter: new Map(),\r\n      blocks: new Map(),\r\n      text: []\r\n    }\r\n    this.decorationsToMeasure = {\r\n      highlights: [],\r\n      cursors: new Map()\r\n    }\r\n    this.textDecorationsByMarker = new Map()\r\n    this.textDecorationBoundaries = []\r\n    this.pendingScrollTopRow = this.props.initialScrollTopRow\r\n    this.pendingScrollLeftColumn = this.props.initialScrollLeftColumn\r\n    this.tabIndex = this.props.element && this.props.element.tabIndex ? this.props.element.tabIndex : -1\r\n\r\n    this.measuredContent = false\r\n    this.queryGuttersToRender()\r\n    this.queryMaxLineNumberDigits()\r\n    this.observeBlockDecorations()\r\n    this.updateClassList()\r\n    etch.updateSync(this)\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "TextEditorComponent.didKeydown",
            "start_line": 1672,
            "end_line": 1690,
            "comment": [
                " We need to get clever to detect when the accented character menu is",
                " opened on macOS. Usually, every keydown event that could cause input is",
                " followed by a corresponding keypress. However, pressing and holding",
                " long enough to open the accented character menu causes additional keydown",
                " events to fire that aren't followed by their own keypress and textInput",
                " events.",
                "",
                " Therefore, we assume the accented character menu has been deployed if,",
                " before observing any keyup event, we observe events in the following",
                " sequence:",
                "",
                " keydown(code: X), keypress, keydown(code: X)",
                "",
                " The code X must be the same in the keydown events that bracket the",
                " keypress, meaning we're *holding* the _same_ key we intially pressed.",
                " Got that?"
            ],
            "params": [
                {
                    "name": "event",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/title-bar.js",
            "name": "onDidChangeActiveThemes",
            "line": 18,
            "func_location": "TitleBar.constructor",
            "func_start_line": 3,
            "func_end_line": 22,
            "args": [
                null
            ],
            "code": "  constructor ({workspace, themes, applicationDelegate}) {\r\n    this.dblclickHandler = this.dblclickHandler.bind(this)\r\n    this.workspace = workspace\r\n    this.themes = themes\r\n    this.applicationDelegate = applicationDelegate\r\n    this.element = document.createElement('div')\r\n    this.element.classList.add('title-bar')\r\n\r\n    this.titleElement = document.createElement('div')\r\n    this.titleElement.classList.add('title')\r\n    this.element.appendChild(this.titleElement)\r\n\r\n    this.element.addEventListener('dblclick', this.dblclickHandler)\r\n\r\n    this.workspace.onDidChangeWindowTitle(() => this.updateTitle())\r\n    this.themes.onDidChangeActiveThemes(() => this.updateWindowSheetOffset())\r\n\r\n    this.updateTitle()\r\n    this.updateWindowSheetOffset()\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/theme-manager.js",
            "name": "ThemeManager.onDidChangeActiveThemes",
            "start_line": 55,
            "end_line": 57,
            "comment": [
                "\r\n  Section: Event Subscription\r\n  ",
                " Essential: Invoke `callback` when style sheet changes associated with",
                " updating the list of active themes have completed.",
                "",
                " * `callback` {Function}",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "consumeServices",
            "line": 41,
            "func_location": "Project.constructor",
            "func_start_line": 22,
            "func_end_line": 42,
            "args": [
                {
                    "name": "packageManager",
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Construction and Destruction\r\n  "
            ],
            "code": "  constructor ({notificationManager, packageManager, config, applicationDelegate, grammarRegistry}) {\r\n    super()\r\n    this.notificationManager = notificationManager\r\n    this.applicationDelegate = applicationDelegate\r\n    this.grammarRegistry = grammarRegistry\r\n\r\n    this.emitter = new Emitter()\r\n    this.buffers = []\r\n    this.rootDirectories = []\r\n    this.repositories = []\r\n    this.directoryProviders = []\r\n    this.defaultDirectoryProvider = new DefaultDirectoryProvider()\r\n    this.repositoryPromisesByPath = new Map()\r\n    this.repositoryProviders = [new GitRepositoryProvider(this, config)]\r\n    this.loadPromisesByPath = {}\r\n    this.watcherPromisesByPath = {}\r\n    this.retiredBufferIDs = new Set()\r\n    this.retiredBufferPaths = new Set()\r\n    this.subscriptions = new CompositeDisposable()\r\n    this.consumeServices(packageManager)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/workspace.js",
            "name": "Workspace.consumeServices",
            "start_line": 328,
            "end_line": 335,
            "comment": [],
            "params": [
                [
                    "serviceHub"
                ]
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js",
            "name": "onUpdateError",
            "line": 19,
            "func_location": "AutoUpdateManager.constructor",
            "func_start_line": 16,
            "func_end_line": 25,
            "args": [
                null
            ],
            "code": "  constructor (version, testMode, config) {\r\n    super()\r\n    this.onUpdateNotAvailable = this.onUpdateNotAvailable.bind(this)\r\n    this.onUpdateError = this.onUpdateError.bind(this)\r\n    this.version = version\r\n    this.testMode = testMode\r\n    this.config = config\r\n    this.state = IdleState\r\n    this.iconPath = path.resolve(__dirname, '..', '..', 'resources', 'atom.png')\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/auto-update-manager.js",
            "name": "AutoUpdateManager.onUpdateError",
            "start_line": 162,
            "end_line": 173,
            "comment": [
                " noop callback to get async behavior"
            ],
            "params": [
                {
                    "name": "event",
                    "type": []
                },
                {
                    "name": "message",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "copy",
            "line": 971,
            "func_location": "TextEditor.copy",
            "func_start_line": 969,
            "func_end_line": 988,
            "args": [
                {
                    "name": ".id",
                    "type": []
                }
            ],
            "comment": [
                " Create an {TextEditor} with its initial state based on this object"
            ],
            "code": "  copy () {\r\n    const displayLayer = this.displayLayer.copy()\r\n    const selectionsMarkerLayer = displayLayer.getMarkerLayer(this.buffer.getMarkerLayer(this.selectionsMarkerLayer.id).copy().id)\r\n    const softTabs = this.getSoftTabs()\r\n    return new TextEditor({\r\n      buffer: this.buffer,\r\n      selectionsMarkerLayer,\r\n      softTabs,\r\n      suppressCursorCreation: true,\r\n      tabLength: this.getTabLength(),\r\n      initialScrollTopRow: this.getScrollTopRow(),\r\n      initialScrollLeftColumn: this.getScrollLeftColumn(),\r\n      assert: this.assert,\r\n      displayLayer,\r\n      grammar: this.getGrammar(),\r\n      autoWidth: this.autoWidth,\r\n      autoHeight: this.autoHeight,\r\n      showCursorOnSelection: this.showCursorOnSelection\r\n    })\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.copy",
            "start_line": 969,
            "end_line": 988,
            "comment": [
                " Create an {TextEditor} with its initial state based on this object"
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/gutter.js",
            "name": "addGutterDecoration",
            "line": 106,
            "func_location": "Gutter.decorateMarker",
            "func_start_line": 105,
            "func_end_line": 107,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": "marker",
                    "type": []
                },
                {
                    "name": "options",
                    "type": []
                }
            ],
            "comment": [
                " Essential: Add a decoration that tracks a {DisplayMarker}. When the marker moves,",
                " is invalidated, or is destroyed, the decoration will be updated to reflect",
                " the marker's state.",
                "",
                " ## Arguments",
                "",
                " * `marker` A {DisplayMarker} you want this decoration to follow.",
                " * `decorationParams` An {Object} representing the decoration. It is passed",
                "   to {TextEditor::decorateMarker} as its `decorationParams` and so supports",
                "   all options documented there.",
                "   * `type` __Caveat__: set to `'line-number'` if this is the line-number",
                "     gutter, `'gutter'` otherwise. This cannot be overridden.",
                "",
                " Returns a {Decoration} object"
            ],
            "code": "  decorateMarker (marker, options) {\r\n    return this.gutterContainer.addGutterDecoration(this, marker, options)\r\n  }\r",
            "return_type": [
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/gutter-container.js",
            "name": "GutterContainer.addGutterDecoration",
            "start_line": 99,
            "end_line": 107,
            "comment": [
                " The public interface is Gutter::decorateMarker or TextEditor::decorateMarker."
            ],
            "params": [
                {
                    "name": "gutter",
                    "type": []
                },
                {
                    "name": "marker",
                    "type": []
                },
                {
                    "name": "options",
                    "type": []
                }
            ],
            "return_type": [
                "object"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/gutter.js",
            "name": "addGutterDecoration",
            "line": 106,
            "func_location": "Gutter.decorateMarker",
            "func_start_line": 105,
            "func_end_line": 107,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": "marker",
                    "type": []
                },
                {
                    "name": "options",
                    "type": []
                }
            ],
            "comment": [
                " Essential: Add a decoration that tracks a {DisplayMarker}. When the marker moves,",
                " is invalidated, or is destroyed, the decoration will be updated to reflect",
                " the marker's state.",
                "",
                " ## Arguments",
                "",
                " * `marker` A {DisplayMarker} you want this decoration to follow.",
                " * `decorationParams` An {Object} representing the decoration. It is passed",
                "   to {TextEditor::decorateMarker} as its `decorationParams` and so supports",
                "   all options documented there.",
                "   * `type` __Caveat__: set to `'line-number'` if this is the line-number",
                "     gutter, `'gutter'` otherwise. This cannot be overridden.",
                "",
                " Returns a {Decoration} object"
            ],
            "code": "  decorateMarker (marker, options) {\r\n    return this.gutterContainer.addGutterDecoration(this, marker, options)\r\n  }\r",
            "return_type": [
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/gutter-container.js",
            "name": "GutterContainer.addGutterDecoration",
            "start_line": 99,
            "end_line": 107,
            "comment": [
                " The public interface is Gutter::decorateMarker or TextEditor::decorateMarker."
            ],
            "params": [
                {
                    "name": "gutter",
                    "type": []
                },
                {
                    "name": "marker",
                    "type": []
                },
                {
                    "name": "options",
                    "type": []
                }
            ],
            "return_type": [
                "object"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "ensureWritable",
            "line": 567,
            "func_location": "Selection.deleteToBeginningOfLine",
            "func_start_line": 566,
            "func_end_line": 574,
            "args": [
                {
                    "name": {
                        "type": "string"
                    },
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Removes from the beginning of the line which the selection begins on",
                " all the way through to the end of the selection.",
                "",
                " * `options` (optional) {Object}",
                "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"
            ],
            "code": "  deleteToBeginningOfLine (options = {}) {\r\n    if (!this.ensureWritable('deleteToBeginningOfLine', options)) return\r\n    if (this.isEmpty() && this.cursor.isAtBeginningOfLine()) {\r\n      this.selectLeft()\r\n    } else {\r\n      this.selectToBeginningOfLine()\r\n    }\r\n    this.deleteSelectedText(options)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.ensureWritable",
            "start_line": 412,
            "end_line": 427,
            "comment": [
                " Private: Ensure that the {TextEditor} is not marked read-only before allowing a buffer modification to occur. if",
                " the editor is read-only, require an explicit opt-in option to proceed (`bypassReadOnly`) or throw an Error."
            ],
            "params": [
                {
                    "name": "methodName",
                    "type": []
                },
                {
                    "name": "opts",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "ensureWritable",
            "line": 567,
            "func_location": "Selection.deleteToBeginningOfLine",
            "func_start_line": 566,
            "func_end_line": 574,
            "args": [
                {
                    "name": {
                        "type": "string"
                    },
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Removes from the beginning of the line which the selection begins on",
                " all the way through to the end of the selection.",
                "",
                " * `options` (optional) {Object}",
                "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"
            ],
            "code": "  deleteToBeginningOfLine (options = {}) {\r\n    if (!this.ensureWritable('deleteToBeginningOfLine', options)) return\r\n    if (this.isEmpty() && this.cursor.isAtBeginningOfLine()) {\r\n      this.selectLeft()\r\n    } else {\r\n      this.selectToBeginningOfLine()\r\n    }\r\n    this.deleteSelectedText(options)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.ensureWritable",
            "start_line": 412,
            "end_line": 427,
            "comment": [
                " Private: Ensure that the {TextEditor} is not marked read-only before allowing a buffer modification to occur. if",
                " the editor is read-only, require an explicit opt-in option to proceed (`bypassReadOnly`) or throw an Error."
            ],
            "params": [
                {
                    "name": "methodName",
                    "type": []
                },
                {
                    "name": "opts",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "selectLeft",
            "line": 569,
            "func_location": "Selection.deleteToBeginningOfLine",
            "func_start_line": 566,
            "func_end_line": 574,
            "args": [],
            "comment": [
                " Public: Removes from the beginning of the line which the selection begins on",
                " all the way through to the end of the selection.",
                "",
                " * `options` (optional) {Object}",
                "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"
            ],
            "code": "  deleteToBeginningOfLine (options = {}) {\r\n    if (!this.ensureWritable('deleteToBeginningOfLine', options)) return\r\n    if (this.isEmpty() && this.cursor.isAtBeginningOfLine()) {\r\n      this.selectLeft()\r\n    } else {\r\n      this.selectToBeginningOfLine()\r\n    }\r\n    this.deleteSelectedText(options)\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.selectLeft",
            "start_line": 251,
            "end_line": 253,
            "comment": [
                " Public: Selects the text one position left of the cursor.",
                "",
                " * `columnCount` (optional) {Number} number of columns to select (default: 1)"
            ],
            "params": [
                {
                    "name": "columnCount",
                    "type": [
                        "number",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "ensureWritable",
            "line": 556,
            "func_location": "Selection.deleteToBeginningOfWord",
            "func_start_line": 555,
            "func_end_line": 559,
            "args": [
                {
                    "name": {
                        "type": "string"
                    },
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Removes from the start of the selection to the beginning of the",
                " current word if the selection is empty otherwise it deletes the selection.",
                "",
                " * `options` (optional) {Object}",
                "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"
            ],
            "code": "  deleteToBeginningOfWord (options = {}) {\r\n    if (!this.ensureWritable('deleteToBeginningOfWord', options)) return\r\n    if (this.isEmpty()) this.selectToBeginningOfWord()\r\n    this.deleteSelectedText(options)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.ensureWritable",
            "start_line": 412,
            "end_line": 427,
            "comment": [
                " Private: Ensure that the {TextEditor} is not marked read-only before allowing a buffer modification to occur. if",
                " the editor is read-only, require an explicit opt-in option to proceed (`bypassReadOnly`) or throw an Error."
            ],
            "params": [
                {
                    "name": "methodName",
                    "type": []
                },
                {
                    "name": "opts",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "ensureWritable",
            "line": 556,
            "func_location": "Selection.deleteToBeginningOfWord",
            "func_start_line": 555,
            "func_end_line": 559,
            "args": [
                {
                    "name": {
                        "type": "string"
                    },
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Removes from the start of the selection to the beginning of the",
                " current word if the selection is empty otherwise it deletes the selection.",
                "",
                " * `options` (optional) {Object}",
                "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"
            ],
            "code": "  deleteToBeginningOfWord (options = {}) {\r\n    if (!this.ensureWritable('deleteToBeginningOfWord', options)) return\r\n    if (this.isEmpty()) this.selectToBeginningOfWord()\r\n    this.deleteSelectedText(options)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.ensureWritable",
            "start_line": 412,
            "end_line": 427,
            "comment": [
                " Private: Ensure that the {TextEditor} is not marked read-only before allowing a buffer modification to occur. if",
                " the editor is read-only, require an explicit opt-in option to proceed (`bypassReadOnly`) or throw an Error."
            ],
            "params": [
                {
                    "name": "methodName",
                    "type": []
                },
                {
                    "name": "opts",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "ensureWritable",
            "line": 545,
            "func_location": "Selection.deleteToNextWordBoundary",
            "func_start_line": 544,
            "func_end_line": 548,
            "args": [
                {
                    "name": {
                        "type": "string"
                    },
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Removes the selection or, if nothing is selected, then all",
                " characters from the start of the selection up to the next word",
                " boundary.",
                "",
                " * `options` (optional) {Object}",
                "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"
            ],
            "code": "  deleteToNextWordBoundary (options = {}) {\r\n    if (!this.ensureWritable('deleteToNextWordBoundary', options)) return\r\n    if (this.isEmpty()) this.selectToNextWordBoundary()\r\n    this.deleteSelectedText(options)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.ensureWritable",
            "start_line": 412,
            "end_line": 427,
            "comment": [
                " Private: Ensure that the {TextEditor} is not marked read-only before allowing a buffer modification to occur. if",
                " the editor is read-only, require an explicit opt-in option to proceed (`bypassReadOnly`) or throw an Error."
            ],
            "params": [
                {
                    "name": "methodName",
                    "type": []
                },
                {
                    "name": "opts",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "ensureWritable",
            "line": 545,
            "func_location": "Selection.deleteToNextWordBoundary",
            "func_start_line": 544,
            "func_end_line": 548,
            "args": [
                {
                    "name": {
                        "type": "string"
                    },
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Removes the selection or, if nothing is selected, then all",
                " characters from the start of the selection up to the next word",
                " boundary.",
                "",
                " * `options` (optional) {Object}",
                "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"
            ],
            "code": "  deleteToNextWordBoundary (options = {}) {\r\n    if (!this.ensureWritable('deleteToNextWordBoundary', options)) return\r\n    if (this.isEmpty()) this.selectToNextWordBoundary()\r\n    this.deleteSelectedText(options)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.ensureWritable",
            "start_line": 412,
            "end_line": 427,
            "comment": [
                " Private: Ensure that the {TextEditor} is not marked read-only before allowing a buffer modification to occur. if",
                " the editor is read-only, require an explicit opt-in option to proceed (`bypassReadOnly`) or throw an Error."
            ],
            "params": [
                {
                    "name": "methodName",
                    "type": []
                },
                {
                    "name": "opts",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "ensureWritable",
            "line": 533,
            "func_location": "Selection.deleteToPreviousWordBoundary",
            "func_start_line": 532,
            "func_end_line": 536,
            "args": [
                {
                    "name": {
                        "type": "string"
                    },
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Removes the selection or, if nothing is selected, then all",
                " characters from the start of the selection back to the previous word",
                " boundary.",
                "",
                " * `options` (optional) {Object}",
                "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"
            ],
            "code": "  deleteToPreviousWordBoundary (options = {}) {\r\n    if (!this.ensureWritable('deleteToPreviousWordBoundary', options)) return\r\n    if (this.isEmpty()) this.selectToPreviousWordBoundary()\r\n    this.deleteSelectedText(options)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.ensureWritable",
            "start_line": 412,
            "end_line": 427,
            "comment": [
                " Private: Ensure that the {TextEditor} is not marked read-only before allowing a buffer modification to occur. if",
                " the editor is read-only, require an explicit opt-in option to proceed (`bypassReadOnly`) or throw an Error."
            ],
            "params": [
                {
                    "name": "methodName",
                    "type": []
                },
                {
                    "name": "opts",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "ensureWritable",
            "line": 533,
            "func_location": "Selection.deleteToPreviousWordBoundary",
            "func_start_line": 532,
            "func_end_line": 536,
            "args": [
                {
                    "name": {
                        "type": "string"
                    },
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Removes the selection or, if nothing is selected, then all",
                " characters from the start of the selection back to the previous word",
                " boundary.",
                "",
                " * `options` (optional) {Object}",
                "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify text within a read-only editor. (default: false)"
            ],
            "code": "  deleteToPreviousWordBoundary (options = {}) {\r\n    if (!this.ensureWritable('deleteToPreviousWordBoundary', options)) return\r\n    if (this.isEmpty()) this.selectToPreviousWordBoundary()\r\n    this.deleteSelectedText(options)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.ensureWritable",
            "start_line": 412,
            "end_line": 427,
            "comment": [
                " Private: Ensure that the {TextEditor} is not marked read-only before allowing a buffer modification to occur. if",
                " the editor is read-only, require an explicit opt-in option to proceed (`bypassReadOnly`) or throw an Error."
            ],
            "params": [
                {
                    "name": "methodName",
                    "type": []
                },
                {
                    "name": "opts",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/deserializer-manager.js",
            "name": "warn",
            "line": 76,
            "func_location": "DeserializerManager.deserialize",
            "func_start_line": 59,
            "func_end_line": 78,
            "args": [
                {
                    "name": {
                        "type": "string"
                    },
                    "type": []
                },
                {
                    "name": "state",
                    "type": [
                        "object"
                    ]
                }
            ],
            "comment": [
                " Public: Deserialize the state and params.",
                "",
                " * `state` The state {Object} to deserialize."
            ],
            "code": "  deserialize (state) {\r\n    if (state == null) {\r\n      return\r\n    }\r\n\r\n    const deserializer = this.get(state)\r\n    if (deserializer) {\r\n      let stateVersion = (\r\n        (typeof state.get === 'function') && state.get('version') ||\r\n        state.version\r\n      )\r\n\r\n      if ((deserializer.version != null) && deserializer.version !== stateVersion) {\r\n        return\r\n      }\r\n      return deserializer.deserialize(state, this.atomEnvironment)\r\n    } else {\r\n      return console.warn('No deserializer found for', state)\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/initialize-benchmark-window.js",
            "name": "console.warn",
            "start_line": 82,
            "end_line": 85,
            "comment": [],
            "params": [
                "args"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/tooltip.js",
            "name": "remove",
            "line": 502,
            "func_location": "Tooltip.prototype.destroy",
            "func_start_line": 500,
            "func_end_line": 504,
            "args": [],
            "code": "Tooltip.prototype.destroy = function () {\r\n  clearTimeout(this.timeout)\r\n  this.tip && this.tip.remove()\r\n  this.disposables.dispose()\r\n}\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/gutter.js",
            "name": "removeGutter",
            "line": 33,
            "func_location": "Gutter.destroy",
            "func_start_line": 29,
            "func_end_line": 37,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Gutter Destruction\r\n  ",
                " Essential: Destroys the gutter."
            ],
            "code": "  destroy () {\r\n    if (this.name === 'line-number') {\r\n      throw new Error('The line-number gutter cannot be destroyed.')\r\n    } else {\r\n      this.gutterContainer.removeGutter(this)\r\n      this.emitter.emit('did-destroy')\r\n      this.emitter.dispose()\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/gutter-container.js",
            "name": "GutterContainer.removeGutter",
            "start_line": 85,
            "end_line": 96,
            "comment": [
                "\r\n  Section: Private Methods\r\n  ",
                " Processes the destruction of the gutter. Throws an error if this gutter is",
                " not within this gutterContainer."
            ],
            "params": [
                {
                    "name": "gutter",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/gutter.js",
            "name": "removeGutter",
            "line": 33,
            "func_location": "Gutter.destroy",
            "func_start_line": 29,
            "func_end_line": 37,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Gutter Destruction\r\n  ",
                " Essential: Destroys the gutter."
            ],
            "code": "  destroy () {\r\n    if (this.name === 'line-number') {\r\n      throw new Error('The line-number gutter cannot be destroyed.')\r\n    } else {\r\n      this.gutterContainer.removeGutter(this)\r\n      this.emitter.emit('did-destroy')\r\n      this.emitter.dispose()\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/gutter-container.js",
            "name": "GutterContainer.removeGutter",
            "start_line": 85,
            "end_line": 96,
            "comment": [
                "\r\n  Section: Private Methods\r\n  ",
                " Processes the destruction of the gutter. Throws an error if this gutter is",
                " not within this gutterContainer."
            ],
            "params": [
                {
                    "name": "gutter",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "remove",
            "line": 3407,
            "func_location": "LineNumberComponent.destroy",
            "func_start_line": 3406,
            "func_end_line": 3409,
            "args": [],
            "code": "  destroy () {\r\n    this.element.remove()\r\n    this.props.nodePool.release(this.element)\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "remove",
            "line": 3971,
            "func_location": "LineComponent.destroy",
            "func_start_line": 3964,
            "func_end_line": 3973,
            "args": [],
            "code": "  destroy () {\r\n    const {nodePool, lineComponentsByScreenLineId, screenLine} = this.props\r\n\r\n    if (lineComponentsByScreenLineId.get(screenLine.id) === this) {\r\n      lineComponentsByScreenLineId.delete(screenLine.id)\r\n    }\r\n\r\n    this.element.remove()\r\n    nodePool.release(this.element)\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/panel.js",
            "name": "remove",
            "line": 32,
            "func_location": "Panel.destroy",
            "func_start_line": 28,
            "func_end_line": 35,
            "args": [],
            "comment": [
                " Public: Destroy and remove this panel from the UI."
            ],
            "code": "  destroy () {\r\n    if (this.destroyed) return\r\n    this.destroyed = true\r\n    this.hide()\r\n    if (this.element) this.element.remove()\r\n    this.emitter.emit('did-destroy', this)\r\n    return this.emitter.dispose()\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "addBlockDecoration",
            "line": 925,
            "func_location": "TextEditor.didAddDecoration",
            "func_start_line": 923,
            "func_end_line": 927,
            "args": [
                {
                    "name": "decoration",
                    "type": []
                }
            ],
            "comment": [
                " Called by DecorationManager when a decoration is added."
            ],
            "code": "  didAddDecoration (decoration) {\r\n    if (this.component && decoration.isType('block')) {\r\n      this.component.addBlockDecoration(decoration)\r\n    }\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "TextEditorComponent.addBlockDecoration",
            "start_line": 2508,
            "end_line": 2560,
            "comment": [],
            "params": [
                "decoration",
                "subscribeToChanges"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "selectLeft",
            "line": 1732,
            "func_location": "TextEditorComponent.didCompositionStart",
            "func_start_line": 1716,
            "func_end_line": 1734,
            "args": [],
            "comment": [
                " The IME composition events work like this:",
                "",
                " User types 's', chromium pops up the completion helper",
                "   1. compositionstart fired",
                "   2. compositionupdate fired; event.data == 's'",
                " User hits arrow keys to move around in completion helper",
                "   3. compositionupdate fired; event.data == 's' for each arry key press",
                " User escape to cancel OR User chooses a completion",
                "   4. compositionend fired",
                "   5. textInput fired; event.data == the completion string"
            ],
            "code": "  didCompositionStart () {\r\n    // Workaround for Chromium not preventing composition events when\r\n    // preventDefault is called on the keydown event that precipitated them.\r\n    if (this.lastKeydown && this.lastKeydown.defaultPrevented) {\r\n      this.getHiddenInput().disabled = true\r\n      process.nextTick(() => {\r\n        // Disabling the hidden input makes it lose focus as well, so we have to\r\n        // re-enable and re-focus it.\r\n        this.getHiddenInput().disabled = false\r\n        this.getHiddenInput().focus()\r\n      })\r\n      return\r\n    }\r\n\r\n    this.compositionCheckpoint = this.props.model.createCheckpoint()\r\n    if (this.accentedCharacterMenuIsOpen) {\r\n      this.props.model.selectLeft()\r\n    }\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.selectLeft",
            "start_line": 251,
            "end_line": 253,
            "comment": [
                " Public: Selects the text one position left of the cursor.",
                "",
                " * `columnCount` (optional) {Number} number of columns to select (default: 1)"
            ],
            "params": [
                {
                    "name": "columnCount",
                    "type": [
                        "number",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "insertText",
            "line": 1737,
            "func_location": "TextEditorComponent.didCompositionUpdate",
            "func_start_line": 1736,
            "func_end_line": 1738,
            "args": [
                "event.data",
                null
            ],
            "code": "  didCompositionUpdate (event) {\r\n    this.props.model.insertText(event.data, {select: true})\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.insertText",
            "start_line": 451,
            "end_line": 513,
            "comment": [
                "\r\n  Section: Modifying the selected text\r\n  ",
                " Public: Replaces text at the current selection.",
                "",
                " * `text` A {String} representing the text to add",
                " * `options` (optional) {Object} with keys:",
                "   * `select` If `true`, selects the newly added text.",
                "   * `autoIndent` If `true`, indents all inserted text appropriately.",
                "   * `autoIndentNewline` If `true`, indent newline appropriately.",
                "   * `autoDecreaseIndent` If `true`, decreases indent level appropriately",
                "     (for example, when a closing bracket is inserted).",
                "   * `preserveTrailingLineIndentation` By default, when pasting multiple",
                "   lines, Atom attempts to preserve the relative indent level between the",
                "   first line and trailing lines, even if the indent level of the first",
                "   line has changed from the copied text. If this option is `true`, this",
                "   behavior is suppressed.",
                "     level between the first lines and the trailing lines.",
                "   * `normalizeLineEndings` (optional) {Boolean} (default: true)",
                "   * `undo` *Deprecated* If `skip`, skips the undo stack for this operation. This property is deprecated. Call groupLastChanges() on the {TextBuffer} afterward instead.",
                "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)"
            ],
            "params": [
                {
                    "name": "text",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "setVisible",
            "line": 1470,
            "func_location": "TextEditorComponent.didHide",
            "func_start_line": 1467,
            "func_end_line": 1472,
            "args": [
                {
                    "type": "boolean"
                }
            ],
            "code": "  didHide () {\r\n    if (this.visible) {\r\n      this.visible = false\r\n      this.props.model.setVisible(false)\r\n    }\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.setVisible",
            "start_line": 991,
            "end_line": 996,
            "comment": [
                " Controls visibility based on the given {Boolean}."
            ],
            "params": [
                {
                    "name": "visible",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "setBufferRange",
            "line": 1851,
            "func_location": "TextEditorComponent.didMouseDownOnLineNumberGutter",
            "func_start_line": 1828,
            "func_end_line": 1884,
            "args": [
                "clickedLineBufferRange"
            ],
            "code": "  didMouseDownOnLineNumberGutter (event) {\r\n    const {model} = this.props\r\n    const {target, button, ctrlKey, shiftKey, metaKey} = event\r\n\r\n    // Only handle mousedown events for left mouse button\r\n    if (button !== 0) return\r\n\r\n    const clickedScreenRow = this.screenPositionForMouseEvent(event).row\r\n    const startBufferRow = model.bufferPositionForScreenPosition([clickedScreenRow, 0]).row\r\n\r\n    if (target && (target.matches('.foldable .icon-right') || target.matches('.folded .icon-right'))) {\r\n      model.toggleFoldAtBufferRow(startBufferRow)\r\n      return\r\n    }\r\n\r\n    const addOrRemoveSelection = metaKey || (ctrlKey && this.getPlatform() !== 'darwin')\r\n    const endBufferRow = model.bufferPositionForScreenPosition([clickedScreenRow, Infinity]).row\r\n    const clickedLineBufferRange = Range(Point(startBufferRow, 0), Point(endBufferRow + 1, 0))\r\n\r\n    let initialBufferRange\r\n    if (shiftKey) {\r\n      const lastSelection = model.getLastSelection()\r\n      initialBufferRange = lastSelection.getBufferRange()\r\n      lastSelection.setBufferRange(initialBufferRange.union(clickedLineBufferRange), {\r\n        reversed: clickedScreenRow < lastSelection.getScreenRange().start.row,\r\n        autoscroll: false,\r\n        preserveFolds: true,\r\n        suppressSelectionMerge: true\r\n      })\r\n    } else {\r\n      initialBufferRange = clickedLineBufferRange\r\n      if (addOrRemoveSelection) {\r\n        model.addSelectionForBufferRange(clickedLineBufferRange, {autoscroll: false, preserveFolds: true})\r\n      } else {\r\n        model.setSelectedBufferRange(clickedLineBufferRange, {autoscroll: false, preserveFolds: true})\r\n      }\r\n    }\r\n\r\n    const initialScreenRange = model.screenRangeForBufferRange(initialBufferRange)\r\n    this.handleMouseDragUntilMouseUp({\r\n      didDrag: (event) => {\r\n        this.autoscrollOnMouseDrag(event, true)\r\n        const dragRow = this.screenPositionForMouseEvent(event).row\r\n        const draggedLineScreenRange = Range(Point(dragRow, 0), Point(dragRow + 1, 0))\r\n        model.getLastSelection().setScreenRange(draggedLineScreenRange.union(initialScreenRange), {\r\n          reversed: dragRow < initialScreenRange.start.row,\r\n          autoscroll: false,\r\n          preserveFolds: true\r\n        })\r\n        this.updateSync()\r\n      },\r\n      didStopDragging: () => {\r\n        model.mergeIntersectingSelections()\r\n        this.updateSync()\r\n      }\r\n    })\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.setBufferRange",
            "start_line": 92,
            "end_line": 104,
            "comment": [
                " Public: Modifies the buffer {Range} for the selection.",
                "",
                " * `bufferRange` The new {Range} to select.",
                " * `options` (optional) {Object} with the keys:",
                "   * `preserveFolds` if `true`, the fold settings are preserved after the",
                "     selection moves.",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     range. Defaults to `true` if this is the most recently added selection,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferRange",
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "setVisible",
            "line": 1460,
            "func_location": "TextEditorComponent.didShow",
            "func_start_line": 1456,
            "func_end_line": 1465,
            "args": [
                {
                    "type": "boolean"
                }
            ],
            "code": "  didShow () {\r\n    if (!this.visible && this.isVisible()) {\r\n      if (!this.hasInitialMeasurements) this.measureDimensions()\r\n      this.visible = true\r\n      this.props.model.setVisible(true)\r\n      this.resizeBlockDecorationMeasurementsArea = true\r\n      this.updateSync()\r\n      this.flushPendingLogicalScrollPosition()\r\n    }\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.setVisible",
            "start_line": 991,
            "end_line": 996,
            "comment": [
                " Controls visibility based on the given {Boolean}."
            ],
            "params": [
                {
                    "name": "visible",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "selectLeft",
            "line": 1649,
            "func_location": "TextEditorComponent.didTextInput",
            "func_start_line": 1617,
            "func_end_line": 1654,
            "args": [],
            "code": "  didTextInput (event) {\r\n    if (this.compositionCheckpoint) {\r\n      this.props.model.revertToCheckpoint(this.compositionCheckpoint)\r\n      this.compositionCheckpoint = null\r\n    }\r\n\r\n    if (this.isInputEnabled()) {\r\n      event.stopPropagation()\r\n\r\n      // WARNING: If we call preventDefault on the input of a space\r\n      // character, then the browser interprets the spacebar keypress as a\r\n      // page-down command, causing spaces to scroll elements containing\r\n      // editors. This means typing space will actually change the contents\r\n      // of the hidden input, which will cause the browser to autoscroll the\r\n      // scroll container to reveal the input if it is off screen (See\r\n      // https://github.com/atom/atom/issues/16046). To correct for this\r\n      // situation, we automatically reset the scroll position to 0,0 after\r\n      // typing a space. None of this can really be tested.\r\n      if (event.data === ' ') {\r\n        window.setImmediate(() => {\r\n          this.refs.scrollContainer.scrollTop = 0\r\n          this.refs.scrollContainer.scrollLeft = 0\r\n        })\r\n      } else {\r\n        event.preventDefault()\r\n      }\r\n\r\n      // If the input event is fired while the accented character menu is open it\r\n      // means that the user has chosen one of the accented alternatives. Thus, we\r\n      // will replace the original non accented character with the selected\r\n      // alternative.\r\n      if (this.accentedCharacterMenuIsOpen) {\r\n        this.props.model.selectLeft()\r\n      }\r\n\r\n      this.props.model.insertText(event.data, {groupUndo: true})\r\n    }\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.selectLeft",
            "start_line": 251,
            "end_line": 253,
            "comment": [
                " Public: Selects the text one position left of the cursor.",
                "",
                " * `columnCount` (optional) {Number} number of columns to select (default: 1)"
            ],
            "params": [
                {
                    "name": "columnCount",
                    "type": [
                        "number",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "insertText",
            "line": 1652,
            "func_location": "TextEditorComponent.didTextInput",
            "func_start_line": 1617,
            "func_end_line": 1654,
            "args": [
                "event.data",
                null
            ],
            "code": "  didTextInput (event) {\r\n    if (this.compositionCheckpoint) {\r\n      this.props.model.revertToCheckpoint(this.compositionCheckpoint)\r\n      this.compositionCheckpoint = null\r\n    }\r\n\r\n    if (this.isInputEnabled()) {\r\n      event.stopPropagation()\r\n\r\n      // WARNING: If we call preventDefault on the input of a space\r\n      // character, then the browser interprets the spacebar keypress as a\r\n      // page-down command, causing spaces to scroll elements containing\r\n      // editors. This means typing space will actually change the contents\r\n      // of the hidden input, which will cause the browser to autoscroll the\r\n      // scroll container to reveal the input if it is off screen (See\r\n      // https://github.com/atom/atom/issues/16046). To correct for this\r\n      // situation, we automatically reset the scroll position to 0,0 after\r\n      // typing a space. None of this can really be tested.\r\n      if (event.data === ' ') {\r\n        window.setImmediate(() => {\r\n          this.refs.scrollContainer.scrollTop = 0\r\n          this.refs.scrollContainer.scrollLeft = 0\r\n        })\r\n      } else {\r\n        event.preventDefault()\r\n      }\r\n\r\n      // If the input event is fired while the accented character menu is open it\r\n      // means that the user has chosen one of the accented alternatives. Thus, we\r\n      // will replace the original non accented character with the selected\r\n      // alternative.\r\n      if (this.accentedCharacterMenuIsOpen) {\r\n        this.props.model.selectLeft()\r\n      }\r\n\r\n      this.props.model.insertText(event.data, {groupUndo: true})\r\n    }\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.insertText",
            "start_line": 451,
            "end_line": 513,
            "comment": [
                "\r\n  Section: Modifying the selected text\r\n  ",
                " Public: Replaces text at the current selection.",
                "",
                " * `text` A {String} representing the text to add",
                " * `options` (optional) {Object} with keys:",
                "   * `select` If `true`, selects the newly added text.",
                "   * `autoIndent` If `true`, indents all inserted text appropriately.",
                "   * `autoIndentNewline` If `true`, indent newline appropriately.",
                "   * `autoDecreaseIndent` If `true`, decreases indent level appropriately",
                "     (for example, when a closing bracket is inserted).",
                "   * `preserveTrailingLineIndentation` By default, when pasting multiple",
                "   lines, Atom attempts to preserve the relative indent level between the",
                "   first line and trailing lines, even if the indent level of the first",
                "   line has changed from the copied text. If this option is `true`, this",
                "   behavior is suppressed.",
                "     level between the first lines and the trailing lines.",
                "   * `normalizeLineEndings` (optional) {Boolean} (default: true)",
                "   * `undo` *Deprecated* If `skip`, skips the undo stack for this operation. This property is deprecated. Call groupLastChanges() on the {TextBuffer} afterward instead.",
                "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)"
            ],
            "params": [
                {
                    "name": "text",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/dock.js",
            "name": "updateSync",
            "line": 77,
            "func_location": "Dock.elementAttached",
            "func_start_line": 75,
            "func_end_line": 78,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " This method is called explicitly by the object which adds the Dock to the document."
            ],
            "code": "  elementAttached () {\r\n    // Re-render when the dock is attached to make sure we remeasure sizes defined in CSS.\r\n    etch.updateSync(this)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "TextEditorComponent.updateSync",
            "start_line": 221,
            "end_line": 289,
            "comment": [],
            "params": [
                "useScheduler"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/package.js",
            "name": "removeAtKeyPath",
            "line": 69,
            "func_location": "Package.enable",
            "func_start_line": 68,
            "func_end_line": 70,
            "args": [
                {
                    "name": {
                        "type": "string"
                    },
                    "type": []
                },
                {
                    "name": ".name",
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Instance Methods\r\n  "
            ],
            "code": "  enable () {\r\n    return this.config.removeAtKeyPath('core.disabledPackages', this.name)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.removeAtKeyPath",
            "start_line": 887,
            "end_line": 893,
            "comment": [],
            "params": [
                "keyPath",
                "value"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "flattenMenuItems",
            "line": 97,
            "func_location": "ApplicationMenu.enableWindowSpecificItems",
            "func_start_line": 96,
            "func_end_line": 100,
            "args": [
                {
                    "name": ".menu",
                    "type": []
                }
            ],
            "comment": [
                " Public: Used to make all window related menu items are active.",
                "",
                " enable - If true enables all window specific items, if false disables all",
                "          window specific items."
            ],
            "code": "  enableWindowSpecificItems (enable) {\r\n    for (let item of this.flattenMenuItems(this.menu)) {\r\n      if (item.metadata && item.metadata.windowSpecific) item.enabled = enable\r\n    }\r\n  }\r",
            "return_type": [
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "ApplicationMenu.flattenMenuItems",
            "start_line": 67,
            "end_line": 76,
            "comment": [
                " Flattens the given menu and submenu items into an single Array.",
                "",
                " menu - A complete menu configuration object for atom-shell's menu API.",
                "",
                " Returns an Array of native menu items."
            ],
            "params": [
                {
                    "name": "menu",
                    "type": [
                        "array",
                        "object"
                    ]
                }
            ],
            "return_type": [
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "flattenMenuItems",
            "line": 97,
            "func_location": "ApplicationMenu.enableWindowSpecificItems",
            "func_start_line": 96,
            "func_end_line": 100,
            "args": [
                {
                    "name": ".menu",
                    "type": []
                }
            ],
            "comment": [
                " Public: Used to make all window related menu items are active.",
                "",
                " enable - If true enables all window specific items, if false disables all",
                "          window specific items."
            ],
            "code": "  enableWindowSpecificItems (enable) {\r\n    for (let item of this.flattenMenuItems(this.menu)) {\r\n      if (item.metadata && item.metadata.windowSpecific) item.enabled = enable\r\n    }\r\n  }\r",
            "return_type": [
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "ApplicationMenu.flattenMenuItems",
            "start_line": 67,
            "end_line": 76,
            "comment": [
                " Flattens the given menu and submenu items into an single Array.",
                "",
                " menu - A complete menu configuration object for atom-shell's menu API.",
                "",
                " Returns an Array of native menu items."
            ],
            "params": [
                {
                    "name": "menu",
                    "type": [
                        "array",
                        "object"
                    ]
                }
            ],
            "return_type": [
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/initialize-benchmark-window.js",
            "name": "write",
            "line": 88,
            "func_location": "console.error",
            "func_start_line": 86,
            "func_end_line": 89,
            "args": [
                null
            ],
            "code": "      console.error = function (...args) {\r\n        const formatted = util.format(...args)\r\n        process.stderr.write(formatted + '\\n')\r\n      }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/clipboard.js",
            "name": "Clipboard.write",
            "start_line": 42,
            "end_line": 46,
            "comment": [
                " Public: Write the given text to the clipboard.",
                "",
                " The metadata associated with the text is available by calling",
                " {::readWithMetadata}.",
                "",
                " * `text` The {String} to store.",
                " * `metadata` (optional) The additional info to associate with the text."
            ],
            "params": [
                {
                    "name": "text",
                    "type": [
                        "string",
                        "optional"
                    ]
                },
                {
                    "name": "metadata",
                    "type": [
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "getBufferRange",
            "line": 404,
            "func_location": "Selection.expandOverLine",
            "func_start_line": 403,
            "func_end_line": 408,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Expands the newest selection to include the entire line on which",
                " the cursor currently rests.",
                "",
                " It also includes the newline character."
            ],
            "code": "  expandOverLine (options) {\r\n    const range = this.getBufferRange().union(this.cursor.getCurrentLineBufferRange({includeNewline: true}))\r\n    this.setBufferRange(range, {autoscroll: false})\r\n    const autoscroll = options && options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.cursor.autoscroll()\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.getBufferRange",
            "start_line": 79,
            "end_line": 81,
            "comment": [
                " Public: Returns the buffer {Range} for the selection."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "getCurrentLineBufferRange",
            "line": 404,
            "func_location": "Selection.expandOverLine",
            "func_start_line": 403,
            "func_end_line": 408,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Expands the newest selection to include the entire line on which",
                " the cursor currently rests.",
                "",
                " It also includes the newline character."
            ],
            "code": "  expandOverLine (options) {\r\n    const range = this.getBufferRange().union(this.cursor.getCurrentLineBufferRange({includeNewline: true}))\r\n    this.setBufferRange(range, {autoscroll: false})\r\n    const autoscroll = options && options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.cursor.autoscroll()\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getCurrentLineBufferRange",
            "start_line": 623,
            "end_line": 625,
            "comment": [
                " Public: Returns the buffer Range for the current line.",
                "",
                " * `options` (optional) {Object}",
                "   * `includeNewline` A {Boolean} which controls whether the Range should",
                "     include the newline."
            ],
            "params": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "getCurrentLineBufferRange",
            "line": 404,
            "func_location": "Selection.expandOverLine",
            "func_start_line": 403,
            "func_end_line": 408,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Expands the newest selection to include the entire line on which",
                " the cursor currently rests.",
                "",
                " It also includes the newline character."
            ],
            "code": "  expandOverLine (options) {\r\n    const range = this.getBufferRange().union(this.cursor.getCurrentLineBufferRange({includeNewline: true}))\r\n    this.setBufferRange(range, {autoscroll: false})\r\n    const autoscroll = options && options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.cursor.autoscroll()\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getCurrentLineBufferRange",
            "start_line": 623,
            "end_line": 625,
            "comment": [
                " Public: Returns the buffer Range for the current line.",
                "",
                " * `options` (optional) {Object}",
                "   * `includeNewline` A {Boolean} which controls whether the Range should",
                "     include the newline."
            ],
            "params": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "setBufferRange",
            "line": 405,
            "func_location": "Selection.expandOverLine",
            "func_start_line": 403,
            "func_end_line": 408,
            "args": [
                {
                    "name": "range",
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Expands the newest selection to include the entire line on which",
                " the cursor currently rests.",
                "",
                " It also includes the newline character."
            ],
            "code": "  expandOverLine (options) {\r\n    const range = this.getBufferRange().union(this.cursor.getCurrentLineBufferRange({includeNewline: true}))\r\n    this.setBufferRange(range, {autoscroll: false})\r\n    const autoscroll = options && options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.cursor.autoscroll()\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.setBufferRange",
            "start_line": 92,
            "end_line": 104,
            "comment": [
                " Public: Modifies the buffer {Range} for the selection.",
                "",
                " * `bufferRange` The new {Range} to select.",
                " * `options` (optional) {Object} with the keys:",
                "   * `preserveFolds` if `true`, the fold settings are preserved after the",
                "     selection moves.",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     range. Defaults to `true` if this is the most recently added selection,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferRange",
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "setBufferRange",
            "line": 405,
            "func_location": "Selection.expandOverLine",
            "func_start_line": 403,
            "func_end_line": 408,
            "args": [
                {
                    "name": "range",
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Expands the newest selection to include the entire line on which",
                " the cursor currently rests.",
                "",
                " It also includes the newline character."
            ],
            "code": "  expandOverLine (options) {\r\n    const range = this.getBufferRange().union(this.cursor.getCurrentLineBufferRange({includeNewline: true}))\r\n    this.setBufferRange(range, {autoscroll: false})\r\n    const autoscroll = options && options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.cursor.autoscroll()\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.setBufferRange",
            "start_line": 92,
            "end_line": 104,
            "comment": [
                " Public: Modifies the buffer {Range} for the selection.",
                "",
                " * `bufferRange` The new {Range} to select.",
                " * `options` (optional) {Object} with the keys:",
                "   * `preserveFolds` if `true`, the fold settings are preserved after the",
                "     selection moves.",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     range. Defaults to `true` if this is the most recently added selection,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferRange",
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "setBufferRange",
            "line": 377,
            "func_location": "Selection.expandOverWord",
            "func_start_line": 376,
            "func_end_line": 380,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Expands the newest selection to include the entire word on which",
                " the cursors rests."
            ],
            "code": "  expandOverWord (options) {\r\n    this.setBufferRange(this.getBufferRange().union(this.cursor.getCurrentWordBufferRange()), {autoscroll: false})\r\n    const autoscroll = options && options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.cursor.autoscroll()\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.setBufferRange",
            "start_line": 92,
            "end_line": 104,
            "comment": [
                " Public: Modifies the buffer {Range} for the selection.",
                "",
                " * `bufferRange` The new {Range} to select.",
                " * `options` (optional) {Object} with the keys:",
                "   * `preserveFolds` if `true`, the fold settings are preserved after the",
                "     selection moves.",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     range. Defaults to `true` if this is the most recently added selection,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferRange",
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "setBufferRange",
            "line": 377,
            "func_location": "Selection.expandOverWord",
            "func_start_line": 376,
            "func_end_line": 380,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Expands the newest selection to include the entire word on which",
                " the cursors rests."
            ],
            "code": "  expandOverWord (options) {\r\n    this.setBufferRange(this.getBufferRange().union(this.cursor.getCurrentWordBufferRange()), {autoscroll: false})\r\n    const autoscroll = options && options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.cursor.autoscroll()\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.setBufferRange",
            "start_line": 92,
            "end_line": 104,
            "comment": [
                " Public: Modifies the buffer {Range} for the selection.",
                "",
                " * `bufferRange` The new {Range} to select.",
                " * `options` (optional) {Object} with the keys:",
                "   * `preserveFolds` if `true`, the fold settings are preserved after the",
                "     selection moves.",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     range. Defaults to `true` if this is the most recently added selection,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferRange",
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "getBufferRange",
            "line": 377,
            "func_location": "Selection.expandOverWord",
            "func_start_line": 376,
            "func_end_line": 380,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Expands the newest selection to include the entire word on which",
                " the cursors rests."
            ],
            "code": "  expandOverWord (options) {\r\n    this.setBufferRange(this.getBufferRange().union(this.cursor.getCurrentWordBufferRange()), {autoscroll: false})\r\n    const autoscroll = options && options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.cursor.autoscroll()\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.getBufferRange",
            "start_line": 79,
            "end_line": 81,
            "comment": [
                " Public: Returns the buffer {Range} for the selection."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "getCurrentWordBufferRange",
            "line": 377,
            "func_location": "Selection.expandOverWord",
            "func_start_line": 376,
            "func_end_line": 380,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Expands the newest selection to include the entire word on which",
                " the cursors rests."
            ],
            "code": "  expandOverWord (options) {\r\n    this.setBufferRange(this.getBufferRange().union(this.cursor.getCurrentWordBufferRange()), {autoscroll: false})\r\n    const autoscroll = options && options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.cursor.autoscroll()\r\n  }\r",
            "return_type": [
                "object",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getCurrentWordBufferRange",
            "start_line": 606,
            "end_line": 616,
            "comment": [
                " Public: Returns the buffer Range occupied by the word located under the cursor.",
                "",
                " * `options` (optional) {Object}",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "     (default: {::wordRegExp})."
            ],
            "params": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": [
                "object",
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "getCurrentWordBufferRange",
            "line": 377,
            "func_location": "Selection.expandOverWord",
            "func_start_line": 376,
            "func_end_line": 380,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Expands the newest selection to include the entire word on which",
                " the cursors rests."
            ],
            "code": "  expandOverWord (options) {\r\n    this.setBufferRange(this.getBufferRange().union(this.cursor.getCurrentWordBufferRange()), {autoscroll: false})\r\n    const autoscroll = options && options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.cursor.autoscroll()\r\n  }\r",
            "return_type": [
                "object",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getCurrentWordBufferRange",
            "start_line": 606,
            "end_line": 616,
            "comment": [
                " Public: Returns the buffer Range occupied by the word located under the cursor.",
                "",
                " * `options` (optional) {Object}",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "     (default: {::wordRegExp})."
            ],
            "params": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": [
                "object",
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/tooltip-manager.js",
            "name": "has",
            "line": 185,
            "func_location": "TooltipManager.findTooltips",
            "func_start_line": 184,
            "func_end_line": 190,
            "args": [
                {
                    "name": "target",
                    "type": []
                }
            ],
            "comment": [
                " Extended: Find the tooltips that have been applied to the given element.",
                "",
                " * `target` The `HTMLElement` to find tooltips on.",
                "",
                " Returns an {Array} of `Tooltip` objects that match the `target`."
            ],
            "code": "  findTooltips (target) {\r\n    if (this.tooltips.has(target)) {\r\n      return this.tooltips.get(target).slice()\r\n    } else {\r\n      return []\r\n    }\r\n  }\r",
            "return_type": [
                "object",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/file-system-blob-store.js",
            "name": "FileSystemBlobStore.has",
            "start_line": 68,
            "end_line": 70,
            "comment": [],
            "params": [
                "key"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "flattenMenuItems",
            "line": 73,
            "func_location": "ApplicationMenu.flattenMenuItems",
            "func_start_line": 67,
            "func_end_line": 76,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Flattens the given menu and submenu items into an single Array.",
                "",
                " menu - A complete menu configuration object for atom-shell's menu API.",
                "",
                " Returns an Array of native menu items."
            ],
            "code": "  flattenMenuItems (menu) {\r\n    const object = menu.items || {}\r\n    let items = []\r\n    for (let index in object) {\r\n      const item = object[index]\r\n      items.push(item)\r\n      if (item.submenu) items = items.concat(this.flattenMenuItems(item.submenu))\r\n    }\r\n    return items\r\n  }\r",
            "return_type": [
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "ApplicationMenu.flattenMenuItems",
            "start_line": 67,
            "end_line": 76,
            "comment": [
                " Flattens the given menu and submenu items into an single Array.",
                "",
                " menu - A complete menu configuration object for atom-shell's menu API.",
                "",
                " Returns an Array of native menu items."
            ],
            "params": [
                {
                    "name": "menu",
                    "type": [
                        "array",
                        "object"
                    ]
                }
            ],
            "return_type": [
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "flattenMenuItems",
            "line": 73,
            "func_location": "ApplicationMenu.flattenMenuItems",
            "func_start_line": 67,
            "func_end_line": 76,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Flattens the given menu and submenu items into an single Array.",
                "",
                " menu - A complete menu configuration object for atom-shell's menu API.",
                "",
                " Returns an Array of native menu items."
            ],
            "code": "  flattenMenuItems (menu) {\r\n    const object = menu.items || {}\r\n    let items = []\r\n    for (let index in object) {\r\n      const item = object[index]\r\n      items.push(item)\r\n      if (item.submenu) items = items.concat(this.flattenMenuItems(item.submenu))\r\n    }\r\n    return items\r\n  }\r",
            "return_type": [
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "ApplicationMenu.flattenMenuItems",
            "start_line": 67,
            "end_line": 76,
            "comment": [
                " Flattens the given menu and submenu items into an single Array.",
                "",
                " menu - A complete menu configuration object for atom-shell's menu API.",
                "",
                " Returns an Array of native menu items."
            ],
            "params": [
                {
                    "name": "menu",
                    "type": [
                        "array",
                        "object"
                    ]
                }
            ],
            "return_type": [
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "flattenMenuTemplate",
            "line": 87,
            "func_location": "ApplicationMenu.flattenMenuTemplate",
            "func_start_line": 83,
            "func_end_line": 90,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Flattens the given menu template into an single Array.",
                "",
                " template - An object describing the menu item.",
                "",
                " Returns an Array of native menu items."
            ],
            "code": "  flattenMenuTemplate (template) {\r\n    let items = []\r\n    for (let item of template) {\r\n      items.push(item)\r\n      if (item.submenu) items = items.concat(this.flattenMenuTemplate(item.submenu))\r\n    }\r\n    return items\r\n  }\r",
            "return_type": [
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "ApplicationMenu.flattenMenuTemplate",
            "start_line": 83,
            "end_line": 90,
            "comment": [
                " Flattens the given menu template into an single Array.",
                "",
                " template - An object describing the menu item.",
                "",
                " Returns an Array of native menu items."
            ],
            "params": [
                {
                    "name": "template",
                    "type": [
                        "array",
                        "object"
                    ]
                }
            ],
            "return_type": [
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "flattenMenuTemplate",
            "line": 87,
            "func_location": "ApplicationMenu.flattenMenuTemplate",
            "func_start_line": 83,
            "func_end_line": 90,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Flattens the given menu template into an single Array.",
                "",
                " template - An object describing the menu item.",
                "",
                " Returns an Array of native menu items."
            ],
            "code": "  flattenMenuTemplate (template) {\r\n    let items = []\r\n    for (let item of template) {\r\n      items.push(item)\r\n      if (item.submenu) items = items.concat(this.flattenMenuTemplate(item.submenu))\r\n    }\r\n    return items\r\n  }\r",
            "return_type": [
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "ApplicationMenu.flattenMenuTemplate",
            "start_line": 83,
            "end_line": 90,
            "comment": [
                " Flattens the given menu template into an single Array.",
                "",
                " template - An object describing the menu item.",
                "",
                " Returns an Array of native menu items."
            ],
            "params": [
                {
                    "name": "template",
                    "type": [
                        "array",
                        "object"
                    ]
                }
            ],
            "return_type": [
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/scope-descriptor.js",
            "name": "constructor",
            "line": 26,
            "func_location": "ScopeDescriptor.fromObject",
            "func_start_line": 22,
            "func_end_line": 28
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/scope-descriptor.js",
            "name": "ScopeDescriptor.constructor",
            "start_line": 38,
            "end_line": 40,
            "comment": [
                "\r\n  Section: Construction and Destruction\r\n  ",
                " Public: Create a {ScopeDescriptor} object.",
                "",
                " * `object` {Object}",
                "   * `scopes` {Array} of {String}s"
            ],
            "params": [
                {
                    "name": [
                        "scopes"
                    ],
                    "type": [
                        "string",
                        "array"
                    ]
                }
            ],
            "return_type": [
                "string",
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "getRawScopedValue",
            "line": 597,
            "func_location": "Config.get",
            "func_start_line": 585,
            "func_end_line": 602,
            "args": [
                {
                    "name": "scope",
                    "type": [
                        "optional"
                    ]
                },
                {
                    "name": "keyPath",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                "\r\n  Section: Managing Settings\r\n  ",
                " Essential: Retrieves the setting for the given key.",
                "",
                " ### Examples",
                "",
                " You might want to know what themes are enabled, so check `core.themes`",
                "",
                " ```coffee",
                " atom.config.get('core.themes')",
                " ```",
                "",
                " With scope descriptors you can get settings within a specific editor",
                " scope. For example, you might want to know `editor.tabLength` for ruby",
                " files.",
                "",
                " ```coffee",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2",
                " ```",
                "",
                " This setting in ruby files might be different than the global tabLength setting",
                "",
                " ```coffee",
                " atom.config.get('editor.tabLength') # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2",
                " ```",
                "",
                " You can get the language scope descriptor via",
                " {TextEditor::getRootScopeDescriptor}. This will get the setting specifically",
                " for the editor's language.",
                "",
                " ```coffee",
                " atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2",
                " ```",
                "",
                " Additionally, you can get the setting at the specific cursor position.",
                "",
                " ```coffee",
                " scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()",
                " atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2",
                " ```",
                "",
                " * `keyPath` The {String} name of the key to retrieve.",
                " * `options` (optional) {Object}",
                "   * `sources` (optional) {Array} of {String} source names. If provided, only",
                "     values that were associated with these sources during {::set} will be used.",
                "   * `excludeSources` (optional) {Array} of {String} source names. If provided,",
                "     values that  were associated with these sources during {::set} will not",
                "     be used.",
                "   * `scope` (optional) {ScopeDescriptor} describing a path from",
                "     the root of the syntax tree to a token. Get one by calling",
                "     {editor.getLastCursor().getScopeDescriptor()}",
                "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)",
                "     for more information.",
                "",
                " Returns the value from Atom's default settings, the user's configuration",
                " file in the type specified by the configuration schema."
            ],
            "code": "  get (...args) {\r\n    let keyPath, options, scope\r\n    if (args.length > 1) {\r\n      if ((typeof args[0] === 'string') || (args[0] == null)) {\r\n        [keyPath, options] = args;\r\n        ({scope} = options)\r\n      }\r\n    } else {\r\n      [keyPath] = args\r\n    }\r\n\r\n    if (scope != null) {\r\n      const value = this.getRawScopedValue(scope, keyPath, options)\r\n      return value != null ? value : this.getRawValue(keyPath, options)\r\n    } else {\r\n      return this.getRawValue(keyPath, options)\r\n    }\r\n  }\r",
            "return_type": [
                "string",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.getRawScopedValue",
            "start_line": 1244,
            "end_line": 1262,
            "comment": [],
            "params": [
                "scopeDescriptor",
                "keyPath",
                "options"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "getRawValue",
            "line": 598,
            "func_location": "Config.get",
            "func_start_line": 585,
            "func_end_line": 602,
            "args": [
                {
                    "name": "keyPath",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                "\r\n  Section: Managing Settings\r\n  ",
                " Essential: Retrieves the setting for the given key.",
                "",
                " ### Examples",
                "",
                " You might want to know what themes are enabled, so check `core.themes`",
                "",
                " ```coffee",
                " atom.config.get('core.themes')",
                " ```",
                "",
                " With scope descriptors you can get settings within a specific editor",
                " scope. For example, you might want to know `editor.tabLength` for ruby",
                " files.",
                "",
                " ```coffee",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2",
                " ```",
                "",
                " This setting in ruby files might be different than the global tabLength setting",
                "",
                " ```coffee",
                " atom.config.get('editor.tabLength') # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2",
                " ```",
                "",
                " You can get the language scope descriptor via",
                " {TextEditor::getRootScopeDescriptor}. This will get the setting specifically",
                " for the editor's language.",
                "",
                " ```coffee",
                " atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2",
                " ```",
                "",
                " Additionally, you can get the setting at the specific cursor position.",
                "",
                " ```coffee",
                " scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()",
                " atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2",
                " ```",
                "",
                " * `keyPath` The {String} name of the key to retrieve.",
                " * `options` (optional) {Object}",
                "   * `sources` (optional) {Array} of {String} source names. If provided, only",
                "     values that were associated with these sources during {::set} will be used.",
                "   * `excludeSources` (optional) {Array} of {String} source names. If provided,",
                "     values that  were associated with these sources during {::set} will not",
                "     be used.",
                "   * `scope` (optional) {ScopeDescriptor} describing a path from",
                "     the root of the syntax tree to a token. Get one by calling",
                "     {editor.getLastCursor().getScopeDescriptor()}",
                "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)",
                "     for more information.",
                "",
                " Returns the value from Atom's default settings, the user's configuration",
                " file in the type specified by the configuration schema."
            ],
            "code": "  get (...args) {\r\n    let keyPath, options, scope\r\n    if (args.length > 1) {\r\n      if ((typeof args[0] === 'string') || (args[0] == null)) {\r\n        [keyPath, options] = args;\r\n        ({scope} = options)\r\n      }\r\n    } else {\r\n      [keyPath] = args\r\n    }\r\n\r\n    if (scope != null) {\r\n      const value = this.getRawScopedValue(scope, keyPath, options)\r\n      return value != null ? value : this.getRawValue(keyPath, options)\r\n    } else {\r\n      return this.getRawValue(keyPath, options)\r\n    }\r\n  }\r",
            "return_type": [
                "string",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.getRawValue",
            "start_line": 994,
            "end_line": 1018,
            "comment": [],
            "params": [
                "keyPath",
                "options"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "getRawValue",
            "line": 600,
            "func_location": "Config.get",
            "func_start_line": 585,
            "func_end_line": 602,
            "args": [
                {
                    "name": "keyPath",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                "\r\n  Section: Managing Settings\r\n  ",
                " Essential: Retrieves the setting for the given key.",
                "",
                " ### Examples",
                "",
                " You might want to know what themes are enabled, so check `core.themes`",
                "",
                " ```coffee",
                " atom.config.get('core.themes')",
                " ```",
                "",
                " With scope descriptors you can get settings within a specific editor",
                " scope. For example, you might want to know `editor.tabLength` for ruby",
                " files.",
                "",
                " ```coffee",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2",
                " ```",
                "",
                " This setting in ruby files might be different than the global tabLength setting",
                "",
                " ```coffee",
                " atom.config.get('editor.tabLength') # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2",
                " ```",
                "",
                " You can get the language scope descriptor via",
                " {TextEditor::getRootScopeDescriptor}. This will get the setting specifically",
                " for the editor's language.",
                "",
                " ```coffee",
                " atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2",
                " ```",
                "",
                " Additionally, you can get the setting at the specific cursor position.",
                "",
                " ```coffee",
                " scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()",
                " atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2",
                " ```",
                "",
                " * `keyPath` The {String} name of the key to retrieve.",
                " * `options` (optional) {Object}",
                "   * `sources` (optional) {Array} of {String} source names. If provided, only",
                "     values that were associated with these sources during {::set} will be used.",
                "   * `excludeSources` (optional) {Array} of {String} source names. If provided,",
                "     values that  were associated with these sources during {::set} will not",
                "     be used.",
                "   * `scope` (optional) {ScopeDescriptor} describing a path from",
                "     the root of the syntax tree to a token. Get one by calling",
                "     {editor.getLastCursor().getScopeDescriptor()}",
                "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)",
                "     for more information.",
                "",
                " Returns the value from Atom's default settings, the user's configuration",
                " file in the type specified by the configuration schema."
            ],
            "code": "  get (...args) {\r\n    let keyPath, options, scope\r\n    if (args.length > 1) {\r\n      if ((typeof args[0] === 'string') || (args[0] == null)) {\r\n        [keyPath, options] = args;\r\n        ({scope} = options)\r\n      }\r\n    } else {\r\n      [keyPath] = args\r\n    }\r\n\r\n    if (scope != null) {\r\n      const value = this.getRawScopedValue(scope, keyPath, options)\r\n      return value != null ? value : this.getRawValue(keyPath, options)\r\n    } else {\r\n      return this.getRawValue(keyPath, options)\r\n    }\r\n  }\r",
            "return_type": [
                "string",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.getRawValue",
            "start_line": 994,
            "end_line": 1018,
            "comment": [],
            "params": [
                "keyPath",
                "options"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/theme-manager.js",
            "name": "getActiveThemes",
            "line": 88,
            "func_location": "ThemeManager.getActiveThemeNames",
            "func_start_line": 87,
            "func_end_line": 89,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Accessing Active Themes\r\n  ",
                " Public: Returns an {Array} of {String}s of all the active theme names."
            ],
            "code": "  getActiveThemeNames () {\r\n    return this.getActiveThemes().map((theme) => theme.name)\r\n  }\r",
            "return_type": [
                "string",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/theme-manager.js",
            "name": "ThemeManager.getActiveThemes",
            "start_line": 92,
            "end_line": 94,
            "comment": [
                " Public: Returns an {Array} of all the active themes."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 255,
            "func_location": "GitRepository.getAheadBehindCount",
            "func_start_line": 254,
            "func_end_line": 256,
            "args": [
                {
                    "name": "reference",
                    "type": [
                        "string"
                    ]
                }
            ],
            "comment": [
                " Public: Returns the number of commits behind the current branch is from the",
                " its upstream remote branch.",
                "",
                " * `reference` The {String} branch reference name.",
                " * `path`      The {String} path in the repository to get this information for,",
                "   only needed if the repository contains submodules."
            ],
            "code": "  getAheadBehindCount (reference, path) {\r\n    return this.getRepo(path).getAheadBehindCount(reference)\r\n  }\r",
            "return_type": [
                "number"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "number"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 255,
            "func_location": "GitRepository.getAheadBehindCount",
            "func_start_line": 254,
            "func_end_line": 256,
            "args": [
                {
                    "name": "reference",
                    "type": [
                        "string"
                    ]
                }
            ],
            "comment": [
                " Public: Returns the number of commits behind the current branch is from the",
                " its upstream remote branch.",
                "",
                " * `reference` The {String} branch reference name.",
                " * `path`      The {String} path in the repository to get this information for,",
                "   only needed if the repository contains submodules."
            ],
            "code": "  getAheadBehindCount (reference, path) {\r\n    return this.getRepo(path).getAheadBehindCount(reference)\r\n  }\r",
            "return_type": [
                "number"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "number"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getAheadBehindCount",
            "line": 255,
            "func_location": "GitRepository.getAheadBehindCount",
            "func_start_line": 254,
            "func_end_line": 256,
            "args": [
                {
                    "name": "reference",
                    "type": [
                        "string"
                    ]
                }
            ],
            "comment": [
                " Public: Returns the number of commits behind the current branch is from the",
                " its upstream remote branch.",
                "",
                " * `reference` The {String} branch reference name.",
                " * `path`      The {String} path in the repository to get this information for,",
                "   only needed if the repository contains submodules."
            ],
            "code": "  getAheadBehindCount (reference, path) {\r\n    return this.getRepo(path).getAheadBehindCount(reference)\r\n  }\r",
            "return_type": [
                "number",
                "object",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getAheadBehindCount",
            "start_line": 254,
            "end_line": 256,
            "comment": [
                " Public: Returns the number of commits behind the current branch is from the",
                " its upstream remote branch.",
                "",
                " * `reference` The {String} branch reference name.",
                " * `path`      The {String} path in the repository to get this information for,",
                "   only needed if the repository contains submodules."
            ],
            "params": [
                {
                    "name": "reference",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "path",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "number",
                "object",
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getAheadBehindCount",
            "line": 255,
            "func_location": "GitRepository.getAheadBehindCount",
            "func_start_line": 254,
            "func_end_line": 256,
            "args": [
                {
                    "name": "reference",
                    "type": [
                        "string"
                    ]
                }
            ],
            "comment": [
                " Public: Returns the number of commits behind the current branch is from the",
                " its upstream remote branch.",
                "",
                " * `reference` The {String} branch reference name.",
                " * `path`      The {String} path in the repository to get this information for,",
                "   only needed if the repository contains submodules."
            ],
            "code": "  getAheadBehindCount (reference, path) {\r\n    return this.getRepo(path).getAheadBehindCount(reference)\r\n  }\r",
            "return_type": [
                "number",
                "object",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getAheadBehindCount",
            "start_line": 254,
            "end_line": 256,
            "comment": [
                " Public: Returns the number of commits behind the current branch is from the",
                " its upstream remote branch.",
                "",
                " * `reference` The {String} branch reference name.",
                " * `path`      The {String} path in the repository to get this information for,",
                "   only needed if the repository contains submodules."
            ],
            "params": [
                {
                    "name": "reference",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "path",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "number",
                "object",
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "fromObject",
            "line": 619,
            "func_location": "Config.getAll",
            "func_start_line": 613,
            "func_end_line": 643,
            "args": [
                {
                    "name": "scope",
                    "type": []
                }
            ],
            "comment": [
                " Extended: Get all of the values for the given key-path, along with their",
                " associated scope selector.",
                "",
                " * `keyPath` The {String} name of the key to retrieve",
                " * `options` (optional) {Object} see the `options` argument to {::get}",
                "",
                " Returns an {Array} of {Object}s with the following keys:",
                "  * `scopeDescriptor` The {ScopeDescriptor} with which the value is associated",
                "  * `value` The value for the key-path"
            ],
            "code": "  getAll (keyPath, options) {\r\n    let globalValue, result, scope\r\n    if (options != null) { ({scope} = options) }\r\n\r\n    if (scope != null) {\r\n      let legacyScopeDescriptor\r\n      const scopeDescriptor = ScopeDescriptor.fromObject(scope)\r\n      result = this.scopedSettingsStore.getAll(\r\n          scopeDescriptor.getScopeChain(),\r\n          keyPath,\r\n          options\r\n        )\r\n      legacyScopeDescriptor = this.getLegacyScopeDescriptorForNewScopeDescriptor(scopeDescriptor)\r\n      if (legacyScopeDescriptor) {\r\n        result.push(...Array.from(this.scopedSettingsStore.getAll(\r\n           legacyScopeDescriptor.getScopeChain(),\r\n           keyPath,\r\n           options\r\n         ) || []))\r\n      }\r\n    } else {\r\n      result = []\r\n    }\r\n\r\n    globalValue = this.getRawValue(keyPath, options)\r\n    if (globalValue) {\r\n      result.push({scopeSelector: '*', value: globalValue})\r\n    }\r\n\r\n    return result\r\n  }\r",
            "return_type": [
                "number",
                "object",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/scope-descriptor.js",
            "name": "ScopeDescriptor.fromObject",
            "start_line": 22,
            "end_line": 28,
            "comment": [],
            "params": [
                "scopes"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "getAll",
            "line": 620,
            "func_location": "Config.getAll",
            "func_start_line": 613,
            "func_end_line": 643
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.getAll",
            "start_line": 613,
            "end_line": 643,
            "comment": [
                " Extended: Get all of the values for the given key-path, along with their",
                " associated scope selector.",
                "",
                " * `keyPath` The {String} name of the key to retrieve",
                " * `options` (optional) {Object} see the `options` argument to {::get}",
                "",
                " Returns an {Array} of {Object}s with the following keys:",
                "  * `scopeDescriptor` The {ScopeDescriptor} with which the value is associated",
                "  * `value` The value for the key-path"
            ],
            "params": [
                {
                    "name": "keyPath",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": [
                "object",
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "getLegacyScopeDescriptorForNewScopeDescriptor",
            "line": 625,
            "func_location": "Config.getAll",
            "func_start_line": 613,
            "func_end_line": 643,
            "args": [
                {
                    "name": "scopeDescriptor",
                    "type": []
                }
            ],
            "comment": [
                " Extended: Get all of the values for the given key-path, along with their",
                " associated scope selector.",
                "",
                " * `keyPath` The {String} name of the key to retrieve",
                " * `options` (optional) {Object} see the `options` argument to {::get}",
                "",
                " Returns an {Array} of {Object}s with the following keys:",
                "  * `scopeDescriptor` The {ScopeDescriptor} with which the value is associated",
                "  * `value` The value for the key-path"
            ],
            "code": "  getAll (keyPath, options) {\r\n    let globalValue, result, scope\r\n    if (options != null) { ({scope} = options) }\r\n\r\n    if (scope != null) {\r\n      let legacyScopeDescriptor\r\n      const scopeDescriptor = ScopeDescriptor.fromObject(scope)\r\n      result = this.scopedSettingsStore.getAll(\r\n          scopeDescriptor.getScopeChain(),\r\n          keyPath,\r\n          options\r\n        )\r\n      legacyScopeDescriptor = this.getLegacyScopeDescriptorForNewScopeDescriptor(scopeDescriptor)\r\n      if (legacyScopeDescriptor) {\r\n        result.push(...Array.from(this.scopedSettingsStore.getAll(\r\n           legacyScopeDescriptor.getScopeChain(),\r\n           keyPath,\r\n           options\r\n         ) || []))\r\n      }\r\n    } else {\r\n      result = []\r\n    }\r\n\r\n    globalValue = this.getRawValue(keyPath, options)\r\n    if (globalValue) {\r\n      result.push({scopeSelector: '*', value: globalValue})\r\n    }\r\n\r\n    return result\r\n  }\r",
            "return_type": [
                "object",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.getLegacyScopeDescriptorForNewScopeDescriptor",
            "start_line": 825,
            "end_line": 827,
            "comment": [],
            "params": [
                "scopeDescriptor"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "getAll",
            "line": 627,
            "func_location": "Config.getAll",
            "func_start_line": 613,
            "func_end_line": 643
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.getAll",
            "start_line": 613,
            "end_line": 643,
            "comment": [
                " Extended: Get all of the values for the given key-path, along with their",
                " associated scope selector.",
                "",
                " * `keyPath` The {String} name of the key to retrieve",
                " * `options` (optional) {Object} see the `options` argument to {::get}",
                "",
                " Returns an {Array} of {Object}s with the following keys:",
                "  * `scopeDescriptor` The {ScopeDescriptor} with which the value is associated",
                "  * `value` The value for the key-path"
            ],
            "params": [
                {
                    "name": "keyPath",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": [
                "object",
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "getRawValue",
            "line": 637,
            "func_location": "Config.getAll",
            "func_start_line": 613,
            "func_end_line": 643,
            "args": [
                {
                    "name": "keyPath",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Extended: Get all of the values for the given key-path, along with their",
                " associated scope selector.",
                "",
                " * `keyPath` The {String} name of the key to retrieve",
                " * `options` (optional) {Object} see the `options` argument to {::get}",
                "",
                " Returns an {Array} of {Object}s with the following keys:",
                "  * `scopeDescriptor` The {ScopeDescriptor} with which the value is associated",
                "  * `value` The value for the key-path"
            ],
            "code": "  getAll (keyPath, options) {\r\n    let globalValue, result, scope\r\n    if (options != null) { ({scope} = options) }\r\n\r\n    if (scope != null) {\r\n      let legacyScopeDescriptor\r\n      const scopeDescriptor = ScopeDescriptor.fromObject(scope)\r\n      result = this.scopedSettingsStore.getAll(\r\n          scopeDescriptor.getScopeChain(),\r\n          keyPath,\r\n          options\r\n        )\r\n      legacyScopeDescriptor = this.getLegacyScopeDescriptorForNewScopeDescriptor(scopeDescriptor)\r\n      if (legacyScopeDescriptor) {\r\n        result.push(...Array.from(this.scopedSettingsStore.getAll(\r\n           legacyScopeDescriptor.getScopeChain(),\r\n           keyPath,\r\n           options\r\n         ) || []))\r\n      }\r\n    } else {\r\n      result = []\r\n    }\r\n\r\n    globalValue = this.getRawValue(keyPath, options)\r\n    if (globalValue) {\r\n      result.push({scopeSelector: '*', value: globalValue})\r\n    }\r\n\r\n    return result\r\n  }\r",
            "return_type": [
                "object",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.getRawValue",
            "start_line": 994,
            "end_line": 1018,
            "comment": [],
            "params": [
                "keyPath",
                "options"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "wordRegExp",
            "line": 536,
            "func_location": "Cursor.getBeginningOfCurrentWordBufferPosition",
            "func_start_line": 527,
            "func_end_line": 547,
            "args": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Retrieves the buffer position of where the current word starts.",
                "",
                " * `options` (optional) An {Object} with the following keys:",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "     (default: {::wordRegExp}).",
                "   * `includeNonWordCharacters` A {Boolean} indicating whether to include",
                "     non-word characters in the default word regex.",
                "     Has no effect if wordRegex is set.",
                "   * `allowPrevious` A {Boolean} indicating whether the beginning of the",
                "     previous word can be returned.",
                "",
                " Returns a {Range}."
            ],
            "code": "  getBeginningOfCurrentWordBufferPosition (options = {}) {\r\n    const allowPrevious = options.allowPrevious !== false\r\n    const position = this.getBufferPosition()\r\n\r\n    const scanRange = allowPrevious\r\n      ? new Range(new Point(position.row - 1, 0), position)\r\n      : new Range(new Point(position.row, 0), position)\r\n\r\n    const ranges = this.editor.buffer.findAllInRangeSync(\r\n      options.wordRegex || this.wordRegExp(options),\r\n      scanRange\r\n    )\r\n\r\n    let result\r\n    for (let range of ranges) {\r\n      if (position.isLessThanOrEqual(range.start)) break\r\n      if (allowPrevious || position.isLessThanOrEqual(range.end)) result = Point.fromObject(range.start)\r\n    }\r\n\r\n    return result || (allowPrevious ? new Point(0, 0) : position)\r\n  }\r",
            "return_type": [
                "object",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.wordRegExp",
            "start_line": 674,
            "end_line": 679
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "fromObject",
            "line": 543,
            "func_location": "Cursor.getBeginningOfCurrentWordBufferPosition",
            "func_start_line": 527,
            "func_end_line": 547,
            "args": [
                {
                    "name": "range.end",
                    "type": []
                }
            ],
            "comment": [
                " Public: Retrieves the buffer position of where the current word starts.",
                "",
                " * `options` (optional) An {Object} with the following keys:",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "     (default: {::wordRegExp}).",
                "   * `includeNonWordCharacters` A {Boolean} indicating whether to include",
                "     non-word characters in the default word regex.",
                "     Has no effect if wordRegex is set.",
                "   * `allowPrevious` A {Boolean} indicating whether the beginning of the",
                "     previous word can be returned.",
                "",
                " Returns a {Range}."
            ],
            "code": "  getBeginningOfCurrentWordBufferPosition (options = {}) {\r\n    const allowPrevious = options.allowPrevious !== false\r\n    const position = this.getBufferPosition()\r\n\r\n    const scanRange = allowPrevious\r\n      ? new Range(new Point(position.row - 1, 0), position)\r\n      : new Range(new Point(position.row, 0), position)\r\n\r\n    const ranges = this.editor.buffer.findAllInRangeSync(\r\n      options.wordRegex || this.wordRegExp(options),\r\n      scanRange\r\n    )\r\n\r\n    let result\r\n    for (let range of ranges) {\r\n      if (position.isLessThanOrEqual(range.start)) break\r\n      if (allowPrevious || position.isLessThanOrEqual(range.end)) result = Point.fromObject(range.start)\r\n    }\r\n\r\n    return result || (allowPrevious ? new Point(0, 0) : position)\r\n  }\r",
            "return_type": [
                "object",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/scope-descriptor.js",
            "name": "ScopeDescriptor.fromObject",
            "start_line": 22,
            "end_line": 28,
            "comment": [],
            "params": [
                "scopes"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "isInsideWord",
            "line": 589,
            "func_location": "Cursor.getBeginningOfNextWordBufferPosition",
            "func_start_line": 587,
            "func_end_line": 599,
            "args": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Retrieves the buffer position of where the next word starts.",
                "",
                " * `options` (optional) {Object}",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "     (default: {::wordRegExp}).",
                "",
                " Returns a {Range}"
            ],
            "code": "  getBeginningOfNextWordBufferPosition (options = {}) {\r\n    const currentBufferPosition = this.getBufferPosition()\r\n    const start = this.isInsideWord(options) ? this.getEndOfCurrentWordBufferPosition(options) : currentBufferPosition\r\n    const scanRange = [start, this.editor.getEofBufferPosition()]\r\n\r\n    let beginningOfNextWordPosition\r\n    this.editor.scanInBufferRange(options.wordRegex || this.wordRegExp(), scanRange, ({range, stop}) => {\r\n      beginningOfNextWordPosition = range.start\r\n      stop()\r\n    })\r\n\r\n    return beginningOfNextWordPosition || currentBufferPosition\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.isInsideWord",
            "start_line": 178,
            "end_line": 183,
            "comment": [
                " Public: Returns whether this cursor is between a word's start and end.",
                "",
                " * `options` (optional) {Object}",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "     (default: {::wordRegExp}).",
                "",
                " Returns a {Boolean}"
            ],
            "params": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "isInsideWord",
            "line": 589,
            "func_location": "Cursor.getBeginningOfNextWordBufferPosition",
            "func_start_line": 587,
            "func_end_line": 599,
            "args": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Retrieves the buffer position of where the next word starts.",
                "",
                " * `options` (optional) {Object}",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "     (default: {::wordRegExp}).",
                "",
                " Returns a {Range}"
            ],
            "code": "  getBeginningOfNextWordBufferPosition (options = {}) {\r\n    const currentBufferPosition = this.getBufferPosition()\r\n    const start = this.isInsideWord(options) ? this.getEndOfCurrentWordBufferPosition(options) : currentBufferPosition\r\n    const scanRange = [start, this.editor.getEofBufferPosition()]\r\n\r\n    let beginningOfNextWordPosition\r\n    this.editor.scanInBufferRange(options.wordRegex || this.wordRegExp(), scanRange, ({range, stop}) => {\r\n      beginningOfNextWordPosition = range.start\r\n      stop()\r\n    })\r\n\r\n    return beginningOfNextWordPosition || currentBufferPosition\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.isInsideWord",
            "start_line": 178,
            "end_line": 183,
            "comment": [
                " Public: Returns whether this cursor is between a word's start and end.",
                "",
                " * `options` (optional) {Object}",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "     (default: {::wordRegExp}).",
                "",
                " Returns a {Boolean}"
            ],
            "params": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getEndOfCurrentWordBufferPosition",
            "line": 589,
            "func_location": "Cursor.getBeginningOfNextWordBufferPosition",
            "func_start_line": 587,
            "func_end_line": 599,
            "args": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Retrieves the buffer position of where the next word starts.",
                "",
                " * `options` (optional) {Object}",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "     (default: {::wordRegExp}).",
                "",
                " Returns a {Range}"
            ],
            "code": "  getBeginningOfNextWordBufferPosition (options = {}) {\r\n    const currentBufferPosition = this.getBufferPosition()\r\n    const start = this.isInsideWord(options) ? this.getEndOfCurrentWordBufferPosition(options) : currentBufferPosition\r\n    const scanRange = [start, this.editor.getEofBufferPosition()]\r\n\r\n    let beginningOfNextWordPosition\r\n    this.editor.scanInBufferRange(options.wordRegex || this.wordRegExp(), scanRange, ({range, stop}) => {\r\n      beginningOfNextWordPosition = range.start\r\n      stop()\r\n    })\r\n\r\n    return beginningOfNextWordPosition || currentBufferPosition\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getEndOfCurrentWordBufferPosition",
            "start_line": 559,
            "end_line": 578,
            "comment": [
                " Public: Retrieves the buffer position of where the current word ends.",
                "",
                " * `options` (optional) {Object} with the following keys:",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "      (default: {::wordRegExp})",
                "   * `includeNonWordCharacters` A Boolean indicating whether to include",
                "     non-word characters in the default word regex. Has no effect if",
                "     wordRegex is set.",
                "",
                " Returns a {Range}."
            ],
            "params": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getEndOfCurrentWordBufferPosition",
            "line": 589,
            "func_location": "Cursor.getBeginningOfNextWordBufferPosition",
            "func_start_line": 587,
            "func_end_line": 599,
            "args": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Retrieves the buffer position of where the next word starts.",
                "",
                " * `options` (optional) {Object}",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "     (default: {::wordRegExp}).",
                "",
                " Returns a {Range}"
            ],
            "code": "  getBeginningOfNextWordBufferPosition (options = {}) {\r\n    const currentBufferPosition = this.getBufferPosition()\r\n    const start = this.isInsideWord(options) ? this.getEndOfCurrentWordBufferPosition(options) : currentBufferPosition\r\n    const scanRange = [start, this.editor.getEofBufferPosition()]\r\n\r\n    let beginningOfNextWordPosition\r\n    this.editor.scanInBufferRange(options.wordRegex || this.wordRegExp(), scanRange, ({range, stop}) => {\r\n      beginningOfNextWordPosition = range.start\r\n      stop()\r\n    })\r\n\r\n    return beginningOfNextWordPosition || currentBufferPosition\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getEndOfCurrentWordBufferPosition",
            "start_line": 559,
            "end_line": 578,
            "comment": [
                " Public: Retrieves the buffer position of where the current word ends.",
                "",
                " * `options` (optional) {Object} with the following keys:",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "      (default: {::wordRegExp})",
                "   * `includeNonWordCharacters` A Boolean indicating whether to include",
                "     non-word characters in the default word regex. Has no effect if",
                "     wordRegex is set.",
                "",
                " Returns a {Range}."
            ],
            "params": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "relativize",
            "line": 398,
            "func_location": "GitRepository.getCachedPathStatus",
            "func_start_line": 397,
            "func_end_line": 399,
            "args": [
                {
                    "name": "path",
                    "type": [
                        "string"
                    ]
                }
            ],
            "comment": [
                " Public: Get the cached status for the given path.",
                "",
                " * `path` A {String} path in the repository, relative or absolute.",
                "",
                " Returns a status {Number} or null if the path is not in the cache."
            ],
            "code": "  getCachedPathStatus (path) {\r\n    return this.statuses[this.relativize(path)]\r\n  }\r",
            "return_type": [
                "number",
                "null"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.relativize",
            "start_line": 208,
            "end_line": 210,
            "comment": [
                " Public: Makes a path relative to the repository's working directory."
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "number",
                "null"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "relativize",
            "line": 398,
            "func_location": "GitRepository.getCachedPathStatus",
            "func_start_line": 397,
            "func_end_line": 399,
            "args": [
                {
                    "name": "path",
                    "type": [
                        "string"
                    ]
                }
            ],
            "comment": [
                " Public: Get the cached status for the given path.",
                "",
                " * `path` A {String} path in the repository, relative or absolute.",
                "",
                " Returns a status {Number} or null if the path is not in the cache."
            ],
            "code": "  getCachedPathStatus (path) {\r\n    return this.statuses[this.relativize(path)]\r\n  }\r",
            "return_type": [
                "number",
                "null"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.relativize",
            "start_line": 208,
            "end_line": 210,
            "comment": [
                " Public: Makes a path relative to the repository's working directory."
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "number",
                "null"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 268,
            "func_location": "GitRepository.getCachedUpstreamAheadBehindCount",
            "func_start_line": 267,
            "func_end_line": 269,
            "args": [
                {
                    "name": "path",
                    "type": [
                        "string",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Get the cached ahead/behind commit counts for the current branch's",
                " upstream branch.",
                "",
                " * `path` An optional {String} path in the repository to get this information",
                "   for, only needed if the repository has submodules.",
                "",
                " Returns an {Object} with the following keys:",
                "   * `ahead`  The {Number} of commits ahead.",
                "   * `behind` The {Number} of commits behind."
            ],
            "code": "  getCachedUpstreamAheadBehindCount (path) {\r\n    return this.getRepo(path).upstream || this.upstream\r\n  }\r",
            "return_type": [
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "object"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 268,
            "func_location": "GitRepository.getCachedUpstreamAheadBehindCount",
            "func_start_line": 267,
            "func_end_line": 269,
            "args": [
                {
                    "name": "path",
                    "type": [
                        "string",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Get the cached ahead/behind commit counts for the current branch's",
                " upstream branch.",
                "",
                " * `path` An optional {String} path in the repository to get this information",
                "   for, only needed if the repository has submodules.",
                "",
                " Returns an {Object} with the following keys:",
                "   * `ahead`  The {Number} of commits ahead.",
                "   * `behind` The {Number} of commits behind."
            ],
            "code": "  getCachedUpstreamAheadBehindCount (path) {\r\n    return this.getRepo(path).upstream || this.upstream\r\n  }\r",
            "return_type": [
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "object"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/start.js",
            "name": "resetUserSettings",
            "line": 118,
            "func_location": "getConfig",
            "func_start_line": 106,
            "func_end_line": 122,
            "args": [
                "configFileData"
            ],
            "code": "function getConfig () {\r\n  const config = new Config()\r\n\r\n  let configFilePath\r\n  if (fs.existsSync(path.join(process.env.ATOM_HOME, 'config.json'))) {\r\n    configFilePath = path.join(process.env.ATOM_HOME, 'config.json')\r\n  } else if (fs.existsSync(path.join(process.env.ATOM_HOME, 'config.cson'))) {\r\n    configFilePath = path.join(process.env.ATOM_HOME, 'config.cson')\r\n  }\r\n\r\n  if (configFilePath) {\r\n    const configFileData = CSON.readFileSync(configFilePath)\r\n    config.resetUserSettings(configFileData)\r\n  }\r\n\r\n  return config\r\n}\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.resetUserSettings",
            "start_line": 936,
            "end_line": 938,
            "comment": [
                "\r\n  Section: Private methods managing global settings\r\n  "
            ],
            "params": [
                {
                    "name": "newSettings",
                    "type": []
                },
                {
                    "name": "options",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 277,
            "func_location": "GitRepository.getConfigValue",
            "func_start_line": 276,
            "func_end_line": 278,
            "args": [
                {
                    "name": "key",
                    "type": [
                        "string"
                    ]
                }
            ],
            "comment": [
                " Public: Returns the git configuration value specified by the key.",
                "",
                " * `key`  The {String} key for the configuration to lookup.",
                " * `path` An optional {String} path in the repository to get this information",
                "   for, only needed if the repository has submodules."
            ],
            "code": "  getConfigValue (key, path) {\r\n    return this.getRepo(path).getConfigValue(key)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 277,
            "func_location": "GitRepository.getConfigValue",
            "func_start_line": 276,
            "func_end_line": 278,
            "args": [
                {
                    "name": "key",
                    "type": [
                        "string"
                    ]
                }
            ],
            "comment": [
                " Public: Returns the git configuration value specified by the key.",
                "",
                " * `key`  The {String} key for the configuration to lookup.",
                " * `path` An optional {String} path in the repository to get this information",
                "   for, only needed if the repository has submodules."
            ],
            "code": "  getConfigValue (key, path) {\r\n    return this.getRepo(path).getConfigValue(key)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getConfigValue",
            "line": 277,
            "func_location": "GitRepository.getConfigValue",
            "func_start_line": 276,
            "func_end_line": 278,
            "args": [
                {
                    "name": "key",
                    "type": [
                        "string"
                    ]
                }
            ],
            "comment": [
                " Public: Returns the git configuration value specified by the key.",
                "",
                " * `key`  The {String} key for the configuration to lookup.",
                " * `path` An optional {String} path in the repository to get this information",
                "   for, only needed if the repository has submodules."
            ],
            "code": "  getConfigValue (key, path) {\r\n    return this.getRepo(path).getConfigValue(key)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getConfigValue",
            "start_line": 276,
            "end_line": 278,
            "comment": [
                " Public: Returns the git configuration value specified by the key.",
                "",
                " * `key`  The {String} key for the configuration to lookup.",
                " * `path` An optional {String} path in the repository to get this information",
                "   for, only needed if the repository has submodules."
            ],
            "params": [
                {
                    "name": "key",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "path",
                    "type": [
                        "string",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getConfigValue",
            "line": 277,
            "func_location": "GitRepository.getConfigValue",
            "func_start_line": 276,
            "func_end_line": 278,
            "args": [
                {
                    "name": "key",
                    "type": [
                        "string"
                    ]
                }
            ],
            "comment": [
                " Public: Returns the git configuration value specified by the key.",
                "",
                " * `key`  The {String} key for the configuration to lookup.",
                " * `path` An optional {String} path in the repository to get this information",
                "   for, only needed if the repository has submodules."
            ],
            "code": "  getConfigValue (key, path) {\r\n    return this.getRepo(path).getConfigValue(key)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getConfigValue",
            "start_line": 276,
            "end_line": 278,
            "comment": [
                " Public: Returns the git configuration value specified by the key.",
                "",
                " * `key`  The {String} key for the configuration to lookup.",
                " * `path` An optional {String} path in the repository to get this information",
                "   for, only needed if the repository has submodules."
            ],
            "params": [
                {
                    "name": "key",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "path",
                    "type": [
                        "string",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getBufferRow",
            "line": 118,
            "func_location": "Cursor.getCurrentBufferLine",
            "func_start_line": 117,
            "func_end_line": 119,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Returns the cursor's current buffer row of text excluding its line",
                " ending."
            ],
            "code": "  getCurrentBufferLine () {\r\n    return this.editor.lineTextForBufferRow(this.getBufferRow())\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getBufferRow",
            "start_line": 106,
            "end_line": 108,
            "comment": [
                " Public: Retrieves the cursor's current buffer row."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getBufferRow",
            "line": 624,
            "func_location": "Cursor.getCurrentLineBufferRange",
            "func_start_line": 623,
            "func_end_line": 625,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Returns the buffer Range for the current line.",
                "",
                " * `options` (optional) {Object}",
                "   * `includeNewline` A {Boolean} which controls whether the Range should",
                "     include the newline."
            ],
            "code": "  getCurrentLineBufferRange (options) {\r\n    return this.editor.bufferRangeForBufferRow(this.getBufferRow(), options)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getBufferRow",
            "start_line": 106,
            "end_line": 108,
            "comment": [
                " Public: Retrieves the cursor's current buffer row."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getBufferRow",
            "line": 633,
            "func_location": "Cursor.getCurrentParagraphBufferRange",
            "func_start_line": 632,
            "func_end_line": 634,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Retrieves the range for the current paragraph.",
                "",
                " A paragraph is defined as a block of text surrounded by empty lines or comments.",
                "",
                " Returns a {Range}."
            ],
            "code": "  getCurrentParagraphBufferRange () {\r\n    return this.editor.rowRangeForParagraphAtBufferRow(this.getBufferRow())\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getBufferRow",
            "start_line": 106,
            "end_line": 108,
            "comment": [
                " Public: Retrieves the cursor's current buffer row."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "wordRegExp",
            "line": 609,
            "func_location": "Cursor.getCurrentWordBufferRange",
            "func_start_line": 606,
            "func_end_line": 616,
            "args": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Returns the buffer Range occupied by the word located under the cursor.",
                "",
                " * `options` (optional) {Object}",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "     (default: {::wordRegExp})."
            ],
            "code": "  getCurrentWordBufferRange (options = {}) {\r\n    const position = this.getBufferPosition()\r\n    const ranges = this.editor.buffer.findAllInRangeSync(\r\n      options.wordRegex || this.wordRegExp(options),\r\n      new Range(new Point(position.row, 0), new Point(position.row, Infinity))\r\n    )\r\n    const range = ranges.find(range =>\r\n      range.end.column >= position.column && range.start.column <= position.column\r\n    )\r\n    return range ? Range.fromObject(range) : new Range(position, position)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.wordRegExp",
            "start_line": 674,
            "end_line": 679
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "fromObject",
            "line": 615,
            "func_location": "Cursor.getCurrentWordBufferRange",
            "func_start_line": 606,
            "func_end_line": 616,
            "args": [
                {
                    "name": "range",
                    "type": []
                }
            ],
            "comment": [
                " Public: Returns the buffer Range occupied by the word located under the cursor.",
                "",
                " * `options` (optional) {Object}",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "     (default: {::wordRegExp})."
            ],
            "code": "  getCurrentWordBufferRange (options = {}) {\r\n    const position = this.getBufferPosition()\r\n    const ranges = this.editor.buffer.findAllInRangeSync(\r\n      options.wordRegex || this.wordRegExp(options),\r\n      new Range(new Point(position.row, 0), new Point(position.row, Infinity))\r\n    )\r\n    const range = ranges.find(range =>\r\n      range.end.column >= position.column && range.start.column <= position.column\r\n    )\r\n    return range ? Range.fromObject(range) : new Range(position, position)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/scope-descriptor.js",
            "name": "ScopeDescriptor.fromObject",
            "start_line": 22,
            "end_line": 28,
            "comment": [],
            "params": [
                "scopes"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getBeginningOfCurrentWordBufferPosition",
            "line": 638,
            "func_location": "Cursor.getCurrentWordPrefix",
            "func_start_line": 637,
            "func_end_line": 639,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Returns the characters preceding the cursor in the current word."
            ],
            "code": "  getCurrentWordPrefix () {\r\n    return this.editor.getTextInBufferRange([this.getBeginningOfCurrentWordBufferPosition(), this.getBufferPosition()])\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getBeginningOfCurrentWordBufferPosition",
            "start_line": 527,
            "end_line": 547,
            "comment": [
                " Public: Retrieves the buffer position of where the current word starts.",
                "",
                " * `options` (optional) An {Object} with the following keys:",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "     (default: {::wordRegExp}).",
                "   * `includeNonWordCharacters` A {Boolean} indicating whether to include",
                "     non-word characters in the default word regex.",
                "     Has no effect if wordRegex is set.",
                "   * `allowPrevious` A {Boolean} indicating whether the beginning of the",
                "     previous word can be returned.",
                "",
                " Returns a {Range}."
            ],
            "params": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getBeginningOfCurrentWordBufferPosition",
            "line": 638,
            "func_location": "Cursor.getCurrentWordPrefix",
            "func_start_line": 637,
            "func_end_line": 639,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Returns the characters preceding the cursor in the current word."
            ],
            "code": "  getCurrentWordPrefix () {\r\n    return this.editor.getTextInBufferRange([this.getBeginningOfCurrentWordBufferPosition(), this.getBufferPosition()])\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getBeginningOfCurrentWordBufferPosition",
            "start_line": 527,
            "end_line": 547,
            "comment": [
                " Public: Retrieves the buffer position of where the current word starts.",
                "",
                " * `options` (optional) An {Object} with the following keys:",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "     (default: {::wordRegExp}).",
                "   * `includeNonWordCharacters` A {Boolean} indicating whether to include",
                "     non-word characters in the default word regex.",
                "     Has no effect if wordRegex is set.",
                "   * `allowPrevious` A {Boolean} indicating whether the beginning of the",
                "     previous word can be returned.",
                "",
                " Returns a {Range}."
            ],
            "params": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getBufferPosition",
            "line": 638,
            "func_location": "Cursor.getCurrentWordPrefix",
            "func_start_line": 637,
            "func_end_line": 639,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Returns the characters preceding the cursor in the current word."
            ],
            "code": "  getCurrentWordPrefix () {\r\n    return this.editor.getTextInBufferRange([this.getBeginningOfCurrentWordBufferPosition(), this.getBufferPosition()])\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getBufferPosition",
            "start_line": 91,
            "end_line": 93,
            "comment": [
                " Public: Returns the current buffer position as an Array."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 432,
            "func_location": "GitRepository.getDiffStats",
            "func_start_line": 431,
            "func_end_line": 434,
            "args": [
                {
                    "name": "path",
                    "type": [
                        "number",
                        "string"
                    ]
                }
            ],
            "comment": [
                "\r\n  Section: Retrieving Diffs\r\n  ",
                " Public: Retrieves the number of lines added and removed to a path.",
                "",
                " This compares the working directory contents of the path to the `HEAD`",
                " version.",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns an {Object} with the following keys:",
                "   * `added` The {Number} of added lines.",
                "   * `deleted` The {Number} of deleted lines."
            ],
            "code": "  getDiffStats (path) {\r\n    const repo = this.getRepo(path)\r\n    return repo.getDiffStats(repo.relativize(path))\r\n  }\r",
            "return_type": [
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "object"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 432,
            "func_location": "GitRepository.getDiffStats",
            "func_start_line": 431,
            "func_end_line": 434,
            "args": [
                {
                    "name": "path",
                    "type": [
                        "number",
                        "string"
                    ]
                }
            ],
            "comment": [
                "\r\n  Section: Retrieving Diffs\r\n  ",
                " Public: Retrieves the number of lines added and removed to a path.",
                "",
                " This compares the working directory contents of the path to the `HEAD`",
                " version.",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns an {Object} with the following keys:",
                "   * `added` The {Number} of added lines.",
                "   * `deleted` The {Number} of deleted lines."
            ],
            "code": "  getDiffStats (path) {\r\n    const repo = this.getRepo(path)\r\n    return repo.getDiffStats(repo.relativize(path))\r\n  }\r",
            "return_type": [
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "object"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getDiffStats",
            "line": 433,
            "func_location": "GitRepository.getDiffStats",
            "func_start_line": 431,
            "func_end_line": 434,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Retrieving Diffs\r\n  ",
                " Public: Retrieves the number of lines added and removed to a path.",
                "",
                " This compares the working directory contents of the path to the `HEAD`",
                " version.",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns an {Object} with the following keys:",
                "   * `added` The {Number} of added lines.",
                "   * `deleted` The {Number} of deleted lines."
            ],
            "code": "  getDiffStats (path) {\r\n    const repo = this.getRepo(path)\r\n    return repo.getDiffStats(repo.relativize(path))\r\n  }\r",
            "return_type": [
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getDiffStats",
            "start_line": 431,
            "end_line": 434,
            "comment": [
                "\r\n  Section: Retrieving Diffs\r\n  ",
                " Public: Retrieves the number of lines added and removed to a path.",
                "",
                " This compares the working directory contents of the path to the `HEAD`",
                " version.",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns an {Object} with the following keys:",
                "   * `added` The {Number} of added lines.",
                "   * `deleted` The {Number} of deleted lines."
            ],
            "params": [
                {
                    "name": "path",
                    "type": [
                        "number",
                        "string"
                    ]
                }
            ],
            "return_type": [
                "object"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getDiffStats",
            "line": 433,
            "func_location": "GitRepository.getDiffStats",
            "func_start_line": 431,
            "func_end_line": 434,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Retrieving Diffs\r\n  ",
                " Public: Retrieves the number of lines added and removed to a path.",
                "",
                " This compares the working directory contents of the path to the `HEAD`",
                " version.",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns an {Object} with the following keys:",
                "   * `added` The {Number} of added lines.",
                "   * `deleted` The {Number} of deleted lines."
            ],
            "code": "  getDiffStats (path) {\r\n    const repo = this.getRepo(path)\r\n    return repo.getDiffStats(repo.relativize(path))\r\n  }\r",
            "return_type": [
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getDiffStats",
            "start_line": 431,
            "end_line": 434,
            "comment": [
                "\r\n  Section: Retrieving Diffs\r\n  ",
                " Public: Retrieves the number of lines added and removed to a path.",
                "",
                " This compares the working directory contents of the path to the `HEAD`",
                " version.",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns an {Object} with the following keys:",
                "   * `added` The {Number} of added lines.",
                "   * `deleted` The {Number} of deleted lines."
            ],
            "params": [
                {
                    "name": "path",
                    "type": [
                        "number",
                        "string"
                    ]
                }
            ],
            "return_type": [
                "object"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "relativize",
            "line": 433,
            "func_location": "GitRepository.getDiffStats",
            "func_start_line": 431,
            "func_end_line": 434,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Retrieving Diffs\r\n  ",
                " Public: Retrieves the number of lines added and removed to a path.",
                "",
                " This compares the working directory contents of the path to the `HEAD`",
                " version.",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns an {Object} with the following keys:",
                "   * `added` The {Number} of added lines.",
                "   * `deleted` The {Number} of deleted lines."
            ],
            "code": "  getDiffStats (path) {\r\n    const repo = this.getRepo(path)\r\n    return repo.getDiffStats(repo.relativize(path))\r\n  }\r",
            "return_type": [
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.relativize",
            "start_line": 208,
            "end_line": 210,
            "comment": [
                " Public: Makes a path relative to the repository's working directory."
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "object"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "relativize",
            "line": 433,
            "func_location": "GitRepository.getDiffStats",
            "func_start_line": 431,
            "func_end_line": 434,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Retrieving Diffs\r\n  ",
                " Public: Retrieves the number of lines added and removed to a path.",
                "",
                " This compares the working directory contents of the path to the `HEAD`",
                " version.",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns an {Object} with the following keys:",
                "   * `added` The {Number} of added lines.",
                "   * `deleted` The {Number} of deleted lines."
            ],
            "code": "  getDiffStats (path) {\r\n    const repo = this.getRepo(path)\r\n    return repo.getDiffStats(repo.relativize(path))\r\n  }\r",
            "return_type": [
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.relativize",
            "start_line": 208,
            "end_line": 210,
            "comment": [
                " Public: Makes a path relative to the repository's working directory."
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "object"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/panel.js",
            "name": "getView",
            "line": 42,
            "func_location": "Panel.getElement",
            "func_start_line": 37,
            "func_end_line": 45,
            "args": [
                null
            ],
            "code": "  getElement () {\r\n    if (!this.element) {\r\n      this.element = document.createElement('atom-panel')\r\n      if (!this.visible) this.element.style.display = 'none'\r\n      if (this.className) this.element.classList.add(...this.className.split(' '))\r\n      this.element.appendChild(this.viewRegistry.getView(this.item))\r\n    }\r\n    return this.element\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/view-registry.js",
            "name": "ViewRegistry.getView",
            "start_line": 122,
            "end_line": 131,
            "comment": [
                " Essential: Get the view associated with an object in the workspace.",
                "",
                " If you're just *using* the workspace, you shouldn't need to access the view",
                " layer, but view layer access may be necessary if you want to perform DOM",
                " manipulation that isn't supported via the model API.",
                "",
                " ## View Resolution Algorithm",
                "",
                " The view associated with the object is resolved using the following",
                " sequence",
                "",
                "  1. Is the object an instance of `HTMLElement`? If true, return the object.",
                "  2. Does the object have a method named `getElement` that returns an",
                "     instance of `HTMLElement`? If true, return that value.",
                "  3. Does the object have a property named `element` with a value which is",
                "     an instance of `HTMLElement`? If true, return the property value.",
                "  4. Is the object a jQuery object, indicated by the presence of a `jquery`",
                "     property? If true, return the root DOM element (i.e. `object[0]`).",
                "  5. Has a view provider been registered for the object? If true, use the",
                "     provider to create a view associated with the object, and return the",
                "     view.",
                "",
                " If no associated view is returned by the sequence an error is thrown.",
                "",
                " Returns a DOM element."
            ],
            "params": [
                {
                    "name": "object",
                    "type": [
                        "object"
                    ]
                }
            ],
            "return_type": [
                "object",
                "string",
                "null"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "wordRegExp",
            "line": 568,
            "func_location": "Cursor.getEndOfCurrentWordBufferPosition",
            "func_start_line": 559,
            "func_end_line": 578,
            "args": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Retrieves the buffer position of where the current word ends.",
                "",
                " * `options` (optional) {Object} with the following keys:",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "      (default: {::wordRegExp})",
                "   * `includeNonWordCharacters` A Boolean indicating whether to include",
                "     non-word characters in the default word regex. Has no effect if",
                "     wordRegex is set.",
                "",
                " Returns a {Range}."
            ],
            "code": "  getEndOfCurrentWordBufferPosition (options = {}) {\r\n    const allowNext = options.allowNext !== false\r\n    const position = this.getBufferPosition()\r\n\r\n    const scanRange = allowNext\r\n      ? new Range(position, new Point(position.row + 2, 0))\r\n      : new Range(position, new Point(position.row, Infinity))\r\n\r\n    const ranges = this.editor.buffer.findAllInRangeSync(\r\n      options.wordRegex || this.wordRegExp(options),\r\n      scanRange\r\n    )\r\n\r\n    for (let range of ranges) {\r\n      if (position.isLessThan(range.start) && !allowNext) break\r\n      if (position.isLessThan(range.end)) return Point.fromObject(range.end)\r\n    }\r\n\r\n    return allowNext ? this.editor.getEofBufferPosition() : position\r\n  }\r",
            "return_type": [
                "object",
                "string",
                "null"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.wordRegExp",
            "start_line": 674,
            "end_line": 679
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "fromObject",
            "line": 574,
            "func_location": "Cursor.getEndOfCurrentWordBufferPosition",
            "func_start_line": 559,
            "func_end_line": 578,
            "args": [
                {
                    "name": "range.end",
                    "type": []
                }
            ],
            "comment": [
                " Public: Retrieves the buffer position of where the current word ends.",
                "",
                " * `options` (optional) {Object} with the following keys:",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "      (default: {::wordRegExp})",
                "   * `includeNonWordCharacters` A Boolean indicating whether to include",
                "     non-word characters in the default word regex. Has no effect if",
                "     wordRegex is set.",
                "",
                " Returns a {Range}."
            ],
            "code": "  getEndOfCurrentWordBufferPosition (options = {}) {\r\n    const allowNext = options.allowNext !== false\r\n    const position = this.getBufferPosition()\r\n\r\n    const scanRange = allowNext\r\n      ? new Range(position, new Point(position.row + 2, 0))\r\n      : new Range(position, new Point(position.row, Infinity))\r\n\r\n    const ranges = this.editor.buffer.findAllInRangeSync(\r\n      options.wordRegex || this.wordRegExp(options),\r\n      scanRange\r\n    )\r\n\r\n    for (let range of ranges) {\r\n      if (position.isLessThan(range.start) && !allowNext) break\r\n      if (position.isLessThan(range.end)) return Point.fromObject(range.end)\r\n    }\r\n\r\n    return allowNext ? this.editor.getEofBufferPosition() : position\r\n  }\r",
            "return_type": [
                "object",
                "string",
                "null"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/scope-descriptor.js",
            "name": "ScopeDescriptor.fromObject",
            "start_line": 22,
            "end_line": 28,
            "comment": [],
            "params": [
                "scopes"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "getBuffer",
            "line": 208,
            "func_location": "TextEditorRegistry.getGrammarOverride",
            "func_start_line": 207,
            "func_end_line": 209,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Deprecated: Retrieve the grammar scope name that has been set as a",
                " grammar override for the given {TextEditor}.",
                "",
                " * `editor` The editor.",
                "",
                " Returns a {String} scope name, or `null` if no override has been set",
                " for the given editor."
            ],
            "code": "  getGrammarOverride (editor) {\r\n    return atom.grammars.getAssignedLanguageId(editor.getBuffer())\r\n  }\r",
            "return_type": [
                "object",
                "string",
                "null"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.getBuffer",
            "start_line": 963,
            "end_line": 963,
            "comment": [
                " Essential: Retrieves the current {TextBuffer}."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 451,
            "func_location": "GitRepository.getLineDiffs",
            "func_start_line": 447,
            "func_end_line": 453,
            "args": [
                {
                    "name": "path",
                    "type": [
                        "string"
                    ]
                }
            ],
            "comment": [
                " Public: Retrieves the line diffs comparing the `HEAD` version of the given",
                " path and the given text.",
                "",
                " * `path` The {String} path relative to the repository.",
                " * `text` The {String} to compare against the `HEAD` contents",
                "",
                " Returns an {Array} of hunk {Object}s with the following keys:",
                "   * `oldStart` The line {Number} of the old hunk.",
                "   * `newStart` The line {Number} of the new hunk.",
                "   * `oldLines` The {Number} of lines in the old hunk.",
                "   * `newLines` The {Number} of lines in the new hunk"
            ],
            "code": "  getLineDiffs (path, text) {\r\n    // Ignore eol of line differences on windows so that files checked in as\r\n    // LF don't report every line modified when the text contains CRLF endings.\r\n    const options = {ignoreEolWhitespace: process.platform === 'win32'}\r\n    const repo = this.getRepo(path)\r\n    return repo.getLineDiffs(repo.relativize(path), text, options)\r\n  }\r",
            "return_type": [
                "object",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "object",
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 451,
            "func_location": "GitRepository.getLineDiffs",
            "func_start_line": 447,
            "func_end_line": 453,
            "args": [
                {
                    "name": "path",
                    "type": [
                        "string"
                    ]
                }
            ],
            "comment": [
                " Public: Retrieves the line diffs comparing the `HEAD` version of the given",
                " path and the given text.",
                "",
                " * `path` The {String} path relative to the repository.",
                " * `text` The {String} to compare against the `HEAD` contents",
                "",
                " Returns an {Array} of hunk {Object}s with the following keys:",
                "   * `oldStart` The line {Number} of the old hunk.",
                "   * `newStart` The line {Number} of the new hunk.",
                "   * `oldLines` The {Number} of lines in the old hunk.",
                "   * `newLines` The {Number} of lines in the new hunk"
            ],
            "code": "  getLineDiffs (path, text) {\r\n    // Ignore eol of line differences on windows so that files checked in as\r\n    // LF don't report every line modified when the text contains CRLF endings.\r\n    const options = {ignoreEolWhitespace: process.platform === 'win32'}\r\n    const repo = this.getRepo(path)\r\n    return repo.getLineDiffs(repo.relativize(path), text, options)\r\n  }\r",
            "return_type": [
                "object",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "object",
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getLineDiffs",
            "line": 452,
            "func_location": "GitRepository.getLineDiffs",
            "func_start_line": 447,
            "func_end_line": 453,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": "text",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "options",
                    "type": []
                }
            ],
            "comment": [
                " Public: Retrieves the line diffs comparing the `HEAD` version of the given",
                " path and the given text.",
                "",
                " * `path` The {String} path relative to the repository.",
                " * `text` The {String} to compare against the `HEAD` contents",
                "",
                " Returns an {Array} of hunk {Object}s with the following keys:",
                "   * `oldStart` The line {Number} of the old hunk.",
                "   * `newStart` The line {Number} of the new hunk.",
                "   * `oldLines` The {Number} of lines in the old hunk.",
                "   * `newLines` The {Number} of lines in the new hunk"
            ],
            "code": "  getLineDiffs (path, text) {\r\n    // Ignore eol of line differences on windows so that files checked in as\r\n    // LF don't report every line modified when the text contains CRLF endings.\r\n    const options = {ignoreEolWhitespace: process.platform === 'win32'}\r\n    const repo = this.getRepo(path)\r\n    return repo.getLineDiffs(repo.relativize(path), text, options)\r\n  }\r",
            "return_type": [
                "object",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getLineDiffs",
            "start_line": 447,
            "end_line": 453,
            "comment": [
                " Public: Retrieves the line diffs comparing the `HEAD` version of the given",
                " path and the given text.",
                "",
                " * `path` The {String} path relative to the repository.",
                " * `text` The {String} to compare against the `HEAD` contents",
                "",
                " Returns an {Array} of hunk {Object}s with the following keys:",
                "   * `oldStart` The line {Number} of the old hunk.",
                "   * `newStart` The line {Number} of the new hunk.",
                "   * `oldLines` The {Number} of lines in the old hunk.",
                "   * `newLines` The {Number} of lines in the new hunk"
            ],
            "params": [
                {
                    "name": "path",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "text",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "object",
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getLineDiffs",
            "line": 452,
            "func_location": "GitRepository.getLineDiffs",
            "func_start_line": 447,
            "func_end_line": 453,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": "text",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "options",
                    "type": []
                }
            ],
            "comment": [
                " Public: Retrieves the line diffs comparing the `HEAD` version of the given",
                " path and the given text.",
                "",
                " * `path` The {String} path relative to the repository.",
                " * `text` The {String} to compare against the `HEAD` contents",
                "",
                " Returns an {Array} of hunk {Object}s with the following keys:",
                "   * `oldStart` The line {Number} of the old hunk.",
                "   * `newStart` The line {Number} of the new hunk.",
                "   * `oldLines` The {Number} of lines in the old hunk.",
                "   * `newLines` The {Number} of lines in the new hunk"
            ],
            "code": "  getLineDiffs (path, text) {\r\n    // Ignore eol of line differences on windows so that files checked in as\r\n    // LF don't report every line modified when the text contains CRLF endings.\r\n    const options = {ignoreEolWhitespace: process.platform === 'win32'}\r\n    const repo = this.getRepo(path)\r\n    return repo.getLineDiffs(repo.relativize(path), text, options)\r\n  }\r",
            "return_type": [
                "object",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getLineDiffs",
            "start_line": 447,
            "end_line": 453,
            "comment": [
                " Public: Retrieves the line diffs comparing the `HEAD` version of the given",
                " path and the given text.",
                "",
                " * `path` The {String} path relative to the repository.",
                " * `text` The {String} to compare against the `HEAD` contents",
                "",
                " Returns an {Array} of hunk {Object}s with the following keys:",
                "   * `oldStart` The line {Number} of the old hunk.",
                "   * `newStart` The line {Number} of the new hunk.",
                "   * `oldLines` The {Number} of lines in the old hunk.",
                "   * `newLines` The {Number} of lines in the new hunk"
            ],
            "params": [
                {
                    "name": "path",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "text",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "object",
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "relativize",
            "line": 452,
            "func_location": "GitRepository.getLineDiffs",
            "func_start_line": 447,
            "func_end_line": 453,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": "text",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "options",
                    "type": []
                }
            ],
            "comment": [
                " Public: Retrieves the line diffs comparing the `HEAD` version of the given",
                " path and the given text.",
                "",
                " * `path` The {String} path relative to the repository.",
                " * `text` The {String} to compare against the `HEAD` contents",
                "",
                " Returns an {Array} of hunk {Object}s with the following keys:",
                "   * `oldStart` The line {Number} of the old hunk.",
                "   * `newStart` The line {Number} of the new hunk.",
                "   * `oldLines` The {Number} of lines in the old hunk.",
                "   * `newLines` The {Number} of lines in the new hunk"
            ],
            "code": "  getLineDiffs (path, text) {\r\n    // Ignore eol of line differences on windows so that files checked in as\r\n    // LF don't report every line modified when the text contains CRLF endings.\r\n    const options = {ignoreEolWhitespace: process.platform === 'win32'}\r\n    const repo = this.getRepo(path)\r\n    return repo.getLineDiffs(repo.relativize(path), text, options)\r\n  }\r",
            "return_type": [
                "object",
                "array",
                "string"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.relativize",
            "start_line": 208,
            "end_line": 210,
            "comment": [
                " Public: Makes a path relative to the repository's working directory."
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "object",
                "array",
                "string"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "relativize",
            "line": 452,
            "func_location": "GitRepository.getLineDiffs",
            "func_start_line": 447,
            "func_end_line": 453,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": "text",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "options",
                    "type": []
                }
            ],
            "comment": [
                " Public: Retrieves the line diffs comparing the `HEAD` version of the given",
                " path and the given text.",
                "",
                " * `path` The {String} path relative to the repository.",
                " * `text` The {String} to compare against the `HEAD` contents",
                "",
                " Returns an {Array} of hunk {Object}s with the following keys:",
                "   * `oldStart` The line {Number} of the old hunk.",
                "   * `newStart` The line {Number} of the new hunk.",
                "   * `oldLines` The {Number} of lines in the old hunk.",
                "   * `newLines` The {Number} of lines in the new hunk"
            ],
            "code": "  getLineDiffs (path, text) {\r\n    // Ignore eol of line differences on windows so that files checked in as\r\n    // LF don't report every line modified when the text contains CRLF endings.\r\n    const options = {ignoreEolWhitespace: process.platform === 'win32'}\r\n    const repo = this.getRepo(path)\r\n    return repo.getLineDiffs(repo.relativize(path), text, options)\r\n  }\r",
            "return_type": [
                "object",
                "array",
                "string"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.relativize",
            "start_line": 208,
            "end_line": 210,
            "comment": [
                " Public: Makes a path relative to the repository's working directory."
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "object",
                "array",
                "string"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/theme-manager.js",
            "name": "getLoadedThemes",
            "line": 74,
            "func_location": "ThemeManager.getLoadedThemeNames",
            "func_start_line": 73,
            "func_end_line": 75,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Accessing Loaded Themes\r\n  ",
                " Public: Returns an {Array} of {String}s of all the loaded theme names."
            ],
            "code": "  getLoadedThemeNames () {\r\n    return this.getLoadedThemes().map((theme) => theme.name)\r\n  }\r",
            "return_type": [
                "object",
                "array",
                "string"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/theme-manager.js",
            "name": "ThemeManager.getLoadedThemes",
            "start_line": 78,
            "end_line": 80,
            "comment": [
                " Public: Returns an {Array} of all the loaded themes."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "fromObject",
            "line": 506,
            "func_location": "Cursor.getNextWordBoundaryBufferPosition",
            "func_start_line": 493,
            "func_end_line": 513,
            "args": [
                {
                    "name": "range.start",
                    "type": []
                }
            ],
            "comment": [
                " Public: Returns buffer position of the next word boundary. It might be on",
                " the current word, or the previous word.",
                "",
                " * `options` (optional) {Object} with the following keys:",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "      (default: {::wordRegExp})"
            ],
            "code": "  getNextWordBoundaryBufferPosition (options = {}) {\r\n    const currentBufferPosition = this.getBufferPosition()\r\n    const scanRange = Range(currentBufferPosition, this.editor.getEofBufferPosition())\r\n\r\n    const range = this.editor.buffer.findInRangeSync(\r\n      options.wordRegex || this.wordRegExp(),\r\n      scanRange\r\n    )\r\n\r\n    if (range) {\r\n      if (range.start.row > currentBufferPosition.row) {\r\n        return Point(range.start.row, 0)\r\n      } else if (currentBufferPosition.isLessThan(range.start)) {\r\n        return Point.fromObject(range.start)\r\n      } else {\r\n        return Point.fromObject(range.end)\r\n      }\r\n    } else {\r\n      return currentBufferPosition\r\n    }\r\n  }\r",
            "return_type": [
                "object",
                "array",
                "string"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/scope-descriptor.js",
            "name": "ScopeDescriptor.fromObject",
            "start_line": 22,
            "end_line": 28,
            "comment": [],
            "params": [
                "scopes"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "fromObject",
            "line": 508,
            "func_location": "Cursor.getNextWordBoundaryBufferPosition",
            "func_start_line": 493,
            "func_end_line": 513,
            "args": [
                {
                    "name": "range.end",
                    "type": []
                }
            ],
            "comment": [
                " Public: Returns buffer position of the next word boundary. It might be on",
                " the current word, or the previous word.",
                "",
                " * `options` (optional) {Object} with the following keys:",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "      (default: {::wordRegExp})"
            ],
            "code": "  getNextWordBoundaryBufferPosition (options = {}) {\r\n    const currentBufferPosition = this.getBufferPosition()\r\n    const scanRange = Range(currentBufferPosition, this.editor.getEofBufferPosition())\r\n\r\n    const range = this.editor.buffer.findInRangeSync(\r\n      options.wordRegex || this.wordRegExp(),\r\n      scanRange\r\n    )\r\n\r\n    if (range) {\r\n      if (range.start.row > currentBufferPosition.row) {\r\n        return Point(range.start.row, 0)\r\n      } else if (currentBufferPosition.isLessThan(range.start)) {\r\n        return Point.fromObject(range.start)\r\n      } else {\r\n        return Point.fromObject(range.end)\r\n      }\r\n    } else {\r\n      return currentBufferPosition\r\n    }\r\n  }\r",
            "return_type": [
                "object",
                "array",
                "string"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/scope-descriptor.js",
            "name": "ScopeDescriptor.fromObject",
            "start_line": 22,
            "end_line": 28,
            "comment": [],
            "params": [
                "scopes"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getConfigValue",
            "line": 285,
            "func_location": "GitRepository.getOriginURL",
            "func_start_line": 284,
            "func_end_line": 286,
            "args": [
                {
                    "name": {
                        "type": "string"
                    },
                    "type": []
                },
                {
                    "name": "path",
                    "type": [
                        "string",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Returns the origin url of the repository.",
                "",
                " * `path` (optional) {String} path in the repository to get this information",
                "   for, only needed if the repository has submodules."
            ],
            "code": "  getOriginURL (path) {\r\n    return this.getConfigValue('remote.origin.url', path)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getConfigValue",
            "start_line": 276,
            "end_line": 278,
            "comment": [
                " Public: Returns the git configuration value specified by the key.",
                "",
                " * `key`  The {String} key for the configuration to lookup.",
                " * `path` An optional {String} path in the repository to get this information",
                "   for, only needed if the repository has submodules."
            ],
            "params": [
                {
                    "name": "key",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "path",
                    "type": [
                        "string",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getConfigValue",
            "line": 285,
            "func_location": "GitRepository.getOriginURL",
            "func_start_line": 284,
            "func_end_line": 286,
            "args": [
                {
                    "name": {
                        "type": "string"
                    },
                    "type": []
                },
                {
                    "name": "path",
                    "type": [
                        "string",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Returns the origin url of the repository.",
                "",
                " * `path` (optional) {String} path in the repository to get this information",
                "   for, only needed if the repository has submodules."
            ],
            "code": "  getOriginURL (path) {\r\n    return this.getConfigValue('remote.origin.url', path)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getConfigValue",
            "start_line": 276,
            "end_line": 278,
            "comment": [
                " Public: Returns the git configuration value specified by the key.",
                "",
                " * `key`  The {String} key for the configuration to lookup.",
                " * `path` An optional {String} path in the repository to get this information",
                "   for, only needed if the repository has submodules."
            ],
            "params": [
                {
                    "name": "key",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "path",
                    "type": [
                        "string",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 188,
            "func_location": "GitRepository.getPath",
            "func_start_line": 186,
            "func_end_line": 191,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Returns the {String} path of the repository."
            ],
            "code": "  getPath () {\r\n    if (this.path == null) {\r\n      this.path = fs.absolute(this.getRepo().getPath())\r\n    }\r\n    return this.path\r\n  }\r",
            "return_type": [
                "string"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "string"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 188,
            "func_location": "GitRepository.getPath",
            "func_start_line": 186,
            "func_end_line": 191,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Returns the {String} path of the repository."
            ],
            "code": "  getPath () {\r\n    if (this.path == null) {\r\n      this.path = fs.absolute(this.getRepo().getPath())\r\n    }\r\n    return this.path\r\n  }\r",
            "return_type": [
                "string"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "string"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 375,
            "func_location": "GitRepository.getPathStatus",
            "func_start_line": 374,
            "func_end_line": 390,
            "args": [
                {
                    "name": "path",
                    "type": [
                        "string"
                    ]
                }
            ],
            "comment": [
                " Public: Get the status of a single path in the repository.",
                "",
                " * `path` A {String} repository-relative path.",
                "",
                " Returns a {Number} representing the status. This value can be passed to",
                " {::isStatusModified} or {::isStatusNew} to get more information."
            ],
            "code": "  getPathStatus (path) {\r\n    const repo = this.getRepo(path)\r\n    const relativePath = this.relativize(path)\r\n    const currentPathStatus = this.statuses[relativePath] || 0\r\n    let pathStatus = repo.getStatus(repo.relativize(path)) || 0\r\n    if (repo.isStatusIgnored(pathStatus)) pathStatus = 0\r\n    if (pathStatus > 0) {\r\n      this.statuses[relativePath] = pathStatus\r\n    } else {\r\n      delete this.statuses[relativePath]\r\n    }\r\n    if (currentPathStatus !== pathStatus) {\r\n      this.emitter.emit('did-change-status', {path, pathStatus})\r\n    }\r\n\r\n    return pathStatus\r\n  }\r",
            "return_type": [
                "number"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "number"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 375,
            "func_location": "GitRepository.getPathStatus",
            "func_start_line": 374,
            "func_end_line": 390,
            "args": [
                {
                    "name": "path",
                    "type": [
                        "string"
                    ]
                }
            ],
            "comment": [
                " Public: Get the status of a single path in the repository.",
                "",
                " * `path` A {String} repository-relative path.",
                "",
                " Returns a {Number} representing the status. This value can be passed to",
                " {::isStatusModified} or {::isStatusNew} to get more information."
            ],
            "code": "  getPathStatus (path) {\r\n    const repo = this.getRepo(path)\r\n    const relativePath = this.relativize(path)\r\n    const currentPathStatus = this.statuses[relativePath] || 0\r\n    let pathStatus = repo.getStatus(repo.relativize(path)) || 0\r\n    if (repo.isStatusIgnored(pathStatus)) pathStatus = 0\r\n    if (pathStatus > 0) {\r\n      this.statuses[relativePath] = pathStatus\r\n    } else {\r\n      delete this.statuses[relativePath]\r\n    }\r\n    if (currentPathStatus !== pathStatus) {\r\n      this.emitter.emit('did-change-status', {path, pathStatus})\r\n    }\r\n\r\n    return pathStatus\r\n  }\r",
            "return_type": [
                "number"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "number"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "relativize",
            "line": 376,
            "func_location": "GitRepository.getPathStatus",
            "func_start_line": 374,
            "func_end_line": 390,
            "args": [
                {
                    "name": "path",
                    "type": [
                        "string"
                    ]
                }
            ],
            "comment": [
                " Public: Get the status of a single path in the repository.",
                "",
                " * `path` A {String} repository-relative path.",
                "",
                " Returns a {Number} representing the status. This value can be passed to",
                " {::isStatusModified} or {::isStatusNew} to get more information."
            ],
            "code": "  getPathStatus (path) {\r\n    const repo = this.getRepo(path)\r\n    const relativePath = this.relativize(path)\r\n    const currentPathStatus = this.statuses[relativePath] || 0\r\n    let pathStatus = repo.getStatus(repo.relativize(path)) || 0\r\n    if (repo.isStatusIgnored(pathStatus)) pathStatus = 0\r\n    if (pathStatus > 0) {\r\n      this.statuses[relativePath] = pathStatus\r\n    } else {\r\n      delete this.statuses[relativePath]\r\n    }\r\n    if (currentPathStatus !== pathStatus) {\r\n      this.emitter.emit('did-change-status', {path, pathStatus})\r\n    }\r\n\r\n    return pathStatus\r\n  }\r",
            "return_type": [
                "number"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.relativize",
            "start_line": 208,
            "end_line": 210,
            "comment": [
                " Public: Makes a path relative to the repository's working directory."
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "number"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "relativize",
            "line": 376,
            "func_location": "GitRepository.getPathStatus",
            "func_start_line": 374,
            "func_end_line": 390,
            "args": [
                {
                    "name": "path",
                    "type": [
                        "string"
                    ]
                }
            ],
            "comment": [
                " Public: Get the status of a single path in the repository.",
                "",
                " * `path` A {String} repository-relative path.",
                "",
                " Returns a {Number} representing the status. This value can be passed to",
                " {::isStatusModified} or {::isStatusNew} to get more information."
            ],
            "code": "  getPathStatus (path) {\r\n    const repo = this.getRepo(path)\r\n    const relativePath = this.relativize(path)\r\n    const currentPathStatus = this.statuses[relativePath] || 0\r\n    let pathStatus = repo.getStatus(repo.relativize(path)) || 0\r\n    if (repo.isStatusIgnored(pathStatus)) pathStatus = 0\r\n    if (pathStatus > 0) {\r\n      this.statuses[relativePath] = pathStatus\r\n    } else {\r\n      delete this.statuses[relativePath]\r\n    }\r\n    if (currentPathStatus !== pathStatus) {\r\n      this.emitter.emit('did-change-status', {path, pathStatus})\r\n    }\r\n\r\n    return pathStatus\r\n  }\r",
            "return_type": [
                "number"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.relativize",
            "start_line": 208,
            "end_line": 210,
            "comment": [
                " Public: Makes a path relative to the repository's working directory."
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "number"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "relativize",
            "line": 378,
            "func_location": "GitRepository.getPathStatus",
            "func_start_line": 374,
            "func_end_line": 390,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Get the status of a single path in the repository.",
                "",
                " * `path` A {String} repository-relative path.",
                "",
                " Returns a {Number} representing the status. This value can be passed to",
                " {::isStatusModified} or {::isStatusNew} to get more information."
            ],
            "code": "  getPathStatus (path) {\r\n    const repo = this.getRepo(path)\r\n    const relativePath = this.relativize(path)\r\n    const currentPathStatus = this.statuses[relativePath] || 0\r\n    let pathStatus = repo.getStatus(repo.relativize(path)) || 0\r\n    if (repo.isStatusIgnored(pathStatus)) pathStatus = 0\r\n    if (pathStatus > 0) {\r\n      this.statuses[relativePath] = pathStatus\r\n    } else {\r\n      delete this.statuses[relativePath]\r\n    }\r\n    if (currentPathStatus !== pathStatus) {\r\n      this.emitter.emit('did-change-status', {path, pathStatus})\r\n    }\r\n\r\n    return pathStatus\r\n  }\r",
            "return_type": [
                "number"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.relativize",
            "start_line": 208,
            "end_line": 210,
            "comment": [
                " Public: Makes a path relative to the repository's working directory."
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "number"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "relativize",
            "line": 378,
            "func_location": "GitRepository.getPathStatus",
            "func_start_line": 374,
            "func_end_line": 390,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Get the status of a single path in the repository.",
                "",
                " * `path` A {String} repository-relative path.",
                "",
                " Returns a {Number} representing the status. This value can be passed to",
                " {::isStatusModified} or {::isStatusNew} to get more information."
            ],
            "code": "  getPathStatus (path) {\r\n    const repo = this.getRepo(path)\r\n    const relativePath = this.relativize(path)\r\n    const currentPathStatus = this.statuses[relativePath] || 0\r\n    let pathStatus = repo.getStatus(repo.relativize(path)) || 0\r\n    if (repo.isStatusIgnored(pathStatus)) pathStatus = 0\r\n    if (pathStatus > 0) {\r\n      this.statuses[relativePath] = pathStatus\r\n    } else {\r\n      delete this.statuses[relativePath]\r\n    }\r\n    if (currentPathStatus !== pathStatus) {\r\n      this.emitter.emit('did-change-status', {path, pathStatus})\r\n    }\r\n\r\n    return pathStatus\r\n  }\r",
            "return_type": [
                "number"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.relativize",
            "start_line": 208,
            "end_line": 210,
            "comment": [
                " Public: Makes a path relative to the repository's working directory."
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "number"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "fromObject",
            "line": 478,
            "func_location": "Cursor.getPreviousWordBoundaryBufferPosition",
            "func_start_line": 463,
            "func_end_line": 485,
            "args": [
                {
                    "name": "range.end",
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Local Positions and Ranges\r\n  ",
                " Public: Returns buffer position of previous word boundary. It might be on",
                " the current word, or the previous word.",
                "",
                " * `options` (optional) {Object} with the following keys:",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "      (default: {::wordRegExp})"
            ],
            "code": "  getPreviousWordBoundaryBufferPosition (options = {}) {\r\n    const currentBufferPosition = this.getBufferPosition()\r\n    const previousNonBlankRow = this.editor.buffer.previousNonBlankRow(currentBufferPosition.row)\r\n    const scanRange = Range(Point(previousNonBlankRow || 0, 0), currentBufferPosition)\r\n\r\n    const ranges = this.editor.buffer.findAllInRangeSync(\r\n      options.wordRegex || this.wordRegExp(),\r\n      scanRange\r\n    )\r\n\r\n    const range = ranges[ranges.length - 1]\r\n    if (range) {\r\n      if (range.start.row < currentBufferPosition.row && currentBufferPosition.column > 0) {\r\n        return Point(currentBufferPosition.row, 0)\r\n      } else if (currentBufferPosition.isGreaterThan(range.end)) {\r\n        return Point.fromObject(range.end)\r\n      } else {\r\n        return Point.fromObject(range.start)\r\n      }\r\n    } else {\r\n      return currentBufferPosition\r\n    }\r\n  }\r",
            "return_type": [
                "number"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/scope-descriptor.js",
            "name": "ScopeDescriptor.fromObject",
            "start_line": 22,
            "end_line": 28,
            "comment": [],
            "params": [
                "scopes"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "fromObject",
            "line": 480,
            "func_location": "Cursor.getPreviousWordBoundaryBufferPosition",
            "func_start_line": 463,
            "func_end_line": 485,
            "args": [
                {
                    "name": "range.start",
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Local Positions and Ranges\r\n  ",
                " Public: Returns buffer position of previous word boundary. It might be on",
                " the current word, or the previous word.",
                "",
                " * `options` (optional) {Object} with the following keys:",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "      (default: {::wordRegExp})"
            ],
            "code": "  getPreviousWordBoundaryBufferPosition (options = {}) {\r\n    const currentBufferPosition = this.getBufferPosition()\r\n    const previousNonBlankRow = this.editor.buffer.previousNonBlankRow(currentBufferPosition.row)\r\n    const scanRange = Range(Point(previousNonBlankRow || 0, 0), currentBufferPosition)\r\n\r\n    const ranges = this.editor.buffer.findAllInRangeSync(\r\n      options.wordRegex || this.wordRegExp(),\r\n      scanRange\r\n    )\r\n\r\n    const range = ranges[ranges.length - 1]\r\n    if (range) {\r\n      if (range.start.row < currentBufferPosition.row && currentBufferPosition.column > 0) {\r\n        return Point(currentBufferPosition.row, 0)\r\n      } else if (currentBufferPosition.isGreaterThan(range.end)) {\r\n        return Point.fromObject(range.end)\r\n      } else {\r\n        return Point.fromObject(range.start)\r\n      }\r\n    } else {\r\n      return currentBufferPosition\r\n    }\r\n  }\r",
            "return_type": [
                "number"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/scope-descriptor.js",
            "name": "ScopeDescriptor.fromObject",
            "start_line": 22,
            "end_line": 28,
            "comment": [],
            "params": [
                "scopes"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 309,
            "func_location": "GitRepository.getReferences",
            "func_start_line": 308,
            "func_end_line": 310,
            "args": [],
            "comment": [
                " Public: Gets all the local and remote references.",
                "",
                " * `path` An optional {String} path in the repository to get this information",
                "   for, only needed if the repository has submodules.",
                "",
                " Returns an {Object} with the following keys:",
                "  * `heads`   An {Array} of head reference names.",
                "  * `remotes` An {Array} of remote reference names.",
                "  * `tags`    An {Array} of tag reference names."
            ],
            "code": "  getReferences (path) {\r\n    return this.getRepo(path).getReferences()\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getReferences",
            "line": 309,
            "func_location": "GitRepository.getReferences",
            "func_start_line": 308,
            "func_end_line": 310,
            "args": [],
            "comment": [
                " Public: Gets all the local and remote references.",
                "",
                " * `path` An optional {String} path in the repository to get this information",
                "   for, only needed if the repository has submodules.",
                "",
                " Returns an {Object} with the following keys:",
                "  * `heads`   An {Array} of head reference names.",
                "  * `remotes` An {Array} of remote reference names.",
                "  * `tags`    An {Array} of tag reference names."
            ],
            "code": "  getReferences (path) {\r\n    return this.getRepo(path).getReferences()\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getReferences",
            "start_line": 308,
            "end_line": 310,
            "comment": [
                " Public: Gets all the local and remote references.",
                "",
                " * `path` An optional {String} path in the repository to get this information",
                "   for, only needed if the repository has submodules.",
                "",
                " Returns an {Object} with the following keys:",
                "  * `heads`   An {Array} of head reference names.",
                "  * `remotes` An {Array} of remote reference names.",
                "  * `tags`    An {Array} of tag reference names."
            ],
            "params": [
                {
                    "name": "path",
                    "type": [
                        "string",
                        "optional"
                    ]
                }
            ],
            "return_type": [
                "object"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 318,
            "func_location": "GitRepository.getReferenceTarget",
            "func_start_line": 317,
            "func_end_line": 319,
            "args": [
                {
                    "name": "reference",
                    "type": [
                        "string",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Returns the current {String} SHA for the given reference.",
                "",
                " * `reference` The {String} reference to get the target of.",
                " * `path` An optional {String} path in the repo to get the reference target",
                "   for. Only needed if the repository contains submodules."
            ],
            "code": "  getReferenceTarget (reference, path) {\r\n    return this.getRepo(path).getReferenceTarget(reference)\r\n  }\r",
            "return_type": [
                "string"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "string"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 318,
            "func_location": "GitRepository.getReferenceTarget",
            "func_start_line": 317,
            "func_end_line": 319,
            "args": [
                {
                    "name": "reference",
                    "type": [
                        "string",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Returns the current {String} SHA for the given reference.",
                "",
                " * `reference` The {String} reference to get the target of.",
                " * `path` An optional {String} path in the repo to get the reference target",
                "   for. Only needed if the repository contains submodules."
            ],
            "code": "  getReferenceTarget (reference, path) {\r\n    return this.getRepo(path).getReferenceTarget(reference)\r\n  }\r",
            "return_type": [
                "string"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "string"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getReferenceTarget",
            "line": 318,
            "func_location": "GitRepository.getReferenceTarget",
            "func_start_line": 317,
            "func_end_line": 319,
            "args": [
                {
                    "name": "reference",
                    "type": [
                        "string",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Returns the current {String} SHA for the given reference.",
                "",
                " * `reference` The {String} reference to get the target of.",
                " * `path` An optional {String} path in the repo to get the reference target",
                "   for. Only needed if the repository contains submodules."
            ],
            "code": "  getReferenceTarget (reference, path) {\r\n    return this.getRepo(path).getReferenceTarget(reference)\r\n  }\r",
            "return_type": [
                "string"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getReferenceTarget",
            "start_line": 317,
            "end_line": 319,
            "comment": [
                " Public: Returns the current {String} SHA for the given reference.",
                "",
                " * `reference` The {String} reference to get the target of.",
                " * `path` An optional {String} path in the repo to get the reference target",
                "   for. Only needed if the repository contains submodules."
            ],
            "params": [
                {
                    "name": "reference",
                    "type": [
                        "string",
                        "optional"
                    ]
                },
                {
                    "name": "path",
                    "type": [
                        "string",
                        "optional"
                    ]
                }
            ],
            "return_type": [
                "string"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getReferenceTarget",
            "line": 318,
            "func_location": "GitRepository.getReferenceTarget",
            "func_start_line": 317,
            "func_end_line": 319,
            "args": [
                {
                    "name": "reference",
                    "type": [
                        "string",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Returns the current {String} SHA for the given reference.",
                "",
                " * `reference` The {String} reference to get the target of.",
                " * `path` An optional {String} path in the repo to get the reference target",
                "   for. Only needed if the repository contains submodules."
            ],
            "code": "  getReferenceTarget (reference, path) {\r\n    return this.getRepo(path).getReferenceTarget(reference)\r\n  }\r",
            "return_type": [
                "string"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getReferenceTarget",
            "start_line": 317,
            "end_line": 319,
            "comment": [
                " Public: Returns the current {String} SHA for the given reference.",
                "",
                " * `reference` The {String} reference to get the target of.",
                " * `path` An optional {String} path in the repo to get the reference target",
                "   for. Only needed if the repository contains submodules."
            ],
            "params": [
                {
                    "name": "reference",
                    "type": [
                        "string",
                        "optional"
                    ]
                },
                {
                    "name": "path",
                    "type": [
                        "string",
                        "optional"
                    ]
                }
            ],
            "return_type": [
                "string"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getBufferPosition",
            "line": 198,
            "func_location": "Cursor.getScopeDescriptor",
            "func_start_line": 197,
            "func_end_line": 199,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Retrieves the scope descriptor for the cursor's current position.",
                "",
                " Returns a {ScopeDescriptor}"
            ],
            "code": "  getScopeDescriptor () {\r\n    return this.editor.scopeDescriptorForBufferPosition(this.getBufferPosition())\r\n  }\r",
            "return_type": [
                "string"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getBufferPosition",
            "start_line": 91,
            "end_line": 93,
            "comment": [
                " Public: Returns the current buffer position as an Array."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 228,
            "func_location": "GitRepository.getShortHead",
            "func_start_line": 227,
            "func_end_line": 229,
            "args": [],
            "comment": [
                " Public: Retrieves a shortened version of the HEAD reference value.",
                "",
                " This removes the leading segments of `refs/heads`, `refs/tags`, or",
                " `refs/remotes`.  It also shortens the SHA-1 of a detached `HEAD` to 7",
                " characters.",
                "",
                " * `path` An optional {String} path in the repository to get this information",
                "   for, only needed if the repository contains submodules.",
                "",
                " Returns a {String}."
            ],
            "code": "  getShortHead (path) {\r\n    return this.getRepo(path).getShortHead()\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getShortHead",
            "line": 228,
            "func_location": "GitRepository.getShortHead",
            "func_start_line": 227,
            "func_end_line": 229,
            "args": [],
            "comment": [
                " Public: Retrieves a shortened version of the HEAD reference value.",
                "",
                " This removes the leading segments of `refs/heads`, `refs/tags`, or",
                " `refs/remotes`.  It also shortens the SHA-1 of a detached `HEAD` to 7",
                " characters.",
                "",
                " * `path` An optional {String} path in the repository to get this information",
                "   for, only needed if the repository contains submodules.",
                "",
                " Returns a {String}."
            ],
            "code": "  getShortHead (path) {\r\n    return this.getRepo(path).getShortHead()\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getShortHead",
            "start_line": 227,
            "end_line": 229,
            "comment": [
                " Public: Retrieves a shortened version of the HEAD reference value.",
                "",
                " This removes the leading segments of `refs/heads`, `refs/tags`, or",
                " `refs/remotes`.  It also shortens the SHA-1 of a detached `HEAD` to 7",
                " characters.",
                "",
                " * `path` An optional {String} path in the repository to get this information",
                "   for, only needed if the repository contains submodules.",
                "",
                " Returns a {String}."
            ],
            "params": [
                {
                    "name": "path",
                    "type": [
                        "string",
                        "optional"
                    ]
                }
            ],
            "return_type": [
                "string",
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getBufferPosition",
            "line": 205,
            "func_location": "Cursor.getSyntaxTreeScopeDescriptor",
            "func_start_line": 204,
            "func_end_line": 206,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Retrieves the syntax tree scope descriptor for the cursor's current position.",
                "",
                " Returns a {ScopeDescriptor}"
            ],
            "code": "  getSyntaxTreeScopeDescriptor () {\r\n    return this.editor.syntaxTreeScopeDescriptorForBufferPosition(this.getBufferPosition())\r\n  }\r",
            "return_type": [
                "string",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getBufferPosition",
            "start_line": 91,
            "end_line": 93,
            "comment": [
                " Public: Returns the current buffer position as an Array."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "getBufferRange",
            "line": 158,
            "func_location": "Selection.getText",
            "func_start_line": 157,
            "func_end_line": 159,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Returns the text in the selection."
            ],
            "code": "  getText () {\r\n    return this.editor.buffer.getTextInRange(this.getBufferRange())\r\n  }\r",
            "return_type": [
                "string",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.getBufferRange",
            "start_line": 79,
            "end_line": 81,
            "comment": [
                " Public: Returns the buffer {Range} for the selection."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/workspace-center.js",
            "name": "getPaneItems",
            "line": 271,
            "func_location": "WorkspaceCenter.getTextEditors",
            "func_start_line": 270,
            "func_end_line": 272,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Essential: Get all text editors in the workspace center.",
                "",
                " Returns an {Array} of {TextEditor}s."
            ],
            "code": "  getTextEditors () {\r\n    return this.getPaneItems().filter(item => item instanceof TextEditor)\r\n  }\r",
            "return_type": [
                "string",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/workspace-center.js",
            "name": "WorkspaceCenter.getPaneItems",
            "start_line": 256,
            "end_line": 258,
            "comment": [
                "\r\n  Section: Pane Items\r\n  ",
                " Essential: Get all pane items in the workspace center.",
                "",
                " Returns an {Array} of items."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 296,
            "func_location": "GitRepository.getUpstreamBranch",
            "func_start_line": 295,
            "func_end_line": 297,
            "args": [],
            "comment": [
                " Public: Returns the upstream branch for the current HEAD, or null if there",
                " is no upstream branch for the current HEAD.",
                "",
                " * `path` An optional {String} path in the repo to get this information for,",
                "   only needed if the repository contains submodules.",
                "",
                " Returns a {String} branch name such as `refs/remotes/origin/master`."
            ],
            "code": "  getUpstreamBranch (path) {\r\n    return this.getRepo(path).getUpstreamBranch()\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getUpstreamBranch",
            "line": 296,
            "func_location": "GitRepository.getUpstreamBranch",
            "func_start_line": 295,
            "func_end_line": 297,
            "args": [],
            "comment": [
                " Public: Returns the upstream branch for the current HEAD, or null if there",
                " is no upstream branch for the current HEAD.",
                "",
                " * `path` An optional {String} path in the repo to get this information for,",
                "   only needed if the repository contains submodules.",
                "",
                " Returns a {String} branch name such as `refs/remotes/origin/master`."
            ],
            "code": "  getUpstreamBranch (path) {\r\n    return this.getRepo(path).getUpstreamBranch()\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getUpstreamBranch",
            "start_line": 295,
            "end_line": 297,
            "comment": [
                " Public: Returns the upstream branch for the current HEAD, or null if there",
                " is no upstream branch for the current HEAD.",
                "",
                " * `path` An optional {String} path in the repo to get this information for,",
                "   only needed if the repository contains submodules.",
                "",
                " Returns a {String} branch name such as `refs/remotes/origin/master`."
            ],
            "params": [
                {
                    "name": "path",
                    "type": [
                        "string",
                        "optional"
                    ]
                }
            ],
            "return_type": [
                "null",
                "string",
                "object"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/style-manager.js",
            "name": "resolve",
            "line": 253,
            "func_location": "StyleManager.getUserStyleSheetPath",
            "func_start_line": 249,
            "func_end_line": 260,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Paths\r\n  ",
                " Extended: Get the path of the user style sheet in `~/.atom`.",
                "",
                " Returns a {String}."
            ],
            "code": "  getUserStyleSheetPath () {\r\n    if (this.configDirPath == null) {\r\n      return ''\r\n    } else {\r\n      const stylesheetPath = fs.resolve(path.join(this.configDirPath, 'styles'), ['css', 'less'])\r\n      if (fs.isFileSync(stylesheetPath)) {\r\n        return stylesheetPath\r\n      } else {\r\n        return path.join(this.configDirPath, 'styles.less')\r\n      }\r\n    }\r\n  }\r",
            "return_type": [
                "null",
                "string",
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/native-compile-cache.js",
            "name": "require.resolve",
            "start_line": 49,
            "end_line": 51,
            "comment": [],
            "params": [
                "request"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/view-registry.js",
            "name": "createView",
            "line": 127,
            "func_location": "ViewRegistry.getView",
            "func_start_line": 122,
            "func_end_line": 131,
            "args": [
                {
                    "name": "object",
                    "type": [
                        "object"
                    ]
                }
            ],
            "comment": [
                " Essential: Get the view associated with an object in the workspace.",
                "",
                " If you're just *using* the workspace, you shouldn't need to access the view",
                " layer, but view layer access may be necessary if you want to perform DOM",
                " manipulation that isn't supported via the model API.",
                "",
                " ## View Resolution Algorithm",
                "",
                " The view associated with the object is resolved using the following",
                " sequence",
                "",
                "  1. Is the object an instance of `HTMLElement`? If true, return the object.",
                "  2. Does the object have a method named `getElement` that returns an",
                "     instance of `HTMLElement`? If true, return that value.",
                "  3. Does the object have a property named `element` with a value which is",
                "     an instance of `HTMLElement`? If true, return the property value.",
                "  4. Is the object a jQuery object, indicated by the presence of a `jquery`",
                "     property? If true, return the root DOM element (i.e. `object[0]`).",
                "  5. Has a view provider been registered for the object? If true, use the",
                "     provider to create a view associated with the object, and return the",
                "     view.",
                "",
                " If no associated view is returned by the sequence an error is thrown.",
                "",
                " Returns a DOM element."
            ],
            "code": "  getView (object) {\r\n    if (object == null) { return }\r\n\r\n    let view = this.views.get(object)\r\n    if (!view) {\r\n      view = this.createView(object)\r\n      this.views.set(object, view)\r\n    }\r\n    return view\r\n  }\r",
            "return_type": [
                "null",
                "string",
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/view-registry.js",
            "name": "ViewRegistry.createView",
            "start_line": 133,
            "end_line": 185,
            "comment": [],
            "params": [
                "object"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 195,
            "func_location": "GitRepository.getWorkingDirectory",
            "func_start_line": 194,
            "func_end_line": 196,
            "args": [],
            "comment": [
                " Public: Returns the {String} working directory path of the repository."
            ],
            "code": "  getWorkingDirectory () {\r\n    return this.getRepo().getWorkingDirectory()\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/dock.js",
            "name": "pointWithinHoverArea",
            "line": 312,
            "func_location": "Dock.handleDrag",
            "func_start_line": 311,
            "func_end_line": 315,
            "args": [
                null,
                {
                    "type": "boolean"
                }
            ],
            "code": "  handleDrag (event) {\r\n    if (!this.pointWithinHoverArea({x: event.pageX, y: event.pageY}, true)) {\r\n      this.draggedOut()\r\n    }\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/dock.js",
            "name": "Dock.pointWithinHoverArea",
            "start_line": 333,
            "end_line": 405,
            "comment": [
                " Determine whether the cursor is within the dock hover area. This isn't as simple as just using",
                " mouseenter/leave because we want to be a little more forgiving. For example, if the cursor is",
                " over the footer, we want to show the bottom dock's toggle button. Also note that our criteria",
                " for detecting entry are different than detecting exit but, in order for us to avoid jitter, the",
                " area considered when detecting exit MUST fully encompass the area considered when detecting",
                " entry."
            ],
            "params": [
                {
                    "name": "point",
                    "type": []
                },
                {
                    "name": "detectingExit",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/buffered-process.js",
            "name": "bufferStream",
            "line": 269,
            "func_location": "BufferedProcess.handleEvents",
            "func_start_line": 252,
            "func_end_line": 295
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/buffered-process.js",
            "name": "BufferedProcess.bufferStream",
            "start_line": 134,
            "end_line": 157,
            "comment": [
                "\r\n  Section: Helper Methods\r\n  ",
                " Helper method to pass data line by line.",
                "",
                " * `stream` The Stream to read from.",
                " * `onLines` The callback to call with each line of data.",
                " * `onDone` The callback to call when the stream has closed."
            ],
            "params": [
                {
                    "name": "stream",
                    "type": []
                },
                {
                    "name": "onLines",
                    "type": []
                },
                {
                    "name": "onDone",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/buffered-process.js",
            "name": "bufferStream",
            "line": 277,
            "func_location": "BufferedProcess.handleEvents",
            "func_start_line": 252,
            "func_end_line": 295
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/buffered-process.js",
            "name": "BufferedProcess.bufferStream",
            "start_line": 134,
            "end_line": 157,
            "comment": [
                "\r\n  Section: Helper Methods\r\n  ",
                " Helper method to pass data line by line.",
                "",
                " * `stream` The Stream to read from.",
                " * `onLines` The callback to call with each line of data.",
                " * `onDone` The callback to call when the stream has closed."
            ],
            "params": [
                {
                    "name": "stream",
                    "type": []
                },
                {
                    "name": "onLines",
                    "type": []
                },
                {
                    "name": "onDone",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/window-event-handler.js",
            "name": "remove",
            "line": 203,
            "func_location": "WindowEventHandler.handleLeaveFullScreen",
            "func_start_line": 202,
            "func_end_line": 204,
            "args": [
                {
                    "type": "string"
                }
            ],
            "code": "  handleLeaveFullScreen () {\r\n    this.document.body.classList.remove('fullscreen')\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/uri-handler-registry.js",
            "name": "parse",
            "line": 93,
            "func_location": "URIHandlerRegistry.handleURI",
            "func_start_line": 92,
            "func_end_line": 113,
            "args": [
                "uri",
                {
                    "type": "boolean"
                }
            ],
            "code": "  handleURI (uri) {\r\n    const parsed = url.parse(uri, true)\r\n    const {protocol, slashes, auth, port, host} = parsed\r\n    if (protocol !== 'atom:' || slashes !== true || auth || port) {\r\n      throw new Error(`URIHandlerRegistry#handleURI asked to handle an invalid URI: ${uri}`)\r\n    }\r\n\r\n    const registration = this.registrations.get(host)\r\n    const historyEntry = {id: ++this._id, uri: uri, handled: false, host}\r\n    try {\r\n      if (registration) {\r\n        historyEntry.handled = true\r\n        registration(parsed, uri)\r\n      }\r\n    } finally {\r\n      this.history.unshift(historyEntry)\r\n      if (this.history.length > this.maxHistoryLength) {\r\n        this.history.length = this.maxHistoryLength\r\n      }\r\n      this.emitter.emit('history-change')\r\n    }\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/color.js",
            "name": "Color.parse",
            "start_line": 14,
            "end_line": 36,
            "comment": [
                " Essential: Parse a {String} or {Object} into a {Color}.",
                "",
                " * `value` A {String} such as `'white'`, `#ff00ff`, or",
                "   `'rgba(255, 15, 60, .75)'` or an {Object} with `red`, `green`, `blue`,",
                "   and `alpha` properties.",
                "",
                " Returns a {Color} or `null` if it cannot be parsed."
            ],
            "params": [
                {
                    "name": "value",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "null"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/window-event-handler.js",
            "name": "remove",
            "line": 186,
            "func_location": "WindowEventHandler.handleWindowFocus",
            "func_start_line": 185,
            "func_end_line": 187,
            "args": [
                {
                    "type": "string"
                }
            ],
            "code": "  handleWindowFocus () {\r\n    this.document.body.classList.remove('is-blurred')\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getReferenceTarget",
            "line": 214,
            "func_location": "GitRepository.hasBranch",
            "func_start_line": 213,
            "func_end_line": 215,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Returns true if the given branch exists."
            ],
            "code": "  hasBranch (branch) {\r\n    return this.getReferenceTarget(`refs/heads/${branch}`) != null\r\n  }\r",
            "return_type": [
                "string"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getReferenceTarget",
            "start_line": 317,
            "end_line": 319,
            "comment": [
                " Public: Returns the current {String} SHA for the given reference.",
                "",
                " * `reference` The {String} reference to get the target of.",
                " * `path` An optional {String} path in the repo to get the reference target",
                "   for. Only needed if the repository contains submodules."
            ],
            "params": [
                {
                    "name": "reference",
                    "type": [
                        "string",
                        "optional"
                    ]
                },
                {
                    "name": "path",
                    "type": [
                        "string",
                        "optional"
                    ]
                }
            ],
            "return_type": [
                "string"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getReferenceTarget",
            "line": 214,
            "func_location": "GitRepository.hasBranch",
            "func_start_line": 213,
            "func_end_line": 215,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Returns true if the given branch exists."
            ],
            "code": "  hasBranch (branch) {\r\n    return this.getReferenceTarget(`refs/heads/${branch}`) != null\r\n  }\r",
            "return_type": [
                "string"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getReferenceTarget",
            "start_line": 317,
            "end_line": 319,
            "comment": [
                " Public: Returns the current {String} SHA for the given reference.",
                "",
                " * `reference` The {String} reference to get the target of.",
                " * `path` An optional {String} path in the repo to get the reference target",
                "   for. Only needed if the repository contains submodules."
            ],
            "params": [
                {
                    "name": "reference",
                    "type": [
                        "string",
                        "optional"
                    ]
                },
                {
                    "name": "path",
                    "type": [
                        "string",
                        "optional"
                    ]
                }
            ],
            "return_type": [
                "string"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/tooltip.js",
            "name": "remove",
            "line": 371,
            "func_location": "Tooltip.prototype.hide",
            "func_start_line": 360,
            "func_end_line": 391,
            "args": [
                {
                    "type": "string"
                }
            ],
            "code": "Tooltip.prototype.hide = function (callback) {\r\n  this.inState = {}\r\n\r\n  if (this.hideOnClickOutsideOfTooltip) {\r\n    window.removeEventListener('click', this.hideOnClickOutsideOfTooltip, true)\r\n  }\r\n\r\n  if (this.hideOnKeydownOutsideOfTooltip) {\r\n    window.removeEventListener('keydown', this.hideOnKeydownOutsideOfTooltip, true)\r\n  }\r\n\r\n  this.tip && this.tip.classList.remove('in')\r\n  this.stopObservingMutations()\r\n\r\n  if (this.hoverState !== 'in') this.tip && this.tip.remove()\r\n\r\n  this.element.removeAttribute('aria-describedby')\r\n\r\n  callback && callback()\r\n\r\n  this.hoverState = null\r\n\r\n  clearTimeout(followThroughTimer)\r\n  followThroughTimer = setTimeout(\r\n    function () {\r\n      followThroughTimer = null\r\n    },\r\n    Tooltip.FOLLOW_THROUGH_DURATION\r\n  )\r\n\r\n  return this\r\n}\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/tooltip.js",
            "name": "remove",
            "line": 374,
            "func_location": "Tooltip.prototype.hide",
            "func_start_line": 360,
            "func_end_line": 391,
            "args": [],
            "code": "Tooltip.prototype.hide = function (callback) {\r\n  this.inState = {}\r\n\r\n  if (this.hideOnClickOutsideOfTooltip) {\r\n    window.removeEventListener('click', this.hideOnClickOutsideOfTooltip, true)\r\n  }\r\n\r\n  if (this.hideOnKeydownOutsideOfTooltip) {\r\n    window.removeEventListener('keydown', this.hideOnKeydownOutsideOfTooltip, true)\r\n  }\r\n\r\n  this.tip && this.tip.classList.remove('in')\r\n  this.stopObservingMutations()\r\n\r\n  if (this.hoverState !== 'in') this.tip && this.tip.remove()\r\n\r\n  this.element.removeAttribute('aria-describedby')\r\n\r\n  callback && callback()\r\n\r\n  this.hoverState = null\r\n\r\n  clearTimeout(followThroughTimer)\r\n  followThroughTimer = setTimeout(\r\n    function () {\r\n      followThroughTimer = null\r\n    },\r\n    Tooltip.FOLLOW_THROUGH_DURATION\r\n  )\r\n\r\n  return this\r\n}\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/dock.js",
            "name": "setState",
            "line": 126,
            "func_location": "Dock.hide",
            "func_start_line": 125,
            "func_end_line": 127,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Extended: Hide the dock and activate the {WorkspaceCenter} if the dock was",
                " was previously focused."
            ],
            "code": "  hide () {\r\n    this.setState({visible: false})\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/dock.js",
            "name": "Dock.setState",
            "start_line": 144,
            "end_line": 177,
            "comment": [],
            "params": [
                "newState"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/panel-container-element.js",
            "name": "onDidAddPanel",
            "line": 21,
            "func_location": "PanelContainerElement.initialize",
            "func_start_line": 17,
            "func_end_line": 31,
            "args": [
                null
            ],
            "code": "  initialize (model, viewRegistry) {\r\n    this.model = model\r\n    this.viewRegistry = viewRegistry\r\n\r\n    this.subscriptions.add(this.model.onDidAddPanel(this.panelAdded.bind(this)))\r\n    this.subscriptions.add(this.model.onDidDestroy(this.destroyed.bind(this)))\r\n    this.classList.add(this.model.getLocation())\r\n\r\n    // Add the dock.\r\n    if (this.model.dock != null) {\r\n      this.appendChild(this.model.dock.getElement())\r\n    }\r\n\r\n    return this\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/panel-container.js",
            "name": "PanelContainer.onDidAddPanel",
            "start_line": 34,
            "end_line": 36,
            "comment": [
                "\r\n  Section: Event Subscription\r\n  "
            ],
            "params": [
                {
                    "name": "callback",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/atom-environment.js",
            "name": "resetUserSettings",
            "line": 224,
            "func_location": "AtomEnvironment.initialize",
            "func_start_line": 201,
            "func_end_line": 274,
            "args": [
                "userSettings"
            ],
            "code": "  initialize (params = {}) {\r\n    // This will force TextEditorElement to register the custom element, so that\r\n    // using `document.createElement('atom-text-editor')` works if it's called\r\n    // before opening a buffer.\r\n    require('./text-editor-element')\r\n\r\n    this.window = params.window\r\n    this.document = params.document\r\n    this.blobStore = params.blobStore\r\n    this.configDirPath = params.configDirPath\r\n\r\n    const {devMode, safeMode, resourcePath, userSettings, projectSpecification} = this.getLoadSettings()\r\n\r\n    ConfigSchema.projectHome = {\r\n      type: 'string',\r\n      default: path.join(fs.getHomeDirectory(), 'github'),\r\n      description: 'The directory where projects are assumed to be located. Packages created using the Package Generator will be stored here by default.'\r\n    }\r\n\r\n    this.config.initialize({\r\n      mainSource: this.enablePersistence && path.join(this.configDirPath, 'config.cson'),\r\n      projectHomeSchema: ConfigSchema.projectHome\r\n    })\r\n    this.config.resetUserSettings(userSettings)\r\n\r\n    if (projectSpecification != null && projectSpecification.config != null) {\r\n      this.project.replace(projectSpecification)\r\n    }\r\n\r\n    this.menu.initialize({resourcePath})\r\n    this.contextMenu.initialize({resourcePath, devMode})\r\n\r\n    this.keymaps.configDirPath = this.configDirPath\r\n    this.keymaps.resourcePath = resourcePath\r\n    this.keymaps.devMode = devMode\r\n    if (!this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.commands.attach(this.window)\r\n\r\n    this.styles.initialize({configDirPath: this.configDirPath})\r\n    this.packages.initialize({devMode, configDirPath: this.configDirPath, resourcePath, safeMode})\r\n    this.themes.initialize({configDirPath: this.configDirPath, resourcePath, safeMode, devMode})\r\n\r\n    this.commandInstaller.initialize(this.getVersion())\r\n    this.uriHandlerRegistry.registerHostHandler('core', CoreURIHandlers.create(this))\r\n    this.autoUpdater.initialize()\r\n\r\n    this.protocolHandlerInstaller.initialize(this.config, this.notifications)\r\n\r\n    this.themes.loadBaseStylesheets()\r\n    this.initialStyleElements = this.styles.getSnapshot()\r\n    if (params.onlyLoadBaseStyleSheets) this.themes.initialLoadComplete = true\r\n    this.setBodyPlatformClass()\r\n\r\n    this.stylesElement = this.styles.buildStylesElement()\r\n    this.document.head.appendChild(this.stylesElement)\r\n\r\n    this.keymaps.subscribeToFileReadFailure()\r\n\r\n    this.installUncaughtErrorHandler()\r\n    this.attachSaveStateListeners()\r\n    this.windowEventHandler.initialize(this.window, this.document)\r\n\r\n    const didChangeStyles = this.didChangeStyles.bind(this)\r\n    this.disposables.add(this.styles.onDidAddStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidUpdateStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidRemoveStyleElement(didChangeStyles))\r\n\r\n    this.observeAutoHideMenuBar()\r\n\r\n    this.disposables.add(this.applicationDelegate.onDidChangeHistoryManager(() => this.history.loadState()))\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.resetUserSettings",
            "start_line": 936,
            "end_line": 938,
            "comment": [
                "\r\n  Section: Private methods managing global settings\r\n  "
            ],
            "params": [
                {
                    "name": "newSettings",
                    "type": []
                },
                {
                    "name": "options",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/atom-environment.js",
            "name": "replace",
            "line": 227,
            "func_location": "AtomEnvironment.initialize",
            "func_start_line": 201,
            "func_end_line": 274,
            "args": [
                "projectSpecification"
            ],
            "code": "  initialize (params = {}) {\r\n    // This will force TextEditorElement to register the custom element, so that\r\n    // using `document.createElement('atom-text-editor')` works if it's called\r\n    // before opening a buffer.\r\n    require('./text-editor-element')\r\n\r\n    this.window = params.window\r\n    this.document = params.document\r\n    this.blobStore = params.blobStore\r\n    this.configDirPath = params.configDirPath\r\n\r\n    const {devMode, safeMode, resourcePath, userSettings, projectSpecification} = this.getLoadSettings()\r\n\r\n    ConfigSchema.projectHome = {\r\n      type: 'string',\r\n      default: path.join(fs.getHomeDirectory(), 'github'),\r\n      description: 'The directory where projects are assumed to be located. Packages created using the Package Generator will be stored here by default.'\r\n    }\r\n\r\n    this.config.initialize({\r\n      mainSource: this.enablePersistence && path.join(this.configDirPath, 'config.cson'),\r\n      projectHomeSchema: ConfigSchema.projectHome\r\n    })\r\n    this.config.resetUserSettings(userSettings)\r\n\r\n    if (projectSpecification != null && projectSpecification.config != null) {\r\n      this.project.replace(projectSpecification)\r\n    }\r\n\r\n    this.menu.initialize({resourcePath})\r\n    this.contextMenu.initialize({resourcePath, devMode})\r\n\r\n    this.keymaps.configDirPath = this.configDirPath\r\n    this.keymaps.resourcePath = resourcePath\r\n    this.keymaps.devMode = devMode\r\n    if (!this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.commands.attach(this.window)\r\n\r\n    this.styles.initialize({configDirPath: this.configDirPath})\r\n    this.packages.initialize({devMode, configDirPath: this.configDirPath, resourcePath, safeMode})\r\n    this.themes.initialize({configDirPath: this.configDirPath, resourcePath, safeMode, devMode})\r\n\r\n    this.commandInstaller.initialize(this.getVersion())\r\n    this.uriHandlerRegistry.registerHostHandler('core', CoreURIHandlers.create(this))\r\n    this.autoUpdater.initialize()\r\n\r\n    this.protocolHandlerInstaller.initialize(this.config, this.notifications)\r\n\r\n    this.themes.loadBaseStylesheets()\r\n    this.initialStyleElements = this.styles.getSnapshot()\r\n    if (params.onlyLoadBaseStyleSheets) this.themes.initialLoadComplete = true\r\n    this.setBodyPlatformClass()\r\n\r\n    this.stylesElement = this.styles.buildStylesElement()\r\n    this.document.head.appendChild(this.stylesElement)\r\n\r\n    this.keymaps.subscribeToFileReadFailure()\r\n\r\n    this.installUncaughtErrorHandler()\r\n    this.attachSaveStateListeners()\r\n    this.windowEventHandler.initialize(this.window, this.document)\r\n\r\n    const didChangeStyles = this.didChangeStyles.bind(this)\r\n    this.disposables.add(this.styles.onDidAddStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidUpdateStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidRemoveStyleElement(didChangeStyles))\r\n\r\n    this.observeAutoHideMenuBar()\r\n\r\n    this.disposables.add(this.applicationDelegate.onDidChangeHistoryManager(() => this.history.loadState()))\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "Project.replace",
            "start_line": 82,
            "end_line": 99,
            "comment": [
                " Layers the contents of a project's file's config",
                " on top of the current global config."
            ],
            "params": [
                {
                    "name": "projectSpecification",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/atom-environment.js",
            "name": "onDidAddStyleElement",
            "line": 267,
            "func_location": "AtomEnvironment.initialize",
            "func_start_line": 201,
            "func_end_line": 274,
            "args": [
                null
            ],
            "code": "  initialize (params = {}) {\r\n    // This will force TextEditorElement to register the custom element, so that\r\n    // using `document.createElement('atom-text-editor')` works if it's called\r\n    // before opening a buffer.\r\n    require('./text-editor-element')\r\n\r\n    this.window = params.window\r\n    this.document = params.document\r\n    this.blobStore = params.blobStore\r\n    this.configDirPath = params.configDirPath\r\n\r\n    const {devMode, safeMode, resourcePath, userSettings, projectSpecification} = this.getLoadSettings()\r\n\r\n    ConfigSchema.projectHome = {\r\n      type: 'string',\r\n      default: path.join(fs.getHomeDirectory(), 'github'),\r\n      description: 'The directory where projects are assumed to be located. Packages created using the Package Generator will be stored here by default.'\r\n    }\r\n\r\n    this.config.initialize({\r\n      mainSource: this.enablePersistence && path.join(this.configDirPath, 'config.cson'),\r\n      projectHomeSchema: ConfigSchema.projectHome\r\n    })\r\n    this.config.resetUserSettings(userSettings)\r\n\r\n    if (projectSpecification != null && projectSpecification.config != null) {\r\n      this.project.replace(projectSpecification)\r\n    }\r\n\r\n    this.menu.initialize({resourcePath})\r\n    this.contextMenu.initialize({resourcePath, devMode})\r\n\r\n    this.keymaps.configDirPath = this.configDirPath\r\n    this.keymaps.resourcePath = resourcePath\r\n    this.keymaps.devMode = devMode\r\n    if (!this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.commands.attach(this.window)\r\n\r\n    this.styles.initialize({configDirPath: this.configDirPath})\r\n    this.packages.initialize({devMode, configDirPath: this.configDirPath, resourcePath, safeMode})\r\n    this.themes.initialize({configDirPath: this.configDirPath, resourcePath, safeMode, devMode})\r\n\r\n    this.commandInstaller.initialize(this.getVersion())\r\n    this.uriHandlerRegistry.registerHostHandler('core', CoreURIHandlers.create(this))\r\n    this.autoUpdater.initialize()\r\n\r\n    this.protocolHandlerInstaller.initialize(this.config, this.notifications)\r\n\r\n    this.themes.loadBaseStylesheets()\r\n    this.initialStyleElements = this.styles.getSnapshot()\r\n    if (params.onlyLoadBaseStyleSheets) this.themes.initialLoadComplete = true\r\n    this.setBodyPlatformClass()\r\n\r\n    this.stylesElement = this.styles.buildStylesElement()\r\n    this.document.head.appendChild(this.stylesElement)\r\n\r\n    this.keymaps.subscribeToFileReadFailure()\r\n\r\n    this.installUncaughtErrorHandler()\r\n    this.attachSaveStateListeners()\r\n    this.windowEventHandler.initialize(this.window, this.document)\r\n\r\n    const didChangeStyles = this.didChangeStyles.bind(this)\r\n    this.disposables.add(this.styles.onDidAddStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidUpdateStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidRemoveStyleElement(didChangeStyles))\r\n\r\n    this.observeAutoHideMenuBar()\r\n\r\n    this.disposables.add(this.applicationDelegate.onDidChangeHistoryManager(() => this.history.loadState()))\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/style-manager.js",
            "name": "StyleManager.onDidAddStyleElement",
            "start_line": 72,
            "end_line": 74,
            "comment": [
                " Extended: Invoke `callback` when a style element is added.",
                "",
                " * `callback` {Function} that is called with style elements.",
                "   * `styleElement` An `HTMLStyleElement` instance. The `.sheet` property",
                "     will be null because this element isn't attached to the DOM. If you want",
                "     to attach this element to the DOM, be sure to clone it first by calling",
                "     `.cloneNode(true)` on it. The style element will also have the following",
                "     non-standard properties:",
                "     * `sourcePath` A {String} containing the path from which the style",
                "       element was loaded.",
                "     * `context` A {String} indicating the target context of the style",
                "       element.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to cancel the",
                " subscription."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/atom-environment.js",
            "name": "onDidUpdateStyleElement",
            "line": 268,
            "func_location": "AtomEnvironment.initialize",
            "func_start_line": 201,
            "func_end_line": 274,
            "args": [
                null
            ],
            "code": "  initialize (params = {}) {\r\n    // This will force TextEditorElement to register the custom element, so that\r\n    // using `document.createElement('atom-text-editor')` works if it's called\r\n    // before opening a buffer.\r\n    require('./text-editor-element')\r\n\r\n    this.window = params.window\r\n    this.document = params.document\r\n    this.blobStore = params.blobStore\r\n    this.configDirPath = params.configDirPath\r\n\r\n    const {devMode, safeMode, resourcePath, userSettings, projectSpecification} = this.getLoadSettings()\r\n\r\n    ConfigSchema.projectHome = {\r\n      type: 'string',\r\n      default: path.join(fs.getHomeDirectory(), 'github'),\r\n      description: 'The directory where projects are assumed to be located. Packages created using the Package Generator will be stored here by default.'\r\n    }\r\n\r\n    this.config.initialize({\r\n      mainSource: this.enablePersistence && path.join(this.configDirPath, 'config.cson'),\r\n      projectHomeSchema: ConfigSchema.projectHome\r\n    })\r\n    this.config.resetUserSettings(userSettings)\r\n\r\n    if (projectSpecification != null && projectSpecification.config != null) {\r\n      this.project.replace(projectSpecification)\r\n    }\r\n\r\n    this.menu.initialize({resourcePath})\r\n    this.contextMenu.initialize({resourcePath, devMode})\r\n\r\n    this.keymaps.configDirPath = this.configDirPath\r\n    this.keymaps.resourcePath = resourcePath\r\n    this.keymaps.devMode = devMode\r\n    if (!this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.commands.attach(this.window)\r\n\r\n    this.styles.initialize({configDirPath: this.configDirPath})\r\n    this.packages.initialize({devMode, configDirPath: this.configDirPath, resourcePath, safeMode})\r\n    this.themes.initialize({configDirPath: this.configDirPath, resourcePath, safeMode, devMode})\r\n\r\n    this.commandInstaller.initialize(this.getVersion())\r\n    this.uriHandlerRegistry.registerHostHandler('core', CoreURIHandlers.create(this))\r\n    this.autoUpdater.initialize()\r\n\r\n    this.protocolHandlerInstaller.initialize(this.config, this.notifications)\r\n\r\n    this.themes.loadBaseStylesheets()\r\n    this.initialStyleElements = this.styles.getSnapshot()\r\n    if (params.onlyLoadBaseStyleSheets) this.themes.initialLoadComplete = true\r\n    this.setBodyPlatformClass()\r\n\r\n    this.stylesElement = this.styles.buildStylesElement()\r\n    this.document.head.appendChild(this.stylesElement)\r\n\r\n    this.keymaps.subscribeToFileReadFailure()\r\n\r\n    this.installUncaughtErrorHandler()\r\n    this.attachSaveStateListeners()\r\n    this.windowEventHandler.initialize(this.window, this.document)\r\n\r\n    const didChangeStyles = this.didChangeStyles.bind(this)\r\n    this.disposables.add(this.styles.onDidAddStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidUpdateStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidRemoveStyleElement(didChangeStyles))\r\n\r\n    this.observeAutoHideMenuBar()\r\n\r\n    this.disposables.add(this.applicationDelegate.onDidChangeHistoryManager(() => this.history.loadState()))\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/style-manager.js",
            "name": "StyleManager.onDidUpdateStyleElement",
            "start_line": 100,
            "end_line": 102,
            "comment": [
                " Extended: Invoke `callback` when an existing style element is updated.",
                "",
                " * `callback` {Function} that is called with style elements.",
                "   * `styleElement` An `HTMLStyleElement` instance. The `.sheet` property",
                "      will be null because this element isn't attached to the DOM. The style",
                "      element will also have the following non-standard properties:",
                "     * `sourcePath` A {String} containing the path from which the style",
                "       element was loaded.",
                "     * `context` A {String} indicating the target context of the style",
                "       element.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to cancel the",
                " subscription."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/atom-environment.js",
            "name": "onDidRemoveStyleElement",
            "line": 269,
            "func_location": "AtomEnvironment.initialize",
            "func_start_line": 201,
            "func_end_line": 274,
            "args": [
                null
            ],
            "code": "  initialize (params = {}) {\r\n    // This will force TextEditorElement to register the custom element, so that\r\n    // using `document.createElement('atom-text-editor')` works if it's called\r\n    // before opening a buffer.\r\n    require('./text-editor-element')\r\n\r\n    this.window = params.window\r\n    this.document = params.document\r\n    this.blobStore = params.blobStore\r\n    this.configDirPath = params.configDirPath\r\n\r\n    const {devMode, safeMode, resourcePath, userSettings, projectSpecification} = this.getLoadSettings()\r\n\r\n    ConfigSchema.projectHome = {\r\n      type: 'string',\r\n      default: path.join(fs.getHomeDirectory(), 'github'),\r\n      description: 'The directory where projects are assumed to be located. Packages created using the Package Generator will be stored here by default.'\r\n    }\r\n\r\n    this.config.initialize({\r\n      mainSource: this.enablePersistence && path.join(this.configDirPath, 'config.cson'),\r\n      projectHomeSchema: ConfigSchema.projectHome\r\n    })\r\n    this.config.resetUserSettings(userSettings)\r\n\r\n    if (projectSpecification != null && projectSpecification.config != null) {\r\n      this.project.replace(projectSpecification)\r\n    }\r\n\r\n    this.menu.initialize({resourcePath})\r\n    this.contextMenu.initialize({resourcePath, devMode})\r\n\r\n    this.keymaps.configDirPath = this.configDirPath\r\n    this.keymaps.resourcePath = resourcePath\r\n    this.keymaps.devMode = devMode\r\n    if (!this.keymaps.canLoadBundledKeymapsFromMemory()) {\r\n      this.keymaps.loadBundledKeymaps()\r\n    }\r\n\r\n    this.commands.attach(this.window)\r\n\r\n    this.styles.initialize({configDirPath: this.configDirPath})\r\n    this.packages.initialize({devMode, configDirPath: this.configDirPath, resourcePath, safeMode})\r\n    this.themes.initialize({configDirPath: this.configDirPath, resourcePath, safeMode, devMode})\r\n\r\n    this.commandInstaller.initialize(this.getVersion())\r\n    this.uriHandlerRegistry.registerHostHandler('core', CoreURIHandlers.create(this))\r\n    this.autoUpdater.initialize()\r\n\r\n    this.protocolHandlerInstaller.initialize(this.config, this.notifications)\r\n\r\n    this.themes.loadBaseStylesheets()\r\n    this.initialStyleElements = this.styles.getSnapshot()\r\n    if (params.onlyLoadBaseStyleSheets) this.themes.initialLoadComplete = true\r\n    this.setBodyPlatformClass()\r\n\r\n    this.stylesElement = this.styles.buildStylesElement()\r\n    this.document.head.appendChild(this.stylesElement)\r\n\r\n    this.keymaps.subscribeToFileReadFailure()\r\n\r\n    this.installUncaughtErrorHandler()\r\n    this.attachSaveStateListeners()\r\n    this.windowEventHandler.initialize(this.window, this.document)\r\n\r\n    const didChangeStyles = this.didChangeStyles.bind(this)\r\n    this.disposables.add(this.styles.onDidAddStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidUpdateStyleElement(didChangeStyles))\r\n    this.disposables.add(this.styles.onDidRemoveStyleElement(didChangeStyles))\r\n\r\n    this.observeAutoHideMenuBar()\r\n\r\n    this.disposables.add(this.applicationDelegate.onDidChangeHistoryManager(() => this.history.loadState()))\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/style-manager.js",
            "name": "StyleManager.onDidRemoveStyleElement",
            "start_line": 83,
            "end_line": 85,
            "comment": [
                " Extended: Invoke `callback` when a style element is removed.",
                "",
                " * `callback` {Function} that is called with style elements.",
                "   * `styleElement` An `HTMLStyleElement` instance.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to cancel the",
                " subscription."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/protocol-handler-installer.js",
            "name": "promptToBecomeProtocolClient",
            "line": 33,
            "func_location": "ProtocolHandlerInstaller.initialize",
            "func_start_line": 24,
            "func_end_line": 52,
            "args": [
                "config",
                "notifications"
            ],
            "code": "  initialize (config, notifications) {\r\n    if (!this.isSupported()) {\r\n      return\r\n    }\r\n\r\n    const behaviorWhenNotProtocolClient = config.get(SETTING)\r\n    switch (behaviorWhenNotProtocolClient) {\r\n      case PROMPT:\r\n        if (!this.isDefaultProtocolClient()) {\r\n          this.promptToBecomeProtocolClient(config, notifications)\r\n        }\r\n        break\r\n      case ALWAYS:\r\n        if (!this.isDefaultProtocolClient()) {\r\n          this.setAsDefaultProtocolClient()\r\n        }\r\n        break\r\n      case NEVER:\r\n        if (process.platform === 'win32') {\r\n          // Only win32 supports deregistration\r\n          const Registry = require('winreg')\r\n          const commandKey = new Registry({hive: 'HKCR', key: `\\\\atom`})\r\n          commandKey.destroy((_err, _val) => { /* no op */ })\r\n        }\r\n        break\r\n      default:\r\n        // Do nothing\r\n    }\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/protocol-handler-installer.js",
            "name": "ProtocolHandlerInstaller.promptToBecomeProtocolClient",
            "start_line": 54,
            "end_line": 100,
            "comment": [
                " Do nothing"
            ],
            "params": [
                {
                    "name": "config",
                    "type": []
                },
                {
                    "name": "notifications",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "ensureWritable",
            "line": 452,
            "func_location": "Selection.insertText",
            "func_start_line": 451,
            "func_end_line": 513,
            "args": [
                {
                    "name": {
                        "type": "string"
                    },
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                "\r\n  Section: Modifying the selected text\r\n  ",
                " Public: Replaces text at the current selection.",
                "",
                " * `text` A {String} representing the text to add",
                " * `options` (optional) {Object} with keys:",
                "   * `select` If `true`, selects the newly added text.",
                "   * `autoIndent` If `true`, indents all inserted text appropriately.",
                "   * `autoIndentNewline` If `true`, indent newline appropriately.",
                "   * `autoDecreaseIndent` If `true`, decreases indent level appropriately",
                "     (for example, when a closing bracket is inserted).",
                "   * `preserveTrailingLineIndentation` By default, when pasting multiple",
                "   lines, Atom attempts to preserve the relative indent level between the",
                "   first line and trailing lines, even if the indent level of the first",
                "   line has changed from the copied text. If this option is `true`, this",
                "   behavior is suppressed.",
                "     level between the first lines and the trailing lines.",
                "   * `normalizeLineEndings` (optional) {Boolean} (default: true)",
                "   * `undo` *Deprecated* If `skip`, skips the undo stack for this operation. This property is deprecated. Call groupLastChanges() on the {TextBuffer} afterward instead.",
                "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)"
            ],
            "code": "  insertText (text, options = {}) {\r\n    if (!this.ensureWritable('insertText', options)) return\r\n\r\n    let desiredIndentLevel, indentAdjustment\r\n    const oldBufferRange = this.getBufferRange()\r\n    const wasReversed = this.isReversed()\r\n    this.clear(options)\r\n\r\n    let autoIndentFirstLine = false\r\n    const precedingText = this.editor.getTextInRange([[oldBufferRange.start.row, 0], oldBufferRange.start])\r\n    const remainingLines = text.split('\\n')\r\n    const firstInsertedLine = remainingLines.shift()\r\n\r\n    if (options.indentBasis != null && !options.preserveTrailingLineIndentation) {\r\n      indentAdjustment = this.editor.indentLevelForLine(precedingText) - options.indentBasis\r\n      this.adjustIndent(remainingLines, indentAdjustment)\r\n    }\r\n\r\n    const textIsAutoIndentable = (text === '\\n') || (text === '\\r\\n') || NonWhitespaceRegExp.test(text)\r\n    if (options.autoIndent && textIsAutoIndentable && !NonWhitespaceRegExp.test(precedingText) && (remainingLines.length > 0)) {\r\n      autoIndentFirstLine = true\r\n      const firstLine = precedingText + firstInsertedLine\r\n      const languageMode = this.editor.buffer.getLanguageMode()\r\n      desiredIndentLevel = (\r\n        languageMode.suggestedIndentForLineAtBufferRow &&\r\n        languageMode.suggestedIndentForLineAtBufferRow(\r\n          oldBufferRange.start.row,\r\n          firstLine,\r\n          this.editor.getTabLength()\r\n        )\r\n      )\r\n      if (desiredIndentLevel != null) {\r\n        indentAdjustment = desiredIndentLevel - this.editor.indentLevelForLine(firstLine)\r\n        this.adjustIndent(remainingLines, indentAdjustment)\r\n      }\r\n    }\r\n\r\n    text = firstInsertedLine\r\n    if (remainingLines.length > 0) text += `\\n${remainingLines.join('\\n')}`\r\n\r\n    const newBufferRange = this.editor.buffer.setTextInRange(oldBufferRange, text, pick(options, 'undo', 'normalizeLineEndings'))\r\n\r\n    if (options.select) {\r\n      this.setBufferRange(newBufferRange, {reversed: wasReversed})\r\n    } else {\r\n      if (wasReversed) this.cursor.setBufferPosition(newBufferRange.end)\r\n    }\r\n\r\n    if (autoIndentFirstLine) {\r\n      this.editor.setIndentationForBufferRow(oldBufferRange.start.row, desiredIndentLevel)\r\n    }\r\n\r\n    if (options.autoIndentNewline && (text === '\\n')) {\r\n      this.editor.autoIndentBufferRow(newBufferRange.end.row, {preserveLeadingWhitespace: true, skipBlankLines: false})\r\n    } else if (options.autoDecreaseIndent && NonWhitespaceRegExp.test(text)) {\r\n      this.editor.autoDecreaseIndentForBufferRow(newBufferRange.start.row)\r\n    }\r\n\r\n    const autoscroll = options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.autoscroll()\r\n\r\n    return newBufferRange\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.ensureWritable",
            "start_line": 412,
            "end_line": 427,
            "comment": [
                " Private: Ensure that the {TextEditor} is not marked read-only before allowing a buffer modification to occur. if",
                " the editor is read-only, require an explicit opt-in option to proceed (`bypassReadOnly`) or throw an Error."
            ],
            "params": [
                {
                    "name": "methodName",
                    "type": []
                },
                {
                    "name": "opts",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "ensureWritable",
            "line": 452,
            "func_location": "Selection.insertText",
            "func_start_line": 451,
            "func_end_line": 513,
            "args": [
                {
                    "name": {
                        "type": "string"
                    },
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                "\r\n  Section: Modifying the selected text\r\n  ",
                " Public: Replaces text at the current selection.",
                "",
                " * `text` A {String} representing the text to add",
                " * `options` (optional) {Object} with keys:",
                "   * `select` If `true`, selects the newly added text.",
                "   * `autoIndent` If `true`, indents all inserted text appropriately.",
                "   * `autoIndentNewline` If `true`, indent newline appropriately.",
                "   * `autoDecreaseIndent` If `true`, decreases indent level appropriately",
                "     (for example, when a closing bracket is inserted).",
                "   * `preserveTrailingLineIndentation` By default, when pasting multiple",
                "   lines, Atom attempts to preserve the relative indent level between the",
                "   first line and trailing lines, even if the indent level of the first",
                "   line has changed from the copied text. If this option is `true`, this",
                "   behavior is suppressed.",
                "     level between the first lines and the trailing lines.",
                "   * `normalizeLineEndings` (optional) {Boolean} (default: true)",
                "   * `undo` *Deprecated* If `skip`, skips the undo stack for this operation. This property is deprecated. Call groupLastChanges() on the {TextBuffer} afterward instead.",
                "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)"
            ],
            "code": "  insertText (text, options = {}) {\r\n    if (!this.ensureWritable('insertText', options)) return\r\n\r\n    let desiredIndentLevel, indentAdjustment\r\n    const oldBufferRange = this.getBufferRange()\r\n    const wasReversed = this.isReversed()\r\n    this.clear(options)\r\n\r\n    let autoIndentFirstLine = false\r\n    const precedingText = this.editor.getTextInRange([[oldBufferRange.start.row, 0], oldBufferRange.start])\r\n    const remainingLines = text.split('\\n')\r\n    const firstInsertedLine = remainingLines.shift()\r\n\r\n    if (options.indentBasis != null && !options.preserveTrailingLineIndentation) {\r\n      indentAdjustment = this.editor.indentLevelForLine(precedingText) - options.indentBasis\r\n      this.adjustIndent(remainingLines, indentAdjustment)\r\n    }\r\n\r\n    const textIsAutoIndentable = (text === '\\n') || (text === '\\r\\n') || NonWhitespaceRegExp.test(text)\r\n    if (options.autoIndent && textIsAutoIndentable && !NonWhitespaceRegExp.test(precedingText) && (remainingLines.length > 0)) {\r\n      autoIndentFirstLine = true\r\n      const firstLine = precedingText + firstInsertedLine\r\n      const languageMode = this.editor.buffer.getLanguageMode()\r\n      desiredIndentLevel = (\r\n        languageMode.suggestedIndentForLineAtBufferRow &&\r\n        languageMode.suggestedIndentForLineAtBufferRow(\r\n          oldBufferRange.start.row,\r\n          firstLine,\r\n          this.editor.getTabLength()\r\n        )\r\n      )\r\n      if (desiredIndentLevel != null) {\r\n        indentAdjustment = desiredIndentLevel - this.editor.indentLevelForLine(firstLine)\r\n        this.adjustIndent(remainingLines, indentAdjustment)\r\n      }\r\n    }\r\n\r\n    text = firstInsertedLine\r\n    if (remainingLines.length > 0) text += `\\n${remainingLines.join('\\n')}`\r\n\r\n    const newBufferRange = this.editor.buffer.setTextInRange(oldBufferRange, text, pick(options, 'undo', 'normalizeLineEndings'))\r\n\r\n    if (options.select) {\r\n      this.setBufferRange(newBufferRange, {reversed: wasReversed})\r\n    } else {\r\n      if (wasReversed) this.cursor.setBufferPosition(newBufferRange.end)\r\n    }\r\n\r\n    if (autoIndentFirstLine) {\r\n      this.editor.setIndentationForBufferRow(oldBufferRange.start.row, desiredIndentLevel)\r\n    }\r\n\r\n    if (options.autoIndentNewline && (text === '\\n')) {\r\n      this.editor.autoIndentBufferRow(newBufferRange.end.row, {preserveLeadingWhitespace: true, skipBlankLines: false})\r\n    } else if (options.autoDecreaseIndent && NonWhitespaceRegExp.test(text)) {\r\n      this.editor.autoDecreaseIndentForBufferRow(newBufferRange.start.row)\r\n    }\r\n\r\n    const autoscroll = options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.autoscroll()\r\n\r\n    return newBufferRange\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.ensureWritable",
            "start_line": 412,
            "end_line": 427,
            "comment": [
                " Private: Ensure that the {TextEditor} is not marked read-only before allowing a buffer modification to occur. if",
                " the editor is read-only, require an explicit opt-in option to proceed (`bypassReadOnly`) or throw an Error."
            ],
            "params": [
                {
                    "name": "methodName",
                    "type": []
                },
                {
                    "name": "opts",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "clear",
            "line": 457,
            "func_location": "Selection.insertText",
            "func_start_line": 451,
            "func_end_line": 513,
            "args": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                "\r\n  Section: Modifying the selected text\r\n  ",
                " Public: Replaces text at the current selection.",
                "",
                " * `text` A {String} representing the text to add",
                " * `options` (optional) {Object} with keys:",
                "   * `select` If `true`, selects the newly added text.",
                "   * `autoIndent` If `true`, indents all inserted text appropriately.",
                "   * `autoIndentNewline` If `true`, indent newline appropriately.",
                "   * `autoDecreaseIndent` If `true`, decreases indent level appropriately",
                "     (for example, when a closing bracket is inserted).",
                "   * `preserveTrailingLineIndentation` By default, when pasting multiple",
                "   lines, Atom attempts to preserve the relative indent level between the",
                "   first line and trailing lines, even if the indent level of the first",
                "   line has changed from the copied text. If this option is `true`, this",
                "   behavior is suppressed.",
                "     level between the first lines and the trailing lines.",
                "   * `normalizeLineEndings` (optional) {Boolean} (default: true)",
                "   * `undo` *Deprecated* If `skip`, skips the undo stack for this operation. This property is deprecated. Call groupLastChanges() on the {TextBuffer} afterward instead.",
                "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)"
            ],
            "code": "  insertText (text, options = {}) {\r\n    if (!this.ensureWritable('insertText', options)) return\r\n\r\n    let desiredIndentLevel, indentAdjustment\r\n    const oldBufferRange = this.getBufferRange()\r\n    const wasReversed = this.isReversed()\r\n    this.clear(options)\r\n\r\n    let autoIndentFirstLine = false\r\n    const precedingText = this.editor.getTextInRange([[oldBufferRange.start.row, 0], oldBufferRange.start])\r\n    const remainingLines = text.split('\\n')\r\n    const firstInsertedLine = remainingLines.shift()\r\n\r\n    if (options.indentBasis != null && !options.preserveTrailingLineIndentation) {\r\n      indentAdjustment = this.editor.indentLevelForLine(precedingText) - options.indentBasis\r\n      this.adjustIndent(remainingLines, indentAdjustment)\r\n    }\r\n\r\n    const textIsAutoIndentable = (text === '\\n') || (text === '\\r\\n') || NonWhitespaceRegExp.test(text)\r\n    if (options.autoIndent && textIsAutoIndentable && !NonWhitespaceRegExp.test(precedingText) && (remainingLines.length > 0)) {\r\n      autoIndentFirstLine = true\r\n      const firstLine = precedingText + firstInsertedLine\r\n      const languageMode = this.editor.buffer.getLanguageMode()\r\n      desiredIndentLevel = (\r\n        languageMode.suggestedIndentForLineAtBufferRow &&\r\n        languageMode.suggestedIndentForLineAtBufferRow(\r\n          oldBufferRange.start.row,\r\n          firstLine,\r\n          this.editor.getTabLength()\r\n        )\r\n      )\r\n      if (desiredIndentLevel != null) {\r\n        indentAdjustment = desiredIndentLevel - this.editor.indentLevelForLine(firstLine)\r\n        this.adjustIndent(remainingLines, indentAdjustment)\r\n      }\r\n    }\r\n\r\n    text = firstInsertedLine\r\n    if (remainingLines.length > 0) text += `\\n${remainingLines.join('\\n')}`\r\n\r\n    const newBufferRange = this.editor.buffer.setTextInRange(oldBufferRange, text, pick(options, 'undo', 'normalizeLineEndings'))\r\n\r\n    if (options.select) {\r\n      this.setBufferRange(newBufferRange, {reversed: wasReversed})\r\n    } else {\r\n      if (wasReversed) this.cursor.setBufferPosition(newBufferRange.end)\r\n    }\r\n\r\n    if (autoIndentFirstLine) {\r\n      this.editor.setIndentationForBufferRow(oldBufferRange.start.row, desiredIndentLevel)\r\n    }\r\n\r\n    if (options.autoIndentNewline && (text === '\\n')) {\r\n      this.editor.autoIndentBufferRow(newBufferRange.end.row, {preserveLeadingWhitespace: true, skipBlankLines: false})\r\n    } else if (options.autoDecreaseIndent && NonWhitespaceRegExp.test(text)) {\r\n      this.editor.autoDecreaseIndentForBufferRow(newBufferRange.start.row)\r\n    }\r\n\r\n    const autoscroll = options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.autoscroll()\r\n\r\n    return newBufferRange\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.clear",
            "start_line": 197,
            "end_line": 205,
            "comment": [
                "\r\n  Section: Modifying the selected range\r\n  ",
                " Public: Clears the selection, moving the marker to the head.",
                "",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     range. Defaults to `true` if this is the most recently added selection,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "clear",
            "line": 457,
            "func_location": "Selection.insertText",
            "func_start_line": 451,
            "func_end_line": 513,
            "args": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                "\r\n  Section: Modifying the selected text\r\n  ",
                " Public: Replaces text at the current selection.",
                "",
                " * `text` A {String} representing the text to add",
                " * `options` (optional) {Object} with keys:",
                "   * `select` If `true`, selects the newly added text.",
                "   * `autoIndent` If `true`, indents all inserted text appropriately.",
                "   * `autoIndentNewline` If `true`, indent newline appropriately.",
                "   * `autoDecreaseIndent` If `true`, decreases indent level appropriately",
                "     (for example, when a closing bracket is inserted).",
                "   * `preserveTrailingLineIndentation` By default, when pasting multiple",
                "   lines, Atom attempts to preserve the relative indent level between the",
                "   first line and trailing lines, even if the indent level of the first",
                "   line has changed from the copied text. If this option is `true`, this",
                "   behavior is suppressed.",
                "     level between the first lines and the trailing lines.",
                "   * `normalizeLineEndings` (optional) {Boolean} (default: true)",
                "   * `undo` *Deprecated* If `skip`, skips the undo stack for this operation. This property is deprecated. Call groupLastChanges() on the {TextBuffer} afterward instead.",
                "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)"
            ],
            "code": "  insertText (text, options = {}) {\r\n    if (!this.ensureWritable('insertText', options)) return\r\n\r\n    let desiredIndentLevel, indentAdjustment\r\n    const oldBufferRange = this.getBufferRange()\r\n    const wasReversed = this.isReversed()\r\n    this.clear(options)\r\n\r\n    let autoIndentFirstLine = false\r\n    const precedingText = this.editor.getTextInRange([[oldBufferRange.start.row, 0], oldBufferRange.start])\r\n    const remainingLines = text.split('\\n')\r\n    const firstInsertedLine = remainingLines.shift()\r\n\r\n    if (options.indentBasis != null && !options.preserveTrailingLineIndentation) {\r\n      indentAdjustment = this.editor.indentLevelForLine(precedingText) - options.indentBasis\r\n      this.adjustIndent(remainingLines, indentAdjustment)\r\n    }\r\n\r\n    const textIsAutoIndentable = (text === '\\n') || (text === '\\r\\n') || NonWhitespaceRegExp.test(text)\r\n    if (options.autoIndent && textIsAutoIndentable && !NonWhitespaceRegExp.test(precedingText) && (remainingLines.length > 0)) {\r\n      autoIndentFirstLine = true\r\n      const firstLine = precedingText + firstInsertedLine\r\n      const languageMode = this.editor.buffer.getLanguageMode()\r\n      desiredIndentLevel = (\r\n        languageMode.suggestedIndentForLineAtBufferRow &&\r\n        languageMode.suggestedIndentForLineAtBufferRow(\r\n          oldBufferRange.start.row,\r\n          firstLine,\r\n          this.editor.getTabLength()\r\n        )\r\n      )\r\n      if (desiredIndentLevel != null) {\r\n        indentAdjustment = desiredIndentLevel - this.editor.indentLevelForLine(firstLine)\r\n        this.adjustIndent(remainingLines, indentAdjustment)\r\n      }\r\n    }\r\n\r\n    text = firstInsertedLine\r\n    if (remainingLines.length > 0) text += `\\n${remainingLines.join('\\n')}`\r\n\r\n    const newBufferRange = this.editor.buffer.setTextInRange(oldBufferRange, text, pick(options, 'undo', 'normalizeLineEndings'))\r\n\r\n    if (options.select) {\r\n      this.setBufferRange(newBufferRange, {reversed: wasReversed})\r\n    } else {\r\n      if (wasReversed) this.cursor.setBufferPosition(newBufferRange.end)\r\n    }\r\n\r\n    if (autoIndentFirstLine) {\r\n      this.editor.setIndentationForBufferRow(oldBufferRange.start.row, desiredIndentLevel)\r\n    }\r\n\r\n    if (options.autoIndentNewline && (text === '\\n')) {\r\n      this.editor.autoIndentBufferRow(newBufferRange.end.row, {preserveLeadingWhitespace: true, skipBlankLines: false})\r\n    } else if (options.autoDecreaseIndent && NonWhitespaceRegExp.test(text)) {\r\n      this.editor.autoDecreaseIndentForBufferRow(newBufferRange.start.row)\r\n    }\r\n\r\n    const autoscroll = options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.autoscroll()\r\n\r\n    return newBufferRange\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.clear",
            "start_line": 197,
            "end_line": 205,
            "comment": [
                "\r\n  Section: Modifying the selected range\r\n  ",
                " Public: Clears the selection, moving the marker to the head.",
                "",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     range. Defaults to `true` if this is the most recently added selection,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "setBufferRange",
            "line": 494,
            "func_location": "Selection.insertText",
            "func_start_line": 451,
            "func_end_line": 513,
            "args": [
                {
                    "name": "newBufferRange",
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Modifying the selected text\r\n  ",
                " Public: Replaces text at the current selection.",
                "",
                " * `text` A {String} representing the text to add",
                " * `options` (optional) {Object} with keys:",
                "   * `select` If `true`, selects the newly added text.",
                "   * `autoIndent` If `true`, indents all inserted text appropriately.",
                "   * `autoIndentNewline` If `true`, indent newline appropriately.",
                "   * `autoDecreaseIndent` If `true`, decreases indent level appropriately",
                "     (for example, when a closing bracket is inserted).",
                "   * `preserveTrailingLineIndentation` By default, when pasting multiple",
                "   lines, Atom attempts to preserve the relative indent level between the",
                "   first line and trailing lines, even if the indent level of the first",
                "   line has changed from the copied text. If this option is `true`, this",
                "   behavior is suppressed.",
                "     level between the first lines and the trailing lines.",
                "   * `normalizeLineEndings` (optional) {Boolean} (default: true)",
                "   * `undo` *Deprecated* If `skip`, skips the undo stack for this operation. This property is deprecated. Call groupLastChanges() on the {TextBuffer} afterward instead.",
                "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)"
            ],
            "code": "  insertText (text, options = {}) {\r\n    if (!this.ensureWritable('insertText', options)) return\r\n\r\n    let desiredIndentLevel, indentAdjustment\r\n    const oldBufferRange = this.getBufferRange()\r\n    const wasReversed = this.isReversed()\r\n    this.clear(options)\r\n\r\n    let autoIndentFirstLine = false\r\n    const precedingText = this.editor.getTextInRange([[oldBufferRange.start.row, 0], oldBufferRange.start])\r\n    const remainingLines = text.split('\\n')\r\n    const firstInsertedLine = remainingLines.shift()\r\n\r\n    if (options.indentBasis != null && !options.preserveTrailingLineIndentation) {\r\n      indentAdjustment = this.editor.indentLevelForLine(precedingText) - options.indentBasis\r\n      this.adjustIndent(remainingLines, indentAdjustment)\r\n    }\r\n\r\n    const textIsAutoIndentable = (text === '\\n') || (text === '\\r\\n') || NonWhitespaceRegExp.test(text)\r\n    if (options.autoIndent && textIsAutoIndentable && !NonWhitespaceRegExp.test(precedingText) && (remainingLines.length > 0)) {\r\n      autoIndentFirstLine = true\r\n      const firstLine = precedingText + firstInsertedLine\r\n      const languageMode = this.editor.buffer.getLanguageMode()\r\n      desiredIndentLevel = (\r\n        languageMode.suggestedIndentForLineAtBufferRow &&\r\n        languageMode.suggestedIndentForLineAtBufferRow(\r\n          oldBufferRange.start.row,\r\n          firstLine,\r\n          this.editor.getTabLength()\r\n        )\r\n      )\r\n      if (desiredIndentLevel != null) {\r\n        indentAdjustment = desiredIndentLevel - this.editor.indentLevelForLine(firstLine)\r\n        this.adjustIndent(remainingLines, indentAdjustment)\r\n      }\r\n    }\r\n\r\n    text = firstInsertedLine\r\n    if (remainingLines.length > 0) text += `\\n${remainingLines.join('\\n')}`\r\n\r\n    const newBufferRange = this.editor.buffer.setTextInRange(oldBufferRange, text, pick(options, 'undo', 'normalizeLineEndings'))\r\n\r\n    if (options.select) {\r\n      this.setBufferRange(newBufferRange, {reversed: wasReversed})\r\n    } else {\r\n      if (wasReversed) this.cursor.setBufferPosition(newBufferRange.end)\r\n    }\r\n\r\n    if (autoIndentFirstLine) {\r\n      this.editor.setIndentationForBufferRow(oldBufferRange.start.row, desiredIndentLevel)\r\n    }\r\n\r\n    if (options.autoIndentNewline && (text === '\\n')) {\r\n      this.editor.autoIndentBufferRow(newBufferRange.end.row, {preserveLeadingWhitespace: true, skipBlankLines: false})\r\n    } else if (options.autoDecreaseIndent && NonWhitespaceRegExp.test(text)) {\r\n      this.editor.autoDecreaseIndentForBufferRow(newBufferRange.start.row)\r\n    }\r\n\r\n    const autoscroll = options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.autoscroll()\r\n\r\n    return newBufferRange\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.setBufferRange",
            "start_line": 92,
            "end_line": 104,
            "comment": [
                " Public: Modifies the buffer {Range} for the selection.",
                "",
                " * `bufferRange` The new {Range} to select.",
                " * `options` (optional) {Object} with the keys:",
                "   * `preserveFolds` if `true`, the fold settings are preserved after the",
                "     selection moves.",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     range. Defaults to `true` if this is the most recently added selection,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferRange",
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "setBufferRange",
            "line": 494,
            "func_location": "Selection.insertText",
            "func_start_line": 451,
            "func_end_line": 513,
            "args": [
                {
                    "name": "newBufferRange",
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Modifying the selected text\r\n  ",
                " Public: Replaces text at the current selection.",
                "",
                " * `text` A {String} representing the text to add",
                " * `options` (optional) {Object} with keys:",
                "   * `select` If `true`, selects the newly added text.",
                "   * `autoIndent` If `true`, indents all inserted text appropriately.",
                "   * `autoIndentNewline` If `true`, indent newline appropriately.",
                "   * `autoDecreaseIndent` If `true`, decreases indent level appropriately",
                "     (for example, when a closing bracket is inserted).",
                "   * `preserveTrailingLineIndentation` By default, when pasting multiple",
                "   lines, Atom attempts to preserve the relative indent level between the",
                "   first line and trailing lines, even if the indent level of the first",
                "   line has changed from the copied text. If this option is `true`, this",
                "   behavior is suppressed.",
                "     level between the first lines and the trailing lines.",
                "   * `normalizeLineEndings` (optional) {Boolean} (default: true)",
                "   * `undo` *Deprecated* If `skip`, skips the undo stack for this operation. This property is deprecated. Call groupLastChanges() on the {TextBuffer} afterward instead.",
                "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)"
            ],
            "code": "  insertText (text, options = {}) {\r\n    if (!this.ensureWritable('insertText', options)) return\r\n\r\n    let desiredIndentLevel, indentAdjustment\r\n    const oldBufferRange = this.getBufferRange()\r\n    const wasReversed = this.isReversed()\r\n    this.clear(options)\r\n\r\n    let autoIndentFirstLine = false\r\n    const precedingText = this.editor.getTextInRange([[oldBufferRange.start.row, 0], oldBufferRange.start])\r\n    const remainingLines = text.split('\\n')\r\n    const firstInsertedLine = remainingLines.shift()\r\n\r\n    if (options.indentBasis != null && !options.preserveTrailingLineIndentation) {\r\n      indentAdjustment = this.editor.indentLevelForLine(precedingText) - options.indentBasis\r\n      this.adjustIndent(remainingLines, indentAdjustment)\r\n    }\r\n\r\n    const textIsAutoIndentable = (text === '\\n') || (text === '\\r\\n') || NonWhitespaceRegExp.test(text)\r\n    if (options.autoIndent && textIsAutoIndentable && !NonWhitespaceRegExp.test(precedingText) && (remainingLines.length > 0)) {\r\n      autoIndentFirstLine = true\r\n      const firstLine = precedingText + firstInsertedLine\r\n      const languageMode = this.editor.buffer.getLanguageMode()\r\n      desiredIndentLevel = (\r\n        languageMode.suggestedIndentForLineAtBufferRow &&\r\n        languageMode.suggestedIndentForLineAtBufferRow(\r\n          oldBufferRange.start.row,\r\n          firstLine,\r\n          this.editor.getTabLength()\r\n        )\r\n      )\r\n      if (desiredIndentLevel != null) {\r\n        indentAdjustment = desiredIndentLevel - this.editor.indentLevelForLine(firstLine)\r\n        this.adjustIndent(remainingLines, indentAdjustment)\r\n      }\r\n    }\r\n\r\n    text = firstInsertedLine\r\n    if (remainingLines.length > 0) text += `\\n${remainingLines.join('\\n')}`\r\n\r\n    const newBufferRange = this.editor.buffer.setTextInRange(oldBufferRange, text, pick(options, 'undo', 'normalizeLineEndings'))\r\n\r\n    if (options.select) {\r\n      this.setBufferRange(newBufferRange, {reversed: wasReversed})\r\n    } else {\r\n      if (wasReversed) this.cursor.setBufferPosition(newBufferRange.end)\r\n    }\r\n\r\n    if (autoIndentFirstLine) {\r\n      this.editor.setIndentationForBufferRow(oldBufferRange.start.row, desiredIndentLevel)\r\n    }\r\n\r\n    if (options.autoIndentNewline && (text === '\\n')) {\r\n      this.editor.autoIndentBufferRow(newBufferRange.end.row, {preserveLeadingWhitespace: true, skipBlankLines: false})\r\n    } else if (options.autoDecreaseIndent && NonWhitespaceRegExp.test(text)) {\r\n      this.editor.autoDecreaseIndentForBufferRow(newBufferRange.start.row)\r\n    }\r\n\r\n    const autoscroll = options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.autoscroll()\r\n\r\n    return newBufferRange\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.setBufferRange",
            "start_line": 92,
            "end_line": 104,
            "comment": [
                " Public: Modifies the buffer {Range} for the selection.",
                "",
                " * `bufferRange` The new {Range} to select.",
                " * `options` (optional) {Object} with the keys:",
                "   * `preserveFolds` if `true`, the fold settings are preserved after the",
                "     selection moves.",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     range. Defaults to `true` if this is the most recently added selection,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferRange",
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "setBufferPosition",
            "line": 496,
            "func_location": "Selection.insertText",
            "func_start_line": 451,
            "func_end_line": 513,
            "args": [
                {
                    "name": "newBufferRange.end",
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Modifying the selected text\r\n  ",
                " Public: Replaces text at the current selection.",
                "",
                " * `text` A {String} representing the text to add",
                " * `options` (optional) {Object} with keys:",
                "   * `select` If `true`, selects the newly added text.",
                "   * `autoIndent` If `true`, indents all inserted text appropriately.",
                "   * `autoIndentNewline` If `true`, indent newline appropriately.",
                "   * `autoDecreaseIndent` If `true`, decreases indent level appropriately",
                "     (for example, when a closing bracket is inserted).",
                "   * `preserveTrailingLineIndentation` By default, when pasting multiple",
                "   lines, Atom attempts to preserve the relative indent level between the",
                "   first line and trailing lines, even if the indent level of the first",
                "   line has changed from the copied text. If this option is `true`, this",
                "   behavior is suppressed.",
                "     level between the first lines and the trailing lines.",
                "   * `normalizeLineEndings` (optional) {Boolean} (default: true)",
                "   * `undo` *Deprecated* If `skip`, skips the undo stack for this operation. This property is deprecated. Call groupLastChanges() on the {TextBuffer} afterward instead.",
                "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)"
            ],
            "code": "  insertText (text, options = {}) {\r\n    if (!this.ensureWritable('insertText', options)) return\r\n\r\n    let desiredIndentLevel, indentAdjustment\r\n    const oldBufferRange = this.getBufferRange()\r\n    const wasReversed = this.isReversed()\r\n    this.clear(options)\r\n\r\n    let autoIndentFirstLine = false\r\n    const precedingText = this.editor.getTextInRange([[oldBufferRange.start.row, 0], oldBufferRange.start])\r\n    const remainingLines = text.split('\\n')\r\n    const firstInsertedLine = remainingLines.shift()\r\n\r\n    if (options.indentBasis != null && !options.preserveTrailingLineIndentation) {\r\n      indentAdjustment = this.editor.indentLevelForLine(precedingText) - options.indentBasis\r\n      this.adjustIndent(remainingLines, indentAdjustment)\r\n    }\r\n\r\n    const textIsAutoIndentable = (text === '\\n') || (text === '\\r\\n') || NonWhitespaceRegExp.test(text)\r\n    if (options.autoIndent && textIsAutoIndentable && !NonWhitespaceRegExp.test(precedingText) && (remainingLines.length > 0)) {\r\n      autoIndentFirstLine = true\r\n      const firstLine = precedingText + firstInsertedLine\r\n      const languageMode = this.editor.buffer.getLanguageMode()\r\n      desiredIndentLevel = (\r\n        languageMode.suggestedIndentForLineAtBufferRow &&\r\n        languageMode.suggestedIndentForLineAtBufferRow(\r\n          oldBufferRange.start.row,\r\n          firstLine,\r\n          this.editor.getTabLength()\r\n        )\r\n      )\r\n      if (desiredIndentLevel != null) {\r\n        indentAdjustment = desiredIndentLevel - this.editor.indentLevelForLine(firstLine)\r\n        this.adjustIndent(remainingLines, indentAdjustment)\r\n      }\r\n    }\r\n\r\n    text = firstInsertedLine\r\n    if (remainingLines.length > 0) text += `\\n${remainingLines.join('\\n')}`\r\n\r\n    const newBufferRange = this.editor.buffer.setTextInRange(oldBufferRange, text, pick(options, 'undo', 'normalizeLineEndings'))\r\n\r\n    if (options.select) {\r\n      this.setBufferRange(newBufferRange, {reversed: wasReversed})\r\n    } else {\r\n      if (wasReversed) this.cursor.setBufferPosition(newBufferRange.end)\r\n    }\r\n\r\n    if (autoIndentFirstLine) {\r\n      this.editor.setIndentationForBufferRow(oldBufferRange.start.row, desiredIndentLevel)\r\n    }\r\n\r\n    if (options.autoIndentNewline && (text === '\\n')) {\r\n      this.editor.autoIndentBufferRow(newBufferRange.end.row, {preserveLeadingWhitespace: true, skipBlankLines: false})\r\n    } else if (options.autoDecreaseIndent && NonWhitespaceRegExp.test(text)) {\r\n      this.editor.autoDecreaseIndentForBufferRow(newBufferRange.start.row)\r\n    }\r\n\r\n    const autoscroll = options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.autoscroll()\r\n\r\n    return newBufferRange\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "setBufferPosition",
            "line": 496,
            "func_location": "Selection.insertText",
            "func_start_line": 451,
            "func_end_line": 513,
            "args": [
                {
                    "name": "newBufferRange.end",
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Modifying the selected text\r\n  ",
                " Public: Replaces text at the current selection.",
                "",
                " * `text` A {String} representing the text to add",
                " * `options` (optional) {Object} with keys:",
                "   * `select` If `true`, selects the newly added text.",
                "   * `autoIndent` If `true`, indents all inserted text appropriately.",
                "   * `autoIndentNewline` If `true`, indent newline appropriately.",
                "   * `autoDecreaseIndent` If `true`, decreases indent level appropriately",
                "     (for example, when a closing bracket is inserted).",
                "   * `preserveTrailingLineIndentation` By default, when pasting multiple",
                "   lines, Atom attempts to preserve the relative indent level between the",
                "   first line and trailing lines, even if the indent level of the first",
                "   line has changed from the copied text. If this option is `true`, this",
                "   behavior is suppressed.",
                "     level between the first lines and the trailing lines.",
                "   * `normalizeLineEndings` (optional) {Boolean} (default: true)",
                "   * `undo` *Deprecated* If `skip`, skips the undo stack for this operation. This property is deprecated. Call groupLastChanges() on the {TextBuffer} afterward instead.",
                "   * `bypassReadOnly` (optional) {Boolean} Must be `true` to modify a read-only editor. (default: false)"
            ],
            "code": "  insertText (text, options = {}) {\r\n    if (!this.ensureWritable('insertText', options)) return\r\n\r\n    let desiredIndentLevel, indentAdjustment\r\n    const oldBufferRange = this.getBufferRange()\r\n    const wasReversed = this.isReversed()\r\n    this.clear(options)\r\n\r\n    let autoIndentFirstLine = false\r\n    const precedingText = this.editor.getTextInRange([[oldBufferRange.start.row, 0], oldBufferRange.start])\r\n    const remainingLines = text.split('\\n')\r\n    const firstInsertedLine = remainingLines.shift()\r\n\r\n    if (options.indentBasis != null && !options.preserveTrailingLineIndentation) {\r\n      indentAdjustment = this.editor.indentLevelForLine(precedingText) - options.indentBasis\r\n      this.adjustIndent(remainingLines, indentAdjustment)\r\n    }\r\n\r\n    const textIsAutoIndentable = (text === '\\n') || (text === '\\r\\n') || NonWhitespaceRegExp.test(text)\r\n    if (options.autoIndent && textIsAutoIndentable && !NonWhitespaceRegExp.test(precedingText) && (remainingLines.length > 0)) {\r\n      autoIndentFirstLine = true\r\n      const firstLine = precedingText + firstInsertedLine\r\n      const languageMode = this.editor.buffer.getLanguageMode()\r\n      desiredIndentLevel = (\r\n        languageMode.suggestedIndentForLineAtBufferRow &&\r\n        languageMode.suggestedIndentForLineAtBufferRow(\r\n          oldBufferRange.start.row,\r\n          firstLine,\r\n          this.editor.getTabLength()\r\n        )\r\n      )\r\n      if (desiredIndentLevel != null) {\r\n        indentAdjustment = desiredIndentLevel - this.editor.indentLevelForLine(firstLine)\r\n        this.adjustIndent(remainingLines, indentAdjustment)\r\n      }\r\n    }\r\n\r\n    text = firstInsertedLine\r\n    if (remainingLines.length > 0) text += `\\n${remainingLines.join('\\n')}`\r\n\r\n    const newBufferRange = this.editor.buffer.setTextInRange(oldBufferRange, text, pick(options, 'undo', 'normalizeLineEndings'))\r\n\r\n    if (options.select) {\r\n      this.setBufferRange(newBufferRange, {reversed: wasReversed})\r\n    } else {\r\n      if (wasReversed) this.cursor.setBufferPosition(newBufferRange.end)\r\n    }\r\n\r\n    if (autoIndentFirstLine) {\r\n      this.editor.setIndentationForBufferRow(oldBufferRange.start.row, desiredIndentLevel)\r\n    }\r\n\r\n    if (options.autoIndentNewline && (text === '\\n')) {\r\n      this.editor.autoIndentBufferRow(newBufferRange.end.row, {preserveLeadingWhitespace: true, skipBlankLines: false})\r\n    } else if (options.autoDecreaseIndent && NonWhitespaceRegExp.test(text)) {\r\n      this.editor.autoDecreaseIndentForBufferRow(newBufferRange.start.row)\r\n    }\r\n\r\n    const autoscroll = options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n    if (autoscroll) this.autoscroll()\r\n\r\n    return newBufferRange\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "getBufferRange",
            "line": 167,
            "func_location": "Selection.intersectsBufferRange",
            "func_start_line": 166,
            "func_end_line": 168,
            "args": [
                {
                    "name": "bufferRange",
                    "type": []
                }
            ],
            "comment": [
                " Public: Identifies if a selection intersects with a given buffer range.",
                "",
                " * `bufferRange` A {Range} to check against.",
                "",
                " Returns a {Boolean}"
            ],
            "code": "  intersectsBufferRange (bufferRange) {\r\n    return this.getBufferRange().intersectsWith(bufferRange)\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.getBufferRange",
            "start_line": 79,
            "end_line": 81,
            "comment": [
                " Public: Returns the buffer {Range} for the selection."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "intersectsWith",
            "line": 167,
            "func_location": "Selection.intersectsBufferRange",
            "func_start_line": 166,
            "func_end_line": 168,
            "args": [
                {
                    "name": "bufferRange",
                    "type": []
                }
            ],
            "comment": [
                " Public: Identifies if a selection intersects with a given buffer range.",
                "",
                " * `bufferRange` A {Range} to check against.",
                "",
                " Returns a {Boolean}"
            ],
            "code": "  intersectsBufferRange (bufferRange) {\r\n    return this.getBufferRange().intersectsWith(bufferRange)\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.intersectsWith",
            "start_line": 183,
            "end_line": 185,
            "comment": [
                " Public: Identifies if a selection intersects with another selection.",
                "",
                " * `otherSelection` A {Selection} to check against.",
                "",
                " Returns a {Boolean}"
            ],
            "params": [
                {
                    "name": "otherSelection",
                    "type": []
                },
                {
                    "name": "exclusive",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "intersectsWith",
            "line": 167,
            "func_location": "Selection.intersectsBufferRange",
            "func_start_line": 166,
            "func_end_line": 168,
            "args": [
                {
                    "name": "bufferRange",
                    "type": []
                }
            ],
            "comment": [
                " Public: Identifies if a selection intersects with a given buffer range.",
                "",
                " * `bufferRange` A {Range} to check against.",
                "",
                " Returns a {Boolean}"
            ],
            "code": "  intersectsBufferRange (bufferRange) {\r\n    return this.getBufferRange().intersectsWith(bufferRange)\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.intersectsWith",
            "start_line": 183,
            "end_line": 185,
            "comment": [
                " Public: Identifies if a selection intersects with another selection.",
                "",
                " * `otherSelection` A {Selection} to check against.",
                "",
                " Returns a {Boolean}"
            ],
            "params": [
                {
                    "name": "otherSelection",
                    "type": []
                },
                {
                    "name": "exclusive",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "getBufferRange",
            "line": 184,
            "func_location": "Selection.intersectsWith",
            "func_start_line": 183,
            "func_end_line": 185,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": "exclusive",
                    "type": []
                }
            ],
            "comment": [
                " Public: Identifies if a selection intersects with another selection.",
                "",
                " * `otherSelection` A {Selection} to check against.",
                "",
                " Returns a {Boolean}"
            ],
            "code": "  intersectsWith (otherSelection, exclusive) {\r\n    return this.getBufferRange().intersectsWith(otherSelection.getBufferRange(), exclusive)\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.getBufferRange",
            "start_line": 79,
            "end_line": 81,
            "comment": [
                " Public: Returns the buffer {Range} for the selection."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "intersectsWith",
            "line": 184,
            "func_location": "Selection.intersectsWith",
            "func_start_line": 183,
            "func_end_line": 185,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": "exclusive",
                    "type": []
                }
            ],
            "comment": [
                " Public: Identifies if a selection intersects with another selection.",
                "",
                " * `otherSelection` A {Selection} to check against.",
                "",
                " Returns a {Boolean}"
            ],
            "code": "  intersectsWith (otherSelection, exclusive) {\r\n    return this.getBufferRange().intersectsWith(otherSelection.getBufferRange(), exclusive)\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.intersectsWith",
            "start_line": 183,
            "end_line": 185,
            "comment": [
                " Public: Identifies if a selection intersects with another selection.",
                "",
                " * `otherSelection` A {Selection} to check against.",
                "",
                " Returns a {Boolean}"
            ],
            "params": [
                {
                    "name": "otherSelection",
                    "type": []
                },
                {
                    "name": "exclusive",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "intersectsWith",
            "line": 184,
            "func_location": "Selection.intersectsWith",
            "func_start_line": 183,
            "func_end_line": 185,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": "exclusive",
                    "type": []
                }
            ],
            "comment": [
                " Public: Identifies if a selection intersects with another selection.",
                "",
                " * `otherSelection` A {Selection} to check against.",
                "",
                " Returns a {Boolean}"
            ],
            "code": "  intersectsWith (otherSelection, exclusive) {\r\n    return this.getBufferRange().intersectsWith(otherSelection.getBufferRange(), exclusive)\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.intersectsWith",
            "start_line": 183,
            "end_line": 185,
            "comment": [
                " Public: Identifies if a selection intersects with another selection.",
                "",
                " * `otherSelection` A {Selection} to check against.",
                "",
                " Returns a {Boolean}"
            ],
            "params": [
                {
                    "name": "otherSelection",
                    "type": []
                },
                {
                    "name": "exclusive",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "getBufferRange",
            "line": 184,
            "func_location": "Selection.intersectsWith",
            "func_start_line": 183,
            "func_end_line": 185,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": "exclusive",
                    "type": []
                }
            ],
            "comment": [
                " Public: Identifies if a selection intersects with another selection.",
                "",
                " * `otherSelection` A {Selection} to check against.",
                "",
                " Returns a {Boolean}"
            ],
            "code": "  intersectsWith (otherSelection, exclusive) {\r\n    return this.getBufferRange().intersectsWith(otherSelection.getBufferRange(), exclusive)\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.getBufferRange",
            "start_line": 79,
            "end_line": 81,
            "comment": [
                " Public: Returns the buffer {Range} for the selection."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-element.js",
            "name": "getComponent",
            "line": 307,
            "func_location": "TextEditorElement.invalidateBlockDecorationDimensions",
            "func_start_line": 306,
            "func_end_line": 308,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Experimental: Invalidate the passed block {Decoration}'s dimensions,",
                " forcing them to be recalculated and the surrounding content to be adjusted",
                " on the next animation frame.",
                "",
                " * {blockDecoration} A {Decoration} representing the block decoration you",
                " want to update the dimensions of."
            ],
            "code": "  invalidateBlockDecorationDimensions () {\r\n    this.getComponent().invalidateBlockDecorationDimensions(...arguments)\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-element.js",
            "name": "TextEditorElement.getComponent",
            "start_line": 276,
            "end_line": 288,
            "comment": [],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getBufferPosition",
            "line": 128,
            "func_location": "Cursor.isAtEndOfLine",
            "func_start_line": 127,
            "func_end_line": 129,
            "args": [
                {
                    "name": ".end",
                    "type": []
                }
            ],
            "comment": [
                " Public: Returns whether the cursor is on the line return character."
            ],
            "code": "  isAtEndOfLine () {\r\n    return this.getBufferPosition().isEqual(this.getCurrentLineBufferRange().end)\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getBufferPosition",
            "start_line": 91,
            "end_line": 93,
            "comment": [
                " Public: Returns the current buffer position as an Array."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getCurrentLineBufferRange",
            "line": 128,
            "func_location": "Cursor.isAtEndOfLine",
            "func_start_line": 127,
            "func_end_line": 129,
            "args": [
                {
                    "name": ".end",
                    "type": []
                }
            ],
            "comment": [
                " Public: Returns whether the cursor is on the line return character."
            ],
            "code": "  isAtEndOfLine () {\r\n    return this.getBufferPosition().isEqual(this.getCurrentLineBufferRange().end)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getCurrentLineBufferRange",
            "start_line": 623,
            "end_line": 625,
            "comment": [
                " Public: Returns the buffer Range for the current line.",
                "",
                " * `options` (optional) {Object}",
                "   * `includeNewline` A {Boolean} which controls whether the Range should",
                "     include the newline."
            ],
            "params": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getCurrentLineBufferRange",
            "line": 128,
            "func_location": "Cursor.isAtEndOfLine",
            "func_start_line": 127,
            "func_end_line": 129,
            "args": [
                {
                    "name": ".end",
                    "type": []
                }
            ],
            "comment": [
                " Public: Returns whether the cursor is on the line return character."
            ],
            "code": "  isAtEndOfLine () {\r\n    return this.getBufferPosition().isEqual(this.getCurrentLineBufferRange().end)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getCurrentLineBufferRange",
            "start_line": 623,
            "end_line": 625,
            "comment": [
                " Public: Returns the buffer Range for the current line.",
                "",
                " * `options` (optional) {Object}",
                "   * `includeNewline` A {Boolean} which controls whether the Range should",
                "     include the newline."
            ],
            "params": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/color.js",
            "name": "parse",
            "line": 101,
            "func_location": "Color.isEqual",
            "func_start_line": 95,
            "func_end_line": 109,
            "args": [
                "color"
            ],
            "code": "  isEqual (color) {\r\n    if (this === color) {\r\n      return true\r\n    }\r\n\r\n    if (!(color instanceof Color)) {\r\n      color = Color.parse(color)\r\n    }\r\n\r\n    if (color == null) {\r\n      return false\r\n    }\r\n\r\n    return color.red === this.red && color.blue === this.blue && color.green === this.green && color.alpha === this.alpha\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/color.js",
            "name": "Color.parse",
            "start_line": 14,
            "end_line": 36,
            "comment": [
                " Essential: Parse a {String} or {Object} into a {Color}.",
                "",
                " * `value` A {String} such as `'white'`, `#ff00ff`, or",
                "   `'rgba(255, 15, 60, .75)'` or an {Object} with `red`, `green`, `blue`,",
                "   and `alpha` properties.",
                "",
                " Returns a {Color} or `null` if it cannot be parsed."
            ],
            "params": [
                {
                    "name": "value",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "null",
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "wordRegExp",
            "line": 182,
            "func_location": "Cursor.isInsideWord",
            "func_start_line": 178,
            "func_end_line": 183,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Returns whether this cursor is between a word's start and end.",
                "",
                " * `options` (optional) {Object}",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "     (default: {::wordRegExp}).",
                "",
                " Returns a {Boolean}"
            ],
            "code": "  isInsideWord (options) {\r\n    const {row, column} = this.getBufferPosition()\r\n    const range = [[row, column], [row, Infinity]]\r\n    const text = this.editor.getTextInBufferRange(range)\r\n    return text.search((options && options.wordRegex) || this.wordRegExp()) === 0\r\n  }\r",
            "return_type": [
                "null",
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.wordRegExp",
            "start_line": 674,
            "end_line": 679
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 349,
            "func_location": "GitRepository.isPathIgnored",
            "func_start_line": 348,
            "func_end_line": 350,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Is the given path ignored?",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns a {Boolean} that's true if the `path` is ignored."
            ],
            "code": "  isPathIgnored (path) {\r\n    return this.getRepo().isIgnored(this.relativize(path))\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 349,
            "func_location": "GitRepository.isPathIgnored",
            "func_start_line": 348,
            "func_end_line": 350,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Is the given path ignored?",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns a {Boolean} that's true if the `path` is ignored."
            ],
            "code": "  isPathIgnored (path) {\r\n    return this.getRepo().isIgnored(this.relativize(path))\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "relativize",
            "line": 349,
            "func_location": "GitRepository.isPathIgnored",
            "func_start_line": 348,
            "func_end_line": 350,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Is the given path ignored?",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns a {Boolean} that's true if the `path` is ignored."
            ],
            "code": "  isPathIgnored (path) {\r\n    return this.getRepo().isIgnored(this.relativize(path))\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.relativize",
            "start_line": 208,
            "end_line": 210,
            "comment": [
                " Public: Makes a path relative to the repository's working directory."
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "relativize",
            "line": 349,
            "func_location": "GitRepository.isPathIgnored",
            "func_start_line": 348,
            "func_end_line": 350,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Is the given path ignored?",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns a {Boolean} that's true if the `path` is ignored."
            ],
            "code": "  isPathIgnored (path) {\r\n    return this.getRepo().isIgnored(this.relativize(path))\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.relativize",
            "start_line": 208,
            "end_line": 210,
            "comment": [
                " Public: Makes a path relative to the repository's working directory."
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "isStatusModified",
            "line": 331,
            "func_location": "GitRepository.isPathModified",
            "func_start_line": 330,
            "func_end_line": 332,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Reading Status\r\n  ",
                " Public: Returns true if the given path is modified.",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns a {Boolean} that's true if the `path` is modified."
            ],
            "code": "  isPathModified (path) {\r\n    return this.isStatusModified(this.getPathStatus(path))\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.isStatusModified",
            "start_line": 406,
            "end_line": 406,
            "comment": [
                " Public: Returns true if the given status indicates modification.",
                "",
                " * `status` A {Number} representing the status.",
                "",
                " Returns a {Boolean} that's true if the `status` indicates modification."
            ],
            "params": [
                {
                    "name": "status",
                    "type": [
                        "number"
                    ]
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "isStatusModified",
            "line": 331,
            "func_location": "GitRepository.isPathModified",
            "func_start_line": 330,
            "func_end_line": 332,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Reading Status\r\n  ",
                " Public: Returns true if the given path is modified.",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns a {Boolean} that's true if the `path` is modified."
            ],
            "code": "  isPathModified (path) {\r\n    return this.isStatusModified(this.getPathStatus(path))\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.isStatusModified",
            "start_line": 406,
            "end_line": 406,
            "comment": [
                " Public: Returns true if the given status indicates modification.",
                "",
                " * `status` A {Number} representing the status.",
                "",
                " Returns a {Boolean} that's true if the `status` indicates modification."
            ],
            "params": [
                {
                    "name": "status",
                    "type": [
                        "number"
                    ]
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getPathStatus",
            "line": 331,
            "func_location": "GitRepository.isPathModified",
            "func_start_line": 330,
            "func_end_line": 332,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Reading Status\r\n  ",
                " Public: Returns true if the given path is modified.",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns a {Boolean} that's true if the `path` is modified."
            ],
            "code": "  isPathModified (path) {\r\n    return this.isStatusModified(this.getPathStatus(path))\r\n  }\r",
            "return_type": [
                "number",
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getPathStatus",
            "start_line": 374,
            "end_line": 390,
            "comment": [
                " Public: Get the status of a single path in the repository.",
                "",
                " * `path` A {String} repository-relative path.",
                "",
                " Returns a {Number} representing the status. This value can be passed to",
                " {::isStatusModified} or {::isStatusNew} to get more information."
            ],
            "params": [
                {
                    "name": "path",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "number",
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getPathStatus",
            "line": 331,
            "func_location": "GitRepository.isPathModified",
            "func_start_line": 330,
            "func_end_line": 332,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Reading Status\r\n  ",
                " Public: Returns true if the given path is modified.",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns a {Boolean} that's true if the `path` is modified."
            ],
            "code": "  isPathModified (path) {\r\n    return this.isStatusModified(this.getPathStatus(path))\r\n  }\r",
            "return_type": [
                "number",
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getPathStatus",
            "start_line": 374,
            "end_line": 390,
            "comment": [
                " Public: Get the status of a single path in the repository.",
                "",
                " * `path` A {String} repository-relative path.",
                "",
                " Returns a {Number} representing the status. This value can be passed to",
                " {::isStatusModified} or {::isStatusNew} to get more information."
            ],
            "params": [
                {
                    "name": "path",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "number",
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "isStatusNew",
            "line": 340,
            "func_location": "GitRepository.isPathNew",
            "func_start_line": 339,
            "func_end_line": 341,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Returns true if the given path is new.",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns a {Boolean} that's true if the `path` is new."
            ],
            "code": "  isPathNew (path) {\r\n    return this.isStatusNew(this.getPathStatus(path))\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.isStatusNew",
            "start_line": 413,
            "end_line": 415,
            "comment": [
                " Public: Returns true if the given status indicates a new path.",
                "",
                " * `status` A {Number} representing the status.",
                "",
                " Returns a {Boolean} that's true if the `status` indicates a new path."
            ],
            "params": [
                {
                    "name": "status",
                    "type": [
                        "number"
                    ]
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "isStatusNew",
            "line": 340,
            "func_location": "GitRepository.isPathNew",
            "func_start_line": 339,
            "func_end_line": 341,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Returns true if the given path is new.",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns a {Boolean} that's true if the `path` is new."
            ],
            "code": "  isPathNew (path) {\r\n    return this.isStatusNew(this.getPathStatus(path))\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.isStatusNew",
            "start_line": 413,
            "end_line": 415,
            "comment": [
                " Public: Returns true if the given status indicates a new path.",
                "",
                " * `status` A {Number} representing the status.",
                "",
                " Returns a {Boolean} that's true if the `status` indicates a new path."
            ],
            "params": [
                {
                    "name": "status",
                    "type": [
                        "number"
                    ]
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getPathStatus",
            "line": 340,
            "func_location": "GitRepository.isPathNew",
            "func_start_line": 339,
            "func_end_line": 341,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Returns true if the given path is new.",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns a {Boolean} that's true if the `path` is new."
            ],
            "code": "  isPathNew (path) {\r\n    return this.isStatusNew(this.getPathStatus(path))\r\n  }\r",
            "return_type": [
                "number",
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getPathStatus",
            "start_line": 374,
            "end_line": 390,
            "comment": [
                " Public: Get the status of a single path in the repository.",
                "",
                " * `path` A {String} repository-relative path.",
                "",
                " Returns a {Number} representing the status. This value can be passed to",
                " {::isStatusModified} or {::isStatusNew} to get more information."
            ],
            "params": [
                {
                    "name": "path",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "number",
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getPathStatus",
            "line": 340,
            "func_location": "GitRepository.isPathNew",
            "func_start_line": 339,
            "func_end_line": 341,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Returns true if the given path is new.",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns a {Boolean} that's true if the `path` is new."
            ],
            "code": "  isPathNew (path) {\r\n    return this.isStatusNew(this.getPathStatus(path))\r\n  }\r",
            "return_type": [
                "number",
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getPathStatus",
            "start_line": 374,
            "end_line": 390,
            "comment": [
                " Public: Get the status of a single path in the repository.",
                "",
                " * `path` A {String} repository-relative path.",
                "",
                " Returns a {Number} representing the status. This value can be passed to",
                " {::isStatusModified} or {::isStatusNew} to get more information."
            ],
            "params": [
                {
                    "name": "path",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "number",
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "relativize",
            "line": 202,
            "func_location": "GitRepository.isProjectAtRoot",
            "func_start_line": 200,
            "func_end_line": 205,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Returns true if at the root, false if in a subfolder of the",
                " repository."
            ],
            "code": "  isProjectAtRoot () {\r\n    if (this.projectAtRoot == null) {\r\n      this.projectAtRoot = this.project && this.project.relativize(this.getWorkingDirectory()) === ''\r\n    }\r\n    return this.projectAtRoot\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.relativize",
            "start_line": 208,
            "end_line": 210,
            "comment": [
                " Public: Makes a path relative to the repository's working directory."
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "relativize",
            "line": 202,
            "func_location": "GitRepository.isProjectAtRoot",
            "func_start_line": 200,
            "func_end_line": 205,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Returns true if at the root, false if in a subfolder of the",
                " repository."
            ],
            "code": "  isProjectAtRoot () {\r\n    if (this.projectAtRoot == null) {\r\n      this.projectAtRoot = this.project && this.project.relativize(this.getWorkingDirectory()) === ''\r\n    }\r\n    return this.projectAtRoot\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.relativize",
            "start_line": 208,
            "end_line": 210,
            "comment": [
                " Public: Makes a path relative to the repository's working directory."
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getWorkingDirectory",
            "line": 202,
            "func_location": "GitRepository.isProjectAtRoot",
            "func_start_line": 200,
            "func_end_line": 205,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Returns true if at the root, false if in a subfolder of the",
                " repository."
            ],
            "code": "  isProjectAtRoot () {\r\n    if (this.projectAtRoot == null) {\r\n      this.projectAtRoot = this.project && this.project.relativize(this.getWorkingDirectory()) === ''\r\n    }\r\n    return this.projectAtRoot\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getWorkingDirectory",
            "start_line": 194,
            "end_line": 196,
            "comment": [
                " Public: Returns the {String} working directory path of the repository."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 406,
            "func_location": "GitRepository.isStatusModified",
            "func_start_line": 406,
            "func_end_line": 406,
            "args": [
                {
                    "name": "status",
                    "type": [
                        "number"
                    ]
                }
            ],
            "comment": [
                " Public: Returns true if the given status indicates modification.",
                "",
                " * `status` A {Number} representing the status.",
                "",
                " Returns a {Boolean} that's true if the `status` indicates modification."
            ],
            "code": "  isStatusModified (status) { return this.getRepo().isStatusModified(status) }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 406,
            "func_location": "GitRepository.isStatusModified",
            "func_start_line": 406,
            "func_end_line": 406,
            "args": [
                {
                    "name": "status",
                    "type": [
                        "number"
                    ]
                }
            ],
            "comment": [
                " Public: Returns true if the given status indicates modification.",
                "",
                " * `status` A {Number} representing the status.",
                "",
                " Returns a {Boolean} that's true if the `status` indicates modification."
            ],
            "code": "  isStatusModified (status) { return this.getRepo().isStatusModified(status) }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "isStatusModified",
            "line": 406,
            "func_location": "GitRepository.isStatusModified",
            "func_start_line": 406,
            "func_end_line": 406,
            "args": [
                {
                    "name": "status",
                    "type": [
                        "number"
                    ]
                }
            ],
            "comment": [
                " Public: Returns true if the given status indicates modification.",
                "",
                " * `status` A {Number} representing the status.",
                "",
                " Returns a {Boolean} that's true if the `status` indicates modification."
            ],
            "code": "  isStatusModified (status) { return this.getRepo().isStatusModified(status) }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.isStatusModified",
            "start_line": 406,
            "end_line": 406,
            "comment": [
                " Public: Returns true if the given status indicates modification.",
                "",
                " * `status` A {Number} representing the status.",
                "",
                " Returns a {Boolean} that's true if the `status` indicates modification."
            ],
            "params": [
                {
                    "name": "status",
                    "type": [
                        "number"
                    ]
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "isStatusModified",
            "line": 406,
            "func_location": "GitRepository.isStatusModified",
            "func_start_line": 406,
            "func_end_line": 406,
            "args": [
                {
                    "name": "status",
                    "type": [
                        "number"
                    ]
                }
            ],
            "comment": [
                " Public: Returns true if the given status indicates modification.",
                "",
                " * `status` A {Number} representing the status.",
                "",
                " Returns a {Boolean} that's true if the `status` indicates modification."
            ],
            "code": "  isStatusModified (status) { return this.getRepo().isStatusModified(status) }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.isStatusModified",
            "start_line": 406,
            "end_line": 406,
            "comment": [
                " Public: Returns true if the given status indicates modification.",
                "",
                " * `status` A {Number} representing the status.",
                "",
                " Returns a {Boolean} that's true if the `status` indicates modification."
            ],
            "params": [
                {
                    "name": "status",
                    "type": [
                        "number"
                    ]
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 414,
            "func_location": "GitRepository.isStatusNew",
            "func_start_line": 413,
            "func_end_line": 415,
            "args": [
                {
                    "name": "status",
                    "type": [
                        "number"
                    ]
                }
            ],
            "comment": [
                " Public: Returns true if the given status indicates a new path.",
                "",
                " * `status` A {Number} representing the status.",
                "",
                " Returns a {Boolean} that's true if the `status` indicates a new path."
            ],
            "code": "  isStatusNew (status) {\r\n    return this.getRepo().isStatusNew(status)\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 414,
            "func_location": "GitRepository.isStatusNew",
            "func_start_line": 413,
            "func_end_line": 415,
            "args": [
                {
                    "name": "status",
                    "type": [
                        "number"
                    ]
                }
            ],
            "comment": [
                " Public: Returns true if the given status indicates a new path.",
                "",
                " * `status` A {Number} representing the status.",
                "",
                " Returns a {Boolean} that's true if the `status` indicates a new path."
            ],
            "code": "  isStatusNew (status) {\r\n    return this.getRepo().isStatusNew(status)\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "isStatusNew",
            "line": 414,
            "func_location": "GitRepository.isStatusNew",
            "func_start_line": 413,
            "func_end_line": 415,
            "args": [
                {
                    "name": "status",
                    "type": [
                        "number"
                    ]
                }
            ],
            "comment": [
                " Public: Returns true if the given status indicates a new path.",
                "",
                " * `status` A {Number} representing the status.",
                "",
                " Returns a {Boolean} that's true if the `status` indicates a new path."
            ],
            "code": "  isStatusNew (status) {\r\n    return this.getRepo().isStatusNew(status)\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.isStatusNew",
            "start_line": 413,
            "end_line": 415,
            "comment": [
                " Public: Returns true if the given status indicates a new path.",
                "",
                " * `status` A {Number} representing the status.",
                "",
                " Returns a {Boolean} that's true if the `status` indicates a new path."
            ],
            "params": [
                {
                    "name": "status",
                    "type": [
                        "number"
                    ]
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "isStatusNew",
            "line": 414,
            "func_location": "GitRepository.isStatusNew",
            "func_start_line": 413,
            "func_end_line": 415,
            "args": [
                {
                    "name": "status",
                    "type": [
                        "number"
                    ]
                }
            ],
            "comment": [
                " Public: Returns true if the given status indicates a new path.",
                "",
                " * `status` A {Number} representing the status.",
                "",
                " Returns a {Boolean} that's true if the `status` indicates a new path."
            ],
            "code": "  isStatusNew (status) {\r\n    return this.getRepo().isStatusNew(status)\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.isStatusNew",
            "start_line": 413,
            "end_line": 415,
            "comment": [
                " Public: Returns true if the given status indicates a new path.",
                "",
                " * `status` A {Number} representing the status.",
                "",
                " Returns a {Boolean} that's true if the `status` indicates a new path."
            ],
            "params": [
                {
                    "name": "status",
                    "type": [
                        "number"
                    ]
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 239,
            "func_location": "GitRepository.isSubmodule",
            "func_start_line": 236,
            "func_end_line": 246,
            "args": [
                {
                    "name": "filePath",
                    "type": []
                }
            ],
            "comment": [
                " Public: Is the given path a submodule in the repository?",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns a {Boolean}."
            ],
            "code": "  isSubmodule (filePath) {\r\n    if (!filePath) return false\r\n\r\n    const repo = this.getRepo(filePath)\r\n    if (repo.isSubmodule(repo.relativize(filePath))) {\r\n      return true\r\n    } else {\r\n      // Check if the filePath is a working directory in a repo that isn't the root.\r\n      return repo !== this.getRepo() && repo.relativize(path.join(filePath, 'dir')) === 'dir'\r\n    }\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 239,
            "func_location": "GitRepository.isSubmodule",
            "func_start_line": 236,
            "func_end_line": 246,
            "args": [
                {
                    "name": "filePath",
                    "type": []
                }
            ],
            "comment": [
                " Public: Is the given path a submodule in the repository?",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns a {Boolean}."
            ],
            "code": "  isSubmodule (filePath) {\r\n    if (!filePath) return false\r\n\r\n    const repo = this.getRepo(filePath)\r\n    if (repo.isSubmodule(repo.relativize(filePath))) {\r\n      return true\r\n    } else {\r\n      // Check if the filePath is a working directory in a repo that isn't the root.\r\n      return repo !== this.getRepo() && repo.relativize(path.join(filePath, 'dir')) === 'dir'\r\n    }\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "isSubmodule",
            "line": 240,
            "func_location": "GitRepository.isSubmodule",
            "func_start_line": 236,
            "func_end_line": 246,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Is the given path a submodule in the repository?",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns a {Boolean}."
            ],
            "code": "  isSubmodule (filePath) {\r\n    if (!filePath) return false\r\n\r\n    const repo = this.getRepo(filePath)\r\n    if (repo.isSubmodule(repo.relativize(filePath))) {\r\n      return true\r\n    } else {\r\n      // Check if the filePath is a working directory in a repo that isn't the root.\r\n      return repo !== this.getRepo() && repo.relativize(path.join(filePath, 'dir')) === 'dir'\r\n    }\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.isSubmodule",
            "start_line": 236,
            "end_line": 246,
            "comment": [
                " Public: Is the given path a submodule in the repository?",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns a {Boolean}."
            ],
            "params": [
                {
                    "name": "filePath",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "isSubmodule",
            "line": 240,
            "func_location": "GitRepository.isSubmodule",
            "func_start_line": 236,
            "func_end_line": 246,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Is the given path a submodule in the repository?",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns a {Boolean}."
            ],
            "code": "  isSubmodule (filePath) {\r\n    if (!filePath) return false\r\n\r\n    const repo = this.getRepo(filePath)\r\n    if (repo.isSubmodule(repo.relativize(filePath))) {\r\n      return true\r\n    } else {\r\n      // Check if the filePath is a working directory in a repo that isn't the root.\r\n      return repo !== this.getRepo() && repo.relativize(path.join(filePath, 'dir')) === 'dir'\r\n    }\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.isSubmodule",
            "start_line": 236,
            "end_line": 246,
            "comment": [
                " Public: Is the given path a submodule in the repository?",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns a {Boolean}."
            ],
            "params": [
                {
                    "name": "filePath",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "relativize",
            "line": 240,
            "func_location": "GitRepository.isSubmodule",
            "func_start_line": 236,
            "func_end_line": 246,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Is the given path a submodule in the repository?",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns a {Boolean}."
            ],
            "code": "  isSubmodule (filePath) {\r\n    if (!filePath) return false\r\n\r\n    const repo = this.getRepo(filePath)\r\n    if (repo.isSubmodule(repo.relativize(filePath))) {\r\n      return true\r\n    } else {\r\n      // Check if the filePath is a working directory in a repo that isn't the root.\r\n      return repo !== this.getRepo() && repo.relativize(path.join(filePath, 'dir')) === 'dir'\r\n    }\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.relativize",
            "start_line": 208,
            "end_line": 210,
            "comment": [
                " Public: Makes a path relative to the repository's working directory."
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "relativize",
            "line": 240,
            "func_location": "GitRepository.isSubmodule",
            "func_start_line": 236,
            "func_end_line": 246,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Is the given path a submodule in the repository?",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns a {Boolean}."
            ],
            "code": "  isSubmodule (filePath) {\r\n    if (!filePath) return false\r\n\r\n    const repo = this.getRepo(filePath)\r\n    if (repo.isSubmodule(repo.relativize(filePath))) {\r\n      return true\r\n    } else {\r\n      // Check if the filePath is a working directory in a repo that isn't the root.\r\n      return repo !== this.getRepo() && repo.relativize(path.join(filePath, 'dir')) === 'dir'\r\n    }\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.relativize",
            "start_line": 208,
            "end_line": 210,
            "comment": [
                " Public: Makes a path relative to the repository's working directory."
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 244,
            "func_location": "GitRepository.isSubmodule",
            "func_start_line": 236,
            "func_end_line": 246,
            "args": [],
            "comment": [
                " Public: Is the given path a submodule in the repository?",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns a {Boolean}."
            ],
            "code": "  isSubmodule (filePath) {\r\n    if (!filePath) return false\r\n\r\n    const repo = this.getRepo(filePath)\r\n    if (repo.isSubmodule(repo.relativize(filePath))) {\r\n      return true\r\n    } else {\r\n      // Check if the filePath is a working directory in a repo that isn't the root.\r\n      return repo !== this.getRepo() && repo.relativize(path.join(filePath, 'dir')) === 'dir'\r\n    }\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "relativize",
            "line": 244,
            "func_location": "GitRepository.isSubmodule",
            "func_start_line": 236,
            "func_end_line": 246,
            "args": [],
            "comment": [
                " Public: Is the given path a submodule in the repository?",
                "",
                " * `path` The {String} path to check.",
                "",
                " Returns a {Boolean}."
            ],
            "code": "  isSubmodule (filePath) {\r\n    if (!filePath) return false\r\n\r\n    const repo = this.getRepo(filePath)\r\n    if (repo.isSubmodule(repo.relativize(filePath))) {\r\n      return true\r\n    } else {\r\n      // Check if the filePath is a working directory in a repo that isn't the root.\r\n      return repo !== this.getRepo() && repo.relativize(path.join(filePath, 'dir')) === 'dir'\r\n    }\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.relativize",
            "start_line": 208,
            "end_line": 210,
            "comment": [
                " Public: Makes a path relative to the repository's working directory."
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/decoration.js",
            "name": "isType",
            "line": 143,
            "func_location": "Decoration.isType",
            "func_start_line": 142,
            "func_end_line": 144,
            "args": [
                {
                    "name": ".properties",
                    "type": []
                },
                {
                    "name": "type",
                    "type": [
                        "string",
                        "number",
                        "array"
                    ]
                }
            ],
            "comment": [
                " Public: Check if this decoration is of type `type`",
                "",
                " * `type` {String} type like `'line-number'`, `'line'`, etc. `type` can also",
                "   be an {Array} of {String}s, where it will return true if the decoration's",
                "   type matches any in the array.",
                "",
                " Returns {Boolean}"
            ],
            "code": "  isType (type) {\r\n    return Decoration.isType(this.properties, type)\r\n  }\r",
            "return_type": [
                "string",
                "array",
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/decoration.js",
            "name": "Decoration.isType",
            "start_line": 49,
            "end_line": 68,
            "comment": [
                " Private: Check if the `decorationProperties.type` matches `type`",
                "",
                " * `decorationProperties` {Object} eg. `{type: 'line-number', class: 'my-new-class'}`",
                " * `type` {String} type like `'line-number'`, `'line'`, etc. `type` can also",
                "   be an {Array} of {String}s, where it will return true if the decoration's",
                "   type matches any in the array.",
                "",
                " Returns {Boolean}",
                " Note: 'line-number' is a special subtype of the 'gutter' type. I.e., a",
                " 'line-number' is a 'gutter', but a 'gutter' is not a 'line-number'."
            ],
            "params": [
                {
                    "name": "decorationProperties",
                    "type": [
                        "number",
                        "object"
                    ]
                },
                {
                    "name": "type",
                    "type": [
                        "number",
                        "object",
                        "string",
                        "array"
                    ]
                }
            ],
            "return_type": [
                "string",
                "array",
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/decoration.js",
            "name": "isType",
            "line": 143,
            "func_location": "Decoration.isType",
            "func_start_line": 142,
            "func_end_line": 144,
            "args": [
                {
                    "name": ".properties",
                    "type": []
                },
                {
                    "name": "type",
                    "type": [
                        "string",
                        "number",
                        "array"
                    ]
                }
            ],
            "comment": [
                " Public: Check if this decoration is of type `type`",
                "",
                " * `type` {String} type like `'line-number'`, `'line'`, etc. `type` can also",
                "   be an {Array} of {String}s, where it will return true if the decoration's",
                "   type matches any in the array.",
                "",
                " Returns {Boolean}"
            ],
            "code": "  isType (type) {\r\n    return Decoration.isType(this.properties, type)\r\n  }\r",
            "return_type": [
                "string",
                "array",
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/decoration.js",
            "name": "Decoration.isType",
            "start_line": 49,
            "end_line": 68,
            "comment": [
                " Private: Check if the `decorationProperties.type` matches `type`",
                "",
                " * `decorationProperties` {Object} eg. `{type: 'line-number', class: 'my-new-class'}`",
                " * `type` {String} type like `'line-number'`, `'line'`, etc. `type` can also",
                "   be an {Array} of {String}s, where it will return true if the decoration's",
                "   type matches any in the array.",
                "",
                " Returns {Boolean}",
                " Note: 'line-number' is a special subtype of the 'gutter' type. I.e., a",
                " 'line-number' is a 'gutter', but a 'gutter' is not a 'line-number'."
            ],
            "params": [
                {
                    "name": "decorationProperties",
                    "type": [
                        "number",
                        "object"
                    ]
                },
                {
                    "name": "type",
                    "type": [
                        "number",
                        "object",
                        "string",
                        "array"
                    ]
                }
            ],
            "return_type": [
                "string",
                "array",
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/file-system-blob-store.js",
            "name": "parse",
            "line": 38,
            "func_location": "FileSystemBlobStore.load",
            "func_start_line": 28,
            "func_end_line": 42,
            "args": [
                null
            ],
            "code": "  load () {\r\n    if (!fs.existsSync(this.blobMapFilename)) {\r\n      return\r\n    }\r\n    if (!fs.existsSync(this.blobFilename)) {\r\n      return\r\n    }\r\n\r\n    try {\r\n      this.storedBlob = fs.readFileSync(this.blobFilename)\r\n      this.storedBlobMap = JSON.parse(fs.readFileSync(this.blobMapFilename))\r\n    } catch (e) {\r\n      this.reset()\r\n    }\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/color.js",
            "name": "Color.parse",
            "start_line": 14,
            "end_line": 36,
            "comment": [
                " Essential: Parse a {String} or {Object} into a {Color}.",
                "",
                " * `value` A {String} such as `'white'`, `#ff00ff`, or",
                "   `'rgba(255, 15, 60, .75)'` or an {Object} with `red`, `green`, `blue`,",
                "   and `alpha` properties.",
                "",
                " Returns a {Color} or `null` if it cannot be parsed."
            ],
            "params": [
                {
                    "name": "value",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "null"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/module-cache.js",
            "name": "parse",
            "line": 64,
            "func_location": "loadDependencies",
            "func_start_line": 52,
            "func_end_line": 84,
            "args": [
                null
            ],
            "code": "function loadDependencies (modulePath, rootPath, rootMetadata, moduleCache) {\r\n  const fs = require('fs-plus')\r\n\r\n  for (let childPath of fs.listSync(path.join(modulePath, 'node_modules'))) {\r\n    if (path.basename(childPath) === '.bin') continue\r\n    if (rootPath === modulePath && (rootMetadata.packageDependencies && rootMetadata.packageDependencies.hasOwnProperty(path.basename(childPath)))) {\r\n      continue\r\n    }\r\n\r\n    const childMetadataPath = path.join(childPath, 'package.json')\r\n    if (!fs.isFileSync(childMetadataPath)) continue\r\n\r\n    const childMetadata = JSON.parse(fs.readFileSync(childMetadataPath))\r\n    if (childMetadata && childMetadata.version) {\r\n      var mainPath\r\n      try {\r\n        mainPath = require.resolve(childPath)\r\n      } catch (error) {\r\n        mainPath = null\r\n      }\r\n\r\n      if (mainPath) {\r\n        moduleCache.dependencies.push({\r\n          name: childMetadata.name,\r\n          version: childMetadata.version,\r\n          path: path.relative(rootPath, mainPath)\r\n        })\r\n      }\r\n\r\n      loadDependencies(childPath, rootPath, rootMetadata, moduleCache)\r\n    }\r\n  }\r\n}\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/color.js",
            "name": "Color.parse",
            "start_line": 14,
            "end_line": 36,
            "comment": [
                " Essential: Parse a {String} or {Object} into a {Color}.",
                "",
                " * `value` A {String} such as `'white'`, `#ff00ff`, or",
                "   `'rgba(255, 15, 60, .75)'` or an {Object} with `red`, `green`, `blue`,",
                "   and `alpha` properties.",
                "",
                " Returns a {Color} or `null` if it cannot be parsed."
            ],
            "params": [
                {
                    "name": "value",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "null"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/module-cache.js",
            "name": "parse",
            "line": 92,
            "func_location": "loadFolderCompatibility",
            "func_start_line": 86,
            "func_end_line": 126,
            "args": [
                null
            ],
            "code": "function loadFolderCompatibility (modulePath, rootPath, rootMetadata, moduleCache) {\r\n  const fs = require('fs-plus')\r\n\r\n  const metadataPath = path.join(modulePath, 'package.json')\r\n  if (!fs.isFileSync(metadataPath)) return\r\n\r\n  const metadata = JSON.parse(fs.readFileSync(metadataPath))\r\n  const dependencies = metadata.dependencies || {}\r\n\r\n  for (let name in dependencies) {\r\n    if (!semver.validRange(dependencies[name])) {\r\n      delete dependencies[name]\r\n    }\r\n  }\r\n\r\n  const onDirectory = childPath => path.basename(childPath) !== 'node_modules'\r\n\r\n  const extensions = ['.js', '.coffee', '.json', '.node']\r\n  let paths = {}\r\n  function onFile (childPath) {\r\n    const needle = path.extname(childPath)\r\n    if (extensions.includes(needle)) {\r\n      const relativePath = path.relative(rootPath, path.dirname(childPath))\r\n      paths[relativePath] = true\r\n    }\r\n  }\r\n  fs.traverseTreeSync(modulePath, onFile, onDirectory)\r\n\r\n  paths = Object.keys(paths)\r\n  if (paths.length > 0 && Object.keys(dependencies).length > 0) {\r\n    moduleCache.folders.push({paths, dependencies})\r\n  }\r\n\r\n  for (let childPath of fs.listSync(path.join(modulePath, 'node_modules'))) {\r\n    if (path.basename(childPath) === '.bin') continue\r\n    if (rootPath === modulePath && (rootMetadata.packageDependencies && rootMetadata.packageDependencies.hasOwnProperty(path.basename(childPath)))) {\r\n      continue\r\n    }\r\n    loadFolderCompatibility(childPath, rootPath, rootMetadata, moduleCache)\r\n  }\r\n}\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/color.js",
            "name": "Color.parse",
            "start_line": 14,
            "end_line": 36,
            "comment": [
                " Essential: Parse a {String} or {Object} into a {Color}.",
                "",
                " * `value` A {String} such as `'white'`, `#ff00ff`, or",
                "   `'rgba(255, 15, 60, .75)'` or an {Object} with `red`, `green`, `blue`,",
                "   and `alpha` properties.",
                "",
                " Returns a {Color} or `null` if it cannot be parsed."
            ],
            "params": [
                {
                    "name": "value",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "null"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/theme-manager.js",
            "name": "addError",
            "line": 295,
            "func_location": "ThemeManager.loadLessStylesheet",
            "func_start_line": 249,
            "func_end_line": 298,
            "args": [
                "message",
                null
            ],
            "code": "  loadLessStylesheet (lessStylesheetPath, importFallbackVariables = false) {\r\n    if (this.lessCache == null) {\r\n      this.lessCache = new LessCompileCache({\r\n        resourcePath: this.resourcePath,\r\n        lessSourcesByRelativeFilePath: this.lessSourcesByRelativeFilePath,\r\n        importedFilePathsByRelativeImportPath: this.importedFilePathsByRelativeImportPath,\r\n        importPaths: this.getImportPaths()\r\n      })\r\n    }\r\n\r\n    try {\r\n      if (importFallbackVariables) {\r\n        const baseVarImports = `\\\r\n@import \"variables/ui-variables\";\r\n@import \"variables/syntax-variables\";\\\r\n`\r\n        const relativeFilePath = path.relative(this.resourcePath, lessStylesheetPath)\r\n        const lessSource = this.lessSourcesByRelativeFilePath[relativeFilePath]\r\n\r\n        let content, digest\r\n        if (lessSource != null) {\r\n          ({ content } = lessSource);\r\n          ({ digest } = lessSource)\r\n        } else {\r\n          content = baseVarImports + '\\n' + fs.readFileSync(lessStylesheetPath, 'utf8')\r\n          digest = null\r\n        }\r\n\r\n        return this.lessCache.cssForFile(lessStylesheetPath, content, digest)\r\n      } else {\r\n        return this.lessCache.read(lessStylesheetPath)\r\n      }\r\n    } catch (error) {\r\n      let detail, message\r\n      error.less = true\r\n      if (error.line != null) {\r\n        // Adjust line numbers for import fallbacks\r\n        if (importFallbackVariables) { error.line -= 2 }\r\n\r\n        message = `Error compiling Less stylesheet: \\`${lessStylesheetPath}\\``\r\n        detail = `Line number: ${error.line}\\n${error.message}`\r\n      } else {\r\n        message = `Error loading Less stylesheet: \\`${lessStylesheetPath}\\``\r\n        detail = error.message\r\n      }\r\n\r\n      this.notificationManager.addError(message, {detail, dismissable: true})\r\n      throw error\r\n    }\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/notification-manager.js",
            "name": "NotificationManager.addError",
            "start_line": 153,
            "end_line": 155,
            "comment": [
                " Public: Add an error notification.",
                "",
                " * `message` A {String} message",
                " * `options` (optional) An options {Object} with the following keys:",
                "    * `buttons` (optional) An {Array} of {Object} where each {Object} has",
                "      the following options:",
                "      * `className` (optional) {String} a class name to add to the button's",
                "        default class name (`btn btn-error`).",
                "      * `onDidClick` (optional) {Function} callback to call when the button",
                "        has been clicked. The context will be set to the",
                "        {NotificationElement} instance.",
                "      * `text` {String} inner text for the button",
                "    * `description` (optional) A Markdown {String} containing a longer",
                "      description about the notification. By default, this **will not**",
                "      preserve newlines and whitespace when it is rendered.",
                "    * `detail` (optional) A plain-text {String} containing additional",
                "      details about the notification. By default, this **will** preserve",
                "      newlines and whitespace when it is rendered.",
                "    * `dismissable` (optional) A {Boolean} indicating whether this",
                "      notification can be dismissed by the user. Defaults to `false`.",
                "    * `icon` (optional) A {String} name of an icon from Octicons to display",
                "      in the notification header. Defaults to `'flame'`.",
                "    * `stack` (optional) A preformatted {String} with stack trace",
                "      information describing the location of the error.",
                "",
                " Returns the {Notification} that was added."
            ],
            "params": [
                {
                    "name": "message",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/theme-manager.js",
            "name": "addError",
            "line": 207,
            "func_location": "ThemeManager.loadUserStylesheet",
            "func_start_line": 185,
            "func_end_line": 218,
            "args": [
                "message",
                null
            ],
            "code": "  loadUserStylesheet () {\r\n    this.unwatchUserStylesheet()\r\n\r\n    const userStylesheetPath = this.styleManager.getUserStyleSheetPath()\r\n    if (!fs.isFileSync(userStylesheetPath)) { return }\r\n\r\n    try {\r\n      this.userStylesheetFile = new File(userStylesheetPath)\r\n      this.userStylesheetSubscriptions = new CompositeDisposable()\r\n      const reloadStylesheet = () => this.loadUserStylesheet()\r\n      this.userStylesheetSubscriptions.add(this.userStylesheetFile.onDidChange(reloadStylesheet))\r\n      this.userStylesheetSubscriptions.add(this.userStylesheetFile.onDidRename(reloadStylesheet))\r\n      this.userStylesheetSubscriptions.add(this.userStylesheetFile.onDidDelete(reloadStylesheet))\r\n    } catch (error) {\r\n      const message = `\\\r\nUnable to watch path: \\`${path.basename(userStylesheetPath)}\\`. Make sure\r\nyou have permissions to \\`${userStylesheetPath}\\`.\r\n\r\nOn linux there are currently problems with watch sizes. See\r\n[this document][watches] for more info.\r\n[watches]:https://github.com/atom/atom/blob/master/docs/build-instructions/linux.md#typeerror-unable-to-watch-path\\\r\n`\r\n      this.notificationManager.addError(message, {dismissable: true})\r\n    }\r\n\r\n    let userStylesheetContents\r\n    try {\r\n      userStylesheetContents = this.loadStylesheet(userStylesheetPath, true)\r\n    } catch (error) {\r\n      return\r\n    }\r\n\r\n    this.userStyleSheetDisposable = this.styleManager.addStyleSheet(userStylesheetContents, {sourcePath: userStylesheetPath, priority: 2})\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/notification-manager.js",
            "name": "NotificationManager.addError",
            "start_line": 153,
            "end_line": 155,
            "comment": [
                " Public: Add an error notification.",
                "",
                " * `message` A {String} message",
                " * `options` (optional) An options {Object} with the following keys:",
                "    * `buttons` (optional) An {Array} of {Object} where each {Object} has",
                "      the following options:",
                "      * `className` (optional) {String} a class name to add to the button's",
                "        default class name (`btn btn-error`).",
                "      * `onDidClick` (optional) {Function} callback to call when the button",
                "        has been clicked. The context will be set to the",
                "        {NotificationElement} instance.",
                "      * `text` {String} inner text for the button",
                "    * `description` (optional) A Markdown {String} containing a longer",
                "      description about the notification. By default, this **will not**",
                "      preserve newlines and whitespace when it is rendered.",
                "    * `detail` (optional) A plain-text {String} containing additional",
                "      details about the notification. By default, this **will** preserve",
                "      newlines and whitespace when it is rendered.",
                "    * `dismissable` (optional) A {Boolean} indicating whether this",
                "      notification can be dismissed by the user. Defaults to `false`.",
                "    * `icon` (optional) A {String} name of an icon from Octicons to display",
                "      in the notification header. Defaults to `'flame'`.",
                "    * `stack` (optional) A preformatted {String} with stack trace",
                "      information describing the location of the error.",
                "",
                " Returns the {Notification} that was added."
            ],
            "params": [
                {
                    "name": "message",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/initialize-benchmark-window.js",
            "name": "write",
            "line": 80,
            "func_location": "console.log",
            "func_start_line": 78,
            "func_end_line": 81,
            "args": [
                null
            ],
            "code": "      console.log = function (...args) {\r\n        const formatted = util.format(...args)\r\n        process.stdout.write(formatted + '\\n')\r\n      }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/clipboard.js",
            "name": "Clipboard.write",
            "start_line": 42,
            "end_line": 46,
            "comment": [
                " Public: Write the given text to the clipboard.",
                "",
                " The metadata associated with the text is available by calling",
                " {::readWithMetadata}.",
                "",
                " * `text` The {String} to store.",
                " * `metadata` (optional) The additional info to associate with the text."
            ],
            "params": [
                {
                    "name": "text",
                    "type": [
                        "string",
                        "optional"
                    ]
                },
                {
                    "name": "metadata",
                    "type": [
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "has",
            "line": 146,
            "func_location": "TextEditorRegistry.maintainConfig",
            "func_start_line": 145,
            "func_end_line": 177,
            "args": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "comment": [
                " Keep a {TextEditor}'s configuration in sync with Atom's settings.",
                "",
                " * `editor` The editor whose configuration will be maintained.",
                "",
                " Returns a {Disposable} that can be used to stop updating the editor's",
                " configuration."
            ],
            "code": "  maintainConfig (editor) {\r\n    if (this.editorsWithMaintainedConfig.has(editor)) {\r\n      return new Disposable(noop)\r\n    }\r\n    this.editorsWithMaintainedConfig.add(editor)\r\n\r\n    this.updateAndMonitorEditorSettings(editor)\r\n    const languageChangeSubscription = editor.buffer.onDidChangeLanguageMode((newLanguageMode, oldLanguageMode) => {\r\n      this.updateAndMonitorEditorSettings(editor, oldLanguageMode)\r\n    })\r\n    this.subscriptions.add(languageChangeSubscription)\r\n\r\n    const updateTabTypes = () => {\r\n      const configOptions = {scope: editor.getRootScopeDescriptor()}\r\n      editor.setSoftTabs(shouldEditorUseSoftTabs(\r\n        editor,\r\n        this.config.get('editor.tabType', configOptions),\r\n        this.config.get('editor.softTabs', configOptions)\r\n      ))\r\n    }\r\n\r\n    updateTabTypes()\r\n    const tokenizeSubscription = editor.onDidTokenize(updateTabTypes)\r\n    this.subscriptions.add(tokenizeSubscription)\r\n\r\n    return new Disposable(() => {\r\n      this.editorsWithMaintainedConfig.delete(editor)\r\n      tokenizeSubscription.dispose()\r\n      languageChangeSubscription.dispose()\r\n      this.subscriptions.remove(languageChangeSubscription)\r\n      this.subscriptions.remove(tokenizeSubscription)\r\n    })\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/file-system-blob-store.js",
            "name": "FileSystemBlobStore.has",
            "start_line": 68,
            "end_line": 70,
            "comment": [],
            "params": [
                "key"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "getBuffer",
            "line": 188,
            "func_location": "TextEditorRegistry.maintainGrammar",
            "func_start_line": 187,
            "func_end_line": 189,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Deprecated: set a {TextEditor}'s grammar based on its path and content,",
                " and continue to update its grammar as grammars are added or updated, or",
                " the editor's file path changes.",
                "",
                " * `editor` The editor whose grammar will be maintained.",
                "",
                " Returns a {Disposable} that can be used to stop updating the editor's",
                " grammar."
            ],
            "code": "  maintainGrammar (editor) {\r\n    atom.grammars.maintainLanguageMode(editor.getBuffer())\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.getBuffer",
            "start_line": 963,
            "end_line": 963,
            "comment": [
                " Essential: Retrieves the current {TextBuffer}."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "getSchema",
            "line": 1173,
            "func_location": "Config.makeValueConformToSchema",
            "func_start_line": 1164,
            "func_end_line": 1178,
            "args": [
                "keyPath"
            ],
            "code": "  makeValueConformToSchema (keyPath, value, options) {\r\n    if (options != null ? options.suppressException : undefined) {\r\n      try {\r\n        return this.makeValueConformToSchema(keyPath, value)\r\n      } catch (e) {\r\n        return undefined\r\n      }\r\n    } else {\r\n      let schema\r\n      if ((schema = this.getSchema(keyPath)) == null) {\r\n        if (schema === false) { throw new Error(`Illegal key path ${keyPath}`) }\r\n      }\r\n      return this.constructor.executeSchemaEnforcers(keyPath, value, schema)\r\n    }\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.getSchema",
            "start_line": 783,
            "end_line": 805,
            "comment": [
                " Extended: Retrieve the schema for a specific key path. The schema will tell",
                " you what type the keyPath expects, and other metadata about the config",
                " option.",
                "",
                " * `keyPath` The {String} name of the key.",
                "",
                " Returns an {Object} eg. `{type: 'integer', default: 23, minimum: 1}`.",
                " Returns `null` when the keyPath has no schema specified, but is accessible",
                " from the root schema."
            ],
            "params": [
                {
                    "name": "keyPath",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "object",
                "null"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selectors.js",
            "name": "parse",
            "line": 24,
            "func_location": "matcherForSelector",
            "func_start_line": 23,
            "func_end_line": 29,
            "args": [
                {
                    "name": "selector",
                    "type": [
                        "string"
                    ]
                }
            ],
            "comment": [
                " Essential: Return a matcher function for a selector.",
                "",
                " * selector, a {String} selector",
                " Returns {(scope: String) -> Boolean}, a matcher function returning",
                " true iff the scope matches the selector."
            ],
            "code": "function matcherForSelector (selector) {\r\n  const parts = parse(selector)\r\n  if (typeof parts === 'function') return parts\r\n  return selector\r\n    ? scope => isSubset(parts, parse(scope))\r\n    : always\r\n}\r",
            "return_type": [
                "string",
                "array",
                "function",
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selectors.js",
            "name": "parse",
            "start_line": 10,
            "end_line": 14,
            "comment": [
                " Private: Parse a selector into parts.",
                "          If already parsed, returns the selector unmodified.",
                "",
                " * `selector` a {String|Array<String>} specifying what to match",
                " Returns selector parts, an {Array<String>}."
            ],
            "params": [
                {
                    "name": "selector",
                    "type": [
                        "string",
                        "array"
                    ]
                }
            ],
            "return_type": [
                "string",
                "array",
                "function",
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selectors.js",
            "name": "parse",
            "line": 24,
            "func_location": "matcherForSelector",
            "func_start_line": 23,
            "func_end_line": 29,
            "args": [
                {
                    "name": "selector",
                    "type": [
                        "string"
                    ]
                }
            ],
            "comment": [
                " Essential: Return a matcher function for a selector.",
                "",
                " * selector, a {String} selector",
                " Returns {(scope: String) -> Boolean}, a matcher function returning",
                " true iff the scope matches the selector."
            ],
            "code": "function matcherForSelector (selector) {\r\n  const parts = parse(selector)\r\n  if (typeof parts === 'function') return parts\r\n  return selector\r\n    ? scope => isSubset(parts, parse(scope))\r\n    : always\r\n}\r",
            "return_type": [
                "string",
                "array",
                "function",
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selectors.js",
            "name": "parse",
            "start_line": 10,
            "end_line": 14,
            "comment": [
                " Private: Parse a selector into parts.",
                "          If already parsed, returns the selector unmodified.",
                "",
                " * `selector` a {String|Array<String>} specifying what to match",
                " Returns selector parts, an {Array<String>}."
            ],
            "params": [
                {
                    "name": "selector",
                    "type": [
                        "string",
                        "array"
                    ]
                }
            ],
            "return_type": [
                "string",
                "array",
                "function",
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/window.js",
            "name": "log",
            "line": 12,
            "func_location": "window.measure",
            "func_start_line": 8,
            "func_end_line": 14,
            "args": [
                {
                    "name": "description",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "result",
                    "type": []
                }
            ],
            "comment": [
                " Public: Measure how long a function takes to run.",
                "",
                " description - A {String} description that will be logged to the console when",
                "               the function completes.",
                " fn - A {Function} to measure the duration of.",
                "",
                " Returns the value returned by the given function."
            ],
            "code": "window.measure = function (description, fn) {\r\n  let start = Date.now()\r\n  let value = fn()\r\n  let result = Date.now() - start\r\n  console.log(description, result)\r\n  return value\r\n}\r",
            "return_type": [
                "string",
                "array",
                "function",
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/initialize-benchmark-window.js",
            "name": "console.log",
            "start_line": 78,
            "end_line": 81,
            "comment": [],
            "params": [
                "args"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "remove",
            "line": 358,
            "func_location": "TextEditorComponent.measureBlockDecorations",
            "func_start_line": 291,
            "func_end_line": 362,
            "args": [],
            "code": "  measureBlockDecorations () {\r\n    if (this.remeasureAllBlockDecorations) {\r\n      this.remeasureAllBlockDecorations = false\r\n\r\n      const decorations = this.props.model.getDecorations()\r\n      for (var i = 0; i < decorations.length; i++) {\r\n        const decoration = decorations[i]\r\n        const marker = decoration.getMarker()\r\n        if (marker.isValid() && decoration.getProperties().type === 'block') {\r\n          this.blockDecorationsToMeasure.add(decoration)\r\n        }\r\n      }\r\n\r\n      // Update the width of the line tiles to ensure block decorations are\r\n      // measured with the most recent width.\r\n      if (this.blockDecorationsToMeasure.size > 0) {\r\n        this.updateSyncBeforeMeasuringContent()\r\n      }\r\n    }\r\n\r\n    if (this.blockDecorationsToMeasure.size > 0) {\r\n      const {blockDecorationMeasurementArea} = this.refs\r\n      const sentinelElements = new Set()\r\n\r\n      blockDecorationMeasurementArea.appendChild(document.createElement('div'))\r\n      this.blockDecorationsToMeasure.forEach((decoration) => {\r\n        const {item} = decoration.getProperties()\r\n        const decorationElement = TextEditor.viewForItem(item)\r\n        if (document.contains(decorationElement)) {\r\n          const parentElement = decorationElement.parentElement\r\n\r\n          if (!decorationElement.previousSibling) {\r\n            const sentinelElement = this.blockDecorationSentinel.cloneNode()\r\n            parentElement.insertBefore(sentinelElement, decorationElement)\r\n            sentinelElements.add(sentinelElement)\r\n          }\r\n\r\n          if (!decorationElement.nextSibling) {\r\n            const sentinelElement = this.blockDecorationSentinel.cloneNode()\r\n            parentElement.appendChild(sentinelElement)\r\n            sentinelElements.add(sentinelElement)\r\n          }\r\n\r\n          this.didMeasureVisibleBlockDecoration = true\r\n        } else {\r\n          blockDecorationMeasurementArea.appendChild(this.blockDecorationSentinel.cloneNode())\r\n          blockDecorationMeasurementArea.appendChild(decorationElement)\r\n          blockDecorationMeasurementArea.appendChild(this.blockDecorationSentinel.cloneNode())\r\n        }\r\n      })\r\n\r\n      if (this.resizeBlockDecorationMeasurementsArea) {\r\n        this.resizeBlockDecorationMeasurementsArea = false\r\n        this.refs.blockDecorationMeasurementArea.style.width = this.getScrollWidth() + 'px'\r\n      }\r\n\r\n      this.blockDecorationsToMeasure.forEach((decoration) => {\r\n        const {item} = decoration.getProperties()\r\n        const decorationElement = TextEditor.viewForItem(item)\r\n        const {previousSibling, nextSibling} = decorationElement\r\n        const height = nextSibling.getBoundingClientRect().top - previousSibling.getBoundingClientRect().bottom\r\n        this.heightsByBlockDecoration.set(decoration, height)\r\n        this.lineTopIndex.resizeBlock(decoration, height)\r\n      })\r\n\r\n      sentinelElements.forEach((sentinelElement) => sentinelElement.remove())\r\n      while (blockDecorationMeasurementArea.firstChild) {\r\n        blockDecorationMeasurementArea.firstChild.remove()\r\n      }\r\n      this.blockDecorationsToMeasure.clear()\r\n    }\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/menu-helpers.js",
            "name": "addItemToMenu",
            "line": 20,
            "func_location": "merge",
            "func_start_line": 14,
            "func_end_line": 32,
            "args": [
                "item",
                "menu"
            ],
            "code": "function merge (menu, item, itemSpecificity = Infinity) {\r\n  item = cloneMenuItem(item)\r\n  ItemSpecificities.set(item, itemSpecificity)\r\n  const matchingItemIndex = findMatchingItemIndex(menu, item)\r\n\r\n  if (matchingItemIndex === -1) {\r\n    addItemToMenu(item, menu)\r\n    return\r\n  }\r\n\r\n  const matchingItem = menu[matchingItemIndex]\r\n  if (item.submenu != null) {\r\n    for (let submenuItem of item.submenu) {\r\n      merge(matchingItem.submenu, submenuItem, itemSpecificity)\r\n    }\r\n  } else if (itemSpecificity && itemSpecificity >= ItemSpecificities.get(matchingItem)) {\r\n    menu[matchingItemIndex] = item\r\n  }\r\n}\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/menu-helpers.js",
            "name": "addItemToMenu",
            "start_line": 6,
            "end_line": 12,
            "comment": [
                " Add an item to a menu, ensuring separators are not duplicated."
            ],
            "params": [
                {
                    "name": "item",
                    "type": []
                },
                {
                    "name": "menu",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setScreenPosition",
            "line": 271,
            "func_location": "Cursor.moveDown",
            "func_start_line": 261,
            "func_end_line": 273,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor down one screen row.",
                "",
                " * `rowCount` (optional) {Number} number of rows to move (default: 1)",
                " * `options` (optional) {Object} with the following keys:",
                "   * `moveToEndOfSelection` if true, move to the left of the selection if a",
                "     selection exists."
            ],
            "code": "  moveDown (rowCount = 1, {moveToEndOfSelection} = {}) {\r\n    let row, column\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      ({row, column} = range.end)\r\n    } else {\r\n      ({row, column} = this.getScreenPosition())\r\n    }\r\n\r\n    if (this.goalColumn != null) column = this.goalColumn\r\n    this.setScreenPosition({row: row + rowCount, column}, {skipSoftWrapIndentation: true})\r\n    this.goalColumn = column\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setScreenPosition",
            "start_line": 66,
            "end_line": 70,
            "comment": [
                "\r\n  Section: Managing Cursor Position\r\n  ",
                " Public: Moves a cursor to a given screen position.",
                "",
                " * `screenPosition` {Array} of two numbers: the screen row, and the screen column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever",
                "     the cursor moves to."
            ],
            "params": [
                {
                    "name": "screenPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setScreenPosition",
            "line": 271,
            "func_location": "Cursor.moveDown",
            "func_start_line": 261,
            "func_end_line": 273,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor down one screen row.",
                "",
                " * `rowCount` (optional) {Number} number of rows to move (default: 1)",
                " * `options` (optional) {Object} with the following keys:",
                "   * `moveToEndOfSelection` if true, move to the left of the selection if a",
                "     selection exists."
            ],
            "code": "  moveDown (rowCount = 1, {moveToEndOfSelection} = {}) {\r\n    let row, column\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      ({row, column} = range.end)\r\n    } else {\r\n      ({row, column} = this.getScreenPosition())\r\n    }\r\n\r\n    if (this.goalColumn != null) column = this.goalColumn\r\n    this.setScreenPosition({row: row + rowCount, column}, {skipSoftWrapIndentation: true})\r\n    this.goalColumn = column\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setScreenPosition",
            "start_line": 66,
            "end_line": 70,
            "comment": [
                "\r\n  Section: Managing Cursor Position\r\n  ",
                " Public: Moves a cursor to a given screen position.",
                "",
                " * `screenPosition` {Array} of two numbers: the screen row, and the screen column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever",
                "     the cursor moves to."
            ],
            "params": [
                {
                    "name": "screenPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setScreenPosition",
            "line": 284,
            "func_location": "Cursor.moveLeft",
            "func_start_line": 281,
            "func_end_line": 297,
            "args": [
                {
                    "name": "range.start",
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor left one screen column.",
                "",
                " * `columnCount` (optional) {Number} number of columns to move (default: 1)",
                " * `options` (optional) {Object} with the following keys:",
                "   * `moveToEndOfSelection` if true, move to the left of the selection if a",
                "     selection exists."
            ],
            "code": "  moveLeft (columnCount = 1, {moveToEndOfSelection} = {}) {\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      this.setScreenPosition(range.start)\r\n    } else {\r\n      let {row, column} = this.getScreenPosition()\r\n\r\n      while (columnCount > column && row > 0) {\r\n        columnCount -= column\r\n        column = this.editor.lineLengthForScreenRow(--row)\r\n        columnCount-- // subtract 1 for the row move\r\n      }\r\n\r\n      column = column - columnCount\r\n      this.setScreenPosition({row, column}, {clipDirection: 'backward'})\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setScreenPosition",
            "start_line": 66,
            "end_line": 70,
            "comment": [
                "\r\n  Section: Managing Cursor Position\r\n  ",
                " Public: Moves a cursor to a given screen position.",
                "",
                " * `screenPosition` {Array} of two numbers: the screen row, and the screen column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever",
                "     the cursor moves to."
            ],
            "params": [
                {
                    "name": "screenPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setScreenPosition",
            "line": 284,
            "func_location": "Cursor.moveLeft",
            "func_start_line": 281,
            "func_end_line": 297,
            "args": [
                {
                    "name": "range.start",
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor left one screen column.",
                "",
                " * `columnCount` (optional) {Number} number of columns to move (default: 1)",
                " * `options` (optional) {Object} with the following keys:",
                "   * `moveToEndOfSelection` if true, move to the left of the selection if a",
                "     selection exists."
            ],
            "code": "  moveLeft (columnCount = 1, {moveToEndOfSelection} = {}) {\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      this.setScreenPosition(range.start)\r\n    } else {\r\n      let {row, column} = this.getScreenPosition()\r\n\r\n      while (columnCount > column && row > 0) {\r\n        columnCount -= column\r\n        column = this.editor.lineLengthForScreenRow(--row)\r\n        columnCount-- // subtract 1 for the row move\r\n      }\r\n\r\n      column = column - columnCount\r\n      this.setScreenPosition({row, column}, {clipDirection: 'backward'})\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setScreenPosition",
            "start_line": 66,
            "end_line": 70,
            "comment": [
                "\r\n  Section: Managing Cursor Position\r\n  ",
                " Public: Moves a cursor to a given screen position.",
                "",
                " * `screenPosition` {Array} of two numbers: the screen row, and the screen column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever",
                "     the cursor moves to."
            ],
            "params": [
                {
                    "name": "screenPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setScreenPosition",
            "line": 295,
            "func_location": "Cursor.moveLeft",
            "func_start_line": 281,
            "func_end_line": 297,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor left one screen column.",
                "",
                " * `columnCount` (optional) {Number} number of columns to move (default: 1)",
                " * `options` (optional) {Object} with the following keys:",
                "   * `moveToEndOfSelection` if true, move to the left of the selection if a",
                "     selection exists."
            ],
            "code": "  moveLeft (columnCount = 1, {moveToEndOfSelection} = {}) {\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      this.setScreenPosition(range.start)\r\n    } else {\r\n      let {row, column} = this.getScreenPosition()\r\n\r\n      while (columnCount > column && row > 0) {\r\n        columnCount -= column\r\n        column = this.editor.lineLengthForScreenRow(--row)\r\n        columnCount-- // subtract 1 for the row move\r\n      }\r\n\r\n      column = column - columnCount\r\n      this.setScreenPosition({row, column}, {clipDirection: 'backward'})\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setScreenPosition",
            "start_line": 66,
            "end_line": 70,
            "comment": [
                "\r\n  Section: Managing Cursor Position\r\n  ",
                " Public: Moves a cursor to a given screen position.",
                "",
                " * `screenPosition` {Array} of two numbers: the screen row, and the screen column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever",
                "     the cursor moves to."
            ],
            "params": [
                {
                    "name": "screenPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setScreenPosition",
            "line": 295,
            "func_location": "Cursor.moveLeft",
            "func_start_line": 281,
            "func_end_line": 297,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor left one screen column.",
                "",
                " * `columnCount` (optional) {Number} number of columns to move (default: 1)",
                " * `options` (optional) {Object} with the following keys:",
                "   * `moveToEndOfSelection` if true, move to the left of the selection if a",
                "     selection exists."
            ],
            "code": "  moveLeft (columnCount = 1, {moveToEndOfSelection} = {}) {\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      this.setScreenPosition(range.start)\r\n    } else {\r\n      let {row, column} = this.getScreenPosition()\r\n\r\n      while (columnCount > column && row > 0) {\r\n        columnCount -= column\r\n        column = this.editor.lineLengthForScreenRow(--row)\r\n        columnCount-- // subtract 1 for the row move\r\n      }\r\n\r\n      column = column - columnCount\r\n      this.setScreenPosition({row, column}, {clipDirection: 'backward'})\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setScreenPosition",
            "start_line": 66,
            "end_line": 70,
            "comment": [
                "\r\n  Section: Managing Cursor Position\r\n  ",
                " Public: Moves a cursor to a given screen position.",
                "",
                " * `screenPosition` {Array} of two numbers: the screen row, and the screen column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever",
                "     the cursor moves to."
            ],
            "params": [
                {
                    "name": "screenPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setScreenPosition",
            "line": 308,
            "func_location": "Cursor.moveRight",
            "func_start_line": 305,
            "func_end_line": 327,
            "args": [
                {
                    "name": "range.end",
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor right one screen column.",
                "",
                " * `columnCount` (optional) {Number} number of columns to move (default: 1)",
                " * `options` (optional) {Object} with the following keys:",
                "   * `moveToEndOfSelection` if true, move to the right of the selection if a",
                "     selection exists."
            ],
            "code": "  moveRight (columnCount = 1, {moveToEndOfSelection} = {}) {\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      this.setScreenPosition(range.end)\r\n    } else {\r\n      let {row, column} = this.getScreenPosition()\r\n      const maxLines = this.editor.getScreenLineCount()\r\n      let rowLength = this.editor.lineLengthForScreenRow(row)\r\n      let columnsRemainingInLine = rowLength - column\r\n\r\n      while (columnCount > columnsRemainingInLine && row < maxLines - 1) {\r\n        columnCount -= columnsRemainingInLine\r\n        columnCount-- // subtract 1 for the row move\r\n\r\n        column = 0\r\n        rowLength = this.editor.lineLengthForScreenRow(++row)\r\n        columnsRemainingInLine = rowLength\r\n      }\r\n\r\n      column = column + columnCount\r\n      this.setScreenPosition({row, column}, {clipDirection: 'forward'})\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setScreenPosition",
            "start_line": 66,
            "end_line": 70,
            "comment": [
                "\r\n  Section: Managing Cursor Position\r\n  ",
                " Public: Moves a cursor to a given screen position.",
                "",
                " * `screenPosition` {Array} of two numbers: the screen row, and the screen column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever",
                "     the cursor moves to."
            ],
            "params": [
                {
                    "name": "screenPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setScreenPosition",
            "line": 308,
            "func_location": "Cursor.moveRight",
            "func_start_line": 305,
            "func_end_line": 327,
            "args": [
                {
                    "name": "range.end",
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor right one screen column.",
                "",
                " * `columnCount` (optional) {Number} number of columns to move (default: 1)",
                " * `options` (optional) {Object} with the following keys:",
                "   * `moveToEndOfSelection` if true, move to the right of the selection if a",
                "     selection exists."
            ],
            "code": "  moveRight (columnCount = 1, {moveToEndOfSelection} = {}) {\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      this.setScreenPosition(range.end)\r\n    } else {\r\n      let {row, column} = this.getScreenPosition()\r\n      const maxLines = this.editor.getScreenLineCount()\r\n      let rowLength = this.editor.lineLengthForScreenRow(row)\r\n      let columnsRemainingInLine = rowLength - column\r\n\r\n      while (columnCount > columnsRemainingInLine && row < maxLines - 1) {\r\n        columnCount -= columnsRemainingInLine\r\n        columnCount-- // subtract 1 for the row move\r\n\r\n        column = 0\r\n        rowLength = this.editor.lineLengthForScreenRow(++row)\r\n        columnsRemainingInLine = rowLength\r\n      }\r\n\r\n      column = column + columnCount\r\n      this.setScreenPosition({row, column}, {clipDirection: 'forward'})\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setScreenPosition",
            "start_line": 66,
            "end_line": 70,
            "comment": [
                "\r\n  Section: Managing Cursor Position\r\n  ",
                " Public: Moves a cursor to a given screen position.",
                "",
                " * `screenPosition` {Array} of two numbers: the screen row, and the screen column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever",
                "     the cursor moves to."
            ],
            "params": [
                {
                    "name": "screenPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setScreenPosition",
            "line": 325,
            "func_location": "Cursor.moveRight",
            "func_start_line": 305,
            "func_end_line": 327,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor right one screen column.",
                "",
                " * `columnCount` (optional) {Number} number of columns to move (default: 1)",
                " * `options` (optional) {Object} with the following keys:",
                "   * `moveToEndOfSelection` if true, move to the right of the selection if a",
                "     selection exists."
            ],
            "code": "  moveRight (columnCount = 1, {moveToEndOfSelection} = {}) {\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      this.setScreenPosition(range.end)\r\n    } else {\r\n      let {row, column} = this.getScreenPosition()\r\n      const maxLines = this.editor.getScreenLineCount()\r\n      let rowLength = this.editor.lineLengthForScreenRow(row)\r\n      let columnsRemainingInLine = rowLength - column\r\n\r\n      while (columnCount > columnsRemainingInLine && row < maxLines - 1) {\r\n        columnCount -= columnsRemainingInLine\r\n        columnCount-- // subtract 1 for the row move\r\n\r\n        column = 0\r\n        rowLength = this.editor.lineLengthForScreenRow(++row)\r\n        columnsRemainingInLine = rowLength\r\n      }\r\n\r\n      column = column + columnCount\r\n      this.setScreenPosition({row, column}, {clipDirection: 'forward'})\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setScreenPosition",
            "start_line": 66,
            "end_line": 70,
            "comment": [
                "\r\n  Section: Managing Cursor Position\r\n  ",
                " Public: Moves a cursor to a given screen position.",
                "",
                " * `screenPosition` {Array} of two numbers: the screen row, and the screen column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever",
                "     the cursor moves to."
            ],
            "params": [
                {
                    "name": "screenPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setScreenPosition",
            "line": 325,
            "func_location": "Cursor.moveRight",
            "func_start_line": 305,
            "func_end_line": 327,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor right one screen column.",
                "",
                " * `columnCount` (optional) {Number} number of columns to move (default: 1)",
                " * `options` (optional) {Object} with the following keys:",
                "   * `moveToEndOfSelection` if true, move to the right of the selection if a",
                "     selection exists."
            ],
            "code": "  moveRight (columnCount = 1, {moveToEndOfSelection} = {}) {\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      this.setScreenPosition(range.end)\r\n    } else {\r\n      let {row, column} = this.getScreenPosition()\r\n      const maxLines = this.editor.getScreenLineCount()\r\n      let rowLength = this.editor.lineLengthForScreenRow(row)\r\n      let columnsRemainingInLine = rowLength - column\r\n\r\n      while (columnCount > columnsRemainingInLine && row < maxLines - 1) {\r\n        columnCount -= columnsRemainingInLine\r\n        columnCount-- // subtract 1 for the row move\r\n\r\n        column = 0\r\n        rowLength = this.editor.lineLengthForScreenRow(++row)\r\n        columnsRemainingInLine = rowLength\r\n      }\r\n\r\n      column = column + columnCount\r\n      this.setScreenPosition({row, column}, {clipDirection: 'forward'})\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setScreenPosition",
            "start_line": 66,
            "end_line": 70,
            "comment": [
                "\r\n  Section: Managing Cursor Position\r\n  ",
                " Public: Moves a cursor to a given screen position.",
                "",
                " * `screenPosition` {Array} of two numbers: the screen row, and the screen column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever",
                "     the cursor moves to."
            ],
            "params": [
                {
                    "name": "screenPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 348,
            "func_location": "Cursor.moveToBeginningOfLine",
            "func_start_line": 347,
            "func_end_line": 349,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the beginning of the buffer line."
            ],
            "code": "  moveToBeginningOfLine () {\r\n    this.setBufferPosition([this.getBufferRow(), 0])\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 348,
            "func_location": "Cursor.moveToBeginningOfLine",
            "func_start_line": 347,
            "func_end_line": 349,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the beginning of the buffer line."
            ],
            "code": "  moveToBeginningOfLine () {\r\n    this.setBufferPosition([this.getBufferRow(), 0])\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getBufferRow",
            "line": 348,
            "func_location": "Cursor.moveToBeginningOfLine",
            "func_start_line": 347,
            "func_end_line": 349,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the beginning of the buffer line."
            ],
            "code": "  moveToBeginningOfLine () {\r\n    this.setBufferPosition([this.getBufferRow(), 0])\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getBufferRow",
            "start_line": 106,
            "end_line": 108,
            "comment": [
                " Public: Retrieves the cursor's current buffer row."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 444,
            "func_location": "Cursor.moveToBeginningOfNextParagraph",
            "func_start_line": 442,
            "func_end_line": 445,
            "args": [
                {
                    "name": "position",
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the beginning of the next paragraph"
            ],
            "code": "  moveToBeginningOfNextParagraph () {\r\n    const position = this.getBeginningOfNextParagraphBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 444,
            "func_location": "Cursor.moveToBeginningOfNextParagraph",
            "func_start_line": 442,
            "func_end_line": 445,
            "args": [
                {
                    "name": "position",
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the beginning of the next paragraph"
            ],
            "code": "  moveToBeginningOfNextParagraph () {\r\n    const position = this.getBeginningOfNextParagraphBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getBeginningOfNextWordBufferPosition",
            "line": 398,
            "func_location": "Cursor.moveToBeginningOfNextWord",
            "func_start_line": 397,
            "func_end_line": 400,
            "args": [],
            "comment": [
                " Public: Moves the cursor to the beginning of the next word."
            ],
            "code": "  moveToBeginningOfNextWord () {\r\n    const position = this.getBeginningOfNextWordBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getBeginningOfNextWordBufferPosition",
            "start_line": 587,
            "end_line": 599,
            "comment": [
                " Public: Retrieves the buffer position of where the next word starts.",
                "",
                " * `options` (optional) {Object}",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "     (default: {::wordRegExp}).",
                "",
                " Returns a {Range}"
            ],
            "params": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 399,
            "func_location": "Cursor.moveToBeginningOfNextWord",
            "func_start_line": 397,
            "func_end_line": 400,
            "args": [
                {
                    "name": "position",
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the beginning of the next word."
            ],
            "code": "  moveToBeginningOfNextWord () {\r\n    const position = this.getBeginningOfNextWordBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 399,
            "func_location": "Cursor.moveToBeginningOfNextWord",
            "func_start_line": 397,
            "func_end_line": 400,
            "args": [
                {
                    "name": "position",
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the beginning of the next word."
            ],
            "code": "  moveToBeginningOfNextWord () {\r\n    const position = this.getBeginningOfNextWordBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 450,
            "func_location": "Cursor.moveToBeginningOfPreviousParagraph",
            "func_start_line": 448,
            "func_end_line": 451,
            "args": [
                {
                    "name": "position",
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the beginning of the previous paragraph"
            ],
            "code": "  moveToBeginningOfPreviousParagraph () {\r\n    const position = this.getBeginningOfPreviousParagraphBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 450,
            "func_location": "Cursor.moveToBeginningOfPreviousParagraph",
            "func_start_line": 448,
            "func_end_line": 451,
            "args": [
                {
                    "name": "position",
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the beginning of the previous paragraph"
            ],
            "code": "  moveToBeginningOfPreviousParagraph () {\r\n    const position = this.getBeginningOfPreviousParagraphBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setScreenPosition",
            "line": 343,
            "func_location": "Cursor.moveToBeginningOfScreenLine",
            "func_start_line": 342,
            "func_end_line": 344,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the beginning of the line."
            ],
            "code": "  moveToBeginningOfScreenLine () {\r\n    this.setScreenPosition([this.getScreenRow(), 0])\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setScreenPosition",
            "start_line": 66,
            "end_line": 70,
            "comment": [
                "\r\n  Section: Managing Cursor Position\r\n  ",
                " Public: Moves a cursor to a given screen position.",
                "",
                " * `screenPosition` {Array} of two numbers: the screen row, and the screen column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever",
                "     the cursor moves to."
            ],
            "params": [
                {
                    "name": "screenPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setScreenPosition",
            "line": 343,
            "func_location": "Cursor.moveToBeginningOfScreenLine",
            "func_start_line": 342,
            "func_end_line": 344,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the beginning of the line."
            ],
            "code": "  moveToBeginningOfScreenLine () {\r\n    this.setScreenPosition([this.getScreenRow(), 0])\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setScreenPosition",
            "start_line": 66,
            "end_line": 70,
            "comment": [
                "\r\n  Section: Managing Cursor Position\r\n  ",
                " Public: Moves a cursor to a given screen position.",
                "",
                " * `screenPosition` {Array} of two numbers: the screen row, and the screen column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever",
                "     the cursor moves to."
            ],
            "params": [
                {
                    "name": "screenPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getScreenRow",
            "line": 343,
            "func_location": "Cursor.moveToBeginningOfScreenLine",
            "func_start_line": 342,
            "func_end_line": 344,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the beginning of the line."
            ],
            "code": "  moveToBeginningOfScreenLine () {\r\n    this.setScreenPosition([this.getScreenRow(), 0])\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getScreenRow",
            "start_line": 96,
            "end_line": 98,
            "comment": [
                " Public: Returns the cursor's current screen row."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 387,
            "func_location": "Cursor.moveToBeginningOfWord",
            "func_start_line": 386,
            "func_end_line": 388,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the beginning of the word."
            ],
            "code": "  moveToBeginningOfWord () {\r\n    this.setBufferPosition(this.getBeginningOfCurrentWordBufferPosition())\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 387,
            "func_location": "Cursor.moveToBeginningOfWord",
            "func_start_line": 386,
            "func_end_line": 388,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the beginning of the word."
            ],
            "code": "  moveToBeginningOfWord () {\r\n    this.setBufferPosition(this.getBeginningOfCurrentWordBufferPosition())\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getBeginningOfCurrentWordBufferPosition",
            "line": 387,
            "func_location": "Cursor.moveToBeginningOfWord",
            "func_start_line": 386,
            "func_end_line": 388,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the beginning of the word."
            ],
            "code": "  moveToBeginningOfWord () {\r\n    this.setBufferPosition(this.getBeginningOfCurrentWordBufferPosition())\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getBeginningOfCurrentWordBufferPosition",
            "start_line": 527,
            "end_line": 547,
            "comment": [
                " Public: Retrieves the buffer position of where the current word starts.",
                "",
                " * `options` (optional) An {Object} with the following keys:",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "     (default: {::wordRegExp}).",
                "   * `includeNonWordCharacters` A {Boolean} indicating whether to include",
                "     non-word characters in the default word regex.",
                "     Has no effect if wordRegex is set.",
                "   * `allowPrevious` A {Boolean} indicating whether the beginning of the",
                "     previous word can be returned.",
                "",
                " Returns a {Range}."
            ],
            "params": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getBeginningOfCurrentWordBufferPosition",
            "line": 387,
            "func_location": "Cursor.moveToBeginningOfWord",
            "func_start_line": 386,
            "func_end_line": 388,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the beginning of the word."
            ],
            "code": "  moveToBeginningOfWord () {\r\n    this.setBufferPosition(this.getBeginningOfCurrentWordBufferPosition())\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getBeginningOfCurrentWordBufferPosition",
            "start_line": 527,
            "end_line": 547,
            "comment": [
                " Public: Retrieves the buffer position of where the current word starts.",
                "",
                " * `options` (optional) An {Object} with the following keys:",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "     (default: {::wordRegExp}).",
                "   * `includeNonWordCharacters` A {Boolean} indicating whether to include",
                "     non-word characters in the default word regex.",
                "     Has no effect if wordRegex is set.",
                "   * `allowPrevious` A {Boolean} indicating whether the beginning of the",
                "     previous word can be returned.",
                "",
                " Returns a {Range}."
            ],
            "params": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 337,
            "func_location": "Cursor.moveToBottom",
            "func_start_line": 335,
            "func_end_line": 339,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the bottom of the buffer."
            ],
            "code": "  moveToBottom () {\r\n    const column = this.goalColumn\r\n    this.setBufferPosition(this.editor.getEofBufferPosition())\r\n    this.goalColumn = column\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 337,
            "func_location": "Cursor.moveToBottom",
            "func_start_line": 335,
            "func_end_line": 339,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the bottom of the buffer."
            ],
            "code": "  moveToBottom () {\r\n    const column = this.goalColumn\r\n    this.setBufferPosition(this.editor.getEofBufferPosition())\r\n    this.goalColumn = column\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 382,
            "func_location": "Cursor.moveToEndOfLine",
            "func_start_line": 381,
            "func_end_line": 383,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the end of the buffer line."
            ],
            "code": "  moveToEndOfLine () {\r\n    this.setBufferPosition([this.getBufferRow(), Infinity])\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 382,
            "func_location": "Cursor.moveToEndOfLine",
            "func_start_line": 381,
            "func_end_line": 383,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the end of the buffer line."
            ],
            "code": "  moveToEndOfLine () {\r\n    this.setBufferPosition([this.getBufferRow(), Infinity])\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getBufferRow",
            "line": 382,
            "func_location": "Cursor.moveToEndOfLine",
            "func_start_line": 381,
            "func_end_line": 383,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the end of the buffer line."
            ],
            "code": "  moveToEndOfLine () {\r\n    this.setBufferPosition([this.getBufferRow(), Infinity])\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getBufferRow",
            "start_line": 106,
            "end_line": 108,
            "comment": [
                " Public: Retrieves the cursor's current buffer row."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setScreenPosition",
            "line": 377,
            "func_location": "Cursor.moveToEndOfScreenLine",
            "func_start_line": 376,
            "func_end_line": 378,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the end of the line."
            ],
            "code": "  moveToEndOfScreenLine () {\r\n    this.setScreenPosition([this.getScreenRow(), Infinity])\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setScreenPosition",
            "start_line": 66,
            "end_line": 70,
            "comment": [
                "\r\n  Section: Managing Cursor Position\r\n  ",
                " Public: Moves a cursor to a given screen position.",
                "",
                " * `screenPosition` {Array} of two numbers: the screen row, and the screen column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever",
                "     the cursor moves to."
            ],
            "params": [
                {
                    "name": "screenPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setScreenPosition",
            "line": 377,
            "func_location": "Cursor.moveToEndOfScreenLine",
            "func_start_line": 376,
            "func_end_line": 378,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the end of the line."
            ],
            "code": "  moveToEndOfScreenLine () {\r\n    this.setScreenPosition([this.getScreenRow(), Infinity])\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setScreenPosition",
            "start_line": 66,
            "end_line": 70,
            "comment": [
                "\r\n  Section: Managing Cursor Position\r\n  ",
                " Public: Moves a cursor to a given screen position.",
                "",
                " * `screenPosition` {Array} of two numbers: the screen row, and the screen column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever",
                "     the cursor moves to."
            ],
            "params": [
                {
                    "name": "screenPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getScreenRow",
            "line": 377,
            "func_location": "Cursor.moveToEndOfScreenLine",
            "func_start_line": 376,
            "func_end_line": 378,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the end of the line."
            ],
            "code": "  moveToEndOfScreenLine () {\r\n    this.setScreenPosition([this.getScreenRow(), Infinity])\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getScreenRow",
            "start_line": 96,
            "end_line": 98,
            "comment": [
                " Public: Returns the cursor's current screen row."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getEndOfCurrentWordBufferPosition",
            "line": 392,
            "func_location": "Cursor.moveToEndOfWord",
            "func_start_line": 391,
            "func_end_line": 394,
            "args": [],
            "comment": [
                " Public: Moves the cursor to the end of the word."
            ],
            "code": "  moveToEndOfWord () {\r\n    const position = this.getEndOfCurrentWordBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getEndOfCurrentWordBufferPosition",
            "start_line": 559,
            "end_line": 578,
            "comment": [
                " Public: Retrieves the buffer position of where the current word ends.",
                "",
                " * `options` (optional) {Object} with the following keys:",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "      (default: {::wordRegExp})",
                "   * `includeNonWordCharacters` A Boolean indicating whether to include",
                "     non-word characters in the default word regex. Has no effect if",
                "     wordRegex is set.",
                "",
                " Returns a {Range}."
            ],
            "params": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 393,
            "func_location": "Cursor.moveToEndOfWord",
            "func_start_line": 391,
            "func_end_line": 394,
            "args": [
                {
                    "name": "position",
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the end of the word."
            ],
            "code": "  moveToEndOfWord () {\r\n    const position = this.getEndOfCurrentWordBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 393,
            "func_location": "Cursor.moveToEndOfWord",
            "func_start_line": 391,
            "func_end_line": 394,
            "args": [
                {
                    "name": "position",
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the end of the word."
            ],
            "code": "  moveToEndOfWord () {\r\n    const position = this.getEndOfCurrentWordBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 372,
            "func_location": "Cursor.moveToFirstCharacterOfLine",
            "func_start_line": 353,
            "func_end_line": 373,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the beginning of the first character in the",
                " line."
            ],
            "code": "  moveToFirstCharacterOfLine () {\r\n    let targetBufferColumn\r\n    const screenRow = this.getScreenRow()\r\n    const screenLineStart = this.editor.clipScreenPosition([screenRow, 0], {skipSoftWrapIndentation: true})\r\n    const screenLineEnd = [screenRow, Infinity]\r\n    const screenLineBufferRange = this.editor.bufferRangeForScreenRange([screenLineStart, screenLineEnd])\r\n\r\n    let firstCharacterColumn = null\r\n    this.editor.scanInBufferRange(/\\S/, screenLineBufferRange, ({range, stop}) => {\r\n      firstCharacterColumn = range.start.column\r\n      stop()\r\n    })\r\n\r\n    if (firstCharacterColumn != null && firstCharacterColumn !== this.getBufferColumn()) {\r\n      targetBufferColumn = firstCharacterColumn\r\n    } else {\r\n      targetBufferColumn = screenLineBufferRange.start.column\r\n    }\r\n\r\n    this.setBufferPosition([screenLineBufferRange.start.row, targetBufferColumn])\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 372,
            "func_location": "Cursor.moveToFirstCharacterOfLine",
            "func_start_line": 353,
            "func_end_line": 373,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the beginning of the first character in the",
                " line."
            ],
            "code": "  moveToFirstCharacterOfLine () {\r\n    let targetBufferColumn\r\n    const screenRow = this.getScreenRow()\r\n    const screenLineStart = this.editor.clipScreenPosition([screenRow, 0], {skipSoftWrapIndentation: true})\r\n    const screenLineEnd = [screenRow, Infinity]\r\n    const screenLineBufferRange = this.editor.bufferRangeForScreenRange([screenLineStart, screenLineEnd])\r\n\r\n    let firstCharacterColumn = null\r\n    this.editor.scanInBufferRange(/\\S/, screenLineBufferRange, ({range, stop}) => {\r\n      firstCharacterColumn = range.start.column\r\n      stop()\r\n    })\r\n\r\n    if (firstCharacterColumn != null && firstCharacterColumn !== this.getBufferColumn()) {\r\n      targetBufferColumn = firstCharacterColumn\r\n    } else {\r\n      targetBufferColumn = screenLineBufferRange.start.column\r\n    }\r\n\r\n    this.setBufferPosition([screenLineBufferRange.start.row, targetBufferColumn])\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getNextWordBoundaryBufferPosition",
            "line": 424,
            "func_location": "Cursor.moveToNextSubwordBoundary",
            "func_start_line": 422,
            "func_end_line": 426,
            "args": [
                {
                    "name": "options",
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the next subword boundary."
            ],
            "code": "  moveToNextSubwordBoundary () {\r\n    const options = {wordRegex: this.subwordRegExp()}\r\n    const position = this.getNextWordBoundaryBufferPosition(options)\r\n    if (position) this.setBufferPosition(position)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getNextWordBoundaryBufferPosition",
            "start_line": 493,
            "end_line": 513,
            "comment": [
                " Public: Returns buffer position of the next word boundary. It might be on",
                " the current word, or the previous word.",
                "",
                " * `options` (optional) {Object} with the following keys:",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "      (default: {::wordRegExp})"
            ],
            "params": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getNextWordBoundaryBufferPosition",
            "line": 424,
            "func_location": "Cursor.moveToNextSubwordBoundary",
            "func_start_line": 422,
            "func_end_line": 426,
            "args": [
                {
                    "name": "options",
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the next subword boundary."
            ],
            "code": "  moveToNextSubwordBoundary () {\r\n    const options = {wordRegex: this.subwordRegExp()}\r\n    const position = this.getNextWordBoundaryBufferPosition(options)\r\n    if (position) this.setBufferPosition(position)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getNextWordBoundaryBufferPosition",
            "start_line": 493,
            "end_line": 513,
            "comment": [
                " Public: Returns buffer position of the next word boundary. It might be on",
                " the current word, or the previous word.",
                "",
                " * `options` (optional) {Object} with the following keys:",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "      (default: {::wordRegExp})"
            ],
            "params": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 425,
            "func_location": "Cursor.moveToNextSubwordBoundary",
            "func_start_line": 422,
            "func_end_line": 426,
            "args": [
                {
                    "name": "position",
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the next subword boundary."
            ],
            "code": "  moveToNextSubwordBoundary () {\r\n    const options = {wordRegex: this.subwordRegExp()}\r\n    const position = this.getNextWordBoundaryBufferPosition(options)\r\n    if (position) this.setBufferPosition(position)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 425,
            "func_location": "Cursor.moveToNextSubwordBoundary",
            "func_start_line": 422,
            "func_end_line": 426,
            "args": [
                {
                    "name": "position",
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the next subword boundary."
            ],
            "code": "  moveToNextSubwordBoundary () {\r\n    const options = {wordRegex: this.subwordRegExp()}\r\n    const position = this.getNextWordBoundaryBufferPosition(options)\r\n    if (position) this.setBufferPosition(position)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getNextWordBoundaryBufferPosition",
            "line": 410,
            "func_location": "Cursor.moveToNextWordBoundary",
            "func_start_line": 409,
            "func_end_line": 412,
            "args": [],
            "comment": [
                " Public: Moves the cursor to the next word boundary."
            ],
            "code": "  moveToNextWordBoundary () {\r\n    const position = this.getNextWordBoundaryBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getNextWordBoundaryBufferPosition",
            "start_line": 493,
            "end_line": 513,
            "comment": [
                " Public: Returns buffer position of the next word boundary. It might be on",
                " the current word, or the previous word.",
                "",
                " * `options` (optional) {Object} with the following keys:",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "      (default: {::wordRegExp})"
            ],
            "params": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 411,
            "func_location": "Cursor.moveToNextWordBoundary",
            "func_start_line": 409,
            "func_end_line": 412,
            "args": [
                {
                    "name": "position",
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the next word boundary."
            ],
            "code": "  moveToNextWordBoundary () {\r\n    const position = this.getNextWordBoundaryBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 411,
            "func_location": "Cursor.moveToNextWordBoundary",
            "func_start_line": 409,
            "func_end_line": 412,
            "args": [
                {
                    "name": "position",
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the next word boundary."
            ],
            "code": "  moveToNextWordBoundary () {\r\n    const position = this.getNextWordBoundaryBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getPreviousWordBoundaryBufferPosition",
            "line": 417,
            "func_location": "Cursor.moveToPreviousSubwordBoundary",
            "func_start_line": 415,
            "func_end_line": 419,
            "args": [
                {
                    "name": "options",
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the previous subword boundary."
            ],
            "code": "  moveToPreviousSubwordBoundary () {\r\n    const options = {wordRegex: this.subwordRegExp({backwards: true})}\r\n    const position = this.getPreviousWordBoundaryBufferPosition(options)\r\n    if (position) this.setBufferPosition(position)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getPreviousWordBoundaryBufferPosition",
            "start_line": 463,
            "end_line": 485,
            "comment": [
                "\r\n  Section: Local Positions and Ranges\r\n  ",
                " Public: Returns buffer position of previous word boundary. It might be on",
                " the current word, or the previous word.",
                "",
                " * `options` (optional) {Object} with the following keys:",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "      (default: {::wordRegExp})"
            ],
            "params": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getPreviousWordBoundaryBufferPosition",
            "line": 417,
            "func_location": "Cursor.moveToPreviousSubwordBoundary",
            "func_start_line": 415,
            "func_end_line": 419,
            "args": [
                {
                    "name": "options",
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the previous subword boundary."
            ],
            "code": "  moveToPreviousSubwordBoundary () {\r\n    const options = {wordRegex: this.subwordRegExp({backwards: true})}\r\n    const position = this.getPreviousWordBoundaryBufferPosition(options)\r\n    if (position) this.setBufferPosition(position)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getPreviousWordBoundaryBufferPosition",
            "start_line": 463,
            "end_line": 485,
            "comment": [
                "\r\n  Section: Local Positions and Ranges\r\n  ",
                " Public: Returns buffer position of previous word boundary. It might be on",
                " the current word, or the previous word.",
                "",
                " * `options` (optional) {Object} with the following keys:",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "      (default: {::wordRegExp})"
            ],
            "params": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 418,
            "func_location": "Cursor.moveToPreviousSubwordBoundary",
            "func_start_line": 415,
            "func_end_line": 419,
            "args": [
                {
                    "name": "position",
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the previous subword boundary."
            ],
            "code": "  moveToPreviousSubwordBoundary () {\r\n    const options = {wordRegex: this.subwordRegExp({backwards: true})}\r\n    const position = this.getPreviousWordBoundaryBufferPosition(options)\r\n    if (position) this.setBufferPosition(position)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 418,
            "func_location": "Cursor.moveToPreviousSubwordBoundary",
            "func_start_line": 415,
            "func_end_line": 419,
            "args": [
                {
                    "name": "position",
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the previous subword boundary."
            ],
            "code": "  moveToPreviousSubwordBoundary () {\r\n    const options = {wordRegex: this.subwordRegExp({backwards: true})}\r\n    const position = this.getPreviousWordBoundaryBufferPosition(options)\r\n    if (position) this.setBufferPosition(position)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getPreviousWordBoundaryBufferPosition",
            "line": 404,
            "func_location": "Cursor.moveToPreviousWordBoundary",
            "func_start_line": 403,
            "func_end_line": 406,
            "args": [],
            "comment": [
                " Public: Moves the cursor to the previous word boundary."
            ],
            "code": "  moveToPreviousWordBoundary () {\r\n    const position = this.getPreviousWordBoundaryBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getPreviousWordBoundaryBufferPosition",
            "start_line": 463,
            "end_line": 485,
            "comment": [
                "\r\n  Section: Local Positions and Ranges\r\n  ",
                " Public: Returns buffer position of previous word boundary. It might be on",
                " the current word, or the previous word.",
                "",
                " * `options` (optional) {Object} with the following keys:",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "      (default: {::wordRegExp})"
            ],
            "params": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 405,
            "func_location": "Cursor.moveToPreviousWordBoundary",
            "func_start_line": 403,
            "func_end_line": 406,
            "args": [
                {
                    "name": "position",
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the previous word boundary."
            ],
            "code": "  moveToPreviousWordBoundary () {\r\n    const position = this.getPreviousWordBoundaryBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 405,
            "func_location": "Cursor.moveToPreviousWordBoundary",
            "func_start_line": 403,
            "func_end_line": 406,
            "args": [
                {
                    "name": "position",
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the previous word boundary."
            ],
            "code": "  moveToPreviousWordBoundary () {\r\n    const position = this.getPreviousWordBoundaryBufferPosition()\r\n    if (position) this.setBufferPosition(position)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 331,
            "func_location": "Cursor.moveToTop",
            "func_start_line": 330,
            "func_end_line": 332,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the top of the buffer."
            ],
            "code": "  moveToTop () {\r\n    this.setBufferPosition([0, 0])\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 331,
            "func_location": "Cursor.moveToTop",
            "func_start_line": 330,
            "func_end_line": 332,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the top of the buffer."
            ],
            "code": "  moveToTop () {\r\n    this.setBufferPosition([0, 0])\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setScreenPosition",
            "line": 251,
            "func_location": "Cursor.moveUp",
            "func_start_line": 241,
            "func_end_line": 253,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Moving the Cursor\r\n  ",
                " Public: Moves the cursor up one screen row.",
                "",
                " * `rowCount` (optional) {Number} number of rows to move (default: 1)",
                " * `options` (optional) {Object} with the following keys:",
                "   * `moveToEndOfSelection` if true, move to the left of the selection if a",
                "     selection exists."
            ],
            "code": "  moveUp (rowCount = 1, {moveToEndOfSelection} = {}) {\r\n    let row, column\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      ({row, column} = range.start)\r\n    } else {\r\n      ({row, column} = this.getScreenPosition())\r\n    }\r\n\r\n    if (this.goalColumn != null) column = this.goalColumn\r\n    this.setScreenPosition({row: row - rowCount, column}, {skipSoftWrapIndentation: true})\r\n    this.goalColumn = column\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setScreenPosition",
            "start_line": 66,
            "end_line": 70,
            "comment": [
                "\r\n  Section: Managing Cursor Position\r\n  ",
                " Public: Moves a cursor to a given screen position.",
                "",
                " * `screenPosition` {Array} of two numbers: the screen row, and the screen column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever",
                "     the cursor moves to."
            ],
            "params": [
                {
                    "name": "screenPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setScreenPosition",
            "line": 251,
            "func_location": "Cursor.moveUp",
            "func_start_line": 241,
            "func_end_line": 253,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Moving the Cursor\r\n  ",
                " Public: Moves the cursor up one screen row.",
                "",
                " * `rowCount` (optional) {Number} number of rows to move (default: 1)",
                " * `options` (optional) {Object} with the following keys:",
                "   * `moveToEndOfSelection` if true, move to the left of the selection if a",
                "     selection exists."
            ],
            "code": "  moveUp (rowCount = 1, {moveToEndOfSelection} = {}) {\r\n    let row, column\r\n    const range = this.marker.getScreenRange()\r\n    if (moveToEndOfSelection && !range.isEmpty()) {\r\n      ({row, column} = range.start)\r\n    } else {\r\n      ({row, column} = this.getScreenPosition())\r\n    }\r\n\r\n    if (this.goalColumn != null) column = this.goalColumn\r\n    this.setScreenPosition({row: row - rowCount, column}, {skipSoftWrapIndentation: true})\r\n    this.goalColumn = column\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setScreenPosition",
            "start_line": 66,
            "end_line": 70,
            "comment": [
                "\r\n  Section: Managing Cursor Position\r\n  ",
                " Public: Moves a cursor to a given screen position.",
                "",
                " * `screenPosition` {Array} of two numbers: the screen row, and the screen column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` A Boolean which, if `true`, scrolls the {TextEditor} to wherever",
                "     the cursor moves to."
            ],
            "params": [
                {
                    "name": "screenPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/start.js",
            "name": "replace",
            "line": 126,
            "func_location": "normalizeDriveLetterName",
            "func_start_line": 124,
            "func_end_line": 130,
            "args": [
                {
                    "type": "object"
                },
                null
            ],
            "code": "function normalizeDriveLetterName (filePath) {\r\n  if (process.platform === 'win32' && filePath) {\r\n    return filePath.replace(/^([a-z]):/, ([driveLetter]) => driveLetter.toUpperCase() + ':')\r\n  } else {\r\n    return filePath\r\n  }\r\n}\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "Project.replace",
            "start_line": 82,
            "end_line": 99,
            "comment": [
                " Layers the contents of a project's file's config",
                " on top of the current global config."
            ],
            "params": [
                {
                    "name": "projectSpecification",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/menu-helpers.js",
            "name": "replace",
            "line": 72,
            "func_location": "normalizeLabel",
            "func_start_line": 68,
            "func_end_line": 73,
            "args": [
                {
                    "type": "object"
                },
                {
                    "type": "string"
                }
            ],
            "code": "function normalizeLabel (label) {\r\n  if (label == null) {\r\n    return\r\n  }\r\n  return process.platform === 'darwin' ? label : label.replace(/&/g, '')\r\n}\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "Project.replace",
            "start_line": 82,
            "end_line": 99,
            "comment": [
                " Layers the contents of a project's file's config",
                " on top of the current global config."
            ],
            "params": [
                {
                    "name": "projectSpecification",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "error",
            "line": 478,
            "func_location": "Config.observe",
            "func_start_line": 470,
            "func_end_line": 487,
            "args": [
                {
                    "name": {
                        "type": "string"
                    },
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Config Subscription\r\n  ",
                " Essential: Add a listener for changes to a given key path. This is different",
                " than {::onDidChange} in that it will immediately call your callback with the",
                " current value of the config entry.",
                "",
                " ### Examples",
                "",
                " You might want to be notified when the themes change. We'll watch",
                " `core.themes` for changes",
                "",
                " ```coffee",
                " atom.config.observe 'core.themes', (value) ->",
                "   # do stuff with value",
                " ```",
                "",
                " * `keyPath` {String} name of the key to observe",
                " * `options` (optional) {Object}",
                "   * `scope` (optional) {ScopeDescriptor} describing a path from",
                "     the root of the syntax tree to a token. Get one by calling",
                "     {editor.getLastCursor().getScopeDescriptor()}. See {::get} for examples.",
                "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)",
                "     for more information.",
                " * `callback` {Function} to call when the value of the key changes.",
                "   * `value` the new value of the key",
                "",
                " Returns a {Disposable} with the following keys on which you can call",
                " `.dispose()` to unsubscribe."
            ],
            "code": "  observe (...args) {\r\n    let callback, keyPath, options, scopeDescriptor\r\n    if (args.length === 2) {\r\n      [keyPath, callback] = args\r\n    } else if ((args.length === 3) && (_.isString(args[0]) && _.isObject(args[1]))) {\r\n      [keyPath, options, callback] = args\r\n      scopeDescriptor = options.scope\r\n    } else {\r\n      console.error('An unsupported form of Config::observe is being used. See https://atom.io/docs/api/latest/Config for details')\r\n      return\r\n    }\r\n\r\n    if (scopeDescriptor != null) {\r\n      return this.observeScopedKeyPath(scopeDescriptor, keyPath, callback)\r\n    } else {\r\n      return this.observeKeyPath(keyPath, options != null ? options : {}, callback)\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/initialize-benchmark-window.js",
            "name": "console.error",
            "start_line": 86,
            "end_line": 89,
            "comment": [],
            "params": [
                "args"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "observeScopedKeyPath",
            "line": 483,
            "func_location": "Config.observe",
            "func_start_line": 470,
            "func_end_line": 487,
            "args": [
                {
                    "name": "scopeDescriptor",
                    "type": []
                },
                {
                    "name": "keyPath",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "comment": [
                "\r\n  Section: Config Subscription\r\n  ",
                " Essential: Add a listener for changes to a given key path. This is different",
                " than {::onDidChange} in that it will immediately call your callback with the",
                " current value of the config entry.",
                "",
                " ### Examples",
                "",
                " You might want to be notified when the themes change. We'll watch",
                " `core.themes` for changes",
                "",
                " ```coffee",
                " atom.config.observe 'core.themes', (value) ->",
                "   # do stuff with value",
                " ```",
                "",
                " * `keyPath` {String} name of the key to observe",
                " * `options` (optional) {Object}",
                "   * `scope` (optional) {ScopeDescriptor} describing a path from",
                "     the root of the syntax tree to a token. Get one by calling",
                "     {editor.getLastCursor().getScopeDescriptor()}. See {::get} for examples.",
                "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)",
                "     for more information.",
                " * `callback` {Function} to call when the value of the key changes.",
                "   * `value` the new value of the key",
                "",
                " Returns a {Disposable} with the following keys on which you can call",
                " `.dispose()` to unsubscribe."
            ],
            "code": "  observe (...args) {\r\n    let callback, keyPath, options, scopeDescriptor\r\n    if (args.length === 2) {\r\n      [keyPath, callback] = args\r\n    } else if ((args.length === 3) && (_.isString(args[0]) && _.isObject(args[1]))) {\r\n      [keyPath, options, callback] = args\r\n      scopeDescriptor = options.scope\r\n    } else {\r\n      console.error('An unsupported form of Config::observe is being used. See https://atom.io/docs/api/latest/Config for details')\r\n      return\r\n    }\r\n\r\n    if (scopeDescriptor != null) {\r\n      return this.observeScopedKeyPath(scopeDescriptor, keyPath, callback)\r\n    } else {\r\n      return this.observeKeyPath(keyPath, options != null ? options : {}, callback)\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.observeScopedKeyPath",
            "start_line": 1264,
            "end_line": 1267,
            "comment": [],
            "params": [
                "scope",
                "keyPath",
                "callback"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "observeKeyPath",
            "line": 485,
            "func_location": "Config.observe",
            "func_start_line": 470,
            "func_end_line": 487,
            "args": [
                {
                    "name": "keyPath",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "comment": [
                "\r\n  Section: Config Subscription\r\n  ",
                " Essential: Add a listener for changes to a given key path. This is different",
                " than {::onDidChange} in that it will immediately call your callback with the",
                " current value of the config entry.",
                "",
                " ### Examples",
                "",
                " You might want to be notified when the themes change. We'll watch",
                " `core.themes` for changes",
                "",
                " ```coffee",
                " atom.config.observe 'core.themes', (value) ->",
                "   # do stuff with value",
                " ```",
                "",
                " * `keyPath` {String} name of the key to observe",
                " * `options` (optional) {Object}",
                "   * `scope` (optional) {ScopeDescriptor} describing a path from",
                "     the root of the syntax tree to a token. Get one by calling",
                "     {editor.getLastCursor().getScopeDescriptor()}. See {::get} for examples.",
                "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)",
                "     for more information.",
                " * `callback` {Function} to call when the value of the key changes.",
                "   * `value` the new value of the key",
                "",
                " Returns a {Disposable} with the following keys on which you can call",
                " `.dispose()` to unsubscribe."
            ],
            "code": "  observe (...args) {\r\n    let callback, keyPath, options, scopeDescriptor\r\n    if (args.length === 2) {\r\n      [keyPath, callback] = args\r\n    } else if ((args.length === 3) && (_.isString(args[0]) && _.isObject(args[1]))) {\r\n      [keyPath, options, callback] = args\r\n      scopeDescriptor = options.scope\r\n    } else {\r\n      console.error('An unsupported form of Config::observe is being used. See https://atom.io/docs/api/latest/Config for details')\r\n      return\r\n    }\r\n\r\n    if (scopeDescriptor != null) {\r\n      return this.observeScopedKeyPath(scopeDescriptor, keyPath, callback)\r\n    } else {\r\n      return this.observeKeyPath(keyPath, options != null ? options : {}, callback)\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.observeKeyPath",
            "start_line": 1041,
            "end_line": 1044,
            "comment": [],
            "params": [
                "keyPath",
                "options",
                "callback"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "onDidAddBuffer",
            "line": 192,
            "func_location": "Project.observeBuffers",
            "func_start_line": 190,
            "func_end_line": 193,
            "args": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "comment": [
                " Public: Invoke the given callback with all current and future text",
                " buffers in the project.",
                "",
                " * `callback` {Function} to be called with current and future text buffers.",
                "   * `buffer` A {TextBuffer} item.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "code": "  observeBuffers (callback) {\r\n    for (let buffer of this.getBuffers()) { callback(buffer) }\r\n    return this.onDidAddBuffer(callback)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "Project.onDidAddBuffer",
            "start_line": 179,
            "end_line": 181,
            "comment": [
                " Public: Invoke the given callback when a text buffer is added to the",
                " project.",
                "",
                " * `callback` {Function} to be called when a text buffer is added.",
                "   * `buffer` A {TextBuffer} item.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "onDidAddBuffer",
            "line": 192,
            "func_location": "Project.observeBuffers",
            "func_start_line": 190,
            "func_end_line": 193,
            "args": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "comment": [
                " Public: Invoke the given callback with all current and future text",
                " buffers in the project.",
                "",
                " * `callback` {Function} to be called with current and future text buffers.",
                "   * `buffer` A {TextBuffer} item.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "code": "  observeBuffers (callback) {\r\n    for (let buffer of this.getBuffers()) { callback(buffer) }\r\n    return this.onDidAddBuffer(callback)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "Project.onDidAddBuffer",
            "start_line": 179,
            "end_line": 181,
            "comment": [
                " Public: Invoke the given callback when a text buffer is added to the",
                " project.",
                "",
                " * `callback` {Function} to be called when a text buffer is added.",
                "   * `buffer` A {TextBuffer} item.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "onDidAddCursor",
            "line": 836,
            "func_location": "TextEditor.observeCursors",
            "func_start_line": 834,
            "func_end_line": 837,
            "args": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "comment": [
                " Extended: Calls your `callback` when a {Cursor} is added to the editor.",
                " Immediately calls your callback for each existing cursor.",
                "",
                " * `callback` {Function}",
                "   * `cursor` {Cursor} that was added",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "code": "  observeCursors (callback) {\r\n    this.getCursors().forEach(callback)\r\n    return this.onDidAddCursor(callback)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.onDidAddCursor",
            "start_line": 845,
            "end_line": 847,
            "comment": [
                " Extended: Calls your `callback` when a {Cursor} is added to the editor.",
                "",
                " * `callback` {Function}",
                "   * `cursor` {Cursor} that was added",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "onDidAddCursor",
            "line": 836,
            "func_location": "TextEditor.observeCursors",
            "func_start_line": 834,
            "func_end_line": 837,
            "args": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "comment": [
                " Extended: Calls your `callback` when a {Cursor} is added to the editor.",
                " Immediately calls your callback for each existing cursor.",
                "",
                " * `callback` {Function}",
                "   * `cursor` {Cursor} that was added",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "code": "  observeCursors (callback) {\r\n    this.getCursors().forEach(callback)\r\n    return this.onDidAddCursor(callback)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.onDidAddCursor",
            "start_line": 845,
            "end_line": 847,
            "comment": [
                " Extended: Calls your `callback` when a {Cursor} is added to the editor.",
                "",
                " * `callback` {Function}",
                "   * `cursor` {Cursor} that was added",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "getGrammar",
            "line": 748,
            "func_location": "TextEditor.observeGrammar",
            "func_start_line": 747,
            "func_end_line": 750,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Extended: Calls your `callback` when the grammar that interprets and",
                " colorizes the text has been changed. Immediately calls your callback with",
                " the current grammar.",
                "",
                " * `callback` {Function}",
                "   * `grammar` {Grammar}",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "code": "  observeGrammar (callback) {\r\n    callback(this.getGrammar())\r\n    return this.onDidChangeGrammar(callback)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-mate-language-mode.js",
            "name": "TextMateLanguageMode.getGrammar",
            "start_line": 55,
            "end_line": 57,
            "comment": [],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "onDidChangeGrammar",
            "line": 749,
            "func_location": "TextEditor.observeGrammar",
            "func_start_line": 747,
            "func_end_line": 750,
            "args": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "comment": [
                " Extended: Calls your `callback` when the grammar that interprets and",
                " colorizes the text has been changed. Immediately calls your callback with",
                " the current grammar.",
                "",
                " * `callback` {Function}",
                "   * `grammar` {Grammar}",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "code": "  observeGrammar (callback) {\r\n    callback(this.getGrammar())\r\n    return this.onDidChangeGrammar(callback)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.onDidChangeGrammar",
            "start_line": 759,
            "end_line": 763,
            "comment": [
                " Extended: Calls your `callback` when the grammar that interprets and",
                " colorizes the text has been changed.",
                "",
                " * `callback` {Function}",
                "   * `grammar` {Grammar}",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "onDidChangeGrammar",
            "line": 749,
            "func_location": "TextEditor.observeGrammar",
            "func_start_line": 747,
            "func_end_line": 750,
            "args": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "comment": [
                " Extended: Calls your `callback` when the grammar that interprets and",
                " colorizes the text has been changed. Immediately calls your callback with",
                " the current grammar.",
                "",
                " * `callback` {Function}",
                "   * `grammar` {Grammar}",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "code": "  observeGrammar (callback) {\r\n    callback(this.getGrammar())\r\n    return this.onDidChangeGrammar(callback)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.onDidChangeGrammar",
            "start_line": 759,
            "end_line": 763,
            "comment": [
                " Extended: Calls your `callback` when the grammar that interprets and",
                " colorizes the text has been changed.",
                "",
                " * `callback` {Function}",
                "   * `grammar` {Grammar}",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "get",
            "line": 1042,
            "func_location": "Config.observeKeyPath",
            "func_start_line": 1041,
            "func_end_line": 1044,
            "args": [
                null
            ],
            "code": "  observeKeyPath (keyPath, options, callback) {\r\n    callback(this.get(keyPath))\r\n    return this.onDidChangeKeyPath(keyPath, event => callback(event.newValue))\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.get",
            "start_line": 585,
            "end_line": 602,
            "comment": [
                "\r\n  Section: Managing Settings\r\n  ",
                " Essential: Retrieves the setting for the given key.",
                "",
                " ### Examples",
                "",
                " You might want to know what themes are enabled, so check `core.themes`",
                "",
                " ```coffee",
                " atom.config.get('core.themes')",
                " ```",
                "",
                " With scope descriptors you can get settings within a specific editor",
                " scope. For example, you might want to know `editor.tabLength` for ruby",
                " files.",
                "",
                " ```coffee",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2",
                " ```",
                "",
                " This setting in ruby files might be different than the global tabLength setting",
                "",
                " ```coffee",
                " atom.config.get('editor.tabLength') # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2",
                " ```",
                "",
                " You can get the language scope descriptor via",
                " {TextEditor::getRootScopeDescriptor}. This will get the setting specifically",
                " for the editor's language.",
                "",
                " ```coffee",
                " atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2",
                " ```",
                "",
                " Additionally, you can get the setting at the specific cursor position.",
                "",
                " ```coffee",
                " scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()",
                " atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2",
                " ```",
                "",
                " * `keyPath` The {String} name of the key to retrieve.",
                " * `options` (optional) {Object}",
                "   * `sources` (optional) {Array} of {String} source names. If provided, only",
                "     values that were associated with these sources during {::set} will be used.",
                "   * `excludeSources` (optional) {Array} of {String} source names. If provided,",
                "     values that  were associated with these sources during {::set} will not",
                "     be used.",
                "   * `scope` (optional) {ScopeDescriptor} describing a path from",
                "     the root of the syntax tree to a token. Get one by calling",
                "     {editor.getLastCursor().getScopeDescriptor()}",
                "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)",
                "     for more information.",
                "",
                " Returns the value from Atom's default settings, the user's configuration",
                " file in the type specified by the configuration schema."
            ],
            "params": [
                {
                    "name": "args",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "get",
            "line": 1265,
            "func_location": "Config.observeScopedKeyPath",
            "func_start_line": 1264,
            "func_end_line": 1267,
            "args": [
                null
            ],
            "code": "  observeScopedKeyPath (scope, keyPath, callback) {\r\n    callback(this.get(keyPath, {scope}))\r\n    return this.onDidChangeScopedKeyPath(scope, keyPath, event => callback(event.newValue))\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.get",
            "start_line": 585,
            "end_line": 602,
            "comment": [
                "\r\n  Section: Managing Settings\r\n  ",
                " Essential: Retrieves the setting for the given key.",
                "",
                " ### Examples",
                "",
                " You might want to know what themes are enabled, so check `core.themes`",
                "",
                " ```coffee",
                " atom.config.get('core.themes')",
                " ```",
                "",
                " With scope descriptors you can get settings within a specific editor",
                " scope. For example, you might want to know `editor.tabLength` for ruby",
                " files.",
                "",
                " ```coffee",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2",
                " ```",
                "",
                " This setting in ruby files might be different than the global tabLength setting",
                "",
                " ```coffee",
                " atom.config.get('editor.tabLength') # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2",
                " ```",
                "",
                " You can get the language scope descriptor via",
                " {TextEditor::getRootScopeDescriptor}. This will get the setting specifically",
                " for the editor's language.",
                "",
                " ```coffee",
                " atom.config.get('editor.tabLength', scope: @editor.getRootScopeDescriptor()) # => 2",
                " ```",
                "",
                " Additionally, you can get the setting at the specific cursor position.",
                "",
                " ```coffee",
                " scopeDescriptor = @editor.getLastCursor().getScopeDescriptor()",
                " atom.config.get('editor.tabLength', scope: scopeDescriptor) # => 2",
                " ```",
                "",
                " * `keyPath` The {String} name of the key to retrieve.",
                " * `options` (optional) {Object}",
                "   * `sources` (optional) {Array} of {String} source names. If provided, only",
                "     values that were associated with these sources during {::set} will be used.",
                "   * `excludeSources` (optional) {Array} of {String} source names. If provided,",
                "     values that  were associated with these sources during {::set} will not",
                "     be used.",
                "   * `scope` (optional) {ScopeDescriptor} describing a path from",
                "     the root of the syntax tree to a token. Get one by calling",
                "     {editor.getLastCursor().getScopeDescriptor()}",
                "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)",
                "     for more information.",
                "",
                " Returns the value from Atom's default settings, the user's configuration",
                " file in the type specified by the configuration schema."
            ],
            "params": [
                {
                    "name": "args",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "onDidAddSelection",
            "line": 868,
            "func_location": "TextEditor.observeSelections",
            "func_start_line": 866,
            "func_end_line": 869,
            "args": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "comment": [
                " Extended: Calls your `callback` when a {Selection} is added to the editor.",
                " Immediately calls your callback for each existing selection.",
                "",
                " * `callback` {Function}",
                "   * `selection` {Selection} that was added",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "code": "  observeSelections (callback) {\r\n    this.getSelections().forEach(callback)\r\n    return this.onDidAddSelection(callback)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.onDidAddSelection",
            "start_line": 877,
            "end_line": 879,
            "comment": [
                " Extended: Calls your `callback` when a {Selection} is added to the editor.",
                "",
                " * `callback` {Function}",
                "   * `selection` {Selection} that was added",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "onDidAddSelection",
            "line": 868,
            "func_location": "TextEditor.observeSelections",
            "func_start_line": 866,
            "func_end_line": 869,
            "args": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "comment": [
                " Extended: Calls your `callback` when a {Selection} is added to the editor.",
                " Immediately calls your callback for each existing selection.",
                "",
                " * `callback` {Function}",
                "   * `selection` {Selection} that was added",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "code": "  observeSelections (callback) {\r\n    this.getSelections().forEach(callback)\r\n    return this.onDidAddSelection(callback)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.onDidAddSelection",
            "start_line": 877,
            "end_line": 879,
            "comment": [
                " Extended: Calls your `callback` when a {Selection} is added to the editor.",
                "",
                " * `callback` {Function}",
                "   * `selection` {Selection} that was added",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/style-manager.js",
            "name": "onDidAddStyleElement",
            "line": 54,
            "func_location": "StyleManager.observeStyleElements",
            "func_start_line": 49,
            "func_end_line": 55,
            "args": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "comment": [
                "\r\n  Section: Event Subscription\r\n  ",
                " Extended: Invoke `callback` for all current and future style elements.",
                "",
                " * `callback` {Function} that is called with style elements.",
                "   * `styleElement` An `HTMLStyleElement` instance. The `.sheet` property",
                "     will be null because this element isn't attached to the DOM. If you want",
                "     to attach this element to the DOM, be sure to clone it first by calling",
                "     `.cloneNode(true)` on it. The style element will also have the following",
                "     non-standard properties:",
                "     * `sourcePath` A {String} containing the path from which the style",
                "       element was loaded.",
                "     * `context` A {String} indicating the target context of the style",
                "       element.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to cancel the",
                " subscription."
            ],
            "code": "  observeStyleElements (callback) {\r\n    for (let styleElement of this.getStyleElements()) {\r\n      callback(styleElement)\r\n    }\r\n\r\n    return this.onDidAddStyleElement(callback)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/style-manager.js",
            "name": "StyleManager.onDidAddStyleElement",
            "start_line": 72,
            "end_line": 74,
            "comment": [
                " Extended: Invoke `callback` when a style element is added.",
                "",
                " * `callback` {Function} that is called with style elements.",
                "   * `styleElement` An `HTMLStyleElement` instance. The `.sheet` property",
                "     will be null because this element isn't attached to the DOM. If you want",
                "     to attach this element to the DOM, be sure to clone it first by calling",
                "     `.cloneNode(true)` on it. The style element will also have the following",
                "     non-standard properties:",
                "     * `sourcePath` A {String} containing the path from which the style",
                "       element was loaded.",
                "     * `context` A {String} indicating the target context of the style",
                "       element.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to cancel the",
                " subscription."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/style-manager.js",
            "name": "onDidAddStyleElement",
            "line": 54,
            "func_location": "StyleManager.observeStyleElements",
            "func_start_line": 49,
            "func_end_line": 55,
            "args": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "comment": [
                "\r\n  Section: Event Subscription\r\n  ",
                " Extended: Invoke `callback` for all current and future style elements.",
                "",
                " * `callback` {Function} that is called with style elements.",
                "   * `styleElement` An `HTMLStyleElement` instance. The `.sheet` property",
                "     will be null because this element isn't attached to the DOM. If you want",
                "     to attach this element to the DOM, be sure to clone it first by calling",
                "     `.cloneNode(true)` on it. The style element will also have the following",
                "     non-standard properties:",
                "     * `sourcePath` A {String} containing the path from which the style",
                "       element was loaded.",
                "     * `context` A {String} indicating the target context of the style",
                "       element.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to cancel the",
                " subscription."
            ],
            "code": "  observeStyleElements (callback) {\r\n    for (let styleElement of this.getStyleElements()) {\r\n      callback(styleElement)\r\n    }\r\n\r\n    return this.onDidAddStyleElement(callback)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/style-manager.js",
            "name": "StyleManager.onDidAddStyleElement",
            "start_line": 72,
            "end_line": 74,
            "comment": [
                " Extended: Invoke `callback` when a style element is added.",
                "",
                " * `callback` {Function} that is called with style elements.",
                "   * `styleElement` An `HTMLStyleElement` instance. The `.sheet` property",
                "     will be null because this element isn't attached to the DOM. If you want",
                "     to attach this element to the DOM, be sure to clone it first by calling",
                "     `.cloneNode(true)` on it. The style element will also have the following",
                "     non-standard properties:",
                "     * `sourcePath` A {String} containing the path from which the style",
                "       element was loaded.",
                "     * `context` A {String} indicating the target context of the style",
                "       element.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to cancel the",
                " subscription."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/workspace-center.js",
            "name": "onDidAddTextEditor",
            "line": 60,
            "func_location": "WorkspaceCenter.observeTextEditors",
            "func_start_line": 58,
            "func_end_line": 61,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Event Subscription\r\n  ",
                " Essential: Invoke the given callback with all current and future text",
                " editors in the workspace center.",
                "",
                " * `callback` {Function} to be called with current and future text editors.",
                "   * `editor` An {TextEditor} that is present in {::getTextEditors} at the time",
                "     of subscription or that is added at some later time.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "code": "  observeTextEditors (callback) {\r\n    for (let textEditor of this.getTextEditors()) { callback(textEditor) }\r\n    return this.onDidAddTextEditor(({textEditor}) => callback(textEditor))\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/workspace-center.js",
            "name": "WorkspaceCenter.onDidAddTextEditor",
            "start_line": 241,
            "end_line": 247,
            "comment": [
                " Extended: Invoke the given callback when a text editor is added to the",
                " workspace center.",
                "",
                " * `callback` {Function} to be called when panes are added.",
                "   * `event` {Object} with the following keys:",
                "     * `textEditor` {TextEditor} that was added.",
                "     * `pane` {Pane} containing the added text editor.",
                "     * `index` {Number} indicating the index of the added text editor in its",
                "        pane.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/workspace-center.js",
            "name": "onDidAddTextEditor",
            "line": 60,
            "func_location": "WorkspaceCenter.observeTextEditors",
            "func_start_line": 58,
            "func_end_line": 61,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Event Subscription\r\n  ",
                " Essential: Invoke the given callback with all current and future text",
                " editors in the workspace center.",
                "",
                " * `callback` {Function} to be called with current and future text editors.",
                "   * `editor` An {TextEditor} that is present in {::getTextEditors} at the time",
                "     of subscription or that is added at some later time.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "code": "  observeTextEditors (callback) {\r\n    for (let textEditor of this.getTextEditors()) { callback(textEditor) }\r\n    return this.onDidAddTextEditor(({textEditor}) => callback(textEditor))\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/workspace-center.js",
            "name": "WorkspaceCenter.onDidAddTextEditor",
            "start_line": 241,
            "end_line": 247,
            "comment": [
                " Extended: Invoke the given callback when a text editor is added to the",
                " workspace center.",
                "",
                " * `callback` {Function} to be called when panes are added.",
                "   * `event` {Object} with the following keys:",
                "     * `textEditor` {TextEditor} that was added.",
                "     * `pane` {Pane} containing the added text editor.",
                "     * `index` {Number} indicating the index of the added text editor in its",
                "        pane.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/dock.js",
            "name": "isVisible",
            "line": 455,
            "func_location": "Dock.observeVisible",
            "func_start_line": 454,
            "func_end_line": 457,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Essential: Invoke the given callback with the current and all future visibilities of the dock.",
                "",
                " * `callback` {Function} to be called when the visibility changes.",
                "   * `visible` {Boolean} Is the dock now visible?",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "code": "  observeVisible (callback) {\r\n    callback(this.isVisible())\r\n    return this.onDidChangeVisible(callback)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/dock.js",
            "name": "Dock.isVisible",
            "start_line": 140,
            "end_line": 142,
            "comment": [
                " Extended: Check if the dock is visible.",
                "",
                " Returns a {Boolean}."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/dock.js",
            "name": "onDidChangeVisible",
            "line": 456,
            "func_location": "Dock.observeVisible",
            "func_start_line": 454,
            "func_end_line": 457,
            "args": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "comment": [
                " Essential: Invoke the given callback with the current and all future visibilities of the dock.",
                "",
                " * `callback` {Function} to be called when the visibility changes.",
                "   * `visible` {Boolean} Is the dock now visible?",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "code": "  observeVisible (callback) {\r\n    callback(this.isVisible())\r\n    return this.onDidChangeVisible(callback)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/dock.js",
            "name": "Dock.onDidChangeVisible",
            "start_line": 444,
            "end_line": 446,
            "comment": [
                "\r\n  Section: Event Subscription\r\n  ",
                " Essential: Invoke the given callback when the visibility of the dock changes.",
                "",
                " * `callback` {Function} to be called when the visibility changes.",
                "   * `visible` {Boolean} Is the dock now visible?",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/dock.js",
            "name": "onDidChangeVisible",
            "line": 456,
            "func_location": "Dock.observeVisible",
            "func_start_line": 454,
            "func_end_line": 457,
            "args": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "comment": [
                " Essential: Invoke the given callback with the current and all future visibilities of the dock.",
                "",
                " * `callback` {Function} to be called when the visibility changes.",
                "   * `visible` {Boolean} Is the dock now visible?",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "code": "  observeVisible (callback) {\r\n    callback(this.isVisible())\r\n    return this.onDidChangeVisible(callback)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/dock.js",
            "name": "Dock.onDidChangeVisible",
            "start_line": 444,
            "end_line": 446,
            "comment": [
                "\r\n  Section: Event Subscription\r\n  ",
                " Essential: Invoke the given callback when the visibility of the dock changes.",
                "",
                " * `callback` {Function} to be called when the visibility changes.",
                "   * `visible` {Boolean} Is the dock now visible?",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/workspace-center.js",
            "name": "onDidAddPaneItem",
            "line": 242,
            "func_location": "WorkspaceCenter.onDidAddTextEditor",
            "func_start_line": 241,
            "func_end_line": 247
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/workspace-center.js",
            "name": "WorkspaceCenter.onDidAddPaneItem",
            "start_line": 197,
            "end_line": 199,
            "comment": [
                " Extended: Invoke the given callback when a pane item is added to the",
                " workspace center.",
                "",
                " * `callback` {Function} to be called when pane items are added.",
                "   * `event` {Object} with the following keys:",
                "     * `item` The added pane item.",
                "     * `pane` {Pane} containing the added item.",
                "     * `index` {Number} indicating the index of the added item in its pane.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "onDidChangeScopedKeyPath",
            "line": 520,
            "func_location": "Config.onDidChange",
            "func_start_line": 507,
            "func_end_line": 524,
            "args": [
                {
                    "name": "scopeDescriptor",
                    "type": []
                },
                {
                    "name": "keyPath",
                    "type": [
                        "string",
                        "optional"
                    ]
                },
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "comment": [
                " Essential: Add a listener for changes to a given key path. If `keyPath` is",
                " not specified, your callback will be called on changes to any key.",
                "",
                " * `keyPath` (optional) {String} name of the key to observe. Must be",
                "   specified if `scopeDescriptor` is specified.",
                " * `options` (optional) {Object}",
                "   * `scope` (optional) {ScopeDescriptor} describing a path from",
                "     the root of the syntax tree to a token. Get one by calling",
                "     {editor.getLastCursor().getScopeDescriptor()}. See {::get} for examples.",
                "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)",
                "     for more information.",
                " * `callback` {Function} to call when the value of the key changes.",
                "   * `event` {Object}",
                "     * `newValue` the new value of the key",
                "     * `oldValue` the prior value of the key.",
                "",
                " Returns a {Disposable} with the following keys on which you can call",
                " `.dispose()` to unsubscribe."
            ],
            "code": "  onDidChange (...args) {\r\n    let callback, keyPath, scopeDescriptor\r\n    if (args.length === 1) {\r\n      [callback] = args\r\n    } else if (args.length === 2) {\r\n      [keyPath, callback] = args\r\n    } else {\r\n      let options;\r\n      [keyPath, options, callback] = args\r\n      scopeDescriptor = options.scope\r\n    }\r\n\r\n    if (scopeDescriptor != null) {\r\n      return this.onDidChangeScopedKeyPath(scopeDescriptor, keyPath, callback)\r\n    } else {\r\n      return this.onDidChangeKeyPath(keyPath, callback)\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.onDidChangeScopedKeyPath",
            "start_line": 1269,
            "end_line": 1279,
            "comment": [],
            "params": [
                "scope",
                "keyPath",
                "callback"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "onDidChangeKeyPath",
            "line": 522,
            "func_location": "Config.onDidChange",
            "func_start_line": 507,
            "func_end_line": 524,
            "args": [
                {
                    "name": "keyPath",
                    "type": [
                        "string",
                        "optional"
                    ]
                },
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "comment": [
                " Essential: Add a listener for changes to a given key path. If `keyPath` is",
                " not specified, your callback will be called on changes to any key.",
                "",
                " * `keyPath` (optional) {String} name of the key to observe. Must be",
                "   specified if `scopeDescriptor` is specified.",
                " * `options` (optional) {Object}",
                "   * `scope` (optional) {ScopeDescriptor} describing a path from",
                "     the root of the syntax tree to a token. Get one by calling",
                "     {editor.getLastCursor().getScopeDescriptor()}. See {::get} for examples.",
                "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)",
                "     for more information.",
                " * `callback` {Function} to call when the value of the key changes.",
                "   * `event` {Object}",
                "     * `newValue` the new value of the key",
                "     * `oldValue` the prior value of the key.",
                "",
                " Returns a {Disposable} with the following keys on which you can call",
                " `.dispose()` to unsubscribe."
            ],
            "code": "  onDidChange (...args) {\r\n    let callback, keyPath, scopeDescriptor\r\n    if (args.length === 1) {\r\n      [callback] = args\r\n    } else if (args.length === 2) {\r\n      [keyPath, callback] = args\r\n    } else {\r\n      let options;\r\n      [keyPath, options, callback] = args\r\n      scopeDescriptor = options.scope\r\n    }\r\n\r\n    if (scopeDescriptor != null) {\r\n      return this.onDidChangeScopedKeyPath(scopeDescriptor, keyPath, callback)\r\n    } else {\r\n      return this.onDidChangeKeyPath(keyPath, callback)\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.onDidChangeKeyPath",
            "start_line": 1046,
            "end_line": 1056,
            "comment": [],
            "params": [
                "keyPath",
                "callback"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "getBuffer",
            "line": 781,
            "func_location": "TextEditor.onDidConflict",
            "func_start_line": 780,
            "func_end_line": 782,
            "args": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "comment": [
                " Extended: Calls your `callback` when the buffer's underlying file changes on",
                " disk at a moment when the result of {::isModified} is true.",
                "",
                " * `callback` {Function}",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "code": "  onDidConflict (callback) {\r\n    return this.getBuffer().onDidConflict(callback)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.getBuffer",
            "start_line": 963,
            "end_line": 963,
            "comment": [
                " Essential: Retrieves the current {TextBuffer}."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "onDidConflict",
            "line": 781,
            "func_location": "TextEditor.onDidConflict",
            "func_start_line": 780,
            "func_end_line": 782,
            "args": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "comment": [
                " Extended: Calls your `callback` when the buffer's underlying file changes on",
                " disk at a moment when the result of {::isModified} is true.",
                "",
                " * `callback` {Function}",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "code": "  onDidConflict (callback) {\r\n    return this.getBuffer().onDidConflict(callback)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.onDidConflict",
            "start_line": 780,
            "end_line": 782,
            "comment": [
                " Extended: Calls your `callback` when the buffer's underlying file changes on",
                " disk at a moment when the result of {::isModified} is true.",
                "",
                " * `callback` {Function}",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "onDidConflict",
            "line": 781,
            "func_location": "TextEditor.onDidConflict",
            "func_start_line": 780,
            "func_end_line": 782,
            "args": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "comment": [
                " Extended: Calls your `callback` when the buffer's underlying file changes on",
                " disk at a moment when the result of {::isModified} is true.",
                "",
                " * `callback` {Function}",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "code": "  onDidConflict (callback) {\r\n    return this.getBuffer().onDidConflict(callback)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.onDidConflict",
            "start_line": 780,
            "end_line": 782,
            "comment": [
                " Extended: Calls your `callback` when the buffer's underlying file changes on",
                " disk at a moment when the result of {::isModified} is true.",
                "",
                " * `callback` {Function}",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "getBuffer",
            "line": 815,
            "func_location": "TextEditor.onDidSave",
            "func_start_line": 814,
            "func_end_line": 816,
            "args": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "comment": [
                " Essential: Invoke the given callback after the buffer is saved to disk.",
                "",
                " * `callback` {Function} to be called after the buffer is saved.",
                "   * `event` {Object} with the following keys:",
                "     * `path` The path to which the buffer was saved.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "code": "  onDidSave (callback) {\r\n    return this.getBuffer().onDidSave(callback)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.getBuffer",
            "start_line": 963,
            "end_line": 963,
            "comment": [
                " Essential: Retrieves the current {TextBuffer}."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "onDidSave",
            "line": 815,
            "func_location": "TextEditor.onDidSave",
            "func_start_line": 814,
            "func_end_line": 816,
            "args": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "comment": [
                " Essential: Invoke the given callback after the buffer is saved to disk.",
                "",
                " * `callback` {Function} to be called after the buffer is saved.",
                "   * `event` {Object} with the following keys:",
                "     * `path` The path to which the buffer was saved.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "code": "  onDidSave (callback) {\r\n    return this.getBuffer().onDidSave(callback)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.onDidSave",
            "start_line": 814,
            "end_line": 816,
            "comment": [
                " Essential: Invoke the given callback after the buffer is saved to disk.",
                "",
                " * `callback` {Function} to be called after the buffer is saved.",
                "   * `event` {Object} with the following keys:",
                "     * `path` The path to which the buffer was saved.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "onDidSave",
            "line": 815,
            "func_location": "TextEditor.onDidSave",
            "func_start_line": 814,
            "func_end_line": 816,
            "args": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "comment": [
                " Essential: Invoke the given callback after the buffer is saved to disk.",
                "",
                " * `callback` {Function} to be called after the buffer is saved.",
                "   * `event` {Object} with the following keys:",
                "     * `path` The path to which the buffer was saved.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "code": "  onDidSave (callback) {\r\n    return this.getBuffer().onDidSave(callback)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.onDidSave",
            "start_line": 814,
            "end_line": 816,
            "comment": [
                " Essential: Invoke the given callback after the buffer is saved to disk.",
                "",
                " * `callback` {Function} to be called after the buffer is saved.",
                "   * `event` {Object} with the following keys:",
                "     * `path` The path to which the buffer was saved.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "getBuffer",
            "line": 686,
            "func_location": "TextEditor.onDidStopChanging",
            "func_start_line": 685,
            "func_end_line": 687,
            "args": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "comment": [
                " Essential: Invoke `callback` when the buffer's contents change. It is",
                " emit asynchronously 300ms after the last buffer change. This is a good place",
                " to handle changes to the buffer without compromising typing performance.",
                "",
                " * `callback` {Function}",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "code": "  onDidStopChanging (callback) {\r\n    return this.getBuffer().onDidStopChanging(callback)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.getBuffer",
            "start_line": 963,
            "end_line": 963,
            "comment": [
                " Essential: Retrieves the current {TextBuffer}."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "onDidStopChanging",
            "line": 686,
            "func_location": "TextEditor.onDidStopChanging",
            "func_start_line": 685,
            "func_end_line": 687,
            "args": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "comment": [
                " Essential: Invoke `callback` when the buffer's contents change. It is",
                " emit asynchronously 300ms after the last buffer change. This is a good place",
                " to handle changes to the buffer without compromising typing performance.",
                "",
                " * `callback` {Function}",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "code": "  onDidStopChanging (callback) {\r\n    return this.getBuffer().onDidStopChanging(callback)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.onDidStopChanging",
            "start_line": 685,
            "end_line": 687,
            "comment": [
                " Essential: Invoke `callback` when the buffer's contents change. It is",
                " emit asynchronously 300ms after the last buffer change. This is a good place",
                " to handle changes to the buffer without compromising typing performance.",
                "",
                " * `callback` {Function}",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "onDidStopChanging",
            "line": 686,
            "func_location": "TextEditor.onDidStopChanging",
            "func_start_line": 685,
            "func_end_line": 687,
            "args": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "comment": [
                " Essential: Invoke `callback` when the buffer's contents change. It is",
                " emit asynchronously 300ms after the last buffer change. This is a good place",
                " to handle changes to the buffer without compromising typing performance.",
                "",
                " * `callback` {Function}",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "code": "  onDidStopChanging (callback) {\r\n    return this.getBuffer().onDidStopChanging(callback)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.onDidStopChanging",
            "start_line": 685,
            "end_line": 687,
            "comment": [
                " Essential: Invoke `callback` when the buffer's contents change. It is",
                " emit asynchronously 300ms after the last buffer change. This is a good place",
                " to handle changes to the buffer without compromising typing performance.",
                "",
                " * `callback` {Function}",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/atom-application.js",
            "name": "replace",
            "line": 57,
            "func_location": "AtomApplication.open",
            "func_start_line": 34,
            "func_end_line": 85
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "Project.replace",
            "start_line": 82,
            "end_line": 99,
            "comment": [
                " Layers the contents of a project's file's config",
                " on top of the current global config."
            ],
            "params": [
                {
                    "name": "projectSpecification",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/atom-application.js",
            "name": "replace",
            "line": 58,
            "func_location": "AtomApplication.open",
            "func_start_line": 34,
            "func_end_line": 85
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "Project.replace",
            "start_line": 82,
            "end_line": 99,
            "comment": [
                " Layers the contents of a project's file's config",
                " on top of the current global config."
            ],
            "params": [
                {
                    "name": "projectSpecification",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/atom-application.js",
            "name": "constructor",
            "line": 73,
            "func_location": "AtomApplication.open",
            "func_start_line": 34,
            "func_end_line": 85,
            "args": [
                {
                    "name": "options",
                    "type": []
                }
            ],
            "comment": [
                " Public: The entry point into the Atom application."
            ],
            "code": "  static open (options) {\r\n    if (!options.socketPath) {\r\n      const {username} = os.userInfo()\r\n\r\n      // Lowercasing the ATOM_HOME to make sure that we don't get multiple sockets\r\n      // on case-insensitive filesystems due to arbitrary case differences in paths.\r\n      const atomHomeUnique = path.resolve(process.env.ATOM_HOME).toLowerCase()\r\n      const hash = crypto\r\n        .createHash('sha1')\r\n        .update(options.version)\r\n        .update('|')\r\n        .update(process.arch)\r\n        .update('|')\r\n        .update(username || '')\r\n        .update('|')\r\n        .update(atomHomeUnique)\r\n\r\n      // We only keep the first 12 characters of the hash as not to have excessively long\r\n      // socket file. Note that macOS/BSD limit the length of socket file paths (see #15081).\r\n      // The replace calls convert the digest into \"URL and Filename Safe\" encoding (see RFC 4648).\r\n      const atomInstanceDigest = hash\r\n        .digest('base64')\r\n        .substring(0, 12)\r\n        .replace(/\\+/g, '-')\r\n        .replace(/\\//g, '_')\r\n\r\n      if (process.platform === 'win32') {\r\n        options.socketPath = `\\\\\\\\.\\\\pipe\\\\atom-${atomInstanceDigest}-sock`\r\n      } else {\r\n        options.socketPath = path.join(os.tmpdir(), `atom-${atomInstanceDigest}.sock`)\r\n      }\r\n    }\r\n\r\n    // FIXME: Sometimes when socketPath doesn't exist, net.connect would strangely\r\n    // take a few seconds to trigger 'error' event, it could be a bug of node\r\n    // or electron, before it's fixed we check the existence of socketPath to\r\n    // speedup startup.\r\n    if ((process.platform !== 'win32' && !fs.existsSync(options.socketPath)) ||\r\n        options.test || options.benchmark || options.benchmarkTest) {\r\n      new AtomApplication(options).initialize(options)\r\n      return\r\n    }\r\n\r\n    const client = net.connect({path: options.socketPath}, () => {\r\n      client.write(JSON.stringify(options), () => {\r\n        client.end()\r\n        app.quit()\r\n      })\r\n    })\r\n\r\n    client.on('error', () => new AtomApplication(options).initialize(options))\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/atom-application.js",
            "name": "AtomApplication.constructor",
            "start_line": 91,
            "end_line": 136,
            "comment": [],
            "params": [
                "options"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/core-uri-handlers.js",
            "name": "getLineColNumber",
            "line": 12,
            "func_location": "openFile",
            "func_start_line": 8,
            "func_end_line": 16,
            "args": [
                "line"
            ],
            "code": "function openFile (atom, {query}) {\r\n  const {filename, line, column} = query\r\n\r\n  atom.workspace.open(filename, {\r\n    initialLine: getLineColNumber(line),\r\n    initialColumn: getLineColNumber(column),\r\n    searchAllPanes: true\r\n  })\r\n}\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/core-uri-handlers.js",
            "name": "getLineColNumber",
            "start_line": 3,
            "end_line": 6,
            "comment": [
                " Converts a query string parameter for a line or column number",
                " to a zero-based line or column number for the Atom API."
            ],
            "params": [
                {
                    "name": "numStr",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/core-uri-handlers.js",
            "name": "getLineColNumber",
            "line": 13,
            "func_location": "openFile",
            "func_start_line": 8,
            "func_end_line": 16,
            "args": [
                "column"
            ],
            "code": "function openFile (atom, {query}) {\r\n  const {filename, line, column} = query\r\n\r\n  atom.workspace.open(filename, {\r\n    initialLine: getLineColNumber(line),\r\n    initialColumn: getLineColNumber(column),\r\n    searchAllPanes: true\r\n  })\r\n}\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/core-uri-handlers.js",
            "name": "getLineColNumber",
            "start_line": 3,
            "end_line": 6,
            "comment": [
                " Converts a query string parameter for a line or column number",
                " to a zero-based line or column number for the Atom API."
            ],
            "params": [
                {
                    "name": "numStr",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selectors.js",
            "name": "replace",
            "line": 12,
            "func_location": "parse",
            "func_start_line": 10,
            "func_end_line": 14,
            "args": [
                {
                    "name": {
                        "type": "string"
                    },
                    "type": []
                }
            ],
            "comment": [
                " Private: Parse a selector into parts.",
                "          If already parsed, returns the selector unmodified.",
                "",
                " * `selector` a {String|Array<String>} specifying what to match",
                " Returns selector parts, an {Array<String>}."
            ],
            "code": "function parse (selector) {\r\n  return typeof selector === 'string'\r\n    ? selector.replace(/^\\./, '').split('.')\r\n    : selector\r\n}\r",
            "return_type": [
                "string",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "Project.replace",
            "start_line": 82,
            "end_line": 99,
            "comment": [
                " Layers the contents of a project's file's config",
                " on top of the current global config."
            ],
            "params": [
                {
                    "name": "projectSpecification",
                    "type": []
                }
            ],
            "return_type": [
                "string",
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selectors.js",
            "name": "replace",
            "line": 12,
            "func_location": "parse",
            "func_start_line": 10,
            "func_end_line": 14,
            "args": [
                {
                    "name": {
                        "type": "string"
                    },
                    "type": []
                }
            ],
            "comment": [
                " Private: Parse a selector into parts.",
                "          If already parsed, returns the selector unmodified.",
                "",
                " * `selector` a {String|Array<String>} specifying what to match",
                " Returns selector parts, an {Array<String>}."
            ],
            "code": "function parse (selector) {\r\n  return typeof selector === 'string'\r\n    ? selector.replace(/^\\./, '').split('.')\r\n    : selector\r\n}\r",
            "return_type": [
                "string",
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "Project.replace",
            "start_line": 82,
            "end_line": 99,
            "comment": [
                " Layers the contents of a project's file's config",
                " on top of the current global config."
            ],
            "params": [
                {
                    "name": "projectSpecification",
                    "type": []
                }
            ],
            "return_type": [
                "string",
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/parse-command-line.js",
            "name": "write",
            "line": 78,
            "func_location": "parseCommandLine",
            "func_start_line": 7,
            "func_end_line": 127
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/clipboard.js",
            "name": "Clipboard.write",
            "start_line": 42,
            "end_line": 46,
            "comment": [
                " Public: Write the given text to the clipboard.",
                "",
                " The metadata associated with the text is available by calling",
                " {::readWithMetadata}.",
                "",
                " * `text` The {String} to store.",
                " * `metadata` (optional) The additional info to associate with the text."
            ],
            "params": [
                {
                    "name": "text",
                    "type": [
                        "string",
                        "optional"
                    ]
                },
                {
                    "name": "metadata",
                    "type": [
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/parse-command-line.js",
            "name": "write",
            "line": 83,
            "func_location": "parseCommandLine",
            "func_start_line": 7,
            "func_end_line": 127
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/clipboard.js",
            "name": "Clipboard.write",
            "start_line": 42,
            "end_line": 46,
            "comment": [
                " Public: Write the given text to the clipboard.",
                "",
                " The metadata associated with the text is available by calling",
                " {::readWithMetadata}.",
                "",
                " * `text` The {String} to store.",
                " * `metadata` (optional) The additional info to associate with the text."
            ],
            "params": [
                {
                    "name": "text",
                    "type": [
                        "string",
                        "optional"
                    ]
                },
                {
                    "name": "metadata",
                    "type": [
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "remove",
            "line": 4182,
            "func_location": "HighlightComponent.performFlash",
            "func_start_line": 4172,
            "func_end_line": 4190,
            "args": [
                "flashClass"
            ],
            "code": "  performFlash () {\r\n    const {flashClass, flashDuration} = this.props\r\n    if (!this.timeoutsByClassName) this.timeoutsByClassName = new Map()\r\n\r\n    // If a flash of this class is already in progress, clear it early and\r\n    // flash again on the next frame to ensure CSS transitions apply to the\r\n    // second flash.\r\n    if (this.timeoutsByClassName.has(flashClass)) {\r\n      window.clearTimeout(this.timeoutsByClassName.get(flashClass))\r\n      this.timeoutsByClassName.delete(flashClass)\r\n      this.element.classList.remove(flashClass)\r\n      requestAnimationFrame(() => this.performFlash())\r\n    } else {\r\n      this.element.classList.add(flashClass)\r\n      this.timeoutsByClassName.set(flashClass, window.setTimeout(() => {\r\n        this.element.classList.remove(flashClass)\r\n      }, flashDuration))\r\n    }\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean",
                "object"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-element.js",
            "name": "getComponent",
            "line": 231,
            "func_location": "TextEditorElement.pixelPositionForBufferPosition",
            "func_start_line": 229,
            "func_end_line": 232,
            "args": [
                {
                    "name": "screenPosition",
                    "type": []
                }
            ],
            "comment": [
                " Extended: Converts a buffer position to a pixel position.",
                "",
                " * `bufferPosition` A {Point}-like object that represents a buffer position.",
                "",
                " Be aware that calling this method with a column that does not translate",
                " to column 0 on screen could cause a synchronous DOM update in order to",
                " measure the requested horizontal pixel position if it isn't already",
                " cached.",
                "",
                " Returns an {Object} with two values: `top` and `left`, representing the",
                " pixel position."
            ],
            "code": "  pixelPositionForBufferPosition (bufferPosition) {\r\n    const screenPosition = this.getModel().screenPositionForBufferPosition(bufferPosition)\r\n    return this.getComponent().pixelPositionForScreenPosition(screenPosition)\r\n  }\r",
            "return_type": [
                "boolean",
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-element.js",
            "name": "TextEditorElement.getComponent",
            "start_line": 276,
            "end_line": 288,
            "comment": [],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-element.js",
            "name": "getModel",
            "line": 245,
            "func_location": "TextEditorElement.pixelPositionForScreenPosition",
            "func_start_line": 244,
            "func_end_line": 247,
            "args": [
                {
                    "name": "screenPosition",
                    "type": [
                        "object"
                    ]
                }
            ],
            "comment": [
                " Extended: Converts a screen position to a pixel position.",
                "",
                " * `screenPosition` A {Point}-like object that represents a buffer position.",
                "",
                " Be aware that calling this method with a non-zero column value could",
                " cause a synchronous DOM update in order to measure the requested",
                " horizontal pixel position if it isn't already cached.",
                "",
                " Returns an {Object} with two values: `top` and `left`, representing the",
                " pixel position."
            ],
            "code": "  pixelPositionForScreenPosition (screenPosition) {\r\n    screenPosition = this.getModel().clipScreenPosition(screenPosition)\r\n    return this.getComponent().pixelPositionForScreenPosition(screenPosition)\r\n  }\r",
            "return_type": [
                "boolean",
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-element.js",
            "name": "TextEditorElement.getModel",
            "start_line": 80,
            "end_line": 82,
            "comment": [],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-element.js",
            "name": "getComponent",
            "line": 246,
            "func_location": "TextEditorElement.pixelPositionForScreenPosition",
            "func_start_line": 244,
            "func_end_line": 247,
            "args": [
                {
                    "name": "screenPosition",
                    "type": [
                        "object"
                    ]
                }
            ],
            "comment": [
                " Extended: Converts a screen position to a pixel position.",
                "",
                " * `screenPosition` A {Point}-like object that represents a buffer position.",
                "",
                " Be aware that calling this method with a non-zero column value could",
                " cause a synchronous DOM update in order to measure the requested",
                " horizontal pixel position if it isn't already cached.",
                "",
                " Returns an {Object} with two values: `top` and `left`, representing the",
                " pixel position."
            ],
            "code": "  pixelPositionForScreenPosition (screenPosition) {\r\n    screenPosition = this.getModel().clipScreenPosition(screenPosition)\r\n    return this.getComponent().pixelPositionForScreenPosition(screenPosition)\r\n  }\r",
            "return_type": [
                "boolean",
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-element.js",
            "name": "TextEditorElement.getComponent",
            "start_line": 276,
            "end_line": 288,
            "comment": [],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/dock.js",
            "name": "rectContainsPoint",
            "line": 372,
            "func_location": "Dock.pointWithinHoverArea",
            "func_start_line": 333,
            "func_end_line": 405,
            "args": [
                {
                    "name": "bounds",
                    "type": []
                },
                {
                    "name": "point",
                    "type": []
                }
            ],
            "comment": [
                " Determine whether the cursor is within the dock hover area. This isn't as simple as just using",
                " mouseenter/leave because we want to be a little more forgiving. For example, if the cursor is",
                " over the footer, we want to show the bottom dock's toggle button. Also note that our criteria",
                " for detecting entry are different than detecting exit but, in order for us to avoid jitter, the",
                " area considered when detecting exit MUST fully encompass the area considered when detecting",
                " entry."
            ],
            "code": "  pointWithinHoverArea (point, detectingExit) {\r\n    const dockBounds = this.refs.innerElement.getBoundingClientRect()\r\n\r\n    // Copy the bounds object since we can't mutate it.\r\n    const bounds = {\r\n      top: dockBounds.top,\r\n      right: dockBounds.right,\r\n      bottom: dockBounds.bottom,\r\n      left: dockBounds.left\r\n    }\r\n\r\n    // To provide a minimum target, expand the area toward the center a bit.\r\n    switch (this.location) {\r\n      case 'right':\r\n        bounds.left = Math.min(bounds.left, bounds.right - 2)\r\n        break\r\n      case 'bottom':\r\n        bounds.top = Math.min(bounds.top, bounds.bottom - 1)\r\n        break\r\n      case 'left':\r\n        bounds.right = Math.max(bounds.right, bounds.left + 2)\r\n        break\r\n    }\r\n\r\n    // Further expand the area to include all panels that are closer to the edge than the dock.\r\n    switch (this.location) {\r\n      case 'right':\r\n        bounds.right = Number.POSITIVE_INFINITY\r\n        break\r\n      case 'bottom':\r\n        bounds.bottom = Number.POSITIVE_INFINITY\r\n        break\r\n      case 'left':\r\n        bounds.left = Number.NEGATIVE_INFINITY\r\n        break\r\n    }\r\n\r\n    // If we're in this area, we know we're within the hover area without having to take further\r\n    // measurements.\r\n    if (rectContainsPoint(bounds, point)) return true\r\n\r\n    // If we're within the toggle button, we're definitely in the hover area. Unfortunately, we\r\n    // can't do this measurement conditionally (e.g. only if the toggle button is visible) because\r\n    // our knowledge of the toggle's button is incomplete due to CSS animations. (We may think the\r\n    // toggle button isn't visible when in actuality it is, but is animating to its hidden state.)\r\n    //\r\n    // Since `point` is always the current mouse position, one possible optimization would be to\r\n    // remove it as an argument and determine whether we're inside the toggle button using\r\n    // mouseenter/leave events on it. This class would still need to keep track of the mouse\r\n    // position (via a mousemove listener) for the other measurements, though.\r\n    const toggleButtonBounds = this.refs.toggleButton.getBounds()\r\n    if (rectContainsPoint(toggleButtonBounds, point)) return true\r\n\r\n    // The area used when detecting exit is actually larger than when detecting entrances. Expand\r\n    // our bounds and recheck them.\r\n    if (detectingExit) {\r\n      const hoverMargin = 20\r\n      switch (this.location) {\r\n        case 'right':\r\n          bounds.left = Math.min(bounds.left, toggleButtonBounds.left) - hoverMargin\r\n          break\r\n        case 'bottom':\r\n          bounds.top = Math.min(bounds.top, toggleButtonBounds.top) - hoverMargin\r\n          break\r\n        case 'left':\r\n          bounds.right = Math.max(bounds.right, toggleButtonBounds.right) + hoverMargin\r\n          break\r\n      }\r\n      if (rectContainsPoint(bounds, point)) return true\r\n    }\r\n\r\n    return false\r\n  }\r",
            "return_type": [
                "boolean",
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/dock.js",
            "name": "rectContainsPoint",
            "start_line": 848,
            "end_line": 855,
            "comment": [],
            "params": [
                "rect",
                "point"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/dock.js",
            "name": "rectContainsPoint",
            "line": 384,
            "func_location": "Dock.pointWithinHoverArea",
            "func_start_line": 333,
            "func_end_line": 405,
            "args": [
                {
                    "name": "toggleButtonBounds",
                    "type": []
                },
                {
                    "name": "point",
                    "type": []
                }
            ],
            "comment": [
                " Determine whether the cursor is within the dock hover area. This isn't as simple as just using",
                " mouseenter/leave because we want to be a little more forgiving. For example, if the cursor is",
                " over the footer, we want to show the bottom dock's toggle button. Also note that our criteria",
                " for detecting entry are different than detecting exit but, in order for us to avoid jitter, the",
                " area considered when detecting exit MUST fully encompass the area considered when detecting",
                " entry."
            ],
            "code": "  pointWithinHoverArea (point, detectingExit) {\r\n    const dockBounds = this.refs.innerElement.getBoundingClientRect()\r\n\r\n    // Copy the bounds object since we can't mutate it.\r\n    const bounds = {\r\n      top: dockBounds.top,\r\n      right: dockBounds.right,\r\n      bottom: dockBounds.bottom,\r\n      left: dockBounds.left\r\n    }\r\n\r\n    // To provide a minimum target, expand the area toward the center a bit.\r\n    switch (this.location) {\r\n      case 'right':\r\n        bounds.left = Math.min(bounds.left, bounds.right - 2)\r\n        break\r\n      case 'bottom':\r\n        bounds.top = Math.min(bounds.top, bounds.bottom - 1)\r\n        break\r\n      case 'left':\r\n        bounds.right = Math.max(bounds.right, bounds.left + 2)\r\n        break\r\n    }\r\n\r\n    // Further expand the area to include all panels that are closer to the edge than the dock.\r\n    switch (this.location) {\r\n      case 'right':\r\n        bounds.right = Number.POSITIVE_INFINITY\r\n        break\r\n      case 'bottom':\r\n        bounds.bottom = Number.POSITIVE_INFINITY\r\n        break\r\n      case 'left':\r\n        bounds.left = Number.NEGATIVE_INFINITY\r\n        break\r\n    }\r\n\r\n    // If we're in this area, we know we're within the hover area without having to take further\r\n    // measurements.\r\n    if (rectContainsPoint(bounds, point)) return true\r\n\r\n    // If we're within the toggle button, we're definitely in the hover area. Unfortunately, we\r\n    // can't do this measurement conditionally (e.g. only if the toggle button is visible) because\r\n    // our knowledge of the toggle's button is incomplete due to CSS animations. (We may think the\r\n    // toggle button isn't visible when in actuality it is, but is animating to its hidden state.)\r\n    //\r\n    // Since `point` is always the current mouse position, one possible optimization would be to\r\n    // remove it as an argument and determine whether we're inside the toggle button using\r\n    // mouseenter/leave events on it. This class would still need to keep track of the mouse\r\n    // position (via a mousemove listener) for the other measurements, though.\r\n    const toggleButtonBounds = this.refs.toggleButton.getBounds()\r\n    if (rectContainsPoint(toggleButtonBounds, point)) return true\r\n\r\n    // The area used when detecting exit is actually larger than when detecting entrances. Expand\r\n    // our bounds and recheck them.\r\n    if (detectingExit) {\r\n      const hoverMargin = 20\r\n      switch (this.location) {\r\n        case 'right':\r\n          bounds.left = Math.min(bounds.left, toggleButtonBounds.left) - hoverMargin\r\n          break\r\n        case 'bottom':\r\n          bounds.top = Math.min(bounds.top, toggleButtonBounds.top) - hoverMargin\r\n          break\r\n        case 'left':\r\n          bounds.right = Math.max(bounds.right, toggleButtonBounds.right) + hoverMargin\r\n          break\r\n      }\r\n      if (rectContainsPoint(bounds, point)) return true\r\n    }\r\n\r\n    return false\r\n  }\r",
            "return_type": [
                "boolean",
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/dock.js",
            "name": "rectContainsPoint",
            "start_line": 848,
            "end_line": 855,
            "comment": [],
            "params": [
                "rect",
                "point"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/dock.js",
            "name": "rectContainsPoint",
            "line": 401,
            "func_location": "Dock.pointWithinHoverArea",
            "func_start_line": 333,
            "func_end_line": 405,
            "args": [
                {
                    "name": "bounds",
                    "type": []
                },
                {
                    "name": "point",
                    "type": []
                }
            ],
            "comment": [
                " Determine whether the cursor is within the dock hover area. This isn't as simple as just using",
                " mouseenter/leave because we want to be a little more forgiving. For example, if the cursor is",
                " over the footer, we want to show the bottom dock's toggle button. Also note that our criteria",
                " for detecting entry are different than detecting exit but, in order for us to avoid jitter, the",
                " area considered when detecting exit MUST fully encompass the area considered when detecting",
                " entry."
            ],
            "code": "  pointWithinHoverArea (point, detectingExit) {\r\n    const dockBounds = this.refs.innerElement.getBoundingClientRect()\r\n\r\n    // Copy the bounds object since we can't mutate it.\r\n    const bounds = {\r\n      top: dockBounds.top,\r\n      right: dockBounds.right,\r\n      bottom: dockBounds.bottom,\r\n      left: dockBounds.left\r\n    }\r\n\r\n    // To provide a minimum target, expand the area toward the center a bit.\r\n    switch (this.location) {\r\n      case 'right':\r\n        bounds.left = Math.min(bounds.left, bounds.right - 2)\r\n        break\r\n      case 'bottom':\r\n        bounds.top = Math.min(bounds.top, bounds.bottom - 1)\r\n        break\r\n      case 'left':\r\n        bounds.right = Math.max(bounds.right, bounds.left + 2)\r\n        break\r\n    }\r\n\r\n    // Further expand the area to include all panels that are closer to the edge than the dock.\r\n    switch (this.location) {\r\n      case 'right':\r\n        bounds.right = Number.POSITIVE_INFINITY\r\n        break\r\n      case 'bottom':\r\n        bounds.bottom = Number.POSITIVE_INFINITY\r\n        break\r\n      case 'left':\r\n        bounds.left = Number.NEGATIVE_INFINITY\r\n        break\r\n    }\r\n\r\n    // If we're in this area, we know we're within the hover area without having to take further\r\n    // measurements.\r\n    if (rectContainsPoint(bounds, point)) return true\r\n\r\n    // If we're within the toggle button, we're definitely in the hover area. Unfortunately, we\r\n    // can't do this measurement conditionally (e.g. only if the toggle button is visible) because\r\n    // our knowledge of the toggle's button is incomplete due to CSS animations. (We may think the\r\n    // toggle button isn't visible when in actuality it is, but is animating to its hidden state.)\r\n    //\r\n    // Since `point` is always the current mouse position, one possible optimization would be to\r\n    // remove it as an argument and determine whether we're inside the toggle button using\r\n    // mouseenter/leave events on it. This class would still need to keep track of the mouse\r\n    // position (via a mousemove listener) for the other measurements, though.\r\n    const toggleButtonBounds = this.refs.toggleButton.getBounds()\r\n    if (rectContainsPoint(toggleButtonBounds, point)) return true\r\n\r\n    // The area used when detecting exit is actually larger than when detecting entrances. Expand\r\n    // our bounds and recheck them.\r\n    if (detectingExit) {\r\n      const hoverMargin = 20\r\n      switch (this.location) {\r\n        case 'right':\r\n          bounds.left = Math.min(bounds.left, toggleButtonBounds.left) - hoverMargin\r\n          break\r\n        case 'bottom':\r\n          bounds.top = Math.min(bounds.top, toggleButtonBounds.top) - hoverMargin\r\n          break\r\n        case 'left':\r\n          bounds.right = Math.max(bounds.right, toggleButtonBounds.right) + hoverMargin\r\n          break\r\n      }\r\n      if (rectContainsPoint(bounds, point)) return true\r\n    }\r\n\r\n    return false\r\n  }\r",
            "return_type": [
                "boolean",
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/dock.js",
            "name": "rectContainsPoint",
            "start_line": 848,
            "end_line": 855,
            "comment": [],
            "params": [
                "rect",
                "point"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/window.js",
            "name": "measure",
            "line": 24,
            "func_location": "window.profile",
            "func_start_line": 23,
            "func_end_line": 30
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/window.js",
            "name": "window.measure",
            "start_line": 8,
            "end_line": 14,
            "comment": [
                " Public: Measure how long a function takes to run.",
                "",
                " description - A {String} description that will be logged to the console when",
                "               the function completes.",
                " fn - A {Function} to measure the duration of.",
                "",
                " Returns the value returned by the given function."
            ],
            "params": [
                {
                    "name": "description",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "fn",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": [
                "function"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/protocol-handler-installer.js",
            "name": "addInfo",
            "line": 72,
            "func_location": "ProtocolHandlerInstaller.promptToBecomeProtocolClient",
            "func_start_line": 54,
            "func_end_line": 100
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/notification-manager.js",
            "name": "NotificationManager.addInfo",
            "start_line": 95,
            "end_line": 97,
            "comment": [
                " Public: Add an informational notification.",
                "",
                " * `message` A {String} message",
                " * `options` (optional) An options {Object} with the following keys:",
                "    * `buttons` (optional) An {Array} of {Object} where each {Object} has",
                "      the following options:",
                "      * `className` (optional) {String} a class name to add to the button's",
                "        default class name (`btn btn-info`).",
                "      * `onDidClick` (optional) {Function} callback to call when the button",
                "        has been clicked. The context will be set to the",
                "        {NotificationElement} instance.",
                "      * `text` {String} inner text for the button",
                "    * `description` (optional) A Markdown {String} containing a longer",
                "      description about the notification. By default, this **will not**",
                "      preserve newlines and whitespace when it is rendered.",
                "    * `detail` (optional) A plain-text {String} containing additional",
                "      details about the notification. By default, this **will** preserve",
                "      newlines and whitespace when it is rendered.",
                "    * `dismissable` (optional) A {Boolean} indicating whether this",
                "      notification can be dismissed by the user. Defaults to `false`.",
                "    * `icon` (optional) A {String} name of an icon from Octicons to display",
                "      in the notification header. Defaults to `'info'`.",
                "",
                " Returns the {Notification} that was added."
            ],
            "params": [
                {
                    "name": "message",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "set",
            "line": 875,
            "func_location": "Config.pushAtKeyPath",
            "func_start_line": 871,
            "func_end_line": 877,
            "args": [
                "keyPath",
                "arrayValue"
            ],
            "code": "  pushAtKeyPath (keyPath, value) {\r\n    const left = this.get(keyPath)\r\n    const arrayValue = (left == null ? [] : left)\r\n    const result = arrayValue.push(value)\r\n    this.set(keyPath, arrayValue)\r\n    return result\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.set",
            "start_line": 687,
            "end_line": 722,
            "comment": [
                " Essential: Sets the value for a configuration setting.",
                "",
                " This value is stored in Atom's internal configuration file.",
                "",
                " ### Examples",
                "",
                " You might want to change the themes programmatically:",
                "",
                " ```coffee",
                " atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])",
                " ```",
                "",
                " You can also set scoped settings. For example, you might want change the",
                " `editor.tabLength` only for ruby files.",
                "",
                " ```coffee",
                " atom.config.get('editor.tabLength') # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",
                "",
                " # Set ruby to 2",
                " atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true",
                "",
                " # Notice it's only set to 2 in the case of ruby",
                " atom.config.get('editor.tabLength') # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2",
                " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",
                " ```",
                "",
                " * `keyPath` The {String} name of the key.",
                " * `value` The value of the setting. Passing `undefined` will revert the",
                "   setting to the default value.",
                " * `options` (optional) {Object}",
                "   * `scopeSelector` (optional) {String}. eg. '.source.ruby'",
                "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)",
                "     for more information.",
                "   * `source` (optional) {String} The name of a file with which the setting",
                "     is associated. Defaults to the user's config file.",
                "",
                " Returns a {Boolean}",
                " * `true` if the value was set.",
                " * `false` if the value was not able to be coerced to the type specified in the setting's schema."
            ],
            "params": [
                {
                    "name": "args",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/clipboard.js",
            "name": "md5",
            "line": 63,
            "func_location": "Clipboard.readWithMetadata",
            "func_start_line": 61,
            "func_end_line": 68,
            "args": [
                {
                    "name": "text",
                    "type": [
                        "string"
                    ]
                }
            ],
            "comment": [
                " Public: Read the text from the clipboard and return both the text and the",
                " associated metadata.",
                "",
                " Returns an {Object} with the following keys:",
                " * `text` The {String} clipboard text.",
                " * `metadata` The metadata stored by an earlier call to {::write}."
            ],
            "code": "  readWithMetadata () {\r\n    const text = this.read()\r\n    if (this.signatureForMetadata === this.md5(text)) {\r\n      return {text, metadata: this.metadata}\r\n    } else {\r\n      return {text}\r\n    }\r\n  }\r",
            "return_type": [
                "string",
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/clipboard.js",
            "name": "Clipboard.md5",
            "start_line": 31,
            "end_line": 33,
            "comment": [
                " Creates an `md5` hash of some text.",
                "",
                " * `text` A {String} to hash.",
                "",
                " Returns a hashed {String}."
            ],
            "params": [
                {
                    "name": "text",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "string",
                "object"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/clipboard.js",
            "name": "md5",
            "line": 63,
            "func_location": "Clipboard.readWithMetadata",
            "func_start_line": 61,
            "func_end_line": 68,
            "args": [
                {
                    "name": "text",
                    "type": [
                        "string"
                    ]
                }
            ],
            "comment": [
                " Public: Read the text from the clipboard and return both the text and the",
                " associated metadata.",
                "",
                " Returns an {Object} with the following keys:",
                " * `text` The {String} clipboard text.",
                " * `metadata` The metadata stored by an earlier call to {::write}."
            ],
            "code": "  readWithMetadata () {\r\n    const text = this.read()\r\n    if (this.signatureForMetadata === this.md5(text)) {\r\n      return {text, metadata: this.metadata}\r\n    } else {\r\n      return {text}\r\n    }\r\n  }\r",
            "return_type": [
                "string",
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/clipboard.js",
            "name": "Clipboard.md5",
            "start_line": 31,
            "end_line": 33,
            "comment": [
                " Creates an `md5` hash of some text.",
                "",
                " * `text` A {String} to hash.",
                "",
                " Returns a hashed {String}."
            ],
            "params": [
                {
                    "name": "text",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "string",
                "object"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/tooltip.js",
            "name": "replace",
            "line": 524,
            "func_location": "Tooltip.prototype.recalculatePosition",
            "func_start_line": 515,
            "func_end_line": 548,
            "args": [
                "autoToken",
                {
                    "type": "string"
                }
            ],
            "code": "Tooltip.prototype.recalculatePosition = function () {\r\n  var tip = this.getTooltipElement()\r\n\r\n  var placement = typeof this.options.placement === 'function'\r\n    ? this.options.placement.call(this, tip, this.element)\r\n    : this.options.placement\r\n\r\n  var autoToken = /\\s?auto?\\s?/i\r\n  var autoPlace = autoToken.test(placement)\r\n  if (autoPlace) placement = placement.replace(autoToken, '') || 'top'\r\n\r\n  tip.classList.add(placement)\r\n\r\n  var pos = this.element.getBoundingClientRect()\r\n  var actualWidth = tip.offsetWidth\r\n  var actualHeight = tip.offsetHeight\r\n\r\n  if (autoPlace) {\r\n    var orgPlacement = placement\r\n    var viewportDim = this.viewport.getBoundingClientRect()\r\n\r\n    placement = placement === 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top'\r\n              : placement === 'top' && pos.top - actualHeight < viewportDim.top ? 'bottom'\r\n              : placement === 'right' && pos.right + actualWidth > viewportDim.width ? 'left'\r\n              : placement === 'left' && pos.left - actualWidth < viewportDim.left ? 'right'\r\n              : placement\r\n\r\n    tip.classList.remove(orgPlacement)\r\n    tip.classList.add(placement)\r\n  }\r\n\r\n  var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)\r\n  this.applyPlacement(calculatedOffset, placement)\r\n}\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "Project.replace",
            "start_line": 82,
            "end_line": 99,
            "comment": [
                " Layers the contents of a project's file's config",
                " on top of the current global config."
            ],
            "params": [
                {
                    "name": "projectSpecification",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/tooltip.js",
            "name": "remove",
            "line": 542,
            "func_location": "Tooltip.prototype.recalculatePosition",
            "func_start_line": 515,
            "func_end_line": 548,
            "args": [
                "orgPlacement"
            ],
            "code": "Tooltip.prototype.recalculatePosition = function () {\r\n  var tip = this.getTooltipElement()\r\n\r\n  var placement = typeof this.options.placement === 'function'\r\n    ? this.options.placement.call(this, tip, this.element)\r\n    : this.options.placement\r\n\r\n  var autoToken = /\\s?auto?\\s?/i\r\n  var autoPlace = autoToken.test(placement)\r\n  if (autoPlace) placement = placement.replace(autoToken, '') || 'top'\r\n\r\n  tip.classList.add(placement)\r\n\r\n  var pos = this.element.getBoundingClientRect()\r\n  var actualWidth = tip.offsetWidth\r\n  var actualHeight = tip.offsetHeight\r\n\r\n  if (autoPlace) {\r\n    var orgPlacement = placement\r\n    var viewportDim = this.viewport.getBoundingClientRect()\r\n\r\n    placement = placement === 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top'\r\n              : placement === 'top' && pos.top - actualHeight < viewportDim.top ? 'bottom'\r\n              : placement === 'right' && pos.right + actualWidth > viewportDim.width ? 'left'\r\n              : placement === 'left' && pos.left - actualWidth < viewportDim.left ? 'right'\r\n              : placement\r\n\r\n    tip.classList.remove(orgPlacement)\r\n    tip.classList.add(placement)\r\n  }\r\n\r\n  var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)\r\n  this.applyPlacement(calculatedOffset, placement)\r\n}\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 535,
            "func_location": "GitRepository.refreshIndex",
            "func_start_line": 534,
            "func_end_line": 536,
            "args": [],
            "comment": [
                " Reread the index to update any values that have changed since the",
                " last time the index was read."
            ],
            "code": "  refreshIndex () {\r\n    return this.getRepo().refreshIndex()\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 209,
            "func_location": "GitRepository.relativize",
            "func_start_line": 208,
            "func_end_line": 210,
            "args": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "comment": [
                " Public: Makes a path relative to the repository's working directory."
            ],
            "code": "  relativize (path) {\r\n    return this.getRepo().relativize(path)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "getRepo",
            "line": 209,
            "func_location": "GitRepository.relativize",
            "func_start_line": 208,
            "func_end_line": 210,
            "args": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "comment": [
                " Public: Makes a path relative to the repository's working directory."
            ],
            "code": "  relativize (path) {\r\n    return this.getRepo().relativize(path)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.getRepo",
            "start_line": 524,
            "end_line": 530,
            "comment": [
                " Returns the corresponding {Repository}"
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "relativize",
            "line": 209,
            "func_location": "GitRepository.relativize",
            "func_start_line": 208,
            "func_end_line": 210,
            "args": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "comment": [
                " Public: Makes a path relative to the repository's working directory."
            ],
            "code": "  relativize (path) {\r\n    return this.getRepo().relativize(path)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.relativize",
            "start_line": 208,
            "end_line": 210,
            "comment": [
                " Public: Makes a path relative to the repository's working directory."
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "relativize",
            "line": 209,
            "func_location": "GitRepository.relativize",
            "func_start_line": 208,
            "func_end_line": 210,
            "args": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "comment": [
                " Public: Makes a path relative to the repository's working directory."
            ],
            "code": "  relativize (path) {\r\n    return this.getRepo().relativize(path)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "GitRepository.relativize",
            "start_line": 208,
            "end_line": 210,
            "comment": [
                " Public: Makes a path relative to the repository's working directory."
            ],
            "params": [
                {
                    "name": "path",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/theme-manager.js",
            "name": "requireStylesheet",
            "line": 225,
            "func_location": "ThemeManager.reloadBaseStylesheets",
            "func_start_line": 224,
            "func_end_line": 226,
            "args": [
                {
                    "type": "string"
                },
                null,
                {
                    "type": "boolean"
                }
            ],
            "code": "  reloadBaseStylesheets () {\r\n    this.requireStylesheet('../static/atom', -2, true)\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/theme-manager.js",
            "name": "ThemeManager.requireStylesheet",
            "start_line": 167,
            "end_line": 175,
            "comment": [
                "\r\n  Section: Private\r\n  ",
                " Resolve and apply the stylesheet specified by the path.",
                "",
                " This supports both CSS and Less stylesheets.",
                "",
                " * `stylesheetPath` A {String} path to the stylesheet that can be an absolute",
                "   path or a relative path that will be resolved against the load path.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to remove the",
                " required stylesheet."
            ],
            "params": [
                {
                    "name": "stylesheetPath",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "priority",
                    "type": []
                },
                {
                    "name": "skipDeprecatedSelectorsTransformation",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "remove",
            "line": 890,
            "func_location": "Config.removeAtKeyPath",
            "func_start_line": 887,
            "func_end_line": 893,
            "args": [
                "arrayValue",
                "value"
            ],
            "code": "  removeAtKeyPath (keyPath, value) {\r\n    const left = this.get(keyPath)\r\n    const arrayValue = (left == null ? [] : left)\r\n    const result = _.remove(arrayValue, value)\r\n    this.set(keyPath, arrayValue)\r\n    return result\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "set",
            "line": 891,
            "func_location": "Config.removeAtKeyPath",
            "func_start_line": 887,
            "func_end_line": 893,
            "args": [
                "keyPath",
                "arrayValue"
            ],
            "code": "  removeAtKeyPath (keyPath, value) {\r\n    const left = this.get(keyPath)\r\n    const arrayValue = (left == null ? [] : left)\r\n    const result = _.remove(arrayValue, value)\r\n    this.set(keyPath, arrayValue)\r\n    return result\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.set",
            "start_line": 687,
            "end_line": 722,
            "comment": [
                " Essential: Sets the value for a configuration setting.",
                "",
                " This value is stored in Atom's internal configuration file.",
                "",
                " ### Examples",
                "",
                " You might want to change the themes programmatically:",
                "",
                " ```coffee",
                " atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])",
                " ```",
                "",
                " You can also set scoped settings. For example, you might want change the",
                " `editor.tabLength` only for ruby files.",
                "",
                " ```coffee",
                " atom.config.get('editor.tabLength') # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",
                "",
                " # Set ruby to 2",
                " atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true",
                "",
                " # Notice it's only set to 2 in the case of ruby",
                " atom.config.get('editor.tabLength') # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2",
                " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",
                " ```",
                "",
                " * `keyPath` The {String} name of the key.",
                " * `value` The value of the setting. Passing `undefined` will revert the",
                "   setting to the default value.",
                " * `options` (optional) {Object}",
                "   * `scopeSelector` (optional) {String}. eg. '.source.ruby'",
                "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)",
                "     for more information.",
                "   * `source` (optional) {String} The name of a file with which the setting",
                "     is associated. Defaults to the user's config file.",
                "",
                " Returns a {Boolean}",
                " * `true` if the value was set.",
                " * `false` if the value was not able to be coerced to the type specified in the setting's schema."
            ],
            "params": [
                {
                    "name": "args",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/dock.js",
            "name": "isItemAllowed",
            "line": 240,
            "func_location": "Dock.render",
            "func_start_line": 179,
            "func_end_line": 244,
            "args": [
                ".state.draggingItem",
                ".location"
            ],
            "code": "  render () {\r\n    const innerElementClassList = ['atom-dock-inner', this.location]\r\n    if (this.state.visible) innerElementClassList.push(VISIBLE_CLASS)\r\n\r\n    const maskElementClassList = ['atom-dock-mask']\r\n    if (this.state.shouldAnimate) maskElementClassList.push(SHOULD_ANIMATE_CLASS)\r\n\r\n    const cursorOverlayElementClassList = ['atom-dock-cursor-overlay', this.location]\r\n    if (this.state.resizing) cursorOverlayElementClassList.push(CURSOR_OVERLAY_VISIBLE_CLASS)\r\n\r\n    const shouldBeVisible = this.state.visible || this.state.showDropTarget\r\n    const size = Math.max(MINIMUM_SIZE,\r\n      this.state.size ||\r\n      (this.state.draggingItem && getPreferredSize(this.state.draggingItem, this.location)) ||\r\n      DEFAULT_INITIAL_SIZE\r\n    )\r\n\r\n    // We need to change the size of the mask...\r\n    const maskStyle = {[this.widthOrHeight]: `${shouldBeVisible ? size : 0}px`}\r\n    // ...but the content needs to maintain a constant size.\r\n    const wrapperStyle = {[this.widthOrHeight]: `${size}px`}\r\n\r\n    return $(\r\n      'atom-dock',\r\n      {className: this.location},\r\n      $.div(\r\n        {ref: 'innerElement', className: innerElementClassList.join(' ')},\r\n        $.div(\r\n          {\r\n            className: maskElementClassList.join(' '),\r\n            style: maskStyle\r\n          },\r\n          $.div(\r\n            {\r\n              ref: 'wrapperElement',\r\n              className: `atom-dock-content-wrapper ${this.location}`,\r\n              style: wrapperStyle\r\n            },\r\n            $(DockResizeHandle, {\r\n              location: this.location,\r\n              onResizeStart: this.handleResizeHandleDragStart,\r\n              onResizeToFit: this.handleResizeToFit,\r\n              dockIsVisible: this.state.visible\r\n            }),\r\n            $(ElementComponent, {element: this.paneContainer.getElement()}),\r\n            $.div({className: cursorOverlayElementClassList.join(' ')})\r\n          )\r\n        ),\r\n        $(DockToggleButton, {\r\n          ref: 'toggleButton',\r\n          onDragEnter: this.state.draggingItem ? this.handleToggleButtonDragEnter : null,\r\n          location: this.location,\r\n          toggle: this.toggle,\r\n          dockIsVisible: shouldBeVisible,\r\n          visible:\r\n            // Don't show the toggle button if the dock is closed and empty...\r\n            (this.state.hovered &&\r\n              (this.state.visible || this.getPaneItems().length > 0)) ||\r\n            // ...or if the item can't be dropped in that dock.\r\n            (!shouldBeVisible &&\r\n              this.state.draggingItem &&\r\n              isItemAllowed(this.state.draggingItem, this.location))\r\n        })\r\n      )\r\n    )\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/dock.js",
            "name": "isItemAllowed",
            "start_line": 858,
            "end_line": 861,
            "comment": [
                " Is the item allowed in the given location?"
            ],
            "params": [
                {
                    "name": "item",
                    "type": []
                },
                {
                    "name": "location",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "replace",
            "line": 492,
            "func_location": "TextEditorComponent.render",
            "func_start_line": 451,
            "func_end_line": 521,
            "args": [
                {
                    "type": "object"
                },
                {
                    "type": "string"
                }
            ],
            "code": "  render () {\r\n    const {model} = this.props\r\n    const style = {}\r\n\r\n    if (!model.getAutoHeight() && !model.getAutoWidth()) {\r\n      style.contain = 'size'\r\n    }\r\n\r\n    let clientContainerHeight = '100%'\r\n    let clientContainerWidth = '100%'\r\n    if (this.hasInitialMeasurements) {\r\n      if (model.getAutoHeight()) {\r\n        clientContainerHeight =\r\n          this.getContentHeight() +\r\n          this.getHorizontalScrollbarHeight() +\r\n          'px'\r\n      }\r\n      if (model.getAutoWidth()) {\r\n        style.width = 'min-content'\r\n        clientContainerWidth =\r\n          this.getGutterContainerWidth() +\r\n          this.getContentWidth() +\r\n          this.getVerticalScrollbarWidth() +\r\n          'px'\r\n      } else {\r\n        style.width = this.element.style.width\r\n      }\r\n    }\r\n\r\n    let attributes = {}\r\n    if (model.isMini()) {\r\n      attributes.mini = ''\r\n    }\r\n\r\n    if (model.isReadOnly()) {\r\n      attributes.readonly = ''\r\n    }\r\n\r\n    const dataset = {encoding: model.getEncoding()}\r\n    const grammar = model.getGrammar()\r\n    if (grammar && grammar.scopeName) {\r\n      dataset.grammar = grammar.scopeName.replace(/\\./g, ' ')\r\n    }\r\n\r\n    return $('atom-text-editor',\r\n      {\r\n        // See this.updateClassList() for construction of the class name\r\n        style,\r\n        attributes,\r\n        dataset,\r\n        tabIndex: -1,\r\n        on: {mousewheel: this.didMouseWheel}\r\n      },\r\n      $.div(\r\n        {\r\n          ref: 'clientContainer',\r\n          style: {\r\n            position: 'relative',\r\n            contain: 'strict',\r\n            overflow: 'hidden',\r\n            backgroundColor: 'inherit',\r\n            height: clientContainerHeight,\r\n            width: clientContainerWidth\r\n          }\r\n        },\r\n        this.renderGutterContainer(),\r\n        this.renderScrollContainer()\r\n      ),\r\n      this.renderOverlayDecorations()\r\n    )\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "Project.replace",
            "start_line": 82,
            "end_line": 99,
            "comment": [
                " Layers the contents of a project's file's config",
                " on top of the current global config."
            ],
            "params": [
                {
                    "name": "projectSpecification",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "resetProjectSettings",
            "line": 95,
            "func_location": "Project.replace",
            "func_start_line": 82,
            "func_end_line": 99,
            "args": [
                {
                    "name": "projectSpecification.config",
                    "type": []
                },
                {
                    "name": "projectSpecification.originPath",
                    "type": []
                }
            ],
            "comment": [
                " Layers the contents of a project's file's config",
                " on top of the current global config."
            ],
            "code": "  replace (projectSpecification) {\r\n    if (projectSpecification == null) {\r\n      atom.config.clearProjectSettings()\r\n      this.setPaths([])\r\n    } else {\r\n      if (projectSpecification.originPath == null) {\r\n        return\r\n      }\r\n\r\n      // If no path is specified, set to directory of originPath.\r\n      if (!Array.isArray(projectSpecification.paths)) {\r\n        projectSpecification.paths = [path.dirname(projectSpecification.originPath)]\r\n      }\r\n      atom.config.resetProjectSettings(projectSpecification.config, projectSpecification.originPath)\r\n      this.setPaths(projectSpecification.paths)\r\n    }\r\n    this.emitter.emit('did-replace', projectSpecification)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.resetProjectSettings",
            "start_line": 977,
            "end_line": 988,
            "comment": [],
            "params": [
                "newSettings",
                "projectFile"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/theme-manager.js",
            "name": "resolveStylesheet",
            "line": 168,
            "func_location": "ThemeManager.requireStylesheet",
            "func_start_line": 167,
            "func_end_line": 175,
            "args": [
                {
                    "name": "stylesheetPath",
                    "type": [
                        "string"
                    ]
                }
            ],
            "comment": [
                "\r\n  Section: Private\r\n  ",
                " Resolve and apply the stylesheet specified by the path.",
                "",
                " This supports both CSS and Less stylesheets.",
                "",
                " * `stylesheetPath` A {String} path to the stylesheet that can be an absolute",
                "   path or a relative path that will be resolved against the load path.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to remove the",
                " required stylesheet."
            ],
            "code": "  requireStylesheet (stylesheetPath, priority, skipDeprecatedSelectorsTransformation) {\r\n    let fullPath = this.resolveStylesheet(stylesheetPath)\r\n    if (fullPath) {\r\n      const content = this.loadStylesheet(fullPath)\r\n      return this.applyStylesheet(fullPath, content, priority, skipDeprecatedSelectorsTransformation)\r\n    } else {\r\n      throw new Error(`Could not find a file at path '${stylesheetPath}'`)\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/theme-manager.js",
            "name": "ThemeManager.resolveStylesheet",
            "start_line": 233,
            "end_line": 239,
            "comment": [],
            "params": [
                "stylesheetPath"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/theme-manager.js",
            "name": "loadStylesheet",
            "line": 170,
            "func_location": "ThemeManager.requireStylesheet",
            "func_start_line": 167,
            "func_end_line": 175,
            "args": [
                {
                    "name": "fullPath",
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Private\r\n  ",
                " Resolve and apply the stylesheet specified by the path.",
                "",
                " This supports both CSS and Less stylesheets.",
                "",
                " * `stylesheetPath` A {String} path to the stylesheet that can be an absolute",
                "   path or a relative path that will be resolved against the load path.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to remove the",
                " required stylesheet."
            ],
            "code": "  requireStylesheet (stylesheetPath, priority, skipDeprecatedSelectorsTransformation) {\r\n    let fullPath = this.resolveStylesheet(stylesheetPath)\r\n    if (fullPath) {\r\n      const content = this.loadStylesheet(fullPath)\r\n      return this.applyStylesheet(fullPath, content, priority, skipDeprecatedSelectorsTransformation)\r\n    } else {\r\n      throw new Error(`Could not find a file at path '${stylesheetPath}'`)\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/theme-manager.js",
            "name": "ThemeManager.loadStylesheet",
            "start_line": 241,
            "end_line": 247,
            "comment": [],
            "params": [
                "stylesheetPath",
                "importFallbackVariables"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/theme-manager.js",
            "name": "applyStylesheet",
            "line": 171,
            "func_location": "ThemeManager.requireStylesheet",
            "func_start_line": 167,
            "func_end_line": 175,
            "args": [
                {
                    "name": "fullPath",
                    "type": []
                },
                {
                    "name": "content",
                    "type": []
                },
                {
                    "name": "priority",
                    "type": []
                },
                {
                    "name": "skipDeprecatedSelectorsTransformation",
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Private\r\n  ",
                " Resolve and apply the stylesheet specified by the path.",
                "",
                " This supports both CSS and Less stylesheets.",
                "",
                " * `stylesheetPath` A {String} path to the stylesheet that can be an absolute",
                "   path or a relative path that will be resolved against the load path.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to remove the",
                " required stylesheet."
            ],
            "code": "  requireStylesheet (stylesheetPath, priority, skipDeprecatedSelectorsTransformation) {\r\n    let fullPath = this.resolveStylesheet(stylesheetPath)\r\n    if (fullPath) {\r\n      const content = this.loadStylesheet(fullPath)\r\n      return this.applyStylesheet(fullPath, content, priority, skipDeprecatedSelectorsTransformation)\r\n    } else {\r\n      throw new Error(`Could not find a file at path '${stylesheetPath}'`)\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/theme-manager.js",
            "name": "ThemeManager.applyStylesheet",
            "start_line": 306,
            "end_line": 317,
            "comment": [],
            "params": [
                "path",
                "text",
                "priority",
                "skipDeprecatedSelectorsTransformation"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "priorityForSource",
            "line": 1217,
            "func_location": "Config.resetScopedSettings",
            "func_start_line": 1215,
            "func_end_line": 1229,
            "args": [
                "source"
            ],
            "code": "  resetScopedSettings (newScopedSettings, options = {}) {\r\n    const source = options.source == null ? this.mainSource : options.source\r\n    const priority = this.priorityForSource(source)\r\n    this.scopedSettingsStore.removePropertiesForSource(source)\r\n\r\n    for (let scopeSelector in newScopedSettings) {\r\n      let settings = newScopedSettings[scopeSelector]\r\n      settings = this.makeValueConformToSchema(null, settings, {suppressException: true})\r\n      const validatedSettings = {}\r\n      validatedSettings[scopeSelector] = withoutEmptyObjects(settings)\r\n      if (validatedSettings[scopeSelector] != null) { this.scopedSettingsStore.addProperties(source, validatedSettings, {priority}) }\r\n    }\r\n\r\n    return this.emitChangeEvent()\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.priorityForSource",
            "start_line": 1200,
            "end_line": 1209,
            "comment": [
                "\r\n  Section: Private Scoped Settings\r\n  "
            ],
            "params": [
                {
                    "name": "source",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "transact",
            "line": 1184,
            "func_location": "Config.resetSettingsForSchemaChange",
            "func_start_line": 1182,
            "func_end_line": 1194
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.transact",
            "start_line": 816,
            "end_line": 823,
            "comment": [
                " Extended: Suppress calls to handler functions registered with {::onDidChange}",
                " and {::observe} for the duration of `callback`. After `callback` executes,",
                " handlers will be called once if the value for their key-path has changed.",
                "",
                " * `callback` {Function} to execute while suppressing calls to handlers."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "_resetSettings",
            "line": 937,
            "func_location": "Config.resetUserSettings",
            "func_start_line": 936,
            "func_end_line": 938,
            "args": [
                {
                    "name": "newSettings",
                    "type": []
                },
                {
                    "name": "options",
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Private methods managing global settings\r\n  "
            ],
            "code": "  resetUserSettings (newSettings, options = {}) {\r\n    this._resetSettings(newSettings, options)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config._resetSettings",
            "start_line": 940,
            "end_line": 967,
            "comment": [],
            "params": [
                "newSettings",
                "options"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/compile-cache.js",
            "name": "warn",
            "line": 149,
            "func_location": "retrieveSourceMap",
            "func_start_line": 137,
            "func_end_line": 190,
            "args": [
                {
                    "name": {
                        "type": "string"
                    },
                    "type": []
                },
                {
                    "name": "error.stack",
                    "type": []
                }
            ],
            "comment": [
                " Most of this logic is the same as the default implementation in the",
                " source-map-support module, but we've overridden it to read the javascript",
                " code from our cache directory."
            ],
            "code": "    retrieveSourceMap: function (filePath) {\r\n      if (filePath === '<embedded>') {\r\n        return {map: snapshotSourceMapConsumer}\r\n      }\r\n\r\n      if (!cacheDirectory || !fs.isFileSync(filePath)) {\r\n        return null\r\n      }\r\n\r\n      try {\r\n        var sourceCode = fs.readFileSync(filePath, 'utf8')\r\n      } catch (error) {\r\n        console.warn('Error reading source file', error.stack)\r\n        return null\r\n      }\r\n\r\n      var compiler = COMPILERS[path.extname(filePath)]\r\n      if (!compiler) compiler = COMPILERS['.js']\r\n\r\n      try {\r\n        var fileData = readCachedJavaScript(compiler.getCachePath(sourceCode, filePath))\r\n      } catch (error) {\r\n        console.warn('Error reading compiled file', error.stack)\r\n        return null\r\n      }\r\n\r\n      if (fileData == null) {\r\n        return null\r\n      }\r\n\r\n      var match, lastMatch\r\n      INLINE_SOURCE_MAP_REGEXP.lastIndex = 0\r\n      while ((match = INLINE_SOURCE_MAP_REGEXP.exec(fileData))) {\r\n        lastMatch = match\r\n      }\r\n      if (lastMatch == null) {\r\n        return null\r\n      }\r\n\r\n      var sourceMappingURL = lastMatch[1]\r\n      var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1)\r\n\r\n      try {\r\n        var sourceMap = JSON.parse(new Buffer(rawData, 'base64'))\r\n      } catch (error) {\r\n        console.warn('Error parsing source map', error.stack)\r\n        return null\r\n      }\r\n\r\n      return {\r\n        map: sourceMap,\r\n        url: null\r\n      }\r\n    }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/initialize-benchmark-window.js",
            "name": "console.warn",
            "start_line": 82,
            "end_line": 85,
            "comment": [],
            "params": [
                "args"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/compile-cache.js",
            "name": "readCachedJavaScript",
            "line": 157,
            "func_location": "retrieveSourceMap",
            "func_start_line": 137,
            "func_end_line": 190,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Most of this logic is the same as the default implementation in the",
                " source-map-support module, but we've overridden it to read the javascript",
                " code from our cache directory."
            ],
            "code": "    retrieveSourceMap: function (filePath) {\r\n      if (filePath === '<embedded>') {\r\n        return {map: snapshotSourceMapConsumer}\r\n      }\r\n\r\n      if (!cacheDirectory || !fs.isFileSync(filePath)) {\r\n        return null\r\n      }\r\n\r\n      try {\r\n        var sourceCode = fs.readFileSync(filePath, 'utf8')\r\n      } catch (error) {\r\n        console.warn('Error reading source file', error.stack)\r\n        return null\r\n      }\r\n\r\n      var compiler = COMPILERS[path.extname(filePath)]\r\n      if (!compiler) compiler = COMPILERS['.js']\r\n\r\n      try {\r\n        var fileData = readCachedJavaScript(compiler.getCachePath(sourceCode, filePath))\r\n      } catch (error) {\r\n        console.warn('Error reading compiled file', error.stack)\r\n        return null\r\n      }\r\n\r\n      if (fileData == null) {\r\n        return null\r\n      }\r\n\r\n      var match, lastMatch\r\n      INLINE_SOURCE_MAP_REGEXP.lastIndex = 0\r\n      while ((match = INLINE_SOURCE_MAP_REGEXP.exec(fileData))) {\r\n        lastMatch = match\r\n      }\r\n      if (lastMatch == null) {\r\n        return null\r\n      }\r\n\r\n      var sourceMappingURL = lastMatch[1]\r\n      var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1)\r\n\r\n      try {\r\n        var sourceMap = JSON.parse(new Buffer(rawData, 'base64'))\r\n      } catch (error) {\r\n        console.warn('Error parsing source map', error.stack)\r\n        return null\r\n      }\r\n\r\n      return {\r\n        map: sourceMap,\r\n        url: null\r\n      }\r\n    }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/compile-cache.js",
            "name": "readCachedJavaScript",
            "start_line": 101,
            "end_line": 109,
            "comment": [],
            "params": [
                "relativeCachePath"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/compile-cache.js",
            "name": "warn",
            "line": 159,
            "func_location": "retrieveSourceMap",
            "func_start_line": 137,
            "func_end_line": 190,
            "args": [
                {
                    "name": {
                        "type": "string"
                    },
                    "type": []
                },
                {
                    "name": "error.stack",
                    "type": []
                }
            ],
            "comment": [
                " Most of this logic is the same as the default implementation in the",
                " source-map-support module, but we've overridden it to read the javascript",
                " code from our cache directory."
            ],
            "code": "    retrieveSourceMap: function (filePath) {\r\n      if (filePath === '<embedded>') {\r\n        return {map: snapshotSourceMapConsumer}\r\n      }\r\n\r\n      if (!cacheDirectory || !fs.isFileSync(filePath)) {\r\n        return null\r\n      }\r\n\r\n      try {\r\n        var sourceCode = fs.readFileSync(filePath, 'utf8')\r\n      } catch (error) {\r\n        console.warn('Error reading source file', error.stack)\r\n        return null\r\n      }\r\n\r\n      var compiler = COMPILERS[path.extname(filePath)]\r\n      if (!compiler) compiler = COMPILERS['.js']\r\n\r\n      try {\r\n        var fileData = readCachedJavaScript(compiler.getCachePath(sourceCode, filePath))\r\n      } catch (error) {\r\n        console.warn('Error reading compiled file', error.stack)\r\n        return null\r\n      }\r\n\r\n      if (fileData == null) {\r\n        return null\r\n      }\r\n\r\n      var match, lastMatch\r\n      INLINE_SOURCE_MAP_REGEXP.lastIndex = 0\r\n      while ((match = INLINE_SOURCE_MAP_REGEXP.exec(fileData))) {\r\n        lastMatch = match\r\n      }\r\n      if (lastMatch == null) {\r\n        return null\r\n      }\r\n\r\n      var sourceMappingURL = lastMatch[1]\r\n      var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1)\r\n\r\n      try {\r\n        var sourceMap = JSON.parse(new Buffer(rawData, 'base64'))\r\n      } catch (error) {\r\n        console.warn('Error parsing source map', error.stack)\r\n        return null\r\n      }\r\n\r\n      return {\r\n        map: sourceMap,\r\n        url: null\r\n      }\r\n    }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/initialize-benchmark-window.js",
            "name": "console.warn",
            "start_line": 82,
            "end_line": 85,
            "comment": [],
            "params": [
                "args"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/compile-cache.js",
            "name": "parse",
            "line": 180,
            "func_location": "retrieveSourceMap",
            "func_start_line": 137,
            "func_end_line": 190,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Most of this logic is the same as the default implementation in the",
                " source-map-support module, but we've overridden it to read the javascript",
                " code from our cache directory."
            ],
            "code": "    retrieveSourceMap: function (filePath) {\r\n      if (filePath === '<embedded>') {\r\n        return {map: snapshotSourceMapConsumer}\r\n      }\r\n\r\n      if (!cacheDirectory || !fs.isFileSync(filePath)) {\r\n        return null\r\n      }\r\n\r\n      try {\r\n        var sourceCode = fs.readFileSync(filePath, 'utf8')\r\n      } catch (error) {\r\n        console.warn('Error reading source file', error.stack)\r\n        return null\r\n      }\r\n\r\n      var compiler = COMPILERS[path.extname(filePath)]\r\n      if (!compiler) compiler = COMPILERS['.js']\r\n\r\n      try {\r\n        var fileData = readCachedJavaScript(compiler.getCachePath(sourceCode, filePath))\r\n      } catch (error) {\r\n        console.warn('Error reading compiled file', error.stack)\r\n        return null\r\n      }\r\n\r\n      if (fileData == null) {\r\n        return null\r\n      }\r\n\r\n      var match, lastMatch\r\n      INLINE_SOURCE_MAP_REGEXP.lastIndex = 0\r\n      while ((match = INLINE_SOURCE_MAP_REGEXP.exec(fileData))) {\r\n        lastMatch = match\r\n      }\r\n      if (lastMatch == null) {\r\n        return null\r\n      }\r\n\r\n      var sourceMappingURL = lastMatch[1]\r\n      var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1)\r\n\r\n      try {\r\n        var sourceMap = JSON.parse(new Buffer(rawData, 'base64'))\r\n      } catch (error) {\r\n        console.warn('Error parsing source map', error.stack)\r\n        return null\r\n      }\r\n\r\n      return {\r\n        map: sourceMap,\r\n        url: null\r\n      }\r\n    }\r",
            "return_type": [
                "null"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/color.js",
            "name": "Color.parse",
            "start_line": 14,
            "end_line": 36,
            "comment": [
                " Essential: Parse a {String} or {Object} into a {Color}.",
                "",
                " * `value` A {String} such as `'white'`, `#ff00ff`, or",
                "   `'rgba(255, 15, 60, .75)'` or an {Object} with `red`, `green`, `blue`,",
                "   and `alpha` properties.",
                "",
                " Returns a {Color} or `null` if it cannot be parsed."
            ],
            "params": [
                {
                    "name": "value",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "null"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/compile-cache.js",
            "name": "parse",
            "line": 180,
            "func_location": "retrieveSourceMap",
            "func_start_line": 137,
            "func_end_line": 190,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Most of this logic is the same as the default implementation in the",
                " source-map-support module, but we've overridden it to read the javascript",
                " code from our cache directory."
            ],
            "code": "    retrieveSourceMap: function (filePath) {\r\n      if (filePath === '<embedded>') {\r\n        return {map: snapshotSourceMapConsumer}\r\n      }\r\n\r\n      if (!cacheDirectory || !fs.isFileSync(filePath)) {\r\n        return null\r\n      }\r\n\r\n      try {\r\n        var sourceCode = fs.readFileSync(filePath, 'utf8')\r\n      } catch (error) {\r\n        console.warn('Error reading source file', error.stack)\r\n        return null\r\n      }\r\n\r\n      var compiler = COMPILERS[path.extname(filePath)]\r\n      if (!compiler) compiler = COMPILERS['.js']\r\n\r\n      try {\r\n        var fileData = readCachedJavaScript(compiler.getCachePath(sourceCode, filePath))\r\n      } catch (error) {\r\n        console.warn('Error reading compiled file', error.stack)\r\n        return null\r\n      }\r\n\r\n      if (fileData == null) {\r\n        return null\r\n      }\r\n\r\n      var match, lastMatch\r\n      INLINE_SOURCE_MAP_REGEXP.lastIndex = 0\r\n      while ((match = INLINE_SOURCE_MAP_REGEXP.exec(fileData))) {\r\n        lastMatch = match\r\n      }\r\n      if (lastMatch == null) {\r\n        return null\r\n      }\r\n\r\n      var sourceMappingURL = lastMatch[1]\r\n      var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1)\r\n\r\n      try {\r\n        var sourceMap = JSON.parse(new Buffer(rawData, 'base64'))\r\n      } catch (error) {\r\n        console.warn('Error parsing source map', error.stack)\r\n        return null\r\n      }\r\n\r\n      return {\r\n        map: sourceMap,\r\n        url: null\r\n      }\r\n    }\r",
            "return_type": [
                "null"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/color.js",
            "name": "Color.parse",
            "start_line": 14,
            "end_line": 36,
            "comment": [
                " Essential: Parse a {String} or {Object} into a {Color}.",
                "",
                " * `value` A {String} such as `'white'`, `#ff00ff`, or",
                "   `'rgba(255, 15, 60, .75)'` or an {Object} with `red`, `green`, `blue`,",
                "   and `alpha` properties.",
                "",
                " Returns a {Color} or `null` if it cannot be parsed."
            ],
            "params": [
                {
                    "name": "value",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "null"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/compile-cache.js",
            "name": "warn",
            "line": 182,
            "func_location": "retrieveSourceMap",
            "func_start_line": 137,
            "func_end_line": 190,
            "args": [
                {
                    "name": {
                        "type": "string"
                    },
                    "type": []
                },
                {
                    "name": "error.stack",
                    "type": []
                }
            ],
            "comment": [
                " Most of this logic is the same as the default implementation in the",
                " source-map-support module, but we've overridden it to read the javascript",
                " code from our cache directory."
            ],
            "code": "    retrieveSourceMap: function (filePath) {\r\n      if (filePath === '<embedded>') {\r\n        return {map: snapshotSourceMapConsumer}\r\n      }\r\n\r\n      if (!cacheDirectory || !fs.isFileSync(filePath)) {\r\n        return null\r\n      }\r\n\r\n      try {\r\n        var sourceCode = fs.readFileSync(filePath, 'utf8')\r\n      } catch (error) {\r\n        console.warn('Error reading source file', error.stack)\r\n        return null\r\n      }\r\n\r\n      var compiler = COMPILERS[path.extname(filePath)]\r\n      if (!compiler) compiler = COMPILERS['.js']\r\n\r\n      try {\r\n        var fileData = readCachedJavaScript(compiler.getCachePath(sourceCode, filePath))\r\n      } catch (error) {\r\n        console.warn('Error reading compiled file', error.stack)\r\n        return null\r\n      }\r\n\r\n      if (fileData == null) {\r\n        return null\r\n      }\r\n\r\n      var match, lastMatch\r\n      INLINE_SOURCE_MAP_REGEXP.lastIndex = 0\r\n      while ((match = INLINE_SOURCE_MAP_REGEXP.exec(fileData))) {\r\n        lastMatch = match\r\n      }\r\n      if (lastMatch == null) {\r\n        return null\r\n      }\r\n\r\n      var sourceMappingURL = lastMatch[1]\r\n      var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1)\r\n\r\n      try {\r\n        var sourceMap = JSON.parse(new Buffer(rawData, 'base64'))\r\n      } catch (error) {\r\n        console.warn('Error parsing source map', error.stack)\r\n        return null\r\n      }\r\n\r\n      return {\r\n        map: sourceMap,\r\n        url: null\r\n      }\r\n    }\r",
            "return_type": [
                "null"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/initialize-benchmark-window.js",
            "name": "console.warn",
            "start_line": 82,
            "end_line": 85,
            "comment": [],
            "params": [
                "args"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/pane-container-element.js",
            "name": "remove",
            "line": 22,
            "func_location": "PaneContainerElement.rootChanged",
            "func_start_line": 19,
            "func_end_line": 31,
            "args": [],
            "code": "  rootChanged (root) {\r\n    const focusedElement = this.hasFocus() ? document.activeElement : null\r\n    if (this.firstChild != null) {\r\n      this.firstChild.remove()\r\n    }\r\n    if (root != null) {\r\n      const view = this.views.getView(root)\r\n      this.appendChild(view)\r\n      if (focusedElement != null) {\r\n        focusedElement.focus()\r\n      }\r\n    }\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/pane-container-element.js",
            "name": "getView",
            "line": 25,
            "func_location": "PaneContainerElement.rootChanged",
            "func_start_line": 19,
            "func_end_line": 31,
            "args": [
                "root"
            ],
            "code": "  rootChanged (root) {\r\n    const focusedElement = this.hasFocus() ? document.activeElement : null\r\n    if (this.firstChild != null) {\r\n      this.firstChild.remove()\r\n    }\r\n    if (root != null) {\r\n      const view = this.views.getView(root)\r\n      this.appendChild(view)\r\n      if (focusedElement != null) {\r\n        focusedElement.focus()\r\n      }\r\n    }\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/view-registry.js",
            "name": "ViewRegistry.getView",
            "start_line": 122,
            "end_line": 131,
            "comment": [
                " Essential: Get the view associated with an object in the workspace.",
                "",
                " If you're just *using* the workspace, you shouldn't need to access the view",
                " layer, but view layer access may be necessary if you want to perform DOM",
                " manipulation that isn't supported via the model API.",
                "",
                " ## View Resolution Algorithm",
                "",
                " The view associated with the object is resolved using the following",
                " sequence",
                "",
                "  1. Is the object an instance of `HTMLElement`? If true, return the object.",
                "  2. Does the object have a method named `getElement` that returns an",
                "     instance of `HTMLElement`? If true, return that value.",
                "  3. Does the object have a property named `element` with a value which is",
                "     an instance of `HTMLElement`? If true, return the property value.",
                "  4. Is the object a jQuery object, indicated by the presence of a `jquery`",
                "     property? If true, return the root DOM element (i.e. `object[0]`).",
                "  5. Has a view provider been registered for the object? If true, use the",
                "     provider to create a view associated with the object, and return the",
                "     view.",
                "",
                " If no associated view is returned by the sequence an error is thrown.",
                "",
                " Returns a DOM element."
            ],
            "params": [
                {
                    "name": "object",
                    "type": [
                        "object"
                    ]
                }
            ],
            "return_type": [
                "object"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-element.js",
            "name": "setScrollTop",
            "line": 211,
            "func_location": "TextEditorElement.scrollToBottom",
            "func_start_line": 210,
            "func_end_line": 212,
            "args": [
                {
                    "name": "Infinity",
                    "type": []
                }
            ],
            "comment": [
                " Essential: Scrolls the editor to the bottom."
            ],
            "code": "  scrollToBottom () {\r\n    this.setScrollTop(Infinity)\r\n  }\r",
            "return_type": [
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-element.js",
            "name": "TextEditorElement.setScrollTop",
            "start_line": 172,
            "end_line": 176,
            "comment": [],
            "params": [
                "scrollTop"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-element.js",
            "name": "setScrollTop",
            "line": 206,
            "func_location": "TextEditorElement.scrollToTop",
            "func_start_line": 205,
            "func_end_line": 207,
            "args": [
                {
                    "name": {
                        "type": "number"
                    },
                    "type": []
                }
            ],
            "comment": [
                " Essential: Scrolls the editor to the top."
            ],
            "code": "  scrollToTop () {\r\n    this.setScrollTop(0)\r\n  }\r",
            "return_type": [
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-element.js",
            "name": "TextEditorElement.setScrollTop",
            "start_line": 172,
            "end_line": 176,
            "comment": [],
            "params": [
                "scrollTop"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "setBufferRange",
            "line": 283,
            "func_location": "Selection.selectAll",
            "func_start_line": 282,
            "func_end_line": 284,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Selects all the text in the buffer."
            ],
            "code": "  selectAll () {\r\n    this.setBufferRange(this.editor.buffer.getRange(), {autoscroll: false})\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.setBufferRange",
            "start_line": 92,
            "end_line": 104,
            "comment": [
                " Public: Modifies the buffer {Range} for the selection.",
                "",
                " * `bufferRange` The new {Range} to select.",
                " * `options` (optional) {Object} with the keys:",
                "   * `preserveFolds` if `true`, the fold settings are preserved after the",
                "     selection moves.",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     range. Defaults to `true` if this is the most recently added selection,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferRange",
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "setBufferRange",
            "line": 283,
            "func_location": "Selection.selectAll",
            "func_start_line": 282,
            "func_end_line": 284,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Public: Selects all the text in the buffer."
            ],
            "code": "  selectAll () {\r\n    this.setBufferRange(this.editor.buffer.getRange(), {autoscroll: false})\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.setBufferRange",
            "start_line": 92,
            "end_line": 104,
            "comment": [
                " Public: Modifies the buffer {Range} for the selection.",
                "",
                " * `bufferRange` The new {Range} to select.",
                " * `options` (optional) {Object} with the keys:",
                "   * `preserveFolds` if `true`, the fold settings are preserved after the",
                "     selection moves.",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     range. Defaults to `true` if this is the most recently added selection,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferRange",
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "setBufferRange",
            "line": 387,
            "func_location": "Selection.selectLine",
            "func_start_line": 385,
            "func_end_line": 397,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": "options",
                    "type": []
                }
            ],
            "comment": [
                " Public: Selects an entire line in the buffer.",
                "",
                " * `row` The line {Number} to select (default: the row of the cursor)."
            ],
            "code": "  selectLine (row, options) {\r\n    if (row != null) {\r\n      this.setBufferRange(this.editor.bufferRangeForBufferRow(row, {includeNewline: true}), options)\r\n    } else {\r\n      const startRange = this.editor.bufferRangeForBufferRow(this.marker.getStartBufferPosition().row)\r\n      const endRange = this.editor.bufferRangeForBufferRow(this.marker.getEndBufferPosition().row, {includeNewline: true})\r\n      this.setBufferRange(startRange.union(endRange), options)\r\n    }\r\n\r\n    this.linewise = true\r\n    this.wordwise = false\r\n    this.initialScreenRange = this.getScreenRange()\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.setBufferRange",
            "start_line": 92,
            "end_line": 104,
            "comment": [
                " Public: Modifies the buffer {Range} for the selection.",
                "",
                " * `bufferRange` The new {Range} to select.",
                " * `options` (optional) {Object} with the keys:",
                "   * `preserveFolds` if `true`, the fold settings are preserved after the",
                "     selection moves.",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     range. Defaults to `true` if this is the most recently added selection,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferRange",
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "setBufferRange",
            "line": 387,
            "func_location": "Selection.selectLine",
            "func_start_line": 385,
            "func_end_line": 397,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": "options",
                    "type": []
                }
            ],
            "comment": [
                " Public: Selects an entire line in the buffer.",
                "",
                " * `row` The line {Number} to select (default: the row of the cursor)."
            ],
            "code": "  selectLine (row, options) {\r\n    if (row != null) {\r\n      this.setBufferRange(this.editor.bufferRangeForBufferRow(row, {includeNewline: true}), options)\r\n    } else {\r\n      const startRange = this.editor.bufferRangeForBufferRow(this.marker.getStartBufferPosition().row)\r\n      const endRange = this.editor.bufferRangeForBufferRow(this.marker.getEndBufferPosition().row, {includeNewline: true})\r\n      this.setBufferRange(startRange.union(endRange), options)\r\n    }\r\n\r\n    this.linewise = true\r\n    this.wordwise = false\r\n    this.initialScreenRange = this.getScreenRange()\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.setBufferRange",
            "start_line": 92,
            "end_line": 104,
            "comment": [
                " Public: Modifies the buffer {Range} for the selection.",
                "",
                " * `bufferRange` The new {Range} to select.",
                " * `options` (optional) {Object} with the keys:",
                "   * `preserveFolds` if `true`, the fold settings are preserved after the",
                "     selection moves.",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     range. Defaults to `true` if this is the most recently added selection,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferRange",
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "setBufferRange",
            "line": 391,
            "func_location": "Selection.selectLine",
            "func_start_line": 385,
            "func_end_line": 397,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": "options",
                    "type": []
                }
            ],
            "comment": [
                " Public: Selects an entire line in the buffer.",
                "",
                " * `row` The line {Number} to select (default: the row of the cursor)."
            ],
            "code": "  selectLine (row, options) {\r\n    if (row != null) {\r\n      this.setBufferRange(this.editor.bufferRangeForBufferRow(row, {includeNewline: true}), options)\r\n    } else {\r\n      const startRange = this.editor.bufferRangeForBufferRow(this.marker.getStartBufferPosition().row)\r\n      const endRange = this.editor.bufferRangeForBufferRow(this.marker.getEndBufferPosition().row, {includeNewline: true})\r\n      this.setBufferRange(startRange.union(endRange), options)\r\n    }\r\n\r\n    this.linewise = true\r\n    this.wordwise = false\r\n    this.initialScreenRange = this.getScreenRange()\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.setBufferRange",
            "start_line": 92,
            "end_line": 104,
            "comment": [
                " Public: Modifies the buffer {Range} for the selection.",
                "",
                " * `bufferRange` The new {Range} to select.",
                " * `options` (optional) {Object} with the keys:",
                "   * `preserveFolds` if `true`, the fold settings are preserved after the",
                "     selection moves.",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     range. Defaults to `true` if this is the most recently added selection,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferRange",
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "setBufferRange",
            "line": 391,
            "func_location": "Selection.selectLine",
            "func_start_line": 385,
            "func_end_line": 397,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": "options",
                    "type": []
                }
            ],
            "comment": [
                " Public: Selects an entire line in the buffer.",
                "",
                " * `row` The line {Number} to select (default: the row of the cursor)."
            ],
            "code": "  selectLine (row, options) {\r\n    if (row != null) {\r\n      this.setBufferRange(this.editor.bufferRangeForBufferRow(row, {includeNewline: true}), options)\r\n    } else {\r\n      const startRange = this.editor.bufferRangeForBufferRow(this.marker.getStartBufferPosition().row)\r\n      const endRange = this.editor.bufferRangeForBufferRow(this.marker.getEndBufferPosition().row, {includeNewline: true})\r\n      this.setBufferRange(startRange.union(endRange), options)\r\n    }\r\n\r\n    this.linewise = true\r\n    this.wordwise = false\r\n    this.initialScreenRange = this.getScreenRange()\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.setBufferRange",
            "start_line": 92,
            "end_line": 104,
            "comment": [
                " Public: Modifies the buffer {Range} for the selection.",
                "",
                " * `bufferRange` The new {Range} to select.",
                " * `options` (optional) {Object} with the keys:",
                "   * `preserveFolds` if `true`, the fold settings are preserved after the",
                "     selection moves.",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     range. Defaults to `true` if this is the most recently added selection,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferRange",
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selectors.js",
            "name": "matcherForSelector",
            "line": 37,
            "func_location": "selectorMatchesAnyScope",
            "func_start_line": 36,
            "func_end_line": 38,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Essential: Return true iff the selector matches any provided scope.",
                "",
                " * {String} selector",
                " * {Array<String>} scopes",
                " Returns {Boolean} true if any scope matches the selector."
            ],
            "code": "function selectorMatchesAnyScope (selector, scopes) {\r\n  return !selector || scopes.some(matcherForSelector(selector))\r\n}\r",
            "return_type": [
                "function",
                "string",
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selectors.js",
            "name": "matcherForSelector",
            "start_line": 23,
            "end_line": 29,
            "comment": [
                " Essential: Return a matcher function for a selector.",
                "",
                " * selector, a {String} selector",
                " Returns {(scope: String) -> Boolean}, a matcher function returning",
                " true iff the scope matches the selector."
            ],
            "params": [
                {
                    "name": "selector",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "function",
                "string",
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selectors.js",
            "name": "matcherForSelector",
            "line": 37,
            "func_location": "selectorMatchesAnyScope",
            "func_start_line": 36,
            "func_end_line": 38,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Essential: Return true iff the selector matches any provided scope.",
                "",
                " * {String} selector",
                " * {Array<String>} scopes",
                " Returns {Boolean} true if any scope matches the selector."
            ],
            "code": "function selectorMatchesAnyScope (selector, scopes) {\r\n  return !selector || scopes.some(matcherForSelector(selector))\r\n}\r",
            "return_type": [
                "function",
                "string",
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selectors.js",
            "name": "matcherForSelector",
            "start_line": 23,
            "end_line": 29,
            "comment": [
                " Essential: Return a matcher function for a selector.",
                "",
                " * selector, a {String} selector",
                " Returns {(scope: String) -> Boolean}, a matcher function returning",
                " true iff the scope matches the selector."
            ],
            "params": [
                {
                    "name": "selector",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "function",
                "string",
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "fromObject",
            "line": 212,
            "func_location": "Selection.selectToScreenPosition",
            "func_start_line": 211,
            "func_end_line": 231,
            "args": [
                {
                    "name": "position",
                    "type": []
                }
            ],
            "comment": [
                " Public: Selects the text from the current cursor position to a given screen",
                " position.",
                "",
                " * `position` An instance of {Point}, with a given `row` and `column`."
            ],
            "code": "  selectToScreenPosition (position, options) {\r\n    position = Point.fromObject(position)\r\n\r\n    this.modifySelection(() => {\r\n      if (this.initialScreenRange) {\r\n        if (position.isLessThan(this.initialScreenRange.start)) {\r\n          this.marker.setScreenRange([position, this.initialScreenRange.end], {reversed: true})\r\n        } else {\r\n          this.marker.setScreenRange([this.initialScreenRange.start, position], {reversed: false})\r\n        }\r\n      } else {\r\n        this.cursor.setScreenPosition(position, options)\r\n      }\r\n\r\n      if (this.linewise) {\r\n        this.expandOverLine(options)\r\n      } else if (this.wordwise) {\r\n        this.expandOverWord(options)\r\n      }\r\n    })\r\n  }\r",
            "return_type": [
                "function",
                "string",
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/scope-descriptor.js",
            "name": "ScopeDescriptor.fromObject",
            "start_line": 22,
            "end_line": 28,
            "comment": [],
            "params": [
                "scopes"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "setBufferRange",
            "line": 369,
            "func_location": "Selection.selectWord",
            "func_start_line": 363,
            "func_end_line": 372,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": "options",
                    "type": []
                }
            ],
            "comment": [
                " Public: Modifies the selection to encompass the current word.",
                "",
                " Returns a {Range}."
            ],
            "code": "  selectWord (options = {}) {\r\n    if (this.cursor.isSurroundedByWhitespace()) options.wordRegex = /[\\t ]*/\r\n    if (this.cursor.isBetweenWordAndNonWord()) {\r\n      options.includeNonWordCharacters = false\r\n    }\r\n\r\n    this.setBufferRange(this.cursor.getCurrentWordBufferRange(options), options)\r\n    this.wordwise = true\r\n    this.initialScreenRange = this.getScreenRange()\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.setBufferRange",
            "start_line": 92,
            "end_line": 104,
            "comment": [
                " Public: Modifies the buffer {Range} for the selection.",
                "",
                " * `bufferRange` The new {Range} to select.",
                " * `options` (optional) {Object} with the keys:",
                "   * `preserveFolds` if `true`, the fold settings are preserved after the",
                "     selection moves.",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     range. Defaults to `true` if this is the most recently added selection,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferRange",
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "setBufferRange",
            "line": 369,
            "func_location": "Selection.selectWord",
            "func_start_line": 363,
            "func_end_line": 372,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": "options",
                    "type": []
                }
            ],
            "comment": [
                " Public: Modifies the selection to encompass the current word.",
                "",
                " Returns a {Range}."
            ],
            "code": "  selectWord (options = {}) {\r\n    if (this.cursor.isSurroundedByWhitespace()) options.wordRegex = /[\\t ]*/\r\n    if (this.cursor.isBetweenWordAndNonWord()) {\r\n      options.includeNonWordCharacters = false\r\n    }\r\n\r\n    this.setBufferRange(this.cursor.getCurrentWordBufferRange(options), options)\r\n    this.wordwise = true\r\n    this.initialScreenRange = this.getScreenRange()\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.setBufferRange",
            "start_line": 92,
            "end_line": 104,
            "comment": [
                " Public: Modifies the buffer {Range} for the selection.",
                "",
                " * `bufferRange` The new {Range} to select.",
                " * `options` (optional) {Object} with the keys:",
                "   * `preserveFolds` if `true`, the fold settings are preserved after the",
                "     selection moves.",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     range. Defaults to `true` if this is the most recently added selection,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferRange",
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "getCurrentWordBufferRange",
            "line": 369,
            "func_location": "Selection.selectWord",
            "func_start_line": 363,
            "func_end_line": 372,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": "options",
                    "type": []
                }
            ],
            "comment": [
                " Public: Modifies the selection to encompass the current word.",
                "",
                " Returns a {Range}."
            ],
            "code": "  selectWord (options = {}) {\r\n    if (this.cursor.isSurroundedByWhitespace()) options.wordRegex = /[\\t ]*/\r\n    if (this.cursor.isBetweenWordAndNonWord()) {\r\n      options.includeNonWordCharacters = false\r\n    }\r\n\r\n    this.setBufferRange(this.cursor.getCurrentWordBufferRange(options), options)\r\n    this.wordwise = true\r\n    this.initialScreenRange = this.getScreenRange()\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getCurrentWordBufferRange",
            "start_line": 606,
            "end_line": 616,
            "comment": [
                " Public: Returns the buffer Range occupied by the word located under the cursor.",
                "",
                " * `options` (optional) {Object}",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "     (default: {::wordRegExp})."
            ],
            "params": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "getCurrentWordBufferRange",
            "line": 369,
            "func_location": "Selection.selectWord",
            "func_start_line": 363,
            "func_end_line": 372,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": "options",
                    "type": []
                }
            ],
            "comment": [
                " Public: Modifies the selection to encompass the current word.",
                "",
                " Returns a {Range}."
            ],
            "code": "  selectWord (options = {}) {\r\n    if (this.cursor.isSurroundedByWhitespace()) options.wordRegex = /[\\t ]*/\r\n    if (this.cursor.isBetweenWordAndNonWord()) {\r\n      options.includeNonWordCharacters = false\r\n    }\r\n\r\n    this.setBufferRange(this.cursor.getCurrentWordBufferRange(options), options)\r\n    this.wordwise = true\r\n    this.initialScreenRange = this.getScreenRange()\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getCurrentWordBufferRange",
            "start_line": 606,
            "end_line": 616,
            "comment": [
                " Public: Returns the buffer Range occupied by the word located under the cursor.",
                "",
                " * `options` (optional) {Object}",
                "   * `wordRegex` A {RegExp} indicating what constitutes a \"word\"",
                "     (default: {::wordRegExp})."
            ],
            "params": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "makeValueConformToSchema",
            "line": 706,
            "func_location": "Config.set",
            "func_start_line": 687,
            "func_end_line": 722,
            "args": [
                {
                    "name": "keyPath",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "value",
                    "type": [
                        "undefined"
                    ]
                }
            ],
            "comment": [
                " Essential: Sets the value for a configuration setting.",
                "",
                " This value is stored in Atom's internal configuration file.",
                "",
                " ### Examples",
                "",
                " You might want to change the themes programmatically:",
                "",
                " ```coffee",
                " atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])",
                " ```",
                "",
                " You can also set scoped settings. For example, you might want change the",
                " `editor.tabLength` only for ruby files.",
                "",
                " ```coffee",
                " atom.config.get('editor.tabLength') # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",
                "",
                " # Set ruby to 2",
                " atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true",
                "",
                " # Notice it's only set to 2 in the case of ruby",
                " atom.config.get('editor.tabLength') # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2",
                " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",
                " ```",
                "",
                " * `keyPath` The {String} name of the key.",
                " * `value` The value of the setting. Passing `undefined` will revert the",
                "   setting to the default value.",
                " * `options` (optional) {Object}",
                "   * `scopeSelector` (optional) {String}. eg. '.source.ruby'",
                "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)",
                "     for more information.",
                "   * `source` (optional) {String} The name of a file with which the setting",
                "     is associated. Defaults to the user's config file.",
                "",
                " Returns a {Boolean}",
                " * `true` if the value was set.",
                " * `false` if the value was not able to be coerced to the type specified in the setting's schema."
            ],
            "code": "  set (...args) {\r\n    let [keyPath, value, options = {}] = args\r\n\r\n    if (!this.settingsLoaded) {\r\n      this.pendingOperations.push(() => this.set(keyPath, value, options))\r\n    }\r\n\r\n    const scopeSelector = options.scopeSelector\r\n    let source = options.source\r\n    const shouldSave = options.save != null ? options.save : true\r\n\r\n    if (source && !scopeSelector && source !== this.projectFile) {\r\n      throw new Error(\"::set with a 'source' and no 'sourceSelector' is not yet implemented!\")\r\n    }\r\n\r\n    if (!source) source = this.mainSource\r\n\r\n    if (value !== undefined) {\r\n      try {\r\n        value = this.makeValueConformToSchema(keyPath, value)\r\n      } catch (e) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    if (scopeSelector != null) {\r\n      this.setRawScopedValue(keyPath, value, source, scopeSelector)\r\n    } else {\r\n      this.setRawValue(keyPath, value, {source})\r\n    }\r\n\r\n    if (source === this.mainSource && shouldSave && this.settingsLoaded) {\r\n      this.requestSave()\r\n    }\r\n    return true\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.makeValueConformToSchema",
            "start_line": 1164,
            "end_line": 1178,
            "comment": [],
            "params": [
                "keyPath",
                "value",
                "options"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "setRawScopedValue",
            "line": 713,
            "func_location": "Config.set",
            "func_start_line": 687,
            "func_end_line": 722,
            "args": [
                {
                    "name": "keyPath",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "value",
                    "type": [
                        "undefined"
                    ]
                },
                {
                    "name": "source",
                    "type": [
                        "string",
                        "optional"
                    ]
                },
                {
                    "name": "scopeSelector",
                    "type": [
                        "string",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Essential: Sets the value for a configuration setting.",
                "",
                " This value is stored in Atom's internal configuration file.",
                "",
                " ### Examples",
                "",
                " You might want to change the themes programmatically:",
                "",
                " ```coffee",
                " atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])",
                " ```",
                "",
                " You can also set scoped settings. For example, you might want change the",
                " `editor.tabLength` only for ruby files.",
                "",
                " ```coffee",
                " atom.config.get('editor.tabLength') # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",
                "",
                " # Set ruby to 2",
                " atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true",
                "",
                " # Notice it's only set to 2 in the case of ruby",
                " atom.config.get('editor.tabLength') # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2",
                " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",
                " ```",
                "",
                " * `keyPath` The {String} name of the key.",
                " * `value` The value of the setting. Passing `undefined` will revert the",
                "   setting to the default value.",
                " * `options` (optional) {Object}",
                "   * `scopeSelector` (optional) {String}. eg. '.source.ruby'",
                "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)",
                "     for more information.",
                "   * `source` (optional) {String} The name of a file with which the setting",
                "     is associated. Defaults to the user's config file.",
                "",
                " Returns a {Boolean}",
                " * `true` if the value was set.",
                " * `false` if the value was not able to be coerced to the type specified in the setting's schema."
            ],
            "code": "  set (...args) {\r\n    let [keyPath, value, options = {}] = args\r\n\r\n    if (!this.settingsLoaded) {\r\n      this.pendingOperations.push(() => this.set(keyPath, value, options))\r\n    }\r\n\r\n    const scopeSelector = options.scopeSelector\r\n    let source = options.source\r\n    const shouldSave = options.save != null ? options.save : true\r\n\r\n    if (source && !scopeSelector && source !== this.projectFile) {\r\n      throw new Error(\"::set with a 'source' and no 'sourceSelector' is not yet implemented!\")\r\n    }\r\n\r\n    if (!source) source = this.mainSource\r\n\r\n    if (value !== undefined) {\r\n      try {\r\n        value = this.makeValueConformToSchema(keyPath, value)\r\n      } catch (e) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    if (scopeSelector != null) {\r\n      this.setRawScopedValue(keyPath, value, source, scopeSelector)\r\n    } else {\r\n      this.setRawValue(keyPath, value, {source})\r\n    }\r\n\r\n    if (source === this.mainSource && shouldSave && this.settingsLoaded) {\r\n      this.requestSave()\r\n    }\r\n    return true\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.setRawScopedValue",
            "start_line": 1231,
            "end_line": 1242,
            "comment": [],
            "params": [
                "keyPath",
                "value",
                "source",
                "selector",
                "options"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "setRawValue",
            "line": 715,
            "func_location": "Config.set",
            "func_start_line": 687,
            "func_end_line": 722,
            "args": [
                {
                    "name": "keyPath",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "value",
                    "type": [
                        "undefined"
                    ]
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Essential: Sets the value for a configuration setting.",
                "",
                " This value is stored in Atom's internal configuration file.",
                "",
                " ### Examples",
                "",
                " You might want to change the themes programmatically:",
                "",
                " ```coffee",
                " atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])",
                " ```",
                "",
                " You can also set scoped settings. For example, you might want change the",
                " `editor.tabLength` only for ruby files.",
                "",
                " ```coffee",
                " atom.config.get('editor.tabLength') # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",
                "",
                " # Set ruby to 2",
                " atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true",
                "",
                " # Notice it's only set to 2 in the case of ruby",
                " atom.config.get('editor.tabLength') # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2",
                " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",
                " ```",
                "",
                " * `keyPath` The {String} name of the key.",
                " * `value` The value of the setting. Passing `undefined` will revert the",
                "   setting to the default value.",
                " * `options` (optional) {Object}",
                "   * `scopeSelector` (optional) {String}. eg. '.source.ruby'",
                "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)",
                "     for more information.",
                "   * `source` (optional) {String} The name of a file with which the setting",
                "     is associated. Defaults to the user's config file.",
                "",
                " Returns a {Boolean}",
                " * `true` if the value was set.",
                " * `false` if the value was not able to be coerced to the type specified in the setting's schema."
            ],
            "code": "  set (...args) {\r\n    let [keyPath, value, options = {}] = args\r\n\r\n    if (!this.settingsLoaded) {\r\n      this.pendingOperations.push(() => this.set(keyPath, value, options))\r\n    }\r\n\r\n    const scopeSelector = options.scopeSelector\r\n    let source = options.source\r\n    const shouldSave = options.save != null ? options.save : true\r\n\r\n    if (source && !scopeSelector && source !== this.projectFile) {\r\n      throw new Error(\"::set with a 'source' and no 'sourceSelector' is not yet implemented!\")\r\n    }\r\n\r\n    if (!source) source = this.mainSource\r\n\r\n    if (value !== undefined) {\r\n      try {\r\n        value = this.makeValueConformToSchema(keyPath, value)\r\n      } catch (e) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    if (scopeSelector != null) {\r\n      this.setRawScopedValue(keyPath, value, source, scopeSelector)\r\n    } else {\r\n      this.setRawValue(keyPath, value, {source})\r\n    }\r\n\r\n    if (source === this.mainSource && shouldSave && this.settingsLoaded) {\r\n      this.requestSave()\r\n    }\r\n    return true\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.setRawValue",
            "start_line": 1020,
            "end_line": 1039,
            "comment": [],
            "params": [
                "keyPath",
                "value",
                "options"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "showUpdateMenuItem",
            "line": 39,
            "func_location": "ApplicationMenu.setActiveTemplate",
            "func_start_line": 32,
            "func_end_line": 40,
            "args": [
                null
            ],
            "code": "  setActiveTemplate (template) {\r\n    if (!_.isEqual(template, this.activeTemplate)) {\r\n      this.activeTemplate = template\r\n      this.menu = Menu.buildFromTemplate(_.deepClone(template))\r\n      Menu.setApplicationMenu(this.menu)\r\n    }\r\n\r\n    return this.showUpdateMenuItem(this.autoUpdateManager.getState())\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "ApplicationMenu.showUpdateMenuItem",
            "start_line": 109,
            "end_line": 140,
            "comment": [
                " Sets the proper visible state the update menu items"
            ],
            "params": [
                {
                    "name": "state",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "fromObject",
            "line": 93,
            "func_location": "Selection.setBufferRange",
            "func_start_line": 92,
            "func_end_line": 104,
            "args": [
                {
                    "name": "bufferRange",
                    "type": []
                }
            ],
            "comment": [
                " Public: Modifies the buffer {Range} for the selection.",
                "",
                " * `bufferRange` The new {Range} to select.",
                " * `options` (optional) {Object} with the keys:",
                "   * `preserveFolds` if `true`, the fold settings are preserved after the",
                "     selection moves.",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     range. Defaults to `true` if this is the most recently added selection,",
                "     `false` otherwise."
            ],
            "code": "  setBufferRange (bufferRange, options = {}) {\r\n    bufferRange = Range.fromObject(bufferRange)\r\n    if (options.reversed == null) options.reversed = this.isReversed()\r\n    if (!options.preserveFolds) this.editor.destroyFoldsContainingBufferPositions([bufferRange.start, bufferRange.end], true)\r\n    this.modifySelection(() => {\r\n      const needsFlash = options.flash\r\n      options.flash = null\r\n      this.marker.setBufferRange(bufferRange, options)\r\n      const autoscroll = options.autoscroll != null ? options.autoscroll : this.isLastSelection()\r\n      if (autoscroll) this.autoscroll()\r\n      if (needsFlash) this.decoration.flash('flash', this.editor.selectionFlashDuration)\r\n    })\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/scope-descriptor.js",
            "name": "ScopeDescriptor.fromObject",
            "start_line": 22,
            "end_line": 28,
            "comment": [],
            "params": [
                "scopes"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/tooltip.js",
            "name": "getView",
            "line": 347,
            "func_location": "Tooltip.prototype.setContent",
            "func_start_line": 338,
            "func_end_line": 358,
            "args": [
                null
            ],
            "code": "Tooltip.prototype.setContent = function () {\r\n  var tip = this.getTooltipElement()\r\n\r\n  if (this.options.class) {\r\n    tip.classList.add(this.options.class)\r\n  }\r\n\r\n  var inner = tip.querySelector('.tooltip-inner')\r\n  if (this.options.item) {\r\n    inner.appendChild(this.viewRegistry.getView(this.options.item))\r\n  } else {\r\n    var title = this.getTitle()\r\n    if (this.options.html) {\r\n      inner.innerHTML = title\r\n    } else {\r\n      inner.textContent = title\r\n    }\r\n  }\r\n\r\n  tip.classList.remove('fade', 'in', 'top', 'bottom', 'left', 'right')\r\n}\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/view-registry.js",
            "name": "ViewRegistry.getView",
            "start_line": 122,
            "end_line": 131,
            "comment": [
                " Essential: Get the view associated with an object in the workspace.",
                "",
                " If you're just *using* the workspace, you shouldn't need to access the view",
                " layer, but view layer access may be necessary if you want to perform DOM",
                " manipulation that isn't supported via the model API.",
                "",
                " ## View Resolution Algorithm",
                "",
                " The view associated with the object is resolved using the following",
                " sequence",
                "",
                "  1. Is the object an instance of `HTMLElement`? If true, return the object.",
                "  2. Does the object have a method named `getElement` that returns an",
                "     instance of `HTMLElement`? If true, return that value.",
                "  3. Does the object have a property named `element` with a value which is",
                "     an instance of `HTMLElement`? If true, return the property value.",
                "  4. Is the object a jQuery object, indicated by the presence of a `jquery`",
                "     property? If true, return the root DOM element (i.e. `object[0]`).",
                "  5. Has a view provider been registered for the object? If true, use the",
                "     provider to create a view associated with the object, and return the",
                "     view.",
                "",
                " If no associated view is returned by the sequence an error is thrown.",
                "",
                " Returns a DOM element."
            ],
            "params": [
                {
                    "name": "object",
                    "type": [
                        "object"
                    ]
                }
            ],
            "return_type": [
                "object"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/tooltip.js",
            "name": "remove",
            "line": 357,
            "func_location": "Tooltip.prototype.setContent",
            "func_start_line": 338,
            "func_end_line": 358,
            "args": [
                {
                    "type": "string"
                },
                {
                    "type": "string"
                },
                {
                    "type": "string"
                },
                {
                    "type": "string"
                },
                {
                    "type": "string"
                },
                {
                    "type": "string"
                }
            ],
            "code": "Tooltip.prototype.setContent = function () {\r\n  var tip = this.getTooltipElement()\r\n\r\n  if (this.options.class) {\r\n    tip.classList.add(this.options.class)\r\n  }\r\n\r\n  var inner = tip.querySelector('.tooltip-inner')\r\n  if (this.options.item) {\r\n    inner.appendChild(this.viewRegistry.getView(this.options.item))\r\n  } else {\r\n    var title = this.getTitle()\r\n    if (this.options.html) {\r\n      inner.innerHTML = title\r\n    } else {\r\n      inner.textContent = title\r\n    }\r\n  }\r\n\r\n  tip.classList.remove('fade', 'in', 'top', 'bottom', 'left', 'right')\r\n}\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "transact",
            "line": 1073,
            "func_location": "Config.setDefaults",
            "func_start_line": 1070,
            "func_end_line": 1090
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.transact",
            "start_line": 816,
            "end_line": 823,
            "comment": [
                " Extended: Suppress calls to handler functions registered with {::onDidChange}",
                " and {::observe} for the duration of `callback`. After `callback` executes,",
                " handlers will be called once if the value for their key-path has changed.",
                "",
                " * `callback` {Function} to execute while suppressing calls to handlers."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "update",
            "line": 1068,
            "func_location": "TextEditor.setEditorWidthInChars",
            "func_start_line": 1068,
            "func_end_line": 1068,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Set the number of characters that can be displayed horizontally in the",
                " editor.",
                "",
                " * `editorWidthInChars` A {Number} representing the width of the",
                " {TextEditorElement} in characters."
            ],
            "code": "  setEditorWidthInChars (editorWidthInChars) { this.update({editorWidthInChars}) }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.update",
            "start_line": 320,
            "end_line": 539,
            "comment": [],
            "params": [
                "params"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "getBuffer",
            "line": 197,
            "func_location": "TextEditorRegistry.setGrammarOverride",
            "func_start_line": 196,
            "func_end_line": 198,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": "languageId",
                    "type": [
                        "string"
                    ]
                }
            ],
            "comment": [
                " Deprecated: Force a {TextEditor} to use a different grammar than the",
                " one that would otherwise be selected for it.",
                "",
                " * `editor` The editor whose gramamr will be set.",
                " * `languageId` The {String} language ID for the desired {Grammar}."
            ],
            "code": "  setGrammarOverride (editor, languageId) {\r\n    atom.grammars.assignLanguageMode(editor.getBuffer(), languageId)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.getBuffer",
            "start_line": 963,
            "end_line": 963,
            "comment": [
                " Essential: Retrieves the current {TextBuffer}."
            ],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/decoration.js",
            "name": "translateDecorationParamsOldToNew",
            "line": 167,
            "func_location": "Decoration.setProperties",
            "func_start_line": 164,
            "func_end_line": 173,
            "args": [
                {
                    "name": "newProperties",
                    "type": [
                        "number",
                        "object"
                    ]
                }
            ],
            "comment": [
                " Essential: Update the marker with new Properties. Allows you to change the decoration's class.",
                "",
                " ## Examples",
                "",
                " ```coffee",
                " decoration.setProperties({type: 'line-number', class: 'my-new-class'})",
                " ```",
                "",
                " * `newProperties` {Object} eg. `{type: 'line-number', class: 'my-new-class'}`"
            ],
            "code": "  setProperties (newProperties) {\r\n    if (this.destroyed) { return }\r\n    const oldProperties = this.properties\r\n    this.properties = translateDecorationParamsOldToNew(newProperties)\r\n    if (newProperties.type != null) {\r\n      this.decorationManager.decorationDidChangeType(this)\r\n    }\r\n    this.decorationManager.emitDidUpdateDecorations()\r\n    return this.emitter.emit('did-change-properties', {oldProperties, newProperties})\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/decoration.js",
            "name": "translateDecorationParamsOldToNew",
            "start_line": 8,
            "end_line": 13,
            "comment": [
                " Applies changes to a decorationsParam {Object} to make it possible to",
                " differentiate decorations on custom gutters versus the line-number gutter."
            ],
            "params": [
                {
                    "name": "decorationParams",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/decoration.js",
            "name": "translateDecorationParamsOldToNew",
            "line": 167,
            "func_location": "Decoration.setProperties",
            "func_start_line": 164,
            "func_end_line": 173,
            "args": [
                {
                    "name": "newProperties",
                    "type": [
                        "number",
                        "object"
                    ]
                }
            ],
            "comment": [
                " Essential: Update the marker with new Properties. Allows you to change the decoration's class.",
                "",
                " ## Examples",
                "",
                " ```coffee",
                " decoration.setProperties({type: 'line-number', class: 'my-new-class'})",
                " ```",
                "",
                " * `newProperties` {Object} eg. `{type: 'line-number', class: 'my-new-class'}`"
            ],
            "code": "  setProperties (newProperties) {\r\n    if (this.destroyed) { return }\r\n    const oldProperties = this.properties\r\n    this.properties = translateDecorationParamsOldToNew(newProperties)\r\n    if (newProperties.type != null) {\r\n      this.decorationManager.decorationDidChangeType(this)\r\n    }\r\n    this.decorationManager.emitDidUpdateDecorations()\r\n    return this.emitter.emit('did-change-properties', {oldProperties, newProperties})\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/decoration.js",
            "name": "translateDecorationParamsOldToNew",
            "start_line": 8,
            "end_line": 13,
            "comment": [
                " Applies changes to a decorationsParam {Object} to make it possible to",
                " differentiate decorations on custom gutters versus the line-number gutter."
            ],
            "params": [
                {
                    "name": "decorationParams",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "priorityForSource",
            "line": 1240,
            "func_location": "Config.setRawScopedValue",
            "func_start_line": 1231,
            "func_end_line": 1242,
            "args": [
                "source",
                "settingsBySelector",
                null
            ],
            "code": "  setRawScopedValue (keyPath, value, source, selector, options) {\r\n    if (keyPath != null) {\r\n      const newValue = {}\r\n      setValueAtKeyPath(newValue, keyPath, value)\r\n      value = newValue\r\n    }\r\n\r\n    const settingsBySelector = {}\r\n    settingsBySelector[selector] = value\r\n    this.scopedSettingsStore.addProperties(source, settingsBySelector, {priority: this.priorityForSource(source)})\r\n    return this.emitChangeEvent()\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.priorityForSource",
            "start_line": 1200,
            "end_line": 1209,
            "comment": [
                "\r\n  Section: Private Scoped Settings\r\n  "
            ],
            "params": [
                {
                    "name": "source",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "transact",
            "line": 916,
            "func_location": "Config.setSchema",
            "func_start_line": 895,
            "func_end_line": 921
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.transact",
            "start_line": 816,
            "end_line": 823,
            "comment": [
                " Extended: Suppress calls to handler functions registered with {::onDidChange}",
                " and {::observe} for the duration of `callback`. After `callback` executes,",
                " handlers will be called once if the value for their key-path has changed.",
                "",
                " * `callback` {Function} to execute while suppressing calls to handlers."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "setScopedDefaultsFromSchema",
            "line": 1148,
            "func_location": "Config.setScopedDefaultsFromSchema",
            "func_start_line": 1131,
            "func_end_line": 1151,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": "childValue",
                    "type": []
                }
            ],
            "comment": [
                " `schema` will look something like this",
                "",
                " ```coffee",
                " type: 'string'",
                " default: 'ok'",
                " scopes:",
                "   '.source.js':",
                "     default: 'omg'",
                " ```"
            ],
            "code": "  setScopedDefaultsFromSchema (keyPath, schema) {\r\n    if ((schema.scopes != null) && isPlainObject(schema.scopes)) {\r\n      const scopedDefaults = {}\r\n      for (let scope in schema.scopes) {\r\n        const scopeSchema = schema.scopes[scope]\r\n        if (!scopeSchema.hasOwnProperty('default')) { continue }\r\n        scopedDefaults[scope] = {}\r\n        setValueAtKeyPath(scopedDefaults[scope], keyPath, scopeSchema.default)\r\n      }\r\n      this.scopedSettingsStore.addProperties('schema-default', scopedDefaults)\r\n    }\r\n\r\n    if ((schema.type === 'object') && (schema.properties != null) && isPlainObject(schema.properties)) {\r\n      const keys = splitKeyPath(keyPath)\r\n      for (let key in schema.properties) {\r\n        const childValue = schema.properties[key]\r\n        if (!schema.properties.hasOwnProperty(key)) { continue }\r\n        this.setScopedDefaultsFromSchema(keys.concat([key]).join('.'), childValue)\r\n      }\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.setScopedDefaultsFromSchema",
            "start_line": 1131,
            "end_line": 1151,
            "comment": [
                " `schema` will look something like this",
                "",
                " ```coffee",
                " type: 'string'",
                " default: 'ok'",
                " scopes:",
                "   '.source.js':",
                "     default: 'omg'",
                " ```"
            ],
            "params": [
                {
                    "name": "keyPath",
                    "type": []
                },
                {
                    "name": "schema",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "setScopedDefaultsFromSchema",
            "line": 1148,
            "func_location": "Config.setScopedDefaultsFromSchema",
            "func_start_line": 1131,
            "func_end_line": 1151,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": "childValue",
                    "type": []
                }
            ],
            "comment": [
                " `schema` will look something like this",
                "",
                " ```coffee",
                " type: 'string'",
                " default: 'ok'",
                " scopes:",
                "   '.source.js':",
                "     default: 'omg'",
                " ```"
            ],
            "code": "  setScopedDefaultsFromSchema (keyPath, schema) {\r\n    if ((schema.scopes != null) && isPlainObject(schema.scopes)) {\r\n      const scopedDefaults = {}\r\n      for (let scope in schema.scopes) {\r\n        const scopeSchema = schema.scopes[scope]\r\n        if (!scopeSchema.hasOwnProperty('default')) { continue }\r\n        scopedDefaults[scope] = {}\r\n        setValueAtKeyPath(scopedDefaults[scope], keyPath, scopeSchema.default)\r\n      }\r\n      this.scopedSettingsStore.addProperties('schema-default', scopedDefaults)\r\n    }\r\n\r\n    if ((schema.type === 'object') && (schema.properties != null) && isPlainObject(schema.properties)) {\r\n      const keys = splitKeyPath(keyPath)\r\n      for (let key in schema.properties) {\r\n        const childValue = schema.properties[key]\r\n        if (!schema.properties.hasOwnProperty(key)) { continue }\r\n        this.setScopedDefaultsFromSchema(keys.concat([key]).join('.'), childValue)\r\n      }\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.setScopedDefaultsFromSchema",
            "start_line": 1131,
            "end_line": 1151,
            "comment": [
                " `schema` will look something like this",
                "",
                " ```coffee",
                " type: 'string'",
                " default: 'ok'",
                " scopes:",
                "   '.source.js':",
                "     default: 'omg'",
                " ```"
            ],
            "params": [
                {
                    "name": "keyPath",
                    "type": []
                },
                {
                    "name": "schema",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "setBufferRange",
            "line": 75,
            "func_location": "Selection.setScreenRange",
            "func_start_line": 74,
            "func_end_line": 76,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Modifies the screen range for the selection.",
                "",
                " * `screenRange` The new {Range} to use.",
                " * `options` (optional) {Object} options matching those found in {::setBufferRange}."
            ],
            "code": "  setScreenRange (screenRange, options) {\r\n    return this.setBufferRange(this.editor.bufferRangeForScreenRange(screenRange), options)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.setBufferRange",
            "start_line": 92,
            "end_line": 104,
            "comment": [
                " Public: Modifies the buffer {Range} for the selection.",
                "",
                " * `bufferRange` The new {Range} to select.",
                " * `options` (optional) {Object} with the keys:",
                "   * `preserveFolds` if `true`, the fold settings are preserved after the",
                "     selection moves.",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     range. Defaults to `true` if this is the most recently added selection,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferRange",
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "setBufferRange",
            "line": 75,
            "func_location": "Selection.setScreenRange",
            "func_start_line": 74,
            "func_end_line": 76,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Modifies the screen range for the selection.",
                "",
                " * `screenRange` The new {Range} to use.",
                " * `options` (optional) {Object} options matching those found in {::setBufferRange}."
            ],
            "code": "  setScreenRange (screenRange, options) {\r\n    return this.setBufferRange(this.editor.bufferRangeForScreenRange(screenRange), options)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/selection.js",
            "name": "Selection.setBufferRange",
            "start_line": 92,
            "end_line": 104,
            "comment": [
                " Public: Modifies the buffer {Range} for the selection.",
                "",
                " * `bufferRange` The new {Range} to select.",
                " * `options` (optional) {Object} with the keys:",
                "   * `preserveFolds` if `true`, the fold settings are preserved after the",
                "     selection moves.",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     range. Defaults to `true` if this is the most recently added selection,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferRange",
                    "type": []
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/tooltip.js",
            "name": "replace",
            "line": 244,
            "func_location": "Tooltip.prototype.show",
            "func_start_line": 218,
            "func_end_line": 281,
            "args": [
                "autoToken",
                {
                    "type": "string"
                }
            ],
            "code": "Tooltip.prototype.show = function () {\r\n  if (this.hasContent() && this.enabled) {\r\n    if (this.hideOnClickOutsideOfTooltip) {\r\n      window.addEventListener('click', this.hideOnClickOutsideOfTooltip, true)\r\n    }\r\n\r\n    if (this.hideOnKeydownOutsideOfTooltip) {\r\n      window.addEventListener('keydown', this.hideOnKeydownOutsideOfTooltip, true)\r\n    }\r\n\r\n    var tip = this.getTooltipElement()\r\n    this.startObservingMutations()\r\n    var tipId = this.getUID('tooltip')\r\n\r\n    this.setContent()\r\n    tip.setAttribute('id', tipId)\r\n    this.element.setAttribute('aria-describedby', tipId)\r\n\r\n    if (this.options.animation) tip.classList.add('fade')\r\n\r\n    var placement = typeof this.options.placement === 'function'\r\n      ? this.options.placement.call(this, tip, this.element)\r\n      : this.options.placement\r\n\r\n    var autoToken = /\\s?auto?\\s?/i\r\n    var autoPlace = autoToken.test(placement)\r\n    if (autoPlace) placement = placement.replace(autoToken, '') || 'top'\r\n\r\n    tip.remove()\r\n    tip.style.top = '0px'\r\n    tip.style.left = '0px'\r\n    tip.style.display = 'block'\r\n    tip.classList.add(placement)\r\n\r\n    document.body.appendChild(tip)\r\n\r\n    var pos = this.element.getBoundingClientRect()\r\n    var actualWidth = tip.offsetWidth\r\n    var actualHeight = tip.offsetHeight\r\n\r\n    if (autoPlace) {\r\n      var orgPlacement = placement\r\n      var viewportDim = this.viewport.getBoundingClientRect()\r\n\r\n      placement = placement === 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top'\r\n                : placement === 'top' && pos.top - actualHeight < viewportDim.top ? 'bottom'\r\n                : placement === 'right' && pos.right + actualWidth > viewportDim.width ? 'left'\r\n                : placement === 'left' && pos.left - actualWidth < viewportDim.left ? 'right'\r\n                : placement\r\n\r\n      tip.classList.remove(orgPlacement)\r\n      tip.classList.add(placement)\r\n    }\r\n\r\n    var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)\r\n\r\n    this.applyPlacement(calculatedOffset, placement)\r\n\r\n    var prevHoverState = this.hoverState\r\n    this.hoverState = null\r\n\r\n    if (prevHoverState === 'out') this.leave()\r\n  }\r\n}\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "Project.replace",
            "start_line": 82,
            "end_line": 99,
            "comment": [
                " Layers the contents of a project's file's config",
                " on top of the current global config."
            ],
            "params": [
                {
                    "name": "projectSpecification",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/tooltip.js",
            "name": "remove",
            "line": 246,
            "func_location": "Tooltip.prototype.show",
            "func_start_line": 218,
            "func_end_line": 281,
            "args": [],
            "code": "Tooltip.prototype.show = function () {\r\n  if (this.hasContent() && this.enabled) {\r\n    if (this.hideOnClickOutsideOfTooltip) {\r\n      window.addEventListener('click', this.hideOnClickOutsideOfTooltip, true)\r\n    }\r\n\r\n    if (this.hideOnKeydownOutsideOfTooltip) {\r\n      window.addEventListener('keydown', this.hideOnKeydownOutsideOfTooltip, true)\r\n    }\r\n\r\n    var tip = this.getTooltipElement()\r\n    this.startObservingMutations()\r\n    var tipId = this.getUID('tooltip')\r\n\r\n    this.setContent()\r\n    tip.setAttribute('id', tipId)\r\n    this.element.setAttribute('aria-describedby', tipId)\r\n\r\n    if (this.options.animation) tip.classList.add('fade')\r\n\r\n    var placement = typeof this.options.placement === 'function'\r\n      ? this.options.placement.call(this, tip, this.element)\r\n      : this.options.placement\r\n\r\n    var autoToken = /\\s?auto?\\s?/i\r\n    var autoPlace = autoToken.test(placement)\r\n    if (autoPlace) placement = placement.replace(autoToken, '') || 'top'\r\n\r\n    tip.remove()\r\n    tip.style.top = '0px'\r\n    tip.style.left = '0px'\r\n    tip.style.display = 'block'\r\n    tip.classList.add(placement)\r\n\r\n    document.body.appendChild(tip)\r\n\r\n    var pos = this.element.getBoundingClientRect()\r\n    var actualWidth = tip.offsetWidth\r\n    var actualHeight = tip.offsetHeight\r\n\r\n    if (autoPlace) {\r\n      var orgPlacement = placement\r\n      var viewportDim = this.viewport.getBoundingClientRect()\r\n\r\n      placement = placement === 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top'\r\n                : placement === 'top' && pos.top - actualHeight < viewportDim.top ? 'bottom'\r\n                : placement === 'right' && pos.right + actualWidth > viewportDim.width ? 'left'\r\n                : placement === 'left' && pos.left - actualWidth < viewportDim.left ? 'right'\r\n                : placement\r\n\r\n      tip.classList.remove(orgPlacement)\r\n      tip.classList.add(placement)\r\n    }\r\n\r\n    var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)\r\n\r\n    this.applyPlacement(calculatedOffset, placement)\r\n\r\n    var prevHoverState = this.hoverState\r\n    this.hoverState = null\r\n\r\n    if (prevHoverState === 'out') this.leave()\r\n  }\r\n}\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/tooltip.js",
            "name": "remove",
            "line": 268,
            "func_location": "Tooltip.prototype.show",
            "func_start_line": 218,
            "func_end_line": 281,
            "args": [
                "orgPlacement"
            ],
            "code": "Tooltip.prototype.show = function () {\r\n  if (this.hasContent() && this.enabled) {\r\n    if (this.hideOnClickOutsideOfTooltip) {\r\n      window.addEventListener('click', this.hideOnClickOutsideOfTooltip, true)\r\n    }\r\n\r\n    if (this.hideOnKeydownOutsideOfTooltip) {\r\n      window.addEventListener('keydown', this.hideOnKeydownOutsideOfTooltip, true)\r\n    }\r\n\r\n    var tip = this.getTooltipElement()\r\n    this.startObservingMutations()\r\n    var tipId = this.getUID('tooltip')\r\n\r\n    this.setContent()\r\n    tip.setAttribute('id', tipId)\r\n    this.element.setAttribute('aria-describedby', tipId)\r\n\r\n    if (this.options.animation) tip.classList.add('fade')\r\n\r\n    var placement = typeof this.options.placement === 'function'\r\n      ? this.options.placement.call(this, tip, this.element)\r\n      : this.options.placement\r\n\r\n    var autoToken = /\\s?auto?\\s?/i\r\n    var autoPlace = autoToken.test(placement)\r\n    if (autoPlace) placement = placement.replace(autoToken, '') || 'top'\r\n\r\n    tip.remove()\r\n    tip.style.top = '0px'\r\n    tip.style.left = '0px'\r\n    tip.style.display = 'block'\r\n    tip.classList.add(placement)\r\n\r\n    document.body.appendChild(tip)\r\n\r\n    var pos = this.element.getBoundingClientRect()\r\n    var actualWidth = tip.offsetWidth\r\n    var actualHeight = tip.offsetHeight\r\n\r\n    if (autoPlace) {\r\n      var orgPlacement = placement\r\n      var viewportDim = this.viewport.getBoundingClientRect()\r\n\r\n      placement = placement === 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top'\r\n                : placement === 'top' && pos.top - actualHeight < viewportDim.top ? 'bottom'\r\n                : placement === 'right' && pos.right + actualWidth > viewportDim.width ? 'left'\r\n                : placement === 'left' && pos.left - actualWidth < viewportDim.left ? 'right'\r\n                : placement\r\n\r\n      tip.classList.remove(orgPlacement)\r\n      tip.classList.add(placement)\r\n    }\r\n\r\n    var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)\r\n\r\n    this.applyPlacement(calculatedOffset, placement)\r\n\r\n    var prevHoverState = this.hoverState\r\n    this.hoverState = null\r\n\r\n    if (prevHoverState === 'out') this.leave()\r\n  }\r\n}\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/dock.js",
            "name": "setState",
            "line": 120,
            "func_location": "Dock.show",
            "func_start_line": 119,
            "func_end_line": 121,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Extended: Show the dock without focusing it."
            ],
            "code": "  show () {\r\n    this.setState({visible: true})\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/dock.js",
            "name": "Dock.setState",
            "start_line": 144,
            "end_line": 177,
            "comment": [],
            "params": [
                "newState"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "flattenMenuItems",
            "line": 110,
            "func_location": "ApplicationMenu.showUpdateMenuItem",
            "func_start_line": 109,
            "func_end_line": 140,
            "args": [
                {
                    "name": ".menu",
                    "type": []
                }
            ],
            "comment": [
                " Sets the proper visible state the update menu items"
            ],
            "code": "  showUpdateMenuItem (state) {\r\n    const items = this.flattenMenuItems(this.menu)\r\n    const checkForUpdateItem = items.find(({label}) => label === 'Check for Update')\r\n    const checkingForUpdateItem = items.find(({label}) => label === 'Checking for Update')\r\n    const downloadingUpdateItem = items.find(({label}) => label === 'Downloading Update')\r\n    const installUpdateItem = items.find(({label}) => label === 'Restart and Install Update')\r\n\r\n    if (!checkForUpdateItem || !checkingForUpdateItem ||\r\n        !downloadingUpdateItem || !installUpdateItem) return\r\n\r\n    checkForUpdateItem.visible = false\r\n    checkingForUpdateItem.visible = false\r\n    downloadingUpdateItem.visible = false\r\n    installUpdateItem.visible = false\r\n\r\n    switch (state) {\r\n      case 'idle':\r\n      case 'error':\r\n      case 'no-update-available':\r\n        checkForUpdateItem.visible = true\r\n        break\r\n      case 'checking':\r\n        checkingForUpdateItem.visible = true\r\n        break\r\n      case 'downloading':\r\n        downloadingUpdateItem.visible = true\r\n        break\r\n      case 'update-available':\r\n        installUpdateItem.visible = true\r\n        break\r\n    }\r\n  }\r",
            "return_type": [
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "ApplicationMenu.flattenMenuItems",
            "start_line": 67,
            "end_line": 76,
            "comment": [
                " Flattens the given menu and submenu items into an single Array.",
                "",
                " menu - A complete menu configuration object for atom-shell's menu API.",
                "",
                " Returns an Array of native menu items."
            ],
            "params": [
                {
                    "name": "menu",
                    "type": [
                        "array",
                        "object"
                    ]
                }
            ],
            "return_type": [
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "flattenMenuItems",
            "line": 110,
            "func_location": "ApplicationMenu.showUpdateMenuItem",
            "func_start_line": 109,
            "func_end_line": 140,
            "args": [
                {
                    "name": ".menu",
                    "type": []
                }
            ],
            "comment": [
                " Sets the proper visible state the update menu items"
            ],
            "code": "  showUpdateMenuItem (state) {\r\n    const items = this.flattenMenuItems(this.menu)\r\n    const checkForUpdateItem = items.find(({label}) => label === 'Check for Update')\r\n    const checkingForUpdateItem = items.find(({label}) => label === 'Checking for Update')\r\n    const downloadingUpdateItem = items.find(({label}) => label === 'Downloading Update')\r\n    const installUpdateItem = items.find(({label}) => label === 'Restart and Install Update')\r\n\r\n    if (!checkForUpdateItem || !checkingForUpdateItem ||\r\n        !downloadingUpdateItem || !installUpdateItem) return\r\n\r\n    checkForUpdateItem.visible = false\r\n    checkingForUpdateItem.visible = false\r\n    downloadingUpdateItem.visible = false\r\n    installUpdateItem.visible = false\r\n\r\n    switch (state) {\r\n      case 'idle':\r\n      case 'error':\r\n      case 'no-update-available':\r\n        checkForUpdateItem.visible = true\r\n        break\r\n      case 'checking':\r\n        checkingForUpdateItem.visible = true\r\n        break\r\n      case 'downloading':\r\n        downloadingUpdateItem.visible = true\r\n        break\r\n      case 'update-available':\r\n        installUpdateItem.visible = true\r\n        break\r\n    }\r\n  }\r",
            "return_type": [
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "ApplicationMenu.flattenMenuItems",
            "start_line": 67,
            "end_line": 76,
            "comment": [
                " Flattens the given menu and submenu items into an single Array.",
                "",
                " menu - A complete menu configuration object for atom-shell's menu API.",
                "",
                " Returns an Array of native menu items."
            ],
            "params": [
                {
                    "name": "menu",
                    "type": [
                        "array",
                        "object"
                    ]
                }
            ],
            "return_type": [
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "getCurrentLineBufferRange",
            "line": 432,
            "func_location": "Cursor.skipLeadingWhitespace",
            "func_start_line": 430,
            "func_end_line": 439,
            "args": [],
            "comment": [
                " Public: Moves the cursor to the beginning of the buffer line, skipping all",
                " whitespace."
            ],
            "code": "  skipLeadingWhitespace () {\r\n    const position = this.getBufferPosition()\r\n    const scanRange = this.getCurrentLineBufferRange()\r\n    let endOfLeadingWhitespace = null\r\n    this.editor.scanInBufferRange(/^[ \\t]*/, scanRange, ({range}) => {\r\n      endOfLeadingWhitespace = range.end\r\n    })\r\n\r\n    if (endOfLeadingWhitespace.isGreaterThan(position)) this.setBufferPosition(endOfLeadingWhitespace)\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.getCurrentLineBufferRange",
            "start_line": 623,
            "end_line": 625,
            "comment": [
                " Public: Returns the buffer Range for the current line.",
                "",
                " * `options` (optional) {Object}",
                "   * `includeNewline` A {Boolean} which controls whether the Range should",
                "     include the newline."
            ],
            "params": [
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 438,
            "func_location": "Cursor.skipLeadingWhitespace",
            "func_start_line": 430,
            "func_end_line": 439,
            "args": [
                {
                    "name": "position",
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the beginning of the buffer line, skipping all",
                " whitespace."
            ],
            "code": "  skipLeadingWhitespace () {\r\n    const position = this.getBufferPosition()\r\n    const scanRange = this.getCurrentLineBufferRange()\r\n    let endOfLeadingWhitespace = null\r\n    this.editor.scanInBufferRange(/^[ \\t]*/, scanRange, ({range}) => {\r\n      endOfLeadingWhitespace = range.end\r\n    })\r\n\r\n    if (endOfLeadingWhitespace.isGreaterThan(position)) this.setBufferPosition(endOfLeadingWhitespace)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "setBufferPosition",
            "line": 438,
            "func_location": "Cursor.skipLeadingWhitespace",
            "func_start_line": 430,
            "func_end_line": 439,
            "args": [
                {
                    "name": "position",
                    "type": []
                }
            ],
            "comment": [
                " Public: Moves the cursor to the beginning of the buffer line, skipping all",
                " whitespace."
            ],
            "code": "  skipLeadingWhitespace () {\r\n    const position = this.getBufferPosition()\r\n    const scanRange = this.getCurrentLineBufferRange()\r\n    let endOfLeadingWhitespace = null\r\n    this.editor.scanInBufferRange(/^[ \\t]*/, scanRange, ({range}) => {\r\n      endOfLeadingWhitespace = range.end\r\n    })\r\n\r\n    if (endOfLeadingWhitespace.isGreaterThan(position)) this.setBufferPosition(endOfLeadingWhitespace)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/cursor.js",
            "name": "Cursor.setBufferPosition",
            "start_line": 84,
            "end_line": 88,
            "comment": [
                " Public: Moves a cursor to a given buffer position.",
                "",
                " * `bufferPosition` {Array} of two numbers: the buffer row, and the buffer column.",
                " * `options` (optional) {Object} with the following keys:",
                "   * `autoscroll` {Boolean} indicating whether to autoscroll to the new",
                "     position. Defaults to `true` if this is the most recently added cursor,",
                "     `false` otherwise."
            ],
            "params": [
                {
                    "name": "bufferPosition",
                    "type": [
                        "number",
                        "array"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/menu-sort-helpers.js",
            "name": "visit",
            "line": 67,
            "func_location": "sortTopologically",
            "func_start_line": 49,
            "func_end_line": 69,
            "args": [
                {
                    "name": "visit",
                    "type": []
                }
            ],
            "comment": [
                " Sort nodes topologically using a depth-first approach. Encountered cycles",
                " are broken."
            ],
            "code": "function sortTopologically (originalOrder, edgesById) {\r\n  const sorted = []\r\n  const marked = new Set()\r\n\r\n  function visit (id) {\r\n    if (marked.has(id)) {\r\n      // Either this node has already been placed, or we have encountered a\r\n      // cycle and need to exit.\r\n      return\r\n    }\r\n    marked.add(id)\r\n    const edges = edgesById.get(id)\r\n    if (edges != null) {\r\n      edges.forEach(visit)\r\n    }\r\n    sorted.push(id)\r\n  }\r\n\r\n  originalOrder.forEach(visit)\r\n  return sorted\r\n}\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/menu-sort-helpers.js",
            "name": "sortTopologically.visit",
            "start_line": 53,
            "end_line": 65,
            "comment": [],
            "params": [
                "id"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/buffered-process.js",
            "name": "clone",
            "line": 99,
            "func_location": "BufferedProcess.spawnWithEscapedWindowsArgs",
            "func_start_line": 79,
            "func_end_line": 103,
            "args": [
                {
                    "name": "options",
                    "type": []
                }
            ],
            "comment": [
                " Windows has a bunch of special rules that node still doesn't take care of for you"
            ],
            "code": "  spawnWithEscapedWindowsArgs (command, args, options) {\r\n    let cmdArgs = []\r\n    // Quote all arguments and escapes inner quotes\r\n    if (args) {\r\n      cmdArgs = args.filter((arg) => arg != null)\r\n        .map((arg) => {\r\n          if (this.isExplorerCommand(command) && /^\\/[a-zA-Z]+,.*$/.test(arg)) {\r\n            // Don't wrap /root,C:\\folder style arguments to explorer calls in\r\n            // quotes since they will not be interpreted correctly if they are\r\n            return arg\r\n          } else {\r\n            // Escape double quotes by putting a backslash in front of them\r\n            return `\\\"${arg.toString().replace(/\"/g, '\\\\\"')}\\\"`\r\n          }\r\n        })\r\n    }\r\n\r\n    // The command itself is quoted if it contains spaces, &, ^, | or # chars\r\n    cmdArgs.unshift(/\\s|&|\\^|\\(|\\)|\\||#/.test(command) ? `\\\"${command}\\\"` : command)\r\n\r\n    const cmdOptions = _.clone(options)\r\n    cmdOptions.windowsVerbatimArguments = true\r\n\r\n    this.spawn(this.getCmdPath(), ['/s', '/d', '/c', `\\\"${cmdArgs.join(' ')}\\\"`], cmdOptions)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/color.js",
            "name": "Color.clone",
            "start_line": 111,
            "end_line": 113,
            "comment": [],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/buffered-process.js",
            "name": "spawn",
            "line": 102,
            "func_location": "BufferedProcess.spawnWithEscapedWindowsArgs",
            "func_start_line": 79,
            "func_end_line": 103,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": "cmdOptions",
                    "type": []
                }
            ],
            "comment": [
                " Windows has a bunch of special rules that node still doesn't take care of for you"
            ],
            "code": "  spawnWithEscapedWindowsArgs (command, args, options) {\r\n    let cmdArgs = []\r\n    // Quote all arguments and escapes inner quotes\r\n    if (args) {\r\n      cmdArgs = args.filter((arg) => arg != null)\r\n        .map((arg) => {\r\n          if (this.isExplorerCommand(command) && /^\\/[a-zA-Z]+,.*$/.test(arg)) {\r\n            // Don't wrap /root,C:\\folder style arguments to explorer calls in\r\n            // quotes since they will not be interpreted correctly if they are\r\n            return arg\r\n          } else {\r\n            // Escape double quotes by putting a backslash in front of them\r\n            return `\\\"${arg.toString().replace(/\"/g, '\\\\\"')}\\\"`\r\n          }\r\n        })\r\n    }\r\n\r\n    // The command itself is quoted if it contains spaces, &, ^, | or # chars\r\n    cmdArgs.unshift(/\\s|&|\\^|\\(|\\)|\\||#/.test(command) ? `\\\"${command}\\\"` : command)\r\n\r\n    const cmdOptions = _.clone(options)\r\n    cmdOptions.windowsVerbatimArguments = true\r\n\r\n    this.spawn(this.getCmdPath(), ['/s', '/d', '/c', `\\\"${cmdArgs.join(' ')}\\\"`], cmdOptions)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/buffered-process.js",
            "name": "BufferedProcess.spawn",
            "start_line": 244,
            "end_line": 250,
            "comment": [],
            "params": [
                "command",
                "args",
                "options"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/buffered-process.js",
            "name": "getCmdPath",
            "line": 102,
            "func_location": "BufferedProcess.spawnWithEscapedWindowsArgs",
            "func_start_line": 79,
            "func_end_line": 103,
            "args": [
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                },
                {
                    "name": "cmdOptions",
                    "type": []
                }
            ],
            "comment": [
                " Windows has a bunch of special rules that node still doesn't take care of for you"
            ],
            "code": "  spawnWithEscapedWindowsArgs (command, args, options) {\r\n    let cmdArgs = []\r\n    // Quote all arguments and escapes inner quotes\r\n    if (args) {\r\n      cmdArgs = args.filter((arg) => arg != null)\r\n        .map((arg) => {\r\n          if (this.isExplorerCommand(command) && /^\\/[a-zA-Z]+,.*$/.test(arg)) {\r\n            // Don't wrap /root,C:\\folder style arguments to explorer calls in\r\n            // quotes since they will not be interpreted correctly if they are\r\n            return arg\r\n          } else {\r\n            // Escape double quotes by putting a backslash in front of them\r\n            return `\\\"${arg.toString().replace(/\"/g, '\\\\\"')}\\\"`\r\n          }\r\n        })\r\n    }\r\n\r\n    // The command itself is quoted if it contains spaces, &, ^, | or # chars\r\n    cmdArgs.unshift(/\\s|&|\\^|\\(|\\)|\\||#/.test(command) ? `\\\"${command}\\\"` : command)\r\n\r\n    const cmdOptions = _.clone(options)\r\n    cmdOptions.windowsVerbatimArguments = true\r\n\r\n    this.spawn(this.getCmdPath(), ['/s', '/d', '/c', `\\\"${cmdArgs.join(' ')}\\\"`], cmdOptions)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/buffered-process.js",
            "name": "BufferedProcess.getCmdPath",
            "start_line": 222,
            "end_line": 230,
            "comment": [],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/buffered-process.js",
            "name": "spawnWithEscapedWindowsArgs",
            "line": 71,
            "func_location": "BufferedProcess.start",
            "func_start_line": 65,
            "func_end_line": 76,
            "args": [
                ".command",
                ".args",
                ".options"
            ],
            "code": "  start () {\r\n    if (this.started === true) return\r\n\r\n    this.started = true\r\n    // Related to joyent/node#2318\r\n    if (process.platform === 'win32' && this.options.shell === undefined) {\r\n      this.spawnWithEscapedWindowsArgs(this.command, this.args, this.options)\r\n    } else {\r\n      this.spawn(this.command, this.args, this.options)\r\n    }\r\n    this.handleEvents(this.stdout, this.stderr, this.exit)\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/buffered-process.js",
            "name": "BufferedProcess.spawnWithEscapedWindowsArgs",
            "start_line": 79,
            "end_line": 103,
            "comment": [
                " Windows has a bunch of special rules that node still doesn't take care of for you"
            ],
            "params": [
                {
                    "name": "command",
                    "type": []
                },
                {
                    "name": "args",
                    "type": []
                },
                {
                    "name": "options",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/theme-manager.js",
            "name": "replace",
            "line": 229,
            "func_location": "ThemeManager.stylesheetElementForId",
            "func_start_line": 228,
            "func_end_line": 231,
            "args": [
                {
                    "type": "object"
                },
                {
                    "type": "string"
                }
            ],
            "code": "  stylesheetElementForId (id) {\r\n    const escapedId = id.replace(/\\\\/g, '\\\\\\\\')\r\n    return document.head.querySelector(`atom-styles style[source-path=\"${escapedId}\"]`)\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "Project.replace",
            "start_line": 82,
            "end_line": 99,
            "comment": [
                " Layers the contents of a project's file's config",
                " on top of the current global config."
            ],
            "params": [
                {
                    "name": "projectSpecification",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "onDidSave",
            "line": 503,
            "func_location": "GitRepository.subscribeToBuffer",
            "func_start_line": 495,
            "func_end_line": 511,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Private\r\n  ",
                " Subscribes to buffer events."
            ],
            "code": "  subscribeToBuffer (buffer) {\r\n    const getBufferPathStatus = () => {\r\n      const bufferPath = buffer.getPath()\r\n      if (bufferPath) this.getPathStatus(bufferPath)\r\n    }\r\n\r\n    getBufferPathStatus()\r\n    const bufferSubscriptions = new CompositeDisposable()\r\n    bufferSubscriptions.add(buffer.onDidSave(getBufferPathStatus))\r\n    bufferSubscriptions.add(buffer.onDidReload(getBufferPathStatus))\r\n    bufferSubscriptions.add(buffer.onDidChangePath(getBufferPathStatus))\r\n    bufferSubscriptions.add(buffer.onDidDestroy(() => {\r\n      bufferSubscriptions.dispose()\r\n      return this.subscriptions.remove(bufferSubscriptions)\r\n    }))\r\n    this.subscriptions.add(bufferSubscriptions)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.onDidSave",
            "start_line": 814,
            "end_line": 816,
            "comment": [
                " Essential: Invoke the given callback after the buffer is saved to disk.",
                "",
                " * `callback` {Function} to be called after the buffer is saved.",
                "   * `event` {Object} with the following keys:",
                "     * `path` The path to which the buffer was saved.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/git-repository.js",
            "name": "onDidSave",
            "line": 503,
            "func_location": "GitRepository.subscribeToBuffer",
            "func_start_line": 495,
            "func_end_line": 511,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Private\r\n  ",
                " Subscribes to buffer events."
            ],
            "code": "  subscribeToBuffer (buffer) {\r\n    const getBufferPathStatus = () => {\r\n      const bufferPath = buffer.getPath()\r\n      if (bufferPath) this.getPathStatus(bufferPath)\r\n    }\r\n\r\n    getBufferPathStatus()\r\n    const bufferSubscriptions = new CompositeDisposable()\r\n    bufferSubscriptions.add(buffer.onDidSave(getBufferPathStatus))\r\n    bufferSubscriptions.add(buffer.onDidReload(getBufferPathStatus))\r\n    bufferSubscriptions.add(buffer.onDidChangePath(getBufferPathStatus))\r\n    bufferSubscriptions.add(buffer.onDidDestroy(() => {\r\n      bufferSubscriptions.dispose()\r\n      return this.subscriptions.remove(bufferSubscriptions)\r\n    }))\r\n    this.subscriptions.add(bufferSubscriptions)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.onDidSave",
            "start_line": 814,
            "end_line": 816,
            "comment": [
                " Essential: Invoke the given callback after the buffer is saved to disk.",
                "",
                " * `callback` {Function} to be called after the buffer is saved.",
                "   * `event` {Object} with the following keys:",
                "     * `path` The path to which the buffer was saved.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "onDidChangeEncoding",
            "line": 588,
            "func_location": "TextEditor.subscribeToBuffer",
            "func_start_line": 581,
            "func_end_line": 595
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.onDidChangeEncoding",
            "start_line": 735,
            "end_line": 737,
            "comment": [
                " Extended: Calls your `callback` when the buffer's encoding has changed.",
                "",
                " * `callback` {Function}",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/workspace.js",
            "name": "onDidChangePaths",
            "line": 321,
            "func_location": "Workspace.subscribeToEvents",
            "func_start_line": 320,
            "func_end_line": 326,
            "args": [
                ".updateWindowTitle"
            ],
            "code": "  subscribeToEvents () {\r\n    this.project.onDidChangePaths(this.updateWindowTitle)\r\n    this.subscribeToFontSize()\r\n    this.subscribeToAddedItems()\r\n    this.subscribeToMovedItems()\r\n    this.subscribeToDockToggling()\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/project.js",
            "name": "Project.onDidChangePaths",
            "start_line": 168,
            "end_line": 170,
            "comment": [
                "\r\n  Section: Event Subscription\r\n  ",
                " Public: Invoke the given callback when the project paths change.",
                "",
                " * `callback` {Function} to be called after the project paths change.",
                "    * `projectPaths` An {Array} of {String} project paths.",
                "",
                " Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            ],
            "params": [
                {
                    "name": "callback",
                    "type": [
                        "function"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "flattenMenuTemplate",
            "line": 104,
            "func_location": "ApplicationMenu.substituteVersion",
            "func_start_line": 103,
            "func_end_line": 106,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Replaces VERSION with the current version."
            ],
            "code": "  substituteVersion (template) {\r\n    let item = this.flattenMenuTemplate(template).find(({label}) => label === 'VERSION')\r\n    if (item) item.label = `Version ${this.version}`\r\n  }\r",
            "return_type": [
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "ApplicationMenu.flattenMenuTemplate",
            "start_line": 83,
            "end_line": 90,
            "comment": [
                " Flattens the given menu template into an single Array.",
                "",
                " template - An object describing the menu item.",
                "",
                " Returns an Array of native menu items."
            ],
            "params": [
                {
                    "name": "template",
                    "type": [
                        "array",
                        "object"
                    ]
                }
            ],
            "return_type": [
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "flattenMenuTemplate",
            "line": 104,
            "func_location": "ApplicationMenu.substituteVersion",
            "func_start_line": 103,
            "func_end_line": 106,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Replaces VERSION with the current version."
            ],
            "code": "  substituteVersion (template) {\r\n    let item = this.flattenMenuTemplate(template).find(({label}) => label === 'VERSION')\r\n    if (item) item.label = `Version ${this.version}`\r\n  }\r",
            "return_type": [
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "ApplicationMenu.flattenMenuTemplate",
            "start_line": 83,
            "end_line": 90,
            "comment": [
                " Flattens the given menu template into an single Array.",
                "",
                " template - An object describing the menu item.",
                "",
                " Returns an Array of native menu items."
            ],
            "params": [
                {
                    "name": "template",
                    "type": [
                        "array",
                        "object"
                    ]
                }
            ],
            "return_type": [
                "array"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/dock.js",
            "name": "setState",
            "line": 134,
            "func_location": "Dock.toggle",
            "func_start_line": 131,
            "func_end_line": 135,
            "args": [
                {
                    "name": "state",
                    "type": []
                }
            ],
            "comment": [
                " Extended: Toggle the dock's visibility without changing the {Workspace}'s",
                " active pane container."
            ],
            "code": "  toggle () {\r\n    const state = {visible: !this.state.visible}\r\n    if (!state.visible) state.hovered = false\r\n    this.setState(state)\r\n  }\r",
            "return_type": [
                "array"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/dock.js",
            "name": "Dock.setState",
            "start_line": 144,
            "end_line": 177,
            "comment": [],
            "params": [
                "newState"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/style-manager.js",
            "name": "parse",
            "line": 267,
            "func_location": "transformDeprecatedShadowDOMSelectors",
            "func_start_line": 263,
            "func_end_line": 331,
            "args": [
                "css"
            ],
            "code": "function transformDeprecatedShadowDOMSelectors (css, context) {\r\n  const transformedSelectors = []\r\n  let transformedSource\r\n  try {\r\n    transformedSource = postcss.parse(css)\r\n  } catch (e) {\r\n    transformedSource = null\r\n  }\r\n\r\n  if (transformedSource) {\r\n    transformedSource.walkRules((rule) => {\r\n      const transformedSelector = selectorParser((selectors) => {\r\n        selectors.each((selector) => {\r\n          const firstNode = selector.nodes[0]\r\n          if (context === 'atom-text-editor' && firstNode.type === 'pseudo' && firstNode.value === ':host') {\r\n            const atomTextEditorElementNode = selectorParser.tag({value: 'atom-text-editor'})\r\n            firstNode.replaceWith(atomTextEditorElementNode)\r\n          }\r\n\r\n          let previousNodeIsAtomTextEditor = false\r\n          let targetsAtomTextEditorShadow = context === 'atom-text-editor'\r\n          let previousNode\r\n          selector.each((node) => {\r\n            if (targetsAtomTextEditorShadow && node.type === 'class') {\r\n              if (DEPRECATED_SYNTAX_SELECTORS.has(node.value)) {\r\n                node.value = `syntax--${node.value}`\r\n              }\r\n            } else {\r\n              if (previousNodeIsAtomTextEditor && node.type === 'pseudo' && node.value === '::shadow') {\r\n                node.type = 'className'\r\n                node.value = '.editor'\r\n                targetsAtomTextEditorShadow = true\r\n              }\r\n            }\r\n\r\n            previousNode = node\r\n            if (node.type === 'combinator') {\r\n              previousNodeIsAtomTextEditor = false\r\n            } else if (previousNode.type === 'tag' && previousNode.value === 'atom-text-editor') {\r\n              previousNodeIsAtomTextEditor = true\r\n            }\r\n          })\r\n        })\r\n      }).process(rule.selector, {lossless: true}).result\r\n      if (transformedSelector !== rule.selector) {\r\n        transformedSelectors.push({before: rule.selector, after: transformedSelector})\r\n        rule.selector = transformedSelector\r\n      }\r\n    })\r\n    let deprecationMessage\r\n    if (transformedSelectors.length > 0) {\r\n      deprecationMessage = 'Starting from Atom v1.13.0, the contents of `atom-text-editor` elements '\r\n      deprecationMessage += 'are no longer encapsulated within a shadow DOM boundary. '\r\n      deprecationMessage += 'This means you should stop using `:host` and `::shadow` '\r\n      deprecationMessage += 'pseudo-selectors, and prepend all your syntax selectors with `syntax--`. '\r\n      deprecationMessage += 'To prevent breakage with existing style sheets, Atom will automatically '\r\n      deprecationMessage += 'upgrade the following selectors:\\n\\n'\r\n      deprecationMessage += transformedSelectors\r\n        .map((selector) => `* \\`${selector.before}\\` => \\`${selector.after}\\``)\r\n        .join('\\n\\n') + '\\n\\n'\r\n      deprecationMessage += 'Automatic translation of selectors will be removed in a few release cycles to minimize startup time. '\r\n      deprecationMessage += 'Please, make sure to upgrade the above selectors as soon as possible.'\r\n    }\r\n    return {source: transformedSource.toString(), deprecationMessage}\r\n  } else {\r\n    // CSS was malformed so we don't transform it.\r\n    return {source: css}\r\n  }\r\n}\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/color.js",
            "name": "Color.parse",
            "start_line": 14,
            "end_line": 36,
            "comment": [
                " Essential: Parse a {String} or {Object} into a {Color}.",
                "",
                " * `value` A {String} such as `'white'`, `#ff00ff`, or",
                "   `'rgba(255, 15, 60, .75)'` or an {Object} with `red`, `green`, `blue`,",
                "   and `alpha` properties.",
                "",
                " Returns a {Color} or `null` if it cannot be parsed."
            ],
            "params": [
                {
                    "name": "value",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "null"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "set",
            "line": 746,
            "func_location": "Config.unset",
            "func_start_line": 730,
            "func_end_line": 766,
            "args": [
                {
                    "name": {
                        "type": "object"
                    },
                    "type": []
                },
                {
                    "name": "settings",
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Essential: Restore the setting at `keyPath` to its default value.",
                "",
                " * `keyPath` The {String} name of the key.",
                " * `options` (optional) {Object}",
                "   * `scopeSelector` (optional) {String}. See {::set}",
                "   * `source` (optional) {String}. See {::set}"
            ],
            "code": "  unset (keyPath, options) {\r\n    if (!this.settingsLoaded) {\r\n      this.pendingOperations.push(() => this.unset(keyPath, options))\r\n    }\r\n\r\n    let {scopeSelector, source} = options != null ? options : {}\r\n    if (source == null) { source = this.mainSource }\r\n\r\n    if (scopeSelector != null) {\r\n      if (keyPath != null) {\r\n        let settings = this.scopedSettingsStore.propertiesForSourceAndSelector(source, scopeSelector)\r\n        if (getValueAtKeyPath(settings, keyPath) != null) {\r\n          this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n          setValueAtKeyPath(settings, keyPath, undefined)\r\n          settings = withoutEmptyObjects(settings)\r\n          if (settings != null) {\r\n            this.set(null, settings, {scopeSelector, source, priority: this.priorityForSource(source)})\r\n          }\r\n\r\n          const configIsReady = (source === this.mainSource) && this.settingsLoaded\r\n          if (configIsReady) {\r\n            return this.requestSave()\r\n          }\r\n        }\r\n      } else {\r\n        this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n        return this.emitChangeEvent()\r\n      }\r\n    } else {\r\n      for (scopeSelector in this.scopedSettingsStore.propertiesForSource(source)) {\r\n        this.unset(keyPath, {scopeSelector, source})\r\n      }\r\n      if ((keyPath != null) && (source === this.mainSource)) {\r\n        return this.set(keyPath, getValueAtKeyPath(this.defaultSettings, keyPath))\r\n      }\r\n    }\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.set",
            "start_line": 687,
            "end_line": 722,
            "comment": [
                " Essential: Sets the value for a configuration setting.",
                "",
                " This value is stored in Atom's internal configuration file.",
                "",
                " ### Examples",
                "",
                " You might want to change the themes programmatically:",
                "",
                " ```coffee",
                " atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])",
                " ```",
                "",
                " You can also set scoped settings. For example, you might want change the",
                " `editor.tabLength` only for ruby files.",
                "",
                " ```coffee",
                " atom.config.get('editor.tabLength') # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",
                "",
                " # Set ruby to 2",
                " atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true",
                "",
                " # Notice it's only set to 2 in the case of ruby",
                " atom.config.get('editor.tabLength') # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2",
                " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",
                " ```",
                "",
                " * `keyPath` The {String} name of the key.",
                " * `value` The value of the setting. Passing `undefined` will revert the",
                "   setting to the default value.",
                " * `options` (optional) {Object}",
                "   * `scopeSelector` (optional) {String}. eg. '.source.ruby'",
                "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)",
                "     for more information.",
                "   * `source` (optional) {String} The name of a file with which the setting",
                "     is associated. Defaults to the user's config file.",
                "",
                " Returns a {Boolean}",
                " * `true` if the value was set.",
                " * `false` if the value was not able to be coerced to the type specified in the setting's schema."
            ],
            "params": [
                {
                    "name": "args",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "set",
            "line": 746,
            "func_location": "Config.unset",
            "func_start_line": 730,
            "func_end_line": 766,
            "args": [
                {
                    "name": {
                        "type": "object"
                    },
                    "type": []
                },
                {
                    "name": "settings",
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Essential: Restore the setting at `keyPath` to its default value.",
                "",
                " * `keyPath` The {String} name of the key.",
                " * `options` (optional) {Object}",
                "   * `scopeSelector` (optional) {String}. See {::set}",
                "   * `source` (optional) {String}. See {::set}"
            ],
            "code": "  unset (keyPath, options) {\r\n    if (!this.settingsLoaded) {\r\n      this.pendingOperations.push(() => this.unset(keyPath, options))\r\n    }\r\n\r\n    let {scopeSelector, source} = options != null ? options : {}\r\n    if (source == null) { source = this.mainSource }\r\n\r\n    if (scopeSelector != null) {\r\n      if (keyPath != null) {\r\n        let settings = this.scopedSettingsStore.propertiesForSourceAndSelector(source, scopeSelector)\r\n        if (getValueAtKeyPath(settings, keyPath) != null) {\r\n          this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n          setValueAtKeyPath(settings, keyPath, undefined)\r\n          settings = withoutEmptyObjects(settings)\r\n          if (settings != null) {\r\n            this.set(null, settings, {scopeSelector, source, priority: this.priorityForSource(source)})\r\n          }\r\n\r\n          const configIsReady = (source === this.mainSource) && this.settingsLoaded\r\n          if (configIsReady) {\r\n            return this.requestSave()\r\n          }\r\n        }\r\n      } else {\r\n        this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n        return this.emitChangeEvent()\r\n      }\r\n    } else {\r\n      for (scopeSelector in this.scopedSettingsStore.propertiesForSource(source)) {\r\n        this.unset(keyPath, {scopeSelector, source})\r\n      }\r\n      if ((keyPath != null) && (source === this.mainSource)) {\r\n        return this.set(keyPath, getValueAtKeyPath(this.defaultSettings, keyPath))\r\n      }\r\n    }\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.set",
            "start_line": 687,
            "end_line": 722,
            "comment": [
                " Essential: Sets the value for a configuration setting.",
                "",
                " This value is stored in Atom's internal configuration file.",
                "",
                " ### Examples",
                "",
                " You might want to change the themes programmatically:",
                "",
                " ```coffee",
                " atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])",
                " ```",
                "",
                " You can also set scoped settings. For example, you might want change the",
                " `editor.tabLength` only for ruby files.",
                "",
                " ```coffee",
                " atom.config.get('editor.tabLength') # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",
                "",
                " # Set ruby to 2",
                " atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true",
                "",
                " # Notice it's only set to 2 in the case of ruby",
                " atom.config.get('editor.tabLength') # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2",
                " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",
                " ```",
                "",
                " * `keyPath` The {String} name of the key.",
                " * `value` The value of the setting. Passing `undefined` will revert the",
                "   setting to the default value.",
                " * `options` (optional) {Object}",
                "   * `scopeSelector` (optional) {String}. eg. '.source.ruby'",
                "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)",
                "     for more information.",
                "   * `source` (optional) {String} The name of a file with which the setting",
                "     is associated. Defaults to the user's config file.",
                "",
                " Returns a {Boolean}",
                " * `true` if the value was set.",
                " * `false` if the value was not able to be coerced to the type specified in the setting's schema."
            ],
            "params": [
                {
                    "name": "args",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "priorityForSource",
            "line": 746,
            "func_location": "Config.unset",
            "func_start_line": 730,
            "func_end_line": 766,
            "args": [
                {
                    "name": {
                        "type": "object"
                    },
                    "type": []
                },
                {
                    "name": "settings",
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Essential: Restore the setting at `keyPath` to its default value.",
                "",
                " * `keyPath` The {String} name of the key.",
                " * `options` (optional) {Object}",
                "   * `scopeSelector` (optional) {String}. See {::set}",
                "   * `source` (optional) {String}. See {::set}"
            ],
            "code": "  unset (keyPath, options) {\r\n    if (!this.settingsLoaded) {\r\n      this.pendingOperations.push(() => this.unset(keyPath, options))\r\n    }\r\n\r\n    let {scopeSelector, source} = options != null ? options : {}\r\n    if (source == null) { source = this.mainSource }\r\n\r\n    if (scopeSelector != null) {\r\n      if (keyPath != null) {\r\n        let settings = this.scopedSettingsStore.propertiesForSourceAndSelector(source, scopeSelector)\r\n        if (getValueAtKeyPath(settings, keyPath) != null) {\r\n          this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n          setValueAtKeyPath(settings, keyPath, undefined)\r\n          settings = withoutEmptyObjects(settings)\r\n          if (settings != null) {\r\n            this.set(null, settings, {scopeSelector, source, priority: this.priorityForSource(source)})\r\n          }\r\n\r\n          const configIsReady = (source === this.mainSource) && this.settingsLoaded\r\n          if (configIsReady) {\r\n            return this.requestSave()\r\n          }\r\n        }\r\n      } else {\r\n        this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n        return this.emitChangeEvent()\r\n      }\r\n    } else {\r\n      for (scopeSelector in this.scopedSettingsStore.propertiesForSource(source)) {\r\n        this.unset(keyPath, {scopeSelector, source})\r\n      }\r\n      if ((keyPath != null) && (source === this.mainSource)) {\r\n        return this.set(keyPath, getValueAtKeyPath(this.defaultSettings, keyPath))\r\n      }\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.priorityForSource",
            "start_line": 1200,
            "end_line": 1209,
            "comment": [
                "\r\n  Section: Private Scoped Settings\r\n  "
            ],
            "params": [
                {
                    "name": "source",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "priorityForSource",
            "line": 746,
            "func_location": "Config.unset",
            "func_start_line": 730,
            "func_end_line": 766,
            "args": [
                {
                    "name": {
                        "type": "object"
                    },
                    "type": []
                },
                {
                    "name": "settings",
                    "type": []
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Essential: Restore the setting at `keyPath` to its default value.",
                "",
                " * `keyPath` The {String} name of the key.",
                " * `options` (optional) {Object}",
                "   * `scopeSelector` (optional) {String}. See {::set}",
                "   * `source` (optional) {String}. See {::set}"
            ],
            "code": "  unset (keyPath, options) {\r\n    if (!this.settingsLoaded) {\r\n      this.pendingOperations.push(() => this.unset(keyPath, options))\r\n    }\r\n\r\n    let {scopeSelector, source} = options != null ? options : {}\r\n    if (source == null) { source = this.mainSource }\r\n\r\n    if (scopeSelector != null) {\r\n      if (keyPath != null) {\r\n        let settings = this.scopedSettingsStore.propertiesForSourceAndSelector(source, scopeSelector)\r\n        if (getValueAtKeyPath(settings, keyPath) != null) {\r\n          this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n          setValueAtKeyPath(settings, keyPath, undefined)\r\n          settings = withoutEmptyObjects(settings)\r\n          if (settings != null) {\r\n            this.set(null, settings, {scopeSelector, source, priority: this.priorityForSource(source)})\r\n          }\r\n\r\n          const configIsReady = (source === this.mainSource) && this.settingsLoaded\r\n          if (configIsReady) {\r\n            return this.requestSave()\r\n          }\r\n        }\r\n      } else {\r\n        this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n        return this.emitChangeEvent()\r\n      }\r\n    } else {\r\n      for (scopeSelector in this.scopedSettingsStore.propertiesForSource(source)) {\r\n        this.unset(keyPath, {scopeSelector, source})\r\n      }\r\n      if ((keyPath != null) && (source === this.mainSource)) {\r\n        return this.set(keyPath, getValueAtKeyPath(this.defaultSettings, keyPath))\r\n      }\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.priorityForSource",
            "start_line": 1200,
            "end_line": 1209,
            "comment": [
                "\r\n  Section: Private Scoped Settings\r\n  "
            ],
            "params": [
                {
                    "name": "source",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "unset",
            "line": 760,
            "func_location": "Config.unset",
            "func_start_line": 730,
            "func_end_line": 766,
            "args": [
                {
                    "name": "keyPath",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Essential: Restore the setting at `keyPath` to its default value.",
                "",
                " * `keyPath` The {String} name of the key.",
                " * `options` (optional) {Object}",
                "   * `scopeSelector` (optional) {String}. See {::set}",
                "   * `source` (optional) {String}. See {::set}"
            ],
            "code": "  unset (keyPath, options) {\r\n    if (!this.settingsLoaded) {\r\n      this.pendingOperations.push(() => this.unset(keyPath, options))\r\n    }\r\n\r\n    let {scopeSelector, source} = options != null ? options : {}\r\n    if (source == null) { source = this.mainSource }\r\n\r\n    if (scopeSelector != null) {\r\n      if (keyPath != null) {\r\n        let settings = this.scopedSettingsStore.propertiesForSourceAndSelector(source, scopeSelector)\r\n        if (getValueAtKeyPath(settings, keyPath) != null) {\r\n          this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n          setValueAtKeyPath(settings, keyPath, undefined)\r\n          settings = withoutEmptyObjects(settings)\r\n          if (settings != null) {\r\n            this.set(null, settings, {scopeSelector, source, priority: this.priorityForSource(source)})\r\n          }\r\n\r\n          const configIsReady = (source === this.mainSource) && this.settingsLoaded\r\n          if (configIsReady) {\r\n            return this.requestSave()\r\n          }\r\n        }\r\n      } else {\r\n        this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n        return this.emitChangeEvent()\r\n      }\r\n    } else {\r\n      for (scopeSelector in this.scopedSettingsStore.propertiesForSource(source)) {\r\n        this.unset(keyPath, {scopeSelector, source})\r\n      }\r\n      if ((keyPath != null) && (source === this.mainSource)) {\r\n        return this.set(keyPath, getValueAtKeyPath(this.defaultSettings, keyPath))\r\n      }\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.unset",
            "start_line": 730,
            "end_line": 766,
            "comment": [
                " Essential: Restore the setting at `keyPath` to its default value.",
                "",
                " * `keyPath` The {String} name of the key.",
                " * `options` (optional) {Object}",
                "   * `scopeSelector` (optional) {String}. See {::set}",
                "   * `source` (optional) {String}. See {::set}"
            ],
            "params": [
                {
                    "name": "keyPath",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "unset",
            "line": 760,
            "func_location": "Config.unset",
            "func_start_line": 730,
            "func_end_line": 766,
            "args": [
                {
                    "name": "keyPath",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Essential: Restore the setting at `keyPath` to its default value.",
                "",
                " * `keyPath` The {String} name of the key.",
                " * `options` (optional) {Object}",
                "   * `scopeSelector` (optional) {String}. See {::set}",
                "   * `source` (optional) {String}. See {::set}"
            ],
            "code": "  unset (keyPath, options) {\r\n    if (!this.settingsLoaded) {\r\n      this.pendingOperations.push(() => this.unset(keyPath, options))\r\n    }\r\n\r\n    let {scopeSelector, source} = options != null ? options : {}\r\n    if (source == null) { source = this.mainSource }\r\n\r\n    if (scopeSelector != null) {\r\n      if (keyPath != null) {\r\n        let settings = this.scopedSettingsStore.propertiesForSourceAndSelector(source, scopeSelector)\r\n        if (getValueAtKeyPath(settings, keyPath) != null) {\r\n          this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n          setValueAtKeyPath(settings, keyPath, undefined)\r\n          settings = withoutEmptyObjects(settings)\r\n          if (settings != null) {\r\n            this.set(null, settings, {scopeSelector, source, priority: this.priorityForSource(source)})\r\n          }\r\n\r\n          const configIsReady = (source === this.mainSource) && this.settingsLoaded\r\n          if (configIsReady) {\r\n            return this.requestSave()\r\n          }\r\n        }\r\n      } else {\r\n        this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n        return this.emitChangeEvent()\r\n      }\r\n    } else {\r\n      for (scopeSelector in this.scopedSettingsStore.propertiesForSource(source)) {\r\n        this.unset(keyPath, {scopeSelector, source})\r\n      }\r\n      if ((keyPath != null) && (source === this.mainSource)) {\r\n        return this.set(keyPath, getValueAtKeyPath(this.defaultSettings, keyPath))\r\n      }\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.unset",
            "start_line": 730,
            "end_line": 766,
            "comment": [
                " Essential: Restore the setting at `keyPath` to its default value.",
                "",
                " * `keyPath` The {String} name of the key.",
                " * `options` (optional) {Object}",
                "   * `scopeSelector` (optional) {String}. See {::set}",
                "   * `source` (optional) {String}. See {::set}"
            ],
            "params": [
                {
                    "name": "keyPath",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": "options",
                    "type": [
                        "object",
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "set",
            "line": 763,
            "func_location": "Config.unset",
            "func_start_line": 730,
            "func_end_line": 766,
            "args": [
                {
                    "name": "keyPath",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Essential: Restore the setting at `keyPath` to its default value.",
                "",
                " * `keyPath` The {String} name of the key.",
                " * `options` (optional) {Object}",
                "   * `scopeSelector` (optional) {String}. See {::set}",
                "   * `source` (optional) {String}. See {::set}"
            ],
            "code": "  unset (keyPath, options) {\r\n    if (!this.settingsLoaded) {\r\n      this.pendingOperations.push(() => this.unset(keyPath, options))\r\n    }\r\n\r\n    let {scopeSelector, source} = options != null ? options : {}\r\n    if (source == null) { source = this.mainSource }\r\n\r\n    if (scopeSelector != null) {\r\n      if (keyPath != null) {\r\n        let settings = this.scopedSettingsStore.propertiesForSourceAndSelector(source, scopeSelector)\r\n        if (getValueAtKeyPath(settings, keyPath) != null) {\r\n          this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n          setValueAtKeyPath(settings, keyPath, undefined)\r\n          settings = withoutEmptyObjects(settings)\r\n          if (settings != null) {\r\n            this.set(null, settings, {scopeSelector, source, priority: this.priorityForSource(source)})\r\n          }\r\n\r\n          const configIsReady = (source === this.mainSource) && this.settingsLoaded\r\n          if (configIsReady) {\r\n            return this.requestSave()\r\n          }\r\n        }\r\n      } else {\r\n        this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n        return this.emitChangeEvent()\r\n      }\r\n    } else {\r\n      for (scopeSelector in this.scopedSettingsStore.propertiesForSource(source)) {\r\n        this.unset(keyPath, {scopeSelector, source})\r\n      }\r\n      if ((keyPath != null) && (source === this.mainSource)) {\r\n        return this.set(keyPath, getValueAtKeyPath(this.defaultSettings, keyPath))\r\n      }\r\n    }\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.set",
            "start_line": 687,
            "end_line": 722,
            "comment": [
                " Essential: Sets the value for a configuration setting.",
                "",
                " This value is stored in Atom's internal configuration file.",
                "",
                " ### Examples",
                "",
                " You might want to change the themes programmatically:",
                "",
                " ```coffee",
                " atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])",
                " ```",
                "",
                " You can also set scoped settings. For example, you might want change the",
                " `editor.tabLength` only for ruby files.",
                "",
                " ```coffee",
                " atom.config.get('editor.tabLength') # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",
                "",
                " # Set ruby to 2",
                " atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true",
                "",
                " # Notice it's only set to 2 in the case of ruby",
                " atom.config.get('editor.tabLength') # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2",
                " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",
                " ```",
                "",
                " * `keyPath` The {String} name of the key.",
                " * `value` The value of the setting. Passing `undefined` will revert the",
                "   setting to the default value.",
                " * `options` (optional) {Object}",
                "   * `scopeSelector` (optional) {String}. eg. '.source.ruby'",
                "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)",
                "     for more information.",
                "   * `source` (optional) {String} The name of a file with which the setting",
                "     is associated. Defaults to the user's config file.",
                "",
                " Returns a {Boolean}",
                " * `true` if the value was set.",
                " * `false` if the value was not able to be coerced to the type specified in the setting's schema."
            ],
            "params": [
                {
                    "name": "args",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "set",
            "line": 763,
            "func_location": "Config.unset",
            "func_start_line": 730,
            "func_end_line": 766,
            "args": [
                {
                    "name": "keyPath",
                    "type": [
                        "string"
                    ]
                },
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " Essential: Restore the setting at `keyPath` to its default value.",
                "",
                " * `keyPath` The {String} name of the key.",
                " * `options` (optional) {Object}",
                "   * `scopeSelector` (optional) {String}. See {::set}",
                "   * `source` (optional) {String}. See {::set}"
            ],
            "code": "  unset (keyPath, options) {\r\n    if (!this.settingsLoaded) {\r\n      this.pendingOperations.push(() => this.unset(keyPath, options))\r\n    }\r\n\r\n    let {scopeSelector, source} = options != null ? options : {}\r\n    if (source == null) { source = this.mainSource }\r\n\r\n    if (scopeSelector != null) {\r\n      if (keyPath != null) {\r\n        let settings = this.scopedSettingsStore.propertiesForSourceAndSelector(source, scopeSelector)\r\n        if (getValueAtKeyPath(settings, keyPath) != null) {\r\n          this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n          setValueAtKeyPath(settings, keyPath, undefined)\r\n          settings = withoutEmptyObjects(settings)\r\n          if (settings != null) {\r\n            this.set(null, settings, {scopeSelector, source, priority: this.priorityForSource(source)})\r\n          }\r\n\r\n          const configIsReady = (source === this.mainSource) && this.settingsLoaded\r\n          if (configIsReady) {\r\n            return this.requestSave()\r\n          }\r\n        }\r\n      } else {\r\n        this.scopedSettingsStore.removePropertiesForSourceAndSelector(source, scopeSelector)\r\n        return this.emitChangeEvent()\r\n      }\r\n    } else {\r\n      for (scopeSelector in this.scopedSettingsStore.propertiesForSource(source)) {\r\n        this.unset(keyPath, {scopeSelector, source})\r\n      }\r\n      if ((keyPath != null) && (source === this.mainSource)) {\r\n        return this.set(keyPath, getValueAtKeyPath(this.defaultSettings, keyPath))\r\n      }\r\n    }\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.set",
            "start_line": 687,
            "end_line": 722,
            "comment": [
                " Essential: Sets the value for a configuration setting.",
                "",
                " This value is stored in Atom's internal configuration file.",
                "",
                " ### Examples",
                "",
                " You might want to change the themes programmatically:",
                "",
                " ```coffee",
                " atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])",
                " ```",
                "",
                " You can also set scoped settings. For example, you might want change the",
                " `editor.tabLength` only for ruby files.",
                "",
                " ```coffee",
                " atom.config.get('editor.tabLength') # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",
                "",
                " # Set ruby to 2",
                " atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true",
                "",
                " # Notice it's only set to 2 in the case of ruby",
                " atom.config.get('editor.tabLength') # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2",
                " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",
                " ```",
                "",
                " * `keyPath` The {String} name of the key.",
                " * `value` The value of the setting. Passing `undefined` will revert the",
                "   setting to the default value.",
                " * `options` (optional) {Object}",
                "   * `scopeSelector` (optional) {String}. eg. '.source.ruby'",
                "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)",
                "     for more information.",
                "   * `source` (optional) {String} The name of a file with which the setting",
                "     is associated. Defaults to the user's config file.",
                "",
                " Returns a {Boolean}",
                " * `true` if the value was set.",
                " * `false` if the value was not able to be coerced to the type specified in the setting's schema."
            ],
            "params": [
                {
                    "name": "args",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "set",
            "line": 883,
            "func_location": "Config.unshiftAtKeyPath",
            "func_start_line": 879,
            "func_end_line": 885,
            "args": [
                "keyPath",
                "arrayValue"
            ],
            "code": "  unshiftAtKeyPath (keyPath, value) {\r\n    const left = this.get(keyPath)\r\n    const arrayValue = (left == null ? [] : left)\r\n    const result = arrayValue.unshift(value)\r\n    this.set(keyPath, arrayValue)\r\n    return result\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/config.js",
            "name": "Config.set",
            "start_line": 687,
            "end_line": 722,
            "comment": [
                " Essential: Sets the value for a configuration setting.",
                "",
                " This value is stored in Atom's internal configuration file.",
                "",
                " ### Examples",
                "",
                " You might want to change the themes programmatically:",
                "",
                " ```coffee",
                " atom.config.set('core.themes', ['atom-light-ui', 'atom-light-syntax'])",
                " ```",
                "",
                " You can also set scoped settings. For example, you might want change the",
                " `editor.tabLength` only for ruby files.",
                "",
                " ```coffee",
                " atom.config.get('editor.tabLength') # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",
                "",
                " # Set ruby to 2",
                " atom.config.set('editor.tabLength', 2, scopeSelector: '.source.ruby') # => true",
                "",
                " # Notice it's only set to 2 in the case of ruby",
                " atom.config.get('editor.tabLength') # => 4",
                " atom.config.get('editor.tabLength', scope: ['source.ruby']) # => 2",
                " atom.config.get('editor.tabLength', scope: ['source.js']) # => 4",
                " ```",
                "",
                " * `keyPath` The {String} name of the key.",
                " * `value` The value of the setting. Passing `undefined` will revert the",
                "   setting to the default value.",
                " * `options` (optional) {Object}",
                "   * `scopeSelector` (optional) {String}. eg. '.source.ruby'",
                "     See [the scopes docs](http://flight-manual.atom.io/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/)",
                "     for more information.",
                "   * `source` (optional) {String} The name of a file with which the setting",
                "     is associated. Defaults to the user's config file.",
                "",
                " Returns a {Boolean}",
                " * `true` if the value was set.",
                " * `false` if the value was not able to be coerced to the type specified in the setting's schema."
            ],
            "params": [
                {
                    "name": "args",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/pane-axis.js",
            "name": "remove",
            "line": 188,
            "func_location": "PaneAxis.unsubscribeFromChild",
            "func_start_line": 186,
            "func_end_line": 190,
            "args": [
                "subscription"
            ],
            "code": "  unsubscribeFromChild (child) {\r\n    const subscription = this.subscriptionsByChild.get(child)\r\n    this.subscriptions.remove(subscription)\r\n    subscription.dispose()\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "translateTemplate",
            "line": 26,
            "func_location": "ApplicationMenu.update",
            "func_start_line": 25,
            "func_end_line": 30,
            "args": [
                {
                    "name": "template",
                    "type": [
                        "object"
                    ]
                },
                {
                    "name": "keystrokesByCommand",
                    "type": [
                        "object"
                    ]
                }
            ],
            "comment": [
                " Public: Updates the entire menu with the given keybindings.",
                "",
                " window - The BrowserWindow this menu template is associated with.",
                " template - The Object which describes the menu to display.",
                " keystrokesByCommand - An Object where the keys are commands and the values",
                "                       are Arrays containing the keystroke."
            ],
            "code": "  update (window, template, keystrokesByCommand) {\r\n    this.translateTemplate(template, keystrokesByCommand)\r\n    this.substituteVersion(template)\r\n    this.windowTemplates.set(window, template)\r\n    if (window === this.lastFocusedWindow) return this.setActiveTemplate(template)\r\n  }\r",
            "return_type": [
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "ApplicationMenu.translateTemplate",
            "start_line": 198,
            "end_line": 211,
            "comment": [
                " Combines a menu template with the appropriate keystroke.",
                "",
                " template - An Object conforming to atom-shell's menu api but lacking",
                "            accelerator and click properties.",
                " keystrokesByCommand - An Object where the keys are commands and the values",
                "                       are Arrays containing the keystroke.",
                "",
                " Returns a complete menu configuration object for atom-shell's menu API."
            ],
            "params": [
                {
                    "name": "template",
                    "type": [
                        "object"
                    ]
                },
                {
                    "name": "keystrokesByCommand",
                    "type": [
                        "object"
                    ]
                }
            ],
            "return_type": [
                "object"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "translateTemplate",
            "line": 26,
            "func_location": "ApplicationMenu.update",
            "func_start_line": 25,
            "func_end_line": 30,
            "args": [
                {
                    "name": "template",
                    "type": [
                        "object"
                    ]
                },
                {
                    "name": "keystrokesByCommand",
                    "type": [
                        "object"
                    ]
                }
            ],
            "comment": [
                " Public: Updates the entire menu with the given keybindings.",
                "",
                " window - The BrowserWindow this menu template is associated with.",
                " template - The Object which describes the menu to display.",
                " keystrokesByCommand - An Object where the keys are commands and the values",
                "                       are Arrays containing the keystroke."
            ],
            "code": "  update (window, template, keystrokesByCommand) {\r\n    this.translateTemplate(template, keystrokesByCommand)\r\n    this.substituteVersion(template)\r\n    this.windowTemplates.set(window, template)\r\n    if (window === this.lastFocusedWindow) return this.setActiveTemplate(template)\r\n  }\r",
            "return_type": [
                "object"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "ApplicationMenu.translateTemplate",
            "start_line": 198,
            "end_line": 211,
            "comment": [
                " Combines a menu template with the appropriate keystroke.",
                "",
                " template - An Object conforming to atom-shell's menu api but lacking",
                "            accelerator and click properties.",
                " keystrokesByCommand - An Object where the keys are commands and the values",
                "                       are Arrays containing the keystroke.",
                "",
                " Returns a complete menu configuration object for atom-shell's menu API."
            ],
            "params": [
                {
                    "name": "template",
                    "type": [
                        "object"
                    ]
                },
                {
                    "name": "keystrokesByCommand",
                    "type": [
                        "object"
                    ]
                }
            ],
            "return_type": [
                "object"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "substituteVersion",
            "line": 27,
            "func_location": "ApplicationMenu.update",
            "func_start_line": 25,
            "func_end_line": 30,
            "args": [
                {
                    "name": "template",
                    "type": [
                        "object"
                    ]
                }
            ],
            "comment": [
                " Public: Updates the entire menu with the given keybindings.",
                "",
                " window - The BrowserWindow this menu template is associated with.",
                " template - The Object which describes the menu to display.",
                " keystrokesByCommand - An Object where the keys are commands and the values",
                "                       are Arrays containing the keystroke."
            ],
            "code": "  update (window, template, keystrokesByCommand) {\r\n    this.translateTemplate(template, keystrokesByCommand)\r\n    this.substituteVersion(template)\r\n    this.windowTemplates.set(window, template)\r\n    if (window === this.lastFocusedWindow) return this.setActiveTemplate(template)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "ApplicationMenu.substituteVersion",
            "start_line": 103,
            "end_line": 106,
            "comment": [
                " Replaces VERSION with the current version."
            ],
            "params": [
                {
                    "name": "template",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "substituteVersion",
            "line": 27,
            "func_location": "ApplicationMenu.update",
            "func_start_line": 25,
            "func_end_line": 30,
            "args": [
                {
                    "name": "template",
                    "type": [
                        "object"
                    ]
                }
            ],
            "comment": [
                " Public: Updates the entire menu with the given keybindings.",
                "",
                " window - The BrowserWindow this menu template is associated with.",
                " template - The Object which describes the menu to display.",
                " keystrokesByCommand - An Object where the keys are commands and the values",
                "                       are Arrays containing the keystroke."
            ],
            "code": "  update (window, template, keystrokesByCommand) {\r\n    this.translateTemplate(template, keystrokesByCommand)\r\n    this.substituteVersion(template)\r\n    this.windowTemplates.set(window, template)\r\n    if (window === this.lastFocusedWindow) return this.setActiveTemplate(template)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "ApplicationMenu.substituteVersion",
            "start_line": 103,
            "end_line": 106,
            "comment": [
                " Replaces VERSION with the current version."
            ],
            "params": [
                {
                    "name": "template",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "setActiveTemplate",
            "line": 29,
            "func_location": "ApplicationMenu.update",
            "func_start_line": 25,
            "func_end_line": 30,
            "args": [
                {
                    "name": "template",
                    "type": [
                        "object"
                    ]
                }
            ],
            "comment": [
                " Public: Updates the entire menu with the given keybindings.",
                "",
                " window - The BrowserWindow this menu template is associated with.",
                " template - The Object which describes the menu to display.",
                " keystrokesByCommand - An Object where the keys are commands and the values",
                "                       are Arrays containing the keystroke."
            ],
            "code": "  update (window, template, keystrokesByCommand) {\r\n    this.translateTemplate(template, keystrokesByCommand)\r\n    this.substituteVersion(template)\r\n    this.windowTemplates.set(window, template)\r\n    if (window === this.lastFocusedWindow) return this.setActiveTemplate(template)\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/main-process/application-menu.js",
            "name": "ApplicationMenu.setActiveTemplate",
            "start_line": 32,
            "end_line": 40,
            "comment": [],
            "params": [
                "template"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "remove",
            "line": 4318,
            "func_location": "OverlayComponent.update",
            "func_start_line": 4312,
            "func_end_line": 4323,
            "args": [
                "oldProps.className"
            ],
            "code": "  update (newProps) {\r\n    const oldProps = this.props\r\n    this.props = Object.assign({}, oldProps, newProps)\r\n    if (this.props.pixelTop != null) this.element.style.top = this.props.pixelTop + 'px'\r\n    if (this.props.pixelLeft != null) this.element.style.left = this.props.pixelLeft + 'px'\r\n    if (newProps.className !== oldProps.className) {\r\n      if (oldProps.className != null) this.element.classList.remove(oldProps.className)\r\n      if (newProps.className != null) this.element.classList.add(newProps.className)\r\n    }\r\n\r\n    if (this.resolveNextUpdatePromise) this.resolveNextUpdatePromise()\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "remove",
            "line": 3435,
            "func_location": "LineNumberComponent.update",
            "func_start_line": 3411,
            "func_end_line": 3445,
            "args": [],
            "code": "  update (props) {\r\n    const {nodePool, className, width, marginTop, bufferRow, screenRow, number} = props\r\n\r\n    if (this.props.bufferRow !== bufferRow) this.element.dataset.bufferRow = bufferRow\r\n    if (this.props.screenRow !== screenRow) this.element.dataset.screenRow = screenRow\r\n    if (this.props.className !== className) this.element.className = className\r\n    if (this.props.width !== width) {\r\n      if (width != null && width > 0) {\r\n        this.element.style.width = width + 'px'\r\n      } else {\r\n        this.element.style.width = ''\r\n      }\r\n    }\r\n    if (this.props.marginTop !== marginTop) {\r\n      if (marginTop != null && marginTop > 0) {\r\n        this.element.style.marginTop = marginTop + 'px'\r\n      } else {\r\n        this.element.style.marginTop = ''\r\n      }\r\n    }\r\n\r\n    if (this.props.number !== number) {\r\n      if (this.props.number != null) {\r\n        const numberNode = this.element.firstChild\r\n        numberNode.remove()\r\n        nodePool.release(numberNode)\r\n      }\r\n\r\n      if (number != null) {\r\n        this.element.insertBefore(nodePool.getTextNode(number), this.element.firstChild)\r\n      }\r\n    }\r\n\r\n    this.props = props\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "remove",
            "line": 3959,
            "func_location": "LineComponent.update",
            "func_start_line": 3946,
            "func_end_line": 3962,
            "args": [],
            "code": "  update (newProps) {\r\n    if (this.props.lineDecoration !== newProps.lineDecoration) {\r\n      this.props.lineDecoration = newProps.lineDecoration\r\n      this.element.className = this.buildClassName()\r\n    }\r\n\r\n    if (this.props.screenRow !== newProps.screenRow) {\r\n      this.props.screenRow = newProps.screenRow\r\n      this.element.dataset.screenRow = newProps.screenRow\r\n    }\r\n\r\n    if (!textDecorationsEqual(this.props.textDecorations, newProps.textDecorations)) {\r\n      this.props.textDecorations = newProps.textDecorations\r\n      this.element.firstChild.remove()\r\n      this.appendContents()\r\n    }\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "remove",
            "line": 3530,
            "func_location": "CustomGutterDecorationComponent.update",
            "func_start_line": 3519,
            "func_end_line": 3536,
            "args": [],
            "code": "  update (newProps) {\r\n    const oldProps = this.props\r\n    this.props = newProps\r\n\r\n    if (newProps.top !== oldProps.top) this.element.style.top = newProps.top + 'px'\r\n    if (newProps.height !== oldProps.height) {\r\n      this.element.style.height = newProps.height + 'px'\r\n      if (newProps.element) newProps.element.style.height = newProps.height + 'px'\r\n    }\r\n    if (newProps.className !== oldProps.className) this.element.className = newProps.className || ''\r\n    if (newProps.element !== oldProps.element) {\r\n      if (this.element.firstChild) this.element.firstChild.remove()\r\n      if (newProps.element != null) {\r\n        this.element.appendChild(newProps.element)\r\n        newProps.element.style.height = newProps.height + 'px'\r\n      }\r\n    }\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "remove",
            "line": 847,
            "func_location": "TextEditorComponent.updateClassList",
            "func_start_line": 829,
            "func_end_line": 857,
            "args": [
                {
                    "name": "className",
                    "type": []
                }
            ],
            "comment": [
                " Imperatively manipulate the class list of the root element to avoid",
                " clearing classes assigned by package authors."
            ],
            "code": "  updateClassList () {\r\n    const {model} = this.props\r\n\r\n    const oldClassList = this.classList\r\n    const newClassList = ['editor']\r\n    if (this.focused) newClassList.push('is-focused')\r\n    if (model.isMini()) newClassList.push('mini')\r\n    for (var i = 0; i < model.selections.length; i++) {\r\n      if (!model.selections[i].isEmpty()) {\r\n        newClassList.push('has-selection')\r\n        break\r\n      }\r\n    }\r\n\r\n    if (oldClassList) {\r\n      for (let i = 0; i < oldClassList.length; i++) {\r\n        const className = oldClassList[i]\r\n        if (!newClassList.includes(className)) {\r\n          this.element.classList.remove(className)\r\n        }\r\n      }\r\n    }\r\n\r\n    for (let i = 0; i < newClassList.length; i++) {\r\n      this.element.classList.add(newClassList[i])\r\n    }\r\n\r\n    this.classList = newClassList\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "remove",
            "line": 847,
            "func_location": "TextEditorComponent.updateClassList",
            "func_start_line": 829,
            "func_end_line": 857,
            "args": [
                {
                    "name": "className",
                    "type": []
                }
            ],
            "comment": [
                " Imperatively manipulate the class list of the root element to avoid",
                " clearing classes assigned by package authors."
            ],
            "code": "  updateClassList () {\r\n    const {model} = this.props\r\n\r\n    const oldClassList = this.classList\r\n    const newClassList = ['editor']\r\n    if (this.focused) newClassList.push('is-focused')\r\n    if (model.isMini()) newClassList.push('mini')\r\n    for (var i = 0; i < model.selections.length; i++) {\r\n      if (!model.selections[i].isEmpty()) {\r\n        newClassList.push('has-selection')\r\n        break\r\n      }\r\n    }\r\n\r\n    if (oldClassList) {\r\n      for (let i = 0; i < oldClassList.length; i++) {\r\n        const className = oldClassList[i]\r\n        if (!newClassList.includes(className)) {\r\n          this.element.classList.remove(className)\r\n        }\r\n      }\r\n    }\r\n\r\n    for (let i = 0; i < newClassList.length; i++) {\r\n      this.element.classList.add(newClassList[i])\r\n    }\r\n\r\n    this.classList = newClassList\r\n  }\r",
            "return_type": [
                "boolean"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-registry.js",
            "name": "TextEditorRegistry.remove",
            "start_line": 122,
            "end_line": 126,
            "comment": [
                " Remove a `TextEditor`.",
                "",
                " * `editor` The editor to remove.",
                "",
                " Returns a {Boolean} indicating whether the editor was successfully removed."
            ],
            "params": [
                {
                    "name": "editor",
                    "type": []
                }
            ],
            "return_type": [
                "boolean"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/workspace-element.js",
            "name": "pointWithinHoverArea",
            "line": 196,
            "func_location": "WorkspaceElement.updateHoveredDock",
            "func_start_line": 194,
            "func_end_line": 202,
            "args": [
                "mousePosition",
                {
                    "type": "boolean"
                }
            ],
            "code": "  updateHoveredDock (mousePosition) {\r\n    // If we haven't left the currently hovered dock, don't change anything.\r\n    if (this.hoveredDock && this.hoveredDock.pointWithinHoverArea(mousePosition, true)) return\r\n\r\n    const docks = [this.model.getLeftDock(), this.model.getRightDock(), this.model.getBottomDock()]\r\n    const nextHoveredDock =\r\n      docks.find(dock => dock !== this.hoveredDock && dock.pointWithinHoverArea(mousePosition))\r\n    docks.forEach(dock => { dock.setHovered(dock === nextHoveredDock) })\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/dock.js",
            "name": "Dock.pointWithinHoverArea",
            "start_line": 333,
            "end_line": 405,
            "comment": [
                " Determine whether the cursor is within the dock hover area. This isn't as simple as just using",
                " mouseenter/leave because we want to be a little more forgiving. For example, if the cursor is",
                " over the footer, we want to show the bottom dock's toggle button. Also note that our criteria",
                " for detecting entry are different than detecting exit but, in order for us to avoid jitter, the",
                " area considered when detecting exit MUST fully encompass the area considered when detecting",
                " entry."
            ],
            "params": [
                {
                    "name": "point",
                    "type": []
                },
                {
                    "name": "detectingExit",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "setEditorWidthInChars",
            "line": 2128,
            "func_location": "TextEditorComponent.updateModelSoftWrapColumn",
            "func_start_line": 2121,
            "func_end_line": 2145,
            "args": [
                {
                    "name": "newEditorWidthInChars",
                    "type": []
                }
            ],
            "comment": [
                " This method is called at the beginning of a frame render to relay any",
                " potential changes in the editor's width into the model before proceeding."
            ],
            "code": "  updateModelSoftWrapColumn () {\r\n    const {model} = this.props\r\n    const newEditorWidthInChars = this.getScrollContainerClientWidthInBaseCharacters()\r\n    if (newEditorWidthInChars !== model.getEditorWidthInChars()) {\r\n      this.suppressUpdates = true\r\n\r\n      const renderedStartRow = this.getRenderedStartRow()\r\n      this.props.model.setEditorWidthInChars(newEditorWidthInChars)\r\n\r\n      // Relaying a change in to the editor's client width may cause the\r\n      // vertical scrollbar to appear or disappear, which causes the editor's\r\n      // client width to change *again*. Make sure the display layer is fully\r\n      // populated for the visible area before recalculating the editor's\r\n      // width in characters. Then update the display layer *again* just in\r\n      // case a change in scrollbar visibility causes lines to wrap\r\n      // differently. We capture the renderedStartRow before resetting the\r\n      // display layer because once it has been reset, we can't compute the\r\n      // rendered start row accurately. 😥\r\n      this.populateVisibleRowRange(renderedStartRow)\r\n      this.props.model.setEditorWidthInChars(this.getScrollContainerClientWidthInBaseCharacters())\r\n      this.derivedDimensionsCache = {}\r\n\r\n      this.suppressUpdates = false\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.setEditorWidthInChars",
            "start_line": 1068,
            "end_line": 1068,
            "comment": [
                " Set the number of characters that can be displayed horizontally in the",
                " editor.",
                "",
                " * `editorWidthInChars` A {Number} representing the width of the",
                " {TextEditorElement} in characters."
            ],
            "params": [
                {
                    "name": "editorWidthInChars",
                    "type": [
                        "number"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "setEditorWidthInChars",
            "line": 2128,
            "func_location": "TextEditorComponent.updateModelSoftWrapColumn",
            "func_start_line": 2121,
            "func_end_line": 2145,
            "args": [
                {
                    "name": "newEditorWidthInChars",
                    "type": []
                }
            ],
            "comment": [
                " This method is called at the beginning of a frame render to relay any",
                " potential changes in the editor's width into the model before proceeding."
            ],
            "code": "  updateModelSoftWrapColumn () {\r\n    const {model} = this.props\r\n    const newEditorWidthInChars = this.getScrollContainerClientWidthInBaseCharacters()\r\n    if (newEditorWidthInChars !== model.getEditorWidthInChars()) {\r\n      this.suppressUpdates = true\r\n\r\n      const renderedStartRow = this.getRenderedStartRow()\r\n      this.props.model.setEditorWidthInChars(newEditorWidthInChars)\r\n\r\n      // Relaying a change in to the editor's client width may cause the\r\n      // vertical scrollbar to appear or disappear, which causes the editor's\r\n      // client width to change *again*. Make sure the display layer is fully\r\n      // populated for the visible area before recalculating the editor's\r\n      // width in characters. Then update the display layer *again* just in\r\n      // case a change in scrollbar visibility causes lines to wrap\r\n      // differently. We capture the renderedStartRow before resetting the\r\n      // display layer because once it has been reset, we can't compute the\r\n      // rendered start row accurately. 😥\r\n      this.populateVisibleRowRange(renderedStartRow)\r\n      this.props.model.setEditorWidthInChars(this.getScrollContainerClientWidthInBaseCharacters())\r\n      this.derivedDimensionsCache = {}\r\n\r\n      this.suppressUpdates = false\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.setEditorWidthInChars",
            "start_line": 1068,
            "end_line": 1068,
            "comment": [
                " Set the number of characters that can be displayed horizontally in the",
                " editor.",
                "",
                " * `editorWidthInChars` A {Number} representing the width of the",
                " {TextEditorElement} in characters."
            ],
            "params": [
                {
                    "name": "editorWidthInChars",
                    "type": [
                        "number"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "populateVisibleRowRange",
            "line": 2139,
            "func_location": "TextEditorComponent.updateModelSoftWrapColumn",
            "func_start_line": 2121,
            "func_end_line": 2145,
            "args": [
                {
                    "name": "renderedStartRow",
                    "type": []
                }
            ],
            "comment": [
                " This method is called at the beginning of a frame render to relay any",
                " potential changes in the editor's width into the model before proceeding."
            ],
            "code": "  updateModelSoftWrapColumn () {\r\n    const {model} = this.props\r\n    const newEditorWidthInChars = this.getScrollContainerClientWidthInBaseCharacters()\r\n    if (newEditorWidthInChars !== model.getEditorWidthInChars()) {\r\n      this.suppressUpdates = true\r\n\r\n      const renderedStartRow = this.getRenderedStartRow()\r\n      this.props.model.setEditorWidthInChars(newEditorWidthInChars)\r\n\r\n      // Relaying a change in to the editor's client width may cause the\r\n      // vertical scrollbar to appear or disappear, which causes the editor's\r\n      // client width to change *again*. Make sure the display layer is fully\r\n      // populated for the visible area before recalculating the editor's\r\n      // width in characters. Then update the display layer *again* just in\r\n      // case a change in scrollbar visibility causes lines to wrap\r\n      // differently. We capture the renderedStartRow before resetting the\r\n      // display layer because once it has been reset, we can't compute the\r\n      // rendered start row accurately. 😥\r\n      this.populateVisibleRowRange(renderedStartRow)\r\n      this.props.model.setEditorWidthInChars(this.getScrollContainerClientWidthInBaseCharacters())\r\n      this.derivedDimensionsCache = {}\r\n\r\n      this.suppressUpdates = false\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "TextEditorComponent.populateVisibleRowRange",
            "start_line": 2896,
            "end_line": 2908,
            "comment": [
                " Ensure the spatial index is populated with rows that are currently visible"
            ],
            "params": [
                {
                    "name": "renderedStartRow",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "populateVisibleRowRange",
            "line": 2139,
            "func_location": "TextEditorComponent.updateModelSoftWrapColumn",
            "func_start_line": 2121,
            "func_end_line": 2145,
            "args": [
                {
                    "name": "renderedStartRow",
                    "type": []
                }
            ],
            "comment": [
                " This method is called at the beginning of a frame render to relay any",
                " potential changes in the editor's width into the model before proceeding."
            ],
            "code": "  updateModelSoftWrapColumn () {\r\n    const {model} = this.props\r\n    const newEditorWidthInChars = this.getScrollContainerClientWidthInBaseCharacters()\r\n    if (newEditorWidthInChars !== model.getEditorWidthInChars()) {\r\n      this.suppressUpdates = true\r\n\r\n      const renderedStartRow = this.getRenderedStartRow()\r\n      this.props.model.setEditorWidthInChars(newEditorWidthInChars)\r\n\r\n      // Relaying a change in to the editor's client width may cause the\r\n      // vertical scrollbar to appear or disappear, which causes the editor's\r\n      // client width to change *again*. Make sure the display layer is fully\r\n      // populated for the visible area before recalculating the editor's\r\n      // width in characters. Then update the display layer *again* just in\r\n      // case a change in scrollbar visibility causes lines to wrap\r\n      // differently. We capture the renderedStartRow before resetting the\r\n      // display layer because once it has been reset, we can't compute the\r\n      // rendered start row accurately. 😥\r\n      this.populateVisibleRowRange(renderedStartRow)\r\n      this.props.model.setEditorWidthInChars(this.getScrollContainerClientWidthInBaseCharacters())\r\n      this.derivedDimensionsCache = {}\r\n\r\n      this.suppressUpdates = false\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "TextEditorComponent.populateVisibleRowRange",
            "start_line": 2896,
            "end_line": 2908,
            "comment": [
                " Ensure the spatial index is populated with rows that are currently visible"
            ],
            "params": [
                {
                    "name": "renderedStartRow",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "setEditorWidthInChars",
            "line": 2140,
            "func_location": "TextEditorComponent.updateModelSoftWrapColumn",
            "func_start_line": 2121,
            "func_end_line": 2145,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " This method is called at the beginning of a frame render to relay any",
                " potential changes in the editor's width into the model before proceeding."
            ],
            "code": "  updateModelSoftWrapColumn () {\r\n    const {model} = this.props\r\n    const newEditorWidthInChars = this.getScrollContainerClientWidthInBaseCharacters()\r\n    if (newEditorWidthInChars !== model.getEditorWidthInChars()) {\r\n      this.suppressUpdates = true\r\n\r\n      const renderedStartRow = this.getRenderedStartRow()\r\n      this.props.model.setEditorWidthInChars(newEditorWidthInChars)\r\n\r\n      // Relaying a change in to the editor's client width may cause the\r\n      // vertical scrollbar to appear or disappear, which causes the editor's\r\n      // client width to change *again*. Make sure the display layer is fully\r\n      // populated for the visible area before recalculating the editor's\r\n      // width in characters. Then update the display layer *again* just in\r\n      // case a change in scrollbar visibility causes lines to wrap\r\n      // differently. We capture the renderedStartRow before resetting the\r\n      // display layer because once it has been reset, we can't compute the\r\n      // rendered start row accurately. 😥\r\n      this.populateVisibleRowRange(renderedStartRow)\r\n      this.props.model.setEditorWidthInChars(this.getScrollContainerClientWidthInBaseCharacters())\r\n      this.derivedDimensionsCache = {}\r\n\r\n      this.suppressUpdates = false\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.setEditorWidthInChars",
            "start_line": 1068,
            "end_line": 1068,
            "comment": [
                " Set the number of characters that can be displayed horizontally in the",
                " editor.",
                "",
                " * `editorWidthInChars` A {Number} representing the width of the",
                " {TextEditorElement} in characters."
            ],
            "params": [
                {
                    "name": "editorWidthInChars",
                    "type": [
                        "number"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "setEditorWidthInChars",
            "line": 2140,
            "func_location": "TextEditorComponent.updateModelSoftWrapColumn",
            "func_start_line": 2121,
            "func_end_line": 2145,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " This method is called at the beginning of a frame render to relay any",
                " potential changes in the editor's width into the model before proceeding."
            ],
            "code": "  updateModelSoftWrapColumn () {\r\n    const {model} = this.props\r\n    const newEditorWidthInChars = this.getScrollContainerClientWidthInBaseCharacters()\r\n    if (newEditorWidthInChars !== model.getEditorWidthInChars()) {\r\n      this.suppressUpdates = true\r\n\r\n      const renderedStartRow = this.getRenderedStartRow()\r\n      this.props.model.setEditorWidthInChars(newEditorWidthInChars)\r\n\r\n      // Relaying a change in to the editor's client width may cause the\r\n      // vertical scrollbar to appear or disappear, which causes the editor's\r\n      // client width to change *again*. Make sure the display layer is fully\r\n      // populated for the visible area before recalculating the editor's\r\n      // width in characters. Then update the display layer *again* just in\r\n      // case a change in scrollbar visibility causes lines to wrap\r\n      // differently. We capture the renderedStartRow before resetting the\r\n      // display layer because once it has been reset, we can't compute the\r\n      // rendered start row accurately. 😥\r\n      this.populateVisibleRowRange(renderedStartRow)\r\n      this.props.model.setEditorWidthInChars(this.getScrollContainerClientWidthInBaseCharacters())\r\n      this.derivedDimensionsCache = {}\r\n\r\n      this.suppressUpdates = false\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor.js",
            "name": "TextEditor.setEditorWidthInChars",
            "start_line": 1068,
            "end_line": 1068,
            "comment": [
                " Set the number of characters that can be displayed horizontally in the",
                " editor.",
                "",
                " * `editorWidthInChars` A {Number} representing the width of the",
                " {TextEditorElement} in characters."
            ],
            "params": [
                {
                    "name": "editorWidthInChars",
                    "type": [
                        "number"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "getScrollContainerClientWidthInBaseCharacters",
            "line": 2140,
            "func_location": "TextEditorComponent.updateModelSoftWrapColumn",
            "func_start_line": 2121,
            "func_end_line": 2145,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                " This method is called at the beginning of a frame render to relay any",
                " potential changes in the editor's width into the model before proceeding."
            ],
            "code": "  updateModelSoftWrapColumn () {\r\n    const {model} = this.props\r\n    const newEditorWidthInChars = this.getScrollContainerClientWidthInBaseCharacters()\r\n    if (newEditorWidthInChars !== model.getEditorWidthInChars()) {\r\n      this.suppressUpdates = true\r\n\r\n      const renderedStartRow = this.getRenderedStartRow()\r\n      this.props.model.setEditorWidthInChars(newEditorWidthInChars)\r\n\r\n      // Relaying a change in to the editor's client width may cause the\r\n      // vertical scrollbar to appear or disappear, which causes the editor's\r\n      // client width to change *again*. Make sure the display layer is fully\r\n      // populated for the visible area before recalculating the editor's\r\n      // width in characters. Then update the display layer *again* just in\r\n      // case a change in scrollbar visibility causes lines to wrap\r\n      // differently. We capture the renderedStartRow before resetting the\r\n      // display layer because once it has been reset, we can't compute the\r\n      // rendered start row accurately. 😥\r\n      this.populateVisibleRowRange(renderedStartRow)\r\n      this.props.model.setEditorWidthInChars(this.getScrollContainerClientWidthInBaseCharacters())\r\n      this.derivedDimensionsCache = {}\r\n\r\n      this.suppressUpdates = false\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "TextEditorComponent.getScrollContainerClientWidthInBaseCharacters",
            "start_line": 2692,
            "end_line": 2694,
            "comment": [],
            "params": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "populateVisibleRowRange",
            "line": 374,
            "func_location": "TextEditorComponent.updateSyncBeforeMeasuringContent",
            "func_start_line": 364,
            "func_end_line": 387,
            "args": [
                null
            ],
            "code": "  updateSyncBeforeMeasuringContent () {\r\n    this.measuredContent = false\r\n    this.derivedDimensionsCache = {}\r\n    this.updateModelSoftWrapColumn()\r\n    if (this.pendingAutoscroll) {\r\n      let {screenRange, options} = this.pendingAutoscroll\r\n      this.autoscrollVertically(screenRange, options)\r\n      this.requestHorizontalMeasurement(screenRange.start.row, screenRange.start.column)\r\n      this.requestHorizontalMeasurement(screenRange.end.row, screenRange.end.column)\r\n    }\r\n    this.populateVisibleRowRange(this.getRenderedStartRow())\r\n    this.populateVisibleTiles()\r\n    this.queryScreenLinesToRender()\r\n    this.queryLongestLine()\r\n    this.queryLineNumbersToRender()\r\n    this.queryGuttersToRender()\r\n    this.queryDecorationsToRender()\r\n    this.queryExtraScreenLinesToRender()\r\n    this.shouldRenderDummyScrollbars = !this.remeasureScrollbars\r\n    etch.updateSync(this)\r\n    this.updateClassList()\r\n    this.shouldRenderDummyScrollbars = true\r\n    this.didMeasureVisibleBlockDecoration = false\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/text-editor-component.js",
            "name": "TextEditorComponent.populateVisibleRowRange",
            "start_line": 2896,
            "end_line": 2908,
            "comment": [
                " Ensure the spatial index is populated with rows that are currently visible"
            ],
            "params": [
                {
                    "name": "renderedStartRow",
                    "type": []
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/style-manager.js",
            "name": "parse",
            "line": 198,
            "func_location": "StyleManager.upgradeDeprecatedSelectorsForStyleSheet",
            "func_start_line": 189,
            "func_end_line": 207,
            "args": [
                null
            ],
            "code": "  upgradeDeprecatedSelectorsForStyleSheet (styleSheet, context) {\r\n    if (this.cacheDirPath != null) {\r\n      const hash = crypto.createHash('sha1')\r\n      if (context != null) {\r\n        hash.update(context)\r\n      }\r\n      hash.update(styleSheet)\r\n      const cacheFilePath = path.join(this.cacheDirPath, hash.digest('hex'))\r\n      try {\r\n        return JSON.parse(fs.readFileSync(cacheFilePath))\r\n      } catch (e) {\r\n        const transformed = transformDeprecatedShadowDOMSelectors(styleSheet, context)\r\n        fs.writeFileSync(cacheFilePath, JSON.stringify(transformed))\r\n        return transformed\r\n      }\r\n    } else {\r\n      return transformDeprecatedShadowDOMSelectors(styleSheet, context)\r\n    }\r\n  }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/color.js",
            "name": "Color.parse",
            "start_line": 14,
            "end_line": 36,
            "comment": [
                " Essential: Parse a {String} or {Object} into a {Color}.",
                "",
                " * `value` A {String} such as `'white'`, `#ff00ff`, or",
                "   `'rgba(255, 15, 60, .75)'` or an {Object} with `red`, `green`, `blue`,",
                "   and `alpha` properties.",
                "",
                " Returns a {Color} or `null` if it cannot be parsed."
            ],
            "params": [
                {
                    "name": "value",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "null"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/initialize-benchmark-window.js",
            "name": "write",
            "line": 84,
            "func_location": "console.warn",
            "func_start_line": 82,
            "func_end_line": 85,
            "args": [
                null
            ],
            "code": "      console.warn = function (...args) {\r\n        const formatted = util.format(...args)\r\n        process.stderr.write(formatted + '\\n')\r\n      }\r"
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/clipboard.js",
            "name": "Clipboard.write",
            "start_line": 42,
            "end_line": 46,
            "comment": [
                " Public: Write the given text to the clipboard.",
                "",
                " The metadata associated with the text is available by calling",
                " {::readWithMetadata}.",
                "",
                " * `text` The {String} to store.",
                " * `metadata` (optional) The additional info to associate with the text."
            ],
            "params": [
                {
                    "name": "text",
                    "type": [
                        "string",
                        "optional"
                    ]
                },
                {
                    "name": "metadata",
                    "type": [
                        "optional"
                    ]
                }
            ],
            "return_type": []
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/theme-manager.js",
            "name": "warn",
            "line": 109,
            "func_location": "ThemeManager.warnForNonExistentThemes",
            "func_start_line": 104,
            "func_end_line": 112,
            "args": [
                {
                    "name": null,
                    "type": []
                }
            ],
            "comment": [
                "\r\n  Section: Managing Enabled Themes\r\n  "
            ],
            "code": "  warnForNonExistentThemes () {\r\n    let themeNames = this.config.get('core.themes') || []\r\n    if (!Array.isArray(themeNames)) { themeNames = [themeNames] }\r\n    for (let themeName of themeNames) {\r\n      if (!themeName || (typeof themeName !== 'string') || !this.packageManager.resolvePackagePath(themeName)) {\r\n        console.warn(`Enabled theme '${themeName}' is not installed.`)\r\n      }\r\n    }\r\n  }\r",
            "return_type": []
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/initialize-benchmark-window.js",
            "name": "console.warn",
            "start_line": 82,
            "end_line": 85,
            "comment": [],
            "params": [
                "args"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/clipboard.js",
            "name": "md5",
            "line": 43,
            "func_location": "Clipboard.write",
            "func_start_line": 42,
            "func_end_line": 46,
            "args": [
                {
                    "name": "text",
                    "type": [
                        "string",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Write the given text to the clipboard.",
                "",
                " The metadata associated with the text is available by calling",
                " {::readWithMetadata}.",
                "",
                " * `text` The {String} to store.",
                " * `metadata` (optional) The additional info to associate with the text."
            ],
            "code": "  write (text, metadata) {\r\n    this.signatureForMetadata = this.md5(text)\r\n    this.metadata = metadata\r\n    clipboard.writeText(text)\r\n  }\r",
            "return_type": [
                "string"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/clipboard.js",
            "name": "Clipboard.md5",
            "start_line": 31,
            "end_line": 33,
            "comment": [
                " Creates an `md5` hash of some text.",
                "",
                " * `text` A {String} to hash.",
                "",
                " Returns a hashed {String}."
            ],
            "params": [
                {
                    "name": "text",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "string"
            ]
        }
    },
    {
        "call_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/clipboard.js",
            "name": "md5",
            "line": 43,
            "func_location": "Clipboard.write",
            "func_start_line": 42,
            "func_end_line": 46,
            "args": [
                {
                    "name": "text",
                    "type": [
                        "string",
                        "optional"
                    ]
                }
            ],
            "comment": [
                " Public: Write the given text to the clipboard.",
                "",
                " The metadata associated with the text is available by calling",
                " {::readWithMetadata}.",
                "",
                " * `text` The {String} to store.",
                " * `metadata` (optional) The additional info to associate with the text."
            ],
            "code": "  write (text, metadata) {\r\n    this.signatureForMetadata = this.md5(text)\r\n    this.metadata = metadata\r\n    clipboard.writeText(text)\r\n  }\r",
            "return_type": [
                "string"
            ]
        },
        "func_info": {
            "file": "E:/research/parameterMismatch/parametermismatch/dataset/atom/src/clipboard.js",
            "name": "Clipboard.md5",
            "start_line": 31,
            "end_line": 33,
            "comment": [
                " Creates an `md5` hash of some text.",
                "",
                " * `text` A {String} to hash.",
                "",
                " Returns a hashed {String}."
            ],
            "params": [
                {
                    "name": "text",
                    "type": [
                        "string"
                    ]
                }
            ],
            "return_type": [
                "string"
            ]
        }
    }
]